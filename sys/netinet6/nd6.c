begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$KAME: nd6.c,v 1.144 2001/05/24 07:44:00 itojun Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/iso88025.h>
end_include

begin_include
include|#
directive|include
file|<net/fddi.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_kdtrace.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llatbl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/scope6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_ifattach.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/send.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_define
define|#
directive|define
name|ND6_SLOWTIMER_INTERVAL
value|(60 * 60)
end_define

begin_comment
comment|/* 1 hour */
end_comment

begin_define
define|#
directive|define
name|ND6_RECALC_REACHTM_INTERVAL
value|(60 * 120)
end_define

begin_comment
comment|/* 2 hours */
end_comment

begin_define
define|#
directive|define
name|SIN6
parameter_list|(
name|s
parameter_list|)
value|((const struct sockaddr_in6 *)(s))
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IP6NDP
argument_list|,
literal|"ip6ndp"
argument_list|,
literal|"IPv6 Neighbor Discovery"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* timer values */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_prune
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* walk list every 1 seconds */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_delay
argument_list|)
operator|=
literal|5
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* delay first probe time 5 second */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_umaxtries
argument_list|)
operator|=
literal|3
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* maximum unicast query */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_mmaxtries
argument_list|)
operator|=
literal|3
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* maximum multicast query */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_useloopback
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* use loopback interface for 					 * local traffic */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_gctimer
argument_list|)
operator|=
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 1 day: garbage 					 * collection timer */
end_comment

begin_comment
comment|/* preventing too many loops in ND option parsing */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_maxndopt
argument_list|)
operator|=
literal|10
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* max # of ND options allowed */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_maxnudhint
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* max # of subsequent upper 					 * layer hints */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_maxqueuelen
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* max pkts cached in unresolved 					 * ND entries */
end_comment

begin_define
define|#
directive|define
name|V_nd6_maxndopt
value|VNET(nd6_maxndopt)
end_define

begin_define
define|#
directive|define
name|V_nd6_maxqueuelen
value|VNET(nd6_maxqueuelen)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ND6_DEBUG
end_ifdef

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_debug
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_debug
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|lle_event_eh
decl_stmt|,
name|iflladdr_event_eh
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|nd_drhead
argument_list|,
name|nd_defrouter
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|nd_prhead
argument_list|,
name|nd_prefix
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|rwlock
argument_list|,
name|nd6_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|uint64_t
argument_list|,
name|nd6_list_genid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|mtx
argument_list|,
name|nd6_onlink_mtx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_recalc_reachtm_interval
argument_list|)
operator|=
name|ND6_RECALC_REACHTM_INTERVAL
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_nd6_recalc_reachtm_interval
value|VNET(nd6_recalc_reachtm_interval)
end_define

begin_function_decl
name|int
function_decl|(
modifier|*
name|send_sendso_input_hook
function_decl|)
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nd6_is_new_addr_neighbor
parameter_list|(
specifier|const
name|struct
name|sockaddr_in6
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nd6_setmtu0
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|nd_ifinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nd6_slowtimo
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|regen_tmpaddr
parameter_list|(
name|struct
name|in6_ifaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nd6_free
parameter_list|(
name|struct
name|llentry
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nd6_free_redirect
parameter_list|(
specifier|const
name|struct
name|llentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nd6_llinfo_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nd6_llinfo_settimer_locked
parameter_list|(
name|struct
name|llentry
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_llinfo_pqueue
parameter_list|(
name|struct
name|llentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nd6_rtrequest
parameter_list|(
name|int
parameter_list|,
name|struct
name|rtentry
modifier|*
parameter_list|,
name|struct
name|rt_addrinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nd6_resolve_slow
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sockaddr_in6
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|,
name|struct
name|llentry
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nd6_need_cache
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|callout
argument_list|,
name|nd6_slowtimo_ch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_nd6_slowtimo_ch
value|VNET(nd6_slowtimo_ch)
end_define

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|callout
argument_list|,
name|nd6_timer_ch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_nd6_timer_ch
value|VNET(nd6_timer_ch)
end_define

begin_function
specifier|static
name|void
name|nd6_lle_event
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|llentry
modifier|*
name|lle
parameter_list|,
name|int
name|evt
parameter_list|)
block|{
name|struct
name|rt_addrinfo
name|rtinfo
decl_stmt|;
name|struct
name|sockaddr_in6
name|dst
decl_stmt|;
name|struct
name|sockaddr_dl
name|gw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|fibnum
decl_stmt|;
name|LLE_WLOCK_ASSERT
argument_list|(
name|lle
argument_list|)
expr_stmt|;
if|if
condition|(
name|lltable_get_af
argument_list|(
name|lle
operator|->
name|lle_tbl
argument_list|)
operator|!=
name|AF_INET6
condition|)
return|return;
switch|switch
condition|(
name|evt
condition|)
block|{
case|case
name|LLENTRY_RESOLVED
case|:
name|type
operator|=
name|RTM_ADD
expr_stmt|;
name|KASSERT
argument_list|(
name|lle
operator|->
name|la_flags
operator|&
name|LLE_VALID
argument_list|,
operator|(
literal|"%s: %p resolved but not valid?"
operator|,
name|__func__
operator|,
name|lle
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LLENTRY_EXPIRED
case|:
name|type
operator|=
name|RTM_DELETE
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|ifp
operator|=
name|lltable_get_ifp
argument_list|(
name|lle
operator|->
name|lle_tbl
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|gw
argument_list|,
sizeof|sizeof
argument_list|(
name|gw
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|rtinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|rtinfo
argument_list|)
argument_list|)
expr_stmt|;
name|lltable_fill_sa_entry
argument_list|(
name|lle
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|.
name|sin6_scope_id
operator|=
name|in6_getscopezone
argument_list|(
name|ifp
argument_list|,
name|in6_addrscope
argument_list|(
operator|&
name|dst
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|gw
operator|.
name|sdl_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_dl
argument_list|)
expr_stmt|;
name|gw
operator|.
name|sdl_family
operator|=
name|AF_LINK
expr_stmt|;
name|gw
operator|.
name|sdl_alen
operator|=
name|ifp
operator|->
name|if_addrlen
expr_stmt|;
name|gw
operator|.
name|sdl_index
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
name|gw
operator|.
name|sdl_type
operator|=
name|ifp
operator|->
name|if_type
expr_stmt|;
if|if
condition|(
name|evt
operator|==
name|LLENTRY_RESOLVED
condition|)
name|bcopy
argument_list|(
name|lle
operator|->
name|ll_addr
argument_list|,
name|gw
operator|.
name|sdl_data
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
name|rtinfo
operator|.
name|rti_info
index|[
name|RTAX_DST
index|]
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dst
expr_stmt|;
name|rtinfo
operator|.
name|rti_info
index|[
name|RTAX_GATEWAY
index|]
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|gw
expr_stmt|;
name|rtinfo
operator|.
name|rti_addrs
operator|=
name|RTA_DST
operator||
name|RTA_GATEWAY
expr_stmt|;
name|fibnum
operator|=
name|V_rt_add_addr_allfibs
condition|?
name|RT_ALL_FIBS
else|:
name|ifp
operator|->
name|if_fib
expr_stmt|;
name|rt_missmsg_fib
argument_list|(
name|type
argument_list|,
operator|&
name|rtinfo
argument_list|,
name|RTF_HOST
operator||
name|RTF_LLDATA
operator||
operator|(
name|type
operator|==
name|RTM_ADD
condition|?
name|RTF_UP
else|:
literal|0
operator|)
argument_list|,
literal|0
argument_list|,
name|fibnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A handler for interface link layer address change event.  */
end_comment

begin_function
specifier|static
name|void
name|nd6_iflladdr
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|lltable_update_ifaddr
argument_list|(
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nd6_init
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_init
argument_list|(
operator|&
name|V_nd6_onlink_mtx
argument_list|,
literal|"nd6 onlink"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|V_nd6_lock
argument_list|,
literal|"nd6 list"
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|V_nd_prefix
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|V_nd_defrouter
argument_list|)
expr_stmt|;
comment|/* Start timers. */
name|callout_init
argument_list|(
operator|&
name|V_nd6_slowtimo_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|V_nd6_slowtimo_ch
argument_list|,
name|ND6_SLOWTIMER_INTERVAL
operator|*
name|hz
argument_list|,
name|nd6_slowtimo
argument_list|,
name|curvnet
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|V_nd6_timer_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|V_nd6_timer_ch
argument_list|,
name|hz
argument_list|,
name|nd6_timer
argument_list|,
name|curvnet
argument_list|)
expr_stmt|;
name|nd6_dad_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|IS_DEFAULT_VNET
argument_list|(
name|curvnet
argument_list|)
condition|)
block|{
name|lle_event_eh
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|lle_event
argument_list|,
name|nd6_lle_event
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|iflladdr_event_eh
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|iflladdr_event
argument_list|,
name|nd6_iflladdr
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE
end_ifdef

begin_function
name|void
name|nd6_destroy
parameter_list|()
block|{
name|callout_drain
argument_list|(
operator|&
name|V_nd6_slowtimo_ch
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|V_nd6_timer_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DEFAULT_VNET
argument_list|(
name|curvnet
argument_list|)
condition|)
block|{
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|lle_event
argument_list|,
name|lle_event_eh
argument_list|)
expr_stmt|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|iflladdr_event
argument_list|,
name|iflladdr_event_eh
argument_list|)
expr_stmt|;
block|}
name|rw_destroy
argument_list|(
operator|&
name|V_nd6_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|V_nd6_onlink_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|nd_ifinfo
modifier|*
name|nd6_ifattach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|nd_ifinfo
modifier|*
name|nd
decl_stmt|;
name|nd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nd
argument_list|)
argument_list|,
name|M_IP6NDP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|nd
operator|->
name|initialized
operator|=
literal|1
expr_stmt|;
name|nd
operator|->
name|chlim
operator|=
name|IPV6_DEFHLIM
expr_stmt|;
name|nd
operator|->
name|basereachable
operator|=
name|REACHABLE_TIME
expr_stmt|;
name|nd
operator|->
name|reachable
operator|=
name|ND_COMPUTE_RTIME
argument_list|(
name|nd
operator|->
name|basereachable
argument_list|)
expr_stmt|;
name|nd
operator|->
name|retrans
operator|=
name|RETRANS_TIMER
expr_stmt|;
name|nd
operator|->
name|flags
operator|=
name|ND6_IFF_PERFORMNUD
expr_stmt|;
comment|/* A loopback interface always has ND6_IFF_AUTO_LINKLOCAL. 	 * XXXHRS: Clear ND6_IFF_AUTO_LINKLOCAL on an IFT_BRIDGE interface by 	 * default regardless of the V_ip6_auto_linklocal configuration to 	 * give a reasonable default behavior. 	 */
if|if
condition|(
operator|(
name|V_ip6_auto_linklocal
operator|&&
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_BRIDGE
operator|)
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
condition|)
name|nd
operator|->
name|flags
operator||=
name|ND6_IFF_AUTO_LINKLOCAL
expr_stmt|;
comment|/* 	 * A loopback interface does not need to accept RTADV. 	 * XXXHRS: Clear ND6_IFF_ACCEPT_RTADV on an IFT_BRIDGE interface by 	 * default regardless of the V_ip6_accept_rtadv configuration to 	 * prevent the interface from accepting RA messages arrived 	 * on one of the member interfaces with ND6_IFF_ACCEPT_RTADV. 	 */
if|if
condition|(
name|V_ip6_accept_rtadv
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_BRIDGE
operator|)
condition|)
name|nd
operator|->
name|flags
operator||=
name|ND6_IFF_ACCEPT_RTADV
expr_stmt|;
if|if
condition|(
name|V_ip6_no_radr
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
condition|)
name|nd
operator|->
name|flags
operator||=
name|ND6_IFF_NO_RADR
expr_stmt|;
comment|/* XXX: we cannot call nd6_setmtu since ifp is not fully initialized */
name|nd6_setmtu0
argument_list|(
name|ifp
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
name|nd
return|;
block|}
end_function

begin_function
name|void
name|nd6_ifdetach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|nd_ifinfo
modifier|*
name|nd
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
comment|/* stop DAD processing */
name|nd6_dad_stop
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nd
argument_list|,
name|M_IP6NDP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset ND level link MTU. This function is called when the physical MTU  * changes, which means we might have to adjust the ND level MTU.  */
end_comment

begin_function
name|void
name|nd6_setmtu
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_afdata
index|[
name|AF_INET6
index|]
operator|==
name|NULL
condition|)
return|return;
name|nd6_setmtu0
argument_list|(
name|ifp
argument_list|,
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX todo: do not maintain copy of ifp->if_mtu in ndi->maxmtu */
end_comment

begin_function
name|void
name|nd6_setmtu0
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|nd_ifinfo
modifier|*
name|ndi
parameter_list|)
block|{
name|u_int32_t
name|omaxmtu
decl_stmt|;
name|omaxmtu
operator|=
name|ndi
operator|->
name|maxmtu
expr_stmt|;
switch|switch
condition|(
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ARCNET
case|:
name|ndi
operator|->
name|maxmtu
operator|=
name|MIN
argument_list|(
name|ARC_PHDS_MAXMTU
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
comment|/* RFC2497 */
break|break;
case|case
name|IFT_FDDI
case|:
name|ndi
operator|->
name|maxmtu
operator|=
name|MIN
argument_list|(
name|FDDIIPMTU
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
comment|/* RFC2467 */
break|break;
case|case
name|IFT_ISO88025
case|:
name|ndi
operator|->
name|maxmtu
operator|=
name|MIN
argument_list|(
name|ISO88025_MAX_MTU
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ndi
operator|->
name|maxmtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
break|break;
block|}
comment|/* 	 * Decreasing the interface MTU under IPV6 minimum MTU may cause 	 * undesirable situation.  We thus notify the operator of the change 	 * explicitly.  The check for omaxmtu is necessary to restrict the 	 * log to the case of changing the MTU, not initializing it. 	 */
if|if
condition|(
name|omaxmtu
operator|>=
name|IPV6_MMTU
operator|&&
name|ndi
operator|->
name|maxmtu
operator|<
name|IPV6_MMTU
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"nd6_setmtu0: "
literal|"new link MTU on %s (%lu) is too small for IPv6\n"
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ndi
operator|->
name|maxmtu
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ndi
operator|->
name|maxmtu
operator|>
name|V_in6_maxmtu
condition|)
name|in6_setmaxmtu
argument_list|()
expr_stmt|;
comment|/* check all interfaces just in case */
block|}
end_function

begin_function
name|void
name|nd6_option_init
parameter_list|(
name|void
modifier|*
name|opt
parameter_list|,
name|int
name|icmp6len
parameter_list|,
name|union
name|nd_opts
modifier|*
name|ndopts
parameter_list|)
block|{
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_search
operator|=
operator|(
expr|struct
name|nd_opt_hdr
operator|*
operator|)
name|opt
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_last
operator|=
operator|(
expr|struct
name|nd_opt_hdr
operator|*
operator|)
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
name|opt
operator|)
operator|+
name|icmp6len
operator|)
expr_stmt|;
if|if
condition|(
name|icmp6len
operator|==
literal|0
condition|)
block|{
name|ndopts
operator|->
name|nd_opts_done
operator|=
literal|1
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_search
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Take one ND option.  */
end_comment

begin_function
name|struct
name|nd_opt_hdr
modifier|*
name|nd6_option
parameter_list|(
name|union
name|nd_opts
modifier|*
name|ndopts
parameter_list|)
block|{
name|struct
name|nd_opt_hdr
modifier|*
name|nd_opt
decl_stmt|;
name|int
name|olen
decl_stmt|;
name|KASSERT
argument_list|(
name|ndopts
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ndopts == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ndopts
operator|->
name|nd_opts_last
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: uninitialized ndopts"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_search
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_done
condition|)
return|return
name|NULL
return|;
name|nd_opt
operator|=
name|ndopts
operator|->
name|nd_opts_search
expr_stmt|;
comment|/* make sure nd_opt_len is inside the buffer */
if|if
condition|(
operator|(
name|caddr_t
operator|)
operator|&
name|nd_opt
operator|->
name|nd_opt_len
operator|>=
operator|(
name|caddr_t
operator|)
name|ndopts
operator|->
name|nd_opts_last
condition|)
block|{
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|olen
operator|=
name|nd_opt
operator|->
name|nd_opt_len
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|olen
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Message validation requires that all included 		 * options have a length that is greater than zero. 		 */
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ndopts
operator|->
name|nd_opts_search
operator|=
operator|(
expr|struct
name|nd_opt_hdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|nd_opt
operator|+
name|olen
operator|)
expr_stmt|;
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_search
operator|>
name|ndopts
operator|->
name|nd_opts_last
condition|)
block|{
comment|/* option overruns the end of buffer, invalid */
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_search
operator|==
name|ndopts
operator|->
name|nd_opts_last
condition|)
block|{
comment|/* reached the end of options chain */
name|ndopts
operator|->
name|nd_opts_done
operator|=
literal|1
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_search
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|nd_opt
return|;
block|}
end_function

begin_comment
comment|/*  * Parse multiple ND options.  * This function is much easier to use, for ND routines that do not need  * multiple options of the same type.  */
end_comment

begin_function
name|int
name|nd6_options
parameter_list|(
name|union
name|nd_opts
modifier|*
name|ndopts
parameter_list|)
block|{
name|struct
name|nd_opt_hdr
modifier|*
name|nd_opt
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
name|ndopts
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ndopts == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ndopts
operator|->
name|nd_opts_last
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: uninitialized ndopts"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_search
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|nd_opt
operator|=
name|nd6_option
argument_list|(
name|ndopts
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd_opt
operator|==
name|NULL
operator|&&
name|ndopts
operator|->
name|nd_opts_last
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Message validation requires that all included 			 * options have a length that is greater than zero. 			 */
name|ICMP6STAT_INC
argument_list|(
name|icp6s_nd_badopt
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|nd_opt
operator|==
name|NULL
condition|)
goto|goto
name|skip1
goto|;
switch|switch
condition|(
name|nd_opt
operator|->
name|nd_opt_type
condition|)
block|{
case|case
name|ND_OPT_SOURCE_LINKADDR
case|:
case|case
name|ND_OPT_TARGET_LINKADDR
case|:
case|case
name|ND_OPT_MTU
case|:
case|case
name|ND_OPT_REDIRECTED_HEADER
case|:
case|case
name|ND_OPT_NONCE
case|:
if|if
condition|(
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
condition|)
block|{
name|nd6log
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"duplicated ND6 option found (type=%d)\n"
operator|,
name|nd_opt
operator|->
name|nd_opt_type
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX bark? */
block|}
else|else
block|{
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
operator|=
name|nd_opt
expr_stmt|;
block|}
break|break;
case|case
name|ND_OPT_PREFIX_INFORMATION
case|:
if|if
condition|(
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
operator|==
literal|0
condition|)
block|{
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
operator|=
name|nd_opt
expr_stmt|;
block|}
name|ndopts
operator|->
name|nd_opts_pi_end
operator|=
operator|(
expr|struct
name|nd_opt_prefix_info
operator|*
operator|)
name|nd_opt
expr_stmt|;
break|break;
comment|/* What about ND_OPT_ROUTE_INFO? RFC 4191 */
case|case
name|ND_OPT_RDNSS
case|:
comment|/* RFC 6106 */
case|case
name|ND_OPT_DNSSL
case|:
comment|/* RFC 6106 */
comment|/* 			 * Silently ignore options we know and do not care about 			 * in the kernel. 			 */
break|break;
default|default:
comment|/* 			 * Unknown options must be silently ignored, 			 * to accommodate future extension to the protocol. 			 */
name|nd6log
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"nd6_options: unsupported option %d - "
literal|"option ignored\n"
operator|,
name|nd_opt
operator|->
name|nd_opt_type
operator|)
argument_list|)
expr_stmt|;
block|}
name|skip1
label|:
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|V_nd6_maxndopt
condition|)
block|{
name|ICMP6STAT_INC
argument_list|(
name|icp6s_nd_toomanyopt
argument_list|)
expr_stmt|;
name|nd6log
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"too many loop in nd opt\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_done
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ND6 timer routine to handle ND6 entries  */
end_comment

begin_function
specifier|static
name|void
name|nd6_llinfo_settimer_locked
parameter_list|(
name|struct
name|llentry
modifier|*
name|ln
parameter_list|,
name|long
name|tick
parameter_list|)
block|{
name|int
name|canceled
decl_stmt|;
name|LLE_WLOCK_ASSERT
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|tick
operator|<
literal|0
condition|)
block|{
name|ln
operator|->
name|la_expire
operator|=
literal|0
expr_stmt|;
name|ln
operator|->
name|ln_ntick
operator|=
literal|0
expr_stmt|;
name|canceled
operator|=
name|callout_stop
argument_list|(
operator|&
name|ln
operator|->
name|lle_timer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|->
name|la_expire
operator|=
name|time_uptime
operator|+
name|tick
operator|/
name|hz
expr_stmt|;
name|LLE_ADDREF
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|tick
operator|>
name|INT_MAX
condition|)
block|{
name|ln
operator|->
name|ln_ntick
operator|=
name|tick
operator|-
name|INT_MAX
expr_stmt|;
name|canceled
operator|=
name|callout_reset
argument_list|(
operator|&
name|ln
operator|->
name|lle_timer
argument_list|,
name|INT_MAX
argument_list|,
name|nd6_llinfo_timer
argument_list|,
name|ln
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|->
name|ln_ntick
operator|=
literal|0
expr_stmt|;
name|canceled
operator|=
name|callout_reset
argument_list|(
operator|&
name|ln
operator|->
name|lle_timer
argument_list|,
name|tick
argument_list|,
name|nd6_llinfo_timer
argument_list|,
name|ln
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|canceled
operator|>
literal|0
condition|)
name|LLE_REMREF
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Gets source address of the first packet in hold queue  * and stores it in @src.  * Returns pointer to @src (if hold queue is not empty) or NULL.  *  * Set noinline to be dtrace-friendly  */
end_comment

begin_expr_stmt
specifier|static
name|__noinline
expr|struct
name|in6_addr
operator|*
name|nd6_llinfo_get_holdsrc
argument_list|(
argument|struct llentry *ln
argument_list|,
argument|struct in6_addr *src
argument_list|)
block|{ 	struct
name|ip6_hdr
name|hdr
block|; 	struct
name|mbuf
operator|*
name|m
block|;
if|if
condition|(
name|ln
operator|->
name|la_hold
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * assume every packet in la_hold has the same IP header 	 */
name|m
operator|=
name|ln
operator|->
name|la_hold
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|>
name|m
operator|->
name|m_len
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
end_if

begin_expr_stmt
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|hdr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|src
operator|=
name|hdr
operator|.
name|ip6_src
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|src
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Checks if we need to switch from STALE state.  *  * RFC 4861 requires switching from STALE to DELAY state  * on first packet matching entry, waiting V_nd6_delay and  * transition to PROBE state (if upper layer confirmation was  * not received).  *  * This code performs a bit differently:  * On packet hit we don't change state (but desired state  * can be guessed by control plane). However, after V_nd6_delay  * seconds code will transition to PROBE state (so DELAY state  * is kinda skipped in most situations).  *  * Typically, V_nd6_gctimer is bigger than V_nd6_delay, so  * we perform the following upon entering STALE state:  *  * 1) Arm timer to run each V_nd6_delay seconds to make sure that  * if packet was transmitted at the start of given interval, we  * would be able to switch to PROBE state in V_nd6_delay seconds  * as user expects.  *  * 2) Reschedule timer until original V_nd6_gctimer expires keeping  * lle in STALE state (remaining timer value stored in lle_remtime).  *  * 3) Reschedule timer if packet was transmitted less that V_nd6_delay  * seconds ago.  *  * Returns non-zero value if the entry is still STALE (storing  * the next timer interval in @pdelay).  *  * Returns zero value if original timer expired or we need to switch to  * PROBE (store that in @do_switch variable).  */
end_comment

begin_function
unit|static
name|int
name|nd6_is_stale
parameter_list|(
name|struct
name|llentry
modifier|*
name|lle
parameter_list|,
name|long
modifier|*
name|pdelay
parameter_list|,
name|int
modifier|*
name|do_switch
parameter_list|)
block|{
name|int
name|nd_delay
decl_stmt|,
name|nd_gctimer
decl_stmt|,
name|r_skip_req
decl_stmt|;
name|time_t
name|lle_hittime
decl_stmt|;
name|long
name|delay
decl_stmt|;
operator|*
name|do_switch
operator|=
literal|0
expr_stmt|;
name|nd_gctimer
operator|=
name|V_nd6_gctimer
expr_stmt|;
name|nd_delay
operator|=
name|V_nd6_delay
expr_stmt|;
name|LLE_REQ_LOCK
argument_list|(
name|lle
argument_list|)
expr_stmt|;
name|r_skip_req
operator|=
name|lle
operator|->
name|r_skip_req
expr_stmt|;
name|lle_hittime
operator|=
name|lle
operator|->
name|lle_hittime
expr_stmt|;
name|LLE_REQ_UNLOCK
argument_list|(
name|lle
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_skip_req
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Nonzero r_skip_req value was set upon entering 		 * STALE state. Since value was not changed, no 		 * packets were passed using this lle. Ask for 		 * timer reschedule and keep STALE state. 		 */
name|delay
operator|=
call|(
name|long
call|)
argument_list|(
name|MIN
argument_list|(
name|nd_gctimer
argument_list|,
name|nd_delay
argument_list|)
argument_list|)
expr_stmt|;
name|delay
operator|*=
name|hz
expr_stmt|;
if|if
condition|(
name|lle
operator|->
name|lle_remtime
operator|>
name|delay
condition|)
name|lle
operator|->
name|lle_remtime
operator|-=
name|delay
expr_stmt|;
else|else
block|{
name|delay
operator|=
name|lle
operator|->
name|lle_remtime
expr_stmt|;
name|lle
operator|->
name|lle_remtime
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|delay
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The original ng6_gctime timeout ended, 			 * no more rescheduling. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|pdelay
operator|=
name|delay
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Packet received. Verify timestamp 	 */
name|delay
operator|=
call|(
name|long
call|)
argument_list|(
name|time_uptime
operator|-
name|lle_hittime
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|<
name|nd_delay
condition|)
block|{
comment|/* 		 * V_nd6_delay still not passed since the first 		 * hit in STALE state. 		 * Reshedule timer and return. 		 */
operator|*
name|pdelay
operator|=
call|(
name|long
call|)
argument_list|(
name|nd_delay
operator|-
name|delay
argument_list|)
operator|*
name|hz
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Request switching to probe */
operator|*
name|do_switch
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Switch @lle state to new state optionally arming timers.  *  * Set noinline to be dtrace-friendly  */
end_comment

begin_function
name|__noinline
name|void
name|nd6_llinfo_setstate
parameter_list|(
name|struct
name|llentry
modifier|*
name|lle
parameter_list|,
name|int
name|newstate
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|nd_gctimer
decl_stmt|,
name|nd_delay
decl_stmt|;
name|long
name|delay
decl_stmt|,
name|remtime
decl_stmt|;
name|delay
operator|=
literal|0
expr_stmt|;
name|remtime
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|newstate
condition|)
block|{
case|case
name|ND6_LLINFO_INCOMPLETE
case|:
name|ifp
operator|=
name|lle
operator|->
name|lle_tbl
operator|->
name|llt_ifp
expr_stmt|;
name|delay
operator|=
operator|(
name|long
operator|)
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|retrans
operator|*
name|hz
operator|/
literal|1000
expr_stmt|;
break|break;
case|case
name|ND6_LLINFO_REACHABLE
case|:
if|if
condition|(
operator|!
name|ND6_LLINFO_PERMANENT
argument_list|(
name|lle
argument_list|)
condition|)
block|{
name|ifp
operator|=
name|lle
operator|->
name|lle_tbl
operator|->
name|llt_ifp
expr_stmt|;
name|delay
operator|=
operator|(
name|long
operator|)
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|reachable
operator|*
name|hz
expr_stmt|;
block|}
break|break;
case|case
name|ND6_LLINFO_STALE
case|:
comment|/* 		 * Notify fast path that we want to know if any packet 		 * is transmitted by setting r_skip_req. 		 */
name|LLE_REQ_LOCK
argument_list|(
name|lle
argument_list|)
expr_stmt|;
name|lle
operator|->
name|r_skip_req
operator|=
literal|1
expr_stmt|;
name|LLE_REQ_UNLOCK
argument_list|(
name|lle
argument_list|)
expr_stmt|;
name|nd_delay
operator|=
name|V_nd6_delay
expr_stmt|;
name|nd_gctimer
operator|=
name|V_nd6_gctimer
expr_stmt|;
name|delay
operator|=
call|(
name|long
call|)
argument_list|(
name|MIN
argument_list|(
name|nd_gctimer
argument_list|,
name|nd_delay
argument_list|)
argument_list|)
operator|*
name|hz
expr_stmt|;
name|remtime
operator|=
operator|(
name|long
operator|)
name|nd_gctimer
operator|*
name|hz
operator|-
name|delay
expr_stmt|;
break|break;
case|case
name|ND6_LLINFO_DELAY
case|:
name|lle
operator|->
name|la_asked
operator|=
literal|0
expr_stmt|;
name|delay
operator|=
operator|(
name|long
operator|)
name|V_nd6_delay
operator|*
name|hz
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|delay
operator|>
literal|0
condition|)
name|nd6_llinfo_settimer_locked
argument_list|(
name|lle
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|lle
operator|->
name|lle_remtime
operator|=
name|remtime
expr_stmt|;
name|lle
operator|->
name|ln_state
operator|=
name|newstate
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Timer-dependent part of nd state machine.  *  * Set noinline to be dtrace-friendly  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|nd6_llinfo_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|llentry
modifier|*
name|ln
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|dst
decl_stmt|,
modifier|*
name|pdst
decl_stmt|,
modifier|*
name|psrc
decl_stmt|,
name|src
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|nd_ifinfo
modifier|*
name|ndi
decl_stmt|;
name|int
name|do_switch
decl_stmt|,
name|send_ns
decl_stmt|;
name|long
name|delay
decl_stmt|;
name|KASSERT
argument_list|(
name|arg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: arg NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ln
operator|=
operator|(
expr|struct
name|llentry
operator|*
operator|)
name|arg
expr_stmt|;
name|ifp
operator|=
name|lltable_get_ifp
argument_list|(
name|ln
operator|->
name|lle_tbl
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|ND6_RLOCK
argument_list|()
expr_stmt|;
name|LLE_WLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|ln
operator|->
name|lle_timer
argument_list|)
condition|)
block|{
comment|/* 		 * Here we are a bit odd here in the treatment of  		 * active/pending. If the pending bit is set, it got 		 * rescheduled before I ran. The active 		 * bit we ignore, since if it was stopped 		 * in ll_tablefree() and was currently running 		 * it would have return 0 so the code would 		 * not have deleted it since the callout could 		 * not be stopped so we want to go through 		 * with the delete here now. If the callout 		 * was restarted, the pending bit will be back on and 		 * we just want to bail since the callout_reset would 		 * return 1 and our reference would have been removed 		 * by nd6_llinfo_settimer_locked above since canceled 		 * would have been 1. 		 */
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|ND6_RUNLOCK
argument_list|()
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
name|ndi
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|send_ns
operator|=
literal|0
expr_stmt|;
name|dst
operator|=
operator|&
name|ln
operator|->
name|r_l3addr
operator|.
name|addr6
expr_stmt|;
name|pdst
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_ntick
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ln
operator|->
name|ln_ntick
operator|>
name|INT_MAX
condition|)
block|{
name|ln
operator|->
name|ln_ntick
operator|-=
name|INT_MAX
expr_stmt|;
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|->
name|ln_ntick
operator|=
literal|0
expr_stmt|;
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
name|ln
operator|->
name|ln_ntick
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|ln
operator|->
name|la_flags
operator|&
name|LLE_STATIC
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|ln
operator|->
name|la_flags
operator|&
name|LLE_DELETED
condition|)
block|{
name|nd6_free
argument_list|(
operator|&
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|ln
operator|->
name|ln_state
condition|)
block|{
case|case
name|ND6_LLINFO_INCOMPLETE
case|:
if|if
condition|(
name|ln
operator|->
name|la_asked
operator|<
name|V_nd6_mmaxtries
condition|)
block|{
name|ln
operator|->
name|la_asked
operator|++
expr_stmt|;
name|send_ns
operator|=
literal|1
expr_stmt|;
comment|/* Send NS to multicast address */
name|pdst
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|ln
operator|->
name|la_hold
decl_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
comment|/* 				 * assuming every packet in la_hold has the 				 * same IP header.  Send error after unlock. 				 */
name|m0
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|ln
operator|->
name|la_hold
operator|=
name|m0
expr_stmt|;
name|clear_llinfo_pqueue
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
name|nd6_free
argument_list|(
operator|&
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|icmp6_error2
argument_list|(
name|m
argument_list|,
name|ICMP6_DST_UNREACH
argument_list|,
name|ICMP6_DST_UNREACH_ADDR
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ND6_LLINFO_REACHABLE
case|:
if|if
condition|(
operator|!
name|ND6_LLINFO_PERMANENT
argument_list|(
name|ln
argument_list|)
condition|)
name|nd6_llinfo_setstate
argument_list|(
name|ln
argument_list|,
name|ND6_LLINFO_STALE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ND6_LLINFO_STALE
case|:
if|if
condition|(
name|nd6_is_stale
argument_list|(
name|ln
argument_list|,
operator|&
name|delay
argument_list|,
operator|&
name|do_switch
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * No packet has used this entry and GC timeout 			 * has not been passed. Reshedule timer and 			 * return. 			 */
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
name|delay
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|do_switch
operator|==
literal|0
condition|)
block|{
comment|/* 			 * GC timer has ended and entry hasn't been used. 			 * Run Garbage collector (RFC 4861, 5.3) 			 */
if|if
condition|(
operator|!
name|ND6_LLINFO_PERMANENT
argument_list|(
name|ln
argument_list|)
condition|)
name|nd6_free
argument_list|(
operator|&
name|ln
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Entry has been used AND delay timer has ended. */
comment|/* FALLTHROUGH */
case|case
name|ND6_LLINFO_DELAY
case|:
if|if
condition|(
name|ndi
operator|&&
operator|(
name|ndi
operator|->
name|flags
operator|&
name|ND6_IFF_PERFORMNUD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We need NUD */
name|ln
operator|->
name|la_asked
operator|=
literal|1
expr_stmt|;
name|nd6_llinfo_setstate
argument_list|(
name|ln
argument_list|,
name|ND6_LLINFO_PROBE
argument_list|)
expr_stmt|;
name|send_ns
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|nd6_llinfo_setstate
argument_list|(
name|ln
argument_list|,
name|ND6_LLINFO_STALE
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|ND6_LLINFO_PROBE
case|:
if|if
condition|(
name|ln
operator|->
name|la_asked
operator|<
name|V_nd6_umaxtries
condition|)
block|{
name|ln
operator|->
name|la_asked
operator|++
expr_stmt|;
name|send_ns
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nd6_free
argument_list|(
operator|&
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: paths in a dark night can be confusing: %d"
argument_list|,
name|__func__
argument_list|,
name|ln
operator|->
name|ln_state
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
name|ND6_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|send_ns
operator|!=
literal|0
condition|)
block|{
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|ndi
operator|->
name|retrans
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|psrc
operator|=
name|nd6_llinfo_get_holdsrc
argument_list|(
name|ln
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
name|LLE_FREE_LOCKED
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|ln
operator|=
name|NULL
expr_stmt|;
name|nd6_ns_output
argument_list|(
name|ifp
argument_list|,
name|psrc
argument_list|,
name|pdst
argument_list|,
name|dst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
name|LLE_FREE_LOCKED
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ND6 timer routine to expire default route list and prefix list  */
end_comment

begin_function
name|void
name|nd6_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|CURVNET_SET
argument_list|(
operator|(
expr|struct
name|vnet
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|struct
name|nd_drhead
name|drq
decl_stmt|;
name|struct
name|nd_prhead
name|prl
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|,
modifier|*
name|ndr
decl_stmt|;
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|,
modifier|*
name|npr
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|,
modifier|*
name|nia6
decl_stmt|;
name|uint64_t
name|genid
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|drq
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|prl
argument_list|)
expr_stmt|;
name|ND6_WLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|dr
argument_list|,
argument|&V_nd_defrouter
argument_list|,
argument|dr_entry
argument_list|,
argument|ndr
argument_list|)
if|if
condition|(
name|dr
operator|->
name|expire
operator|&&
name|dr
operator|->
name|expire
operator|<
name|time_uptime
condition|)
name|defrouter_unlink
argument_list|(
name|dr
argument_list|,
operator|&
name|drq
argument_list|)
expr_stmt|;
name|ND6_WUNLOCK
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|dr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|drq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|drq
argument_list|,
name|dr
argument_list|,
name|dr_entry
argument_list|)
expr_stmt|;
name|defrouter_del
argument_list|(
name|dr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * expire interface addresses. 	 * in the past the loop was inside prefix expiry processing. 	 * However, from a stricter speci-confrmance standpoint, we should 	 * rather separate address lifetimes and prefix lifetimes. 	 * 	 * XXXRW: in6_ifaddrhead locking. 	 */
name|addrloop
label|:
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ia6
argument_list|,
argument|&V_in6_ifaddrhead
argument_list|,
argument|ia_link
argument_list|,
argument|nia6
argument_list|)
block|{
comment|/* check address lifetime */
if|if
condition|(
name|IFA6_IS_INVALID
argument_list|(
name|ia6
argument_list|)
condition|)
block|{
name|int
name|regen
init|=
literal|0
decl_stmt|;
comment|/* 			 * If the expiring address is temporary, try 			 * regenerating a new one.  This would be useful when 			 * we suspended a laptop PC, then turned it on after a 			 * period that could invalidate all temporary 			 * addresses.  Although we may have to restart the 			 * loop (see below), it must be after purging the 			 * address.  Otherwise, we'd see an infinite loop of 			 * regeneration. 			 */
if|if
condition|(
name|V_ip6_use_tempaddr
operator|&&
operator|(
name|ia6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_TEMPORARY
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|regen_tmpaddr
argument_list|(
name|ia6
argument_list|)
operator|==
literal|0
condition|)
name|regen
operator|=
literal|1
expr_stmt|;
block|}
name|in6_purgeaddr
argument_list|(
operator|&
name|ia6
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
if|if
condition|(
name|regen
condition|)
goto|goto
name|addrloop
goto|;
comment|/* XXX: see below */
block|}
elseif|else
if|if
condition|(
name|IFA6_IS_DEPRECATED
argument_list|(
name|ia6
argument_list|)
condition|)
block|{
name|int
name|oldflags
init|=
name|ia6
operator|->
name|ia6_flags
decl_stmt|;
name|ia6
operator|->
name|ia6_flags
operator||=
name|IN6_IFF_DEPRECATED
expr_stmt|;
comment|/* 			 * If a temporary address has just become deprecated, 			 * regenerate a new one if possible. 			 */
if|if
condition|(
name|V_ip6_use_tempaddr
operator|&&
operator|(
name|ia6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_TEMPORARY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|oldflags
operator|&
name|IN6_IFF_DEPRECATED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|regen_tmpaddr
argument_list|(
name|ia6
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * A new temporary address is 					 * generated. 					 * XXX: this means the address chain 					 * has changed while we are still in 					 * the loop.  Although the change 					 * would not cause disaster (because 					 * it's not a deletion, but an 					 * addition,) we'd rather restart the 					 * loop just for safety.  Or does this 					 * significantly reduce performance?? 					 */
goto|goto
name|addrloop
goto|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ia6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_TENTATIVE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Schedule DAD for a tentative address.  This happens 			 * if the interface was down or not running 			 * when the address was configured. 			 */
name|int
name|delay
decl_stmt|;
name|delay
operator|=
name|arc4random
argument_list|()
operator|%
operator|(
name|MAX_RTR_SOLICITATION_DELAY
operator|*
name|hz
operator|)
expr_stmt|;
name|nd6_dad_start
argument_list|(
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|ia6
argument_list|,
name|delay
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Check status of the interface.  If it is down, 			 * mark the address as tentative for future DAD. 			 */
if|if
condition|(
operator|(
name|ia6
operator|->
name|ia_ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|||
operator|(
name|ia6
operator|->
name|ia_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|(
name|ND_IFINFO
argument_list|(
name|ia6
operator|->
name|ia_ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
operator|!=
literal|0
condition|)
block|{
name|ia6
operator|->
name|ia6_flags
operator|&=
operator|~
name|IN6_IFF_DUPLICATED
expr_stmt|;
name|ia6
operator|->
name|ia6_flags
operator||=
name|IN6_IFF_TENTATIVE
expr_stmt|;
block|}
comment|/* 			 * A new RA might have made a deprecated address 			 * preferred. 			 */
name|ia6
operator|->
name|ia6_flags
operator|&=
operator|~
name|IN6_IFF_DEPRECATED
expr_stmt|;
block|}
block|}
name|ND6_WLOCK
argument_list|()
expr_stmt|;
name|restart
label|:
name|LIST_FOREACH_SAFE
argument_list|(
argument|pr
argument_list|,
argument|&V_nd_prefix
argument_list|,
argument|ndpr_entry
argument_list|,
argument|npr
argument_list|)
block|{
comment|/* 		 * Expire prefixes. Since the pltime is only used for 		 * autoconfigured addresses, pltime processing for prefixes is 		 * not necessary. 		 * 		 * Only unlink after all derived addresses have expired. This 		 * may not occur until two hours after the prefix has expired 		 * per RFC 4862. If the prefix expires before its derived 		 * addresses, mark it off-link. This will be done automatically 		 * after unlinking if no address references remain. 		 */
if|if
condition|(
name|pr
operator|->
name|ndpr_vltime
operator|==
name|ND6_INFINITE_LIFETIME
operator|||
name|time_uptime
operator|-
name|pr
operator|->
name|ndpr_lastupdate
operator|<=
name|pr
operator|->
name|ndpr_vltime
condition|)
continue|continue;
if|if
condition|(
name|pr
operator|->
name|ndpr_addrcnt
operator|==
literal|0
condition|)
block|{
name|nd6_prefix_unlink
argument_list|(
name|pr
argument_list|,
operator|&
name|prl
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|pr
operator|->
name|ndpr_stateflags
operator|&
name|NDPRF_ONLINK
operator|)
operator|!=
literal|0
condition|)
block|{
name|genid
operator|=
name|V_nd6_list_genid
expr_stmt|;
name|nd6_prefix_ref
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|ND6_WUNLOCK
argument_list|()
expr_stmt|;
name|ND6_ONLINK_LOCK
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|nd6_prefix_offlink
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|ND6_ONLINK_UNLOCK
argument_list|()
expr_stmt|;
name|ND6_WLOCK
argument_list|()
expr_stmt|;
name|nd6_prefix_rele
argument_list|(
name|pr
argument_list|)
expr_stmt|;
if|if
condition|(
name|genid
operator|!=
name|V_nd6_list_genid
condition|)
goto|goto
name|restart
goto|;
block|}
block|}
name|ND6_WUNLOCK
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|prl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|pr
argument_list|,
name|ndpr_entry
argument_list|)
expr_stmt|;
name|nd6_prefix_del
argument_list|(
name|pr
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|V_nd6_timer_ch
argument_list|,
name|V_nd6_prune
operator|*
name|hz
argument_list|,
name|nd6_timer
argument_list|,
name|curvnet
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ia6 - deprecated/invalidated temporary address  */
end_comment

begin_function
specifier|static
name|int
name|regen_tmpaddr
parameter_list|(
name|struct
name|in6_ifaddr
modifier|*
name|ia6
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|public_ifa6
init|=
name|NULL
decl_stmt|;
name|ifp
operator|=
name|ia6
operator|->
name|ia_ifa
operator|.
name|ifa_ifp
expr_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|it6
decl_stmt|;
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|it6
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa
expr_stmt|;
comment|/* ignore no autoconf addresses. */
if|if
condition|(
operator|(
name|it6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_AUTOCONF
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* ignore autoconf addresses with different prefixes. */
if|if
condition|(
name|it6
operator|->
name|ia6_ndpr
operator|==
name|NULL
operator|||
name|it6
operator|->
name|ia6_ndpr
operator|!=
name|ia6
operator|->
name|ia6_ndpr
condition|)
continue|continue;
comment|/* 		 * Now we are looking at an autoconf address with the same 		 * prefix as ours.  If the address is temporary and is still 		 * preferred, do not create another one.  It would be rare, but 		 * could happen, for example, when we resume a laptop PC after 		 * a long period. 		 */
if|if
condition|(
operator|(
name|it6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_TEMPORARY
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|IFA6_IS_DEPRECATED
argument_list|(
name|it6
argument_list|)
condition|)
block|{
name|public_ifa6
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* 		 * This is a public autoconf address that has the same prefix 		 * as ours.  If it is preferred, keep it.  We can't break the 		 * loop here, because there may be a still-preferred temporary 		 * address with the prefix. 		 */
if|if
condition|(
operator|!
name|IFA6_IS_DEPRECATED
argument_list|(
name|it6
argument_list|)
condition|)
name|public_ifa6
operator|=
name|it6
expr_stmt|;
block|}
if|if
condition|(
name|public_ifa6
operator|!=
name|NULL
condition|)
name|ifa_ref
argument_list|(
operator|&
name|public_ifa6
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|public_ifa6
operator|!=
name|NULL
condition|)
block|{
name|int
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|in6_tmpifadd
argument_list|(
name|public_ifa6
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifa_free
argument_list|(
operator|&
name|public_ifa6
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"regen_tmpaddr: failed to create a new"
literal|" tmp addr,errno=%d\n"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ifa_free
argument_list|(
operator|&
name|public_ifa6
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove prefix and default router list entries corresponding to ifp. Neighbor  * cache entries are freed in in6_domifdetach().  */
end_comment

begin_function
name|void
name|nd6_purge
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|nd_drhead
name|drq
decl_stmt|;
name|struct
name|nd_prhead
name|prl
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|,
modifier|*
name|ndr
decl_stmt|;
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|,
modifier|*
name|npr
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|drq
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|prl
argument_list|)
expr_stmt|;
comment|/* 	 * Nuke default router list entries toward ifp. 	 * We defer removal of default router list entries that is installed 	 * in the routing table, in order to keep additional side effects as 	 * small as possible. 	 */
name|ND6_WLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|dr
argument_list|,
argument|&V_nd_defrouter
argument_list|,
argument|dr_entry
argument_list|,
argument|ndr
argument_list|)
block|{
if|if
condition|(
name|dr
operator|->
name|installed
condition|)
continue|continue;
if|if
condition|(
name|dr
operator|->
name|ifp
operator|==
name|ifp
condition|)
name|defrouter_unlink
argument_list|(
name|dr
argument_list|,
operator|&
name|drq
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|dr
argument_list|,
argument|&V_nd_defrouter
argument_list|,
argument|dr_entry
argument_list|,
argument|ndr
argument_list|)
block|{
if|if
condition|(
operator|!
name|dr
operator|->
name|installed
condition|)
continue|continue;
if|if
condition|(
name|dr
operator|->
name|ifp
operator|==
name|ifp
condition|)
name|defrouter_unlink
argument_list|(
name|dr
argument_list|,
operator|&
name|drq
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Remove prefixes on ifp. We should have already removed addresses on 	 * this interface, so no addresses should be referencing these prefixes. 	 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|pr
argument_list|,
argument|&V_nd_prefix
argument_list|,
argument|ndpr_entry
argument_list|,
argument|npr
argument_list|)
block|{
if|if
condition|(
name|pr
operator|->
name|ndpr_ifp
operator|==
name|ifp
condition|)
name|nd6_prefix_unlink
argument_list|(
name|pr
argument_list|,
operator|&
name|prl
argument_list|)
expr_stmt|;
block|}
name|ND6_WUNLOCK
argument_list|()
expr_stmt|;
comment|/* Delete the unlinked router and prefix objects. */
while|while
condition|(
operator|(
name|dr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|drq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|drq
argument_list|,
name|dr
argument_list|,
name|dr_entry
argument_list|)
expr_stmt|;
name|defrouter_del
argument_list|(
name|dr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|pr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|prl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|pr
argument_list|,
name|ndpr_entry
argument_list|)
expr_stmt|;
name|nd6_prefix_del
argument_list|(
name|pr
argument_list|)
expr_stmt|;
block|}
comment|/* cancel default outgoing interface setting */
if|if
condition|(
name|V_nd6_defifindex
operator|==
name|ifp
operator|->
name|if_index
condition|)
name|nd6_setdefaultiface
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_ACCEPT_RTADV
condition|)
block|{
comment|/* Refresh default router list. */
name|defrouter_select_fib
argument_list|(
name|ifp
operator|->
name|if_fib
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * the caller acquires and releases the lock on the lltbls  * Returns the llentry locked  */
end_comment

begin_function
name|struct
name|llentry
modifier|*
name|nd6_lookup
parameter_list|(
specifier|const
name|struct
name|in6_addr
modifier|*
name|addr6
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|struct
name|llentry
modifier|*
name|ln
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|=
operator|*
name|addr6
expr_stmt|;
name|IF_AFDATA_LOCK_ASSERT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ln
operator|=
name|lla_lookup
argument_list|(
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|)
expr_stmt|;
return|return
operator|(
name|ln
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|llentry
modifier|*
name|nd6_alloc
parameter_list|(
specifier|const
name|struct
name|in6_addr
modifier|*
name|addr6
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|struct
name|llentry
modifier|*
name|ln
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|=
operator|*
name|addr6
expr_stmt|;
name|ln
operator|=
name|lltable_alloc_entry
argument_list|(
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_NOSTATE
expr_stmt|;
return|return
operator|(
name|ln
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test whether a given IPv6 address is a neighbor or not, ignoring  * the actual neighbor cache.  The neighbor cache is ignored in order  * to not reenter the routing code from within itself.  */
end_comment

begin_function
specifier|static
name|int
name|nd6_is_new_addr_neighbor
parameter_list|(
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|addr
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|rt_addrinfo
name|info
decl_stmt|;
name|struct
name|sockaddr_in6
name|rt_key
decl_stmt|;
specifier|const
name|struct
name|sockaddr
modifier|*
name|dst6
decl_stmt|;
name|uint64_t
name|genid
decl_stmt|;
name|int
name|error
decl_stmt|,
name|fibnum
decl_stmt|;
comment|/* 	 * A link-local address is always a neighbor. 	 * XXX: a link does not necessarily specify a single interface. 	 */
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|addr
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in6
name|sin6_copy
decl_stmt|;
name|u_int32_t
name|zone
decl_stmt|;
comment|/* 		 * We need sin6_copy since sa6_recoverscope() may modify the 		 * content (XXX). 		 */
name|sin6_copy
operator|=
operator|*
name|addr
expr_stmt|;
if|if
condition|(
name|sa6_recoverscope
argument_list|(
operator|&
name|sin6_copy
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX: should be impossible */
if|if
condition|(
name|in6_setscope
argument_list|(
operator|&
name|sin6_copy
operator|.
name|sin6_addr
argument_list|,
name|ifp
argument_list|,
operator|&
name|zone
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sin6_copy
operator|.
name|sin6_scope_id
operator|==
name|zone
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|rt_key
argument_list|,
sizeof|sizeof
argument_list|(
name|rt_key
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|rti_info
index|[
name|RTAX_DST
index|]
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|rt_key
expr_stmt|;
comment|/* 	 * If the address matches one of our addresses, 	 * it should be a neighbor. 	 * If the address matches one of our on-link prefixes, it should be a 	 * neighbor. 	 */
name|ND6_RLOCK
argument_list|()
expr_stmt|;
name|restart
label|:
name|LIST_FOREACH
argument_list|(
argument|pr
argument_list|,
argument|&V_nd_prefix
argument_list|,
argument|ndpr_entry
argument_list|)
block|{
if|if
condition|(
name|pr
operator|->
name|ndpr_ifp
operator|!=
name|ifp
condition|)
continue|continue;
if|if
condition|(
operator|(
name|pr
operator|->
name|ndpr_stateflags
operator|&
name|NDPRF_ONLINK
operator|)
operator|==
literal|0
condition|)
block|{
name|dst6
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|pr
operator|->
name|ndpr_prefix
expr_stmt|;
comment|/* 			 * We only need to check all FIBs if add_addr_allfibs 			 * is unset. If set, checking any FIB will suffice. 			 */
name|fibnum
operator|=
name|V_rt_add_addr_allfibs
condition|?
name|rt_numfibs
operator|-
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
init|;
name|fibnum
operator|<
name|rt_numfibs
condition|;
name|fibnum
operator|++
control|)
block|{
name|genid
operator|=
name|V_nd6_list_genid
expr_stmt|;
name|ND6_RUNLOCK
argument_list|()
expr_stmt|;
comment|/* 				 * Restore length field before 				 * retrying lookup 				 */
name|rt_key
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|rt_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|rib_lookup_info
argument_list|(
name|fibnum
argument_list|,
name|dst6
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|ND6_RLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|genid
operator|!=
name|V_nd6_list_genid
condition|)
goto|goto
name|restart
goto|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
continue|continue;
comment|/* 			 * This is the case where multiple interfaces 			 * have the same prefix, but only one is installed  			 * into the routing table and that prefix entry 			 * is not the one being examined here. In the case 			 * where RADIX_MPATH is enabled, multiple route 			 * entries (of the same rt_key value) will be  			 * installed because the interface addresses all 			 * differ. 			 */
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|pr
operator|->
name|ndpr_prefix
operator|.
name|sin6_addr
argument_list|,
operator|&
name|rt_key
operator|.
name|sin6_addr
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|IN6_ARE_MASKED_ADDR_EQUAL
argument_list|(
operator|&
name|pr
operator|->
name|ndpr_prefix
operator|.
name|sin6_addr
argument_list|,
operator|&
name|addr
operator|->
name|sin6_addr
argument_list|,
operator|&
name|pr
operator|->
name|ndpr_mask
argument_list|)
condition|)
block|{
name|ND6_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|ND6_RUNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * If the address is assigned on the node of the other side of 	 * a p2p interface, the address should be a neighbor. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|addr
operator|->
name|sin6_family
condition|)
continue|continue;
if|if
condition|(
name|ifa
operator|->
name|ifa_dstaddr
operator|!=
name|NULL
operator|&&
name|sa_equal
argument_list|(
name|addr
argument_list|,
name|ifa
operator|->
name|ifa_dstaddr
argument_list|)
condition|)
block|{
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the default router list is empty, all addresses are regarded 	 * as on-link, and thus, as a neighbor. 	 */
if|if
condition|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_ACCEPT_RTADV
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|V_nd_defrouter
argument_list|)
operator|&&
name|V_nd6_defifindex
operator|==
name|ifp
operator|->
name|if_index
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detect if a given IPv6 address identifies a neighbor on a given link.  * XXX: should take care of the destination of a p2p link?  */
end_comment

begin_function
name|int
name|nd6_is_addr_neighbor
parameter_list|(
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|addr
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|llentry
modifier|*
name|lle
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|IF_AFDATA_UNLOCK_ASSERT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd6_is_new_addr_neighbor
argument_list|(
name|addr
argument_list|,
name|ifp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Even if the address matches none of our addresses, it might be 	 * in the neighbor cache. 	 */
name|IF_AFDATA_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lle
operator|=
name|nd6_lookup
argument_list|(
operator|&
name|addr
operator|->
name|sin6_addr
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LLE_RUNLOCK
argument_list|(
name|lle
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
name|IF_AFDATA_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free an nd6 llinfo entry.  * Since the function would cause significant changes in the kernel, DO NOT  * make it global, unless you have a strong reason for the change, and are sure  * that the change is safe.  *  * Set noinline to be dtrace-friendly  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|nd6_free
parameter_list|(
name|struct
name|llentry
modifier|*
modifier|*
name|lnp
parameter_list|,
name|int
name|gc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|llentry
modifier|*
name|ln
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|;
name|ln
operator|=
operator|*
name|lnp
expr_stmt|;
operator|*
name|lnp
operator|=
name|NULL
expr_stmt|;
name|LLE_WLOCK_ASSERT
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|ND6_RLOCK_ASSERT
argument_list|()
expr_stmt|;
name|ifp
operator|=
name|lltable_get_ifp
argument_list|(
name|ln
operator|->
name|lle_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_ACCEPT_RTADV
operator|)
operator|!=
literal|0
condition|)
name|dr
operator|=
name|defrouter_lookup_locked
argument_list|(
operator|&
name|ln
operator|->
name|r_l3addr
operator|.
name|addr6
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
else|else
name|dr
operator|=
name|NULL
expr_stmt|;
name|ND6_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ln
operator|->
name|la_flags
operator|&
name|LLE_DELETED
operator|)
operator|==
literal|0
condition|)
name|EVENTHANDLER_INVOKE
argument_list|(
name|lle_event
argument_list|,
name|ln
argument_list|,
name|LLENTRY_EXPIRED
argument_list|)
expr_stmt|;
comment|/* 	 * we used to have pfctlinput(PRC_HOSTDEAD) here. 	 * even though it is not harmful, it was not really necessary. 	 */
comment|/* cancel timer */
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_ACCEPT_RTADV
condition|)
block|{
if|if
condition|(
name|dr
operator|!=
name|NULL
operator|&&
name|dr
operator|->
name|expire
operator|&&
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_STALE
operator|&&
name|gc
condition|)
block|{
comment|/* 			 * If the reason for the deletion is just garbage 			 * collection, and the neighbor is an active default 			 * router, do not delete it.  Instead, reset the GC 			 * timer using the router's lifetime. 			 * Simply deleting the entry would affect default 			 * router selection, which is not necessarily a good 			 * thing, especially when we're using router preference 			 * values. 			 * XXX: the check for ln_state would be redundant, 			 *      but we intentionally keep it just in case. 			 */
if|if
condition|(
name|dr
operator|->
name|expire
operator|>
name|time_uptime
condition|)
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
operator|(
name|dr
operator|->
name|expire
operator|-
name|time_uptime
operator|)
operator|*
name|hz
argument_list|)
expr_stmt|;
else|else
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|V_nd6_gctimer
operator|*
name|hz
argument_list|)
expr_stmt|;
name|LLE_REMREF
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|defrouter_rele
argument_list|(
name|dr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dr
condition|)
block|{
comment|/* 			 * Unreachablity of a router might affect the default 			 * router selection and on-link detection of advertised 			 * prefixes. 			 */
comment|/* 			 * Temporarily fake the state to choose a new default 			 * router and to perform on-link determination of 			 * prefixes correctly. 			 * Below the state will be set correctly, 			 * or the entry itself will be deleted. 			 */
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_INCOMPLETE
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|->
name|ln_router
operator|||
name|dr
condition|)
block|{
comment|/* 			 * We need to unlock to avoid a LOR with rt6_flush() with the 			 * rnh and for the calls to pfxlist_onlink_check() and 			 * defrouter_select_fib() in the block further down for calls 			 * into nd6_lookup().  We still hold a ref. 			 */
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
comment|/* 			 * rt6_flush must be called whether or not the neighbor 			 * is in the Default Router List. 			 * See a corresponding comment in nd6_na_input(). 			 */
name|rt6_flush
argument_list|(
operator|&
name|ln
operator|->
name|r_l3addr
operator|.
name|addr6
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dr
condition|)
block|{
comment|/* 			 * Since defrouter_select_fib() does not affect the 			 * on-link determination and MIP6 needs the check 			 * before the default router selection, we perform 			 * the check now. 			 */
name|pfxlist_onlink_check
argument_list|()
expr_stmt|;
comment|/* 			 * Refresh default router list. 			 */
name|defrouter_select_fib
argument_list|(
name|dr
operator|->
name|ifp
operator|->
name|if_fib
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If this entry was added by an on-link redirect, remove the 		 * corresponding host route. 		 */
if|if
condition|(
name|ln
operator|->
name|la_flags
operator|&
name|LLE_REDIRECT
condition|)
name|nd6_free_redirect
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_router
operator|||
name|dr
condition|)
name|LLE_WLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Save to unlock. We still hold an extra reference and will not 	 * free(9) in llentry_free() if someone else holds one as well. 	 */
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|IF_AFDATA_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|LLE_WLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
comment|/* Guard against race with other llentry_free(). */
if|if
condition|(
name|ln
operator|->
name|la_flags
operator|&
name|LLE_LINKED
condition|)
block|{
comment|/* Remove callout reference */
name|LLE_REMREF
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|lltable_unlink_entry
argument_list|(
name|ln
operator|->
name|lle_tbl
argument_list|,
name|ln
argument_list|)
expr_stmt|;
block|}
name|IF_AFDATA_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|llentry_free
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|!=
name|NULL
condition|)
name|defrouter_rele
argument_list|(
name|dr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nd6_isdynrte
parameter_list|(
specifier|const
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|,
name|void
modifier|*
name|xap
parameter_list|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|==
operator|(
name|RTF_UP
operator||
name|RTF_HOST
operator||
name|RTF_DYNAMIC
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the rtentry for the given llentry,  * both of which were installed by a redirect.  */
end_comment

begin_function
specifier|static
name|void
name|nd6_free_redirect
parameter_list|(
specifier|const
name|struct
name|llentry
modifier|*
name|ln
parameter_list|)
block|{
name|int
name|fibnum
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|struct
name|rt_addrinfo
name|info
decl_stmt|;
name|lltable_fill_sa_entry
argument_list|(
name|ln
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|rti_info
index|[
name|RTAX_DST
index|]
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
expr_stmt|;
name|info
operator|.
name|rti_filter
operator|=
name|nd6_isdynrte
expr_stmt|;
for|for
control|(
name|fibnum
operator|=
literal|0
init|;
name|fibnum
operator|<
name|rt_numfibs
condition|;
name|fibnum
operator|++
control|)
name|rtrequest1_fib
argument_list|(
name|RTM_DELETE
argument_list|,
operator|&
name|info
argument_list|,
name|NULL
argument_list|,
name|fibnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rejuvenate this function for routing operations related  * processing.  */
end_comment

begin_function
name|void
name|nd6_rtrequest
parameter_list|(
name|int
name|req
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|,
name|struct
name|rt_addrinfo
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|gateway
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|gateway
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
expr_stmt|;
name|ifp
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|RTM_ADD
case|:
break|break;
case|case
name|RTM_DELETE
case|:
if|if
condition|(
operator|!
name|ifp
condition|)
return|return;
comment|/* 		 * Only indirect routes are interesting. 		 */
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* 		 * check for default route 		 */
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|in6addr_any
argument_list|,
operator|&
name|SIN6
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|dr
operator|=
name|defrouter_lookup
argument_list|(
operator|&
name|gateway
operator|->
name|sin6_addr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|!=
name|NULL
condition|)
block|{
name|dr
operator|->
name|installed
operator|=
literal|0
expr_stmt|;
name|defrouter_rele
argument_list|(
name|dr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_function

begin_function
name|int
name|nd6_ioctl
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|in6_ndireq
modifier|*
name|ndi
init|=
operator|(
expr|struct
name|in6_ndireq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|in6_nbrinfo
modifier|*
name|nbi
init|=
operator|(
expr|struct
name|in6_nbrinfo
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|in6_ndifreq
modifier|*
name|ndif
init|=
operator|(
expr|struct
name|in6_ndifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_afdata
index|[
name|AF_INET6
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|EPFNOSUPPORT
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|OSIOCGIFINFO_IN6
case|:
define|#
directive|define
name|ND
value|ndi->ndi
comment|/* XXX: old ndp(8) assumes a positive value for linkmtu. */
name|bzero
argument_list|(
operator|&
name|ND
argument_list|,
sizeof|sizeof
argument_list|(
name|ND
argument_list|)
argument_list|)
expr_stmt|;
name|ND
operator|.
name|linkmtu
operator|=
name|IN6_LINKMTU
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ND
operator|.
name|maxmtu
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|maxmtu
expr_stmt|;
name|ND
operator|.
name|basereachable
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|basereachable
expr_stmt|;
name|ND
operator|.
name|reachable
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|reachable
expr_stmt|;
name|ND
operator|.
name|retrans
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|retrans
expr_stmt|;
name|ND
operator|.
name|flags
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
expr_stmt|;
name|ND
operator|.
name|recalctm
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|recalctm
expr_stmt|;
name|ND
operator|.
name|chlim
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|chlim
expr_stmt|;
break|break;
case|case
name|SIOCGIFINFO_IN6
case|:
name|ND
operator|=
operator|*
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFINFO_IN6
case|:
comment|/* 		 * used to change host variables from userland. 		 * intended for a use on router to reflect RA configurations. 		 */
comment|/* 0 means 'unspecified' */
if|if
condition|(
name|ND
operator|.
name|linkmtu
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ND
operator|.
name|linkmtu
operator|<
name|IPV6_MMTU
operator|||
name|ND
operator|.
name|linkmtu
operator|>
name|IN6_LINKMTU
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|linkmtu
operator|=
name|ND
operator|.
name|linkmtu
expr_stmt|;
block|}
if|if
condition|(
name|ND
operator|.
name|basereachable
operator|!=
literal|0
condition|)
block|{
name|int
name|obasereachable
init|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|basereachable
decl_stmt|;
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|basereachable
operator|=
name|ND
operator|.
name|basereachable
expr_stmt|;
if|if
condition|(
name|ND
operator|.
name|basereachable
operator|!=
name|obasereachable
condition|)
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|reachable
operator|=
name|ND_COMPUTE_RTIME
argument_list|(
name|ND
operator|.
name|basereachable
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ND
operator|.
name|retrans
operator|!=
literal|0
condition|)
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|retrans
operator|=
name|ND
operator|.
name|retrans
expr_stmt|;
if|if
condition|(
name|ND
operator|.
name|chlim
operator|!=
literal|0
condition|)
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|chlim
operator|=
name|ND
operator|.
name|chlim
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SIOCSIFINFO_FLAGS
case|:
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia
decl_stmt|;
if|if
condition|(
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
operator|&&
operator|!
operator|(
name|ND
operator|.
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
condition|)
block|{
comment|/* ifdisabled 1->0 transision */
comment|/* 			 * If the interface is marked as ND6_IFF_IFDISABLED and 			 * has an link-local address with IN6_IFF_DUPLICATED, 			 * do not clear ND6_IFF_IFDISABLED. 			 * See RFC 4862, Section 5.4.5. 			 */
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|ia
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa
expr_stmt|;
if|if
condition|(
operator|(
name|ia
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_DUPLICATED
operator|)
operator|&&
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
name|IA6_IN6
argument_list|(
name|ia
argument_list|)
argument_list|)
condition|)
break|break;
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|!=
name|NULL
condition|)
block|{
comment|/* LLA is duplicated. */
name|ND
operator|.
name|flags
operator||=
name|ND6_IFF_IFDISABLED
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot enable an interface"
literal|" with a link-local address marked"
literal|" duplicate.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|ND6_IFF_IFDISABLED
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|in6_if_up
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
operator|&&
operator|(
name|ND
operator|.
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
condition|)
block|{
comment|/* ifdisabled 0->1 transision */
comment|/* Mark all IPv6 address as tentative. */
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator||=
name|ND6_IFF_IFDISABLED
expr_stmt|;
if|if
condition|(
name|V_ip6_dad_count
operator|>
literal|0
operator|&&
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_NO_DAD
operator|)
operator|==
literal|0
condition|)
block|{
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|ia
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa
expr_stmt|;
name|ia
operator|->
name|ia6_flags
operator||=
name|IN6_IFF_TENTATIVE
expr_stmt|;
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ND
operator|.
name|flags
operator|&
name|ND6_IFF_AUTO_LINKLOCAL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_AUTO_LINKLOCAL
operator|)
condition|)
block|{
comment|/* auto_linklocal 0->1 transision */
comment|/* If no link-local address on ifp, configure */
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator||=
name|ND6_IFF_AUTO_LINKLOCAL
expr_stmt|;
name|in6_ifattach
argument_list|(
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ND
operator|.
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* 				 * When the IF already has 				 * ND6_IFF_AUTO_LINKLOCAL, no link-local 				 * address is assigned, and IFF_UP, try to 				 * assign one. 				 */
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|ia
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
name|IA6_IN6
argument_list|(
name|ia
argument_list|)
argument_list|)
condition|)
break|break;
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|!=
name|NULL
condition|)
comment|/* No LLA is configured. */
name|in6_ifattach
argument_list|(
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|=
name|ND
operator|.
name|flags
expr_stmt|;
break|break;
undef|#
directive|undef
name|ND
case|case
name|SIOCSNDFLUSH_IN6
case|:
comment|/* XXX: the ioctl name is confusing... */
comment|/* sync kernel routing table with the default router list */
name|defrouter_reset
argument_list|()
expr_stmt|;
name|defrouter_select
argument_list|()
expr_stmt|;
break|break;
case|case
name|SIOCSPFXFLUSH_IN6
case|:
block|{
comment|/* flush all the prefix advertised by routers */
name|struct
name|in6_ifaddr
modifier|*
name|ia
decl_stmt|,
modifier|*
name|ia_next
decl_stmt|;
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|nd_prhead
name|prl
decl_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|prl
argument_list|)
expr_stmt|;
name|ND6_WLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|pr
argument_list|,
argument|&V_nd_prefix
argument_list|,
argument|ndpr_entry
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|pr
operator|->
name|ndpr_prefix
operator|.
name|sin6_addr
argument_list|)
condition|)
continue|continue;
comment|/* XXX */
name|nd6_prefix_unlink
argument_list|(
name|pr
argument_list|,
operator|&
name|prl
argument_list|)
expr_stmt|;
block|}
name|ND6_WUNLOCK
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|prl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|pr
argument_list|,
name|ndpr_entry
argument_list|)
expr_stmt|;
comment|/* XXXRW: in6_ifaddrhead locking. */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ia
argument_list|,
argument|&V_in6_ifaddrhead
argument_list|,
argument|ia_link
argument_list|,
argument|ia_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|ia
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_AUTOCONF
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ia
operator|->
name|ia6_ndpr
operator|==
name|pr
condition|)
name|in6_purgeaddr
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
block|}
name|nd6_prefix_del
argument_list|(
name|pr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SIOCSRTRFLUSH_IN6
case|:
block|{
comment|/* flush all the default routers */
name|struct
name|nd_drhead
name|drq
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|drq
argument_list|)
expr_stmt|;
name|defrouter_reset
argument_list|()
expr_stmt|;
name|ND6_WLOCK
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|dr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|V_nd_defrouter
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|defrouter_unlink
argument_list|(
name|dr
argument_list|,
operator|&
name|drq
argument_list|)
expr_stmt|;
name|ND6_WUNLOCK
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|dr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|drq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|drq
argument_list|,
name|dr
argument_list|,
name|dr_entry
argument_list|)
expr_stmt|;
name|defrouter_del
argument_list|(
name|dr
argument_list|)
expr_stmt|;
block|}
name|defrouter_select
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|SIOCGNBRINFO_IN6
case|:
block|{
name|struct
name|llentry
modifier|*
name|ln
decl_stmt|;
name|struct
name|in6_addr
name|nb_addr
init|=
name|nbi
operator|->
name|addr
decl_stmt|;
comment|/* make local for safety */
if|if
condition|(
operator|(
name|error
operator|=
name|in6_setscope
argument_list|(
operator|&
name|nb_addr
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|IF_AFDATA_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ln
operator|=
name|nd6_lookup
argument_list|(
operator|&
name|nb_addr
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|IF_AFDATA_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|nbi
operator|->
name|state
operator|=
name|ln
operator|->
name|ln_state
expr_stmt|;
name|nbi
operator|->
name|asked
operator|=
name|ln
operator|->
name|la_asked
expr_stmt|;
name|nbi
operator|->
name|isrouter
operator|=
name|ln
operator|->
name|ln_router
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|la_expire
operator|==
literal|0
condition|)
name|nbi
operator|->
name|expire
operator|=
literal|0
expr_stmt|;
else|else
name|nbi
operator|->
name|expire
operator|=
name|ln
operator|->
name|la_expire
operator|+
name|ln
operator|->
name|lle_remtime
operator|/
name|hz
operator|+
operator|(
name|time_second
operator|-
name|time_uptime
operator|)
expr_stmt|;
name|LLE_RUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCGDEFIFACE_IN6
case|:
comment|/* XXX: should be implemented as a sysctl? */
name|ndif
operator|->
name|ifindex
operator|=
name|V_nd6_defifindex
expr_stmt|;
break|break;
case|case
name|SIOCSDEFIFACE_IN6
case|:
comment|/* XXX: should be implemented as a sysctl? */
return|return
operator|(
name|nd6_setdefaultiface
argument_list|(
name|ndif
operator|->
name|ifindex
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculates new isRouter value based on provided parameters and  * returns it.  */
end_comment

begin_function
specifier|static
name|int
name|nd6_is_router
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|is_new
parameter_list|,
name|int
name|old_addr
parameter_list|,
name|int
name|new_addr
parameter_list|,
name|int
name|ln_router
parameter_list|)
block|{
comment|/* 	 * ICMP6 type dependent behavior. 	 * 	 * NS: clear IsRouter if new entry 	 * RS: clear IsRouter 	 * RA: set IsRouter if there's lladdr 	 * redir: clear IsRouter if new entry 	 * 	 * RA case, (1): 	 * The spec says that we must set IsRouter in the following cases: 	 * - If lladdr exist, set IsRouter.  This means (1-5). 	 * - If it is old entry (!newentry), set IsRouter.  This means (7). 	 * So, based on the spec, in (1-5) and (7) cases we must set IsRouter. 	 * A quetion arises for (1) case.  (1) case has no lladdr in the 	 * neighbor cache, this is similar to (6). 	 * This case is rare but we figured that we MUST NOT set IsRouter. 	 * 	 *   is_new  old_addr new_addr 	    NS  RS  RA	redir 	 *							D R 	 *	0	n	n	(1)	c   ?     s 	 *	0	y	n	(2)	c   s     s 	 *	0	n	y	(3)	c   s     s 	 *	0	y	y	(4)	c   s     s 	 *	0	y	y	(5)	c   s     s 	 *	1	--	n	(6) c	c	c s 	 *	1	--	y	(7) c	c   s	c s 	 * 	 *					(c=clear s=set) 	 */
switch|switch
condition|(
name|type
operator|&
literal|0xff
condition|)
block|{
case|case
name|ND_NEIGHBOR_SOLICIT
case|:
comment|/* 		 * New entry must have is_router flag cleared. 		 */
if|if
condition|(
name|is_new
condition|)
comment|/* (6-7) */
name|ln_router
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ND_REDIRECT
case|:
comment|/* 		 * If the icmp is a redirect to a better router, always set the 		 * is_router flag.  Otherwise, if the entry is newly created, 		 * clear the flag.  [RFC 2461, sec 8.3] 		 */
if|if
condition|(
name|code
operator|==
name|ND_REDIRECT_ROUTER
condition|)
name|ln_router
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|is_new
condition|)
comment|/* (6-7) */
name|ln_router
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|ND_ROUTER_SOLICIT
case|:
comment|/* 		 * is_router flag must always be cleared. 		 */
name|ln_router
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ND_ROUTER_ADVERT
case|:
comment|/* 		 * Mark an entry with lladdr as a router. 		 */
if|if
condition|(
operator|(
operator|!
name|is_new
operator|&&
operator|(
name|old_addr
operator|||
name|new_addr
operator|)
operator|)
operator|||
comment|/* (2-5) */
operator|(
name|is_new
operator|&&
name|new_addr
operator|)
condition|)
block|{
comment|/* (7) */
name|ln_router
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|ln_router
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create neighbor cache entry and cache link-layer address,  * on reception of inbound ND6 packets.  (RS/RA/NS/redirect)  *  * type - ICMP6 type  * code - type dependent information  *  */
end_comment

begin_function
name|void
name|nd6_cache_lladdr
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|lladdr
parameter_list|,
name|int
name|lladdrlen
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|struct
name|llentry
modifier|*
name|ln
init|=
name|NULL
decl_stmt|,
modifier|*
name|ln_tmp
decl_stmt|;
name|int
name|is_newentry
decl_stmt|;
name|int
name|do_update
decl_stmt|;
name|int
name|olladdr
decl_stmt|;
name|int
name|llchange
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|uint16_t
name|router
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|chain
init|=
name|NULL
decl_stmt|;
name|u_char
name|linkhdr
index|[
name|LLE_MAX_LINKHDR
index|]
decl_stmt|;
name|size_t
name|linkhdrsize
decl_stmt|;
name|int
name|lladdr_off
decl_stmt|;
name|IF_AFDATA_UNLOCK_ASSERT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ifp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ifp == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|from
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: from == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* nothing must be updated for unspecified address */
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
name|from
argument_list|)
condition|)
return|return;
comment|/* 	 * Validation about ifp->if_addrlen and lladdrlen must be done in 	 * the caller. 	 * 	 * XXX If the link does not have link-layer adderss, what should 	 * we do? (ifp->if_addrlen == 0) 	 * Spec says nothing in sections for RA, RS and NA.  There's small 	 * description on it in NS section (RFC 2461 7.2.3). 	 */
name|flags
operator|=
name|lladdr
condition|?
name|LLE_EXCLUSIVE
else|:
literal|0
expr_stmt|;
name|IF_AFDATA_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ln
operator|=
name|nd6_lookup
argument_list|(
name|from
argument_list|,
name|flags
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|IF_AFDATA_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|is_newentry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
name|flags
operator||=
name|LLE_EXCLUSIVE
expr_stmt|;
name|ln
operator|=
name|nd6_alloc
argument_list|(
name|from
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
return|return;
comment|/* 		 * Since we already know all the data for the new entry, 		 * fill it before insertion. 		 */
if|if
condition|(
name|lladdr
operator|!=
name|NULL
condition|)
block|{
name|linkhdrsize
operator|=
sizeof|sizeof
argument_list|(
name|linkhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lltable_calc_llheader
argument_list|(
name|ifp
argument_list|,
name|AF_INET6
argument_list|,
name|lladdr
argument_list|,
name|linkhdr
argument_list|,
operator|&
name|linkhdrsize
argument_list|,
operator|&
name|lladdr_off
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|lltable_set_entry_addr
argument_list|(
name|ifp
argument_list|,
name|ln
argument_list|,
name|linkhdr
argument_list|,
name|linkhdrsize
argument_list|,
name|lladdr_off
argument_list|)
expr_stmt|;
block|}
name|IF_AFDATA_WLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|LLE_WLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
comment|/* Prefer any existing lle over newly-created one */
name|ln_tmp
operator|=
name|nd6_lookup
argument_list|(
name|from
argument_list|,
name|LLE_EXCLUSIVE
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln_tmp
operator|==
name|NULL
condition|)
name|lltable_link_entry
argument_list|(
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|IF_AFDATA_WUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln_tmp
operator|==
name|NULL
condition|)
block|{
comment|/* No existing lle, mark as new entry (6,7) */
name|is_newentry
operator|=
literal|1
expr_stmt|;
name|nd6_llinfo_setstate
argument_list|(
name|ln
argument_list|,
name|ND6_LLINFO_STALE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lladdr
operator|!=
name|NULL
condition|)
comment|/* (7) */
name|EVENTHANDLER_INVOKE
argument_list|(
name|lle_event
argument_list|,
name|ln
argument_list|,
name|LLENTRY_RESOLVED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lltable_free_entry
argument_list|(
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|ln
operator|=
name|ln_tmp
expr_stmt|;
name|ln_tmp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* do nothing if static ndp is set */
if|if
condition|(
operator|(
name|ln
operator|->
name|la_flags
operator|&
name|LLE_STATIC
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LLE_EXCLUSIVE
condition|)
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
else|else
name|LLE_RUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
return|return;
block|}
name|olladdr
operator|=
operator|(
name|ln
operator|->
name|la_flags
operator|&
name|LLE_VALID
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|olladdr
operator|&&
name|lladdr
condition|)
block|{
name|llchange
operator|=
name|bcmp
argument_list|(
name|lladdr
argument_list|,
name|ln
operator|->
name|ll_addr
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|olladdr
operator|&&
name|lladdr
condition|)
name|llchange
operator|=
literal|1
expr_stmt|;
else|else
name|llchange
operator|=
literal|0
expr_stmt|;
comment|/* 	 * newentry olladdr  lladdr  llchange	(*=record) 	 *	0	n	n	--	(1) 	 *	0	y	n	--	(2) 	 *	0	n	y	y	(3) * STALE 	 *	0	y	y	n	(4) * 	 *	0	y	y	y	(5) * STALE 	 *	1	--	n	--	(6)   NOSTATE(= PASSIVE) 	 *	1	--	y	--	(7) * STALE 	 */
name|do_update
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_newentry
operator|==
literal|0
operator|&&
name|llchange
operator|!=
literal|0
condition|)
block|{
name|do_update
operator|=
literal|1
expr_stmt|;
comment|/* (3,5) */
comment|/* 		 * Record source link-layer address 		 * XXX is it dependent to ifp->if_type? 		 */
name|linkhdrsize
operator|=
sizeof|sizeof
argument_list|(
name|linkhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lltable_calc_llheader
argument_list|(
name|ifp
argument_list|,
name|AF_INET6
argument_list|,
name|lladdr
argument_list|,
name|linkhdr
argument_list|,
operator|&
name|linkhdrsize
argument_list|,
operator|&
name|lladdr_off
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|lltable_try_set_entry_addr
argument_list|(
name|ifp
argument_list|,
name|ln
argument_list|,
name|linkhdr
argument_list|,
name|linkhdrsize
argument_list|,
name|lladdr_off
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Entry was deleted */
return|return;
block|}
name|nd6_llinfo_setstate
argument_list|(
name|ln
argument_list|,
name|ND6_LLINFO_STALE
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|lle_event
argument_list|,
name|ln
argument_list|,
name|LLENTRY_RESOLVED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|la_hold
operator|!=
name|NULL
condition|)
name|nd6_grab_holdchain
argument_list|(
name|ln
argument_list|,
operator|&
name|chain
argument_list|,
operator|&
name|sin6
argument_list|)
expr_stmt|;
block|}
comment|/* Calculates new router status */
name|router
operator|=
name|nd6_is_router
argument_list|(
name|type
argument_list|,
name|code
argument_list|,
name|is_newentry
argument_list|,
name|olladdr
argument_list|,
name|lladdr
operator|!=
name|NULL
condition|?
literal|1
else|:
literal|0
argument_list|,
name|ln
operator|->
name|ln_router
argument_list|)
expr_stmt|;
name|ln
operator|->
name|ln_router
operator|=
name|router
expr_stmt|;
comment|/* Mark non-router redirects with special flag */
if|if
condition|(
operator|(
name|type
operator|&
literal|0xFF
operator|)
operator|==
name|ND_REDIRECT
operator|&&
name|code
operator|!=
name|ND_REDIRECT_ROUTER
condition|)
name|ln
operator|->
name|la_flags
operator||=
name|LLE_REDIRECT
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LLE_EXCLUSIVE
condition|)
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
else|else
name|LLE_RUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|!=
name|NULL
condition|)
name|nd6_flush_holdchain
argument_list|(
name|ifp
argument_list|,
name|ifp
argument_list|,
name|chain
argument_list|,
operator|&
name|sin6
argument_list|)
expr_stmt|;
comment|/* 	 * When the link-layer address of a router changes, select the 	 * best router again.  In particular, when the neighbor entry is newly 	 * created, it might affect the selection policy. 	 * Question: can we restrict the first condition to the "is_newentry" 	 * case? 	 * XXX: when we hear an RA from a new router with the link-layer 	 * address option, defrouter_select_fib() is called twice, since 	 * defrtrlist_update called the function as well.  However, I believe 	 * we can compromise the overhead, since it only happens the first 	 * time. 	 * XXX: although defrouter_select_fib() should not have a bad effect 	 * for those are not autoconfigured hosts, we explicitly avoid such 	 * cases for safety. 	 */
if|if
condition|(
operator|(
name|do_update
operator|||
name|is_newentry
operator|)
operator|&&
name|router
operator|&&
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_ACCEPT_RTADV
condition|)
block|{
comment|/* 		 * guaranteed recursion 		 */
name|defrouter_select_fib
argument_list|(
name|ifp
operator|->
name|if_fib
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nd6_slowtimo
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|CURVNET_SET
argument_list|(
operator|(
expr|struct
name|vnet
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|struct
name|nd_ifinfo
modifier|*
name|nd6if
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|callout_reset
argument_list|(
operator|&
name|V_nd6_slowtimo_ch
argument_list|,
name|ND6_SLOWTIMER_INTERVAL
operator|*
name|hz
argument_list|,
name|nd6_slowtimo
argument_list|,
name|curvnet
argument_list|)
expr_stmt|;
name|IFNET_RLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifp
argument_list|,
argument|&V_ifnet
argument_list|,
argument|if_link
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_afdata
index|[
name|AF_INET6
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|nd6if
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd6if
operator|->
name|basereachable
operator|&&
comment|/* already initialized */
operator|(
name|nd6if
operator|->
name|recalctm
operator|-=
name|ND6_SLOWTIMER_INTERVAL
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* 			 * Since reachable time rarely changes by router 			 * advertisements, we SHOULD insure that a new random 			 * value gets recomputed at least once every few hours. 			 * (RFC 2461, 6.3.4) 			 */
name|nd6if
operator|->
name|recalctm
operator|=
name|V_nd6_recalc_reachtm_interval
expr_stmt|;
name|nd6if
operator|->
name|reachable
operator|=
name|ND_COMPUTE_RTIME
argument_list|(
name|nd6if
operator|->
name|basereachable
argument_list|)
expr_stmt|;
block|}
block|}
name|IFNET_RUNLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nd6_grab_holdchain
parameter_list|(
name|struct
name|llentry
modifier|*
name|ln
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|chain
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|sin6
parameter_list|)
block|{
name|LLE_WLOCK_ASSERT
argument_list|(
name|ln
argument_list|)
expr_stmt|;
operator|*
name|chain
operator|=
name|ln
operator|->
name|la_hold
expr_stmt|;
name|ln
operator|->
name|la_hold
operator|=
name|NULL
expr_stmt|;
name|lltable_fill_sa_entry
argument_list|(
name|ln
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_STALE
condition|)
block|{
comment|/* 		 * The first time we send a packet to a 		 * neighbor whose entry is STALE, we have 		 * to change the state to DELAY and a sets 		 * a timer to expire in DELAY_FIRST_PROBE_TIME 		 * seconds to ensure do neighbor unreachability 		 * detection on expiration. 		 * (RFC 2461 7.3.3) 		 */
name|nd6_llinfo_setstate
argument_list|(
name|ln
argument_list|,
name|ND6_LLINFO_DELAY
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|nd6_output_ifp
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifnet
modifier|*
name|origifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|dst
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|ip6len
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_netinet6_nd6_send
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If called from nd6_ns_output() (NS), nd6_na_output() (NA), 	 * icmp6_redirect_output() (REDIRECT) or from rip6_output() (RS, RA 	 * as handled by rtsol and rtadvd), mbufs will be tagged for SeND 	 * to be diverted to user space.  When re-injected into the kernel, 	 * send_output() will directly dispatch them to the outgoing interface. 	 */
if|if
condition|(
name|send_sendso_input_hook
operator|!=
name|NULL
condition|)
block|{
name|mtag
operator|=
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_ND_OUTGOING
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|!=
name|NULL
condition|)
block|{
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|ip6len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
comment|/* Use the SEND socket */
name|error
operator|=
name|send_sendso_input_hook
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|,
name|SND_OUT
argument_list|,
name|ip6len
argument_list|)
expr_stmt|;
comment|/* -1 == no app on SEND socket */
if|if
condition|(
name|error
operator|==
literal|0
operator|||
name|error
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|m_clrprotoflags
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Avoid confusing lower layers. */
name|IP_PROBE
argument_list|(
name|send
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|==
literal|0
condition|)
name|origifp
operator|=
name|ifp
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|origifp
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
argument_list|,
name|ro
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup link headerfor @sa_dst address. Stores found  * data in @desten buffer. Copy of lle ln_flags can be also  * saved in @pflags if @pflags is non-NULL.  *  * If destination LLE does not exists or lle state modification  * is required, call "slow" version.  *  * Return values:  * - 0 on success (address copied to buffer).  * - EWOULDBLOCK (no local error, but address is still unresolved)  * - other errors (alloc failure, etc)  */
end_comment

begin_function
name|int
name|nd6_resolve
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|is_gw
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa_dst
parameter_list|,
name|u_char
modifier|*
name|desten
parameter_list|,
name|uint32_t
modifier|*
name|pflags
parameter_list|,
name|struct
name|llentry
modifier|*
modifier|*
name|plle
parameter_list|)
block|{
name|struct
name|llentry
modifier|*
name|ln
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|dst6
decl_stmt|;
if|if
condition|(
name|pflags
operator|!=
name|NULL
condition|)
operator|*
name|pflags
operator|=
literal|0
expr_stmt|;
name|dst6
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa_dst
expr_stmt|;
comment|/* discard the packet if IPv6 operation is disabled on the interface */
if|if
condition|(
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/* better error? */
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
block|{
switch|switch
condition|(
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_FDDI
case|:
case|case
name|IFT_L2VLAN
case|:
case|case
name|IFT_IEEE80211
case|:
case|case
name|IFT_BRIDGE
case|:
case|case
name|IFT_ISO88025
case|:
name|ETHER_MAP_IPV6_MULTICAST
argument_list|(
operator|&
name|dst6
operator|->
name|sin6_addr
argument_list|,
name|desten
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
block|}
name|IF_AFDATA_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ln
operator|=
name|nd6_lookup
argument_list|(
operator|&
name|dst6
operator|->
name|sin6_addr
argument_list|,
name|plle
condition|?
name|LLE_EXCLUSIVE
else|:
name|LLE_UNLOCKED
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
operator|&&
operator|(
name|ln
operator|->
name|r_flags
operator|&
name|RLLE_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Entry found, let's copy lle info */
name|bcopy
argument_list|(
name|ln
operator|->
name|r_linkdata
argument_list|,
name|desten
argument_list|,
name|ln
operator|->
name|r_hdrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pflags
operator|!=
name|NULL
condition|)
operator|*
name|pflags
operator|=
name|LLE_VALID
operator||
operator|(
name|ln
operator|->
name|r_flags
operator|&
name|RLLE_IFADDR
operator|)
expr_stmt|;
comment|/* Check if we have feedback request from nd6 timer */
if|if
condition|(
name|ln
operator|->
name|r_skip_req
operator|!=
literal|0
condition|)
block|{
name|LLE_REQ_LOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|ln
operator|->
name|r_skip_req
operator|=
literal|0
expr_stmt|;
comment|/* Notify that entry was used */
name|ln
operator|->
name|lle_hittime
operator|=
name|time_uptime
expr_stmt|;
name|LLE_REQ_UNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|plle
condition|)
block|{
name|LLE_ADDREF
argument_list|(
name|ln
argument_list|)
expr_stmt|;
operator|*
name|plle
operator|=
name|ln
expr_stmt|;
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
name|IF_AFDATA_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|plle
operator|&&
name|ln
condition|)
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|IF_AFDATA_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|nd6_resolve_slow
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
name|dst6
argument_list|,
name|desten
argument_list|,
name|pflags
argument_list|,
name|plle
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do L2 address resolution for @sa_dst address. Stores found  * address in @desten buffer. Copy of lle ln_flags can be also  * saved in @pflags if @pflags is non-NULL.  *  * Heavy version.  * Function assume that destination LLE does not exist,  * is invalid or stale, so LLE_EXCLUSIVE lock needs to be acquired.  *  * Set noinline to be dtrace-friendly  */
end_comment

begin_function
specifier|static
name|__noinline
name|int
name|nd6_resolve_slow
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|dst
parameter_list|,
name|u_char
modifier|*
name|desten
parameter_list|,
name|uint32_t
modifier|*
name|pflags
parameter_list|,
name|struct
name|llentry
modifier|*
modifier|*
name|plle
parameter_list|)
block|{
name|struct
name|llentry
modifier|*
name|lle
init|=
name|NULL
decl_stmt|,
modifier|*
name|lle_tmp
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|psrc
decl_stmt|,
name|src
decl_stmt|;
name|int
name|send_ns
decl_stmt|,
name|ll_len
decl_stmt|;
name|char
modifier|*
name|lladdr
decl_stmt|;
comment|/* 	 * Address resolution or Neighbor Unreachability Detection 	 * for the next hop. 	 * At this point, the destination of the packet must be a unicast 	 * or an anycast address(i.e. not a multicast). 	 */
if|if
condition|(
name|lle
operator|==
name|NULL
condition|)
block|{
name|IF_AFDATA_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|lle
operator|=
name|nd6_lookup
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
name|LLE_EXCLUSIVE
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|IF_AFDATA_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lle
operator|==
name|NULL
operator|)
operator|&&
name|nd6_is_addr_neighbor
argument_list|(
name|dst
argument_list|,
name|ifp
argument_list|)
condition|)
block|{
comment|/* 			 * Since nd6_is_addr_neighbor() internally calls nd6_lookup(), 			 * the condition below is not very efficient.  But we believe 			 * it is tolerable, because this should be a rare case. 			 */
name|lle
operator|=
name|nd6_alloc
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lle
operator|==
name|NULL
condition|)
block|{
name|char
name|ip6buf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"nd6_output: can't allocate llinfo for %s "
literal|"(ln=%p)\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6buf
argument_list|,
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|lle
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|IF_AFDATA_WLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|LLE_WLOCK
argument_list|(
name|lle
argument_list|)
expr_stmt|;
comment|/* Prefer any existing entry over newly-created one */
name|lle_tmp
operator|=
name|nd6_lookup
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
name|LLE_EXCLUSIVE
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lle_tmp
operator|==
name|NULL
condition|)
name|lltable_link_entry
argument_list|(
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|lle
argument_list|)
expr_stmt|;
name|IF_AFDATA_WUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lle_tmp
operator|!=
name|NULL
condition|)
block|{
name|lltable_free_entry
argument_list|(
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|lle
argument_list|)
expr_stmt|;
name|lle
operator|=
name|lle_tmp
expr_stmt|;
name|lle_tmp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lle
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_PERFORMNUD
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|LLE_WLOCK_ASSERT
argument_list|(
name|lle
argument_list|)
expr_stmt|;
comment|/* 	 * The first time we send a packet to a neighbor whose entry is 	 * STALE, we have to change the state to DELAY and a sets a timer to 	 * expire in DELAY_FIRST_PROBE_TIME seconds to ensure do 	 * neighbor unreachability detection on expiration. 	 * (RFC 2461 7.3.3) 	 */
if|if
condition|(
name|lle
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_STALE
condition|)
name|nd6_llinfo_setstate
argument_list|(
name|lle
argument_list|,
name|ND6_LLINFO_DELAY
argument_list|)
expr_stmt|;
comment|/* 	 * If the neighbor cache entry has a state other than INCOMPLETE 	 * (i.e. its link-layer address is already resolved), just 	 * send the packet. 	 */
if|if
condition|(
name|lle
operator|->
name|ln_state
operator|>
name|ND6_LLINFO_INCOMPLETE
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LLE_ADDRONLY
condition|)
block|{
name|lladdr
operator|=
name|lle
operator|->
name|ll_addr
expr_stmt|;
name|ll_len
operator|=
name|ifp
operator|->
name|if_addrlen
expr_stmt|;
block|}
else|else
block|{
name|lladdr
operator|=
name|lle
operator|->
name|r_linkdata
expr_stmt|;
name|ll_len
operator|=
name|lle
operator|->
name|r_hdrlen
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|lladdr
argument_list|,
name|desten
argument_list|,
name|ll_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pflags
operator|!=
name|NULL
condition|)
operator|*
name|pflags
operator|=
name|lle
operator|->
name|la_flags
expr_stmt|;
if|if
condition|(
name|plle
condition|)
block|{
name|LLE_ADDREF
argument_list|(
name|lle
argument_list|)
expr_stmt|;
operator|*
name|plle
operator|=
name|lle
expr_stmt|;
block|}
name|LLE_WUNLOCK
argument_list|(
name|lle
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * There is a neighbor cache entry, but no ethernet address 	 * response yet.  Append this latest packet to the end of the 	 * packet queue in the mbuf.  When it exceeds nd6_maxqueuelen, 	 * the oldest packet in the queue will be removed. 	 */
if|if
condition|(
name|lle
operator|->
name|la_hold
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m_hold
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m_hold
operator|=
name|lle
operator|->
name|la_hold
init|;
name|m_hold
condition|;
name|m_hold
operator|=
name|m_hold
operator|->
name|m_nextpkt
control|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|m_hold
operator|->
name|m_nextpkt
operator|==
name|NULL
condition|)
block|{
name|m_hold
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
name|i
operator|>=
name|V_nd6_maxqueuelen
condition|)
block|{
name|m_hold
operator|=
name|lle
operator|->
name|la_hold
expr_stmt|;
name|lle
operator|->
name|la_hold
operator|=
name|lle
operator|->
name|la_hold
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|m_hold
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|lle
operator|->
name|la_hold
operator|=
name|m
expr_stmt|;
block|}
comment|/* 	 * If there has been no NS for the neighbor after entering the 	 * INCOMPLETE state, send the first solicitation. 	 * Note that for newly-created lle la_asked will be 0, 	 * so we will transition from ND6_LLINFO_NOSTATE to 	 * ND6_LLINFO_INCOMPLETE state here. 	 */
name|psrc
operator|=
name|NULL
expr_stmt|;
name|send_ns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lle
operator|->
name|la_asked
operator|==
literal|0
condition|)
block|{
name|lle
operator|->
name|la_asked
operator|++
expr_stmt|;
name|send_ns
operator|=
literal|1
expr_stmt|;
name|psrc
operator|=
name|nd6_llinfo_get_holdsrc
argument_list|(
name|lle
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
name|nd6_llinfo_setstate
argument_list|(
name|lle
argument_list|,
name|ND6_LLINFO_INCOMPLETE
argument_list|)
expr_stmt|;
block|}
name|LLE_WUNLOCK
argument_list|(
name|lle
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_ns
operator|!=
literal|0
condition|)
name|nd6_ns_output
argument_list|(
name|ifp
argument_list|,
name|psrc
argument_list|,
name|NULL
argument_list|,
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do L2 address resolution for @sa_dst address. Stores found  * address in @desten buffer. Copy of lle ln_flags can be also  * saved in @pflags if @pflags is non-NULL.  *  * Return values:  * - 0 on success (address copied to buffer).  * - EWOULDBLOCK (no local error, but address is still unresolved)  * - other errors (alloc failure, etc)  */
end_comment

begin_function
name|int
name|nd6_resolve_addr
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|char
modifier|*
name|desten
parameter_list|,
name|uint32_t
modifier|*
name|pflags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|flags
operator||=
name|LLE_ADDRONLY
expr_stmt|;
name|error
operator|=
name|nd6_resolve_slow
argument_list|(
name|ifp
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dst
argument_list|,
name|desten
argument_list|,
name|pflags
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nd6_flush_holdchain
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifnet
modifier|*
name|origifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|chain
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|dst
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_head
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|outifp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|m_head
operator|=
name|chain
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|!=
literal|0
condition|)
name|outifp
operator|=
name|origifp
expr_stmt|;
else|else
name|outifp
operator|=
name|ifp
expr_stmt|;
while|while
condition|(
name|m_head
condition|)
block|{
name|m
operator|=
name|m_head
expr_stmt|;
name|m_head
operator|=
name|m_head
operator|->
name|m_nextpkt
expr_stmt|;
name|error
operator|=
name|nd6_output_ifp
argument_list|(
name|ifp
argument_list|,
name|origifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX 	 * note that intermediate errors are blindly ignored 	 */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nd6_need_cache
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
comment|/* 	 * XXX: we currently do not make neighbor cache on any interface 	 * other than ARCnet, Ethernet, FDDI and GIF. 	 * 	 * RFC2893 says: 	 * - unidirectional tunnels needs no ND 	 */
switch|switch
condition|(
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ARCNET
case|:
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_FDDI
case|:
case|case
name|IFT_IEEE1394
case|:
case|case
name|IFT_L2VLAN
case|:
case|case
name|IFT_IEEE80211
case|:
case|case
name|IFT_INFINIBAND
case|:
case|case
name|IFT_BRIDGE
case|:
case|case
name|IFT_PROPVIRTUAL
case|:
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add pernament ND6 link-layer record for given  * interface address.  *  * Very similar to IPv4 arp_ifinit(), but:  * 1) IPv6 DAD is performed in different place  * 2) It is called by IPv6 protocol stack in contrast to  * arp_ifinit() which is typically called in SIOCSIFADDR  * driver ioctl handler.  *  */
end_comment

begin_function
name|int
name|nd6_add_ifa_lle
parameter_list|(
name|struct
name|in6_ifaddr
modifier|*
name|ia
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|llentry
modifier|*
name|ln
decl_stmt|,
modifier|*
name|ln_tmp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|ifp
operator|=
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_ifp
expr_stmt|;
if|if
condition|(
name|nd6_need_cache
argument_list|(
name|ifp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_rtrequest
operator|=
name|nd6_rtrequest
expr_stmt|;
name|dst
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ia
operator|->
name|ia_addr
expr_stmt|;
name|ln
operator|=
name|lltable_alloc_entry
argument_list|(
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|LLE_IFADDR
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|IF_AFDATA_WLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|LLE_WLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
comment|/* Unlink any entry if exists */
name|ln_tmp
operator|=
name|lla_lookup
argument_list|(
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|LLE_EXCLUSIVE
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln_tmp
operator|!=
name|NULL
condition|)
name|lltable_unlink_entry
argument_list|(
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ln_tmp
argument_list|)
expr_stmt|;
name|lltable_link_entry
argument_list|(
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|IF_AFDATA_WUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln_tmp
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_INVOKE
argument_list|(
name|lle_event
argument_list|,
name|ln_tmp
argument_list|,
name|LLENTRY_EXPIRED
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|lle_event
argument_list|,
name|ln
argument_list|,
name|LLENTRY_RESOLVED
argument_list|)
expr_stmt|;
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln_tmp
operator|!=
name|NULL
condition|)
name|llentry_free
argument_list|(
name|ln_tmp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Removes either all lle entries for given @ia, or lle  * corresponding to @ia address.  */
end_comment

begin_function
name|void
name|nd6_rem_ifa_lle
parameter_list|(
name|struct
name|in6_ifaddr
modifier|*
name|ia
parameter_list|,
name|int
name|all
parameter_list|)
block|{
name|struct
name|sockaddr_in6
name|mask
decl_stmt|,
name|addr
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|saddr
decl_stmt|,
modifier|*
name|smask
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_ifp
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|ia
operator|->
name|ia_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ia
operator|->
name|ia_addr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mask
argument_list|,
operator|&
name|ia
operator|->
name|ia_prefixmask
argument_list|,
sizeof|sizeof
argument_list|(
name|ia
operator|->
name|ia_prefixmask
argument_list|)
argument_list|)
expr_stmt|;
name|saddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
expr_stmt|;
name|smask
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|all
operator|!=
literal|0
condition|)
name|lltable_prefix_free
argument_list|(
name|AF_INET6
argument_list|,
name|saddr
argument_list|,
name|smask
argument_list|,
name|LLE_STATIC
argument_list|)
expr_stmt|;
else|else
name|lltable_delete_addr
argument_list|(
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|LLE_IFADDR
argument_list|,
name|saddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_llinfo_pqueue
parameter_list|(
name|struct
name|llentry
modifier|*
name|ln
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_hold
decl_stmt|,
modifier|*
name|m_hold_next
decl_stmt|;
for|for
control|(
name|m_hold
operator|=
name|ln
operator|->
name|la_hold
init|;
name|m_hold
condition|;
name|m_hold
operator|=
name|m_hold_next
control|)
block|{
name|m_hold_next
operator|=
name|m_hold
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|m_hold
argument_list|)
expr_stmt|;
block|}
name|ln
operator|->
name|la_hold
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|nd6_sysctl_drlist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nd6_sysctl_prlist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet6_icmp6
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet6_icmp6
argument_list|,
name|ICMPV6CTL_ND6_DRLIST
argument_list|,
name|nd6_drlist
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|nd6_sysctl_drlist
argument_list|,
literal|"S,in6_defrouter"
argument_list|,
literal|"NDP default router list"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet6_icmp6
argument_list|,
name|ICMPV6CTL_ND6_PRLIST
argument_list|,
name|nd6_prlist
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|nd6_sysctl_prlist
argument_list|,
literal|"S,in6_prefix"
argument_list|,
literal|"NDP prefix list"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet6_icmp6
argument_list|,
name|ICMPV6CTL_ND6_MAXQLEN
argument_list|,
name|nd6_maxqueuelen
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|nd6_maxqueuelen
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet6_icmp6
argument_list|,
name|OID_AUTO
argument_list|,
name|nd6_gctimer
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|nd6_gctimer
argument_list|)
argument_list|,
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|nd6_sysctl_drlist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|in6_defrouter
name|d
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|.
name|rtaddr
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|d
operator|.
name|rtaddr
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|d
operator|.
name|rtaddr
argument_list|)
expr_stmt|;
name|ND6_RLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|dr
argument_list|,
argument|&V_nd_defrouter
argument_list|,
argument|dr_entry
argument_list|)
block|{
name|d
operator|.
name|rtaddr
operator|.
name|sin6_addr
operator|=
name|dr
operator|->
name|rtaddr
expr_stmt|;
name|error
operator|=
name|sa6_recoverscope
argument_list|(
operator|&
name|d
operator|.
name|rtaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|d
operator|.
name|flags
operator|=
name|dr
operator|->
name|raflags
expr_stmt|;
name|d
operator|.
name|rtlifetime
operator|=
name|dr
operator|->
name|rtlifetime
expr_stmt|;
name|d
operator|.
name|expire
operator|=
name|dr
operator|->
name|expire
operator|+
operator|(
name|time_second
operator|-
name|time_uptime
operator|)
expr_stmt|;
name|d
operator|.
name|if_index
operator|=
name|dr
operator|->
name|ifp
operator|->
name|if_index
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
name|ND6_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nd6_sysctl_prlist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|in6_prefix
name|p
decl_stmt|;
name|struct
name|sockaddr_in6
name|s6
decl_stmt|;
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|;
name|struct
name|nd_pfxrouter
modifier|*
name|pfr
decl_stmt|;
name|time_t
name|maxexpire
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|ip6buf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|origin
operator|=
name|PR_ORIG_RA
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|s6
argument_list|,
sizeof|sizeof
argument_list|(
name|s6
argument_list|)
argument_list|)
expr_stmt|;
name|s6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|s6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|s6
argument_list|)
expr_stmt|;
name|ND6_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pr
argument_list|,
argument|&V_nd_prefix
argument_list|,
argument|ndpr_entry
argument_list|)
block|{
name|p
operator|.
name|prefix
operator|=
name|pr
operator|->
name|ndpr_prefix
expr_stmt|;
if|if
condition|(
name|sa6_recoverscope
argument_list|(
operator|&
name|p
operator|.
name|prefix
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"scope error in prefix list (%s)\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6buf
argument_list|,
operator|&
name|p
operator|.
name|prefix
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: press on... */
block|}
name|p
operator|.
name|raflags
operator|=
name|pr
operator|->
name|ndpr_raf
expr_stmt|;
name|p
operator|.
name|prefixlen
operator|=
name|pr
operator|->
name|ndpr_plen
expr_stmt|;
name|p
operator|.
name|vltime
operator|=
name|pr
operator|->
name|ndpr_vltime
expr_stmt|;
name|p
operator|.
name|pltime
operator|=
name|pr
operator|->
name|ndpr_pltime
expr_stmt|;
name|p
operator|.
name|if_index
operator|=
name|pr
operator|->
name|ndpr_ifp
operator|->
name|if_index
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|ndpr_vltime
operator|==
name|ND6_INFINITE_LIFETIME
condition|)
name|p
operator|.
name|expire
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* XXX: we assume time_t is signed. */
name|maxexpire
operator|=
operator|(
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|time_t
operator|)
literal|1
operator|<<
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|maxexpire
argument_list|)
operator|*
literal|8
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|ndpr_vltime
operator|<
name|maxexpire
operator|-
name|pr
operator|->
name|ndpr_lastupdate
condition|)
name|p
operator|.
name|expire
operator|=
name|pr
operator|->
name|ndpr_lastupdate
operator|+
name|pr
operator|->
name|ndpr_vltime
operator|+
operator|(
name|time_second
operator|-
name|time_uptime
operator|)
expr_stmt|;
else|else
name|p
operator|.
name|expire
operator|=
name|maxexpire
expr_stmt|;
block|}
name|p
operator|.
name|refcnt
operator|=
name|pr
operator|->
name|ndpr_addrcnt
expr_stmt|;
name|p
operator|.
name|flags
operator|=
name|pr
operator|->
name|ndpr_stateflags
expr_stmt|;
name|p
operator|.
name|advrtrs
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pfr
argument_list|,
argument|&pr->ndpr_advrtrs
argument_list|,
argument|pfr_entry
argument_list|)
name|p
operator|.
name|advrtrs
operator|++
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|LIST_FOREACH
argument_list|(
argument|pfr
argument_list|,
argument|&pr->ndpr_advrtrs
argument_list|,
argument|pfr_entry
argument_list|)
block|{
name|s6
operator|.
name|sin6_addr
operator|=
name|pfr
operator|->
name|router
operator|->
name|rtaddr
expr_stmt|;
if|if
condition|(
name|sa6_recoverscope
argument_list|(
operator|&
name|s6
argument_list|)
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"scope error in prefix list (%s)\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6buf
argument_list|,
operator|&
name|pfr
operator|->
name|router
operator|->
name|rtaddr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|s6
argument_list|,
sizeof|sizeof
argument_list|(
name|s6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
name|ND6_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

