begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$KAME: nd6.c,v 1.144 2001/05/24 07:44:00 itojun Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/iso88025.h>
end_include

begin_include
include|#
directive|include
file|<net/fddi.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_kdtrace.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llatbl.h>
end_include

begin_define
define|#
directive|define
name|L3_ADDR_SIN6
parameter_list|(
name|le
parameter_list|)
value|((struct sockaddr_in6 *) L3_ADDR(le))
end_define

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/scope6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_ifattach.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/send.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_define
define|#
directive|define
name|ND6_SLOWTIMER_INTERVAL
value|(60 * 60)
end_define

begin_comment
comment|/* 1 hour */
end_comment

begin_define
define|#
directive|define
name|ND6_RECALC_REACHTM_INTERVAL
value|(60 * 120)
end_define

begin_comment
comment|/* 2 hours */
end_comment

begin_define
define|#
directive|define
name|SIN6
parameter_list|(
name|s
parameter_list|)
value|((const struct sockaddr_in6 *)(s))
end_define

begin_comment
comment|/* timer values */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_prune
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* walk list every 1 seconds */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_delay
argument_list|)
operator|=
literal|5
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* delay first probe time 5 second */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_umaxtries
argument_list|)
operator|=
literal|3
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* maximum unicast query */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_mmaxtries
argument_list|)
operator|=
literal|3
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* maximum multicast query */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_useloopback
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* use loopback interface for 					 * local traffic */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_gctimer
argument_list|)
operator|=
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 1 day: garbage 					 * collection timer */
end_comment

begin_comment
comment|/* preventing too many loops in ND option parsing */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_maxndopt
argument_list|)
operator|=
literal|10
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* max # of ND options allowed */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_maxnudhint
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* max # of subsequent upper 					 * layer hints */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_maxqueuelen
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* max pkts cached in unresolved 					 * ND entries */
end_comment

begin_define
define|#
directive|define
name|V_nd6_maxndopt
value|VNET(nd6_maxndopt)
end_define

begin_define
define|#
directive|define
name|V_nd6_maxqueuelen
value|VNET(nd6_maxqueuelen)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ND6_DEBUG
end_ifdef

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_debug
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_debug
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* for debugging? */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int nd6_inuse, nd6_allocated;
endif|#
directive|endif
end_endif

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|nd_drhead
argument_list|,
name|nd_defrouter
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|nd_prhead
argument_list|,
name|nd_prefix
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nd6_recalc_reachtm_interval
argument_list|)
operator|=
name|ND6_RECALC_REACHTM_INTERVAL
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_nd6_recalc_reachtm_interval
value|VNET(nd6_recalc_reachtm_interval)
end_define

begin_function_decl
name|int
function_decl|(
modifier|*
name|send_sendso_input_hook
function_decl|)
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nd6_is_new_addr_neighbor
parameter_list|(
name|struct
name|sockaddr_in6
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nd6_setmtu0
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|nd_ifinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nd6_slowtimo
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|regen_tmpaddr
parameter_list|(
name|struct
name|in6_ifaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|llentry
modifier|*
name|nd6_free
parameter_list|(
name|struct
name|llentry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nd6_llinfo_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_llinfo_pqueue
parameter_list|(
name|struct
name|llentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nd6_rtrequest
parameter_list|(
name|int
parameter_list|,
name|struct
name|rtentry
modifier|*
parameter_list|,
name|struct
name|rt_addrinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|callout
argument_list|,
name|nd6_slowtimo_ch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_nd6_slowtimo_ch
value|VNET(nd6_slowtimo_ch)
end_define

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|callout
argument_list|,
name|nd6_timer_ch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|nd6_init
parameter_list|(
name|void
parameter_list|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|V_nd_prefix
argument_list|)
expr_stmt|;
comment|/* initialization of the default router list */
name|TAILQ_INIT
argument_list|(
operator|&
name|V_nd_defrouter
argument_list|)
expr_stmt|;
comment|/* start timer */
name|callout_init
argument_list|(
operator|&
name|V_nd6_slowtimo_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|V_nd6_slowtimo_ch
argument_list|,
name|ND6_SLOWTIMER_INTERVAL
operator|*
name|hz
argument_list|,
name|nd6_slowtimo
argument_list|,
name|curvnet
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE
end_ifdef

begin_function
name|void
name|nd6_destroy
parameter_list|()
block|{
name|callout_drain
argument_list|(
operator|&
name|V_nd6_slowtimo_ch
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|V_nd6_timer_ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|nd_ifinfo
modifier|*
name|nd6_ifattach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|nd_ifinfo
modifier|*
name|nd
decl_stmt|;
name|nd
operator|=
operator|(
expr|struct
name|nd_ifinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nd
argument_list|)
argument_list|,
name|M_IP6NDP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|nd
operator|->
name|initialized
operator|=
literal|1
expr_stmt|;
name|nd
operator|->
name|chlim
operator|=
name|IPV6_DEFHLIM
expr_stmt|;
name|nd
operator|->
name|basereachable
operator|=
name|REACHABLE_TIME
expr_stmt|;
name|nd
operator|->
name|reachable
operator|=
name|ND_COMPUTE_RTIME
argument_list|(
name|nd
operator|->
name|basereachable
argument_list|)
expr_stmt|;
name|nd
operator|->
name|retrans
operator|=
name|RETRANS_TIMER
expr_stmt|;
name|nd
operator|->
name|flags
operator|=
name|ND6_IFF_PERFORMNUD
expr_stmt|;
comment|/* A loopback interface always has ND6_IFF_AUTO_LINKLOCAL. 	 * XXXHRS: Clear ND6_IFF_AUTO_LINKLOCAL on an IFT_BRIDGE interface by 	 * default regardless of the V_ip6_auto_linklocal configuration to 	 * give a reasonable default behavior. 	 */
if|if
condition|(
operator|(
name|V_ip6_auto_linklocal
operator|&&
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_BRIDGE
operator|)
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
condition|)
name|nd
operator|->
name|flags
operator||=
name|ND6_IFF_AUTO_LINKLOCAL
expr_stmt|;
comment|/* 	 * A loopback interface does not need to accept RTADV. 	 * XXXHRS: Clear ND6_IFF_ACCEPT_RTADV on an IFT_BRIDGE interface by 	 * default regardless of the V_ip6_accept_rtadv configuration to 	 * prevent the interface from accepting RA messages arrived 	 * on one of the member interfaces with ND6_IFF_ACCEPT_RTADV. 	 */
if|if
condition|(
name|V_ip6_accept_rtadv
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_BRIDGE
operator|)
condition|)
name|nd
operator|->
name|flags
operator||=
name|ND6_IFF_ACCEPT_RTADV
expr_stmt|;
if|if
condition|(
name|V_ip6_no_radr
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
condition|)
name|nd
operator|->
name|flags
operator||=
name|ND6_IFF_NO_RADR
expr_stmt|;
comment|/* XXX: we cannot call nd6_setmtu since ifp is not fully initialized */
name|nd6_setmtu0
argument_list|(
name|ifp
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
name|nd
return|;
block|}
end_function

begin_function
name|void
name|nd6_ifdetach
parameter_list|(
name|struct
name|nd_ifinfo
modifier|*
name|nd
parameter_list|)
block|{
name|free
argument_list|(
name|nd
argument_list|,
name|M_IP6NDP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset ND level link MTU. This function is called when the physical MTU  * changes, which means we might have to adjust the ND level MTU.  */
end_comment

begin_function
name|void
name|nd6_setmtu
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|nd6_setmtu0
argument_list|(
name|ifp
argument_list|,
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX todo: do not maintain copy of ifp->if_mtu in ndi->maxmtu */
end_comment

begin_function
name|void
name|nd6_setmtu0
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|nd_ifinfo
modifier|*
name|ndi
parameter_list|)
block|{
name|u_int32_t
name|omaxmtu
decl_stmt|;
name|omaxmtu
operator|=
name|ndi
operator|->
name|maxmtu
expr_stmt|;
switch|switch
condition|(
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ARCNET
case|:
name|ndi
operator|->
name|maxmtu
operator|=
name|MIN
argument_list|(
name|ARC_PHDS_MAXMTU
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
comment|/* RFC2497 */
break|break;
case|case
name|IFT_FDDI
case|:
name|ndi
operator|->
name|maxmtu
operator|=
name|MIN
argument_list|(
name|FDDIIPMTU
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
comment|/* RFC2467 */
break|break;
case|case
name|IFT_ISO88025
case|:
name|ndi
operator|->
name|maxmtu
operator|=
name|MIN
argument_list|(
name|ISO88025_MAX_MTU
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ndi
operator|->
name|maxmtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
break|break;
block|}
comment|/* 	 * Decreasing the interface MTU under IPV6 minimum MTU may cause 	 * undesirable situation.  We thus notify the operator of the change 	 * explicitly.  The check for omaxmtu is necessary to restrict the 	 * log to the case of changing the MTU, not initializing it. 	 */
if|if
condition|(
name|omaxmtu
operator|>=
name|IPV6_MMTU
operator|&&
name|ndi
operator|->
name|maxmtu
operator|<
name|IPV6_MMTU
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"nd6_setmtu0: "
literal|"new link MTU on %s (%lu) is too small for IPv6\n"
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ndi
operator|->
name|maxmtu
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ndi
operator|->
name|maxmtu
operator|>
name|V_in6_maxmtu
condition|)
name|in6_setmaxmtu
argument_list|()
expr_stmt|;
comment|/* check all interfaces just in case */
block|}
end_function

begin_function
name|void
name|nd6_option_init
parameter_list|(
name|void
modifier|*
name|opt
parameter_list|,
name|int
name|icmp6len
parameter_list|,
name|union
name|nd_opts
modifier|*
name|ndopts
parameter_list|)
block|{
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_search
operator|=
operator|(
expr|struct
name|nd_opt_hdr
operator|*
operator|)
name|opt
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_last
operator|=
operator|(
expr|struct
name|nd_opt_hdr
operator|*
operator|)
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
name|opt
operator|)
operator|+
name|icmp6len
operator|)
expr_stmt|;
if|if
condition|(
name|icmp6len
operator|==
literal|0
condition|)
block|{
name|ndopts
operator|->
name|nd_opts_done
operator|=
literal|1
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_search
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Take one ND option.  */
end_comment

begin_function
name|struct
name|nd_opt_hdr
modifier|*
name|nd6_option
parameter_list|(
name|union
name|nd_opts
modifier|*
name|ndopts
parameter_list|)
block|{
name|struct
name|nd_opt_hdr
modifier|*
name|nd_opt
decl_stmt|;
name|int
name|olen
decl_stmt|;
name|KASSERT
argument_list|(
name|ndopts
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ndopts == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ndopts
operator|->
name|nd_opts_last
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: uninitialized ndopts"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_search
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_done
condition|)
return|return
name|NULL
return|;
name|nd_opt
operator|=
name|ndopts
operator|->
name|nd_opts_search
expr_stmt|;
comment|/* make sure nd_opt_len is inside the buffer */
if|if
condition|(
operator|(
name|caddr_t
operator|)
operator|&
name|nd_opt
operator|->
name|nd_opt_len
operator|>=
operator|(
name|caddr_t
operator|)
name|ndopts
operator|->
name|nd_opts_last
condition|)
block|{
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|olen
operator|=
name|nd_opt
operator|->
name|nd_opt_len
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|olen
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Message validation requires that all included 		 * options have a length that is greater than zero. 		 */
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ndopts
operator|->
name|nd_opts_search
operator|=
operator|(
expr|struct
name|nd_opt_hdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|nd_opt
operator|+
name|olen
operator|)
expr_stmt|;
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_search
operator|>
name|ndopts
operator|->
name|nd_opts_last
condition|)
block|{
comment|/* option overruns the end of buffer, invalid */
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_search
operator|==
name|ndopts
operator|->
name|nd_opts_last
condition|)
block|{
comment|/* reached the end of options chain */
name|ndopts
operator|->
name|nd_opts_done
operator|=
literal|1
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_search
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|nd_opt
return|;
block|}
end_function

begin_comment
comment|/*  * Parse multiple ND options.  * This function is much easier to use, for ND routines that do not need  * multiple options of the same type.  */
end_comment

begin_function
name|int
name|nd6_options
parameter_list|(
name|union
name|nd_opts
modifier|*
name|ndopts
parameter_list|)
block|{
name|struct
name|nd_opt_hdr
modifier|*
name|nd_opt
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
name|ndopts
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ndopts == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ndopts
operator|->
name|nd_opts_last
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: uninitialized ndopts"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_search
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|nd_opt
operator|=
name|nd6_option
argument_list|(
name|ndopts
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd_opt
operator|==
name|NULL
operator|&&
name|ndopts
operator|->
name|nd_opts_last
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Message validation requires that all included 			 * options have a length that is greater than zero. 			 */
name|ICMP6STAT_INC
argument_list|(
name|icp6s_nd_badopt
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|nd_opt
operator|==
name|NULL
condition|)
goto|goto
name|skip1
goto|;
switch|switch
condition|(
name|nd_opt
operator|->
name|nd_opt_type
condition|)
block|{
case|case
name|ND_OPT_SOURCE_LINKADDR
case|:
case|case
name|ND_OPT_TARGET_LINKADDR
case|:
case|case
name|ND_OPT_MTU
case|:
case|case
name|ND_OPT_REDIRECTED_HEADER
case|:
if|if
condition|(
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
condition|)
block|{
name|nd6log
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"duplicated ND6 option found (type=%d)\n"
operator|,
name|nd_opt
operator|->
name|nd_opt_type
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX bark? */
block|}
else|else
block|{
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
operator|=
name|nd_opt
expr_stmt|;
block|}
break|break;
case|case
name|ND_OPT_PREFIX_INFORMATION
case|:
if|if
condition|(
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
operator|==
literal|0
condition|)
block|{
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
operator|=
name|nd_opt
expr_stmt|;
block|}
name|ndopts
operator|->
name|nd_opts_pi_end
operator|=
operator|(
expr|struct
name|nd_opt_prefix_info
operator|*
operator|)
name|nd_opt
expr_stmt|;
break|break;
comment|/* What about ND_OPT_ROUTE_INFO? RFC 4191 */
case|case
name|ND_OPT_RDNSS
case|:
comment|/* RFC 6106 */
case|case
name|ND_OPT_DNSSL
case|:
comment|/* RFC 6106 */
comment|/* 			 * Silently ignore options we know and do not care about 			 * in the kernel. 			 */
break|break;
default|default:
comment|/* 			 * Unknown options must be silently ignored, 			 * to accomodate future extension to the protocol. 			 */
name|nd6log
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"nd6_options: unsupported option %d - "
literal|"option ignored\n"
operator|,
name|nd_opt
operator|->
name|nd_opt_type
operator|)
argument_list|)
expr_stmt|;
block|}
name|skip1
label|:
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|V_nd6_maxndopt
condition|)
block|{
name|ICMP6STAT_INC
argument_list|(
name|icp6s_nd_toomanyopt
argument_list|)
expr_stmt|;
name|nd6log
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"too many loop in nd opt\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_done
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ND6 timer routine to handle ND6 entries  */
end_comment

begin_function
name|void
name|nd6_llinfo_settimer_locked
parameter_list|(
name|struct
name|llentry
modifier|*
name|ln
parameter_list|,
name|long
name|tick
parameter_list|)
block|{
name|int
name|canceled
decl_stmt|;
name|LLE_WLOCK_ASSERT
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|tick
operator|<
literal|0
condition|)
block|{
name|ln
operator|->
name|la_expire
operator|=
literal|0
expr_stmt|;
name|ln
operator|->
name|ln_ntick
operator|=
literal|0
expr_stmt|;
name|canceled
operator|=
name|callout_stop
argument_list|(
operator|&
name|ln
operator|->
name|ln_timer_ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|->
name|la_expire
operator|=
name|time_uptime
operator|+
name|tick
operator|/
name|hz
expr_stmt|;
name|LLE_ADDREF
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|tick
operator|>
name|INT_MAX
condition|)
block|{
name|ln
operator|->
name|ln_ntick
operator|=
name|tick
operator|-
name|INT_MAX
expr_stmt|;
name|canceled
operator|=
name|callout_reset
argument_list|(
operator|&
name|ln
operator|->
name|ln_timer_ch
argument_list|,
name|INT_MAX
argument_list|,
name|nd6_llinfo_timer
argument_list|,
name|ln
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|->
name|ln_ntick
operator|=
literal|0
expr_stmt|;
name|canceled
operator|=
name|callout_reset
argument_list|(
operator|&
name|ln
operator|->
name|ln_timer_ch
argument_list|,
name|tick
argument_list|,
name|nd6_llinfo_timer
argument_list|,
name|ln
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|canceled
condition|)
name|LLE_REMREF
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nd6_llinfo_settimer
parameter_list|(
name|struct
name|llentry
modifier|*
name|ln
parameter_list|,
name|long
name|tick
parameter_list|)
block|{
name|LLE_WLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
name|tick
argument_list|)
expr_stmt|;
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nd6_llinfo_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|llentry
modifier|*
name|ln
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|dst
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|nd_ifinfo
modifier|*
name|ndi
init|=
name|NULL
decl_stmt|;
name|KASSERT
argument_list|(
name|arg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: arg NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ln
operator|=
operator|(
expr|struct
name|llentry
operator|*
operator|)
name|arg
expr_stmt|;
name|LLE_WLOCK_ASSERT
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|ln
operator|->
name|lle_tbl
operator|->
name|llt_ifp
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_ntick
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ln
operator|->
name|ln_ntick
operator|>
name|INT_MAX
condition|)
block|{
name|ln
operator|->
name|ln_ntick
operator|-=
name|INT_MAX
expr_stmt|;
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|->
name|ln_ntick
operator|=
literal|0
expr_stmt|;
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
name|ln
operator|->
name|ln_ntick
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|ndi
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|&
name|L3_ADDR_SIN6
argument_list|(
name|ln
argument_list|)
operator|->
name|sin6_addr
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|la_flags
operator|&
name|LLE_STATIC
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|ln
operator|->
name|la_flags
operator|&
name|LLE_DELETED
condition|)
block|{
operator|(
name|void
operator|)
name|nd6_free
argument_list|(
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ln
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|ln
operator|->
name|ln_state
condition|)
block|{
case|case
name|ND6_LLINFO_INCOMPLETE
case|:
if|if
condition|(
name|ln
operator|->
name|la_asked
operator|<
name|V_nd6_mmaxtries
condition|)
block|{
name|ln
operator|->
name|la_asked
operator|++
expr_stmt|;
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|ndi
operator|->
name|retrans
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|nd6_ns_output
argument_list|(
name|ifp
argument_list|,
name|NULL
argument_list|,
name|dst
argument_list|,
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LLE_WLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|ln
operator|->
name|la_hold
decl_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
comment|/* 				 * assuming every packet in la_hold has the 				 * same IP header.  Send error after unlock. 				 */
name|m0
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|ln
operator|->
name|la_hold
operator|=
name|m0
expr_stmt|;
name|clear_llinfo_pqueue
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
name|EVENTHANDLER_INVOKE
argument_list|(
name|lle_event
argument_list|,
name|ln
argument_list|,
name|LLENTRY_TIMEDOUT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nd6_free
argument_list|(
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ln
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|icmp6_error2
argument_list|(
name|m
argument_list|,
name|ICMP6_DST_UNREACH
argument_list|,
name|ICMP6_DST_UNREACH_ADDR
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ND6_LLINFO_REACHABLE
case|:
if|if
condition|(
operator|!
name|ND6_LLINFO_PERMANENT
argument_list|(
name|ln
argument_list|)
condition|)
block|{
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_STALE
expr_stmt|;
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|V_nd6_gctimer
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ND6_LLINFO_STALE
case|:
comment|/* Garbage Collection(RFC 2461 5.3) */
if|if
condition|(
operator|!
name|ND6_LLINFO_PERMANENT
argument_list|(
name|ln
argument_list|)
condition|)
block|{
name|EVENTHANDLER_INVOKE
argument_list|(
name|lle_event
argument_list|,
name|ln
argument_list|,
name|LLENTRY_EXPIRED
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nd6_free
argument_list|(
name|ln
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ln
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|ND6_LLINFO_DELAY
case|:
if|if
condition|(
name|ndi
operator|&&
operator|(
name|ndi
operator|->
name|flags
operator|&
name|ND6_IFF_PERFORMNUD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We need NUD */
name|ln
operator|->
name|la_asked
operator|=
literal|1
expr_stmt|;
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_PROBE
expr_stmt|;
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|ndi
operator|->
name|retrans
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|nd6_ns_output
argument_list|(
name|ifp
argument_list|,
name|dst
argument_list|,
name|dst
argument_list|,
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LLE_WLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_STALE
expr_stmt|;
comment|/* XXX */
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|V_nd6_gctimer
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ND6_LLINFO_PROBE
case|:
if|if
condition|(
name|ln
operator|->
name|la_asked
operator|<
name|V_nd6_umaxtries
condition|)
block|{
name|ln
operator|->
name|la_asked
operator|++
expr_stmt|;
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|ndi
operator|->
name|retrans
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|nd6_ns_output
argument_list|(
name|ifp
argument_list|,
name|dst
argument_list|,
name|dst
argument_list|,
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LLE_WLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EVENTHANDLER_INVOKE
argument_list|(
name|lle_event
argument_list|,
name|ln
argument_list|,
name|LLENTRY_EXPIRED
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nd6_free
argument_list|(
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ln
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: paths in a dark night can be confusing: %d"
argument_list|,
name|__func__
argument_list|,
name|ln
operator|->
name|ln_state
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
name|LLE_FREE_LOCKED
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ND6 timer routine to expire default route list and prefix list  */
end_comment

begin_function
name|void
name|nd6_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|CURVNET_SET
argument_list|(
operator|(
expr|struct
name|vnet
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|,
modifier|*
name|ndr
decl_stmt|;
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|,
modifier|*
name|npr
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|,
modifier|*
name|nia6
decl_stmt|;
name|callout_reset
argument_list|(
operator|&
name|V_nd6_timer_ch
argument_list|,
name|V_nd6_prune
operator|*
name|hz
argument_list|,
name|nd6_timer
argument_list|,
name|curvnet
argument_list|)
expr_stmt|;
comment|/* expire default router list */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|dr
argument_list|,
argument|&V_nd_defrouter
argument_list|,
argument|dr_entry
argument_list|,
argument|ndr
argument_list|)
block|{
if|if
condition|(
name|dr
operator|->
name|expire
operator|&&
name|dr
operator|->
name|expire
operator|<
name|time_uptime
condition|)
name|defrtrlist_del
argument_list|(
name|dr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * expire interface addresses. 	 * in the past the loop was inside prefix expiry processing. 	 * However, from a stricter speci-confrmance standpoint, we should 	 * rather separate address lifetimes and prefix lifetimes. 	 * 	 * XXXRW: in6_ifaddrhead locking. 	 */
name|addrloop
label|:
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ia6
argument_list|,
argument|&V_in6_ifaddrhead
argument_list|,
argument|ia_link
argument_list|,
argument|nia6
argument_list|)
block|{
comment|/* check address lifetime */
if|if
condition|(
name|IFA6_IS_INVALID
argument_list|(
name|ia6
argument_list|)
condition|)
block|{
name|int
name|regen
init|=
literal|0
decl_stmt|;
comment|/* 			 * If the expiring address is temporary, try 			 * regenerating a new one.  This would be useful when 			 * we suspended a laptop PC, then turned it on after a 			 * period that could invalidate all temporary 			 * addresses.  Although we may have to restart the 			 * loop (see below), it must be after purging the 			 * address.  Otherwise, we'd see an infinite loop of 			 * regeneration. 			 */
if|if
condition|(
name|V_ip6_use_tempaddr
operator|&&
operator|(
name|ia6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_TEMPORARY
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|regen_tmpaddr
argument_list|(
name|ia6
argument_list|)
operator|==
literal|0
condition|)
name|regen
operator|=
literal|1
expr_stmt|;
block|}
name|in6_purgeaddr
argument_list|(
operator|&
name|ia6
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
if|if
condition|(
name|regen
condition|)
goto|goto
name|addrloop
goto|;
comment|/* XXX: see below */
block|}
elseif|else
if|if
condition|(
name|IFA6_IS_DEPRECATED
argument_list|(
name|ia6
argument_list|)
condition|)
block|{
name|int
name|oldflags
init|=
name|ia6
operator|->
name|ia6_flags
decl_stmt|;
name|ia6
operator|->
name|ia6_flags
operator||=
name|IN6_IFF_DEPRECATED
expr_stmt|;
comment|/* 			 * If a temporary address has just become deprecated, 			 * regenerate a new one if possible. 			 */
if|if
condition|(
name|V_ip6_use_tempaddr
operator|&&
operator|(
name|ia6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_TEMPORARY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|oldflags
operator|&
name|IN6_IFF_DEPRECATED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|regen_tmpaddr
argument_list|(
name|ia6
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * A new temporary address is 					 * generated. 					 * XXX: this means the address chain 					 * has changed while we are still in 					 * the loop.  Although the change 					 * would not cause disaster (because 					 * it's not a deletion, but an 					 * addition,) we'd rather restart the 					 * loop just for safety.  Or does this 					 * significantly reduce performance?? 					 */
goto|goto
name|addrloop
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * A new RA might have made a deprecated address 			 * preferred. 			 */
name|ia6
operator|->
name|ia6_flags
operator|&=
operator|~
name|IN6_IFF_DEPRECATED
expr_stmt|;
block|}
block|}
comment|/* expire prefix list */
name|LIST_FOREACH_SAFE
argument_list|(
argument|pr
argument_list|,
argument|&V_nd_prefix
argument_list|,
argument|ndpr_entry
argument_list|,
argument|npr
argument_list|)
block|{
comment|/* 		 * check prefix lifetime. 		 * since pltime is just for autoconf, pltime processing for 		 * prefix is not necessary. 		 */
if|if
condition|(
name|pr
operator|->
name|ndpr_vltime
operator|!=
name|ND6_INFINITE_LIFETIME
operator|&&
name|time_uptime
operator|-
name|pr
operator|->
name|ndpr_lastupdate
operator|>
name|pr
operator|->
name|ndpr_vltime
condition|)
block|{
comment|/* 			 * address expiration and prefix expiration are 			 * separate.  NEVER perform in6_purgeaddr here. 			 */
name|prelist_remove
argument_list|(
name|pr
argument_list|)
expr_stmt|;
block|}
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ia6 - deprecated/invalidated temporary address  */
end_comment

begin_function
specifier|static
name|int
name|regen_tmpaddr
parameter_list|(
name|struct
name|in6_ifaddr
modifier|*
name|ia6
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|public_ifa6
init|=
name|NULL
decl_stmt|;
name|ifp
operator|=
name|ia6
operator|->
name|ia_ifa
operator|.
name|ifa_ifp
expr_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|it6
decl_stmt|;
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|it6
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa
expr_stmt|;
comment|/* ignore no autoconf addresses. */
if|if
condition|(
operator|(
name|it6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_AUTOCONF
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* ignore autoconf addresses with different prefixes. */
if|if
condition|(
name|it6
operator|->
name|ia6_ndpr
operator|==
name|NULL
operator|||
name|it6
operator|->
name|ia6_ndpr
operator|!=
name|ia6
operator|->
name|ia6_ndpr
condition|)
continue|continue;
comment|/* 		 * Now we are looking at an autoconf address with the same 		 * prefix as ours.  If the address is temporary and is still 		 * preferred, do not create another one.  It would be rare, but 		 * could happen, for example, when we resume a laptop PC after 		 * a long period. 		 */
if|if
condition|(
operator|(
name|it6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_TEMPORARY
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|IFA6_IS_DEPRECATED
argument_list|(
name|it6
argument_list|)
condition|)
block|{
name|public_ifa6
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* 		 * This is a public autoconf address that has the same prefix 		 * as ours.  If it is preferred, keep it.  We can't break the 		 * loop here, because there may be a still-preferred temporary 		 * address with the prefix. 		 */
if|if
condition|(
operator|!
name|IFA6_IS_DEPRECATED
argument_list|(
name|it6
argument_list|)
condition|)
name|public_ifa6
operator|=
name|it6
expr_stmt|;
if|if
condition|(
name|public_ifa6
operator|!=
name|NULL
condition|)
name|ifa_ref
argument_list|(
operator|&
name|public_ifa6
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|public_ifa6
operator|!=
name|NULL
condition|)
block|{
name|int
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|in6_tmpifadd
argument_list|(
name|public_ifa6
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifa_free
argument_list|(
operator|&
name|public_ifa6
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"regen_tmpaddr: failed to create a new"
literal|" tmp addr,errno=%d\n"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ifa_free
argument_list|(
operator|&
name|public_ifa6
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Nuke neighbor cache/prefix/default router management table, right before  * ifp goes away.  */
end_comment

begin_function
name|void
name|nd6_purge
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|,
modifier|*
name|ndr
decl_stmt|;
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|,
modifier|*
name|npr
decl_stmt|;
comment|/* 	 * Nuke default router list entries toward ifp. 	 * We defer removal of default router list entries that is installed 	 * in the routing table, in order to keep additional side effects as 	 * small as possible. 	 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|dr
argument_list|,
argument|&V_nd_defrouter
argument_list|,
argument|dr_entry
argument_list|,
argument|ndr
argument_list|)
block|{
if|if
condition|(
name|dr
operator|->
name|installed
condition|)
continue|continue;
if|if
condition|(
name|dr
operator|->
name|ifp
operator|==
name|ifp
condition|)
name|defrtrlist_del
argument_list|(
name|dr
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|dr
argument_list|,
argument|&V_nd_defrouter
argument_list|,
argument|dr_entry
argument_list|,
argument|ndr
argument_list|)
block|{
if|if
condition|(
operator|!
name|dr
operator|->
name|installed
condition|)
continue|continue;
if|if
condition|(
name|dr
operator|->
name|ifp
operator|==
name|ifp
condition|)
name|defrtrlist_del
argument_list|(
name|dr
argument_list|)
expr_stmt|;
block|}
comment|/* Nuke prefix list entries toward ifp */
name|LIST_FOREACH_SAFE
argument_list|(
argument|pr
argument_list|,
argument|&V_nd_prefix
argument_list|,
argument|ndpr_entry
argument_list|,
argument|npr
argument_list|)
block|{
if|if
condition|(
name|pr
operator|->
name|ndpr_ifp
operator|==
name|ifp
condition|)
block|{
comment|/* 			 * Because if_detach() does *not* release prefixes 			 * while purging addresses the reference count will 			 * still be above zero. We therefore reset it to 			 * make sure that the prefix really gets purged. 			 */
name|pr
operator|->
name|ndpr_refcnt
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Previously, pr->ndpr_addr is removed as well, 			 * but I strongly believe we don't have to do it. 			 * nd6_purge() is only called from in6_ifdetach(), 			 * which removes all the associated interface addresses 			 * by itself. 			 * (jinmei@kame.net 20010129) 			 */
name|prelist_remove
argument_list|(
name|pr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* cancel default outgoing interface setting */
if|if
condition|(
name|V_nd6_defifindex
operator|==
name|ifp
operator|->
name|if_index
condition|)
name|nd6_setdefaultiface
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_ACCEPT_RTADV
condition|)
block|{
comment|/* Refresh default router list. */
name|defrouter_select
argument_list|()
expr_stmt|;
block|}
comment|/* XXXXX 	 * We do not nuke the neighbor cache entries here any more 	 * because the neighbor cache is kept in if_afdata[AF_INET6]. 	 * nd6_purge() is invoked by in6_ifdetach() which is called 	 * from if_detach() where everything gets purged. So let 	 * in6_domifdetach() do the actual L2 table purging work. 	 */
block|}
end_function

begin_comment
comment|/*   * the caller acquires and releases the lock on the lltbls  * Returns the llentry locked  */
end_comment

begin_function
name|struct
name|llentry
modifier|*
name|nd6_lookup
parameter_list|(
name|struct
name|in6_addr
modifier|*
name|addr6
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|struct
name|llentry
modifier|*
name|ln
decl_stmt|;
name|int
name|llflags
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|=
operator|*
name|addr6
expr_stmt|;
name|IF_AFDATA_LOCK_ASSERT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|llflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ND6_CREATE
condition|)
name|llflags
operator||=
name|LLE_CREATE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ND6_EXCLUSIVE
condition|)
name|llflags
operator||=
name|LLE_EXCLUSIVE
expr_stmt|;
name|ln
operator|=
name|lla_lookup
argument_list|(
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|llflags
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ln
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|llflags
operator|&
name|LLE_CREATE
operator|)
condition|)
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_NOSTATE
expr_stmt|;
return|return
operator|(
name|ln
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test whether a given IPv6 address is a neighbor or not, ignoring  * the actual neighbor cache.  The neighbor cache is ignored in order  * to not reenter the routing code from within itself.  */
end_comment

begin_function
specifier|static
name|int
name|nd6_is_new_addr_neighbor
parameter_list|(
name|struct
name|sockaddr_in6
modifier|*
name|addr
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|dstaddr
decl_stmt|;
comment|/* 	 * A link-local address is always a neighbor. 	 * XXX: a link does not necessarily specify a single interface. 	 */
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|addr
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in6
name|sin6_copy
decl_stmt|;
name|u_int32_t
name|zone
decl_stmt|;
comment|/* 		 * We need sin6_copy since sa6_recoverscope() may modify the 		 * content (XXX). 		 */
name|sin6_copy
operator|=
operator|*
name|addr
expr_stmt|;
if|if
condition|(
name|sa6_recoverscope
argument_list|(
operator|&
name|sin6_copy
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX: should be impossible */
if|if
condition|(
name|in6_setscope
argument_list|(
operator|&
name|sin6_copy
operator|.
name|sin6_addr
argument_list|,
name|ifp
argument_list|,
operator|&
name|zone
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sin6_copy
operator|.
name|sin6_scope_id
operator|==
name|zone
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the address matches one of our addresses, 	 * it should be a neighbor. 	 * If the address matches one of our on-link prefixes, it should be a 	 * neighbor. 	 */
name|LIST_FOREACH
argument_list|(
argument|pr
argument_list|,
argument|&V_nd_prefix
argument_list|,
argument|ndpr_entry
argument_list|)
block|{
if|if
condition|(
name|pr
operator|->
name|ndpr_ifp
operator|!=
name|ifp
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|pr
operator|->
name|ndpr_stateflags
operator|&
name|NDPRF_ONLINK
operator|)
condition|)
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
comment|/* Always use the default FIB here. */
name|rt
operator|=
name|in6_rtalloc1
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|pr
operator|->
name|ndpr_prefix
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|RT_DEFAULT_FIB
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 			 * This is the case where multiple interfaces 			 * have the same prefix, but only one is installed  			 * into the routing table and that prefix entry 			 * is not the one being examined here. In the case 			 * where RADIX_MPATH is enabled, multiple route 			 * entries (of the same rt_key value) will be  			 * installed because the interface addresses all 			 * differ. 			 */
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|pr
operator|->
name|ndpr_prefix
operator|.
name|sin6_addr
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt_key
argument_list|(
name|rt
argument_list|)
operator|)
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|RTFREE_LOCKED
argument_list|(
name|rt
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|RTFREE_LOCKED
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IN6_ARE_MASKED_ADDR_EQUAL
argument_list|(
operator|&
name|pr
operator|->
name|ndpr_prefix
operator|.
name|sin6_addr
argument_list|,
operator|&
name|addr
operator|->
name|sin6_addr
argument_list|,
operator|&
name|pr
operator|->
name|ndpr_mask
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If the address is assigned on the node of the other side of 	 * a p2p interface, the address should be a neighbor. 	 */
name|dstaddr
operator|=
name|ifa_ifwithdstaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstaddr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dstaddr
operator|->
name|ifa_ifp
operator|==
name|ifp
condition|)
block|{
name|ifa_free
argument_list|(
name|dstaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ifa_free
argument_list|(
name|dstaddr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the default router list is empty, all addresses are regarded 	 * as on-link, and thus, as a neighbor. 	 */
if|if
condition|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_ACCEPT_RTADV
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|V_nd_defrouter
argument_list|)
operator|&&
name|V_nd6_defifindex
operator|==
name|ifp
operator|->
name|if_index
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detect if a given IPv6 address identifies a neighbor on a given link.  * XXX: should take care of the destination of a p2p link?  */
end_comment

begin_function
name|int
name|nd6_is_addr_neighbor
parameter_list|(
name|struct
name|sockaddr_in6
modifier|*
name|addr
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|llentry
modifier|*
name|lle
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|IF_AFDATA_UNLOCK_ASSERT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd6_is_new_addr_neighbor
argument_list|(
name|addr
argument_list|,
name|ifp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Even if the address matches none of our addresses, it might be 	 * in the neighbor cache. 	 */
name|IF_AFDATA_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lle
operator|=
name|nd6_lookup
argument_list|(
operator|&
name|addr
operator|->
name|sin6_addr
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LLE_RUNLOCK
argument_list|(
name|lle
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
name|IF_AFDATA_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free an nd6 llinfo entry.  * Since the function would cause significant changes in the kernel, DO NOT  * make it global, unless you have a strong reason for the change, and are sure  * that the change is safe.  */
end_comment

begin_function
specifier|static
name|struct
name|llentry
modifier|*
name|nd6_free
parameter_list|(
name|struct
name|llentry
modifier|*
name|ln
parameter_list|,
name|int
name|gc
parameter_list|)
block|{
name|struct
name|llentry
modifier|*
name|next
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|LLE_WLOCK_ASSERT
argument_list|(
name|ln
argument_list|)
expr_stmt|;
comment|/* 	 * we used to have pfctlinput(PRC_HOSTDEAD) here. 	 * even though it is not harmful, it was not really necessary. 	 */
comment|/* cancel timer */
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|ln
operator|->
name|lle_tbl
operator|->
name|llt_ifp
expr_stmt|;
if|if
condition|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_ACCEPT_RTADV
condition|)
block|{
name|dr
operator|=
name|defrouter_lookup
argument_list|(
operator|&
name|L3_ADDR_SIN6
argument_list|(
name|ln
argument_list|)
operator|->
name|sin6_addr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|!=
name|NULL
operator|&&
name|dr
operator|->
name|expire
operator|&&
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_STALE
operator|&&
name|gc
condition|)
block|{
comment|/* 			 * If the reason for the deletion is just garbage 			 * collection, and the neighbor is an active default 			 * router, do not delete it.  Instead, reset the GC 			 * timer using the router's lifetime. 			 * Simply deleting the entry would affect default 			 * router selection, which is not necessarily a good 			 * thing, especially when we're using router preference 			 * values. 			 * XXX: the check for ln_state would be redundant, 			 *      but we intentionally keep it just in case. 			 */
if|if
condition|(
name|dr
operator|->
name|expire
operator|>
name|time_uptime
condition|)
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
operator|(
name|dr
operator|->
name|expire
operator|-
name|time_uptime
operator|)
operator|*
name|hz
argument_list|)
expr_stmt|;
else|else
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|V_nd6_gctimer
operator|*
name|hz
argument_list|)
expr_stmt|;
name|next
operator|=
name|LIST_NEXT
argument_list|(
name|ln
argument_list|,
name|lle_next
argument_list|)
expr_stmt|;
name|LLE_REMREF
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
if|if
condition|(
name|dr
condition|)
block|{
comment|/* 			 * Unreachablity of a router might affect the default 			 * router selection and on-link detection of advertised 			 * prefixes. 			 */
comment|/* 			 * Temporarily fake the state to choose a new default 			 * router and to perform on-link determination of 			 * prefixes correctly. 			 * Below the state will be set correctly, 			 * or the entry itself will be deleted. 			 */
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_INCOMPLETE
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|->
name|ln_router
operator|||
name|dr
condition|)
block|{
comment|/* 			 * We need to unlock to avoid a LOR with rt6_flush() with the 			 * rnh and for the calls to pfxlist_onlink_check() and 			 * defrouter_select() in the block further down for calls 			 * into nd6_lookup().  We still hold a ref. 			 */
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
comment|/* 			 * rt6_flush must be called whether or not the neighbor 			 * is in the Default Router List. 			 * See a corresponding comment in nd6_na_input(). 			 */
name|rt6_flush
argument_list|(
operator|&
name|L3_ADDR_SIN6
argument_list|(
name|ln
argument_list|)
operator|->
name|sin6_addr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dr
condition|)
block|{
comment|/* 			 * Since defrouter_select() does not affect the 			 * on-link determination and MIP6 needs the check 			 * before the default router selection, we perform 			 * the check now. 			 */
name|pfxlist_onlink_check
argument_list|()
expr_stmt|;
comment|/* 			 * Refresh default router list. 			 */
name|defrouter_select
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|->
name|ln_router
operator|||
name|dr
condition|)
name|LLE_WLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Before deleting the entry, remember the next entry as the 	 * return value.  We need this because pfxlist_onlink_check() above 	 * might have freed other entries (particularly the old next entry) as 	 * a side effect (XXX). 	 */
name|next
operator|=
name|LIST_NEXT
argument_list|(
name|ln
argument_list|,
name|lle_next
argument_list|)
expr_stmt|;
comment|/* 	 * Save to unlock. We still hold an extra reference and will not 	 * free(9) in llentry_free() if someone else holds one as well. 	 */
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|IF_AFDATA_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|LLE_WLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
comment|/* Guard against race with other llentry_free(). */
if|if
condition|(
name|ln
operator|->
name|la_flags
operator|&
name|LLE_LINKED
condition|)
block|{
name|LLE_REMREF
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|llentry_free
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
else|else
name|LLE_FREE_LOCKED
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|IF_AFDATA_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Upper-layer reachability hint for Neighbor Unreachability Detection.  *  * XXX cost-effective methods?  */
end_comment

begin_function
name|void
name|nd6_nud_hint
parameter_list|(
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|dst6
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|llentry
modifier|*
name|ln
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
operator|(
name|dst6
operator|==
name|NULL
operator|)
operator|||
operator|(
name|rt
operator|==
name|NULL
operator|)
condition|)
return|return;
name|ifp
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
name|IF_AFDATA_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ln
operator|=
name|nd6_lookup
argument_list|(
name|dst6
argument_list|,
name|ND6_EXCLUSIVE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|IF_AFDATA_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|<
name|ND6_LLINFO_REACHABLE
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * if we get upper-layer reachability confirmation many times, 	 * it is possible we have false information. 	 */
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|ln
operator|->
name|ln_byhint
operator|++
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_byhint
operator|>
name|V_nd6_maxnudhint
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_REACHABLE
expr_stmt|;
if|if
condition|(
operator|!
name|ND6_LLINFO_PERMANENT
argument_list|(
name|ln
argument_list|)
condition|)
block|{
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|ND_IFINFO
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|)
operator|->
name|reachable
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rejuvenate this function for routing operations related  * processing.  */
end_comment

begin_function
name|void
name|nd6_rtrequest
parameter_list|(
name|int
name|req
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|,
name|struct
name|rt_addrinfo
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|gateway
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|RT_LOCK_ASSERT
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|gateway
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
expr_stmt|;
name|ifp
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|RTM_ADD
case|:
break|break;
case|case
name|RTM_DELETE
case|:
if|if
condition|(
operator|!
name|ifp
condition|)
return|return;
comment|/* 		 * Only indirect routes are interesting. 		 */
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* 		 * check for default route 		 */
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|in6addr_any
argument_list|,
operator|&
name|SIN6
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|dr
operator|=
name|defrouter_lookup
argument_list|(
operator|&
name|gateway
operator|->
name|sin6_addr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|!=
name|NULL
condition|)
name|dr
operator|->
name|installed
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|int
name|nd6_ioctl
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|in6_drlist
modifier|*
name|drl
init|=
operator|(
expr|struct
name|in6_drlist
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|in6_oprlist
modifier|*
name|oprl
init|=
operator|(
expr|struct
name|in6_oprlist
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|in6_ndireq
modifier|*
name|ndi
init|=
operator|(
expr|struct
name|in6_ndireq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|in6_nbrinfo
modifier|*
name|nbi
init|=
operator|(
expr|struct
name|in6_nbrinfo
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|in6_ndifreq
modifier|*
name|ndif
init|=
operator|(
expr|struct
name|in6_ndifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|;
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_afdata
index|[
name|AF_INET6
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|EPFNOSUPPORT
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGDRLST_IN6
case|:
comment|/* 		 * obsolete API, use sysctl under net.inet6.icmp6 		 */
name|bzero
argument_list|(
name|drl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|drl
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|dr
argument_list|,
argument|&V_nd_defrouter
argument_list|,
argument|dr_entry
argument_list|)
block|{
if|if
condition|(
name|i
operator|>=
name|DRLSTSIZ
condition|)
break|break;
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|rtaddr
operator|=
name|dr
operator|->
name|rtaddr
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|rtaddr
argument_list|)
expr_stmt|;
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|dr
operator|->
name|flags
expr_stmt|;
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|rtlifetime
operator|=
name|dr
operator|->
name|rtlifetime
expr_stmt|;
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|expire
operator|=
name|dr
operator|->
name|expire
operator|+
operator|(
name|time_second
operator|-
name|time_uptime
operator|)
expr_stmt|;
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|if_index
operator|=
name|dr
operator|->
name|ifp
operator|->
name|if_index
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SIOCGPRLST_IN6
case|:
comment|/* 		 * obsolete API, use sysctl under net.inet6.icmp6 		 * 		 * XXX the structure in6_prlist was changed in backward- 		 * incompatible manner.  in6_oprlist is used for SIOCGPRLST_IN6, 		 * in6_prlist is used for nd6_sysctl() - fill_prlist(). 		 */
comment|/* 		 * XXX meaning of fields, especialy "raflags", is very 		 * differnet between RA prefix list and RR/static prefix list. 		 * how about separating ioctls into two? 		 */
name|bzero
argument_list|(
name|oprl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|oprl
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pr
argument_list|,
argument|&V_nd_prefix
argument_list|,
argument|ndpr_entry
argument_list|)
block|{
name|struct
name|nd_pfxrouter
modifier|*
name|pfr
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|PRLSTSIZ
condition|)
break|break;
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|prefix
operator|=
name|pr
operator|->
name|ndpr_prefix
operator|.
name|sin6_addr
expr_stmt|;
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|raflags
operator|=
name|pr
operator|->
name|ndpr_raf
expr_stmt|;
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|prefixlen
operator|=
name|pr
operator|->
name|ndpr_plen
expr_stmt|;
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|vltime
operator|=
name|pr
operator|->
name|ndpr_vltime
expr_stmt|;
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|pltime
operator|=
name|pr
operator|->
name|ndpr_pltime
expr_stmt|;
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|if_index
operator|=
name|pr
operator|->
name|ndpr_ifp
operator|->
name|if_index
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|ndpr_vltime
operator|==
name|ND6_INFINITE_LIFETIME
condition|)
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|expire
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|time_t
name|maxexpire
decl_stmt|;
comment|/* XXX: we assume time_t is signed. */
name|maxexpire
operator|=
operator|(
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|time_t
operator|)
literal|1
operator|<<
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|maxexpire
argument_list|)
operator|*
literal|8
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|ndpr_vltime
operator|<
name|maxexpire
operator|-
name|pr
operator|->
name|ndpr_lastupdate
condition|)
block|{
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|expire
operator|=
name|pr
operator|->
name|ndpr_lastupdate
operator|+
name|pr
operator|->
name|ndpr_vltime
operator|+
operator|(
name|time_second
operator|-
name|time_uptime
operator|)
expr_stmt|;
block|}
else|else
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|expire
operator|=
name|maxexpire
expr_stmt|;
block|}
name|j
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pfr
argument_list|,
argument|&pr->ndpr_advrtrs
argument_list|,
argument|pfr_entry
argument_list|)
block|{
if|if
condition|(
name|j
operator|<
name|DRLSTSIZ
condition|)
block|{
define|#
directive|define
name|RTRADDR
value|oprl->prefix[i].advrtr[j]
name|RTRADDR
operator|=
name|pfr
operator|->
name|router
operator|->
name|rtaddr
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|RTRADDR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|RTRADDR
block|}
name|j
operator|++
expr_stmt|;
block|}
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|advrtrs
operator|=
name|j
expr_stmt|;
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|origin
operator|=
name|PR_ORIG_RA
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|OSIOCGIFINFO_IN6
case|:
define|#
directive|define
name|ND
value|ndi->ndi
comment|/* XXX: old ndp(8) assumes a positive value for linkmtu. */
name|bzero
argument_list|(
operator|&
name|ND
argument_list|,
sizeof|sizeof
argument_list|(
name|ND
argument_list|)
argument_list|)
expr_stmt|;
name|ND
operator|.
name|linkmtu
operator|=
name|IN6_LINKMTU
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ND
operator|.
name|maxmtu
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|maxmtu
expr_stmt|;
name|ND
operator|.
name|basereachable
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|basereachable
expr_stmt|;
name|ND
operator|.
name|reachable
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|reachable
expr_stmt|;
name|ND
operator|.
name|retrans
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|retrans
expr_stmt|;
name|ND
operator|.
name|flags
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
expr_stmt|;
name|ND
operator|.
name|recalctm
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|recalctm
expr_stmt|;
name|ND
operator|.
name|chlim
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|chlim
expr_stmt|;
break|break;
case|case
name|SIOCGIFINFO_IN6
case|:
name|ND
operator|=
operator|*
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFINFO_IN6
case|:
comment|/* 		 * used to change host variables from userland. 		 * intented for a use on router to reflect RA configurations. 		 */
comment|/* 0 means 'unspecified' */
if|if
condition|(
name|ND
operator|.
name|linkmtu
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ND
operator|.
name|linkmtu
operator|<
name|IPV6_MMTU
operator|||
name|ND
operator|.
name|linkmtu
operator|>
name|IN6_LINKMTU
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|linkmtu
operator|=
name|ND
operator|.
name|linkmtu
expr_stmt|;
block|}
if|if
condition|(
name|ND
operator|.
name|basereachable
operator|!=
literal|0
condition|)
block|{
name|int
name|obasereachable
init|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|basereachable
decl_stmt|;
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|basereachable
operator|=
name|ND
operator|.
name|basereachable
expr_stmt|;
if|if
condition|(
name|ND
operator|.
name|basereachable
operator|!=
name|obasereachable
condition|)
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|reachable
operator|=
name|ND_COMPUTE_RTIME
argument_list|(
name|ND
operator|.
name|basereachable
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ND
operator|.
name|retrans
operator|!=
literal|0
condition|)
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|retrans
operator|=
name|ND
operator|.
name|retrans
expr_stmt|;
if|if
condition|(
name|ND
operator|.
name|chlim
operator|!=
literal|0
condition|)
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|chlim
operator|=
name|ND
operator|.
name|chlim
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SIOCSIFINFO_FLAGS
case|:
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia
decl_stmt|;
if|if
condition|(
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
operator|&&
operator|!
operator|(
name|ND
operator|.
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
condition|)
block|{
comment|/* ifdisabled 1->0 transision */
comment|/* 			 * If the interface is marked as ND6_IFF_IFDISABLED and 			 * has an link-local address with IN6_IFF_DUPLICATED, 			 * do not clear ND6_IFF_IFDISABLED. 			 * See RFC 4862, Section 5.4.5. 			 */
name|int
name|duplicated_linklocal
init|=
literal|0
decl_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|ia
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa
expr_stmt|;
if|if
condition|(
operator|(
name|ia
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_DUPLICATED
operator|)
operator|&&
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
name|IA6_IN6
argument_list|(
name|ia
argument_list|)
argument_list|)
condition|)
block|{
name|duplicated_linklocal
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplicated_linklocal
condition|)
block|{
name|ND
operator|.
name|flags
operator||=
name|ND6_IFF_IFDISABLED
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot enable an interface"
literal|" with a link-local address marked"
literal|" duplicate.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|ND6_IFF_IFDISABLED
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|in6_if_up
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
operator|&&
operator|(
name|ND
operator|.
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
condition|)
block|{
comment|/* ifdisabled 0->1 transision */
comment|/* Mark all IPv6 address as tentative. */
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator||=
name|ND6_IFF_IFDISABLED
expr_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|ia
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa
expr_stmt|;
name|ia
operator|->
name|ia6_flags
operator||=
name|IN6_IFF_TENTATIVE
expr_stmt|;
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ND
operator|.
name|flags
operator|&
name|ND6_IFF_AUTO_LINKLOCAL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_AUTO_LINKLOCAL
operator|)
condition|)
block|{
comment|/* auto_linklocal 0->1 transision */
comment|/* If no link-local address on ifp, configure */
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator||=
name|ND6_IFF_AUTO_LINKLOCAL
expr_stmt|;
name|in6_ifattach
argument_list|(
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ND
operator|.
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* 				 * When the IF already has 				 * ND6_IFF_AUTO_LINKLOCAL, no link-local 				 * address is assigned, and IFF_UP, try to 				 * assign one. 				 */
name|int
name|haslinklocal
init|=
literal|0
decl_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|ia
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
name|IA6_IN6
argument_list|(
name|ia
argument_list|)
argument_list|)
condition|)
block|{
name|haslinklocal
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haslinklocal
condition|)
name|in6_ifattach
argument_list|(
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|=
name|ND
operator|.
name|flags
expr_stmt|;
break|break;
undef|#
directive|undef
name|ND
case|case
name|SIOCSNDFLUSH_IN6
case|:
comment|/* XXX: the ioctl name is confusing... */
comment|/* sync kernel routing table with the default router list */
name|defrouter_reset
argument_list|()
expr_stmt|;
name|defrouter_select
argument_list|()
expr_stmt|;
break|break;
case|case
name|SIOCSPFXFLUSH_IN6
case|:
block|{
comment|/* flush all the prefix advertised by routers */
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|pr
argument_list|,
argument|&V_nd_prefix
argument_list|,
argument|ndpr_entry
argument_list|,
argument|next
argument_list|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ia
decl_stmt|,
modifier|*
name|ia_next
decl_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|pr
operator|->
name|ndpr_prefix
operator|.
name|sin6_addr
argument_list|)
condition|)
continue|continue;
comment|/* XXX */
comment|/* do we really have to remove addresses as well? */
comment|/* XXXRW: in6_ifaddrhead locking. */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ia
argument_list|,
argument|&V_in6_ifaddrhead
argument_list|,
argument|ia_link
argument_list|,
argument|ia_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|ia
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_AUTOCONF
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ia
operator|->
name|ia6_ndpr
operator|==
name|pr
condition|)
name|in6_purgeaddr
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
block|}
name|prelist_remove
argument_list|(
name|pr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SIOCSRTRFLUSH_IN6
case|:
block|{
comment|/* flush all the default routers */
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|defrouter_reset
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|dr
argument_list|,
argument|&V_nd_defrouter
argument_list|,
argument|dr_entry
argument_list|,
argument|next
argument_list|)
block|{
name|defrtrlist_del
argument_list|(
name|dr
argument_list|)
expr_stmt|;
block|}
name|defrouter_select
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|SIOCGNBRINFO_IN6
case|:
block|{
name|struct
name|llentry
modifier|*
name|ln
decl_stmt|;
name|struct
name|in6_addr
name|nb_addr
init|=
name|nbi
operator|->
name|addr
decl_stmt|;
comment|/* make local for safety */
if|if
condition|(
operator|(
name|error
operator|=
name|in6_setscope
argument_list|(
operator|&
name|nb_addr
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|IF_AFDATA_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ln
operator|=
name|nd6_lookup
argument_list|(
operator|&
name|nb_addr
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|IF_AFDATA_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|nbi
operator|->
name|state
operator|=
name|ln
operator|->
name|ln_state
expr_stmt|;
name|nbi
operator|->
name|asked
operator|=
name|ln
operator|->
name|la_asked
expr_stmt|;
name|nbi
operator|->
name|isrouter
operator|=
name|ln
operator|->
name|ln_router
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|la_expire
operator|==
literal|0
condition|)
name|nbi
operator|->
name|expire
operator|=
literal|0
expr_stmt|;
else|else
name|nbi
operator|->
name|expire
operator|=
name|ln
operator|->
name|la_expire
operator|+
operator|(
name|time_second
operator|-
name|time_uptime
operator|)
expr_stmt|;
name|LLE_RUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCGDEFIFACE_IN6
case|:
comment|/* XXX: should be implemented as a sysctl? */
name|ndif
operator|->
name|ifindex
operator|=
name|V_nd6_defifindex
expr_stmt|;
break|break;
case|case
name|SIOCSDEFIFACE_IN6
case|:
comment|/* XXX: should be implemented as a sysctl? */
return|return
operator|(
name|nd6_setdefaultiface
argument_list|(
name|ndif
operator|->
name|ifindex
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create neighbor cache entry and cache link-layer address,  * on reception of inbound ND6 packets.  (RS/RA/NS/redirect)  *  * type - ICMP6 type  * code - type dependent information  *  * XXXXX  *  The caller of this function already acquired the ndp   *  cache table lock because the cache entry is returned.  */
end_comment

begin_function
name|struct
name|llentry
modifier|*
name|nd6_cache_lladdr
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|lladdr
parameter_list|,
name|int
name|lladdrlen
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|struct
name|llentry
modifier|*
name|ln
init|=
name|NULL
decl_stmt|;
name|int
name|is_newentry
decl_stmt|;
name|int
name|do_update
decl_stmt|;
name|int
name|olladdr
decl_stmt|;
name|int
name|llchange
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|newstate
init|=
literal|0
decl_stmt|;
name|uint16_t
name|router
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|chain
init|=
name|NULL
decl_stmt|;
name|int
name|static_route
init|=
literal|0
decl_stmt|;
name|IF_AFDATA_UNLOCK_ASSERT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ifp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ifp == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|from
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: from == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* nothing must be updated for unspecified address */
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
name|from
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* 	 * Validation about ifp->if_addrlen and lladdrlen must be done in 	 * the caller. 	 * 	 * XXX If the link does not have link-layer adderss, what should 	 * we do? (ifp->if_addrlen == 0) 	 * Spec says nothing in sections for RA, RS and NA.  There's small 	 * description on it in NS section (RFC 2461 7.2.3). 	 */
name|flags
operator|=
name|lladdr
condition|?
name|ND6_EXCLUSIVE
else|:
literal|0
expr_stmt|;
name|IF_AFDATA_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ln
operator|=
name|nd6_lookup
argument_list|(
name|from
argument_list|,
name|flags
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|IF_AFDATA_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
name|flags
operator||=
name|ND6_EXCLUSIVE
expr_stmt|;
name|IF_AFDATA_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ln
operator|=
name|nd6_lookup
argument_list|(
name|from
argument_list|,
name|flags
operator||
name|ND6_CREATE
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|IF_AFDATA_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|is_newentry
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* do nothing if static ndp is set */
if|if
condition|(
name|ln
operator|->
name|la_flags
operator|&
name|LLE_STATIC
condition|)
block|{
name|static_route
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|is_newentry
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|olladdr
operator|=
operator|(
name|ln
operator|->
name|la_flags
operator|&
name|LLE_VALID
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|olladdr
operator|&&
name|lladdr
condition|)
block|{
name|llchange
operator|=
name|bcmp
argument_list|(
name|lladdr
argument_list|,
operator|&
name|ln
operator|->
name|ll_addr
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
block|}
else|else
name|llchange
operator|=
literal|0
expr_stmt|;
comment|/* 	 * newentry olladdr  lladdr  llchange	(*=record) 	 *	0	n	n	--	(1) 	 *	0	y	n	--	(2) 	 *	0	n	y	--	(3) * STALE 	 *	0	y	y	n	(4) * 	 *	0	y	y	y	(5) * STALE 	 *	1	--	n	--	(6)   NOSTATE(= PASSIVE) 	 *	1	--	y	--	(7) * STALE 	 */
if|if
condition|(
name|lladdr
condition|)
block|{
comment|/* (3-5) and (7) */
comment|/* 		 * Record source link-layer address 		 * XXX is it dependent to ifp->if_type? 		 */
name|bcopy
argument_list|(
name|lladdr
argument_list|,
operator|&
name|ln
operator|->
name|ll_addr
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
name|ln
operator|->
name|la_flags
operator||=
name|LLE_VALID
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|lle_event
argument_list|,
name|ln
argument_list|,
name|LLENTRY_RESOLVED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_newentry
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|olladdr
operator|&&
name|lladdr
operator|!=
name|NULL
operator|)
operator|||
comment|/* (3) */
operator|(
name|olladdr
operator|&&
name|lladdr
operator|!=
name|NULL
operator|&&
name|llchange
operator|)
condition|)
block|{
comment|/* (5) */
name|do_update
operator|=
literal|1
expr_stmt|;
name|newstate
operator|=
name|ND6_LLINFO_STALE
expr_stmt|;
block|}
else|else
comment|/* (1-2,4) */
name|do_update
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|do_update
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lladdr
operator|==
name|NULL
condition|)
comment|/* (6) */
name|newstate
operator|=
name|ND6_LLINFO_NOSTATE
expr_stmt|;
else|else
comment|/* (7) */
name|newstate
operator|=
name|ND6_LLINFO_STALE
expr_stmt|;
block|}
if|if
condition|(
name|do_update
condition|)
block|{
comment|/* 		 * Update the state of the neighbor cache. 		 */
name|ln
operator|->
name|ln_state
operator|=
name|newstate
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_STALE
condition|)
block|{
comment|/* 			 * XXX: since nd6_output() below will cause 			 * state tansition to DELAY and reset the timer, 			 * we must set the timer now, although it is actually 			 * meaningless. 			 */
name|nd6_llinfo_settimer_locked
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|V_nd6_gctimer
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|la_hold
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m_hold
decl_stmt|,
modifier|*
name|m_hold_next
decl_stmt|;
comment|/* 				 * reset the la_hold in advance, to explicitly 				 * prevent a la_hold lookup in nd6_output() 				 * (wouldn't happen, though...) 				 */
for|for
control|(
name|m_hold
operator|=
name|ln
operator|->
name|la_hold
operator|,
name|ln
operator|->
name|la_hold
operator|=
name|NULL
init|;
name|m_hold
condition|;
name|m_hold
operator|=
name|m_hold_next
control|)
block|{
name|m_hold_next
operator|=
name|m_hold
operator|->
name|m_nextpkt
expr_stmt|;
name|m_hold
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
comment|/* 					 * we assume ifp is not a p2p here, so 					 * just set the 2nd argument as the 					 * 1st one. 					 */
name|nd6_output_lle
argument_list|(
name|ifp
argument_list|,
name|ifp
argument_list|,
name|m_hold
argument_list|,
name|L3_ADDR_SIN6
argument_list|(
name|ln
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|ln
argument_list|,
operator|&
name|chain
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * If we have mbufs in the chain we need to do 				 * deferred transmit. Copy the address from the 				 * llentry before dropping the lock down below. 				 */
if|if
condition|(
name|chain
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
operator|&
name|sin6
argument_list|,
name|L3_ADDR_SIN6
argument_list|(
name|ln
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_INCOMPLETE
condition|)
block|{
comment|/* probe right away */
name|nd6_llinfo_settimer_locked
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * ICMP6 type dependent behavior. 	 * 	 * NS: clear IsRouter if new entry 	 * RS: clear IsRouter 	 * RA: set IsRouter if there's lladdr 	 * redir: clear IsRouter if new entry 	 * 	 * RA case, (1): 	 * The spec says that we must set IsRouter in the following cases: 	 * - If lladdr exist, set IsRouter.  This means (1-5). 	 * - If it is old entry (!newentry), set IsRouter.  This means (7). 	 * So, based on the spec, in (1-5) and (7) cases we must set IsRouter. 	 * A quetion arises for (1) case.  (1) case has no lladdr in the 	 * neighbor cache, this is similar to (6). 	 * This case is rare but we figured that we MUST NOT set IsRouter. 	 * 	 * newentry olladdr  lladdr  llchange	    NS  RS  RA	redir 	 *							D R 	 *	0	n	n	--	(1)	c   ?     s 	 *	0	y	n	--	(2)	c   s     s 	 *	0	n	y	--	(3)	c   s     s 	 *	0	y	y	n	(4)	c   s     s 	 *	0	y	y	y	(5)	c   s     s 	 *	1	--	n	--	(6) c	c	c s 	 *	1	--	y	--	(7) c	c   s	c s 	 * 	 *					(c=clear s=set) 	 */
switch|switch
condition|(
name|type
operator|&
literal|0xff
condition|)
block|{
case|case
name|ND_NEIGHBOR_SOLICIT
case|:
comment|/* 		 * New entry must have is_router flag cleared. 		 */
if|if
condition|(
name|is_newentry
condition|)
comment|/* (6-7) */
name|ln
operator|->
name|ln_router
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ND_REDIRECT
case|:
comment|/* 		 * If the icmp is a redirect to a better router, always set the 		 * is_router flag.  Otherwise, if the entry is newly created, 		 * clear the flag.  [RFC 2461, sec 8.3] 		 */
if|if
condition|(
name|code
operator|==
name|ND_REDIRECT_ROUTER
condition|)
name|ln
operator|->
name|ln_router
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|is_newentry
condition|)
comment|/* (6-7) */
name|ln
operator|->
name|ln_router
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ND_ROUTER_SOLICIT
case|:
comment|/* 		 * is_router flag must always be cleared. 		 */
name|ln
operator|->
name|ln_router
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ND_ROUTER_ADVERT
case|:
comment|/* 		 * Mark an entry with lladdr as a router. 		 */
if|if
condition|(
operator|(
operator|!
name|is_newentry
operator|&&
operator|(
name|olladdr
operator|||
name|lladdr
operator|)
operator|)
operator|||
comment|/* (2-5) */
operator|(
name|is_newentry
operator|&&
name|lladdr
operator|)
condition|)
block|{
comment|/* (7) */
name|ln
operator|->
name|ln_router
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|static_route
operator|=
operator|(
name|ln
operator|->
name|la_flags
operator|&
name|LLE_STATIC
operator|)
expr_stmt|;
name|router
operator|=
name|ln
operator|->
name|ln_router
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ND6_EXCLUSIVE
condition|)
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
else|else
name|LLE_RUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|static_route
condition|)
name|ln
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|chain
condition|)
name|nd6_output_flush
argument_list|(
name|ifp
argument_list|,
name|ifp
argument_list|,
name|chain
argument_list|,
operator|&
name|sin6
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * When the link-layer address of a router changes, select the 	 * best router again.  In particular, when the neighbor entry is newly 	 * created, it might affect the selection policy. 	 * Question: can we restrict the first condition to the "is_newentry" 	 * case? 	 * XXX: when we hear an RA from a new router with the link-layer 	 * address option, defrouter_select() is called twice, since 	 * defrtrlist_update called the function as well.  However, I believe 	 * we can compromise the overhead, since it only happens the first 	 * time. 	 * XXX: although defrouter_select() should not have a bad effect 	 * for those are not autoconfigured hosts, we explicitly avoid such 	 * cases for safety. 	 */
if|if
condition|(
name|do_update
operator|&&
name|router
operator|&&
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_ACCEPT_RTADV
condition|)
block|{
comment|/* 		 * guaranteed recursion 		 */
name|defrouter_select
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ln
operator|)
return|;
name|done
label|:
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|ND6_EXCLUSIVE
condition|)
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
else|else
name|LLE_RUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|static_route
condition|)
name|ln
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ln
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nd6_slowtimo
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|CURVNET_SET
argument_list|(
operator|(
expr|struct
name|vnet
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|struct
name|nd_ifinfo
modifier|*
name|nd6if
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|callout_reset
argument_list|(
operator|&
name|V_nd6_slowtimo_ch
argument_list|,
name|ND6_SLOWTIMER_INTERVAL
operator|*
name|hz
argument_list|,
name|nd6_slowtimo
argument_list|,
name|curvnet
argument_list|)
expr_stmt|;
name|IFNET_RLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifp
argument_list|,
argument|&V_ifnet
argument_list|,
argument|if_list
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_afdata
index|[
name|AF_INET6
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|nd6if
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd6if
operator|->
name|basereachable
operator|&&
comment|/* already initialized */
operator|(
name|nd6if
operator|->
name|recalctm
operator|-=
name|ND6_SLOWTIMER_INTERVAL
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* 			 * Since reachable time rarely changes by router 			 * advertisements, we SHOULD insure that a new random 			 * value gets recomputed at least once every few hours. 			 * (RFC 2461, 6.3.4) 			 */
name|nd6if
operator|->
name|recalctm
operator|=
name|V_nd6_recalc_reachtm_interval
expr_stmt|;
name|nd6if
operator|->
name|reachable
operator|=
name|ND_COMPUTE_RTIME
argument_list|(
name|nd6if
operator|->
name|basereachable
argument_list|)
expr_stmt|;
block|}
block|}
name|IFNET_RUNLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * IPv6 packet output - light version.  * Checks if destination LLE exists and is in proper state  * (e.g no modification required). If not true, fall back to  * "heavy" version.  */
end_comment

begin_function
name|int
name|nd6_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifnet
modifier|*
name|origifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|dst
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt0
parameter_list|)
block|{
name|struct
name|llentry
modifier|*
name|ln
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* discard the packet if IPv6 operation is disabled on the interface */
if|if
condition|(
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/* better error? */
block|}
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|)
condition|)
goto|goto
name|sendpkt
goto|;
if|if
condition|(
name|nd6_need_cache
argument_list|(
name|ifp
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|sendpkt
goto|;
name|IF_AFDATA_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ln
operator|=
name|nd6_lookup
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|IF_AFDATA_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Perform fast path for the following cases: 	 * 1) lle state is REACHABLE 	 * 2) lle state is DELAY (NS message sentNS message sent) 	 * 	 * Every other case involves lle modification, so we handle 	 * them separately. 	 */
if|if
condition|(
name|ln
operator|==
name|NULL
operator|||
operator|(
name|ln
operator|->
name|ln_state
operator|!=
name|ND6_LLINFO_REACHABLE
operator|&&
name|ln
operator|->
name|ln_state
operator|!=
name|ND6_LLINFO_DELAY
operator|)
condition|)
block|{
comment|/* Fall back to slow processing path */
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
name|LLE_RUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
return|return
operator|(
name|nd6_output_lle
argument_list|(
name|ifp
argument_list|,
name|origifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|rt0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
name|sendpkt
label|:
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
name|LLE_RUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_netinet6_nd6_send
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If called from nd6_ns_output() (NS), nd6_na_output() (NA), 	 * icmp6_redirect_output() (REDIRECT) or from rip6_output() (RS, RA 	 * as handled by rtsol and rtadvd), mbufs will be tagged for SeND 	 * to be diverted to user space.  When re-injected into the kernel, 	 * send_output() will directly dispatch them to the outgoing interface. 	 */
if|if
condition|(
name|send_sendso_input_hook
operator|!=
name|NULL
condition|)
block|{
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|int
name|ip6len
decl_stmt|;
name|mtag
operator|=
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_ND_OUTGOING
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|!=
name|NULL
condition|)
block|{
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|ip6len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
comment|/* Use the SEND socket */
name|error
operator|=
name|send_sendso_input_hook
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|,
name|SND_OUT
argument_list|,
name|ip6len
argument_list|)
expr_stmt|;
comment|/* -1 == no app on SEND socket */
if|if
condition|(
name|error
operator|==
literal|0
operator|||
name|error
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|m_clrprotoflags
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Avoid confusing lower layers. */
name|IP_PROBE
argument_list|(
name|send
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|==
literal|0
condition|)
name|origifp
operator|=
name|ifp
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|origifp
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Output IPv6 packet - heavy version.  * Function assume that either  * 1) destination LLE does not exist, is invalid or stale, so  *   ND6_EXCLUSIVE lock needs to be acquired  * 2) destination lle is provided (with ND6_EXCLUSIVE lock),  *   in that case packets are queued in&chain.  *  */
end_comment

begin_function
name|int
name|nd6_output_lle
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifnet
modifier|*
name|origifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|dst
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt0
parameter_list|,
name|struct
name|llentry
modifier|*
name|lle
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|chain
parameter_list|)
block|{
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|has_lle
init|=
literal|0
decl_stmt|;
name|int
name|ip6len
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|lle
operator|!=
name|NULL
condition|)
block|{
name|LLE_WLOCK_ASSERT
argument_list|(
name|lle
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|chain
operator|!=
name|NULL
argument_list|,
operator|(
literal|" lle locked but no mbuf chain pointer passed"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL mbuf, nothing to send"
operator|)
argument_list|)
expr_stmt|;
comment|/* discard the packet if IPv6 operation is disabled on the interface */
if|if
condition|(
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/* better error? */
block|}
if|if
condition|(
name|lle
operator|!=
name|NULL
condition|)
name|has_lle
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|)
condition|)
goto|goto
name|sendpkt
goto|;
if|if
condition|(
name|nd6_need_cache
argument_list|(
name|ifp
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|sendpkt
goto|;
comment|/* 	 * Address resolution or Neighbor Unreachability Detection 	 * for the next hop. 	 * At this point, the destination of the packet must be a unicast 	 * or an anycast address(i.e. not a multicast). 	 */
if|if
condition|(
name|lle
operator|==
name|NULL
condition|)
block|{
name|IF_AFDATA_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|lle
operator|=
name|nd6_lookup
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
name|ND6_EXCLUSIVE
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|IF_AFDATA_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lle
operator|==
name|NULL
operator|)
operator|&&
name|nd6_is_addr_neighbor
argument_list|(
name|dst
argument_list|,
name|ifp
argument_list|)
condition|)
block|{
comment|/* 			 * Since nd6_is_addr_neighbor() internally calls nd6_lookup(), 			 * the condition below is not very efficient.  But we believe 			 * it is tolerable, because this should be a rare case. 			 */
name|flags
operator|=
name|ND6_CREATE
operator||
name|ND6_EXCLUSIVE
expr_stmt|;
name|IF_AFDATA_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|lle
operator|=
name|nd6_lookup
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
name|flags
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|IF_AFDATA_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lle
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_PERFORMNUD
operator|)
condition|)
block|{
name|char
name|ip6buf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"nd6_output: can't allocate llinfo for %s "
literal|"(ln=%p)\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6buf
argument_list|,
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|lle
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
goto|goto
name|sendpkt
goto|;
comment|/* send anyway */
block|}
name|LLE_WLOCK_ASSERT
argument_list|(
name|lle
argument_list|)
expr_stmt|;
comment|/* We don't have to do link-layer address resolution on a p2p link. */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|!=
literal|0
operator|&&
name|lle
operator|->
name|ln_state
operator|<
name|ND6_LLINFO_REACHABLE
condition|)
block|{
name|lle
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_STALE
expr_stmt|;
name|nd6_llinfo_settimer_locked
argument_list|(
name|lle
argument_list|,
operator|(
name|long
operator|)
name|V_nd6_gctimer
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The first time we send a packet to a neighbor whose entry is 	 * STALE, we have to change the state to DELAY and a sets a timer to 	 * expire in DELAY_FIRST_PROBE_TIME seconds to ensure do 	 * neighbor unreachability detection on expiration. 	 * (RFC 2461 7.3.3) 	 */
if|if
condition|(
name|lle
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_STALE
condition|)
block|{
name|lle
operator|->
name|la_asked
operator|=
literal|0
expr_stmt|;
name|lle
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_DELAY
expr_stmt|;
name|nd6_llinfo_settimer_locked
argument_list|(
name|lle
argument_list|,
operator|(
name|long
operator|)
name|V_nd6_delay
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the neighbor cache entry has a state other than INCOMPLETE 	 * (i.e. its link-layer address is already resolved), just 	 * send the packet. 	 */
if|if
condition|(
name|lle
operator|->
name|ln_state
operator|>
name|ND6_LLINFO_INCOMPLETE
condition|)
goto|goto
name|sendpkt
goto|;
comment|/* 	 * There is a neighbor cache entry, but no ethernet address 	 * response yet.  Append this latest packet to the end of the 	 * packet queue in the mbuf, unless the number of the packet 	 * does not exceed nd6_maxqueuelen.  When it exceeds nd6_maxqueuelen, 	 * the oldest packet in the queue will be removed. 	 */
if|if
condition|(
name|lle
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_NOSTATE
condition|)
name|lle
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_INCOMPLETE
expr_stmt|;
if|if
condition|(
name|lle
operator|->
name|la_hold
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m_hold
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m_hold
operator|=
name|lle
operator|->
name|la_hold
init|;
name|m_hold
condition|;
name|m_hold
operator|=
name|m_hold
operator|->
name|m_nextpkt
control|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|m_hold
operator|->
name|m_nextpkt
operator|==
name|NULL
condition|)
block|{
name|m_hold
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
name|i
operator|>=
name|V_nd6_maxqueuelen
condition|)
block|{
name|m_hold
operator|=
name|lle
operator|->
name|la_hold
expr_stmt|;
name|lle
operator|->
name|la_hold
operator|=
name|lle
operator|->
name|la_hold
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|m_hold
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|lle
operator|->
name|la_hold
operator|=
name|m
expr_stmt|;
block|}
comment|/* 	 * If there has been no NS for the neighbor after entering the 	 * INCOMPLETE state, send the first solicitation. 	 */
if|if
condition|(
operator|!
name|ND6_LLINFO_PERMANENT
argument_list|(
name|lle
argument_list|)
operator|&&
name|lle
operator|->
name|la_asked
operator|==
literal|0
condition|)
block|{
name|lle
operator|->
name|la_asked
operator|++
expr_stmt|;
name|nd6_llinfo_settimer_locked
argument_list|(
name|lle
argument_list|,
operator|(
name|long
operator|)
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|retrans
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|LLE_WUNLOCK
argument_list|(
name|lle
argument_list|)
expr_stmt|;
name|nd6_ns_output
argument_list|(
name|ifp
argument_list|,
name|NULL
argument_list|,
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
name|lle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_lle
operator|!=
literal|0
condition|)
name|LLE_WLOCK
argument_list|(
name|lle
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_lle
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We did the lookup (no lle arg) so we 		 * need to do the unlock here. 		 */
name|LLE_WUNLOCK
argument_list|(
name|lle
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|sendpkt
label|:
comment|/* 	 * ln is valid and the caller did not pass in  	 * an llentry 	 */
if|if
condition|(
name|lle
operator|!=
name|NULL
operator|&&
name|has_lle
operator|==
literal|0
condition|)
name|LLE_WUNLOCK
argument_list|(
name|lle
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_netinet6_nd6_send
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If called from nd6_ns_output() (NS), nd6_na_output() (NA), 	 * icmp6_redirect_output() (REDIRECT) or from rip6_output() (RS, RA 	 * as handled by rtsol and rtadvd), mbufs will be tagged for SeND 	 * to be diverted to user space.  When re-injected into the kernel, 	 * send_output() will directly dispatch them to the outgoing interface. 	 */
if|if
condition|(
name|send_sendso_input_hook
operator|!=
name|NULL
condition|)
block|{
name|mtag
operator|=
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_ND_OUTGOING
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|!=
name|NULL
condition|)
block|{
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|ip6len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
comment|/* Use the SEND socket */
name|error
operator|=
name|send_sendso_input_hook
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|,
name|SND_OUT
argument_list|,
name|ip6len
argument_list|)
expr_stmt|;
comment|/* -1 == no app on SEND socket */
if|if
condition|(
name|error
operator|==
literal|0
operator|||
name|error
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * We were passed in a pointer to an lle with the lock held  	 * this means that we can't call if_output as we will 	 * recurse on the lle lock - so what we do is we create 	 * a list of mbufs to send and transmit them in the caller 	 * after the lock is dropped 	 */
if|if
condition|(
name|has_lle
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|chain
operator|==
name|NULL
condition|)
operator|*
name|chain
operator|=
name|m
expr_stmt|;
else|else
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
comment|/* 			 * append mbuf to end of deferred chain 			 */
name|mb
operator|=
operator|*
name|chain
expr_stmt|;
while|while
condition|(
name|mb
operator|->
name|m_nextpkt
operator|!=
name|NULL
condition|)
name|mb
operator|=
name|mb
operator|->
name|m_nextpkt
expr_stmt|;
name|mb
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
name|m_clrprotoflags
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Avoid confusing lower layers. */
name|IP_PROBE
argument_list|(
name|send
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|==
literal|0
condition|)
name|origifp
operator|=
name|ifp
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|origifp
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nd6_output_flush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifnet
modifier|*
name|origifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|chain
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|dst
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_head
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|outifp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|m_head
operator|=
name|chain
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|!=
literal|0
condition|)
name|outifp
operator|=
name|origifp
expr_stmt|;
else|else
name|outifp
operator|=
name|ifp
expr_stmt|;
while|while
condition|(
name|m_head
condition|)
block|{
name|m
operator|=
name|m_head
expr_stmt|;
name|m_head
operator|=
name|m_head
operator|->
name|m_nextpkt
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
argument_list|,
name|ro
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX 	 * note that intermediate errors are blindly ignored - but this is  	 * the same convention as used with nd6_output when called by 	 * nd6_cache_lladdr 	 */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nd6_need_cache
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
comment|/* 	 * XXX: we currently do not make neighbor cache on any interface 	 * other than ARCnet, Ethernet, FDDI and GIF. 	 * 	 * RFC2893 says: 	 * - unidirectional tunnels needs no ND 	 */
switch|switch
condition|(
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ARCNET
case|:
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_FDDI
case|:
case|case
name|IFT_IEEE1394
case|:
ifdef|#
directive|ifdef
name|IFT_L2VLAN
case|case
name|IFT_L2VLAN
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IFT_IEEE80211
case|case
name|IFT_IEEE80211
case|:
endif|#
directive|endif
case|case
name|IFT_INFINIBAND
case|:
case|case
name|IFT_GIF
case|:
comment|/* XXX need more cases? */
case|case
name|IFT_PPP
case|:
case|case
name|IFT_TUNNEL
case|:
case|case
name|IFT_BRIDGE
case|:
case|case
name|IFT_PROPVIRTUAL
case|:
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add pernament ND6 link-layer record for given  * interface address.  *  * Very similar to IPv4 arp_ifinit(), but:  * 1) IPv6 DAD is performed in different place  * 2) It is called by IPv6 protocol stack in contrast to  * arp_ifinit() which is typically called in SIOCSIFADDR  * driver ioctl handler.  *  */
end_comment

begin_function
name|int
name|nd6_add_ifa_lle
parameter_list|(
name|struct
name|in6_ifaddr
modifier|*
name|ia
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|llentry
modifier|*
name|ln
decl_stmt|;
name|ifp
operator|=
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_ifp
expr_stmt|;
name|IF_AFDATA_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_rtrequest
operator|=
name|nd6_rtrequest
expr_stmt|;
name|ln
operator|=
name|lla_lookup
argument_list|(
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|,
operator|(
name|LLE_CREATE
operator||
name|LLE_IFADDR
operator||
name|LLE_EXCLUSIVE
operator|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ia
operator|->
name|ia_addr
argument_list|)
expr_stmt|;
name|IF_AFDATA_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|ln
operator|->
name|la_expire
operator|=
literal|0
expr_stmt|;
comment|/* for IPv6 this means permanent */
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_REACHABLE
expr_stmt|;
name|LLE_WUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|in6_newaddrmsg
argument_list|(
name|ia
argument_list|,
name|RTM_ADD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Removes ALL lle records for interface address prefix.  * XXXME: That's probably not we really want to do, we need  * to remove address record only and keep other records  * until we determine if given prefix is really going   * to be removed.  */
end_comment

begin_function
name|void
name|nd6_rem_ifa_lle
parameter_list|(
name|struct
name|in6_ifaddr
modifier|*
name|ia
parameter_list|)
block|{
name|struct
name|sockaddr_in6
name|mask
decl_stmt|,
name|addr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|in6_newaddrmsg
argument_list|(
name|ia
argument_list|,
name|RTM_DELETE
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_ifp
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|ia
operator|->
name|ia_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ia
operator|->
name|ia_addr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mask
argument_list|,
operator|&
name|ia
operator|->
name|ia_prefixmask
argument_list|,
sizeof|sizeof
argument_list|(
name|ia
operator|->
name|ia_prefixmask
argument_list|)
argument_list|)
expr_stmt|;
name|lltable_prefix_free
argument_list|(
name|AF_INET6
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|mask
argument_list|,
name|LLE_STATIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * the callers of this function need to be re-worked to drop  * the lle lock, drop here for now  */
end_comment

begin_function
name|int
name|nd6_storelladdr
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|u_char
modifier|*
name|desten
parameter_list|,
name|struct
name|llentry
modifier|*
modifier|*
name|lle
parameter_list|)
block|{
name|struct
name|llentry
modifier|*
name|ln
decl_stmt|;
operator|*
name|lle
operator|=
name|NULL
expr_stmt|;
name|IF_AFDATA_UNLOCK_ASSERT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_FDDI
case|:
ifdef|#
directive|ifdef
name|IFT_L2VLAN
case|case
name|IFT_L2VLAN
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IFT_IEEE80211
case|case
name|IFT_IEEE80211
case|:
endif|#
directive|endif
case|case
name|IFT_BRIDGE
case|:
case|case
name|IFT_ISO88025
case|:
name|ETHER_MAP_IPV6_MULTICAST
argument_list|(
operator|&
name|SIN6
argument_list|(
name|dst
argument_list|)
operator|->
name|sin6_addr
argument_list|,
name|desten
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|IFT_IEEE1394
case|:
comment|/* 			 * netbsd can use if_broadcastaddr, but we don't do so 			 * to reduce # of ifdef. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ifp
operator|->
name|if_addrlen
condition|;
name|i
operator|++
control|)
name|desten
index|[
name|i
index|]
operator|=
operator|~
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|IFT_ARCNET
case|:
operator|*
name|desten
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
block|}
comment|/* 	 * the entry should have been created in nd6_store_lladdr 	 */
name|IF_AFDATA_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ln
operator|=
name|lla_lookup
argument_list|(
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|IF_AFDATA_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ln
operator|==
name|NULL
operator|)
operator|||
operator|!
operator|(
name|ln
operator|->
name|la_flags
operator|&
name|LLE_VALID
operator|)
condition|)
block|{
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
name|LLE_RUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
comment|/* this could happen, if we could not allocate memory */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|&
name|ln
operator|->
name|ll_addr
argument_list|,
name|desten
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
operator|*
name|lle
operator|=
name|ln
expr_stmt|;
name|LLE_RUNLOCK
argument_list|(
name|ln
argument_list|)
expr_stmt|;
comment|/* 	 * A *small* use after free race exists here 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_llinfo_pqueue
parameter_list|(
name|struct
name|llentry
modifier|*
name|ln
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_hold
decl_stmt|,
modifier|*
name|m_hold_next
decl_stmt|;
for|for
control|(
name|m_hold
operator|=
name|ln
operator|->
name|la_hold
init|;
name|m_hold
condition|;
name|m_hold
operator|=
name|m_hold_next
control|)
block|{
name|m_hold_next
operator|=
name|m_hold
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|m_hold
argument_list|)
expr_stmt|;
block|}
name|ln
operator|->
name|la_hold
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|nd6_sysctl_drlist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nd6_sysctl_prlist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SYSCTL_DECL
end_ifdef

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet6_icmp6
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet6_icmp6
argument_list|,
name|ICMPV6CTL_ND6_DRLIST
argument_list|,
name|nd6_drlist
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|nd6_sysctl_drlist
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet6_icmp6
argument_list|,
name|ICMPV6CTL_ND6_PRLIST
argument_list|,
name|nd6_prlist
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|nd6_sysctl_prlist
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_inet6_icmp6
argument_list|,
name|ICMPV6CTL_ND6_MAXQLEN
argument_list|,
name|nd6_maxqueuelen
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|nd6_maxqueuelen
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_inet6_icmp6
argument_list|,
name|OID_AUTO
argument_list|,
name|nd6_gctimer
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|nd6_gctimer
argument_list|)
argument_list|,
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|nd6_sysctl_drlist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|in6_defrouter
name|d
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|.
name|rtaddr
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|d
operator|.
name|rtaddr
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|d
operator|.
name|rtaddr
argument_list|)
expr_stmt|;
comment|/* 	 * XXX locking 	 */
name|TAILQ_FOREACH
argument_list|(
argument|dr
argument_list|,
argument|&V_nd_defrouter
argument_list|,
argument|dr_entry
argument_list|)
block|{
name|d
operator|.
name|rtaddr
operator|.
name|sin6_addr
operator|=
name|dr
operator|->
name|rtaddr
expr_stmt|;
name|error
operator|=
name|sa6_recoverscope
argument_list|(
operator|&
name|d
operator|.
name|rtaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|d
operator|.
name|flags
operator|=
name|dr
operator|->
name|flags
expr_stmt|;
name|d
operator|.
name|rtlifetime
operator|=
name|dr
operator|->
name|rtlifetime
expr_stmt|;
name|d
operator|.
name|expire
operator|=
name|dr
operator|->
name|expire
operator|+
operator|(
name|time_second
operator|-
name|time_uptime
operator|)
expr_stmt|;
name|d
operator|.
name|if_index
operator|=
name|dr
operator|->
name|ifp
operator|->
name|if_index
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nd6_sysctl_prlist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|in6_prefix
name|p
decl_stmt|;
name|struct
name|sockaddr_in6
name|s6
decl_stmt|;
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|;
name|struct
name|nd_pfxrouter
modifier|*
name|pfr
decl_stmt|;
name|time_t
name|maxexpire
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|ip6buf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|origin
operator|=
name|PR_ORIG_RA
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|s6
argument_list|,
sizeof|sizeof
argument_list|(
name|s6
argument_list|)
argument_list|)
expr_stmt|;
name|s6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|s6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|s6
argument_list|)
expr_stmt|;
comment|/* 	 * XXX locking 	 */
name|LIST_FOREACH
argument_list|(
argument|pr
argument_list|,
argument|&V_nd_prefix
argument_list|,
argument|ndpr_entry
argument_list|)
block|{
name|p
operator|.
name|prefix
operator|=
name|pr
operator|->
name|ndpr_prefix
expr_stmt|;
if|if
condition|(
name|sa6_recoverscope
argument_list|(
operator|&
name|p
operator|.
name|prefix
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"scope error in prefix list (%s)\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6buf
argument_list|,
operator|&
name|p
operator|.
name|prefix
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: press on... */
block|}
name|p
operator|.
name|raflags
operator|=
name|pr
operator|->
name|ndpr_raf
expr_stmt|;
name|p
operator|.
name|prefixlen
operator|=
name|pr
operator|->
name|ndpr_plen
expr_stmt|;
name|p
operator|.
name|vltime
operator|=
name|pr
operator|->
name|ndpr_vltime
expr_stmt|;
name|p
operator|.
name|pltime
operator|=
name|pr
operator|->
name|ndpr_pltime
expr_stmt|;
name|p
operator|.
name|if_index
operator|=
name|pr
operator|->
name|ndpr_ifp
operator|->
name|if_index
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|ndpr_vltime
operator|==
name|ND6_INFINITE_LIFETIME
condition|)
name|p
operator|.
name|expire
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* XXX: we assume time_t is signed. */
name|maxexpire
operator|=
operator|(
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|time_t
operator|)
literal|1
operator|<<
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|maxexpire
argument_list|)
operator|*
literal|8
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|ndpr_vltime
operator|<
name|maxexpire
operator|-
name|pr
operator|->
name|ndpr_lastupdate
condition|)
name|p
operator|.
name|expire
operator|=
name|pr
operator|->
name|ndpr_lastupdate
operator|+
name|pr
operator|->
name|ndpr_vltime
operator|+
operator|(
name|time_second
operator|-
name|time_uptime
operator|)
expr_stmt|;
else|else
name|p
operator|.
name|expire
operator|=
name|maxexpire
expr_stmt|;
block|}
name|p
operator|.
name|refcnt
operator|=
name|pr
operator|->
name|ndpr_refcnt
expr_stmt|;
name|p
operator|.
name|flags
operator|=
name|pr
operator|->
name|ndpr_stateflags
expr_stmt|;
name|p
operator|.
name|advrtrs
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pfr
argument_list|,
argument|&pr->ndpr_advrtrs
argument_list|,
argument|pfr_entry
argument_list|)
name|p
operator|.
name|advrtrs
operator|++
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|pfr
argument_list|,
argument|&pr->ndpr_advrtrs
argument_list|,
argument|pfr_entry
argument_list|)
block|{
name|s6
operator|.
name|sin6_addr
operator|=
name|pfr
operator|->
name|router
operator|->
name|rtaddr
expr_stmt|;
if|if
condition|(
name|sa6_recoverscope
argument_list|(
operator|&
name|s6
argument_list|)
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"scope error in prefix list (%s)\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6buf
argument_list|,
operator|&
name|pfr
operator|->
name|router
operator|->
name|rtaddr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|s6
argument_list|,
sizeof|sizeof
argument_list|(
name|s6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

