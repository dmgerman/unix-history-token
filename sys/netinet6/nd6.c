begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$KAME: nd6.c,v 1.144 2001/05/24 07:44:00 itojun Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/iso88025.h>
end_include

begin_include
include|#
directive|include
file|<net/fddi.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/scope6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_define
define|#
directive|define
name|ND6_SLOWTIMER_INTERVAL
value|(60 * 60)
end_define

begin_comment
comment|/* 1 hour */
end_comment

begin_define
define|#
directive|define
name|ND6_RECALC_REACHTM_INTERVAL
value|(60 * 120)
end_define

begin_comment
comment|/* 2 hours */
end_comment

begin_define
define|#
directive|define
name|SIN6
parameter_list|(
name|s
parameter_list|)
value|((struct sockaddr_in6 *)s)
end_define

begin_define
define|#
directive|define
name|SDL
parameter_list|(
name|s
parameter_list|)
value|((struct sockaddr_dl *)s)
end_define

begin_comment
comment|/* timer values */
end_comment

begin_decl_stmt
name|int
name|nd6_prune
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* walk list every 1 seconds */
end_comment

begin_decl_stmt
name|int
name|nd6_delay
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delay first probe time 5 second */
end_comment

begin_decl_stmt
name|int
name|nd6_umaxtries
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum unicast query */
end_comment

begin_decl_stmt
name|int
name|nd6_mmaxtries
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum multicast query */
end_comment

begin_decl_stmt
name|int
name|nd6_useloopback
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use loopback interface for local traffic */
end_comment

begin_decl_stmt
name|int
name|nd6_gctimer
init|=
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 day: garbage collection timer */
end_comment

begin_comment
comment|/* preventing too many loops in ND option parsing */
end_comment

begin_decl_stmt
name|int
name|nd6_maxndopt
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max # of ND options allowed */
end_comment

begin_decl_stmt
name|int
name|nd6_maxnudhint
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max # of subsequent upper layer hints */
end_comment

begin_decl_stmt
name|int
name|nd6_maxqueuelen
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max # of packets cached in unresolved ND entries */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ND6_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|nd6_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|nd6_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* for debugging? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nd6_inuse
decl_stmt|,
name|nd6_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|llinfo_nd6
name|llinfo_nd6
init|=
block|{
operator|&
name|llinfo_nd6
block|,
operator|&
name|llinfo_nd6
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nd_drhead
name|nd_defrouter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nd_prhead
name|nd_prefix
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nd6_recalc_reachtm_interval
init|=
name|ND6_RECALC_REACHTM_INTERVAL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in6
name|all1_sa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nd6_is_new_addr_neighbor
name|__P
argument_list|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|,
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nd6_setmtu0
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|nd_ifinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nd6_slowtimo
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|regen_tmpaddr
name|__P
argument_list|(
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|llinfo_nd6
modifier|*
name|nd6_free
name|__P
argument_list|(
operator|(
expr|struct
name|rtentry
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nd6_llinfo_timer
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_llinfo_pqueue
name|__P
argument_list|(
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|callout
name|nd6_slowtimo_ch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|callout
name|nd6_timer_ch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|callout
name|in6_tmpaddrtimer_ch
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|nd6_init
parameter_list|()
block|{
specifier|static
name|int
name|nd6_init_done
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nd6_init_done
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"nd6_init called more than once(ignored)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|all1_sa
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|all1_sa
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|all1_sa
operator|.
name|sin6_addr
argument_list|)
condition|;
name|i
operator|++
control|)
name|all1_sa
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* initialization of the default router list */
name|TAILQ_INIT
argument_list|(
operator|&
name|nd_defrouter
argument_list|)
expr_stmt|;
name|nd6_init_done
operator|=
literal|1
expr_stmt|;
comment|/* start timer */
name|callout_init
argument_list|(
operator|&
name|nd6_slowtimo_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nd6_slowtimo_ch
argument_list|,
name|ND6_SLOWTIMER_INTERVAL
operator|*
name|hz
argument_list|,
name|nd6_slowtimo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|nd_ifinfo
modifier|*
name|nd6_ifattach
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|nd_ifinfo
modifier|*
name|nd
decl_stmt|;
name|nd
operator|=
operator|(
expr|struct
name|nd_ifinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nd
argument_list|)
argument_list|,
name|M_IP6NDP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|nd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nd
argument_list|)
argument_list|)
expr_stmt|;
name|nd
operator|->
name|initialized
operator|=
literal|1
expr_stmt|;
name|nd
operator|->
name|chlim
operator|=
name|IPV6_DEFHLIM
expr_stmt|;
name|nd
operator|->
name|basereachable
operator|=
name|REACHABLE_TIME
expr_stmt|;
name|nd
operator|->
name|reachable
operator|=
name|ND_COMPUTE_RTIME
argument_list|(
name|nd
operator|->
name|basereachable
argument_list|)
expr_stmt|;
name|nd
operator|->
name|retrans
operator|=
name|RETRANS_TIMER
expr_stmt|;
comment|/* 	 * Note that the default value of ip6_accept_rtadv is 0, which means 	 * we won't accept RAs by default even if we set ND6_IFF_ACCEPT_RTADV 	 * here. 	 */
name|nd
operator|->
name|flags
operator|=
operator|(
name|ND6_IFF_PERFORMNUD
operator||
name|ND6_IFF_ACCEPT_RTADV
operator|)
expr_stmt|;
comment|/* XXX: we cannot call nd6_setmtu since ifp is not fully initialized */
name|nd6_setmtu0
argument_list|(
name|ifp
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
name|nd
return|;
block|}
end_function

begin_function
name|void
name|nd6_ifdetach
parameter_list|(
name|nd
parameter_list|)
name|struct
name|nd_ifinfo
modifier|*
name|nd
decl_stmt|;
block|{
name|free
argument_list|(
name|nd
argument_list|,
name|M_IP6NDP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset ND level link MTU. This function is called when the physical MTU  * changes, which means we might have to adjust the ND level MTU.  */
end_comment

begin_function
name|void
name|nd6_setmtu
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|nd6_setmtu0
argument_list|(
name|ifp
argument_list|,
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX todo: do not maintain copy of ifp->if_mtu in ndi->maxmtu */
end_comment

begin_function
name|void
name|nd6_setmtu0
parameter_list|(
name|ifp
parameter_list|,
name|ndi
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|nd_ifinfo
modifier|*
name|ndi
decl_stmt|;
block|{
name|u_int32_t
name|omaxmtu
decl_stmt|;
name|omaxmtu
operator|=
name|ndi
operator|->
name|maxmtu
expr_stmt|;
switch|switch
condition|(
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ARCNET
case|:
name|ndi
operator|->
name|maxmtu
operator|=
name|MIN
argument_list|(
name|ARC_PHDS_MAXMTU
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
comment|/* RFC2497 */
break|break;
case|case
name|IFT_FDDI
case|:
name|ndi
operator|->
name|maxmtu
operator|=
name|MIN
argument_list|(
name|FDDIIPMTU
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
comment|/* RFC2467 */
break|break;
case|case
name|IFT_ISO88025
case|:
name|ndi
operator|->
name|maxmtu
operator|=
name|MIN
argument_list|(
name|ISO88025_MAX_MTU
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ndi
operator|->
name|maxmtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
break|break;
block|}
comment|/* 	 * Decreasing the interface MTU under IPV6 minimum MTU may cause 	 * undesirable situation.  We thus notify the operator of the change 	 * explicitly.  The check for omaxmtu is necessary to restrict the 	 * log to the case of changing the MTU, not initializing it. 	 */
if|if
condition|(
name|omaxmtu
operator|>=
name|IPV6_MMTU
operator|&&
name|ndi
operator|->
name|maxmtu
operator|<
name|IPV6_MMTU
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"nd6_setmtu0: "
literal|"new link MTU on %s (%lu) is too small for IPv6\n"
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ndi
operator|->
name|maxmtu
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ndi
operator|->
name|maxmtu
operator|>
name|in6_maxmtu
condition|)
name|in6_setmaxmtu
argument_list|()
expr_stmt|;
comment|/* check all interfaces just in case */
undef|#
directive|undef
name|MIN
block|}
end_function

begin_function
name|void
name|nd6_option_init
parameter_list|(
name|opt
parameter_list|,
name|icmp6len
parameter_list|,
name|ndopts
parameter_list|)
name|void
modifier|*
name|opt
decl_stmt|;
name|int
name|icmp6len
decl_stmt|;
name|union
name|nd_opts
modifier|*
name|ndopts
decl_stmt|;
block|{
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_search
operator|=
operator|(
expr|struct
name|nd_opt_hdr
operator|*
operator|)
name|opt
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_last
operator|=
operator|(
expr|struct
name|nd_opt_hdr
operator|*
operator|)
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
name|opt
operator|)
operator|+
name|icmp6len
operator|)
expr_stmt|;
if|if
condition|(
name|icmp6len
operator|==
literal|0
condition|)
block|{
name|ndopts
operator|->
name|nd_opts_done
operator|=
literal|1
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_search
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Take one ND option.  */
end_comment

begin_function
name|struct
name|nd_opt_hdr
modifier|*
name|nd6_option
parameter_list|(
name|ndopts
parameter_list|)
name|union
name|nd_opts
modifier|*
name|ndopts
decl_stmt|;
block|{
name|struct
name|nd_opt_hdr
modifier|*
name|nd_opt
decl_stmt|;
name|int
name|olen
decl_stmt|;
if|if
condition|(
name|ndopts
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ndopts == NULL in nd6_option"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_last
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"uninitialized ndopts in nd6_option"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_search
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_done
condition|)
return|return
name|NULL
return|;
name|nd_opt
operator|=
name|ndopts
operator|->
name|nd_opts_search
expr_stmt|;
comment|/* make sure nd_opt_len is inside the buffer */
if|if
condition|(
operator|(
name|caddr_t
operator|)
operator|&
name|nd_opt
operator|->
name|nd_opt_len
operator|>=
operator|(
name|caddr_t
operator|)
name|ndopts
operator|->
name|nd_opts_last
condition|)
block|{
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|olen
operator|=
name|nd_opt
operator|->
name|nd_opt_len
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|olen
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Message validation requires that all included 		 * options have a length that is greater than zero. 		 */
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ndopts
operator|->
name|nd_opts_search
operator|=
operator|(
expr|struct
name|nd_opt_hdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|nd_opt
operator|+
name|olen
operator|)
expr_stmt|;
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_search
operator|>
name|ndopts
operator|->
name|nd_opts_last
condition|)
block|{
comment|/* option overruns the end of buffer, invalid */
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_search
operator|==
name|ndopts
operator|->
name|nd_opts_last
condition|)
block|{
comment|/* reached the end of options chain */
name|ndopts
operator|->
name|nd_opts_done
operator|=
literal|1
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_search
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|nd_opt
return|;
block|}
end_function

begin_comment
comment|/*  * Parse multiple ND options.  * This function is much easier to use, for ND routines that do not need  * multiple options of the same type.  */
end_comment

begin_function
name|int
name|nd6_options
parameter_list|(
name|ndopts
parameter_list|)
name|union
name|nd_opts
modifier|*
name|ndopts
decl_stmt|;
block|{
name|struct
name|nd_opt_hdr
modifier|*
name|nd_opt
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ndopts
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ndopts == NULL in nd6_options"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_last
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"uninitialized ndopts in nd6_options"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_search
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|nd_opt
operator|=
name|nd6_option
argument_list|(
name|ndopts
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd_opt
operator|==
name|NULL
operator|&&
name|ndopts
operator|->
name|nd_opts_last
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Message validation requires that all included 			 * options have a length that is greater than zero. 			 */
name|icmp6stat
operator|.
name|icp6s_nd_badopt
operator|++
expr_stmt|;
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|nd_opt
operator|==
name|NULL
condition|)
goto|goto
name|skip1
goto|;
switch|switch
condition|(
name|nd_opt
operator|->
name|nd_opt_type
condition|)
block|{
case|case
name|ND_OPT_SOURCE_LINKADDR
case|:
case|case
name|ND_OPT_TARGET_LINKADDR
case|:
case|case
name|ND_OPT_MTU
case|:
case|case
name|ND_OPT_REDIRECTED_HEADER
case|:
if|if
condition|(
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
condition|)
block|{
name|nd6log
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"duplicated ND6 option found (type=%d)\n"
operator|,
name|nd_opt
operator|->
name|nd_opt_type
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX bark? */
block|}
else|else
block|{
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
operator|=
name|nd_opt
expr_stmt|;
block|}
break|break;
case|case
name|ND_OPT_PREFIX_INFORMATION
case|:
if|if
condition|(
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
operator|==
literal|0
condition|)
block|{
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
operator|=
name|nd_opt
expr_stmt|;
block|}
name|ndopts
operator|->
name|nd_opts_pi_end
operator|=
operator|(
expr|struct
name|nd_opt_prefix_info
operator|*
operator|)
name|nd_opt
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Unknown options must be silently ignored, 			 * to accomodate future extension to the protocol. 			 */
name|nd6log
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"nd6_options: unsupported option %d - "
literal|"option ignored\n"
operator|,
name|nd_opt
operator|->
name|nd_opt_type
operator|)
argument_list|)
expr_stmt|;
block|}
name|skip1
label|:
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|nd6_maxndopt
condition|)
block|{
name|icmp6stat
operator|.
name|icp6s_nd_toomanyopt
operator|++
expr_stmt|;
name|nd6log
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"too many loop in nd opt\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_done
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ND6 timer routine to handle ND6 entries  */
end_comment

begin_function
name|void
name|nd6_llinfo_settimer
parameter_list|(
name|ln
parameter_list|,
name|tick
parameter_list|)
name|struct
name|llinfo_nd6
modifier|*
name|ln
decl_stmt|;
name|long
name|tick
decl_stmt|;
block|{
if|if
condition|(
name|tick
operator|<
literal|0
condition|)
block|{
name|ln
operator|->
name|ln_expire
operator|=
literal|0
expr_stmt|;
name|ln
operator|->
name|ln_ntick
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|ln
operator|->
name|ln_timer_ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|->
name|ln_expire
operator|=
name|time_second
operator|+
name|tick
operator|/
name|hz
expr_stmt|;
if|if
condition|(
name|tick
operator|>
name|INT_MAX
condition|)
block|{
name|ln
operator|->
name|ln_ntick
operator|=
name|tick
operator|-
name|INT_MAX
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ln
operator|->
name|ln_timer_ch
argument_list|,
name|INT_MAX
argument_list|,
name|nd6_llinfo_timer
argument_list|,
name|ln
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|->
name|ln_ntick
operator|=
literal|0
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ln
operator|->
name|ln_timer_ch
argument_list|,
name|tick
argument_list|,
name|nd6_llinfo_timer
argument_list|,
name|ln
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nd6_llinfo_timer
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|llinfo_nd6
modifier|*
name|ln
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|dst
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|nd_ifinfo
modifier|*
name|ndi
init|=
name|NULL
decl_stmt|;
name|ln
operator|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_ntick
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ln
operator|->
name|ln_ntick
operator|>
name|INT_MAX
condition|)
block|{
name|ln
operator|->
name|ln_ntick
operator|-=
name|INT_MAX
expr_stmt|;
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|->
name|ln_ntick
operator|=
literal|0
expr_stmt|;
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
name|ln
operator|->
name|ln_ntick
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|(
name|rt
operator|=
name|ln
operator|->
name|ln_rt
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ln->ln_rt == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|rt
operator|->
name|rt_ifp
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ln->ln_rt->rt_ifp == NULL"
argument_list|)
expr_stmt|;
name|ndi
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* sanity check */
if|if
condition|(
name|rt
operator|->
name|rt_llinfo
operator|&&
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
operator|!=
name|ln
condition|)
name|panic
argument_list|(
literal|"rt_llinfo(%p) is not equal to ln(%p)"
argument_list|,
name|rt
operator|->
name|rt_llinfo
argument_list|,
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt_key
argument_list|(
name|rt
argument_list|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"rt key is NULL in nd6_timer(ln=%p)"
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt_key
argument_list|(
name|rt
argument_list|)
operator|)
operator|->
name|sin6_addr
expr_stmt|;
switch|switch
condition|(
name|ln
operator|->
name|ln_state
condition|)
block|{
case|case
name|ND6_LLINFO_INCOMPLETE
case|:
if|if
condition|(
name|ln
operator|->
name|ln_asked
operator|<
name|nd6_mmaxtries
condition|)
block|{
name|ln
operator|->
name|ln_asked
operator|++
expr_stmt|;
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|ndi
operator|->
name|retrans
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|nd6_ns_output
argument_list|(
name|ifp
argument_list|,
name|NULL
argument_list|,
name|dst
argument_list|,
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|ln
operator|->
name|ln_hold
decl_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
comment|/* 				 * assuming every packet in ln_hold has the 				 * same IP header 				 */
name|m0
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|icmp6_error2
argument_list|(
name|m
argument_list|,
name|ICMP6_DST_UNREACH
argument_list|,
name|ICMP6_DST_UNREACH_ADDR
argument_list|,
literal|0
argument_list|,
name|rt
operator|->
name|rt_ifp
argument_list|)
expr_stmt|;
name|ln
operator|->
name|ln_hold
operator|=
name|m0
expr_stmt|;
name|clear_llinfo_pqueue
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rt
condition|)
operator|(
name|void
operator|)
name|nd6_free
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ln
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|ND6_LLINFO_REACHABLE
case|:
if|if
condition|(
operator|!
name|ND6_LLINFO_PERMANENT
argument_list|(
name|ln
argument_list|)
condition|)
block|{
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_STALE
expr_stmt|;
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|nd6_gctimer
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ND6_LLINFO_STALE
case|:
comment|/* Garbage Collection(RFC 2461 5.3) */
if|if
condition|(
operator|!
name|ND6_LLINFO_PERMANENT
argument_list|(
name|ln
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|nd6_free
argument_list|(
name|rt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ln
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|ND6_LLINFO_DELAY
case|:
if|if
condition|(
name|ndi
operator|&&
operator|(
name|ndi
operator|->
name|flags
operator|&
name|ND6_IFF_PERFORMNUD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We need NUD */
name|ln
operator|->
name|ln_asked
operator|=
literal|1
expr_stmt|;
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_PROBE
expr_stmt|;
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|ndi
operator|->
name|retrans
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|nd6_ns_output
argument_list|(
name|ifp
argument_list|,
name|dst
argument_list|,
name|dst
argument_list|,
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_STALE
expr_stmt|;
comment|/* XXX */
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|nd6_gctimer
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ND6_LLINFO_PROBE
case|:
if|if
condition|(
name|ln
operator|->
name|ln_asked
operator|<
name|nd6_umaxtries
condition|)
block|{
name|ln
operator|->
name|ln_asked
operator|++
expr_stmt|;
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|ndi
operator|->
name|retrans
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|nd6_ns_output
argument_list|(
name|ifp
argument_list|,
name|dst
argument_list|,
name|dst
argument_list|,
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rt
operator|->
name|rt_ifa
operator|!=
name|NULL
operator|&&
name|rt
operator|->
name|rt_ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|&&
operator|(
operator|(
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|rt
operator|->
name|rt_ifa
operator|)
operator|->
name|ia_flags
operator|&
name|IFA_ROUTE
operator|)
condition|)
block|{
comment|/* 			 * This is an unreachable neighbor whose address is 			 * specified as the destination of a p2p interface 			 * (see in6_ifinit()).  We should not free the entry 			 * since this is sort of a "static" entry generated 			 * via interface address configuration.  			 */
name|ln
operator|->
name|ln_asked
operator|=
literal|0
expr_stmt|;
name|ln
operator|->
name|ln_expire
operator|=
literal|0
expr_stmt|;
comment|/* make it permanent */
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_STALE
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|nd6_free
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ln
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * ND6 timer routine to expire default route list and prefix list  */
end_comment

begin_function
name|void
name|nd6_timer
parameter_list|(
name|ignored_arg
parameter_list|)
name|void
modifier|*
name|ignored_arg
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|;
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|,
modifier|*
name|nia6
decl_stmt|;
name|struct
name|in6_addrlifetime
modifier|*
name|lt6
decl_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nd6_timer_ch
argument_list|,
name|nd6_prune
operator|*
name|hz
argument_list|,
name|nd6_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* expire default router list */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|dr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|nd_defrouter
argument_list|)
expr_stmt|;
while|while
condition|(
name|dr
condition|)
block|{
if|if
condition|(
name|dr
operator|->
name|expire
operator|&&
name|dr
operator|->
name|expire
operator|<
name|time_second
condition|)
block|{
name|struct
name|nd_defrouter
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|TAILQ_NEXT
argument_list|(
name|dr
argument_list|,
name|dr_entry
argument_list|)
expr_stmt|;
name|defrtrlist_del
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|dr
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|dr
operator|=
name|TAILQ_NEXT
argument_list|(
name|dr
argument_list|,
name|dr_entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * expire interface addresses. 	 * in the past the loop was inside prefix expiry processing. 	 * However, from a stricter speci-confrmance standpoint, we should 	 * rather separate address lifetimes and prefix lifetimes. 	 */
name|addrloop
label|:
for|for
control|(
name|ia6
operator|=
name|in6_ifaddr
init|;
name|ia6
condition|;
name|ia6
operator|=
name|nia6
control|)
block|{
name|nia6
operator|=
name|ia6
operator|->
name|ia_next
expr_stmt|;
comment|/* check address lifetime */
name|lt6
operator|=
operator|&
name|ia6
operator|->
name|ia6_lifetime
expr_stmt|;
if|if
condition|(
name|IFA6_IS_INVALID
argument_list|(
name|ia6
argument_list|)
condition|)
block|{
name|int
name|regen
init|=
literal|0
decl_stmt|;
comment|/* 			 * If the expiring address is temporary, try 			 * regenerating a new one.  This would be useful when 			 * we suspended a laptop PC, then turned it on after a 			 * period that could invalidate all temporary 			 * addresses.  Although we may have to restart the 			 * loop (see below), it must be after purging the 			 * address.  Otherwise, we'd see an infinite loop of 			 * regeneration. 			 */
if|if
condition|(
name|ip6_use_tempaddr
operator|&&
operator|(
name|ia6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_TEMPORARY
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|regen_tmpaddr
argument_list|(
name|ia6
argument_list|)
operator|==
literal|0
condition|)
name|regen
operator|=
literal|1
expr_stmt|;
block|}
name|in6_purgeaddr
argument_list|(
operator|&
name|ia6
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
if|if
condition|(
name|regen
condition|)
goto|goto
name|addrloop
goto|;
comment|/* XXX: see below */
block|}
elseif|else
if|if
condition|(
name|IFA6_IS_DEPRECATED
argument_list|(
name|ia6
argument_list|)
condition|)
block|{
name|int
name|oldflags
init|=
name|ia6
operator|->
name|ia6_flags
decl_stmt|;
name|ia6
operator|->
name|ia6_flags
operator||=
name|IN6_IFF_DEPRECATED
expr_stmt|;
comment|/* 			 * If a temporary address has just become deprecated, 			 * regenerate a new one if possible. 			 */
if|if
condition|(
name|ip6_use_tempaddr
operator|&&
operator|(
name|ia6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_TEMPORARY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|oldflags
operator|&
name|IN6_IFF_DEPRECATED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|regen_tmpaddr
argument_list|(
name|ia6
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * A new temporary address is 					 * generated. 					 * XXX: this means the address chain 					 * has changed while we are still in 					 * the loop.  Although the change 					 * would not cause disaster (because 					 * it's not a deletion, but an 					 * addition,) we'd rather restart the 					 * loop just for safety.  Or does this 					 * significantly reduce performance?? 					 */
goto|goto
name|addrloop
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * A new RA might have made a deprecated address 			 * preferred. 			 */
name|ia6
operator|->
name|ia6_flags
operator|&=
operator|~
name|IN6_IFF_DEPRECATED
expr_stmt|;
block|}
block|}
comment|/* expire prefix list */
name|pr
operator|=
name|nd_prefix
operator|.
name|lh_first
expr_stmt|;
while|while
condition|(
name|pr
condition|)
block|{
comment|/* 		 * check prefix lifetime. 		 * since pltime is just for autoconf, pltime processing for 		 * prefix is not necessary. 		 */
if|if
condition|(
name|pr
operator|->
name|ndpr_vltime
operator|!=
name|ND6_INFINITE_LIFETIME
operator|&&
name|time_second
operator|-
name|pr
operator|->
name|ndpr_lastupdate
operator|>
name|pr
operator|->
name|ndpr_vltime
condition|)
block|{
name|struct
name|nd_prefix
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|pr
operator|->
name|ndpr_next
expr_stmt|;
comment|/* 			 * address expiration and prefix expiration are 			 * separate.  NEVER perform in6_purgeaddr here. 			 */
name|prelist_remove
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|pr
operator|=
name|t
expr_stmt|;
block|}
else|else
name|pr
operator|=
name|pr
operator|->
name|ndpr_next
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|regen_tmpaddr
parameter_list|(
name|ia6
parameter_list|)
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|;
comment|/* deprecated/invalidated temporary address */
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|public_ifa6
init|=
name|NULL
decl_stmt|;
name|ifp
operator|=
name|ia6
operator|->
name|ia_ifa
operator|.
name|ifa_ifp
expr_stmt|;
for|for
control|(
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
operator|.
name|tqh_first
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_list
operator|.
name|tqe_next
control|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|it6
decl_stmt|;
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|it6
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa
expr_stmt|;
comment|/* ignore no autoconf addresses. */
if|if
condition|(
operator|(
name|it6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_AUTOCONF
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* ignore autoconf addresses with different prefixes. */
if|if
condition|(
name|it6
operator|->
name|ia6_ndpr
operator|==
name|NULL
operator|||
name|it6
operator|->
name|ia6_ndpr
operator|!=
name|ia6
operator|->
name|ia6_ndpr
condition|)
continue|continue;
comment|/* 		 * Now we are looking at an autoconf address with the same 		 * prefix as ours.  If the address is temporary and is still 		 * preferred, do not create another one.  It would be rare, but 		 * could happen, for example, when we resume a laptop PC after 		 * a long period. 		 */
if|if
condition|(
operator|(
name|it6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_TEMPORARY
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|IFA6_IS_DEPRECATED
argument_list|(
name|it6
argument_list|)
condition|)
block|{
name|public_ifa6
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* 		 * This is a public autoconf address that has the same prefix 		 * as ours.  If it is preferred, keep it.  We can't break the 		 * loop here, because there may be a still-preferred temporary 		 * address with the prefix. 		 */
if|if
condition|(
operator|!
name|IFA6_IS_DEPRECATED
argument_list|(
name|it6
argument_list|)
condition|)
name|public_ifa6
operator|=
name|it6
expr_stmt|;
block|}
if|if
condition|(
name|public_ifa6
operator|!=
name|NULL
condition|)
block|{
name|int
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|in6_tmpifadd
argument_list|(
name|public_ifa6
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"regen_tmpaddr: failed to create a new"
literal|" tmp addr,errno=%d\n"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Nuke neighbor cache/prefix/default router management table, right before  * ifp goes away.  */
end_comment

begin_function
name|void
name|nd6_purge
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|llinfo_nd6
modifier|*
name|ln
decl_stmt|,
modifier|*
name|nln
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|,
modifier|*
name|ndr
decl_stmt|;
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|,
modifier|*
name|npr
decl_stmt|;
comment|/* 	 * Nuke default router list entries toward ifp. 	 * We defer removal of default router list entries that is installed 	 * in the routing table, in order to keep additional side effects as 	 * small as possible. 	 */
for|for
control|(
name|dr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|nd_defrouter
argument_list|)
init|;
name|dr
condition|;
name|dr
operator|=
name|ndr
control|)
block|{
name|ndr
operator|=
name|TAILQ_NEXT
argument_list|(
name|dr
argument_list|,
name|dr_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|installed
condition|)
continue|continue;
if|if
condition|(
name|dr
operator|->
name|ifp
operator|==
name|ifp
condition|)
name|defrtrlist_del
argument_list|(
name|dr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|dr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|nd_defrouter
argument_list|)
init|;
name|dr
condition|;
name|dr
operator|=
name|ndr
control|)
block|{
name|ndr
operator|=
name|TAILQ_NEXT
argument_list|(
name|dr
argument_list|,
name|dr_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dr
operator|->
name|installed
condition|)
continue|continue;
if|if
condition|(
name|dr
operator|->
name|ifp
operator|==
name|ifp
condition|)
name|defrtrlist_del
argument_list|(
name|dr
argument_list|)
expr_stmt|;
block|}
comment|/* Nuke prefix list entries toward ifp */
for|for
control|(
name|pr
operator|=
name|nd_prefix
operator|.
name|lh_first
init|;
name|pr
condition|;
name|pr
operator|=
name|npr
control|)
block|{
name|npr
operator|=
name|pr
operator|->
name|ndpr_next
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|ndpr_ifp
operator|==
name|ifp
condition|)
block|{
comment|/* 			 * Because if_detach() does *not* release prefixes 			 * while purging addresses the reference count will 			 * still be above zero. We therefore reset it to 			 * make sure that the prefix really gets purged. 			 */
name|pr
operator|->
name|ndpr_refcnt
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Previously, pr->ndpr_addr is removed as well, 			 * but I strongly believe we don't have to do it. 			 * nd6_purge() is only called from in6_ifdetach(), 			 * which removes all the associated interface addresses 			 * by itself. 			 * (jinmei@kame.net 20010129) 			 */
name|prelist_remove
argument_list|(
name|pr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* cancel default outgoing interface setting */
if|if
condition|(
name|nd6_defifindex
operator|==
name|ifp
operator|->
name|if_index
condition|)
name|nd6_setdefaultiface
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip6_forwarding
operator|&&
name|ip6_accept_rtadv
condition|)
block|{
comment|/* XXX: too restrictive? */
comment|/* refresh default router list */
name|defrouter_select
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Nuke neighbor cache entries for the ifp. 	 * Note that rt->rt_ifp may not be the same as ifp, 	 * due to KAME goto ours hack.  See RTM_RESOLVE case in 	 * nd6_rtrequest(), and ip6_input(). 	 */
name|ln
operator|=
name|llinfo_nd6
operator|.
name|ln_next
expr_stmt|;
while|while
condition|(
name|ln
operator|&&
name|ln
operator|!=
operator|&
name|llinfo_nd6
condition|)
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|nln
operator|=
name|ln
operator|->
name|ln_next
expr_stmt|;
name|rt
operator|=
name|ln
operator|->
name|ln_rt
expr_stmt|;
if|if
condition|(
name|rt
operator|&&
name|rt
operator|->
name|rt_gateway
operator|&&
name|rt
operator|->
name|rt_gateway
operator|->
name|sa_family
operator|==
name|AF_LINK
condition|)
block|{
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
expr_stmt|;
if|if
condition|(
name|sdl
operator|->
name|sdl_index
operator|==
name|ifp
operator|->
name|if_index
condition|)
name|nln
operator|=
name|nd6_free
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ln
operator|=
name|nln
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|rtentry
modifier|*
name|nd6_lookup
parameter_list|(
name|addr6
parameter_list|,
name|create
parameter_list|,
name|ifp
parameter_list|)
name|struct
name|in6_addr
modifier|*
name|addr6
decl_stmt|;
name|int
name|create
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|=
operator|*
name|addr6
expr_stmt|;
name|rt
operator|=
name|rtalloc1
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
name|create
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
condition|)
block|{
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LLINFO
operator|)
operator|==
literal|0
operator|&&
name|create
condition|)
block|{
comment|/* 			 * This is the case for the default route. 			 * If we want to create a neighbor cache for the 			 * address, we should free the route for the 			 * destination and allocate an interface route. 			 */
name|RTFREE_LOCKED
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|create
operator|&&
name|ifp
condition|)
block|{
name|int
name|e
decl_stmt|;
comment|/* 			 * If no route is available and create is set, 			 * we allocate a host route for the destination 			 * and treat it like an interface route. 			 * This hack is necessary for a neighbor which can't 			 * be covered by our own prefix. 			 */
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
name|ifaof_ifpforaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
name|ifa
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 			 * Create a new route.  RTF_LLINFO is necessary 			 * to create a Neighbor Cache entry for the 			 * destination in nd6_rtrequest which will be 			 * called in rtrequest via ifa->ifa_rtrequest. 			 */
if|if
condition|(
operator|(
name|e
operator|=
name|rtrequest
argument_list|(
name|RTM_ADD
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
name|ifa
operator|->
name|ifa_addr
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|all1_sa
argument_list|,
operator|(
name|ifa
operator|->
name|ifa_flags
operator||
name|RTF_HOST
operator||
name|RTF_LLINFO
operator|)
operator|&
operator|~
name|RTF_CLONING
argument_list|,
operator|&
name|rt
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"nd6_lookup: failed to add route for a "
literal|"neighbor(%s), errno=%d\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|addr6
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|RT_LOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_llinfo
condition|)
block|{
name|struct
name|llinfo_nd6
modifier|*
name|ln
init|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
decl_stmt|;
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_NOSTATE
expr_stmt|;
block|}
block|}
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|RT_LOCK_ASSERT
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|RT_REMREF
argument_list|(
name|rt
argument_list|)
expr_stmt|;
comment|/* 	 * Validation for the entry. 	 * Note that the check for rt_llinfo is necessary because a cloned 	 * route from a parent route that has the L flag (e.g. the default 	 * route to a p2p interface) may have the flag, too, while the 	 * destination is not actually a neighbor. 	 * XXX: we can't use rt->rt_ifp to check for the interface, since 	 *      it might be the loopback interface if the entry is for our 	 *      own address on a non-loopback interface. Instead, we should 	 *      use rt->rt_ifa->ifa_ifp, which would specify the REAL 	 *	interface. 	 * Note also that ifa_ifp and ifp may differ when we connect two 	 * interfaces to a same link, install a link prefix to an interface, 	 * and try to install a neighbor cache on an interface that does not 	 * have a route to the prefix. 	 */
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
operator|)
operator|||
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LLINFO
operator|)
operator|==
literal|0
operator|||
name|rt
operator|->
name|rt_gateway
operator|->
name|sa_family
operator|!=
name|AF_LINK
operator|||
name|rt
operator|->
name|rt_llinfo
operator|==
name|NULL
operator|||
operator|(
name|ifp
operator|&&
name|rt
operator|->
name|rt_ifa
operator|->
name|ifa_ifp
operator|!=
name|ifp
operator|)
condition|)
block|{
if|if
condition|(
name|create
condition|)
block|{
name|nd6log
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"nd6_lookup: failed to lookup %s (if = %s)\n"
operator|,
name|ip6_sprintf
argument_list|(
name|addr6
argument_list|)
operator|,
name|ifp
condition|?
name|if_name
argument_list|(
name|ifp
argument_list|)
else|:
literal|"unspec"
operator|)
argument_list|)
expr_stmt|;
block|}
name|RT_UNLOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|RT_UNLOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
comment|/* XXX not ready to return rt locked */
return|return
operator|(
name|rt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test whether a given IPv6 address is a neighbor or not, ignoring  * the actual neighbor cache.  The neighbor cache is ignored in order  * to not reenter the routing code from within itself.  */
end_comment

begin_function
specifier|static
name|int
name|nd6_is_new_addr_neighbor
parameter_list|(
name|addr
parameter_list|,
name|ifp
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|addr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|dstaddr
decl_stmt|;
comment|/* 	 * A link-local address is always a neighbor. 	 * XXX: a link does not necessarily specify a single interface. 	 */
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|addr
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in6
name|sin6_copy
decl_stmt|;
name|u_int32_t
name|zone
decl_stmt|;
comment|/* 		 * We need sin6_copy since sa6_recoverscope() may modify the 		 * content (XXX). 		 */
name|sin6_copy
operator|=
operator|*
name|addr
expr_stmt|;
if|if
condition|(
name|sa6_recoverscope
argument_list|(
operator|&
name|sin6_copy
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX: should be impossible */
if|if
condition|(
name|in6_setscope
argument_list|(
operator|&
name|sin6_copy
operator|.
name|sin6_addr
argument_list|,
name|ifp
argument_list|,
operator|&
name|zone
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sin6_copy
operator|.
name|sin6_scope_id
operator|==
name|zone
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the address matches one of our addresses, 	 * it should be a neighbor. 	 * If the address matches one of our on-link prefixes, it should be a 	 * neighbor. 	 */
for|for
control|(
name|pr
operator|=
name|nd_prefix
operator|.
name|lh_first
init|;
name|pr
condition|;
name|pr
operator|=
name|pr
operator|->
name|ndpr_next
control|)
block|{
if|if
condition|(
name|pr
operator|->
name|ndpr_ifp
operator|!=
name|ifp
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|pr
operator|->
name|ndpr_stateflags
operator|&
name|NDPRF_ONLINK
operator|)
condition|)
continue|continue;
if|if
condition|(
name|IN6_ARE_MASKED_ADDR_EQUAL
argument_list|(
operator|&
name|pr
operator|->
name|ndpr_prefix
operator|.
name|sin6_addr
argument_list|,
operator|&
name|addr
operator|->
name|sin6_addr
argument_list|,
operator|&
name|pr
operator|->
name|ndpr_mask
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If the address is assigned on the node of the other side of 	 * a p2p interface, the address should be a neighbor. 	 */
name|dstaddr
operator|=
name|ifa_ifwithdstaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dstaddr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|dstaddr
operator|->
name|ifa_ifp
operator|==
name|ifp
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If the default router list is empty, all addresses are regarded 	 * as on-link, and thus, as a neighbor. 	 * XXX: we restrict the condition to hosts, because routers usually do 	 * not have the "default router list". 	 */
if|if
condition|(
operator|!
name|ip6_forwarding
operator|&&
name|TAILQ_FIRST
argument_list|(
operator|&
name|nd_defrouter
argument_list|)
operator|==
name|NULL
operator|&&
name|nd6_defifindex
operator|==
name|ifp
operator|->
name|if_index
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detect if a given IPv6 address identifies a neighbor on a given link.  * XXX: should take care of the destination of a p2p link?  */
end_comment

begin_function
name|int
name|nd6_is_addr_neighbor
parameter_list|(
name|addr
parameter_list|,
name|ifp
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|addr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
if|if
condition|(
name|nd6_is_new_addr_neighbor
argument_list|(
name|addr
argument_list|,
name|ifp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Even if the address matches none of our addresses, it might be 	 * in the neighbor cache. 	 */
if|if
condition|(
name|nd6_lookup
argument_list|(
operator|&
name|addr
operator|->
name|sin6_addr
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free an nd6 llinfo entry.  * Since the function would cause significant changes in the kernel, DO NOT  * make it global, unless you have a strong reason for the change, and are sure  * that the change is safe.  */
end_comment

begin_function
specifier|static
name|struct
name|llinfo_nd6
modifier|*
name|nd6_free
parameter_list|(
name|rt
parameter_list|,
name|gc
parameter_list|)
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|int
name|gc
decl_stmt|;
block|{
name|struct
name|llinfo_nd6
modifier|*
name|ln
init|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|in6_addr
name|in6
init|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt_key
argument_list|(
name|rt
argument_list|)
operator|)
operator|->
name|sin6_addr
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|;
comment|/* 	 * we used to have pfctlinput(PRC_HOSTDEAD) here. 	 * even though it is not harmful, it was not really necessary. 	 */
comment|/* cancel timer */
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip6_forwarding
condition|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|dr
operator|=
name|defrouter_lookup
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt_key
argument_list|(
name|rt
argument_list|)
operator|)
operator|->
name|sin6_addr
argument_list|,
name|rt
operator|->
name|rt_ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|!=
name|NULL
operator|&&
name|dr
operator|->
name|expire
operator|&&
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_STALE
operator|&&
name|gc
condition|)
block|{
comment|/* 			 * If the reason for the deletion is just garbage 			 * collection, and the neighbor is an active default 			 * router, do not delete it.  Instead, reset the GC 			 * timer using the router's lifetime. 			 * Simply deleting the entry would affect default 			 * router selection, which is not necessarily a good 			 * thing, especially when we're using router preference 			 * values. 			 * XXX: the check for ln_state would be redundant, 			 *      but we intentionally keep it just in case. 			 */
if|if
condition|(
name|dr
operator|->
name|expire
operator|>
name|time_second
condition|)
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|(
name|dr
operator|->
name|expire
operator|-
name|time_second
operator|)
operator|*
name|hz
argument_list|)
expr_stmt|;
else|else
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|nd6_gctimer
operator|*
name|hz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ln
operator|->
name|ln_next
operator|)
return|;
block|}
if|if
condition|(
name|ln
operator|->
name|ln_router
operator|||
name|dr
condition|)
block|{
comment|/* 			 * rt6_flush must be called whether or not the neighbor 			 * is in the Default Router List. 			 * See a corresponding comment in nd6_na_input(). 			 */
name|rt6_flush
argument_list|(
operator|&
name|in6
argument_list|,
name|rt
operator|->
name|rt_ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dr
condition|)
block|{
comment|/* 			 * Unreachablity of a router might affect the default 			 * router selection and on-link detection of advertised 			 * prefixes. 			 */
comment|/* 			 * Temporarily fake the state to choose a new default 			 * router and to perform on-link determination of 			 * prefixes correctly. 			 * Below the state will be set correctly, 			 * or the entry itself will be deleted. 			 */
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_INCOMPLETE
expr_stmt|;
comment|/* 			 * Since defrouter_select() does not affect the 			 * on-link determination and MIP6 needs the check 			 * before the default router selection, we perform 			 * the check now. 			 */
name|pfxlist_onlink_check
argument_list|()
expr_stmt|;
comment|/* 			 * refresh default router list 			 */
name|defrouter_select
argument_list|()
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Before deleting the entry, remember the next entry as the 	 * return value.  We need this because pfxlist_onlink_check() above 	 * might have freed other entries (particularly the old next entry) as 	 * a side effect (XXX). 	 */
name|next
operator|=
name|ln
operator|->
name|ln_next
expr_stmt|;
comment|/* 	 * Detach the route from the routing tree and the list of neighbor 	 * caches, and disable the route entry not to be used in already 	 * cached routes. 	 */
name|rtrequest
argument_list|(
name|RTM_DELETE
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
name|rt_mask
argument_list|(
name|rt
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|rtentry
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Upper-layer reachability hint for Neighbor Unreachability Detection.  *  * XXX cost-effective methods?  */
end_comment

begin_function
name|void
name|nd6_nud_hint
parameter_list|(
name|rt
parameter_list|,
name|dst6
parameter_list|,
name|force
parameter_list|)
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|dst6
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|struct
name|llinfo_nd6
modifier|*
name|ln
decl_stmt|;
comment|/* 	 * If the caller specified "rt", use that.  Otherwise, resolve the 	 * routing table by supplied "dst6". 	 */
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dst6
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|rt
operator|=
name|nd6_lookup
argument_list|(
name|dst6
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
block|}
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
operator|)
operator|!=
literal|0
operator|||
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LLINFO
operator|)
operator|==
literal|0
operator|||
name|rt
operator|->
name|rt_llinfo
operator|==
name|NULL
operator|||
name|rt
operator|->
name|rt_gateway
operator|==
name|NULL
operator|||
name|rt
operator|->
name|rt_gateway
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
block|{
comment|/* This is not a host route. */
return|return;
block|}
name|ln
operator|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|<
name|ND6_LLINFO_REACHABLE
condition|)
return|return;
comment|/* 	 * if we get upper-layer reachability confirmation many times, 	 * it is possible we have false information. 	 */
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|ln
operator|->
name|ln_byhint
operator|++
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_byhint
operator|>
name|nd6_maxnudhint
condition|)
return|return;
block|}
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_REACHABLE
expr_stmt|;
if|if
condition|(
operator|!
name|ND6_LLINFO_PERMANENT
argument_list|(
name|ln
argument_list|)
condition|)
block|{
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|ND_IFINFO
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|)
operator|->
name|reachable
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nd6_rtrequest
parameter_list|(
name|req
parameter_list|,
name|rt
parameter_list|,
name|info
parameter_list|)
name|int
name|req
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|rt_addrinfo
modifier|*
name|info
decl_stmt|;
comment|/* xxx unused */
block|{
name|struct
name|sockaddr
modifier|*
name|gate
init|=
name|rt
operator|->
name|rt_gateway
decl_stmt|;
name|struct
name|llinfo_nd6
modifier|*
name|ln
init|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
decl_stmt|;
specifier|static
name|struct
name|sockaddr_dl
name|null_sdl
init|=
block|{
sizeof|sizeof
argument_list|(
name|null_sdl
argument_list|)
block|,
name|AF_LINK
block|}
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|rt
operator|->
name|rt_ifp
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|RT_LOCK_ASSERT
argument_list|(
name|rt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
operator|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|nd6_need_cache
argument_list|(
name|ifp
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_HOST
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This is probably an interface direct route for a link 		 * which does not need neighbor caches (e.g. fe80::%lo0/64). 		 * We do not need special treatment below for such a route. 		 * Moreover, the RTF_LLINFO flag which would be set below 		 * would annoy the ndp(8) command. 		 */
return|return;
block|}
if|if
condition|(
name|req
operator|==
name|RTM_RESOLVE
operator|&&
operator|(
name|nd6_need_cache
argument_list|(
name|ifp
argument_list|)
operator|==
literal|0
operator|||
comment|/* stf case */
operator|!
name|nd6_is_new_addr_neighbor
argument_list|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
name|ifp
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * FreeBSD and BSD/OS often make a cloned host route based 		 * on a less-specific route (e.g. the default route). 		 * If the less specific route does not have a "gateway" 		 * (this is the case when the route just goes to a p2p or an 		 * stf interface), we'll mistakenly make a neighbor cache for 		 * the host route, and will see strange neighbor solicitation 		 * for the corresponding destination.  In order to avoid the 		 * confusion, we check if the destination of the route is 		 * a neighbor in terms of neighbor discovery, and stop the 		 * process if not.  Additionally, we remove the LLINFO flag 		 * so that ndp(8) will not try to get the neighbor information 		 * of the destination. 		 */
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_LLINFO
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|RTM_ADD
case|:
comment|/* 		 * There is no backward compatibility :) 		 * 		 * if ((rt->rt_flags& RTF_HOST) == 0&& 		 *     SIN(rt_mask(rt))->sin_addr.s_addr != 0xffffffff) 		 *	   rt->rt_flags |= RTF_CLONING; 		 */
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_CLONING
operator|)
operator|||
operator|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LLINFO
operator|)
operator|&&
name|ln
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 			 * Case 1: This route should come from a route to 			 * interface (RTF_CLONING case) or the route should be 			 * treated as on-link but is currently not 			 * (RTF_LLINFO&& ln == NULL case). 			 */
name|rt_setgate
argument_list|(
name|rt
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|null_sdl
argument_list|)
expr_stmt|;
name|gate
operator|=
name|rt
operator|->
name|rt_gateway
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_type
operator|=
name|ifp
operator|->
name|if_type
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_index
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
if|if
condition|(
name|ln
condition|)
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_CLONING
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* 		 * In IPv4 code, we try to annonuce new RTF_ANNOUNCE entry here. 		 * We don't do that here since llinfo is not ready yet. 		 * 		 * There are also couple of other things to be discussed: 		 * - unsolicited NA code needs improvement beforehand 		 * - RFC2461 says we MAY send multicast unsolicited NA 		 *   (7.2.6 paragraph 4), however, it also says that we 		 *   SHOULD provide a mechanism to prevent multicast NA storm. 		 *   we don't have anything like it right now. 		 *   note that the mechanism needs a mutual agreement 		 *   between proxies, which means that we need to implement 		 *   a new protocol, or a new kludge. 		 * - from RFC2461 6.2.4, host MUST NOT send an unsolicited NA. 		 *   we need to check ip6forwarding before sending it. 		 *   (or should we allow proxy ND configuration only for 		 *   routers?  there's no mention about proxy ND from hosts) 		 */
comment|/* FALLTHROUGH */
case|case
name|RTM_RESOLVE
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_POINTOPOINT
operator||
name|IFF_LOOPBACK
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Address resolution isn't necessary for a point to 			 * point link, so we can skip this test for a p2p link. 			 */
if|if
condition|(
name|gate
operator|->
name|sa_family
operator|!=
name|AF_LINK
operator|||
name|gate
operator|->
name|sa_len
operator|<
sizeof|sizeof
argument_list|(
name|null_sdl
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"nd6_rtrequest: bad gateway value: %s\n"
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_type
operator|=
name|ifp
operator|->
name|if_type
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_index
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
break|break;
comment|/* This happens on a route change */
comment|/* 		 * Case 2: This route may come from cloning, or a manual route 		 * add with a LL address. 		 */
name|R_Malloc
argument_list|(
name|ln
argument_list|,
expr|struct
name|llinfo_nd6
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ln
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
operator|(
name|caddr_t
operator|)
name|ln
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"nd6_rtrequest: malloc failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|nd6_inuse
operator|++
expr_stmt|;
name|nd6_allocated
operator|++
expr_stmt|;
name|bzero
argument_list|(
name|ln
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ln
argument_list|)
argument_list|)
expr_stmt|;
name|RT_ADDREF
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|ln
operator|->
name|ln_rt
operator|=
name|rt
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|ln
operator|->
name|ln_timer_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* this is required for "ndp" command. - shin */
if|if
condition|(
name|req
operator|==
name|RTM_ADD
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_STATIC
operator|)
condition|)
block|{
comment|/* 			 * gate should have some valid AF_LINK entry, 			 * and ln->ln_expire should have some lifetime 			 * which is specified by ndp command. 			 */
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_REACHABLE
expr_stmt|;
name|ln
operator|->
name|ln_byhint
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * When req == RTM_RESOLVE, rt is created and 			 * initialized in rtrequest(), so rt_expire is 0. 			 */
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_NOSTATE
expr_stmt|;
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|rt
operator|->
name|rt_flags
operator||=
name|RTF_LLINFO
expr_stmt|;
name|ln
operator|->
name|ln_next
operator|=
name|llinfo_nd6
operator|.
name|ln_next
expr_stmt|;
name|llinfo_nd6
operator|.
name|ln_next
operator|=
name|ln
expr_stmt|;
name|ln
operator|->
name|ln_prev
operator|=
operator|&
name|llinfo_nd6
expr_stmt|;
name|ln
operator|->
name|ln_next
operator|->
name|ln_prev
operator|=
name|ln
expr_stmt|;
comment|/* 		 * check if rt_key(rt) is one of my address assigned 		 * to the interface. 		 */
name|ifa
operator|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|in6ifa_ifpwithaddr
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|,
operator|&
name|SIN6
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
condition|)
block|{
name|caddr_t
name|macp
init|=
name|nd6_ifptomac
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_REACHABLE
expr_stmt|;
name|ln
operator|->
name|ln_byhint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|macp
condition|)
block|{
name|bcopy
argument_list|(
name|macp
argument_list|,
name|LLADDR
argument_list|(
name|SDL
argument_list|(
name|gate
argument_list|)
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_alen
operator|=
name|ifp
operator|->
name|if_addrlen
expr_stmt|;
block|}
if|if
condition|(
name|nd6_useloopback
condition|)
block|{
name|rt
operator|->
name|rt_ifp
operator|=
operator|&
name|loif
index|[
literal|0
index|]
expr_stmt|;
comment|/* XXX */
comment|/* 				 * Make sure rt_ifa be equal to the ifaddr 				 * corresponding to the address. 				 * We need this because when we refer 				 * rt_ifa->ia6_flags in ip6_input, we assume 				 * that the rt_ifa points to the address instead 				 * of the loopback address. 				 */
if|if
condition|(
name|ifa
operator|!=
name|rt
operator|->
name|rt_ifa
condition|)
block|{
name|IFAFREE
argument_list|(
name|rt
operator|->
name|rt_ifa
argument_list|)
expr_stmt|;
name|IFAREF
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_ifa
operator|=
name|ifa
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_ANNOUNCE
condition|)
block|{
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_REACHABLE
expr_stmt|;
name|ln
operator|->
name|ln_byhint
operator|=
literal|0
expr_stmt|;
comment|/* join solicited node multicast for proxy ND */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
condition|)
block|{
name|struct
name|in6_addr
name|llsol
decl_stmt|;
name|int
name|error
decl_stmt|;
name|llsol
operator|=
name|SIN6
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|->
name|sin6_addr
expr_stmt|;
name|llsol
operator|.
name|s6_addr32
index|[
literal|0
index|]
operator|=
name|IPV6_ADDR_INT32_MLL
expr_stmt|;
name|llsol
operator|.
name|s6_addr32
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|llsol
operator|.
name|s6_addr32
index|[
literal|2
index|]
operator|=
name|htonl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|llsol
operator|.
name|s6_addr8
index|[
literal|12
index|]
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|in6_setscope
argument_list|(
operator|&
name|llsol
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
if|if
condition|(
name|in6_addmulti
argument_list|(
operator|&
name|llsol
argument_list|,
name|ifp
argument_list|,
operator|&
name|error
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|nd6log
argument_list|(
operator|(
name|LOG_ERR
operator|,
literal|"%s: failed to join "
literal|"%s (errno=%d)\n"
operator|,
name|if_name
argument_list|(
name|ifp
argument_list|)
operator|,
name|ip6_sprintf
argument_list|(
operator|&
name|llsol
argument_list|)
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|RTM_DELETE
case|:
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
break|break;
comment|/* leave from solicited node multicast for proxy ND */
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_ANNOUNCE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|in6_addr
name|llsol
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|in6m
decl_stmt|;
name|llsol
operator|=
name|SIN6
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|->
name|sin6_addr
expr_stmt|;
name|llsol
operator|.
name|s6_addr32
index|[
literal|0
index|]
operator|=
name|IPV6_ADDR_INT32_MLL
expr_stmt|;
name|llsol
operator|.
name|s6_addr32
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|llsol
operator|.
name|s6_addr32
index|[
literal|2
index|]
operator|=
name|htonl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|llsol
operator|.
name|s6_addr8
index|[
literal|12
index|]
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|in6_setscope
argument_list|(
operator|&
name|llsol
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IN6_LOOKUP_MULTI
argument_list|(
name|llsol
argument_list|,
name|ifp
argument_list|,
name|in6m
argument_list|)
expr_stmt|;
if|if
condition|(
name|in6m
condition|)
name|in6_delmulti
argument_list|(
name|in6m
argument_list|)
expr_stmt|;
block|}
else|else
empty_stmt|;
comment|/* XXX: should not happen. bark here? */
block|}
name|nd6_inuse
operator|--
expr_stmt|;
name|ln
operator|->
name|ln_next
operator|->
name|ln_prev
operator|=
name|ln
operator|->
name|ln_prev
expr_stmt|;
name|ln
operator|->
name|ln_prev
operator|->
name|ln_next
operator|=
name|ln
operator|->
name|ln_next
expr_stmt|;
name|ln
operator|->
name|ln_prev
operator|=
name|NULL
expr_stmt|;
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|RT_REMREF
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_LLINFO
expr_stmt|;
name|clear_llinfo_pqueue
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|Free
argument_list|(
operator|(
name|caddr_t
operator|)
name|ln
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|nd6_ioctl
parameter_list|(
name|cmd
parameter_list|,
name|data
parameter_list|,
name|ifp
parameter_list|)
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|in6_drlist
modifier|*
name|drl
init|=
operator|(
expr|struct
name|in6_drlist
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|in6_oprlist
modifier|*
name|oprl
init|=
operator|(
expr|struct
name|in6_oprlist
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|in6_ndireq
modifier|*
name|ndi
init|=
operator|(
expr|struct
name|in6_ndireq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|in6_nbrinfo
modifier|*
name|nbi
init|=
operator|(
expr|struct
name|in6_nbrinfo
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|in6_ndifreq
modifier|*
name|ndif
init|=
operator|(
expr|struct
name|in6_ndifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|;
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGDRLST_IN6
case|:
comment|/* 		 * obsolete API, use sysctl under net.inet6.icmp6 		 */
name|bzero
argument_list|(
name|drl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|drl
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|dr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|nd_defrouter
argument_list|)
expr_stmt|;
while|while
condition|(
name|dr
operator|&&
name|i
operator|<
name|DRLSTSIZ
condition|)
block|{
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|rtaddr
operator|=
name|dr
operator|->
name|rtaddr
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|rtaddr
argument_list|)
expr_stmt|;
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|dr
operator|->
name|flags
expr_stmt|;
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|rtlifetime
operator|=
name|dr
operator|->
name|rtlifetime
expr_stmt|;
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|expire
operator|=
name|dr
operator|->
name|expire
expr_stmt|;
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|if_index
operator|=
name|dr
operator|->
name|ifp
operator|->
name|if_index
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|dr
operator|=
name|TAILQ_NEXT
argument_list|(
name|dr
argument_list|,
name|dr_entry
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGPRLST_IN6
case|:
comment|/* 		 * obsolete API, use sysctl under net.inet6.icmp6 		 * 		 * XXX the structure in6_prlist was changed in backward- 		 * incompatible manner.  in6_oprlist is used for SIOCGPRLST_IN6, 		 * in6_prlist is used for nd6_sysctl() - fill_prlist(). 		 */
comment|/* 		 * XXX meaning of fields, especialy "raflags", is very 		 * differnet between RA prefix list and RR/static prefix list. 		 * how about separating ioctls into two? 		 */
name|bzero
argument_list|(
name|oprl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|oprl
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|pr
operator|=
name|nd_prefix
operator|.
name|lh_first
expr_stmt|;
while|while
condition|(
name|pr
operator|&&
name|i
operator|<
name|PRLSTSIZ
condition|)
block|{
name|struct
name|nd_pfxrouter
modifier|*
name|pfr
decl_stmt|;
name|int
name|j
decl_stmt|;
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|prefix
operator|=
name|pr
operator|->
name|ndpr_prefix
operator|.
name|sin6_addr
expr_stmt|;
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|raflags
operator|=
name|pr
operator|->
name|ndpr_raf
expr_stmt|;
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|prefixlen
operator|=
name|pr
operator|->
name|ndpr_plen
expr_stmt|;
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|vltime
operator|=
name|pr
operator|->
name|ndpr_vltime
expr_stmt|;
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|pltime
operator|=
name|pr
operator|->
name|ndpr_pltime
expr_stmt|;
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|if_index
operator|=
name|pr
operator|->
name|ndpr_ifp
operator|->
name|if_index
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|ndpr_vltime
operator|==
name|ND6_INFINITE_LIFETIME
condition|)
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|expire
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|time_t
name|maxexpire
decl_stmt|;
comment|/* XXX: we assume time_t is signed. */
name|maxexpire
operator|=
operator|(
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|time_t
operator|)
literal|1
operator|<<
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|maxexpire
argument_list|)
operator|*
literal|8
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|ndpr_vltime
operator|<
name|maxexpire
operator|-
name|pr
operator|->
name|ndpr_lastupdate
condition|)
block|{
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|expire
operator|=
name|pr
operator|->
name|ndpr_lastupdate
operator|+
name|pr
operator|->
name|ndpr_vltime
expr_stmt|;
block|}
else|else
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|expire
operator|=
name|maxexpire
expr_stmt|;
block|}
name|pfr
operator|=
name|pr
operator|->
name|ndpr_advrtrs
operator|.
name|lh_first
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pfr
condition|)
block|{
if|if
condition|(
name|j
operator|<
name|DRLSTSIZ
condition|)
block|{
define|#
directive|define
name|RTRADDR
value|oprl->prefix[i].advrtr[j]
name|RTRADDR
operator|=
name|pfr
operator|->
name|router
operator|->
name|rtaddr
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|RTRADDR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|RTRADDR
block|}
name|j
operator|++
expr_stmt|;
name|pfr
operator|=
name|pfr
operator|->
name|pfr_next
expr_stmt|;
block|}
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|advrtrs
operator|=
name|j
expr_stmt|;
name|oprl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|origin
operator|=
name|PR_ORIG_RA
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|pr
operator|=
name|pr
operator|->
name|ndpr_next
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSIOCGIFINFO_IN6
case|:
define|#
directive|define
name|ND
value|ndi->ndi
comment|/* XXX: old ndp(8) assumes a positive value for linkmtu. */
name|bzero
argument_list|(
operator|&
name|ND
argument_list|,
sizeof|sizeof
argument_list|(
name|ND
argument_list|)
argument_list|)
expr_stmt|;
name|ND
operator|.
name|linkmtu
operator|=
name|IN6_LINKMTU
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ND
operator|.
name|maxmtu
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|maxmtu
expr_stmt|;
name|ND
operator|.
name|basereachable
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|basereachable
expr_stmt|;
name|ND
operator|.
name|reachable
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|reachable
expr_stmt|;
name|ND
operator|.
name|retrans
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|retrans
expr_stmt|;
name|ND
operator|.
name|flags
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
expr_stmt|;
name|ND
operator|.
name|recalctm
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|recalctm
expr_stmt|;
name|ND
operator|.
name|chlim
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|chlim
expr_stmt|;
break|break;
case|case
name|SIOCGIFINFO_IN6
case|:
name|ND
operator|=
operator|*
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFINFO_IN6
case|:
comment|/* 		 * used to change host variables from userland. 		 * intented for a use on router to reflect RA configurations. 		 */
comment|/* 0 means 'unspecified' */
if|if
condition|(
name|ND
operator|.
name|linkmtu
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ND
operator|.
name|linkmtu
operator|<
name|IPV6_MMTU
operator|||
name|ND
operator|.
name|linkmtu
operator|>
name|IN6_LINKMTU
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|linkmtu
operator|=
name|ND
operator|.
name|linkmtu
expr_stmt|;
block|}
if|if
condition|(
name|ND
operator|.
name|basereachable
operator|!=
literal|0
condition|)
block|{
name|int
name|obasereachable
init|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|basereachable
decl_stmt|;
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|basereachable
operator|=
name|ND
operator|.
name|basereachable
expr_stmt|;
if|if
condition|(
name|ND
operator|.
name|basereachable
operator|!=
name|obasereachable
condition|)
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|reachable
operator|=
name|ND_COMPUTE_RTIME
argument_list|(
name|ND
operator|.
name|basereachable
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ND
operator|.
name|retrans
operator|!=
literal|0
condition|)
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|retrans
operator|=
name|ND
operator|.
name|retrans
expr_stmt|;
if|if
condition|(
name|ND
operator|.
name|chlim
operator|!=
literal|0
condition|)
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|chlim
operator|=
name|ND
operator|.
name|chlim
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SIOCSIFINFO_FLAGS
case|:
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|=
name|ND
operator|.
name|flags
expr_stmt|;
break|break;
undef|#
directive|undef
name|ND
case|case
name|SIOCSNDFLUSH_IN6
case|:
comment|/* XXX: the ioctl name is confusing... */
comment|/* sync kernel routing table with the default router list */
name|defrouter_reset
argument_list|()
expr_stmt|;
name|defrouter_select
argument_list|()
expr_stmt|;
break|break;
case|case
name|SIOCSPFXFLUSH_IN6
case|:
block|{
comment|/* flush all the prefix advertised by routers */
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|nd_prefix
operator|.
name|lh_first
init|;
name|pr
condition|;
name|pr
operator|=
name|next
control|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ia
decl_stmt|,
modifier|*
name|ia_next
decl_stmt|;
name|next
operator|=
name|pr
operator|->
name|ndpr_next
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|pr
operator|->
name|ndpr_prefix
operator|.
name|sin6_addr
argument_list|)
condition|)
continue|continue;
comment|/* XXX */
comment|/* do we really have to remove addresses as well? */
for|for
control|(
name|ia
operator|=
name|in6_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia_next
control|)
block|{
comment|/* ia might be removed.  keep the next ptr. */
name|ia_next
operator|=
name|ia
operator|->
name|ia_next
expr_stmt|;
if|if
condition|(
operator|(
name|ia
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_AUTOCONF
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ia
operator|->
name|ia6_ndpr
operator|==
name|pr
condition|)
name|in6_purgeaddr
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
block|}
name|prelist_remove
argument_list|(
name|pr
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCSRTRFLUSH_IN6
case|:
block|{
comment|/* flush all the default routers */
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|defrouter_reset
argument_list|()
expr_stmt|;
for|for
control|(
name|dr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|nd_defrouter
argument_list|)
init|;
name|dr
condition|;
name|dr
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|dr
argument_list|,
name|dr_entry
argument_list|)
expr_stmt|;
name|defrtrlist_del
argument_list|(
name|dr
argument_list|)
expr_stmt|;
block|}
name|defrouter_select
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCGNBRINFO_IN6
case|:
block|{
name|struct
name|llinfo_nd6
modifier|*
name|ln
decl_stmt|;
name|struct
name|in6_addr
name|nb_addr
init|=
name|nbi
operator|->
name|addr
decl_stmt|;
comment|/* make local for safety */
if|if
condition|(
operator|(
name|error
operator|=
name|in6_setscope
argument_list|(
operator|&
name|nb_addr
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|=
name|nd6_lookup
argument_list|(
operator|&
name|nb_addr
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|ln
operator|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
expr_stmt|;
name|nbi
operator|->
name|state
operator|=
name|ln
operator|->
name|ln_state
expr_stmt|;
name|nbi
operator|->
name|asked
operator|=
name|ln
operator|->
name|ln_asked
expr_stmt|;
name|nbi
operator|->
name|isrouter
operator|=
name|ln
operator|->
name|ln_router
expr_stmt|;
name|nbi
operator|->
name|expire
operator|=
name|ln
operator|->
name|ln_expire
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCGDEFIFACE_IN6
case|:
comment|/* XXX: should be implemented as a sysctl? */
name|ndif
operator|->
name|ifindex
operator|=
name|nd6_defifindex
expr_stmt|;
break|break;
case|case
name|SIOCSDEFIFACE_IN6
case|:
comment|/* XXX: should be implemented as a sysctl? */
return|return
operator|(
name|nd6_setdefaultiface
argument_list|(
name|ndif
operator|->
name|ifindex
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create neighbor cache entry and cache link-layer address,  * on reception of inbound ND6 packets.  (RS/RA/NS/redirect)  */
end_comment

begin_function
name|struct
name|rtentry
modifier|*
name|nd6_cache_lladdr
parameter_list|(
name|ifp
parameter_list|,
name|from
parameter_list|,
name|lladdr
parameter_list|,
name|lladdrlen
parameter_list|,
name|type
parameter_list|,
name|code
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|lladdr
decl_stmt|;
name|int
name|lladdrlen
decl_stmt|;
name|int
name|type
decl_stmt|;
comment|/* ICMP6 type */
name|int
name|code
decl_stmt|;
comment|/* type dependent information */
block|{
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|NULL
decl_stmt|;
name|struct
name|llinfo_nd6
modifier|*
name|ln
init|=
name|NULL
decl_stmt|;
name|int
name|is_newentry
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
init|=
name|NULL
decl_stmt|;
name|int
name|do_update
decl_stmt|;
name|int
name|olladdr
decl_stmt|;
name|int
name|llchange
decl_stmt|;
name|int
name|newstate
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ifp == NULL in nd6_cache_lladdr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"from == NULL in nd6_cache_lladdr"
argument_list|)
expr_stmt|;
comment|/* nothing must be updated for unspecified address */
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
name|from
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* 	 * Validation about ifp->if_addrlen and lladdrlen must be done in 	 * the caller. 	 * 	 * XXX If the link does not have link-layer adderss, what should 	 * we do? (ifp->if_addrlen == 0) 	 * Spec says nothing in sections for RA, RS and NA.  There's small 	 * description on it in NS section (RFC 2461 7.2.3). 	 */
name|rt
operator|=
name|nd6_lookup
argument_list|(
name|from
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|rt
operator|=
name|nd6_lookup
argument_list|(
name|from
argument_list|,
literal|1
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|is_newentry
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* do nothing if static ndp is set */
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_STATIC
condition|)
return|return
name|NULL
return|;
name|is_newentry
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_GATEWAY
operator||
name|RTF_LLINFO
operator|)
operator|)
operator|!=
name|RTF_LLINFO
condition|)
block|{
name|fail
label|:
operator|(
name|void
operator|)
name|nd6_free
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ln
operator|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|rt
operator|->
name|rt_gateway
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|rt
operator|->
name|rt_gateway
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
goto|goto
name|fail
goto|;
name|sdl
operator|=
name|SDL
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
name|olladdr
operator|=
operator|(
name|sdl
operator|->
name|sdl_alen
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|olladdr
operator|&&
name|lladdr
condition|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|lladdr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
condition|)
name|llchange
operator|=
literal|1
expr_stmt|;
else|else
name|llchange
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|llchange
operator|=
literal|0
expr_stmt|;
comment|/* 	 * newentry olladdr  lladdr  llchange	(*=record) 	 *	0	n	n	--	(1) 	 *	0	y	n	--	(2) 	 *	0	n	y	--	(3) * STALE 	 *	0	y	y	n	(4) * 	 *	0	y	y	y	(5) * STALE 	 *	1	--	n	--	(6)   NOSTATE(= PASSIVE) 	 *	1	--	y	--	(7) * STALE 	 */
if|if
condition|(
name|lladdr
condition|)
block|{
comment|/* (3-5) and (7) */
comment|/* 		 * Record source link-layer address 		 * XXX is it dependent to ifp->if_type? 		 */
name|sdl
operator|->
name|sdl_alen
operator|=
name|ifp
operator|->
name|if_addrlen
expr_stmt|;
name|bcopy
argument_list|(
name|lladdr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_newentry
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|olladdr
operator|&&
name|lladdr
operator|!=
name|NULL
operator|)
operator|||
comment|/* (3) */
operator|(
name|olladdr
operator|&&
name|lladdr
operator|!=
name|NULL
operator|&&
name|llchange
operator|)
condition|)
block|{
comment|/* (5) */
name|do_update
operator|=
literal|1
expr_stmt|;
name|newstate
operator|=
name|ND6_LLINFO_STALE
expr_stmt|;
block|}
else|else
comment|/* (1-2,4) */
name|do_update
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|do_update
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lladdr
operator|==
name|NULL
condition|)
comment|/* (6) */
name|newstate
operator|=
name|ND6_LLINFO_NOSTATE
expr_stmt|;
else|else
comment|/* (7) */
name|newstate
operator|=
name|ND6_LLINFO_STALE
expr_stmt|;
block|}
if|if
condition|(
name|do_update
condition|)
block|{
comment|/* 		 * Update the state of the neighbor cache. 		 */
name|ln
operator|->
name|ln_state
operator|=
name|newstate
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_STALE
condition|)
block|{
comment|/* 			 * XXX: since nd6_output() below will cause 			 * state tansition to DELAY and reset the timer, 			 * we must set the timer now, although it is actually 			 * meaningless. 			 */
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|nd6_gctimer
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_hold
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m_hold
decl_stmt|,
modifier|*
name|m_hold_next
decl_stmt|;
for|for
control|(
name|m_hold
operator|=
name|ln
operator|->
name|ln_hold
init|;
name|m_hold
condition|;
name|m_hold
operator|=
name|m_hold_next
control|)
block|{
name|struct
name|mbuf
modifier|*
name|mpkt
init|=
name|NULL
decl_stmt|;
name|m_hold_next
operator|=
name|m_hold
operator|->
name|m_nextpkt
expr_stmt|;
name|mpkt
operator|=
name|m_copym
argument_list|(
name|m_hold
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpkt
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m_hold
argument_list|)
expr_stmt|;
break|break;
block|}
name|mpkt
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
comment|/* 					 * we assume ifp is not a p2p here, so 					 * just set the 2nd argument as the 					 * 1st one. 					 */
name|nd6_output
argument_list|(
name|ifp
argument_list|,
name|ifp
argument_list|,
name|mpkt
argument_list|,
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
name|ln
operator|->
name|ln_hold
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_INCOMPLETE
condition|)
block|{
comment|/* probe right away */
name|nd6_llinfo_settimer
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * ICMP6 type dependent behavior. 	 * 	 * NS: clear IsRouter if new entry 	 * RS: clear IsRouter 	 * RA: set IsRouter if there's lladdr 	 * redir: clear IsRouter if new entry 	 * 	 * RA case, (1): 	 * The spec says that we must set IsRouter in the following cases: 	 * - If lladdr exist, set IsRouter.  This means (1-5). 	 * - If it is old entry (!newentry), set IsRouter.  This means (7). 	 * So, based on the spec, in (1-5) and (7) cases we must set IsRouter. 	 * A quetion arises for (1) case.  (1) case has no lladdr in the 	 * neighbor cache, this is similar to (6). 	 * This case is rare but we figured that we MUST NOT set IsRouter. 	 * 	 * newentry olladdr  lladdr  llchange	    NS  RS  RA	redir 	 *							D R 	 *	0	n	n	--	(1)	c   ?     s 	 *	0	y	n	--	(2)	c   s     s 	 *	0	n	y	--	(3)	c   s     s 	 *	0	y	y	n	(4)	c   s     s 	 *	0	y	y	y	(5)	c   s     s 	 *	1	--	n	--	(6) c	c 	c s 	 *	1	--	y	--	(7) c	c   s	c s 	 * 	 *					(c=clear s=set) 	 */
switch|switch
condition|(
name|type
operator|&
literal|0xff
condition|)
block|{
case|case
name|ND_NEIGHBOR_SOLICIT
case|:
comment|/* 		 * New entry must have is_router flag cleared. 		 */
if|if
condition|(
name|is_newentry
condition|)
comment|/* (6-7) */
name|ln
operator|->
name|ln_router
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ND_REDIRECT
case|:
comment|/* 		 * If the icmp is a redirect to a better router, always set the 		 * is_router flag.  Otherwise, if the entry is newly created, 		 * clear the flag.  [RFC 2461, sec 8.3] 		 */
if|if
condition|(
name|code
operator|==
name|ND_REDIRECT_ROUTER
condition|)
name|ln
operator|->
name|ln_router
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|is_newentry
condition|)
comment|/* (6-7) */
name|ln
operator|->
name|ln_router
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ND_ROUTER_SOLICIT
case|:
comment|/* 		 * is_router flag must always be cleared. 		 */
name|ln
operator|->
name|ln_router
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ND_ROUTER_ADVERT
case|:
comment|/* 		 * Mark an entry with lladdr as a router. 		 */
if|if
condition|(
operator|(
operator|!
name|is_newentry
operator|&&
operator|(
name|olladdr
operator|||
name|lladdr
operator|)
operator|)
operator|||
comment|/* (2-5) */
operator|(
name|is_newentry
operator|&&
name|lladdr
operator|)
condition|)
block|{
comment|/* (7) */
name|ln
operator|->
name|ln_router
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
comment|/* 	 * When the link-layer address of a router changes, select the 	 * best router again.  In particular, when the neighbor entry is newly 	 * created, it might affect the selection policy. 	 * Question: can we restrict the first condition to the "is_newentry" 	 * case? 	 * XXX: when we hear an RA from a new router with the link-layer 	 * address option, defrouter_select() is called twice, since 	 * defrtrlist_update called the function as well.  However, I believe 	 * we can compromise the overhead, since it only happens the first 	 * time. 	 * XXX: although defrouter_select() should not have a bad effect 	 * for those are not autoconfigured hosts, we explicitly avoid such 	 * cases for safety. 	 */
if|if
condition|(
name|do_update
operator|&&
name|ln
operator|->
name|ln_router
operator|&&
operator|!
name|ip6_forwarding
operator|&&
name|ip6_accept_rtadv
condition|)
name|defrouter_select
argument_list|()
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nd6_slowtimo
parameter_list|(
name|ignored_arg
parameter_list|)
name|void
modifier|*
name|ignored_arg
decl_stmt|;
block|{
name|struct
name|nd_ifinfo
modifier|*
name|nd6if
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nd6_slowtimo_ch
argument_list|,
name|ND6_SLOWTIMER_INTERVAL
operator|*
name|hz
argument_list|,
name|nd6_slowtimo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|IFNET_RLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ifnet
argument_list|)
init|;
name|ifp
condition|;
name|ifp
operator|=
name|TAILQ_NEXT
argument_list|(
name|ifp
argument_list|,
name|if_list
argument_list|)
control|)
block|{
name|nd6if
operator|=
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd6if
operator|->
name|basereachable
operator|&&
comment|/* already initialized */
operator|(
name|nd6if
operator|->
name|recalctm
operator|-=
name|ND6_SLOWTIMER_INTERVAL
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* 			 * Since reachable time rarely changes by router 			 * advertisements, we SHOULD insure that a new random 			 * value gets recomputed at least once every few hours. 			 * (RFC 2461, 6.3.4) 			 */
name|nd6if
operator|->
name|recalctm
operator|=
name|nd6_recalc_reachtm_interval
expr_stmt|;
name|nd6if
operator|->
name|reachable
operator|=
name|ND_COMPUTE_RTIME
argument_list|(
name|nd6if
operator|->
name|basereachable
argument_list|)
expr_stmt|;
block|}
block|}
name|IFNET_RUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|senderr
parameter_list|(
name|e
parameter_list|)
value|{ error = (e); goto bad;}
end_define

begin_function
name|int
name|nd6_output
parameter_list|(
name|ifp
parameter_list|,
name|origifp
parameter_list|,
name|m0
parameter_list|,
name|dst
parameter_list|,
name|rt0
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|origifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|dst
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt0
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|rt0
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|gw6
init|=
name|NULL
decl_stmt|;
name|struct
name|llinfo_nd6
modifier|*
name|ln
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|)
condition|)
goto|goto
name|sendpkt
goto|;
if|if
condition|(
name|nd6_need_cache
argument_list|(
name|ifp
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|sendpkt
goto|;
comment|/* 	 * next hop determination.  This routine is derived from ether_output. 	 */
comment|/* NB: the locking here is tortuous... */
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
name|RT_LOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|RT_UNLOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt0
operator|=
name|rt
operator|=
name|rtalloc1
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
argument_list|,
literal|1
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
name|RT_REMREF
argument_list|(
name|rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_ifp
operator|!=
name|ifp
condition|)
comment|/* 					 * XXX maybe we should update ifp too, 					 * but the original code didn't and I 					 * don't know what is correct here. 					 */
goto|goto
name|again
goto|;
block|}
else|else
name|senderr
argument_list|(
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
block|{
name|gw6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
expr_stmt|;
comment|/* 			 * We skip link-layer address resolution and NUD 			 * if the gateway is not a neighbor from ND point 			 * of view, regardless of the value of nd_ifinfo.flags. 			 * The second condition is a bit tricky; we skip 			 * if the gateway is our own address, which is 			 * sometimes used to install a route to a p2p link. 			 */
if|if
condition|(
operator|!
name|nd6_is_addr_neighbor
argument_list|(
name|gw6
argument_list|,
name|ifp
argument_list|)
operator|||
name|in6ifa_ifpwithaddr
argument_list|(
name|ifp
argument_list|,
operator|&
name|gw6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|RT_UNLOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
comment|/* 				 * We allow this kind of tricky route only 				 * when the outgoing interface is p2p. 				 * XXX: we may need a more generic rule here. 				 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|==
literal|0
condition|)
name|senderr
argument_list|(
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
goto|goto
name|sendpkt
goto|;
block|}
if|if
condition|(
name|rt
operator|->
name|rt_gwroute
operator|==
name|NULL
condition|)
goto|goto
name|lookup
goto|;
name|rt
operator|=
name|rt
operator|->
name|rt_gwroute
expr_stmt|;
name|RT_LOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
comment|/* NB: gwroute */
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|rtfree
argument_list|(
name|rt
argument_list|)
expr_stmt|;
comment|/* unlock gwroute */
name|rt
operator|=
name|rt0
expr_stmt|;
name|lookup
label|:
name|RT_UNLOCK
argument_list|(
name|rt0
argument_list|)
expr_stmt|;
name|rt
operator|=
name|rtalloc1
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|,
literal|1
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|rt0
condition|)
block|{
name|rt0
operator|->
name|rt_gwroute
operator|=
name|NULL
expr_stmt|;
name|RT_REMREF
argument_list|(
name|rt0
argument_list|)
expr_stmt|;
name|RT_UNLOCK
argument_list|(
name|rt0
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
block|}
name|RT_LOCK
argument_list|(
name|rt0
argument_list|)
expr_stmt|;
name|rt0
operator|->
name|rt_gwroute
operator|=
name|rt
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|RT_UNLOCK
argument_list|(
name|rt0
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
block|}
block|}
name|RT_UNLOCK
argument_list|(
name|rt0
argument_list|)
expr_stmt|;
block|}
name|RT_UNLOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Address resolution or Neighbor Unreachability Detection 	 * for the next hop. 	 * At this point, the destination of the packet must be a unicast 	 * or an anycast address(i.e. not a multicast). 	 */
comment|/* Look up the neighbor cache for the nexthop */
if|if
condition|(
name|rt
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LLINFO
operator|)
operator|!=
literal|0
condition|)
name|ln
operator|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
expr_stmt|;
else|else
block|{
comment|/* 		 * Since nd6_is_addr_neighbor() internally calls nd6_lookup(), 		 * the condition below is not very efficient.  But we believe 		 * it is tolerable, because this should be a rare case. 		 */
if|if
condition|(
name|nd6_is_addr_neighbor
argument_list|(
name|dst
argument_list|,
name|ifp
argument_list|)
operator|&&
operator|(
name|rt
operator|=
name|nd6_lookup
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
literal|1
argument_list|,
name|ifp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ln
operator|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|==
name|NULL
operator|||
name|rt
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_PERFORMNUD
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"nd6_output: can't allocate llinfo for %s "
literal|"(ln=%p, rt=%p)\n"
argument_list|,
name|ip6_sprintf
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|ln
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX: good error? */
block|}
goto|goto
name|sendpkt
goto|;
comment|/* send anyway */
block|}
comment|/* We don't have to do link-layer address resolution on a p2p link. */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|!=
literal|0
operator|&&
name|ln
operator|->
name|ln_state
operator|<
name|ND6_LLINFO_REACHABLE
condition|)
block|{
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_STALE
expr_stmt|;
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|nd6_gctimer
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The first time we send a packet to a neighbor whose entry is 	 * STALE, we have to change the state to DELAY and a sets a timer to 	 * expire in DELAY_FIRST_PROBE_TIME seconds to ensure do 	 * neighbor unreachability detection on expiration. 	 * (RFC 2461 7.3.3) 	 */
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_STALE
condition|)
block|{
name|ln
operator|->
name|ln_asked
operator|=
literal|0
expr_stmt|;
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_DELAY
expr_stmt|;
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|nd6_delay
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the neighbor cache entry has a state other than INCOMPLETE 	 * (i.e. its link-layer address is already resolved), just 	 * send the packet. 	 */
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|>
name|ND6_LLINFO_INCOMPLETE
condition|)
goto|goto
name|sendpkt
goto|;
comment|/* 	 * There is a neighbor cache entry, but no ethernet address 	 * response yet.  Append this latest packet to the end of the 	 * packet queue in the mbuf, unless the number of the packet 	 * does not exceed nd6_maxqueuelen.  When it exceeds nd6_maxqueuelen, 	 * the oldest packet in the queue will be removed. 	 */
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_NOSTATE
condition|)
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_INCOMPLETE
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_hold
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m_hold
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m_hold
operator|=
name|ln
operator|->
name|ln_hold
init|;
name|m_hold
condition|;
name|m_hold
operator|=
name|m_hold
operator|->
name|m_nextpkt
control|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|m_hold
operator|->
name|m_nextpkt
operator|==
name|NULL
condition|)
block|{
name|m_hold
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
name|i
operator|>=
name|nd6_maxqueuelen
condition|)
block|{
name|m_hold
operator|=
name|ln
operator|->
name|ln_hold
expr_stmt|;
name|ln
operator|->
name|ln_hold
operator|=
name|ln
operator|->
name|ln_hold
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|m_hold
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|ln
operator|->
name|ln_hold
operator|=
name|m
expr_stmt|;
block|}
comment|/* 	 * If there has been no NS for the neighbor after entering the 	 * INCOMPLETE state, send the first solicitation. 	 */
if|if
condition|(
operator|!
name|ND6_LLINFO_PERMANENT
argument_list|(
name|ln
argument_list|)
operator|&&
name|ln
operator|->
name|ln_asked
operator|==
literal|0
condition|)
block|{
name|ln
operator|->
name|ln_asked
operator|++
expr_stmt|;
name|nd6_llinfo_settimer
argument_list|(
name|ln
argument_list|,
operator|(
name|long
operator|)
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|retrans
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|nd6_ns_output
argument_list|(
name|ifp
argument_list|,
name|NULL
argument_list|,
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|sendpkt
label|:
comment|/* discard the packet if IPv6 operation is disabled on the interface */
if|if
condition|(
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
condition|)
block|{
name|error
operator|=
name|ENETDOWN
expr_stmt|;
comment|/* better error? */
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|IPSEC
comment|/* clean ipsec history once it goes out of the node */
name|ipsec_delaux
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAC
name|mac_create_mbuf_linklayer
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|origifp
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
argument_list|,
name|rt
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
argument_list|,
name|rt
argument_list|)
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|senderr
end_undef

begin_function
name|int
name|nd6_need_cache
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
comment|/* 	 * XXX: we currently do not make neighbor cache on any interface 	 * other than ARCnet, Ethernet, FDDI and GIF. 	 * 	 * RFC2893 says: 	 * - unidirectional tunnels needs no ND 	 */
switch|switch
condition|(
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ARCNET
case|:
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_FDDI
case|:
case|case
name|IFT_IEEE1394
case|:
ifdef|#
directive|ifdef
name|IFT_L2VLAN
case|case
name|IFT_L2VLAN
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IFT_IEEE80211
case|case
name|IFT_IEEE80211
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IFT_CARP
case|case
name|IFT_CARP
case|:
endif|#
directive|endif
case|case
name|IFT_GIF
case|:
comment|/* XXX need more cases? */
case|case
name|IFT_PPP
case|:
case|case
name|IFT_TUNNEL
case|:
case|case
name|IFT_BRIDGE
case|:
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|nd6_storelladdr
parameter_list|(
name|ifp
parameter_list|,
name|rt0
parameter_list|,
name|m
parameter_list|,
name|dst
parameter_list|,
name|desten
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|u_char
modifier|*
name|desten
decl_stmt|;
block|{
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_FDDI
case|:
ifdef|#
directive|ifdef
name|IFT_L2VLAN
case|case
name|IFT_L2VLAN
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IFT_IEEE80211
case|case
name|IFT_IEEE80211
case|:
endif|#
directive|endif
case|case
name|IFT_BRIDGE
case|:
case|case
name|IFT_ISO88025
case|:
name|ETHER_MAP_IPV6_MULTICAST
argument_list|(
operator|&
name|SIN6
argument_list|(
name|dst
argument_list|)
operator|->
name|sin6_addr
argument_list|,
name|desten
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|IFT_IEEE1394
case|:
comment|/* 			 * netbsd can use if_broadcastaddr, but we don't do so 			 * to reduce # of ifdef. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ifp
operator|->
name|if_addrlen
condition|;
name|i
operator|++
control|)
name|desten
index|[
name|i
index|]
operator|=
operator|~
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|IFT_ARCNET
case|:
operator|*
name|desten
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
block|}
if|if
condition|(
name|rt0
operator|==
name|NULL
condition|)
block|{
comment|/* this could happen, if we could not allocate memory */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|rt_check
argument_list|(
operator|&
name|rt
argument_list|,
operator|&
name|rt0
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|RT_UNLOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_gateway
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
block|{
name|printf
argument_list|(
literal|"nd6_storelladdr: something odd happens\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sdl
operator|=
name|SDL
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdl
operator|->
name|sdl_alen
operator|==
literal|0
condition|)
block|{
comment|/* this should be impossible, but we bark here for debugging */
name|printf
argument_list|(
literal|"nd6_storelladdr: sdl_alen == 0\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|desten
argument_list|,
name|sdl
operator|->
name|sdl_alen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_llinfo_pqueue
parameter_list|(
name|ln
parameter_list|)
name|struct
name|llinfo_nd6
modifier|*
name|ln
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m_hold
decl_stmt|,
modifier|*
name|m_hold_next
decl_stmt|;
for|for
control|(
name|m_hold
operator|=
name|ln
operator|->
name|ln_hold
init|;
name|m_hold
condition|;
name|m_hold
operator|=
name|m_hold_next
control|)
block|{
name|m_hold_next
operator|=
name|m_hold
operator|->
name|m_nextpkt
expr_stmt|;
name|m_hold
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m_hold
argument_list|)
expr_stmt|;
block|}
name|ln
operator|->
name|ln_hold
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|nd6_sysctl_drlist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nd6_sysctl_prlist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SYSCTL_DECL
end_ifdef

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet6_icmp6
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet6_icmp6
argument_list|,
name|ICMPV6CTL_ND6_DRLIST
argument_list|,
name|nd6_drlist
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|nd6_sysctl_drlist
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet6_icmp6
argument_list|,
name|ICMPV6CTL_ND6_PRLIST
argument_list|,
name|nd6_prlist
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|nd6_sysctl_prlist
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet6_icmp6
argument_list|,
name|ICMPV6CTL_ND6_MAXQLEN
argument_list|,
name|nd6_maxqueuelen
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nd6_maxqueuelen
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|nd6_sysctl_drlist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|in6_defrouter
modifier|*
name|d
decl_stmt|,
modifier|*
name|de
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
condition|)
return|return
name|EPERM
return|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|nd_defrouter
argument_list|)
init|;
name|dr
condition|;
name|dr
operator|=
name|TAILQ_NEXT
argument_list|(
name|dr
argument_list|,
name|dr_entry
argument_list|)
control|)
block|{
name|d
operator|=
operator|(
expr|struct
name|in6_defrouter
operator|*
operator|)
name|buf
expr_stmt|;
name|de
operator|=
operator|(
expr|struct
name|in6_defrouter
operator|*
operator|)
operator|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|d
operator|+
literal|1
operator|<=
name|de
condition|)
block|{
name|bzero
argument_list|(
name|d
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|rtaddr
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|d
operator|->
name|rtaddr
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|d
operator|->
name|rtaddr
argument_list|)
expr_stmt|;
name|d
operator|->
name|rtaddr
operator|.
name|sin6_addr
operator|=
name|dr
operator|->
name|rtaddr
expr_stmt|;
name|sa6_recoverscope
argument_list|(
operator|&
name|d
operator|->
name|rtaddr
argument_list|)
expr_stmt|;
name|d
operator|->
name|flags
operator|=
name|dr
operator|->
name|flags
expr_stmt|;
name|d
operator|->
name|rtlifetime
operator|=
name|dr
operator|->
name|rtlifetime
expr_stmt|;
name|d
operator|->
name|expire
operator|=
name|dr
operator|->
name|expire
expr_stmt|;
name|d
operator|->
name|if_index
operator|=
name|dr
operator|->
name|ifp
operator|->
name|if_index
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"buffer too short"
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nd6_sysctl_prlist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|in6_prefix
modifier|*
name|p
decl_stmt|,
modifier|*
name|pe
decl_stmt|;
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
condition|)
return|return
name|EPERM
return|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|nd_prefix
operator|.
name|lh_first
init|;
name|pr
condition|;
name|pr
operator|=
name|pr
operator|->
name|ndpr_next
control|)
block|{
name|u_short
name|advrtrs
decl_stmt|;
name|size_t
name|advance
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|,
modifier|*
name|s6
decl_stmt|;
name|struct
name|nd_pfxrouter
modifier|*
name|pfr
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|in6_prefix
operator|*
operator|)
name|buf
expr_stmt|;
name|pe
operator|=
operator|(
expr|struct
name|in6_prefix
operator|*
operator|)
operator|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|1
operator|<=
name|pe
condition|)
block|{
name|bzero
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|p
operator|->
name|prefix
operator|=
name|pr
operator|->
name|ndpr_prefix
expr_stmt|;
if|if
condition|(
name|sa6_recoverscope
argument_list|(
operator|&
name|p
operator|->
name|prefix
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"scope error in prefix list (%s)\n"
argument_list|,
name|ip6_sprintf
argument_list|(
operator|&
name|p
operator|->
name|prefix
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: press on... */
block|}
name|p
operator|->
name|raflags
operator|=
name|pr
operator|->
name|ndpr_raf
expr_stmt|;
name|p
operator|->
name|prefixlen
operator|=
name|pr
operator|->
name|ndpr_plen
expr_stmt|;
name|p
operator|->
name|vltime
operator|=
name|pr
operator|->
name|ndpr_vltime
expr_stmt|;
name|p
operator|->
name|pltime
operator|=
name|pr
operator|->
name|ndpr_pltime
expr_stmt|;
name|p
operator|->
name|if_index
operator|=
name|pr
operator|->
name|ndpr_ifp
operator|->
name|if_index
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|ndpr_vltime
operator|==
name|ND6_INFINITE_LIFETIME
condition|)
name|p
operator|->
name|expire
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|time_t
name|maxexpire
decl_stmt|;
comment|/* XXX: we assume time_t is signed. */
name|maxexpire
operator|=
operator|(
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|time_t
operator|)
literal|1
operator|<<
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|maxexpire
argument_list|)
operator|*
literal|8
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|ndpr_vltime
operator|<
name|maxexpire
operator|-
name|pr
operator|->
name|ndpr_lastupdate
condition|)
block|{
name|p
operator|->
name|expire
operator|=
name|pr
operator|->
name|ndpr_lastupdate
operator|+
name|pr
operator|->
name|ndpr_vltime
expr_stmt|;
block|}
else|else
name|p
operator|->
name|expire
operator|=
name|maxexpire
expr_stmt|;
block|}
name|p
operator|->
name|refcnt
operator|=
name|pr
operator|->
name|ndpr_refcnt
expr_stmt|;
name|p
operator|->
name|flags
operator|=
name|pr
operator|->
name|ndpr_stateflags
expr_stmt|;
name|p
operator|->
name|origin
operator|=
name|PR_ORIG_RA
expr_stmt|;
name|advrtrs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pfr
operator|=
name|pr
operator|->
name|ndpr_advrtrs
operator|.
name|lh_first
init|;
name|pfr
condition|;
name|pfr
operator|=
name|pfr
operator|->
name|pfr_next
control|)
block|{
if|if
condition|(
operator|(
name|void
operator|*
operator|)
operator|&
name|sin6
index|[
name|advrtrs
operator|+
literal|1
index|]
operator|>
operator|(
name|void
operator|*
operator|)
name|pe
condition|)
block|{
name|advrtrs
operator|++
expr_stmt|;
continue|continue;
block|}
name|s6
operator|=
operator|&
name|sin6
index|[
name|advrtrs
index|]
expr_stmt|;
name|bzero
argument_list|(
name|s6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s6
argument_list|)
argument_list|)
expr_stmt|;
name|s6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|s6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
name|s6
operator|->
name|sin6_addr
operator|=
name|pfr
operator|->
name|router
operator|->
name|rtaddr
expr_stmt|;
if|if
condition|(
name|sa6_recoverscope
argument_list|(
name|s6
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"scope error in "
literal|"prefix list (%s)\n"
argument_list|,
name|ip6_sprintf
argument_list|(
operator|&
name|pfr
operator|->
name|router
operator|->
name|rtaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|advrtrs
operator|++
expr_stmt|;
block|}
name|p
operator|->
name|advrtrs
operator|=
name|advrtrs
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"buffer too short"
argument_list|)
expr_stmt|;
name|advance
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
operator|*
name|advrtrs
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
name|advance
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

