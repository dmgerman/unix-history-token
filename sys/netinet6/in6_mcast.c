begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2009 Bruce Simpson.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * IPv6 multicast socket, group, and socket option processing module.  * Normative references: RFC 2292, RFC 3492, RFC 3542, RFC 3678, RFC 3810.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/mld6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/scope6_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|KTR_MLD
end_ifndef

begin_define
define|#
directive|define
name|KTR_MLD
value|KTR_INET6
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__SOCKUNION_DECLARED
end_ifndef

begin_union
union|union
name|sockunion
block|{
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|struct
name|sockaddr_dl
name|sdl
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|sockunion
name|sockunion_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|__SOCKUNION_DECLARED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __SOCKUNION_DECLARED */
end_comment

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IN6MFILTER
argument_list|,
literal|"in6_mfilter"
argument_list|,
literal|"IPv6 multicast PCB-layer source filter"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IP6MADDR
argument_list|,
literal|"in6_multi"
argument_list|,
literal|"IPv6 multicast group"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IP6MOPTS
argument_list|,
literal|"ip6_moptions"
argument_list|,
literal|"IPv6 multicast options"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IP6MSOURCE
argument_list|,
literal|"ip6_msource"
argument_list|,
literal|"IPv6 multicast MLD-layer source filter"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RB_GENERATE
argument_list|(
name|ip6_msource_tree
argument_list|,
name|ip6_msource
argument_list|,
name|im6s_link
argument_list|,
name|ip6_msource_cmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Locking:  * - Lock order is: Giant, INP_WLOCK, IN6_MULTI_LOCK, MLD_LOCK, IF_ADDR_LOCK.  * - The IF_ADDR_LOCK is implicitly taken by in6m_lookup() earlier, however  *   it can be taken by code in net/if.c also.  * - ip6_moptions and in6_mfilter are covered by the INP_WLOCK.  *  * struct in6_multi is covered by IN6_MULTI_LOCK. There isn't strictly  * any need for in6_multi itself to be virtualized -- it is bound to an ifp  * anyway no matter what happens.  */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|in6_multi_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|in6_multi_mtx
argument_list|,
operator|&
name|in6_multi_mtx
argument_list|,
literal|"in6_multi_mtx"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|im6f_commit
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|im6f_get_source
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
name|imf
parameter_list|,
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|psin
parameter_list|,
name|struct
name|in6_msource
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|in6_msource
modifier|*
name|im6f_graft
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
parameter_list|,
specifier|const
name|uint8_t
parameter_list|,
specifier|const
name|struct
name|sockaddr_in6
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|im6f_leave
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|im6f_prune
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
parameter_list|,
specifier|const
name|struct
name|sockaddr_in6
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|im6f_purge
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|im6f_rollback
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|im6f_reap
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|im6o_grow
parameter_list|(
name|struct
name|ip6_moptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|im6o_match_group
parameter_list|(
specifier|const
name|struct
name|ip6_moptions
modifier|*
parameter_list|,
specifier|const
name|struct
name|ifnet
modifier|*
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|in6_msource
modifier|*
name|im6o_match_source
parameter_list|(
specifier|const
name|struct
name|ip6_moptions
modifier|*
parameter_list|,
specifier|const
name|size_t
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|im6s_merge
parameter_list|(
name|struct
name|ip6_msource
modifier|*
name|ims
parameter_list|,
specifier|const
name|struct
name|in6_msource
modifier|*
name|lims
parameter_list|,
specifier|const
name|int
name|rollback
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|in6_mc_get
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
parameter_list|,
name|struct
name|in6_multi
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|in6m_get_source
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
name|addr
parameter_list|,
specifier|const
name|int
name|noalloc
parameter_list|,
name|struct
name|ip6_msource
modifier|*
modifier|*
name|pims
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_function_decl
specifier|static
name|int
name|in6m_is_ifp_detached
parameter_list|(
specifier|const
name|struct
name|in6_multi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|in6m_merge
parameter_list|(
name|struct
name|in6_multi
modifier|*
parameter_list|,
comment|/*const*/
name|struct
name|in6_mfilter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|in6m_purge
parameter_list|(
name|struct
name|in6_multi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|in6m_reap
parameter_list|(
name|struct
name|in6_multi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ip6_moptions
modifier|*
name|in6p_findmoptions
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|in6p_get_source_filters
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|in6p_join_group
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|in6p_leave_group
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ifnet
modifier|*
name|in6p_lookup_mcast_ifp
parameter_list|(
specifier|const
name|struct
name|inpcb
modifier|*
parameter_list|,
specifier|const
name|struct
name|sockaddr_in6
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|in6p_block_unblock_source
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|in6p_set_multicast_if
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|in6p_set_source_filters
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_ip6_mcast_filters
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet6_ip6
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX Not in any common header. */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_inet6_ip6
argument_list|,
name|OID_AUTO
argument_list|,
name|mcast
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"IPv6 multicast"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|in6_mcast_maxgrpsrc
init|=
name|IPV6_MAX_GROUP_SRC_FILTER
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_inet6_ip6_mcast
argument_list|,
name|OID_AUTO
argument_list|,
name|maxgrpsrc
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|in6_mcast_maxgrpsrc
argument_list|,
literal|0
argument_list|,
literal|"Max source filters per group"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_ULONG
argument_list|(
literal|"net.inet6.ip6.mcast.maxgrpsrc"
argument_list|,
operator|&
name|in6_mcast_maxgrpsrc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|in6_mcast_maxsocksrc
init|=
name|IPV6_MAX_SOCK_SRC_FILTER
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_inet6_ip6_mcast
argument_list|,
name|OID_AUTO
argument_list|,
name|maxsocksrc
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|in6_mcast_maxsocksrc
argument_list|,
literal|0
argument_list|,
literal|"Max source filters per socket"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_ULONG
argument_list|(
literal|"net.inet6.ip6.mcast.maxsocksrc"
argument_list|,
operator|&
name|in6_mcast_maxsocksrc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* TODO Virtualize this switch. */
end_comment

begin_decl_stmt
name|int
name|in6_mcast_loop
init|=
name|IPV6_DEFAULT_MULTICAST_LOOP
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet6_ip6_mcast
argument_list|,
name|OID_AUTO
argument_list|,
name|loop
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|in6_mcast_loop
argument_list|,
literal|0
argument_list|,
literal|"Loopback multicast datagrams by default"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"net.inet6.ip6.mcast.loop"
argument_list|,
operator|&
name|in6_mcast_loop
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_inet6_ip6_mcast
argument_list|,
name|OID_AUTO
argument_list|,
name|filters
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sysctl_ip6_mcast_filters
argument_list|,
literal|"Per-interface stack-wide source filters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_comment
comment|/*  * Inline function which wraps assertions for a valid ifp.  * The ifnet layer will set the ifma's ifp pointer to NULL if the ifp  * is detached.  */
end_comment

begin_function
specifier|static
name|int
name|__inline
name|in6m_is_ifp_detached
parameter_list|(
specifier|const
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|KASSERT
argument_list|(
name|inm
operator|->
name|in6m_ifma
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no ifma"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|inm
operator|->
name|in6m_ifma
operator|->
name|ifma_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Sanity check that network-layer notion of ifp is the 		 * same as that of link-layer. 		 */
name|KASSERT
argument_list|(
name|inm
operator|->
name|in6m_ifp
operator|==
name|ifp
argument_list|,
operator|(
literal|"%s: bad ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ifp
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Initialize an in6_mfilter structure to a known state at t0, t1  * with an empty source filter list.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|im6f_init
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
name|imf
parameter_list|,
specifier|const
name|int
name|st0
parameter_list|,
specifier|const
name|int
name|st1
parameter_list|)
block|{
name|memset
argument_list|(
name|imf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_mfilter
argument_list|)
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|imf
operator|->
name|im6f_sources
argument_list|)
expr_stmt|;
name|imf
operator|->
name|im6f_st
index|[
literal|0
index|]
operator|=
name|st0
expr_stmt|;
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
operator|=
name|st1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Resize the ip6_moptions vector to the next power-of-two minus 1.  * May be called with locks held; do not sleep.  */
end_comment

begin_function
specifier|static
name|int
name|im6o_grow
parameter_list|(
name|struct
name|ip6_moptions
modifier|*
name|imo
parameter_list|)
block|{
name|struct
name|in6_multi
modifier|*
modifier|*
name|nmships
decl_stmt|;
name|struct
name|in6_multi
modifier|*
modifier|*
name|omships
decl_stmt|;
name|struct
name|in6_mfilter
modifier|*
name|nmfilters
decl_stmt|;
name|struct
name|in6_mfilter
modifier|*
name|omfilters
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|size_t
name|newmax
decl_stmt|;
name|size_t
name|oldmax
decl_stmt|;
name|nmships
operator|=
name|NULL
expr_stmt|;
name|nmfilters
operator|=
name|NULL
expr_stmt|;
name|omships
operator|=
name|imo
operator|->
name|im6o_membership
expr_stmt|;
name|omfilters
operator|=
name|imo
operator|->
name|im6o_mfilters
expr_stmt|;
name|oldmax
operator|=
name|imo
operator|->
name|im6o_max_memberships
expr_stmt|;
name|newmax
operator|=
operator|(
operator|(
name|oldmax
operator|+
literal|1
operator|)
operator|*
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|newmax
operator|<=
name|IPV6_MAX_MEMBERSHIPS
condition|)
block|{
name|nmships
operator|=
operator|(
expr|struct
name|in6_multi
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|omships
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_multi
operator|*
argument_list|)
operator|*
name|newmax
argument_list|,
name|M_IP6MOPTS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|nmfilters
operator|=
operator|(
expr|struct
name|in6_mfilter
operator|*
operator|)
name|realloc
argument_list|(
name|omfilters
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_mfilter
argument_list|)
operator|*
name|newmax
argument_list|,
name|M_IN6MFILTER
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmships
operator|!=
name|NULL
operator|&&
name|nmfilters
operator|!=
name|NULL
condition|)
block|{
comment|/* Initialize newly allocated source filter heads. */
for|for
control|(
name|idx
operator|=
name|oldmax
init|;
name|idx
operator|<
name|newmax
condition|;
name|idx
operator|++
control|)
block|{
name|im6f_init
argument_list|(
operator|&
name|nmfilters
index|[
name|idx
index|]
argument_list|,
name|MCAST_UNDEFINED
argument_list|,
name|MCAST_EXCLUDE
argument_list|)
expr_stmt|;
block|}
name|imo
operator|->
name|im6o_max_memberships
operator|=
name|newmax
expr_stmt|;
name|imo
operator|->
name|im6o_membership
operator|=
name|nmships
expr_stmt|;
name|imo
operator|->
name|im6o_mfilters
operator|=
name|nmfilters
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nmships
operator|==
name|NULL
operator|||
name|nmfilters
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nmships
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|nmships
argument_list|,
name|M_IP6MOPTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmfilters
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|nmfilters
argument_list|,
name|M_IN6MFILTER
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETOOMANYREFS
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find an IPv6 multicast group entry for this ip6_moptions instance  * which matches the specified group, and optionally an interface.  * Return its index into the array, or -1 if not found.  */
end_comment

begin_function
specifier|static
name|size_t
name|im6o_match_group
parameter_list|(
specifier|const
name|struct
name|ip6_moptions
modifier|*
name|imo
parameter_list|,
specifier|const
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|group
parameter_list|)
block|{
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|gsin6
decl_stmt|;
name|struct
name|in6_multi
modifier|*
modifier|*
name|pinm
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|nmships
decl_stmt|;
name|gsin6
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|group
expr_stmt|;
comment|/* The im6o_membership array may be lazy allocated. */
if|if
condition|(
name|imo
operator|->
name|im6o_membership
operator|==
name|NULL
operator|||
name|imo
operator|->
name|im6o_num_memberships
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|nmships
operator|=
name|imo
operator|->
name|im6o_num_memberships
expr_stmt|;
name|pinm
operator|=
operator|&
name|imo
operator|->
name|im6o_membership
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nmships
condition|;
name|idx
operator|++
operator|,
name|pinm
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|pinm
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifp
operator|==
name|NULL
operator|||
operator|(
operator|(
operator|*
name|pinm
operator|)
operator|->
name|in6m_ifp
operator|==
name|ifp
operator|)
operator|)
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
operator|(
operator|*
name|pinm
operator|)
operator|->
name|in6m_addr
argument_list|,
operator|&
name|gsin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|idx
operator|>=
name|nmships
condition|)
name|idx
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find an IPv6 multicast source entry for this imo which matches  * the given group index for this socket, and source address.  *  * XXX TODO: The scope ID, if present in src, is stripped before  * any comparison. We SHOULD enforce scope/zone checks where the source  * filter entry has a link scope.  *  * NOTE: This does not check if the entry is in-mode, merely if  * it exists, which may not be the desired behaviour.  */
end_comment

begin_function
specifier|static
name|struct
name|in6_msource
modifier|*
name|im6o_match_source
parameter_list|(
specifier|const
name|struct
name|ip6_moptions
modifier|*
name|imo
parameter_list|,
specifier|const
name|size_t
name|gidx
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|ip6_msource
name|find
decl_stmt|;
name|struct
name|in6_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|;
specifier|const
name|sockunion_t
modifier|*
name|psa
decl_stmt|;
name|KASSERT
argument_list|(
name|src
operator|->
name|sa_family
operator|==
name|AF_INET6
argument_list|,
operator|(
literal|"%s: !AF_INET6"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|gidx
operator|!=
operator|-
literal|1
operator|&&
name|gidx
operator|<
name|imo
operator|->
name|im6o_num_memberships
argument_list|,
operator|(
literal|"%s: invalid index %d\n"
operator|,
name|__func__
operator|,
operator|(
name|int
operator|)
name|gidx
operator|)
argument_list|)
expr_stmt|;
comment|/* The im6o_mfilters array may be lazy allocated. */
if|if
condition|(
name|imo
operator|->
name|im6o_mfilters
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|im6o_mfilters
index|[
name|gidx
index|]
expr_stmt|;
name|psa
operator|=
operator|(
specifier|const
name|sockunion_t
operator|*
operator|)
name|src
expr_stmt|;
name|find
operator|.
name|im6s_addr
operator|=
name|psa
operator|->
name|sin6
operator|.
name|sin6_addr
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|find
operator|.
name|im6s_addr
argument_list|)
expr_stmt|;
comment|/* XXX */
name|ims
operator|=
name|RB_FIND
argument_list|(
name|ip6_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|im6f_sources
argument_list|,
operator|&
name|find
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|in6_msource
operator|*
operator|)
name|ims
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform filtering for multicast datagrams on a socket by group and source.  *  * Returns 0 if a datagram should be allowed through, or various error codes  * if the socket was not a member of the group, or the source was muted, etc.  */
end_comment

begin_function
name|int
name|im6o_mc_filter
parameter_list|(
specifier|const
name|struct
name|ip6_moptions
modifier|*
name|imo
parameter_list|,
specifier|const
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|group
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|)
block|{
name|size_t
name|gidx
decl_stmt|;
name|struct
name|in6_msource
modifier|*
name|ims
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|KASSERT
argument_list|(
name|ifp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: null ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|gidx
operator|=
name|im6o_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|gidx
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|MCAST_NOTGMEMBER
operator|)
return|;
comment|/* 	 * Check if the source was included in an (S,G) join. 	 * Allow reception on exclusive memberships by default, 	 * reject reception on inclusive memberships by default. 	 * Exclude source only if an in-mode exclude filter exists. 	 * Include source only if an in-mode include filter exists. 	 * NOTE: We are comparing group state here at MLD t1 (now) 	 * with socket-layer t0 (since last downcall). 	 */
name|mode
operator|=
name|imo
operator|->
name|im6o_mfilters
index|[
name|gidx
index|]
operator|.
name|im6f_st
index|[
literal|1
index|]
expr_stmt|;
name|ims
operator|=
name|im6o_match_source
argument_list|(
name|imo
argument_list|,
name|gidx
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ims
operator|==
name|NULL
operator|&&
name|mode
operator|==
name|MCAST_INCLUDE
operator|)
operator|||
operator|(
name|ims
operator|!=
name|NULL
operator|&&
name|ims
operator|->
name|im6sl_st
index|[
literal|0
index|]
operator|!=
name|mode
operator|)
condition|)
return|return
operator|(
name|MCAST_NOTSMEMBER
operator|)
return|;
return|return
operator|(
name|MCAST_PASS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find and return a reference to an in6_multi record for (ifp, group),  * and bump its reference count.  * If one does not exist, try to allocate it, and update link-layer multicast  * filters on ifp to listen for group.  * Assumes the IN6_MULTI lock is held across the call.  * Return 0 if successful, otherwise return an appropriate error code.  */
end_comment

begin_function
specifier|static
name|int
name|in6_mc_get
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
name|group
parameter_list|,
name|struct
name|in6_multi
modifier|*
modifier|*
name|pinm
parameter_list|)
block|{
name|struct
name|sockaddr_in6
name|gsin6
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|inm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * XXX: Accesses to ifma_protospec must be covered by IF_ADDR_LOCK; 	 * if_addmulti() takes this mutex itself, so we must drop and 	 * re-acquire around the call. 	 */
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IF_ADDR_WLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|inm
operator|=
name|in6m_lookup_locked
argument_list|(
name|ifp
argument_list|,
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we already joined this group, just bump the 		 * refcount and return it. 		 */
name|KASSERT
argument_list|(
name|inm
operator|->
name|in6m_refcount
operator|>=
literal|1
argument_list|,
operator|(
literal|"%s: bad refcount %d"
operator|,
name|__func__
operator|,
name|inm
operator|->
name|in6m_refcount
operator|)
argument_list|)
expr_stmt|;
operator|++
name|inm
operator|->
name|in6m_refcount
expr_stmt|;
operator|*
name|pinm
operator|=
name|inm
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|memset
argument_list|(
operator|&
name|gsin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gsin6
argument_list|)
argument_list|)
expr_stmt|;
name|gsin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|gsin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|gsin6
operator|.
name|sin6_addr
operator|=
operator|*
name|group
expr_stmt|;
comment|/* 	 * Check if a link-layer group is already associated 	 * with this network-layer group on the given ifnet. 	 */
name|IF_ADDR_WUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|error
operator|=
name|if_addmulti
argument_list|(
name|ifp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|gsin6
argument_list|,
operator|&
name|ifma
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|IF_ADDR_WLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * If something other than netinet6 is occupying the link-layer 	 * group, print a meaningful error message and back out of 	 * the allocation. 	 * Otherwise, bump the refcount on the existing network-layer 	 * group association and return it. 	 */
if|if
condition|(
name|ifma
operator|->
name|ifma_protospec
operator|!=
name|NULL
condition|)
block|{
name|inm
operator|=
operator|(
expr|struct
name|in6_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|KASSERT
argument_list|(
name|ifma
operator|->
name|ifma_addr
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no ifma_addr"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
argument_list|,
operator|(
literal|"%s: ifma not AF_INET6"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no ifma_protospec"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|in6m_ifma
operator|!=
name|ifma
operator|||
name|inm
operator|->
name|in6m_ifp
operator|!=
name|ifp
operator|||
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|,
name|group
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: ifma %p is inconsistent with %p (%p)"
argument_list|,
name|__func__
argument_list|,
name|ifma
argument_list|,
name|inm
argument_list|,
name|group
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|inm
operator|->
name|in6m_refcount
expr_stmt|;
operator|*
name|pinm
operator|=
name|inm
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|IF_ADDR_WLOCK_ASSERT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * A new in6_multi record is needed; allocate and initialize it. 	 * We DO NOT perform an MLD join as the in6_ layer may need to 	 * push an initial source list down to MLD to support SSM. 	 * 	 * The initial source filter state is INCLUDE, {} as per the RFC. 	 * Pending state-changes per group are subject to a bounds check. 	 */
name|inm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|inm
argument_list|)
argument_list|,
name|M_IP6MADDR
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|==
name|NULL
condition|)
block|{
name|if_delmulti_ifma
argument_list|(
name|ifma
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|inm
operator|->
name|in6m_addr
operator|=
operator|*
name|group
expr_stmt|;
name|inm
operator|->
name|in6m_ifp
operator|=
name|ifp
expr_stmt|;
name|inm
operator|->
name|in6m_mli
operator|=
name|MLD_IFINFO
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_ifma
operator|=
name|ifma
expr_stmt|;
name|inm
operator|->
name|in6m_refcount
operator|=
literal|1
expr_stmt|;
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_NOT_MEMBER
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|inm
operator|->
name|in6m_scq
argument_list|,
name|MLD_MAX_STATE_CHANGES
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_st
index|[
literal|0
index|]
operator|.
name|iss_fmode
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|inm
operator|->
name|in6m_srcs
argument_list|)
expr_stmt|;
name|ifma
operator|->
name|ifma_protospec
operator|=
name|inm
expr_stmt|;
operator|*
name|pinm
operator|=
name|inm
expr_stmt|;
name|out_locked
label|:
name|IF_ADDR_WUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Drop a reference to an in6_multi record.  *  * If the refcount drops to 0, free the in6_multi record and  * delete the underlying link-layer membership.  */
end_comment

begin_function
name|void
name|in6m_release_locked
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: refcount is %d"
argument_list|,
name|__func__
argument_list|,
name|inm
operator|->
name|in6m_refcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|inm
operator|->
name|in6m_refcount
operator|>
literal|0
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: refcount is now %d"
argument_list|,
name|__func__
argument_list|,
name|inm
operator|->
name|in6m_refcount
argument_list|)
expr_stmt|;
return|return;
block|}
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: freeing inm %p"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|)
expr_stmt|;
name|ifma
operator|=
name|inm
operator|->
name|in6m_ifma
expr_stmt|;
comment|/* XXX this access is not covered by IF_ADDR_LOCK */
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: purging ifma %p"
argument_list|,
name|__func__
argument_list|,
name|ifma
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ifma
operator|->
name|ifma_protospec
operator|==
name|inm
argument_list|,
operator|(
literal|"%s: ifma_protospec != inm"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ifma
operator|->
name|ifma_protospec
operator|=
name|NULL
expr_stmt|;
name|in6m_purge
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inm
argument_list|,
name|M_IP6MADDR
argument_list|)
expr_stmt|;
name|if_delmulti_ifma
argument_list|(
name|ifma
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear recorded source entries for a group.  * Used by the MLD code. Caller must hold the IN6_MULTI lock.  * FIXME: Should reap.  */
end_comment

begin_function
name|void
name|in6m_clear_recorded
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|)
block|{
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|&inm->in6m_srcs
argument_list|)
block|{
if|if
condition|(
name|ims
operator|->
name|im6s_stp
condition|)
block|{
name|ims
operator|->
name|im6s_stp
operator|=
literal|0
expr_stmt|;
operator|--
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_rec
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_rec
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: iss_rec %d not 0"
operator|,
name|__func__
operator|,
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_rec
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Record a source as pending for a Source-Group MLDv2 query.  * This lives here as it modifies the shared tree.  *  * inm is the group descriptor.  * naddr is the address of the source to record in network-byte order.  *  * If the net.inet6.mld.sgalloc sysctl is non-zero, we will  * lazy-allocate a source node in response to an SG query.  * Otherwise, no allocation is performed. This saves some memory  * with the trade-off that the source will not be reported to the  * router if joined in the window between the query response and  * the group actually being joined on the local host.  *  * VIMAGE: XXX: Currently the mld_sgalloc feature has been removed.  * This turns off the allocation of a recorded source entry if  * the group has not been joined.  *  * Return 0 if the source didn't exist or was already marked as recorded.  * Return 1 if the source was marked as recorded by this function.  * Return<0 if any error occured (negated errno code).  */
end_comment

begin_function
name|int
name|in6m_record_source
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|ip6_msource
name|find
decl_stmt|;
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|nims
decl_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|find
operator|.
name|im6s_addr
operator|=
operator|*
name|addr
expr_stmt|;
name|ims
operator|=
name|RB_FIND
argument_list|(
name|ip6_msource_tree
argument_list|,
operator|&
name|inm
operator|->
name|in6m_srcs
argument_list|,
operator|&
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|ims
operator|&&
name|ims
operator|->
name|im6s_stp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ims
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|inm
operator|->
name|in6m_nsrc
operator|==
name|in6_mcast_maxgrpsrc
condition|)
return|return
operator|(
operator|-
name|ENOSPC
operator|)
return|;
name|nims
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_msource
argument_list|)
argument_list|,
name|M_IP6MSOURCE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nims
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|nims
operator|->
name|im6s_addr
operator|=
name|find
operator|.
name|im6s_addr
expr_stmt|;
name|RB_INSERT
argument_list|(
name|ip6_msource_tree
argument_list|,
operator|&
name|inm
operator|->
name|in6m_srcs
argument_list|,
name|nims
argument_list|)
expr_stmt|;
operator|++
name|inm
operator|->
name|in6m_nsrc
expr_stmt|;
name|ims
operator|=
name|nims
expr_stmt|;
block|}
comment|/* 	 * Mark the source as recorded and update the recorded 	 * source count. 	 */
operator|++
name|ims
operator|->
name|im6s_stp
expr_stmt|;
operator|++
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_rec
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a pointer to an in6_msource owned by an in6_mfilter,  * given its source address.  * Lazy-allocate if needed. If this is a new entry its filter state is  * undefined at t0.  *  * imf is the filter set being modified.  * addr is the source address.  *  * SMPng: May be called with locks held; malloc must not block.  */
end_comment

begin_function
specifier|static
name|int
name|im6f_get_source
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
name|imf
parameter_list|,
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|psin
parameter_list|,
name|struct
name|in6_msource
modifier|*
modifier|*
name|plims
parameter_list|)
block|{
name|struct
name|ip6_msource
name|find
decl_stmt|;
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|nims
decl_stmt|;
name|struct
name|in6_msource
modifier|*
name|lims
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ims
operator|=
name|NULL
expr_stmt|;
name|lims
operator|=
name|NULL
expr_stmt|;
name|find
operator|.
name|im6s_addr
operator|=
name|psin
operator|->
name|sin6_addr
expr_stmt|;
name|ims
operator|=
name|RB_FIND
argument_list|(
name|ip6_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|im6f_sources
argument_list|,
operator|&
name|find
argument_list|)
expr_stmt|;
name|lims
operator|=
operator|(
expr|struct
name|in6_msource
operator|*
operator|)
name|ims
expr_stmt|;
if|if
condition|(
name|lims
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|imf
operator|->
name|im6f_nsrc
operator|==
name|in6_mcast_maxsocksrc
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|nims
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_msource
argument_list|)
argument_list|,
name|M_IN6MFILTER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nims
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|lims
operator|=
operator|(
expr|struct
name|in6_msource
operator|*
operator|)
name|nims
expr_stmt|;
name|lims
operator|->
name|im6s_addr
operator|=
name|find
operator|.
name|im6s_addr
expr_stmt|;
name|lims
operator|->
name|im6sl_st
index|[
literal|0
index|]
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
name|RB_INSERT
argument_list|(
name|ip6_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|im6f_sources
argument_list|,
name|nims
argument_list|)
expr_stmt|;
operator|++
name|imf
operator|->
name|im6f_nsrc
expr_stmt|;
block|}
operator|*
name|plims
operator|=
name|lims
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Graft a source entry into an existing socket-layer filter set,  * maintaining any required invariants and checking allocations.  *  * The source is marked as being in the new filter mode at t1.  *  * Return the pointer to the new node, otherwise return NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|in6_msource
modifier|*
name|im6f_graft
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
name|imf
parameter_list|,
specifier|const
name|uint8_t
name|st1
parameter_list|,
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|psin
parameter_list|)
block|{
name|struct
name|ip6_msource
modifier|*
name|nims
decl_stmt|;
name|struct
name|in6_msource
modifier|*
name|lims
decl_stmt|;
name|nims
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_msource
argument_list|)
argument_list|,
name|M_IN6MFILTER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nims
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|lims
operator|=
operator|(
expr|struct
name|in6_msource
operator|*
operator|)
name|nims
expr_stmt|;
name|lims
operator|->
name|im6s_addr
operator|=
name|psin
operator|->
name|sin6_addr
expr_stmt|;
name|lims
operator|->
name|im6sl_st
index|[
literal|0
index|]
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
name|lims
operator|->
name|im6sl_st
index|[
literal|1
index|]
operator|=
name|st1
expr_stmt|;
name|RB_INSERT
argument_list|(
name|ip6_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|im6f_sources
argument_list|,
name|nims
argument_list|)
expr_stmt|;
operator|++
name|imf
operator|->
name|im6f_nsrc
expr_stmt|;
return|return
operator|(
name|lims
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prune a source entry from an existing socket-layer filter set,  * maintaining any required invariants and checking allocations.  *  * The source is marked as being left at t1, it is not freed.  *  * Return 0 if no error occurred, otherwise return an errno value.  */
end_comment

begin_function
specifier|static
name|int
name|im6f_prune
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
name|imf
parameter_list|,
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|psin
parameter_list|)
block|{
name|struct
name|ip6_msource
name|find
decl_stmt|;
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|;
name|struct
name|in6_msource
modifier|*
name|lims
decl_stmt|;
name|find
operator|.
name|im6s_addr
operator|=
name|psin
operator|->
name|sin6_addr
expr_stmt|;
name|ims
operator|=
name|RB_FIND
argument_list|(
name|ip6_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|im6f_sources
argument_list|,
operator|&
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|ims
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|lims
operator|=
operator|(
expr|struct
name|in6_msource
operator|*
operator|)
name|ims
expr_stmt|;
name|lims
operator|->
name|im6sl_st
index|[
literal|1
index|]
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Revert socket-layer filter set deltas at t1 to t0 state.  */
end_comment

begin_function
specifier|static
name|void
name|im6f_rollback
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|tims
decl_stmt|;
name|struct
name|in6_msource
modifier|*
name|lims
decl_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|&imf->im6f_sources
argument_list|,
argument|tims
argument_list|)
block|{
name|lims
operator|=
operator|(
expr|struct
name|in6_msource
operator|*
operator|)
name|ims
expr_stmt|;
if|if
condition|(
name|lims
operator|->
name|im6sl_st
index|[
literal|0
index|]
operator|==
name|lims
operator|->
name|im6sl_st
index|[
literal|1
index|]
condition|)
block|{
comment|/* no change at t1 */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|lims
operator|->
name|im6sl_st
index|[
literal|0
index|]
operator|!=
name|MCAST_UNDEFINED
condition|)
block|{
comment|/* revert change to existing source at t1 */
name|lims
operator|->
name|im6sl_st
index|[
literal|1
index|]
operator|=
name|lims
operator|->
name|im6sl_st
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* revert source added t1 */
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: free ims %p"
argument_list|,
name|__func__
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|ip6_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|im6f_sources
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ims
argument_list|,
name|M_IN6MFILTER
argument_list|)
expr_stmt|;
name|imf
operator|->
name|im6f_nsrc
operator|--
expr_stmt|;
block|}
block|}
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
operator|=
name|imf
operator|->
name|im6f_st
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark socket-layer filter set as INCLUDE {} at t1.  */
end_comment

begin_function
specifier|static
name|void
name|im6f_leave
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|;
name|struct
name|in6_msource
modifier|*
name|lims
decl_stmt|;
name|RB_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|&imf->im6f_sources
argument_list|)
block|{
name|lims
operator|=
operator|(
expr|struct
name|in6_msource
operator|*
operator|)
name|ims
expr_stmt|;
name|lims
operator|->
name|im6sl_st
index|[
literal|1
index|]
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
block|}
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
operator|=
name|MCAST_INCLUDE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark socket-layer filter set deltas as committed.  */
end_comment

begin_function
specifier|static
name|void
name|im6f_commit
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|;
name|struct
name|in6_msource
modifier|*
name|lims
decl_stmt|;
name|RB_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|&imf->im6f_sources
argument_list|)
block|{
name|lims
operator|=
operator|(
expr|struct
name|in6_msource
operator|*
operator|)
name|ims
expr_stmt|;
name|lims
operator|->
name|im6sl_st
index|[
literal|0
index|]
operator|=
name|lims
operator|->
name|im6sl_st
index|[
literal|1
index|]
expr_stmt|;
block|}
name|imf
operator|->
name|im6f_st
index|[
literal|0
index|]
operator|=
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reap unreferenced sources from socket-layer filter set.  */
end_comment

begin_function
specifier|static
name|void
name|im6f_reap
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|tims
decl_stmt|;
name|struct
name|in6_msource
modifier|*
name|lims
decl_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|&imf->im6f_sources
argument_list|,
argument|tims
argument_list|)
block|{
name|lims
operator|=
operator|(
expr|struct
name|in6_msource
operator|*
operator|)
name|ims
expr_stmt|;
if|if
condition|(
operator|(
name|lims
operator|->
name|im6sl_st
index|[
literal|0
index|]
operator|==
name|MCAST_UNDEFINED
operator|)
operator|&&
operator|(
name|lims
operator|->
name|im6sl_st
index|[
literal|1
index|]
operator|==
name|MCAST_UNDEFINED
operator|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: free lims %p"
argument_list|,
name|__func__
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|ip6_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|im6f_sources
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ims
argument_list|,
name|M_IN6MFILTER
argument_list|)
expr_stmt|;
name|imf
operator|->
name|im6f_nsrc
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Purge socket-layer filter set.  */
end_comment

begin_function
specifier|static
name|void
name|im6f_purge
parameter_list|(
name|struct
name|in6_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|tims
decl_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|&imf->im6f_sources
argument_list|,
argument|tims
argument_list|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: free ims %p"
argument_list|,
name|__func__
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|ip6_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|im6f_sources
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ims
argument_list|,
name|M_IN6MFILTER
argument_list|)
expr_stmt|;
name|imf
operator|->
name|im6f_nsrc
operator|--
expr_stmt|;
block|}
name|imf
operator|->
name|im6f_st
index|[
literal|0
index|]
operator|=
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
name|KASSERT
argument_list|(
name|RB_EMPTY
argument_list|(
operator|&
name|imf
operator|->
name|im6f_sources
argument_list|)
argument_list|,
operator|(
literal|"%s: im6f_sources not empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up a source filter entry for a multicast group.  *  * inm is the group descriptor to work with.  * addr is the IPv6 address to look up.  * noalloc may be non-zero to suppress allocation of sources.  * *pims will be set to the address of the retrieved or allocated source.  *  * SMPng: NOTE: may be called with locks held.  * Return 0 if successful, otherwise return a non-zero error code.  */
end_comment

begin_function
specifier|static
name|int
name|in6m_get_source
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
name|addr
parameter_list|,
specifier|const
name|int
name|noalloc
parameter_list|,
name|struct
name|ip6_msource
modifier|*
modifier|*
name|pims
parameter_list|)
block|{
name|struct
name|ip6_msource
name|find
decl_stmt|;
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|nims
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|find
operator|.
name|im6s_addr
operator|=
operator|*
name|addr
expr_stmt|;
name|ims
operator|=
name|RB_FIND
argument_list|(
name|ip6_msource_tree
argument_list|,
operator|&
name|inm
operator|->
name|in6m_srcs
argument_list|,
operator|&
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|ims
operator|==
name|NULL
operator|&&
operator|!
name|noalloc
condition|)
block|{
if|if
condition|(
name|inm
operator|->
name|in6m_nsrc
operator|==
name|in6_mcast_maxgrpsrc
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|nims
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_msource
argument_list|)
argument_list|,
name|M_IP6MSOURCE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nims
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|nims
operator|->
name|im6s_addr
operator|=
operator|*
name|addr
expr_stmt|;
name|RB_INSERT
argument_list|(
name|ip6_msource_tree
argument_list|,
operator|&
name|inm
operator|->
name|in6m_srcs
argument_list|,
name|nims
argument_list|)
expr_stmt|;
operator|++
name|inm
operator|->
name|in6m_nsrc
expr_stmt|;
name|ims
operator|=
name|nims
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: allocated %s as %p"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
name|addr
argument_list|)
argument_list|,
name|ims
argument_list|)
expr_stmt|;
block|}
operator|*
name|pims
operator|=
name|ims
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Merge socket-layer source into MLD-layer source.  * If rollback is non-zero, perform the inverse of the merge.  */
end_comment

begin_function
specifier|static
name|void
name|im6s_merge
parameter_list|(
name|struct
name|ip6_msource
modifier|*
name|ims
parameter_list|,
specifier|const
name|struct
name|in6_msource
modifier|*
name|lims
parameter_list|,
specifier|const
name|int
name|rollback
parameter_list|)
block|{
name|int
name|n
init|=
name|rollback
condition|?
operator|-
literal|1
else|:
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|lims
operator|->
name|im6s_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lims
operator|->
name|im6sl_st
index|[
literal|0
index|]
operator|==
name|MCAST_EXCLUDE
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: t1 ex -= %d on %s"
argument_list|,
name|__func__
argument_list|,
name|n
argument_list|,
name|ip6tbuf
argument_list|)
expr_stmt|;
name|ims
operator|->
name|im6s_st
index|[
literal|1
index|]
operator|.
name|ex
operator|-=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lims
operator|->
name|im6sl_st
index|[
literal|0
index|]
operator|==
name|MCAST_INCLUDE
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: t1 in -= %d on %s"
argument_list|,
name|__func__
argument_list|,
name|n
argument_list|,
name|ip6tbuf
argument_list|)
expr_stmt|;
name|ims
operator|->
name|im6s_st
index|[
literal|1
index|]
operator|.
name|in
operator|-=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|lims
operator|->
name|im6sl_st
index|[
literal|1
index|]
operator|==
name|MCAST_EXCLUDE
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: t1 ex += %d on %s"
argument_list|,
name|__func__
argument_list|,
name|n
argument_list|,
name|ip6tbuf
argument_list|)
expr_stmt|;
name|ims
operator|->
name|im6s_st
index|[
literal|1
index|]
operator|.
name|ex
operator|+=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lims
operator|->
name|im6sl_st
index|[
literal|1
index|]
operator|==
name|MCAST_INCLUDE
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: t1 in += %d on %s"
argument_list|,
name|__func__
argument_list|,
name|n
argument_list|,
name|ip6tbuf
argument_list|)
expr_stmt|;
name|ims
operator|->
name|im6s_st
index|[
literal|1
index|]
operator|.
name|in
operator|+=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Atomically update the global in6_multi state, when a membership's  * filter list is being updated in any way.  *  * imf is the per-inpcb-membership group filter pointer.  * A fake imf may be passed for in-kernel consumers.  *  * XXX This is a candidate for a set-symmetric-difference style loop  * which would eliminate the repeated lookup from root of ims nodes,  * as they share the same key space.  *  * If any error occurred this function will back out of refcounts  * and return a non-zero value.  */
end_comment

begin_function
specifier|static
name|int
name|in6m_merge
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|,
comment|/*const*/
name|struct
name|in6_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|nims
decl_stmt|;
name|struct
name|in6_msource
modifier|*
name|lims
decl_stmt|;
name|int
name|schanged
decl_stmt|,
name|error
decl_stmt|;
name|int
name|nsrc0
decl_stmt|,
name|nsrc1
decl_stmt|;
name|schanged
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|nsrc1
operator|=
name|nsrc0
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Update the source filters first, as this may fail. 	 * Maintain count of in-mode filters at t0, t1. These are 	 * used to work out if we transition into ASM mode or not. 	 * Maintain a count of source filters whose state was 	 * actually modified by this operation. 	 */
name|RB_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|&imf->im6f_sources
argument_list|)
block|{
name|lims
operator|=
operator|(
expr|struct
name|in6_msource
operator|*
operator|)
name|ims
expr_stmt|;
if|if
condition|(
name|lims
operator|->
name|im6sl_st
index|[
literal|0
index|]
operator|==
name|imf
operator|->
name|im6f_st
index|[
literal|0
index|]
condition|)
name|nsrc0
operator|++
expr_stmt|;
if|if
condition|(
name|lims
operator|->
name|im6sl_st
index|[
literal|1
index|]
operator|==
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
condition|)
name|nsrc1
operator|++
expr_stmt|;
if|if
condition|(
name|lims
operator|->
name|im6sl_st
index|[
literal|0
index|]
operator|==
name|lims
operator|->
name|im6sl_st
index|[
literal|1
index|]
condition|)
continue|continue;
name|error
operator|=
name|in6m_get_source
argument_list|(
name|inm
argument_list|,
operator|&
name|lims
operator|->
name|im6s_addr
argument_list|,
literal|0
argument_list|,
operator|&
name|nims
argument_list|)
expr_stmt|;
operator|++
name|schanged
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|im6s_merge
argument_list|(
name|nims
argument_list|,
name|lims
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|struct
name|ip6_msource
modifier|*
name|bims
decl_stmt|;
name|RB_FOREACH_REVERSE_FROM
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|nims
argument_list|)
block|{
name|lims
operator|=
operator|(
expr|struct
name|in6_msource
operator|*
operator|)
name|ims
expr_stmt|;
if|if
condition|(
name|lims
operator|->
name|im6sl_st
index|[
literal|0
index|]
operator|==
name|lims
operator|->
name|im6sl_st
index|[
literal|1
index|]
condition|)
continue|continue;
operator|(
name|void
operator|)
name|in6m_get_source
argument_list|(
name|inm
argument_list|,
operator|&
name|lims
operator|->
name|im6s_addr
argument_list|,
literal|1
argument_list|,
operator|&
name|bims
argument_list|)
expr_stmt|;
if|if
condition|(
name|bims
operator|==
name|NULL
condition|)
continue|continue;
name|im6s_merge
argument_list|(
name|bims
argument_list|,
name|lims
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out_reap
goto|;
block|}
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: imf filters in-mode: %d at t0, %d at t1"
argument_list|,
name|__func__
argument_list|,
name|nsrc0
argument_list|,
name|nsrc1
argument_list|)
expr_stmt|;
comment|/* Handle transition between INCLUDE {n} and INCLUDE {} on socket. */
if|if
condition|(
name|imf
operator|->
name|im6f_st
index|[
literal|0
index|]
operator|==
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
operator|&&
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
operator|==
name|MCAST_INCLUDE
condition|)
block|{
if|if
condition|(
name|nsrc1
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: --in on inm at t1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|--
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_in
expr_stmt|;
block|}
block|}
comment|/* Handle filter mode transition on socket. */
if|if
condition|(
name|imf
operator|->
name|im6f_st
index|[
literal|0
index|]
operator|!=
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: imf transition %d to %d"
argument_list|,
name|__func__
argument_list|,
name|imf
operator|->
name|im6f_st
index|[
literal|0
index|]
argument_list|,
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|imf
operator|->
name|im6f_st
index|[
literal|0
index|]
operator|==
name|MCAST_EXCLUDE
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: --ex on inm at t1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|--
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_ex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|imf
operator|->
name|im6f_st
index|[
literal|0
index|]
operator|==
name|MCAST_INCLUDE
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: --in on inm at t1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|--
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_in
expr_stmt|;
block|}
if|if
condition|(
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
operator|==
name|MCAST_EXCLUDE
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: ex++ on inm at t1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_ex
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
operator|==
name|MCAST_INCLUDE
operator|&&
name|nsrc1
operator|>
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: in++ on inm at t1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_in
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Track inm filter state in terms of listener counts. 	 * If there are any exclusive listeners, stack-wide 	 * membership is exclusive. 	 * Otherwise, if only inclusive listeners, stack-wide is inclusive. 	 * If no listeners remain, state is undefined at t1, 	 * and the MLD lifecycle for this group should finish. 	 */
if|if
condition|(
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_ex
operator|>
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: transition to EX"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
operator|=
name|MCAST_EXCLUDE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_in
operator|>
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: transition to IN"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
operator|=
name|MCAST_INCLUDE
expr_stmt|;
block|}
else|else
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: transition to UNDEF"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
block|}
comment|/* Decrement ASM listener count on transition out of ASM mode. */
if|if
condition|(
name|imf
operator|->
name|im6f_st
index|[
literal|0
index|]
operator|==
name|MCAST_EXCLUDE
operator|&&
name|nsrc0
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
operator|!=
name|MCAST_EXCLUDE
operator|)
operator|||
operator|(
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
operator|==
name|MCAST_EXCLUDE
operator|&&
name|nsrc1
operator|>
literal|0
operator|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: --asm on inm at t1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|--
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_asm
expr_stmt|;
block|}
block|}
comment|/* Increment ASM listener count on transition to ASM mode. */
if|if
condition|(
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
operator|==
name|MCAST_EXCLUDE
operator|&&
name|nsrc1
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: asm++ on inm at t1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_asm
operator|++
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: merged imf %p to inm %p"
argument_list|,
name|__func__
argument_list|,
name|imf
argument_list|,
name|inm
argument_list|)
expr_stmt|;
name|in6m_print
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|out_reap
label|:
if|if
condition|(
name|schanged
operator|>
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: sources changed; reaping"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|in6m_reap
argument_list|(
name|inm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark an in6_multi's filter set deltas as committed.  * Called by MLD after a state change has been enqueued.  */
end_comment

begin_function
name|void
name|in6m_commit
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|)
block|{
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: commit inm %p"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: pre commit:"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|in6m_print
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|&inm->in6m_srcs
argument_list|)
block|{
name|ims
operator|->
name|im6s_st
index|[
literal|0
index|]
operator|=
name|ims
operator|->
name|im6s_st
index|[
literal|1
index|]
expr_stmt|;
block|}
name|inm
operator|->
name|in6m_st
index|[
literal|0
index|]
operator|=
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reap unreferenced nodes from an in6_multi's filter set.  */
end_comment

begin_function
specifier|static
name|void
name|in6m_reap
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|)
block|{
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|tims
decl_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|&inm->in6m_srcs
argument_list|,
argument|tims
argument_list|)
block|{
if|if
condition|(
name|ims
operator|->
name|im6s_st
index|[
literal|0
index|]
operator|.
name|ex
operator|>
literal|0
operator|||
name|ims
operator|->
name|im6s_st
index|[
literal|0
index|]
operator|.
name|in
operator|>
literal|0
operator|||
name|ims
operator|->
name|im6s_st
index|[
literal|1
index|]
operator|.
name|ex
operator|>
literal|0
operator|||
name|ims
operator|->
name|im6s_st
index|[
literal|1
index|]
operator|.
name|in
operator|>
literal|0
operator|||
name|ims
operator|->
name|im6s_stp
operator|!=
literal|0
condition|)
continue|continue;
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: free ims %p"
argument_list|,
name|__func__
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|ip6_msource_tree
argument_list|,
operator|&
name|inm
operator|->
name|in6m_srcs
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ims
argument_list|,
name|M_IP6MSOURCE
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_nsrc
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Purge all source nodes from an in6_multi's filter set.  */
end_comment

begin_function
specifier|static
name|void
name|in6m_purge
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|)
block|{
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|tims
decl_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|&inm->in6m_srcs
argument_list|,
argument|tims
argument_list|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: free ims %p"
argument_list|,
name|__func__
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|ip6_msource_tree
argument_list|,
operator|&
name|inm
operator|->
name|in6m_srcs
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ims
argument_list|,
name|M_IP6MSOURCE
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_nsrc
operator|--
expr_stmt|;
block|}
comment|/* Free state-change requests that might be queued. */
name|_IF_DRAIN
argument_list|(
operator|&
name|inm
operator|->
name|in6m_scq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Join a multicast address w/o sources.  * KAME compatibility entry point.  *  * SMPng: Assume no mc locks held by caller.  */
end_comment

begin_function
name|struct
name|in6_multi_mship
modifier|*
name|in6_joingroup
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|mcaddr
parameter_list|,
name|int
modifier|*
name|errorp
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|struct
name|in6_multi_mship
modifier|*
name|imm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|imm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|imm
argument_list|)
argument_list|,
name|M_IP6MADDR
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|==
name|NULL
condition|)
block|{
operator|*
name|errorp
operator|=
name|ENOBUFS
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|delay
operator|=
operator|(
name|delay
operator|*
name|PR_FASTHZ
operator|)
operator|/
name|hz
expr_stmt|;
name|error
operator|=
name|in6_mc_join
argument_list|(
name|ifp
argument_list|,
name|mcaddr
argument_list|,
name|NULL
argument_list|,
operator|&
name|imm
operator|->
name|i6mm_maddr
argument_list|,
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|errorp
operator|=
name|error
expr_stmt|;
name|free
argument_list|(
name|imm
argument_list|,
name|M_IP6MADDR
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|imm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Leave a multicast address w/o sources.  * KAME compatibility entry point.  *  * SMPng: Assume no mc locks held by caller.  */
end_comment

begin_function
name|int
name|in6_leavegroup
parameter_list|(
name|struct
name|in6_multi_mship
modifier|*
name|imm
parameter_list|)
block|{
if|if
condition|(
name|imm
operator|->
name|i6mm_maddr
operator|!=
name|NULL
condition|)
name|in6_mc_leave
argument_list|(
name|imm
operator|->
name|i6mm_maddr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imm
argument_list|,
name|M_IP6MADDR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Join a multicast group; unlocked entry point.  *  * SMPng: XXX: in6_mc_join() is called from in6_control() when upper  * locks are not held. Fortunately, ifp is unlikely to have been detached  * at this point, so we assume it's OK to recurse.  */
end_comment

begin_function
name|int
name|in6_mc_join
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
name|mcaddr
parameter_list|,
comment|/*const*/
name|struct
name|in6_mfilter
modifier|*
name|imf
parameter_list|,
name|struct
name|in6_multi
modifier|*
modifier|*
name|pinm
parameter_list|,
specifier|const
name|int
name|delay
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|IN6_MULTI_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|in6_mc_join_locked
argument_list|(
name|ifp
argument_list|,
name|mcaddr
argument_list|,
name|imf
argument_list|,
name|pinm
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|IN6_MULTI_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Join a multicast group; real entry point.  *  * Only preserves atomicity at inm level.  * NOTE: imf argument cannot be const due to sys/tree.h limitations.  *  * If the MLD downcall fails, the group is not joined, and an error  * code is returned.  */
end_comment

begin_function
name|int
name|in6_mc_join_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
name|mcaddr
parameter_list|,
comment|/*const*/
name|struct
name|in6_mfilter
modifier|*
name|imf
parameter_list|,
name|struct
name|in6_multi
modifier|*
modifier|*
name|pinm
parameter_list|,
specifier|const
name|int
name|delay
parameter_list|)
block|{
name|struct
name|in6_mfilter
name|timf
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|inm
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INVARIANTS
comment|/* 	 * Sanity: Check scope zone ID was set for ifp, if and 	 * only if group is scoped to an interface. 	 */
name|KASSERT
argument_list|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
name|mcaddr
argument_list|)
argument_list|,
operator|(
literal|"%s: not a multicast address"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
name|mcaddr
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_INTFACELOCAL
argument_list|(
name|mcaddr
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|mcaddr
operator|->
name|s6_addr16
index|[
literal|1
index|]
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: scope zone ID not set"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: join %s on %p(%s))"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
name|mcaddr
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|inm
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If no imf was specified (i.e. kernel consumer), 	 * fake one up and assume it is an ASM join. 	 */
if|if
condition|(
name|imf
operator|==
name|NULL
condition|)
block|{
name|im6f_init
argument_list|(
operator|&
name|timf
argument_list|,
name|MCAST_UNDEFINED
argument_list|,
name|MCAST_EXCLUDE
argument_list|)
expr_stmt|;
name|imf
operator|=
operator|&
name|timf
expr_stmt|;
block|}
name|error
operator|=
name|in6_mc_get
argument_list|(
name|ifp
argument_list|,
name|mcaddr
argument_list|,
operator|&
name|inm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: in6_mc_get() failure"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|in6m_merge
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: failed to merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out_in6m_release
goto|;
block|}
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: doing mld downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|mld_change_state
argument_list|(
name|inm
argument_list|,
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: failed to update source"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out_in6m_release
goto|;
block|}
name|out_in6m_release
label|:
if|if
condition|(
name|error
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: dropping ref on %p"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|)
expr_stmt|;
name|in6m_release_locked
argument_list|(
name|inm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pinm
operator|=
name|inm
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Leave a multicast group; unlocked entry point.  */
end_comment

begin_function
name|int
name|in6_mc_leave
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|,
comment|/*const*/
name|struct
name|in6_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ifp
operator|=
name|inm
operator|->
name|in6m_ifp
expr_stmt|;
name|IN6_MULTI_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|in6_mc_leave_locked
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
name|IN6_MULTI_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Leave a multicast group; real entry point.  * All source filters will be expunged.  *  * Only preserves atomicity at inm level.  *  * Holding the write lock for the INP which contains imf  * is highly advisable. We can't assert for it as imf does not  * contain a back-pointer to the owning inp.  *  * Note: This is not the same as in6m_release(*) as this function also  * makes a state change downcall into MLD.  */
end_comment

begin_function
name|int
name|in6_mc_leave_locked
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|,
comment|/*const*/
name|struct
name|in6_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|struct
name|in6_mfilter
name|timf
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|error
operator|=
literal|0
expr_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: leave inm %p, %s/%s, imf %p"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
argument_list|,
operator|(
name|in6m_is_ifp_detached
argument_list|(
name|inm
argument_list|)
condition|?
literal|"null"
else|:
name|inm
operator|->
name|in6m_ifp
operator|->
name|if_xname
operator|)
argument_list|,
name|imf
argument_list|)
expr_stmt|;
comment|/* 	 * If no imf was specified (i.e. kernel consumer), 	 * fake one up and assume it is an ASM join. 	 */
if|if
condition|(
name|imf
operator|==
name|NULL
condition|)
block|{
name|im6f_init
argument_list|(
operator|&
name|timf
argument_list|,
name|MCAST_EXCLUDE
argument_list|,
name|MCAST_UNDEFINED
argument_list|)
expr_stmt|;
name|imf
operator|=
operator|&
name|timf
expr_stmt|;
block|}
comment|/* 	 * Begin state merge transaction at MLD layer. 	 * 	 * As this particular invocation should not cause any memory 	 * to be allocated, and there is no opportunity to roll back 	 * the transaction, it MUST NOT fail. 	 */
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|in6m_merge
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: failed to merge inm state"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: doing mld downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|mld_change_state
argument_list|(
name|inm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: failed mld downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: dropping ref on %p"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|)
expr_stmt|;
name|in6m_release_locked
argument_list|(
name|inm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Block or unblock an ASM multicast source on an inpcb.  * This implements the delta-based API described in RFC 3678.  *  * The delta-based API applies only to exclusive-mode memberships.  * An MLD downcall will be performed.  *  * SMPng: NOTE: Must take Giant as a join may create a new ifma.  *  * Return 0 if successful, otherwise return an appropriate error code.  */
end_comment

begin_function
specifier|static
name|int
name|in6p_block_unblock_source
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|group_source_req
name|gsr
decl_stmt|;
name|sockunion_t
modifier|*
name|gsa
decl_stmt|,
modifier|*
name|ssa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in6_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip6_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in6_msource
modifier|*
name|ims
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|inm
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|uint16_t
name|fmode
decl_stmt|;
name|int
name|error
decl_stmt|,
name|doblock
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|ifp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|doblock
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|gsr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_group
expr_stmt|;
name|ssa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_source
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|MCAST_BLOCK_SOURCE
case|:
case|case
name|MCAST_UNBLOCK_SOURCE
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|gsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|gsa
operator|->
name|sin6
operator|.
name|sin6_family
operator|!=
name|AF_INET6
operator|||
name|gsa
operator|->
name|sin6
operator|.
name|sin6_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ssa
operator|->
name|sin6
operator|.
name|sin6_family
operator|!=
name|AF_INET6
operator|||
name|ssa
operator|->
name|sin6
operator|.
name|sin6_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|gsr
operator|.
name|gsr_interface
operator|==
literal|0
operator|||
name|V_if_index
operator|<
name|gsr
operator|.
name|gsr_interface
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|gsr
operator|.
name|gsr_interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_BLOCK_SOURCE
condition|)
name|doblock
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: unknown sopt_name %d"
argument_list|,
name|__func__
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
block|}
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|gsa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|(
name|void
operator|)
name|in6_setscope
argument_list|(
operator|&
name|gsa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we are actually a member of this group. 	 */
name|imo
operator|=
name|in6p_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|idx
operator|=
name|im6o_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|imo
operator|->
name|im6o_mfilters
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_in6p_locked
goto|;
block|}
name|KASSERT
argument_list|(
name|imo
operator|->
name|im6o_mfilters
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: im6o_mfilters not allocated"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|im6o_mfilters
index|[
name|idx
index|]
expr_stmt|;
name|inm
operator|=
name|imo
operator|->
name|im6o_membership
index|[
name|idx
index|]
expr_stmt|;
comment|/* 	 * Attempting to use the delta-based API on an 	 * non exclusive-mode membership is an error. 	 */
name|fmode
operator|=
name|imf
operator|->
name|im6f_st
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|fmode
operator|!=
name|MCAST_EXCLUDE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_in6p_locked
goto|;
block|}
comment|/* 	 * Deal with error cases up-front: 	 *  Asked to block, but already blocked; or 	 *  Asked to unblock, but nothing to unblock. 	 * If adding a new block entry, allocate it. 	 */
name|ims
operator|=
name|im6o_match_source
argument_list|(
name|imo
argument_list|,
name|idx
argument_list|,
operator|&
name|ssa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ims
operator|!=
name|NULL
operator|&&
name|doblock
operator|)
operator|||
operator|(
name|ims
operator|==
name|NULL
operator|&&
operator|!
name|doblock
operator|)
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: source %s %spresent"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|ssa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|doblock
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_in6p_locked
goto|;
block|}
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 	 * Begin state merge transaction at socket layer. 	 */
if|if
condition|(
name|doblock
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: %s source"
argument_list|,
name|__func__
argument_list|,
literal|"block"
argument_list|)
expr_stmt|;
name|ims
operator|=
name|im6f_graft
argument_list|(
name|imf
argument_list|,
name|fmode
argument_list|,
operator|&
name|ssa
operator|->
name|sin6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ims
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: %s source"
argument_list|,
name|__func__
argument_list|,
literal|"allow"
argument_list|)
expr_stmt|;
name|error
operator|=
name|im6f_prune
argument_list|(
name|imf
argument_list|,
operator|&
name|ssa
operator|->
name|sin6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: merge imf state failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out_im6f_rollback
goto|;
block|}
comment|/* 	 * Begin state merge transaction at MLD layer. 	 */
name|IN6_MULTI_LOCK
argument_list|()
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|in6m_merge
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: failed to merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
else|else
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: doing mld downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|mld_change_state
argument_list|(
name|inm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: failed mld downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|IN6_MULTI_UNLOCK
argument_list|()
expr_stmt|;
name|out_im6f_rollback
label|:
if|if
condition|(
name|error
condition|)
name|im6f_rollback
argument_list|(
name|imf
argument_list|)
expr_stmt|;
else|else
name|im6f_commit
argument_list|(
name|imf
argument_list|)
expr_stmt|;
name|im6f_reap
argument_list|(
name|imf
argument_list|)
expr_stmt|;
name|out_in6p_locked
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an inpcb, return its multicast options structure pointer.  Accepts  * an unlocked inpcb pointer, but will return it locked.  May sleep.  *  * SMPng: NOTE: Potentially calls malloc(M_WAITOK) with Giant held.  * SMPng: NOTE: Returns with the INP write lock held.  */
end_comment

begin_function
specifier|static
name|struct
name|ip6_moptions
modifier|*
name|in6p_findmoptions
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|ip6_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in6_multi
modifier|*
modifier|*
name|immp
decl_stmt|;
name|struct
name|in6_mfilter
modifier|*
name|imfp
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|in6p_moptions
operator|!=
name|NULL
condition|)
return|return
operator|(
name|inp
operator|->
name|in6p_moptions
operator|)
return|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|imo
argument_list|)
argument_list|,
name|M_IP6MOPTS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|immp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|immp
argument_list|)
operator|*
name|IPV6_MIN_MEMBERSHIPS
argument_list|,
name|M_IP6MOPTS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|imfp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_mfilter
argument_list|)
operator|*
name|IPV6_MIN_MEMBERSHIPS
argument_list|,
name|M_IN6MFILTER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|imo
operator|->
name|im6o_multicast_ifp
operator|=
name|NULL
expr_stmt|;
name|imo
operator|->
name|im6o_multicast_hlim
operator|=
name|V_ip6_defmcasthlim
expr_stmt|;
name|imo
operator|->
name|im6o_multicast_loop
operator|=
name|in6_mcast_loop
expr_stmt|;
name|imo
operator|->
name|im6o_num_memberships
operator|=
literal|0
expr_stmt|;
name|imo
operator|->
name|im6o_max_memberships
operator|=
name|IPV6_MIN_MEMBERSHIPS
expr_stmt|;
name|imo
operator|->
name|im6o_membership
operator|=
name|immp
expr_stmt|;
comment|/* Initialize per-group source filters. */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|IPV6_MIN_MEMBERSHIPS
condition|;
name|idx
operator|++
control|)
name|im6f_init
argument_list|(
operator|&
name|imfp
index|[
name|idx
index|]
argument_list|,
name|MCAST_UNDEFINED
argument_list|,
name|MCAST_EXCLUDE
argument_list|)
expr_stmt|;
name|imo
operator|->
name|im6o_mfilters
operator|=
name|imfp
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|in6p_moptions
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|imfp
argument_list|,
name|M_IN6MFILTER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|immp
argument_list|,
name|M_IP6MOPTS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imo
argument_list|,
name|M_IP6MOPTS
argument_list|)
expr_stmt|;
return|return
operator|(
name|inp
operator|->
name|in6p_moptions
operator|)
return|;
block|}
name|inp
operator|->
name|in6p_moptions
operator|=
name|imo
expr_stmt|;
return|return
operator|(
name|imo
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Discard the IPv6 multicast options (and source filters).  *  * SMPng: NOTE: assumes INP write lock is held.  */
end_comment

begin_function
name|void
name|ip6_freemoptions
parameter_list|(
name|struct
name|ip6_moptions
modifier|*
name|imo
parameter_list|)
block|{
name|struct
name|in6_mfilter
modifier|*
name|imf
decl_stmt|;
name|size_t
name|idx
decl_stmt|,
name|nmships
decl_stmt|;
name|KASSERT
argument_list|(
name|imo
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ip6_moptions is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|nmships
operator|=
name|imo
operator|->
name|im6o_num_memberships
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nmships
condition|;
operator|++
name|idx
control|)
block|{
name|imf
operator|=
name|imo
operator|->
name|im6o_mfilters
condition|?
operator|&
name|imo
operator|->
name|im6o_mfilters
index|[
name|idx
index|]
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|imf
condition|)
name|im6f_leave
argument_list|(
name|imf
argument_list|)
expr_stmt|;
comment|/* XXX this will thrash the lock(s) */
operator|(
name|void
operator|)
name|in6_mc_leave
argument_list|(
name|imo
operator|->
name|im6o_membership
index|[
name|idx
index|]
argument_list|,
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|imf
condition|)
name|im6f_purge
argument_list|(
name|imf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|imo
operator|->
name|im6o_mfilters
condition|)
name|free
argument_list|(
name|imo
operator|->
name|im6o_mfilters
argument_list|,
name|M_IN6MFILTER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imo
operator|->
name|im6o_membership
argument_list|,
name|M_IP6MOPTS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imo
argument_list|,
name|M_IP6MOPTS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Atomically get source filters on a socket for an IPv6 multicast group.  * Called with INP lock held; returns with lock released.  */
end_comment

begin_function
specifier|static
name|int
name|in6p_get_source_filters
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|__msfilterreq
name|msfr
decl_stmt|;
name|sockunion_t
modifier|*
name|gsa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ip6_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in6_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|;
name|struct
name|in6_msource
modifier|*
name|lims
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|psin
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|ptss
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|tss
decl_stmt|;
name|int
name|error
decl_stmt|;
name|size_t
name|idx
decl_stmt|,
name|nsrcs
decl_stmt|,
name|ncsrcs
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|=
name|inp
operator|->
name|in6p_moptions
expr_stmt|;
name|KASSERT
argument_list|(
name|imo
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: null ip6_moptions"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|msfr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|__msfilterreq
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|__msfilterreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|msfr
operator|.
name|msfr_group
operator|.
name|ss_family
operator|!=
name|AF_INET6
operator|||
name|msfr
operator|.
name|msfr_group
operator|.
name|ss_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|msfr
operator|.
name|msfr_group
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|gsa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|msfr
operator|.
name|msfr_ifindex
operator|==
literal|0
operator|||
name|V_if_index
operator|<
name|msfr
operator|.
name|msfr_ifindex
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|msfr
operator|.
name|msfr_ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
operator|(
name|void
operator|)
name|in6_setscope
argument_list|(
operator|&
name|gsa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 	 * Lookup group on the socket. 	 */
name|idx
operator|=
name|im6o_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|imo
operator|->
name|im6o_mfilters
operator|==
name|NULL
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
name|imf
operator|=
operator|&
name|imo
operator|->
name|im6o_mfilters
index|[
name|idx
index|]
expr_stmt|;
comment|/* 	 * Ignore memberships which are in limbo. 	 */
if|if
condition|(
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
operator|==
name|MCAST_UNDEFINED
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|msfr
operator|.
name|msfr_fmode
operator|=
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
expr_stmt|;
comment|/* 	 * If the user specified a buffer, copy out the source filter 	 * entries to userland gracefully. 	 * We only copy out the number of entries which userland 	 * has asked for, but we always tell userland how big the 	 * buffer really needs to be. 	 */
if|if
condition|(
name|msfr
operator|.
name|msfr_nsrcs
operator|>
name|in6_mcast_maxsocksrc
condition|)
name|msfr
operator|.
name|msfr_nsrcs
operator|=
name|in6_mcast_maxsocksrc
expr_stmt|;
name|tss
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|msfr
operator|.
name|msfr_srcs
operator|!=
name|NULL
operator|&&
name|msfr
operator|.
name|msfr_nsrcs
operator|>
literal|0
condition|)
block|{
name|tss
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
operator|*
name|msfr
operator|.
name|msfr_nsrcs
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|tss
operator|==
name|NULL
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
comment|/* 	 * Count number of sources in-mode at t0. 	 * If buffer space exists and remains, copy out source entries. 	 */
name|nsrcs
operator|=
name|msfr
operator|.
name|msfr_nsrcs
expr_stmt|;
name|ncsrcs
operator|=
literal|0
expr_stmt|;
name|ptss
operator|=
name|tss
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|&imf->im6f_sources
argument_list|)
block|{
name|lims
operator|=
operator|(
expr|struct
name|in6_msource
operator|*
operator|)
name|ims
expr_stmt|;
if|if
condition|(
name|lims
operator|->
name|im6sl_st
index|[
literal|0
index|]
operator|==
name|MCAST_UNDEFINED
operator|||
name|lims
operator|->
name|im6sl_st
index|[
literal|0
index|]
operator|!=
name|imf
operator|->
name|im6f_st
index|[
literal|0
index|]
condition|)
continue|continue;
operator|++
name|ncsrcs
expr_stmt|;
if|if
condition|(
name|tss
operator|!=
name|NULL
operator|&&
name|nsrcs
operator|>
literal|0
condition|)
block|{
name|psin
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ptss
expr_stmt|;
name|psin
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|psin
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|psin
operator|->
name|sin6_addr
operator|=
name|lims
operator|->
name|im6s_addr
expr_stmt|;
name|psin
operator|->
name|sin6_port
operator|=
literal|0
expr_stmt|;
operator|--
name|nsrcs
expr_stmt|;
operator|++
name|ptss
expr_stmt|;
block|}
block|}
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tss
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyout
argument_list|(
name|tss
argument_list|,
name|msfr
operator|.
name|msfr_srcs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
operator|*
name|msfr
operator|.
name|msfr_nsrcs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tss
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|msfr
operator|.
name|msfr_nsrcs
operator|=
name|ncsrcs
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|msfr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|__msfilterreq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the IP multicast options in response to user getsockopt().  */
end_comment

begin_function
name|int
name|ip6_getmoptions
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|ip6_moptions
modifier|*
name|im6o
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|optval
decl_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|im6o
operator|=
name|inp
operator|->
name|in6p_moptions
expr_stmt|;
comment|/* 	 * If socket is neither of type SOCK_RAW or SOCK_DGRAM, 	 * or is a divert socket, reject it. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_DIVERT
operator|||
operator|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_type
operator|!=
name|SOCK_RAW
operator|&&
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_type
operator|!=
name|SOCK_DGRAM
operator|)
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|IPV6_MULTICAST_IF
case|:
if|if
condition|(
name|im6o
operator|==
name|NULL
operator|||
name|im6o
operator|->
name|im6o_multicast_ifp
operator|==
name|NULL
condition|)
block|{
name|optval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|optval
operator|=
name|im6o
operator|->
name|im6o_multicast_ifp
operator|->
name|if_index
expr_stmt|;
block|}
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_MULTICAST_HOPS
case|:
if|if
condition|(
name|im6o
operator|==
name|NULL
condition|)
name|optval
operator|=
name|V_ip6_defmcasthlim
expr_stmt|;
else|else
name|optval
operator|=
name|im6o
operator|->
name|im6o_multicast_hlim
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_MULTICAST_LOOP
case|:
if|if
condition|(
name|im6o
operator|==
name|NULL
condition|)
name|optval
operator|=
name|in6_mcast_loop
expr_stmt|;
comment|/* XXX VIMAGE */
else|else
name|optval
operator|=
name|im6o
operator|->
name|im6o_multicast_loop
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_MSFILTER
case|:
if|if
condition|(
name|im6o
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|in6p_get_source_filters
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
name|INP_UNLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up the ifnet to use for a multicast group membership,  * given the address of an IPv6 group.  *  * This routine exists to support legacy IPv6 multicast applications.  *  * If inp is non-NULL, use this socket's current FIB number for any  * required FIB lookup. Look up the group address in the unicast FIB,  * and use its ifp; usually, this points to the default next-hop.  * If the FIB lookup fails, return NULL.  *  * FUTURE: Support multiple forwarding tables for IPv6.  *  * Returns NULL if no ifp could be found.  */
end_comment

begin_function
specifier|static
name|struct
name|ifnet
modifier|*
name|in6p_lookup_mcast_ifp
parameter_list|(
specifier|const
name|struct
name|inpcb
modifier|*
name|in6p
parameter_list|,
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|gsin6
parameter_list|)
block|{
name|struct
name|route_in6
name|ro6
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|KASSERT
argument_list|(
name|in6p
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
argument_list|,
operator|(
literal|"%s: not INP_IPV6 inpcb"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|gsin6
operator|->
name|sin6_family
operator|==
name|AF_INET6
argument_list|,
operator|(
literal|"%s: not AF_INET6 group"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ro6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|route_in6
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ro6
operator|.
name|ro_dst
argument_list|,
name|gsin6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|rtalloc_ign_fib
argument_list|(
operator|(
expr|struct
name|route
operator|*
operator|)
operator|&
name|ro6
argument_list|,
literal|0
argument_list|,
name|in6p
condition|?
name|in6p
operator|->
name|inp_inc
operator|.
name|inc_fibnum
else|:
name|RT_DEFAULT_FIB
argument_list|)
expr_stmt|;
if|if
condition|(
name|ro6
operator|.
name|ro_rt
operator|!=
name|NULL
condition|)
block|{
name|ifp
operator|=
name|ro6
operator|.
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
name|KASSERT
argument_list|(
name|ifp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: null ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|RTFREE
argument_list|(
name|ro6
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ifp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Join an IPv6 multicast group, possibly with a source.  *  * FIXME: The KAME use of the unspecified address (::)  * to join *all* multicast groups is currently unsupported.  */
end_comment

begin_function
specifier|static
name|int
name|in6p_join_group
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|group_source_req
name|gsr
decl_stmt|;
name|sockunion_t
modifier|*
name|gsa
decl_stmt|,
modifier|*
name|ssa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in6_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip6_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|inm
decl_stmt|;
name|struct
name|in6_msource
modifier|*
name|lims
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|int
name|error
decl_stmt|,
name|is_new
decl_stmt|;
name|ifp
operator|=
name|NULL
expr_stmt|;
name|imf
operator|=
name|NULL
expr_stmt|;
name|lims
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|is_new
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|gsr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_group
expr_stmt|;
name|gsa
operator|->
name|ss
operator|.
name|ss_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|ssa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_source
expr_stmt|;
name|ssa
operator|->
name|ss
operator|.
name|ss_family
operator|=
name|AF_UNSPEC
expr_stmt|;
comment|/* 	 * Chew everything into struct group_source_req. 	 * Overwrite the port field if present, as the sockaddr 	 * being copied in may be matched with a binary comparison. 	 * Ignore passed-in scope ID. 	 */
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|IPV6_JOIN_GROUP
case|:
block|{
name|struct
name|ipv6_mreq
name|mreq
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipv6_mreq
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipv6_mreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|gsa
operator|->
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|gsa
operator|->
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|gsa
operator|->
name|sin6
operator|.
name|sin6_addr
operator|=
name|mreq
operator|.
name|ipv6mr_multiaddr
expr_stmt|;
if|if
condition|(
name|mreq
operator|.
name|ipv6mr_interface
operator|==
literal|0
condition|)
block|{
name|ifp
operator|=
name|in6p_lookup_mcast_ifp
argument_list|(
name|inp
argument_list|,
operator|&
name|gsa
operator|->
name|sin6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|V_if_index
operator|<
name|mreq
operator|.
name|ipv6mr_interface
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|mreq
operator|.
name|ipv6mr_interface
argument_list|)
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: ipv6mr_interface = %d, ifp = %p"
argument_list|,
name|__func__
argument_list|,
name|mreq
operator|.
name|ipv6mr_interface
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MCAST_JOIN_GROUP
case|:
case|case
name|MCAST_JOIN_SOURCE_GROUP
case|:
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_JOIN_GROUP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|gsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_req
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_req
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_JOIN_SOURCE_GROUP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|gsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|gsa
operator|->
name|sin6
operator|.
name|sin6_family
operator|!=
name|AF_INET6
operator|||
name|gsa
operator|->
name|sin6
operator|.
name|sin6_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_JOIN_SOURCE_GROUP
condition|)
block|{
if|if
condition|(
name|ssa
operator|->
name|sin6
operator|.
name|sin6_family
operator|!=
name|AF_INET6
operator|||
name|ssa
operator|->
name|sin6
operator|.
name|sin6_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ssa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 			 * TODO: Validate embedded scope ID in source 			 * list entry against passed-in ifp, if and only 			 * if source list filter entry is iface or node local. 			 */
name|in6_clearscope
argument_list|(
operator|&
name|ssa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|)
expr_stmt|;
name|ssa
operator|->
name|sin6
operator|.
name|sin6_port
operator|=
literal|0
expr_stmt|;
name|ssa
operator|->
name|sin6
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|gsr
operator|.
name|gsr_interface
operator|==
literal|0
operator|||
name|V_if_index
operator|<
name|gsr
operator|.
name|gsr_interface
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|gsr
operator|.
name|gsr_interface
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: unknown sopt_name %d"
argument_list|,
name|__func__
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
block|}
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|gsa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ifp
operator|==
name|NULL
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|gsa
operator|->
name|sin6
operator|.
name|sin6_port
operator|=
literal|0
expr_stmt|;
name|gsa
operator|->
name|sin6
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Always set the scope zone ID on memberships created from userland. 	 * Use the passed-in ifp to do this. 	 * XXX The in6_setscope() return value is meaningless. 	 * XXX SCOPE6_LOCK() is taken by in6_setscope(). 	 */
operator|(
name|void
operator|)
name|in6_setscope
argument_list|(
operator|&
name|gsa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|imo
operator|=
name|in6p_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|idx
operator|=
name|im6o_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
name|is_new
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|inm
operator|=
name|imo
operator|->
name|im6o_membership
index|[
name|idx
index|]
expr_stmt|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|im6o_mfilters
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|ssa
operator|->
name|ss
operator|.
name|ss_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
comment|/* 			 * MCAST_JOIN_SOURCE_GROUP on an exclusive membership 			 * is an error. On an existing inclusive membership, 			 * it just adds the source to the filter list. 			 */
if|if
condition|(
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
operator|!=
name|MCAST_INCLUDE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_in6p_locked
goto|;
block|}
comment|/* 			 * Throw out duplicates. 			 * 			 * XXX FIXME: This makes a naive assumption that 			 * even if entries exist for *ssa in this imf, 			 * they will be rejected as dupes, even if they 			 * are not valid in the current mode (in-mode). 			 * 			 * in6_msource is transactioned just as for anything 			 * else in SSM -- but note naive use of in6m_graft() 			 * below for allocating new filter entries. 			 * 			 * This is only an issue if someone mixes the 			 * full-state SSM API with the delta-based API, 			 * which is discouraged in the relevant RFCs. 			 */
name|lims
operator|=
name|im6o_match_source
argument_list|(
name|imo
argument_list|,
name|idx
argument_list|,
operator|&
name|ssa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|lims
operator|!=
name|NULL
comment|/*&& 			    lims->im6sl_st[1] == MCAST_INCLUDE*/
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_in6p_locked
goto|;
block|}
block|}
else|else
block|{
comment|/* 			 * MCAST_JOIN_GROUP alone, on any existing membership, 			 * is rejected, to stop the same inpcb tying up 			 * multiple refs to the in_multi. 			 * On an existing inclusive membership, this is also 			 * an error; if you want to change filter mode, 			 * you must use the userland API setsourcefilter(). 			 * XXX We don't reject this for imf in UNDEFINED 			 * state at t1, because allocation of a filter 			 * is atomic with allocation of a membership. 			 */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_in6p_locked
goto|;
block|}
block|}
comment|/* 	 * Begin state merge transaction at socket layer. 	 */
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_new
condition|)
block|{
if|if
condition|(
name|imo
operator|->
name|im6o_num_memberships
operator|==
name|imo
operator|->
name|im6o_max_memberships
condition|)
block|{
name|error
operator|=
name|im6o_grow
argument_list|(
name|imo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out_in6p_locked
goto|;
block|}
comment|/* 		 * Allocate the new slot upfront so we can deal with 		 * grafting the new source filter in same code path 		 * as for join-source on existing membership. 		 */
name|idx
operator|=
name|imo
operator|->
name|im6o_num_memberships
expr_stmt|;
name|imo
operator|->
name|im6o_membership
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
name|imo
operator|->
name|im6o_num_memberships
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|imo
operator|->
name|im6o_mfilters
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: im6f_mfilters vector was not allocated"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|im6o_mfilters
index|[
name|idx
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|RB_EMPTY
argument_list|(
operator|&
name|imf
operator|->
name|im6f_sources
argument_list|)
argument_list|,
operator|(
literal|"%s: im6f_sources not empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Graft new source into filter list for this inpcb's 	 * membership of the group. The in6_multi may not have 	 * been allocated yet if this is a new membership, however, 	 * the in_mfilter slot will be allocated and must be initialized. 	 * 	 * Note: Grafting of exclusive mode filters doesn't happen 	 * in this path. 	 * XXX: Should check for non-NULL lims (node exists but may 	 * not be in-mode) for interop with full-state API. 	 */
if|if
condition|(
name|ssa
operator|->
name|ss
operator|.
name|ss_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
comment|/* Membership starts in IN mode */
if|if
condition|(
name|is_new
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: new join w/source"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|im6f_init
argument_list|(
name|imf
argument_list|,
name|MCAST_UNDEFINED
argument_list|,
name|MCAST_INCLUDE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: %s source"
argument_list|,
name|__func__
argument_list|,
literal|"allow"
argument_list|)
expr_stmt|;
block|}
name|lims
operator|=
name|im6f_graft
argument_list|(
name|imf
argument_list|,
name|MCAST_INCLUDE
argument_list|,
operator|&
name|ssa
operator|->
name|sin6
argument_list|)
expr_stmt|;
if|if
condition|(
name|lims
operator|==
name|NULL
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: merge imf state failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out_im6o_free
goto|;
block|}
block|}
else|else
block|{
comment|/* No address specified; Membership starts in EX mode */
if|if
condition|(
name|is_new
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: new join w/o source"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|im6f_init
argument_list|(
name|imf
argument_list|,
name|MCAST_UNDEFINED
argument_list|,
name|MCAST_EXCLUDE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Begin state merge transaction at MLD layer. 	 */
name|IN6_MULTI_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_new
condition|)
block|{
name|error
operator|=
name|in6_mc_join_locked
argument_list|(
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|imf
argument_list|,
operator|&
name|inm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IN6_MULTI_UNLOCK
argument_list|()
expr_stmt|;
goto|goto
name|out_im6o_free
goto|;
block|}
name|imo
operator|->
name|im6o_membership
index|[
name|idx
index|]
operator|=
name|inm
expr_stmt|;
block|}
else|else
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|in6m_merge
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: failed to merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
else|else
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: doing mld downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|mld_change_state
argument_list|(
name|inm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: failed mld downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
name|IN6_MULTI_UNLOCK
argument_list|()
expr_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|im6f_rollback
argument_list|(
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_new
condition|)
name|im6f_purge
argument_list|(
name|imf
argument_list|)
expr_stmt|;
else|else
name|im6f_reap
argument_list|(
name|imf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|im6f_commit
argument_list|(
name|imf
argument_list|)
expr_stmt|;
block|}
name|out_im6o_free
label|:
if|if
condition|(
name|error
operator|&&
name|is_new
condition|)
block|{
name|imo
operator|->
name|im6o_membership
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
operator|--
name|imo
operator|->
name|im6o_num_memberships
expr_stmt|;
block|}
name|out_in6p_locked
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Leave an IPv6 multicast group on an inpcb, possibly with a source.  */
end_comment

begin_function
specifier|static
name|int
name|in6p_leave_group
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|ipv6_mreq
name|mreq
decl_stmt|;
name|struct
name|group_source_req
name|gsr
decl_stmt|;
name|sockunion_t
modifier|*
name|gsa
decl_stmt|,
modifier|*
name|ssa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in6_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip6_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in6_msource
modifier|*
name|ims
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|inm
decl_stmt|;
name|uint32_t
name|ifindex
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|int
name|error
decl_stmt|,
name|is_final
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|ifp
operator|=
name|NULL
expr_stmt|;
name|ifindex
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|is_final
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|gsr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_group
expr_stmt|;
name|gsa
operator|->
name|ss
operator|.
name|ss_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|ssa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_source
expr_stmt|;
name|ssa
operator|->
name|ss
operator|.
name|ss_family
operator|=
name|AF_UNSPEC
expr_stmt|;
comment|/* 	 * Chew everything passed in up into a struct group_source_req 	 * as that is easier to process. 	 * Note: Any embedded scope ID in the multicast group passed 	 * in by userland is ignored, the interface index is the recommended 	 * mechanism to specify an interface; see below. 	 */
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|IPV6_LEAVE_GROUP
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipv6_mreq
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipv6_mreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|gsa
operator|->
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|gsa
operator|->
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|gsa
operator|->
name|sin6
operator|.
name|sin6_addr
operator|=
name|mreq
operator|.
name|ipv6mr_multiaddr
expr_stmt|;
name|gsa
operator|->
name|sin6
operator|.
name|sin6_port
operator|=
literal|0
expr_stmt|;
name|gsa
operator|->
name|sin6
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
name|ifindex
operator|=
name|mreq
operator|.
name|ipv6mr_interface
expr_stmt|;
break|break;
case|case
name|MCAST_LEAVE_GROUP
case|:
case|case
name|MCAST_LEAVE_SOURCE_GROUP
case|:
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_LEAVE_GROUP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|gsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_req
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_req
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_LEAVE_SOURCE_GROUP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|gsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|gsa
operator|->
name|sin6
operator|.
name|sin6_family
operator|!=
name|AF_INET6
operator|||
name|gsa
operator|->
name|sin6
operator|.
name|sin6_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_LEAVE_SOURCE_GROUP
condition|)
block|{
if|if
condition|(
name|ssa
operator|->
name|sin6
operator|.
name|sin6_family
operator|!=
name|AF_INET6
operator|||
name|ssa
operator|->
name|sin6
operator|.
name|sin6_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ssa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 			 * TODO: Validate embedded scope ID in source 			 * list entry against passed-in ifp, if and only 			 * if source list filter entry is iface or node local. 			 */
name|in6_clearscope
argument_list|(
operator|&
name|ssa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|)
expr_stmt|;
block|}
name|gsa
operator|->
name|sin6
operator|.
name|sin6_port
operator|=
literal|0
expr_stmt|;
name|gsa
operator|->
name|sin6
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
name|ifindex
operator|=
name|gsr
operator|.
name|gsr_interface
expr_stmt|;
break|break;
default|default:
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: unknown sopt_name %d"
argument_list|,
name|__func__
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
block|}
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|gsa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Validate interface index if provided. If no interface index 	 * was provided separately, attempt to look the membership up 	 * from the default scope as a last resort to disambiguate 	 * the membership we are being asked to leave. 	 * XXX SCOPE6 lock potentially taken here. 	 */
if|if
condition|(
name|ifindex
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|V_if_index
operator|<
name|ifindex
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
operator|(
name|void
operator|)
name|in6_setscope
argument_list|(
operator|&
name|gsa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|sa6_embedscope
argument_list|(
operator|&
name|gsa
operator|->
name|sin6
argument_list|,
name|V_ip6_use_defzone
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
comment|/* 		 * Some badly behaved applications don't pass an ifindex 		 * or a scope ID, which is an API violation. In this case, 		 * perform a lookup as per a v6 join. 		 * 		 * XXX For now, stomp on zone ID for the corner case. 		 * This is not the 'KAME way', but we need to see the ifp 		 * directly until such time as this implementation is 		 * refactored, assuming the scope IDs are the way to go. 		 */
name|ifindex
operator|=
name|ntohs
argument_list|(
name|gsa
operator|->
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr16
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifindex
operator|==
literal|0
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: warning: no ifindex, looking up "
literal|"ifp for group %s."
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|gsa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|in6p_lookup_mcast_ifp
argument_list|(
name|inp
argument_list|,
operator|&
name|gsa
operator|->
name|sin6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|ifindex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: ifp = %p"
argument_list|,
name|__func__
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ifp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ifp did not resolve"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Find the membership in the membership array. 	 */
name|imo
operator|=
name|in6p_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|idx
operator|=
name|im6o_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_in6p_locked
goto|;
block|}
name|inm
operator|=
name|imo
operator|->
name|im6o_membership
index|[
name|idx
index|]
expr_stmt|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|im6o_mfilters
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|ssa
operator|->
name|ss
operator|.
name|ss_family
operator|!=
name|AF_UNSPEC
condition|)
name|is_final
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Begin state merge transaction at socket layer. 	 */
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 	 * If we were instructed only to leave a given source, do so. 	 * MCAST_LEAVE_SOURCE_GROUP is only valid for inclusive memberships. 	 */
if|if
condition|(
name|is_final
condition|)
block|{
name|im6f_leave
argument_list|(
name|imf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|imf
operator|->
name|im6f_st
index|[
literal|0
index|]
operator|==
name|MCAST_EXCLUDE
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_in6p_locked
goto|;
block|}
name|ims
operator|=
name|im6o_match_source
argument_list|(
name|imo
argument_list|,
name|idx
argument_list|,
operator|&
name|ssa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ims
operator|==
name|NULL
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: source %p %spresent"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|ssa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|)
argument_list|,
literal|"not "
argument_list|)
expr_stmt|;
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_in6p_locked
goto|;
block|}
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: %s source"
argument_list|,
name|__func__
argument_list|,
literal|"block"
argument_list|)
expr_stmt|;
name|error
operator|=
name|im6f_prune
argument_list|(
name|imf
argument_list|,
operator|&
name|ssa
operator|->
name|sin6
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: merge imf state failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out_in6p_locked
goto|;
block|}
block|}
comment|/* 	 * Begin state merge transaction at MLD layer. 	 */
name|IN6_MULTI_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_final
condition|)
block|{
comment|/* 		 * Give up the multicast address record to which 		 * the membership points. 		 */
operator|(
name|void
operator|)
name|in6_mc_leave_locked
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|in6m_merge
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: failed to merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
else|else
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: doing mld downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|mld_change_state
argument_list|(
name|inm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: failed mld downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
name|IN6_MULTI_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|im6f_rollback
argument_list|(
name|imf
argument_list|)
expr_stmt|;
else|else
name|im6f_commit
argument_list|(
name|imf
argument_list|)
expr_stmt|;
name|im6f_reap
argument_list|(
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_final
condition|)
block|{
comment|/* Remove the gap in the membership array. */
for|for
control|(
operator|++
name|idx
init|;
name|idx
operator|<
name|imo
operator|->
name|im6o_num_memberships
condition|;
operator|++
name|idx
control|)
block|{
name|imo
operator|->
name|im6o_membership
index|[
name|idx
operator|-
literal|1
index|]
operator|=
name|imo
operator|->
name|im6o_membership
index|[
name|idx
index|]
expr_stmt|;
name|imo
operator|->
name|im6o_mfilters
index|[
name|idx
operator|-
literal|1
index|]
operator|=
name|imo
operator|->
name|im6o_mfilters
index|[
name|idx
index|]
expr_stmt|;
block|}
name|imo
operator|->
name|im6o_num_memberships
operator|--
expr_stmt|;
block|}
name|out_in6p_locked
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Select the interface for transmitting IPv6 multicast datagrams.  *  * Either an instance of struct in6_addr or an instance of struct ipv6_mreqn  * may be passed to this socket option. An address of in6addr_any or an  * interface index of 0 is used to remove a previous selection.  * When no interface is selected, one is chosen for every send.  */
end_comment

begin_function
specifier|static
name|int
name|in6p_set_multicast_if
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ip6_moptions
modifier|*
name|imo
decl_stmt|;
name|u_int
name|ifindex
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|!=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|ifindex
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|V_if_index
operator|<
name|ifindex
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ifindex
operator|==
literal|0
condition|)
name|ifp
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
name|imo
operator|=
name|in6p_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|->
name|im6o_multicast_ifp
operator|=
name|ifp
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically set source filters on a socket for an IPv6 multicast group.  *  * SMPng: NOTE: Potentially calls malloc(M_WAITOK) with Giant held.  */
end_comment

begin_function
specifier|static
name|int
name|in6p_set_source_filters
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|__msfilterreq
name|msfr
decl_stmt|;
name|sockunion_t
modifier|*
name|gsa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in6_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip6_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|inm
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|msfr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|__msfilterreq
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|__msfilterreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|msfr
operator|.
name|msfr_nsrcs
operator|>
name|in6_mcast_maxsocksrc
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
if|if
condition|(
name|msfr
operator|.
name|msfr_fmode
operator|!=
name|MCAST_EXCLUDE
operator|&&
name|msfr
operator|.
name|msfr_fmode
operator|!=
name|MCAST_INCLUDE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|msfr
operator|.
name|msfr_group
operator|.
name|ss_family
operator|!=
name|AF_INET6
operator|||
name|msfr
operator|.
name|msfr_group
operator|.
name|ss_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|msfr
operator|.
name|msfr_group
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|gsa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|gsa
operator|->
name|sin6
operator|.
name|sin6_port
operator|=
literal|0
expr_stmt|;
comment|/* ignore port */
if|if
condition|(
name|msfr
operator|.
name|msfr_ifindex
operator|==
literal|0
operator|||
name|V_if_index
operator|<
name|msfr
operator|.
name|msfr_ifindex
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|msfr
operator|.
name|msfr_ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
operator|(
name|void
operator|)
name|in6_setscope
argument_list|(
operator|&
name|gsa
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Take the INP write lock. 	 * Check if this socket is a member of this group. 	 */
name|imo
operator|=
name|in6p_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|idx
operator|=
name|im6o_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|imo
operator|->
name|im6o_mfilters
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_in6p_locked
goto|;
block|}
name|inm
operator|=
name|imo
operator|->
name|im6o_membership
index|[
name|idx
index|]
expr_stmt|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|im6o_mfilters
index|[
name|idx
index|]
expr_stmt|;
comment|/* 	 * Begin state merge transaction at socket layer. 	 */
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
operator|=
name|msfr
operator|.
name|msfr_fmode
expr_stmt|;
comment|/* 	 * Apply any new source filters, if present. 	 * Make a copy of the user-space source vector so 	 * that we may copy them with a single copyin. This 	 * allows us to deal with page faults up-front. 	 */
if|if
condition|(
name|msfr
operator|.
name|msfr_nsrcs
operator|>
literal|0
condition|)
block|{
name|struct
name|in6_msource
modifier|*
name|lims
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|psin
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|kss
decl_stmt|,
modifier|*
name|pkss
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: loading %lu source list entries"
argument_list|,
name|__func__
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|msfr
operator|.
name|msfr_nsrcs
argument_list|)
expr_stmt|;
name|kss
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
operator|*
name|msfr
operator|.
name|msfr_nsrcs
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|msfr
operator|.
name|msfr_srcs
argument_list|,
name|kss
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
operator|*
name|msfr
operator|.
name|msfr_nsrcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|kss
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 		 * Mark all source filters as UNDEFINED at t1. 		 * Restore new group filter mode, as im6f_leave() 		 * will set it to INCLUDE. 		 */
name|im6f_leave
argument_list|(
name|imf
argument_list|)
expr_stmt|;
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
operator|=
name|msfr
operator|.
name|msfr_fmode
expr_stmt|;
comment|/* 		 * Update socket layer filters at t1, lazy-allocating 		 * new entries. This saves a bunch of memory at the 		 * cost of one RB_FIND() per source entry; duplicate 		 * entries in the msfr_nsrcs vector are ignored. 		 * If we encounter an error, rollback transaction. 		 * 		 * XXX This too could be replaced with a set-symmetric 		 * difference like loop to avoid walking from root 		 * every time, as the key space is common. 		 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pkss
operator|=
name|kss
init|;
name|i
operator|<
name|msfr
operator|.
name|msfr_nsrcs
condition|;
name|i
operator|++
operator|,
name|pkss
operator|++
control|)
block|{
name|psin
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|pkss
expr_stmt|;
if|if
condition|(
name|psin
operator|->
name|sin6_family
operator|!=
name|AF_INET6
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|psin
operator|->
name|sin6_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|psin
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 			 * TODO: Validate embedded scope ID in source 			 * list entry against passed-in ifp, if and only 			 * if source list filter entry is iface or node local. 			 */
name|in6_clearscope
argument_list|(
operator|&
name|psin
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
name|error
operator|=
name|im6f_get_source
argument_list|(
name|imf
argument_list|,
name|psin
argument_list|,
operator|&
name|lims
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|lims
operator|->
name|im6sl_st
index|[
literal|1
index|]
operator|=
name|imf
operator|->
name|im6f_st
index|[
literal|1
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|kss
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|out_im6f_rollback
goto|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|IN6_MULTI_LOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Begin state merge transaction at MLD layer. 	 */
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|in6m_merge
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: failed to merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
else|else
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: doing mld downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|mld_change_state
argument_list|(
name|inm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: failed mld downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|IN6_MULTI_UNLOCK
argument_list|()
expr_stmt|;
name|out_im6f_rollback
label|:
if|if
condition|(
name|error
condition|)
name|im6f_rollback
argument_list|(
name|imf
argument_list|)
expr_stmt|;
else|else
name|im6f_commit
argument_list|(
name|imf
argument_list|)
expr_stmt|;
name|im6f_reap
argument_list|(
name|imf
argument_list|)
expr_stmt|;
name|out_in6p_locked
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the IP multicast options in response to user setsockopt().  *  * Many of the socket options handled in this function duplicate the  * functionality of socket options in the regular unicast API. However,  * it is not possible to merge the duplicate code, because the idempotence  * of the IPv6 multicast part of the BSD Sockets API must be preserved;  * the effects of these options must be treated as separate and distinct.  *  * SMPng: XXX: Unlocked read of inp_socket believed OK.  */
end_comment

begin_function
name|int
name|ip6_setmoptions
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|ip6_moptions
modifier|*
name|im6o
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If socket is neither of type SOCK_RAW or SOCK_DGRAM, 	 * or is a divert socket, reject it. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_DIVERT
operator|||
operator|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_type
operator|!=
name|SOCK_RAW
operator|&&
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_type
operator|!=
name|SOCK_DGRAM
operator|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|IPV6_MULTICAST_IF
case|:
name|error
operator|=
name|in6p_set_multicast_if
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_MULTICAST_HOPS
case|:
block|{
name|int
name|hlim
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|hlim
argument_list|,
sizeof|sizeof
argument_list|(
name|hlim
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|hlim
operator|<
operator|-
literal|1
operator|||
name|hlim
operator|>
literal|255
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|hlim
operator|==
operator|-
literal|1
condition|)
block|{
name|hlim
operator|=
name|V_ip6_defmcasthlim
expr_stmt|;
block|}
name|im6o
operator|=
name|in6p_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|im6o
operator|->
name|im6o_multicast_hlim
operator|=
name|hlim
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IPV6_MULTICAST_LOOP
case|:
block|{
name|u_int
name|loop
decl_stmt|;
comment|/* 		 * Set the loopback flag for outgoing multicast packets. 		 * Must be zero or one. 		 */
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|!=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|loop
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|loop
operator|>
literal|1
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|im6o
operator|=
name|in6p_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|im6o
operator|->
name|im6o_multicast_loop
operator|=
name|loop
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IPV6_JOIN_GROUP
case|:
case|case
name|MCAST_JOIN_GROUP
case|:
case|case
name|MCAST_JOIN_SOURCE_GROUP
case|:
name|error
operator|=
name|in6p_join_group
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_LEAVE_GROUP
case|:
case|case
name|MCAST_LEAVE_GROUP
case|:
case|case
name|MCAST_LEAVE_SOURCE_GROUP
case|:
name|error
operator|=
name|in6p_leave_group
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|MCAST_BLOCK_SOURCE
case|:
case|case
name|MCAST_UNBLOCK_SOURCE
case|:
name|error
operator|=
name|in6p_block_unblock_source
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_MSFILTER
case|:
name|error
operator|=
name|in6p_set_source_filters
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
name|INP_UNLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Expose MLD's multicast filter mode and source list(s) to userland,  * keyed by (ifindex, group).  * The filter mode is written out as a uint32_t, followed by  * 0..n of struct in6_addr.  * For use by ifmcstat(8).  * SMPng: NOTE: unlocked read of ifindex space.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_ip6_mcast_filters
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|in6_addr
name|mcaddr
decl_stmt|;
name|struct
name|in6_addr
name|src
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|inm
decl_stmt|;
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|;
name|int
modifier|*
name|name
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|u_int
name|namelen
decl_stmt|;
name|uint32_t
name|fmode
decl_stmt|,
name|ifindex
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|name
operator|=
operator|(
name|int
operator|*
operator|)
name|arg1
expr_stmt|;
name|namelen
operator|=
name|arg2
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* int: ifindex + 4 * 32 bits of IPv6 address */
if|if
condition|(
name|namelen
operator|!=
literal|5
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ifindex
operator|=
name|name
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ifindex
operator|<=
literal|0
operator|||
name|ifindex
operator|>
name|V_if_index
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: ifindex %u out of range"
argument_list|,
name|__func__
argument_list|,
name|ifindex
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|mcaddr
argument_list|,
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|mcaddr
argument_list|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: group %s is not multicast"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|mcaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: no ifp for ifindex %u"
argument_list|,
name|__func__
argument_list|,
name|ifindex
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 	 * Internal MLD lookups require that scope/zone ID is set. 	 */
operator|(
name|void
operator|)
name|in6_setscope
argument_list|(
operator|&
name|mcaddr
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|retval
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
operator|(
name|in6_mcast_maxgrpsrc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|IN6_MULTI_LOCK
argument_list|()
expr_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
operator|||
name|ifma
operator|->
name|ifma_protospec
operator|==
name|NULL
condition|)
continue|continue;
name|inm
operator|=
operator|(
expr|struct
name|in6_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|,
operator|&
name|mcaddr
argument_list|)
condition|)
continue|continue;
name|fmode
operator|=
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
expr_stmt|;
name|retval
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|fmode
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|RB_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|&inm->in6m_srcs
argument_list|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: visit node %p"
argument_list|,
name|__func__
argument_list|,
name|ims
argument_list|)
expr_stmt|;
comment|/* 			 * Only copy-out sources which are in-mode. 			 */
if|if
condition|(
name|fmode
operator|!=
name|im6s_get_mode
argument_list|(
name|inm
argument_list|,
name|ims
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: skip non-in-mode"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|src
operator|=
name|ims
operator|->
name|im6s_addr
expr_stmt|;
name|retval
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IN6_MULTI_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|in6m_modestrs
index|[]
init|=
block|{
literal|"un"
block|,
literal|"in"
block|,
literal|"ex"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|in6m_mode_str
parameter_list|(
specifier|const
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|>=
name|MCAST_UNDEFINED
operator|&&
name|mode
operator|<=
name|MCAST_EXCLUDE
condition|)
return|return
operator|(
name|in6m_modestrs
index|[
name|mode
index|]
operator|)
return|;
return|return
operator|(
literal|"??"
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|in6m_statestrs
index|[]
init|=
block|{
literal|"not-member"
block|,
literal|"silent"
block|,
literal|"idle"
block|,
literal|"lazy"
block|,
literal|"sleeping"
block|,
literal|"awakening"
block|,
literal|"query-pending"
block|,
literal|"sg-query-pending"
block|,
literal|"leaving"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|in6m_state_str
parameter_list|(
specifier|const
name|int
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|>=
name|MLD_NOT_MEMBER
operator|&&
name|state
operator|<=
name|MLD_LEAVING_MEMBER
condition|)
return|return
operator|(
name|in6m_statestrs
index|[
name|state
index|]
operator|)
return|;
return|return
operator|(
literal|"??"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump an in6_multi structure to the console.  */
end_comment

begin_function
name|void
name|in6m_print
parameter_list|(
specifier|const
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ktr_mask
operator|&
name|KTR_MLD
operator|)
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"%s: --- begin in6m %p ---\n"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"addr %s ifp %p(%s) ifma %p\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|in6m_ifp
argument_list|,
name|inm
operator|->
name|in6m_ifp
operator|->
name|if_xname
argument_list|,
name|inm
operator|->
name|in6m_ifma
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"timer %u state %s refcount %u scq.len %u\n"
argument_list|,
name|inm
operator|->
name|in6m_timer
argument_list|,
name|in6m_state_str
argument_list|(
name|inm
operator|->
name|in6m_state
argument_list|)
argument_list|,
name|inm
operator|->
name|in6m_refcount
argument_list|,
name|inm
operator|->
name|in6m_scq
operator|.
name|ifq_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mli %p nsrc %lu sctimer %u scrv %u\n"
argument_list|,
name|inm
operator|->
name|in6m_mli
argument_list|,
name|inm
operator|->
name|in6m_nsrc
argument_list|,
name|inm
operator|->
name|in6m_sctimer
argument_list|,
name|inm
operator|->
name|in6m_scrv
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
literal|2
condition|;
name|t
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"t%d: fmode %s asm %u ex %u in %u rec %u\n"
argument_list|,
name|t
argument_list|,
name|in6m_mode_str
argument_list|(
name|inm
operator|->
name|in6m_st
index|[
name|t
index|]
operator|.
name|iss_fmode
argument_list|)
argument_list|,
name|inm
operator|->
name|in6m_st
index|[
name|t
index|]
operator|.
name|iss_asm
argument_list|,
name|inm
operator|->
name|in6m_st
index|[
name|t
index|]
operator|.
name|iss_ex
argument_list|,
name|inm
operator|->
name|in6m_st
index|[
name|t
index|]
operator|.
name|iss_in
argument_list|,
name|inm
operator|->
name|in6m_st
index|[
name|t
index|]
operator|.
name|iss_rec
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: --- end in6m %p ---\n"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !KTR */
end_comment

begin_function
name|void
name|in6m_print
parameter_list|(
specifier|const
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|)
block|{  }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KTR */
end_comment

end_unit

