begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Bruce Simpson.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$KAME: mld6.c,v 1.27 2001/04/04 05:17:30 itojun Exp $  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1988 Stephen Deering.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Stephen Deering of Stanford University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)igmp.c	8.1 (Berkeley) 7/19/93  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/scope6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/mld6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/mld6_var.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|KTR_MLD
end_ifndef

begin_define
define|#
directive|define
name|KTR_MLD
value|KTR_INET6
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|mld_ifinfo
modifier|*
name|mli_alloc_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mli_delete_locked
parameter_list|(
specifier|const
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mld_dispatch_packet
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mld_dispatch_queue
parameter_list|(
name|struct
name|ifqueue
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mld_final_leave
parameter_list|(
name|struct
name|in6_multi
modifier|*
parameter_list|,
name|struct
name|mld_ifinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mld_fasttimo_vnet
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mld_handle_state_change
parameter_list|(
name|struct
name|in6_multi
modifier|*
parameter_list|,
name|struct
name|mld_ifinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mld_initial_join
parameter_list|(
name|struct
name|in6_multi
modifier|*
parameter_list|,
name|struct
name|mld_ifinfo
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_function_decl
specifier|static
name|char
modifier|*
name|mld_rec_type_to_str
parameter_list|(
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|mld_set_version
parameter_list|(
name|struct
name|mld_ifinfo
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mld_slowtimo_vnet
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mld_v1_input_query
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
specifier|const
name|struct
name|ip6_hdr
modifier|*
parameter_list|,
comment|/*const*/
name|struct
name|mld_hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mld_v1_input_report
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
specifier|const
name|struct
name|ip6_hdr
modifier|*
parameter_list|,
comment|/*const*/
name|struct
name|mld_hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mld_v1_process_group_timer
parameter_list|(
name|struct
name|mld_ifinfo
modifier|*
parameter_list|,
name|struct
name|in6_multi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mld_v1_process_querier_timers
parameter_list|(
name|struct
name|mld_ifinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mld_v1_transmit_report
parameter_list|(
name|struct
name|in6_multi
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mld_v1_update_group
parameter_list|(
name|struct
name|in6_multi
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mld_v2_cancel_link_timers
parameter_list|(
name|struct
name|mld_ifinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mld_v2_dispatch_general_query
parameter_list|(
name|struct
name|mld_ifinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|mld_v2_encap_report
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mld_v2_enqueue_filter_change
parameter_list|(
name|struct
name|ifqueue
modifier|*
parameter_list|,
name|struct
name|in6_multi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mld_v2_enqueue_group_record
parameter_list|(
name|struct
name|ifqueue
modifier|*
parameter_list|,
name|struct
name|in6_multi
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|,
specifier|const
name|int
parameter_list|,
specifier|const
name|int
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mld_v2_input_query
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
specifier|const
name|struct
name|ip6_hdr
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mld_v2_merge_state_changes
parameter_list|(
name|struct
name|in6_multi
modifier|*
parameter_list|,
name|struct
name|ifqueue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mld_v2_process_group_timers
parameter_list|(
name|struct
name|mld_ifinfo
modifier|*
parameter_list|,
name|struct
name|ifqueue
modifier|*
parameter_list|,
name|struct
name|ifqueue
modifier|*
parameter_list|,
name|struct
name|in6_multi
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mld_v2_process_group_query
parameter_list|(
name|struct
name|in6_multi
modifier|*
parameter_list|,
name|struct
name|mld_ifinfo
modifier|*
name|mli
parameter_list|,
name|int
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_mld_gsr
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_mld_ifinfo
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Normative references: RFC 2710, RFC 3590, RFC 3810.  *  * Locking:  *  * The MLD subsystem lock ends up being system-wide for the moment,  *    but could be per-VIMAGE later on.  *  * The permitted lock order is: IN6_MULTI_LOCK, MLD_LOCK, IF_ADDR_LOCK.  *    Any may be taken independently; if any are held at the same  *    time, the above lock order must be followed.  *  * IN6_MULTI_LOCK covers in_multi.  *  * MLD_LOCK covers per-link state and any global variables in this file.  *  * IF_ADDR_LOCK covers if_multiaddrs, which is used for a variety of  *    per-link state iterators.  *  *  XXX LOR PREVENTION  *  A special case for IPv6 is the in6_setscope() routine. ip6_output()  *  will not accept an ifp; it wants an embedded scope ID, unlike  *  ip_output(), which happily takes the ifp given to it. The embedded  *  scope ID is only used by MLD to select the outgoing interface.  *  *  During interface attach and detach, MLD will take MLD_LOCK *after*  *  the IF_AFDATA_LOCK.  *  As in6_setscope() takes IF_AFDATA_LOCK then SCOPE_LOCK, we can't call  *  it with MLD_LOCK held without triggering an LOR. A netisr with indirect  *  dispatch could work around this, but we'd rather not do that, as it  *  can introduce other races.  *  *  As such, we exploit the fact that the scope ID is just the interface  *  index, and embed it in the IPv6 destination address accordingly.  *  This is potentially NOT VALID for MLDv1 reports, as they  *  are always sent to the multicast group itself; as MLDv2  *  reports are always sent to ff02::16, this is not an issue  *  when MLDv2 is in use.  *  *  This does not however eliminate the LOR when ip6_output() itself  *  calls in6_setscope() internally whilst MLD_LOCK is held. This will  *  trigger a LOR warning in WITNESS when the ifnet is detached.  *  *  The right answer is probably to make IF_AFDATA_LOCK an rwlock, given  *  how it's used across the network stack. Here we're simply exploiting  *  the fact that MLD runs at a similar layer in the stack to scope6.c.  *  * VIMAGE:  *  * Each in6_multi corresponds to an ifp, and each ifp corresponds  *    to a vnet in ifp->if_vnet.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|mld_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MLD
argument_list|,
literal|"mld"
argument_list|,
literal|"mld state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MLD_EMBEDSCOPE
parameter_list|(
name|pin6
parameter_list|,
name|zoneid
parameter_list|)
define|\
value|if (IN6_IS_SCOPE_LINKLOCAL(pin6) ||				\ 	    IN6_IS_ADDR_MC_INTFACELOCAL(pin6))				\ 		(pin6)->s6_addr16[1] = htons((zoneid)& 0xFFFF)
end_define

begin_comment
unit|\
comment|/*  * VIMAGE-wide globals.  */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|timeval
argument_list|,
name|mld_gsrdelay
argument_list|)
operator|=
block|{
literal|10
block|,
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|LIST_HEAD
argument_list|(,
name|mld_ifinfo
argument_list|)
argument_list|,
name|mli_head
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|interface_timers_running6
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|state_change_timers_running6
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|current_state_timers_running6
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_mld_gsrdelay
value|VNET(mld_gsrdelay)
end_define

begin_define
define|#
directive|define
name|V_mli_head
value|VNET(mli_head)
end_define

begin_define
define|#
directive|define
name|V_interface_timers_running6
value|VNET(interface_timers_running6)
end_define

begin_define
define|#
directive|define
name|V_state_change_timers_running6
value|VNET(state_change_timers_running6)
end_define

begin_define
define|#
directive|define
name|V_current_state_timers_running6
value|VNET(current_state_timers_running6)
end_define

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet6
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Note: Not in any common header. */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet6
argument_list|,
name|OID_AUTO
argument_list|,
name|mld
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"IPv6 Multicast Listener Discovery"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Virtualized sysctls.  */
end_comment

begin_expr_stmt
name|SYSCTL_VNET_PROC
argument_list|(
name|_net_inet6_mld
argument_list|,
name|OID_AUTO
argument_list|,
name|gsrdelay
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|mld_gsrdelay
operator|.
name|tv_sec
argument_list|)
argument_list|,
literal|0
argument_list|,
name|sysctl_mld_gsr
argument_list|,
literal|"I"
argument_list|,
literal|"Rate limit for MLDv2 Group-and-Source queries in seconds"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Non-virtualized sysctls.  */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_inet6_mld
argument_list|,
name|OID_AUTO
argument_list|,
name|ifinfo
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sysctl_mld_ifinfo
argument_list|,
literal|"Per-interface MLDv2 state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mld_v1enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet6_mld
argument_list|,
name|OID_AUTO
argument_list|,
name|v1enable
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mld_v1enable
argument_list|,
literal|0
argument_list|,
literal|"Enable fallback to MLDv1"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"net.inet6.mld.v1enable"
argument_list|,
operator|&
name|mld_v1enable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mld_use_allow
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet6_mld
argument_list|,
name|OID_AUTO
argument_list|,
name|use_allow
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mld_use_allow
argument_list|,
literal|0
argument_list|,
literal|"Use ALLOW/BLOCK for RFC 4604 SSM joins/leaves"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"net.inet6.mld.use_allow"
argument_list|,
operator|&
name|mld_use_allow
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Packed Router Alert option structure declaration.  */
end_comment

begin_struct
struct|struct
name|mld_raopt
block|{
name|struct
name|ip6_hbh
name|hbh
decl_stmt|;
name|struct
name|ip6_opt
name|pad
decl_stmt|;
name|struct
name|ip6_opt_router
name|ra
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_comment
comment|/*  * Router Alert hop-by-hop option header.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mld_raopt
name|mld_ra
init|=
block|{
operator|.
name|hbh
operator|=
block|{
literal|0
block|,
literal|0
block|}
block|,
operator|.
name|pad
operator|=
block|{
operator|.
name|ip6o_type
operator|=
name|IP6OPT_PADN
block|,
literal|0
block|}
block|,
operator|.
name|ra
operator|=
block|{
operator|.
name|ip6or_type
operator|=
name|IP6OPT_ROUTER_ALERT
block|,
operator|.
name|ip6or_len
operator|=
name|IP6OPT_RTALERT_LEN
operator|-
literal|2
block|,
operator|.
name|ip6or_value
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|IP6OPT_RTALERT_MLD
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
operator|)
block|,
operator|.
name|ip6or_value
index|[
literal|1
index|]
operator|=
operator|(
name|IP6OPT_RTALERT_MLD
operator|&
literal|0xFF
operator|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ip6_pktopts
name|mld_po
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
name|void
name|mld_save_context
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|VIMAGE
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_loc
operator|.
name|ptr
operator|=
name|ifp
operator|->
name|if_vnet
expr_stmt|;
endif|#
directive|endif
comment|/* VIMAGE */
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|mld_scrub_context
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_loc
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore context from a queued output chain.  * Return saved ifindex.  *  * VIMAGE: The assertion is there to make sure that we  * actually called CURVNET_SET() with what's in the mbuf chain.  */
end_comment

begin_function
specifier|static
name|__inline
name|uint32_t
name|mld_restore_context
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|VIMAGE
argument_list|)
operator|&&
name|defined
argument_list|(
name|INVARIANTS
argument_list|)
name|KASSERT
argument_list|(
name|curvnet
operator|==
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_loc
operator|.
name|ptr
argument_list|,
operator|(
literal|"%s: called when curvnet was not restored"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve or set threshold between group-source queries in seconds.  *  * VIMAGE: Assume curvnet set by caller.  * SMPng: NOTE: Serialized by MLD lock.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_mld_gsr
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|MLD_LOCK
argument_list|()
expr_stmt|;
name|i
operator|=
name|V_mld_gsrdelay
operator|.
name|tv_sec
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
goto|goto
name|out_locked
goto|;
if|if
condition|(
name|i
operator|<
operator|-
literal|1
operator|||
name|i
operator|>=
literal|60
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"change mld_gsrdelay from %d to %d"
argument_list|,
name|V_mld_gsrdelay
operator|.
name|tv_sec
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|V_mld_gsrdelay
operator|.
name|tv_sec
operator|=
name|i
expr_stmt|;
name|out_locked
label|:
name|MLD_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Expose struct mld_ifinfo to userland, keyed by ifindex.  * For use by ifmcstat(8).  *  * SMPng: NOTE: Does an unlocked ifindex space read.  * VIMAGE: Assume curvnet set by caller. The node handler itself  * is not directly virtualized.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_mld_ifinfo
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
modifier|*
name|name
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|namelen
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mld_ifinfo
modifier|*
name|mli
decl_stmt|;
name|name
operator|=
operator|(
name|int
operator|*
operator|)
name|arg1
expr_stmt|;
name|namelen
operator|=
name|arg2
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|namelen
operator|!=
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mld_ifinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|IN6_MULTI_LOCK
argument_list|()
expr_stmt|;
name|MLD_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|<=
literal|0
operator|||
name|name
index|[
literal|0
index|]
operator|>
name|V_if_index
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|error
operator|=
name|ENOENT
expr_stmt|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
goto|goto
name|out_locked
goto|;
name|LIST_FOREACH
argument_list|(
argument|mli
argument_list|,
argument|&V_mli_head
argument_list|,
argument|mli_link
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|==
name|mli
operator|->
name|mli_ifp
condition|)
block|{
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|mli
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mld_ifinfo
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|out_locked
label|:
name|MLD_UNLOCK
argument_list|()
expr_stmt|;
name|IN6_MULTI_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dispatch an entire queue of pending packet chains.  * VIMAGE: Assumes the vnet pointer has been set.  */
end_comment

begin_function
specifier|static
name|void
name|mld_dispatch_queue
parameter_list|(
name|struct
name|ifqueue
modifier|*
name|ifq
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|_IF_DEQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: dispatch %p from %p"
argument_list|,
name|__func__
argument_list|,
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mld_dispatch_packet
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|limit
operator|==
literal|0
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Filter outgoing MLD report state by group.  *  * Reports are ALWAYS suppressed for ALL-HOSTS (ff02::1)  * and node-local addresses. However, kernel and socket consumers  * always embed the KAME scope ID in the address provided, so strip it  * when performing comparison.  * Note: This is not the same as the *multicast* scope.  *  * Return zero if the given group is one for which MLD reports  * should be suppressed, or non-zero if reports should be issued.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|mld_is_addr_reported
parameter_list|(
specifier|const
name|struct
name|in6_addr
modifier|*
name|addr
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
name|addr
argument_list|)
argument_list|,
operator|(
literal|"%s: not multicast"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IPV6_ADDR_MC_SCOPE
argument_list|(
name|addr
argument_list|)
operator|==
name|IPV6_ADDR_SCOPE_NODELOCAL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|IPV6_ADDR_MC_SCOPE
argument_list|(
name|addr
argument_list|)
operator|==
name|IPV6_ADDR_SCOPE_LINKLOCAL
condition|)
block|{
name|struct
name|in6_addr
name|tmp
init|=
operator|*
name|addr
decl_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|in6addr_linklocal_allnodes
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach MLD when PF_INET6 is attached to an interface.  *  * SMPng: Normally called with IF_AFDATA_LOCK held.  */
end_comment

begin_function
name|struct
name|mld_ifinfo
modifier|*
name|mld_domifattach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mld_ifinfo
modifier|*
name|mli
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: called for ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|MLD_LOCK
argument_list|()
expr_stmt|;
name|mli
operator|=
name|mli_alloc_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
condition|)
name|mli
operator|->
name|mli_flags
operator||=
name|MLIF_SILENT
expr_stmt|;
if|if
condition|(
name|mld_use_allow
condition|)
name|mli
operator|->
name|mli_flags
operator||=
name|MLIF_USEALLOW
expr_stmt|;
name|MLD_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|mli
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * VIMAGE: assume curvnet set by caller.  */
end_comment

begin_function
specifier|static
name|struct
name|mld_ifinfo
modifier|*
name|mli_alloc_locked
parameter_list|(
comment|/*const*/
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mld_ifinfo
modifier|*
name|mli
decl_stmt|;
name|MLD_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|mli
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mld_ifinfo
argument_list|)
argument_list|,
name|M_MLD
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mli
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|mli
operator|->
name|mli_ifp
operator|=
name|ifp
expr_stmt|;
name|mli
operator|->
name|mli_version
operator|=
name|MLD_VERSION_2
expr_stmt|;
name|mli
operator|->
name|mli_flags
operator|=
literal|0
expr_stmt|;
name|mli
operator|->
name|mli_rv
operator|=
name|MLD_RV_INIT
expr_stmt|;
name|mli
operator|->
name|mli_qi
operator|=
name|MLD_QI_INIT
expr_stmt|;
name|mli
operator|->
name|mli_qri
operator|=
name|MLD_QRI_INIT
expr_stmt|;
name|mli
operator|->
name|mli_uri
operator|=
name|MLD_URI_INIT
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|mli
operator|->
name|mli_relinmhead
argument_list|)
expr_stmt|;
comment|/* 	 * Responses to general queries are subject to bounds. 	 */
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|mli
operator|->
name|mli_gq
argument_list|,
name|MLD_MAX_RESPONSE_PACKETS
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|V_mli_head
argument_list|,
name|mli
argument_list|,
name|mli_link
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"allocate mld_ifinfo for ifp %p(%s)"
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|mli
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook for ifdetach.  *  * NOTE: Some finalization tasks need to run before the protocol domain  * is detached, but also before the link layer does its cleanup.  * Run before link-layer cleanup; cleanup groups, but do not free MLD state.  *  * SMPng: Caller must hold IN6_MULTI_LOCK().  * Must take IF_ADDR_LOCK() to cover if_multiaddrs iterator.  * XXX This routine is also bitten by unlocked ifma_protospec access.  */
end_comment

begin_function
name|void
name|mld_ifdetach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mld_ifinfo
modifier|*
name|mli
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|inm
decl_stmt|,
modifier|*
name|tinm
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: called for ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|MLD_LOCK
argument_list|()
expr_stmt|;
name|mli
operator|=
name|MLD_IFINFO
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mli
operator|->
name|mli_version
operator|==
name|MLD_VERSION_2
condition|)
block|{
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
operator|||
name|ifma
operator|->
name|ifma_protospec
operator|==
name|NULL
condition|)
continue|continue;
name|inm
operator|=
operator|(
expr|struct
name|in6_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|in6m_state
operator|==
name|MLD_LEAVING_MEMBER
condition|)
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|mli
operator|->
name|mli_relinmhead
argument_list|,
name|inm
argument_list|,
name|in6m_nrele
argument_list|)
expr_stmt|;
block|}
name|in6m_clear_recorded
argument_list|(
name|inm
argument_list|)
expr_stmt|;
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|SLIST_FOREACH_SAFE
argument_list|(
argument|inm
argument_list|,
argument|&mli->mli_relinmhead
argument_list|,
argument|in6m_nrele
argument_list|,
argument|tinm
argument_list|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|mli
operator|->
name|mli_relinmhead
argument_list|,
name|in6m_nrele
argument_list|)
expr_stmt|;
name|in6m_release_locked
argument_list|(
name|inm
argument_list|)
expr_stmt|;
block|}
block|}
name|MLD_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hook for domifdetach.  * Runs after link-layer cleanup; free MLD state.  *  * SMPng: Normally called with IF_AFDATA_LOCK held.  */
end_comment

begin_function
name|void
name|mld_domifdetach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: called for ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|MLD_LOCK
argument_list|()
expr_stmt|;
name|mli_delete_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|MLD_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mli_delete_locked
parameter_list|(
specifier|const
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mld_ifinfo
modifier|*
name|mli
decl_stmt|,
modifier|*
name|tmli
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: freeing mld_ifinfo for ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|MLD_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|mli
argument_list|,
argument|&V_mli_head
argument_list|,
argument|mli_link
argument_list|,
argument|tmli
argument_list|)
block|{
if|if
condition|(
name|mli
operator|->
name|mli_ifp
operator|==
name|ifp
condition|)
block|{
comment|/* 			 * Free deferred General Query responses. 			 */
name|_IF_DRAIN
argument_list|(
operator|&
name|mli
operator|->
name|mli_gq
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|mli
argument_list|,
name|mli_link
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|mli
operator|->
name|mli_relinmhead
argument_list|)
argument_list|,
operator|(
literal|"%s: there are dangling in_multi references"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mli
argument_list|,
name|M_MLD
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"%s: mld_ifinfo not found for ifp %p\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Process a received MLDv1 general or address-specific query.  * Assumes that the query header has been pulled up to sizeof(mld_hdr).  *  * NOTE: Can't be fully const correct as we temporarily embed scope ID in  * mld_addr. This is OK as we own the mbuf chain.  */
end_comment

begin_function
specifier|static
name|int
name|mld_v1_input_query
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|ip6_hdr
modifier|*
name|ip6
parameter_list|,
comment|/*const*/
name|struct
name|mld_hdr
modifier|*
name|mld
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|mld_ifinfo
modifier|*
name|mli
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|inm
decl_stmt|;
name|int
name|is_general_query
decl_stmt|;
name|uint16_t
name|timer
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|is_general_query
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mld_v1enable
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"ignore v1 query %s on ifp %p(%s)"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * RFC3810 Section 6.2: MLD queries must originate from 	 * a router's link-local address. 	 */
if|if
condition|(
operator|!
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"ignore v1 query src %s on ifp %p(%s)"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Do address field validation upfront before we accept 	 * the query. 	 */
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
condition|)
block|{
comment|/* 		 * MLDv1 General Query. 		 * If this was not sent to the all-nodes group, ignore it. 		 */
name|struct
name|in6_addr
name|dst
decl_stmt|;
name|dst
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|in6addr_linklocal_allnodes
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|is_general_query
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Embed scope ID of receiving interface in MLD query for 		 * lookup whilst we don't hold other locks. 		 */
name|in6_setscope
argument_list|(
operator|&
name|mld
operator|->
name|mld_addr
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|IN6_MULTI_LOCK
argument_list|()
expr_stmt|;
name|MLD_LOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Switch to MLDv1 host compatibility mode. 	 */
name|mli
operator|=
name|MLD_IFINFO
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mli
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no mld_ifinfo for ifp %p"
operator|,
name|__func__
operator|,
name|ifp
operator|)
argument_list|)
expr_stmt|;
name|mld_set_version
argument_list|(
name|mli
argument_list|,
name|MLD_VERSION_1
argument_list|)
expr_stmt|;
name|timer
operator|=
operator|(
name|ntohs
argument_list|(
name|mld
operator|->
name|mld_maxdelay
argument_list|)
operator|*
name|PR_FASTHZ
operator|)
operator|/
name|MLD_TIMER_SCALE
expr_stmt|;
if|if
condition|(
name|timer
operator|==
literal|0
condition|)
name|timer
operator|=
literal|1
expr_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_general_query
condition|)
block|{
comment|/* 		 * For each reporting group joined on this 		 * interface, kick the report timer. 		 */
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"process v1 general query on ifp %p(%s)"
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
operator|||
name|ifma
operator|->
name|ifma_protospec
operator|==
name|NULL
condition|)
continue|continue;
name|inm
operator|=
operator|(
expr|struct
name|in6_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
name|mld_v1_update_group
argument_list|(
name|inm
argument_list|,
name|timer
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * MLDv1 Group-Specific Query. 		 * If this is a group-specific MLDv1 query, we need only 		 * look up the single group to process it. 		 */
name|inm
operator|=
name|in6m_lookup_locked
argument_list|(
name|ifp
argument_list|,
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|!=
name|NULL
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"process v1 query %s on ifp %p(%s)"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|mld_v1_update_group
argument_list|(
name|inm
argument_list|,
name|timer
argument_list|)
expr_stmt|;
block|}
comment|/* XXX Clear embedded scope ID as userland won't expect it. */
name|in6_clearscope
argument_list|(
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
expr_stmt|;
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|MLD_UNLOCK
argument_list|()
expr_stmt|;
name|IN6_MULTI_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update the report timer on a group in response to an MLDv1 query.  *  * If we are becoming the reporting member for this group, start the timer.  * If we already are the reporting member for this group, and timer is  * below the threshold, reset it.  *  * We may be updating the group for the first time since we switched  * to MLDv2. If we are, then we must clear any recorded source lists,  * and transition to REPORTING state; the group timer is overloaded  * for group and group-source query responses.   *  * Unlike MLDv2, the delay per group should be jittered  * to avoid bursts of MLDv1 reports.  */
end_comment

begin_function
specifier|static
name|void
name|mld_v1_update_group
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|,
specifier|const
name|int
name|timer
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|CTR4
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: %s/%s timer=%d"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
argument_list|,
name|if_name
argument_list|(
name|inm
operator|->
name|in6m_ifp
argument_list|)
argument_list|,
name|timer
argument_list|)
expr_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|inm
operator|->
name|in6m_state
condition|)
block|{
case|case
name|MLD_NOT_MEMBER
case|:
case|case
name|MLD_SILENT_MEMBER
case|:
break|break;
case|case
name|MLD_REPORTING_MEMBER
case|:
if|if
condition|(
name|inm
operator|->
name|in6m_timer
operator|!=
literal|0
operator|&&
name|inm
operator|->
name|in6m_timer
operator|<=
name|timer
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: REPORTING and timer running, "
literal|"skipping."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|MLD_SG_QUERY_PENDING_MEMBER
case|:
case|case
name|MLD_G_QUERY_PENDING_MEMBER
case|:
case|case
name|MLD_IDLE_MEMBER
case|:
case|case
name|MLD_LAZY_MEMBER
case|:
case|case
name|MLD_AWAKENING_MEMBER
case|:
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: ->REPORTING"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_REPORTING_MEMBER
expr_stmt|;
name|inm
operator|->
name|in6m_timer
operator|=
name|MLD_RANDOM_DELAY
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|V_current_state_timers_running6
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MLD_SLEEPING_MEMBER
case|:
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: ->AWAKENING"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_AWAKENING_MEMBER
expr_stmt|;
break|break;
case|case
name|MLD_LEAVING_MEMBER
case|:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Process a received MLDv2 general, group-specific or  * group-and-source-specific query.  *  * Assumes that the query header has been pulled up to sizeof(mldv2_query).  *  * Return 0 if successful, otherwise an appropriate error code is returned.  */
end_comment

begin_function
specifier|static
name|int
name|mld_v2_input_query
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|ip6_hdr
modifier|*
name|ip6
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|int
name|off
parameter_list|,
specifier|const
name|int
name|icmp6len
parameter_list|)
block|{
name|struct
name|mld_ifinfo
modifier|*
name|mli
decl_stmt|;
name|struct
name|mldv2_query
modifier|*
name|mld
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|inm
decl_stmt|;
name|uint32_t
name|maxdelay
decl_stmt|,
name|nsrc
decl_stmt|,
name|qqi
decl_stmt|;
name|int
name|is_general_query
decl_stmt|;
name|uint16_t
name|timer
decl_stmt|;
name|uint8_t
name|qrv
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|is_general_query
operator|=
literal|0
expr_stmt|;
comment|/* 	 * RFC3810 Section 6.2: MLD queries must originate from 	 * a router's link-local address. 	 */
if|if
condition|(
operator|!
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"ignore v1 query src %s on ifp %p(%s)"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"input v2 query on ifp %p(%s)"
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|mld
operator|=
operator|(
expr|struct
name|mldv2_query
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|maxdelay
operator|=
name|ntohs
argument_list|(
name|mld
operator|->
name|mld_maxdelay
argument_list|)
expr_stmt|;
comment|/* in 1/10ths of a second */
if|if
condition|(
name|maxdelay
operator|>=
literal|32768
condition|)
block|{
name|maxdelay
operator|=
operator|(
name|MLD_MRC_MANT
argument_list|(
name|maxdelay
argument_list|)
operator||
literal|0x1000
operator|)
operator|<<
operator|(
name|MLD_MRC_EXP
argument_list|(
name|maxdelay
argument_list|)
operator|+
literal|3
operator|)
expr_stmt|;
block|}
name|timer
operator|=
operator|(
name|maxdelay
operator|*
name|PR_FASTHZ
operator|)
operator|/
name|MLD_TIMER_SCALE
expr_stmt|;
if|if
condition|(
name|timer
operator|==
literal|0
condition|)
name|timer
operator|=
literal|1
expr_stmt|;
name|qrv
operator|=
name|MLD_QRV
argument_list|(
name|mld
operator|->
name|mld_misc
argument_list|)
expr_stmt|;
if|if
condition|(
name|qrv
operator|<
literal|2
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: clamping qrv %d to %d"
argument_list|,
name|__func__
argument_list|,
name|qrv
argument_list|,
name|MLD_RV_INIT
argument_list|)
expr_stmt|;
name|qrv
operator|=
name|MLD_RV_INIT
expr_stmt|;
block|}
name|qqi
operator|=
name|mld
operator|->
name|mld_qqi
expr_stmt|;
if|if
condition|(
name|qqi
operator|>=
literal|128
condition|)
block|{
name|qqi
operator|=
name|MLD_QQIC_MANT
argument_list|(
name|mld
operator|->
name|mld_qqi
argument_list|)
operator|<<
operator|(
name|MLD_QQIC_EXP
argument_list|(
name|mld
operator|->
name|mld_qqi
argument_list|)
operator|+
literal|3
operator|)
expr_stmt|;
block|}
name|nsrc
operator|=
name|ntohs
argument_list|(
name|mld
operator|->
name|mld_numsrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsrc
operator|>
name|MLD_MAX_GS_SOURCES
condition|)
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
if|if
condition|(
name|icmp6len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_query
argument_list|)
operator|+
operator|(
name|nsrc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
comment|/* 	 * Do further input validation upfront to avoid resetting timers 	 * should we need to discard this query. 	 */
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
condition|)
block|{
comment|/* 		 * A general query with a source list has undefined 		 * behaviour; discard it. 		 */
if|if
condition|(
name|nsrc
operator|>
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|is_general_query
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Embed scope ID of receiving interface in MLD query for 		 * lookup whilst we don't hold other locks (due to KAME 		 * locking lameness). We own this mbuf chain just now. 		 */
name|in6_setscope
argument_list|(
operator|&
name|mld
operator|->
name|mld_addr
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|IN6_MULTI_LOCK
argument_list|()
expr_stmt|;
name|MLD_LOCK
argument_list|()
expr_stmt|;
name|mli
operator|=
name|MLD_IFINFO
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mli
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no mld_ifinfo for ifp %p"
operator|,
name|__func__
operator|,
name|ifp
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Discard the v2 query if we're in Compatibility Mode. 	 * The RFC is pretty clear that hosts need to stay in MLDv1 mode 	 * until the Old Version Querier Present timer expires. 	 */
if|if
condition|(
name|mli
operator|->
name|mli_version
operator|!=
name|MLD_VERSION_2
condition|)
goto|goto
name|out_locked
goto|;
name|mld_set_version
argument_list|(
name|mli
argument_list|,
name|MLD_VERSION_2
argument_list|)
expr_stmt|;
name|mli
operator|->
name|mli_rv
operator|=
name|qrv
expr_stmt|;
name|mli
operator|->
name|mli_qi
operator|=
name|qqi
expr_stmt|;
name|mli
operator|->
name|mli_qri
operator|=
name|maxdelay
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: qrv %d qi %d maxdelay %d"
argument_list|,
name|__func__
argument_list|,
name|qrv
argument_list|,
name|qqi
argument_list|,
name|maxdelay
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_general_query
condition|)
block|{
comment|/* 		 * MLDv2 General Query. 		 * 		 * Schedule a current-state report on this ifp for 		 * all groups, possibly containing source lists. 		 * 		 * If there is a pending General Query response 		 * scheduled earlier than the selected delay, do 		 * not schedule any other reports. 		 * Otherwise, reset the interface timer. 		 */
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"process v2 general query on ifp %p(%s)"
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mli
operator|->
name|mli_v2_timer
operator|==
literal|0
operator|||
name|mli
operator|->
name|mli_v2_timer
operator|>=
name|timer
condition|)
block|{
name|mli
operator|->
name|mli_v2_timer
operator|=
name|MLD_RANDOM_DELAY
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|V_interface_timers_running6
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * MLDv2 Group-specific or Group-and-source-specific Query. 		 * 		 * Group-source-specific queries are throttled on 		 * a per-group basis to defeat denial-of-service attempts. 		 * Queries for groups we are not a member of on this 		 * link are simply ignored. 		 */
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|inm
operator|=
name|in6m_lookup_locked
argument_list|(
name|ifp
argument_list|,
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|==
name|NULL
condition|)
block|{
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
if|if
condition|(
name|nsrc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ratecheck
argument_list|(
operator|&
name|inm
operator|->
name|in6m_lastgsrtv
argument_list|,
operator|&
name|V_mld_gsrdelay
argument_list|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: GS query throttled."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
block|}
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"process v2 group query on ifp %p(%s)"
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If there is a pending General Query response 		 * scheduled sooner than the selected delay, no 		 * further report need be scheduled. 		 * Otherwise, prepare to respond to the 		 * group-specific or group-and-source query. 		 */
if|if
condition|(
name|mli
operator|->
name|mli_v2_timer
operator|==
literal|0
operator|||
name|mli
operator|->
name|mli_v2_timer
operator|>=
name|timer
condition|)
name|mld_v2_process_group_query
argument_list|(
name|inm
argument_list|,
name|mli
argument_list|,
name|timer
argument_list|,
name|m
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* XXX Clear embedded scope ID as userland won't expect it. */
name|in6_clearscope
argument_list|(
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
expr_stmt|;
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|out_locked
label|:
name|MLD_UNLOCK
argument_list|()
expr_stmt|;
name|IN6_MULTI_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a recieved MLDv2 group-specific or group-and-source-specific  * query.  * Return<0 if any error occured. Currently this is ignored.  */
end_comment

begin_function
specifier|static
name|int
name|mld_v2_process_group_query
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|,
name|struct
name|mld_ifinfo
modifier|*
name|mli
parameter_list|,
name|int
name|timer
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
specifier|const
name|int
name|off
parameter_list|)
block|{
name|struct
name|mldv2_query
modifier|*
name|mld
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|uint16_t
name|nsrc
decl_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|MLD_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|mld
operator|=
operator|(
expr|struct
name|mldv2_query
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m0
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
switch|switch
condition|(
name|inm
operator|->
name|in6m_state
condition|)
block|{
case|case
name|MLD_NOT_MEMBER
case|:
case|case
name|MLD_SILENT_MEMBER
case|:
case|case
name|MLD_SLEEPING_MEMBER
case|:
case|case
name|MLD_LAZY_MEMBER
case|:
case|case
name|MLD_AWAKENING_MEMBER
case|:
case|case
name|MLD_IDLE_MEMBER
case|:
case|case
name|MLD_LEAVING_MEMBER
case|:
return|return
operator|(
name|retval
operator|)
return|;
break|break;
case|case
name|MLD_REPORTING_MEMBER
case|:
case|case
name|MLD_G_QUERY_PENDING_MEMBER
case|:
case|case
name|MLD_SG_QUERY_PENDING_MEMBER
case|:
break|break;
block|}
name|nsrc
operator|=
name|ntohs
argument_list|(
name|mld
operator|->
name|mld_numsrc
argument_list|)
expr_stmt|;
comment|/* 	 * Deal with group-specific queries upfront. 	 * If any group query is already pending, purge any recorded 	 * source-list state if it exists, and schedule a query response 	 * for this group-specific query. 	 */
if|if
condition|(
name|nsrc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|inm
operator|->
name|in6m_state
operator|==
name|MLD_G_QUERY_PENDING_MEMBER
operator|||
name|inm
operator|->
name|in6m_state
operator|==
name|MLD_SG_QUERY_PENDING_MEMBER
condition|)
block|{
name|in6m_clear_recorded
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|timer
operator|=
name|min
argument_list|(
name|inm
operator|->
name|in6m_timer
argument_list|,
name|timer
argument_list|)
expr_stmt|;
block|}
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_G_QUERY_PENDING_MEMBER
expr_stmt|;
name|inm
operator|->
name|in6m_timer
operator|=
name|MLD_RANDOM_DELAY
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|V_current_state_timers_running6
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * Deal with the case where a group-and-source-specific query has 	 * been received but a group-specific query is already pending. 	 */
if|if
condition|(
name|inm
operator|->
name|in6m_state
operator|==
name|MLD_G_QUERY_PENDING_MEMBER
condition|)
block|{
name|timer
operator|=
name|min
argument_list|(
name|inm
operator|->
name|in6m_timer
argument_list|,
name|timer
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_timer
operator|=
name|MLD_RANDOM_DELAY
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|V_current_state_timers_running6
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * Finally, deal with the case where a group-and-source-specific 	 * query has been received, where a response to a previous g-s-r 	 * query exists, or none exists. 	 * In this case, we need to parse the source-list which the Querier 	 * has provided us with and check if we have any source list filter 	 * entries at T1 for these sources. If we do not, there is no need 	 * schedule a report and the query may be dropped. 	 * If we do, we must record them and schedule a current-state 	 * report for those sources. 	 */
if|if
condition|(
name|inm
operator|->
name|in6m_nsrc
operator|>
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nrecorded
decl_stmt|;
name|int
name|soff
decl_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
name|soff
operator|=
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_query
argument_list|)
expr_stmt|;
name|nrecorded
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsrc
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|soff
expr_stmt|;
name|retval
operator|=
name|in6m_record_source
argument_list|(
name|inm
argument_list|,
operator|(
specifier|const
expr|struct
name|in6_addr
operator|*
operator|)
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
break|break;
name|nrecorded
operator|+=
name|retval
expr_stmt|;
name|soff
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|soff
operator|>=
name|m
operator|->
name|m_len
condition|)
block|{
name|soff
operator|=
name|soff
operator|-
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|nrecorded
operator|>
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: schedule response to SG query"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_SG_QUERY_PENDING_MEMBER
expr_stmt|;
name|inm
operator|->
name|in6m_timer
operator|=
name|MLD_RANDOM_DELAY
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|V_current_state_timers_running6
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a received MLDv1 host membership report.  * Assumes mld points to mld_hdr in pulled up mbuf chain.  *  * NOTE: Can't be fully const correct as we temporarily embed scope ID in  * mld_addr. This is OK as we own the mbuf chain.  */
end_comment

begin_function
specifier|static
name|int
name|mld_v1_input_report
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|ip6_hdr
modifier|*
name|ip6
parameter_list|,
comment|/*const*/
name|struct
name|mld_hdr
modifier|*
name|mld
parameter_list|)
block|{
name|struct
name|in6_addr
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|inm
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|mld_v1enable
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"ignore v1 report %s on ifp %p(%s)"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * MLDv1 reports must originate from a host's link-local address, 	 * or the unspecified address (when booting). 	 */
name|src
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|src
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|src
argument_list|)
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"ignore v1 query src %s on ifp %p(%s)"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * RFC2710 Section 4: MLDv1 reports must pertain to a multicast 	 * group, and must be directed to the group itself. 	 */
name|dst
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
operator|||
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|mld
operator|->
name|mld_addr
argument_list|,
operator|&
name|dst
argument_list|)
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"ignore v1 query dst %s on ifp %p(%s)"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Make sure we don't hear our own membership report, as fast 	 * leave requires knowing that we are the only member of a 	 * group. Assume we used the link-local address if available, 	 * otherwise look for ::. 	 * 	 * XXX Note that scope ID comparison is needed for the address 	 * returned by in6ifa_ifpforlinklocal(), but SHOULD NOT be 	 * performed for the on-wire address. 	 */
name|ia
operator|=
name|in6ifa_ifpforlinklocal
argument_list|(
name|ifp
argument_list|,
name|IN6_IFF_NOTREADY
operator||
name|IN6_IFF_ANYCAST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ia
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
name|IA6_IN6
argument_list|(
name|ia
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|ia
operator|==
name|NULL
operator|&&
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|src
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"process v1 report %s on ifp %p(%s)"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Embed scope ID of receiving interface in MLD query for lookup 	 * whilst we don't hold other locks (due to KAME locking lameness). 	 */
if|if
condition|(
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
condition|)
name|in6_setscope
argument_list|(
operator|&
name|mld
operator|->
name|mld_addr
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|IN6_MULTI_LOCK
argument_list|()
expr_stmt|;
name|MLD_LOCK
argument_list|()
expr_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * MLDv1 report suppression. 	 * If we are a member of this group, and our membership should be 	 * reported, and our group timer is pending or about to be reset, 	 * stop our group timer by transitioning to the 'lazy' state. 	 */
name|inm
operator|=
name|in6m_lookup_locked
argument_list|(
name|ifp
argument_list|,
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mld_ifinfo
modifier|*
name|mli
decl_stmt|;
name|mli
operator|=
name|inm
operator|->
name|in6m_mli
expr_stmt|;
name|KASSERT
argument_list|(
name|mli
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no mli for ifp %p"
operator|,
name|__func__
operator|,
name|ifp
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * If we are in MLDv2 host mode, do not allow the 		 * other host's MLDv1 report to suppress our reports. 		 */
if|if
condition|(
name|mli
operator|->
name|mli_version
operator|==
name|MLD_VERSION_2
condition|)
goto|goto
name|out_locked
goto|;
name|inm
operator|->
name|in6m_timer
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|inm
operator|->
name|in6m_state
condition|)
block|{
case|case
name|MLD_NOT_MEMBER
case|:
case|case
name|MLD_SILENT_MEMBER
case|:
case|case
name|MLD_SLEEPING_MEMBER
case|:
break|break;
case|case
name|MLD_REPORTING_MEMBER
case|:
case|case
name|MLD_IDLE_MEMBER
case|:
case|case
name|MLD_AWAKENING_MEMBER
case|:
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"report suppressed for %s on ifp %p(%s)"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|MLD_LAZY_MEMBER
case|:
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_LAZY_MEMBER
expr_stmt|;
break|break;
case|case
name|MLD_G_QUERY_PENDING_MEMBER
case|:
case|case
name|MLD_SG_QUERY_PENDING_MEMBER
case|:
case|case
name|MLD_LEAVING_MEMBER
case|:
break|break;
block|}
block|}
name|out_locked
label|:
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|MLD_UNLOCK
argument_list|()
expr_stmt|;
name|IN6_MULTI_UNLOCK
argument_list|()
expr_stmt|;
comment|/* XXX Clear embedded scope ID as userland won't expect it. */
name|in6_clearscope
argument_list|(
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MLD input path.  *  * Assume query messages which fit in a single ICMPv6 message header  * have been pulled up.  * Assume that userland will want to see the message, even if it  * otherwise fails kernel input validation; do not free it.  * Pullup may however free the mbuf chain m if it fails.  *  * Return IPPROTO_DONE if we freed m. Otherwise, return 0.  */
end_comment

begin_function
name|int
name|mld_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|icmp6len
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|mld_hdr
modifier|*
name|mld
decl_stmt|;
name|int
name|mldlen
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: called w/mbuf (%p,%d)"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
comment|/* Pullup to appropriate size. */
name|mld
operator|=
operator|(
expr|struct
name|mld_hdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
if|if
condition|(
name|mld
operator|->
name|mld_type
operator|==
name|MLD_LISTENER_QUERY
operator|&&
name|icmp6len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_query
argument_list|)
condition|)
block|{
name|mldlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_query
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mldlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mld_hdr
argument_list|)
expr_stmt|;
block|}
name|IP6_EXTHDR_GET
argument_list|(
name|mld
argument_list|,
expr|struct
name|mld_hdr
operator|*
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|mldlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|mld
operator|==
name|NULL
condition|)
block|{
name|ICMP6STAT_INC
argument_list|(
name|icp6s_badlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* 	 * Userland needs to see all of this traffic for implementing 	 * the endpoint discovery portion of multicast routing. 	 */
switch|switch
condition|(
name|mld
operator|->
name|mld_type
condition|)
block|{
case|case
name|MLD_LISTENER_QUERY
case|:
name|icmp6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_in_mldquery
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmp6len
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|mld_hdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|mld_v1_input_query
argument_list|(
name|ifp
argument_list|,
name|ip6
argument_list|,
name|mld
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|icmp6len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_query
argument_list|)
condition|)
block|{
if|if
condition|(
name|mld_v2_input_query
argument_list|(
name|ifp
argument_list|,
name|ip6
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|icmp6len
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|MLD_LISTENER_REPORT
case|:
name|icmp6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_in_mldreport
argument_list|)
expr_stmt|;
if|if
condition|(
name|mld_v1_input_report
argument_list|(
name|ifp
argument_list|,
name|ip6
argument_list|,
name|mld
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|MLDV2_LISTENER_REPORT
case|:
name|icmp6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_in_mldreport
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLD_LISTENER_DONE
case|:
name|icmp6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_in_mlddone
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fast timeout handler (global).  * VIMAGE: Timeout handlers are expected to service all vimages.  */
end_comment

begin_function
name|void
name|mld_fasttimo
parameter_list|(
name|void
parameter_list|)
block|{
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|VNET_LIST_RLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|mld_fasttimo_vnet
argument_list|()
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_LIST_RUNLOCK_NOSLEEP
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fast timeout handler (per-vnet).  *  * VIMAGE: Assume caller has set up our curvnet.  */
end_comment

begin_function
specifier|static
name|void
name|mld_fasttimo_vnet
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ifqueue
name|scq
decl_stmt|;
comment|/* State-change packets */
name|struct
name|ifqueue
name|qrq
decl_stmt|;
comment|/* Query response packets */
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mld_ifinfo
modifier|*
name|mli
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|inm
decl_stmt|,
modifier|*
name|tinm
decl_stmt|;
name|int
name|uri_fasthz
decl_stmt|;
name|uri_fasthz
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Quick check to see if any work needs to be done, in order to 	 * minimize the overhead of fasttimo processing. 	 * SMPng: XXX Unlocked reads. 	 */
if|if
condition|(
operator|!
name|V_current_state_timers_running6
operator|&&
operator|!
name|V_interface_timers_running6
operator|&&
operator|!
name|V_state_change_timers_running6
condition|)
return|return;
name|IN6_MULTI_LOCK
argument_list|()
expr_stmt|;
name|MLD_LOCK
argument_list|()
expr_stmt|;
comment|/* 	 * MLDv2 General Query response timer processing. 	 */
if|if
condition|(
name|V_interface_timers_running6
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: interface timers running"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|V_interface_timers_running6
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|mli
argument_list|,
argument|&V_mli_head
argument_list|,
argument|mli_link
argument_list|)
block|{
if|if
condition|(
name|mli
operator|->
name|mli_v2_timer
operator|==
literal|0
condition|)
block|{
comment|/* Do nothing. */
block|}
elseif|else
if|if
condition|(
operator|--
name|mli
operator|->
name|mli_v2_timer
operator|==
literal|0
condition|)
block|{
name|mld_v2_dispatch_general_query
argument_list|(
name|mli
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|V_interface_timers_running6
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|V_current_state_timers_running6
operator|&&
operator|!
name|V_state_change_timers_running6
condition|)
goto|goto
name|out_locked
goto|;
name|V_current_state_timers_running6
operator|=
literal|0
expr_stmt|;
name|V_state_change_timers_running6
operator|=
literal|0
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: state change timers running"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * MLD host report and state-change timer processing. 	 * Note: Processing a v2 group timer may remove a node. 	 */
name|LIST_FOREACH
argument_list|(
argument|mli
argument_list|,
argument|&V_mli_head
argument_list|,
argument|mli_link
argument_list|)
block|{
name|ifp
operator|=
name|mli
operator|->
name|mli_ifp
expr_stmt|;
if|if
condition|(
name|mli
operator|->
name|mli_version
operator|==
name|MLD_VERSION_2
condition|)
block|{
name|uri_fasthz
operator|=
name|MLD_RANDOM_DELAY
argument_list|(
name|mli
operator|->
name|mli_uri
operator|*
name|PR_FASTHZ
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|qrq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifqueue
argument_list|)
argument_list|)
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|qrq
argument_list|,
name|MLD_MAX_G_GS_PACKETS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|scq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifqueue
argument_list|)
argument_list|)
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|scq
argument_list|,
name|MLD_MAX_STATE_CHANGE_PACKETS
argument_list|)
expr_stmt|;
block|}
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
operator|||
name|ifma
operator|->
name|ifma_protospec
operator|==
name|NULL
condition|)
continue|continue;
name|inm
operator|=
operator|(
expr|struct
name|in6_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
switch|switch
condition|(
name|mli
operator|->
name|mli_version
condition|)
block|{
case|case
name|MLD_VERSION_1
case|:
name|mld_v1_process_group_timer
argument_list|(
name|mli
argument_list|,
name|inm
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLD_VERSION_2
case|:
name|mld_v2_process_group_timers
argument_list|(
name|mli
argument_list|,
operator|&
name|qrq
argument_list|,
operator|&
name|scq
argument_list|,
name|inm
argument_list|,
name|uri_fasthz
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mli
operator|->
name|mli_version
condition|)
block|{
case|case
name|MLD_VERSION_1
case|:
comment|/* 			 * Transmit reports for this lifecycle.  This 			 * is done while not holding IF_ADDR_LOCK 			 * since this can call 			 * in6ifa_ifpforlinklocal() which locks 			 * IF_ADDR_LOCK internally as well as 			 * ip6_output() to transmit a packet. 			 */
name|SLIST_FOREACH_SAFE
argument_list|(
argument|inm
argument_list|,
argument|&mli->mli_relinmhead
argument_list|,
argument|in6m_nrele
argument_list|,
argument|tinm
argument_list|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|mli
operator|->
name|mli_relinmhead
argument_list|,
name|in6m_nrele
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mld_v1_transmit_report
argument_list|(
name|inm
argument_list|,
name|MLD_LISTENER_REPORT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MLD_VERSION_2
case|:
name|mld_dispatch_queue
argument_list|(
operator|&
name|qrq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mld_dispatch_queue
argument_list|(
operator|&
name|scq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Free the in_multi reference(s) for 			 * this lifecycle. 			 */
name|SLIST_FOREACH_SAFE
argument_list|(
argument|inm
argument_list|,
argument|&mli->mli_relinmhead
argument_list|,
argument|in6m_nrele
argument_list|,
argument|tinm
argument_list|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|mli
operator|->
name|mli_relinmhead
argument_list|,
name|in6m_nrele
argument_list|)
expr_stmt|;
name|in6m_release_locked
argument_list|(
name|inm
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|out_locked
label|:
name|MLD_UNLOCK
argument_list|()
expr_stmt|;
name|IN6_MULTI_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update host report group timer.  * Will update the global pending timer flags.  */
end_comment

begin_function
specifier|static
name|void
name|mld_v1_process_group_timer
parameter_list|(
name|struct
name|mld_ifinfo
modifier|*
name|mli
parameter_list|,
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|)
block|{
name|int
name|report_timer_expired
decl_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|MLD_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|in6m_timer
operator|==
literal|0
condition|)
block|{
name|report_timer_expired
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|inm
operator|->
name|in6m_timer
operator|==
literal|0
condition|)
block|{
name|report_timer_expired
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|V_current_state_timers_running6
operator|=
literal|1
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|inm
operator|->
name|in6m_state
condition|)
block|{
case|case
name|MLD_NOT_MEMBER
case|:
case|case
name|MLD_SILENT_MEMBER
case|:
case|case
name|MLD_IDLE_MEMBER
case|:
case|case
name|MLD_LAZY_MEMBER
case|:
case|case
name|MLD_SLEEPING_MEMBER
case|:
case|case
name|MLD_AWAKENING_MEMBER
case|:
break|break;
case|case
name|MLD_REPORTING_MEMBER
case|:
if|if
condition|(
name|report_timer_expired
condition|)
block|{
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_IDLE_MEMBER
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|mli
operator|->
name|mli_relinmhead
argument_list|,
name|inm
argument_list|,
name|in6m_nrele
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MLD_G_QUERY_PENDING_MEMBER
case|:
case|case
name|MLD_SG_QUERY_PENDING_MEMBER
case|:
case|case
name|MLD_LEAVING_MEMBER
case|:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Update a group's timers for MLDv2.  * Will update the global pending timer flags.  * Note: Unlocked read from mli.  */
end_comment

begin_function
specifier|static
name|void
name|mld_v2_process_group_timers
parameter_list|(
name|struct
name|mld_ifinfo
modifier|*
name|mli
parameter_list|,
name|struct
name|ifqueue
modifier|*
name|qrq
parameter_list|,
name|struct
name|ifqueue
modifier|*
name|scq
parameter_list|,
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|,
specifier|const
name|int
name|uri_fasthz
parameter_list|)
block|{
name|int
name|query_response_timer_expired
decl_stmt|;
name|int
name|state_change_retransmit_timer_expired
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|MLD_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|query_response_timer_expired
operator|=
literal|0
expr_stmt|;
name|state_change_retransmit_timer_expired
operator|=
literal|0
expr_stmt|;
comment|/* 	 * During a transition from compatibility mode back to MLDv2, 	 * a group record in REPORTING state may still have its group 	 * timer active. This is a no-op in this function; it is easier 	 * to deal with it here than to complicate the slow-timeout path. 	 */
if|if
condition|(
name|inm
operator|->
name|in6m_timer
operator|==
literal|0
condition|)
block|{
name|query_response_timer_expired
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|inm
operator|->
name|in6m_timer
operator|==
literal|0
condition|)
block|{
name|query_response_timer_expired
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|V_current_state_timers_running6
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inm
operator|->
name|in6m_sctimer
operator|==
literal|0
condition|)
block|{
name|state_change_retransmit_timer_expired
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|inm
operator|->
name|in6m_sctimer
operator|==
literal|0
condition|)
block|{
name|state_change_retransmit_timer_expired
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|V_state_change_timers_running6
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We are in fasttimo, so be quick about it. */
if|if
condition|(
operator|!
name|state_change_retransmit_timer_expired
operator|&&
operator|!
name|query_response_timer_expired
condition|)
return|return;
switch|switch
condition|(
name|inm
operator|->
name|in6m_state
condition|)
block|{
case|case
name|MLD_NOT_MEMBER
case|:
case|case
name|MLD_SILENT_MEMBER
case|:
case|case
name|MLD_SLEEPING_MEMBER
case|:
case|case
name|MLD_LAZY_MEMBER
case|:
case|case
name|MLD_AWAKENING_MEMBER
case|:
case|case
name|MLD_IDLE_MEMBER
case|:
break|break;
case|case
name|MLD_G_QUERY_PENDING_MEMBER
case|:
case|case
name|MLD_SG_QUERY_PENDING_MEMBER
case|:
comment|/* 		 * Respond to a previously pending Group-Specific 		 * or Group-and-Source-Specific query by enqueueing 		 * the appropriate Current-State report for 		 * immediate transmission. 		 */
if|if
condition|(
name|query_response_timer_expired
condition|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|mld_v2_enqueue_group_record
argument_list|(
name|qrq
argument_list|,
name|inm
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|inm
operator|->
name|in6m_state
operator|==
name|MLD_SG_QUERY_PENDING_MEMBER
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: enqueue record = %d"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_REPORTING_MEMBER
expr_stmt|;
name|in6m_clear_recorded
argument_list|(
name|inm
argument_list|)
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|MLD_REPORTING_MEMBER
case|:
case|case
name|MLD_LEAVING_MEMBER
case|:
if|if
condition|(
name|state_change_retransmit_timer_expired
condition|)
block|{
comment|/* 			 * State-change retransmission timer fired. 			 * If there are any further pending retransmissions, 			 * set the global pending state-change flag, and 			 * reset the timer. 			 */
if|if
condition|(
operator|--
name|inm
operator|->
name|in6m_scrv
operator|>
literal|0
condition|)
block|{
name|inm
operator|->
name|in6m_sctimer
operator|=
name|uri_fasthz
expr_stmt|;
name|V_state_change_timers_running6
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 			 * Retransmit the previously computed state-change 			 * report. If there are no further pending 			 * retransmissions, the mbuf queue will be consumed. 			 * Update T0 state to T1 as we have now sent 			 * a state-change. 			 */
operator|(
name|void
operator|)
name|mld_v2_merge_state_changes
argument_list|(
name|inm
argument_list|,
name|scq
argument_list|)
expr_stmt|;
name|in6m_commit
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: T1 -> T0 for %s/%s"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
argument_list|,
name|if_name
argument_list|(
name|inm
operator|->
name|in6m_ifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * If we are leaving the group for good, make sure 			 * we release MLD's reference to it. 			 * This release must be deferred using a SLIST, 			 * as we are called from a loop which traverses 			 * the in_ifmultiaddr TAILQ. 			 */
if|if
condition|(
name|inm
operator|->
name|in6m_state
operator|==
name|MLD_LEAVING_MEMBER
operator|&&
name|inm
operator|->
name|in6m_scrv
operator|==
literal|0
condition|)
block|{
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_NOT_MEMBER
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|mli
operator|->
name|mli_relinmhead
argument_list|,
name|inm
argument_list|,
name|in6m_nrele
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Switch to a different version on the given interface,  * as per Section 9.12.  */
end_comment

begin_function
specifier|static
name|void
name|mld_set_version
parameter_list|(
name|struct
name|mld_ifinfo
modifier|*
name|mli
parameter_list|,
specifier|const
name|int
name|version
parameter_list|)
block|{
name|int
name|old_version_timer
decl_stmt|;
name|MLD_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: switching to v%d on ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|version
argument_list|,
name|mli
operator|->
name|mli_ifp
argument_list|,
name|if_name
argument_list|(
name|mli
operator|->
name|mli_ifp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|MLD_VERSION_1
condition|)
block|{
comment|/* 		 * Compute the "Older Version Querier Present" timer as per 		 * Section 9.12. 		 */
name|old_version_timer
operator|=
operator|(
name|mli
operator|->
name|mli_rv
operator|*
name|mli
operator|->
name|mli_qi
operator|)
operator|+
name|mli
operator|->
name|mli_qri
expr_stmt|;
name|old_version_timer
operator|*=
name|PR_SLOWHZ
expr_stmt|;
name|mli
operator|->
name|mli_v1_timer
operator|=
name|old_version_timer
expr_stmt|;
block|}
if|if
condition|(
name|mli
operator|->
name|mli_v1_timer
operator|>
literal|0
operator|&&
name|mli
operator|->
name|mli_version
operator|!=
name|MLD_VERSION_1
condition|)
block|{
name|mli
operator|->
name|mli_version
operator|=
name|MLD_VERSION_1
expr_stmt|;
name|mld_v2_cancel_link_timers
argument_list|(
name|mli
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Cancel pending MLDv2 timers for the given link and all groups  * joined on it; state-change, general-query, and group-query timers.  */
end_comment

begin_function
specifier|static
name|void
name|mld_v2_cancel_link_timers
parameter_list|(
name|struct
name|mld_ifinfo
modifier|*
name|mli
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|inm
decl_stmt|,
modifier|*
name|tinm
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: cancel v2 timers on ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|mli
operator|->
name|mli_ifp
argument_list|,
name|if_name
argument_list|(
name|mli
operator|->
name|mli_ifp
argument_list|)
argument_list|)
expr_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|MLD_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* 	 * Fast-track this potentially expensive operation 	 * by checking all the global 'timer pending' flags. 	 */
if|if
condition|(
operator|!
name|V_interface_timers_running6
operator|&&
operator|!
name|V_state_change_timers_running6
operator|&&
operator|!
name|V_current_state_timers_running6
condition|)
return|return;
name|mli
operator|->
name|mli_v2_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|=
name|mli
operator|->
name|mli_ifp
expr_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|inm
operator|=
operator|(
expr|struct
name|in6_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
switch|switch
condition|(
name|inm
operator|->
name|in6m_state
condition|)
block|{
case|case
name|MLD_NOT_MEMBER
case|:
case|case
name|MLD_SILENT_MEMBER
case|:
case|case
name|MLD_IDLE_MEMBER
case|:
case|case
name|MLD_LAZY_MEMBER
case|:
case|case
name|MLD_SLEEPING_MEMBER
case|:
case|case
name|MLD_AWAKENING_MEMBER
case|:
break|break;
case|case
name|MLD_LEAVING_MEMBER
case|:
comment|/* 			 * If we are leaving the group and switching 			 * version, we need to release the final 			 * reference held for issuing the INCLUDE {}. 			 */
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|mli
operator|->
name|mli_relinmhead
argument_list|,
name|inm
argument_list|,
name|in6m_nrele
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MLD_G_QUERY_PENDING_MEMBER
case|:
case|case
name|MLD_SG_QUERY_PENDING_MEMBER
case|:
name|in6m_clear_recorded
argument_list|(
name|inm
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MLD_REPORTING_MEMBER
case|:
name|inm
operator|->
name|in6m_sctimer
operator|=
literal|0
expr_stmt|;
name|inm
operator|->
name|in6m_timer
operator|=
literal|0
expr_stmt|;
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_REPORTING_MEMBER
expr_stmt|;
comment|/* 			 * Free any pending MLDv2 state-change records. 			 */
name|_IF_DRAIN
argument_list|(
operator|&
name|inm
operator|->
name|in6m_scq
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|SLIST_FOREACH_SAFE
argument_list|(
argument|inm
argument_list|,
argument|&mli->mli_relinmhead
argument_list|,
argument|in6m_nrele
argument_list|,
argument|tinm
argument_list|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|mli
operator|->
name|mli_relinmhead
argument_list|,
name|in6m_nrele
argument_list|)
expr_stmt|;
name|in6m_release_locked
argument_list|(
name|inm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Global slowtimo handler.  * VIMAGE: Timeout handlers are expected to service all vimages.  */
end_comment

begin_function
name|void
name|mld_slowtimo
parameter_list|(
name|void
parameter_list|)
block|{
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|VNET_LIST_RLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|mld_slowtimo_vnet
argument_list|()
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_LIST_RUNLOCK_NOSLEEP
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Per-vnet slowtimo handler.  */
end_comment

begin_function
specifier|static
name|void
name|mld_slowtimo_vnet
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mld_ifinfo
modifier|*
name|mli
decl_stmt|;
name|MLD_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|mli
argument_list|,
argument|&V_mli_head
argument_list|,
argument|mli_link
argument_list|)
block|{
name|mld_v1_process_querier_timers
argument_list|(
name|mli
argument_list|)
expr_stmt|;
block|}
name|MLD_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the Older Version Querier Present timers for a link.  * See Section 9.12 of RFC 3810.  */
end_comment

begin_function
specifier|static
name|void
name|mld_v1_process_querier_timers
parameter_list|(
name|struct
name|mld_ifinfo
modifier|*
name|mli
parameter_list|)
block|{
name|MLD_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|mli
operator|->
name|mli_version
operator|!=
name|MLD_VERSION_2
operator|&&
operator|--
name|mli
operator|->
name|mli_v1_timer
operator|==
literal|0
condition|)
block|{
comment|/* 		 * MLDv1 Querier Present timer expired; revert to MLDv2. 		 */
name|CTR5
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: transition from v%d -> v%d on %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|mli
operator|->
name|mli_version
argument_list|,
name|MLD_VERSION_2
argument_list|,
name|mli
operator|->
name|mli_ifp
argument_list|,
name|if_name
argument_list|(
name|mli
operator|->
name|mli_ifp
argument_list|)
argument_list|)
expr_stmt|;
name|mli
operator|->
name|mli_version
operator|=
name|MLD_VERSION_2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Transmit an MLDv1 report immediately.  */
end_comment

begin_function
specifier|static
name|int
name|mld_v1_transmit_report
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|in6m
parameter_list|,
specifier|const
name|int
name|type
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mh
decl_stmt|,
modifier|*
name|md
decl_stmt|;
name|struct
name|mld_hdr
modifier|*
name|mld
decl_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|MLD_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|ifp
operator|=
name|in6m
operator|->
name|in6m_ifp
expr_stmt|;
name|ia
operator|=
name|in6ifa_ifpforlinklocal
argument_list|(
name|ifp
argument_list|,
name|IN6_IFF_NOTREADY
operator||
name|IN6_IFF_ANYCAST
argument_list|)
expr_stmt|;
comment|/* ia may be NULL if link-local address is tentative. */
name|mh
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|md
operator|=
name|m_get
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|==
name|NULL
condition|)
block|{
name|m_free
argument_list|(
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mh
operator|->
name|m_next
operator|=
name|md
expr_stmt|;
comment|/* 	 * FUTURE: Consider increasing alignment by ETHER_HDR_LEN, so 	 * that ether_output() does not need to allocate another mbuf 	 * for the header in the most common case. 	 */
name|MH_ALIGN
argument_list|(
name|mh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mld_hdr
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|mh
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|ip6
operator|->
name|ip6_flow
operator|=
literal|0
expr_stmt|;
name|ip6
operator|->
name|ip6_vfc
operator|&=
operator|~
name|IPV6_VERSION_MASK
expr_stmt|;
name|ip6
operator|->
name|ip6_vfc
operator||=
name|IPV6_VERSION
expr_stmt|;
name|ip6
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_ICMPV6
expr_stmt|;
name|ip6
operator|->
name|ip6_src
operator|=
name|ia
condition|?
name|ia
operator|->
name|ia_addr
operator|.
name|sin6_addr
else|:
name|in6addr_any
expr_stmt|;
name|ip6
operator|->
name|ip6_dst
operator|=
name|in6m
operator|->
name|in6m_addr
expr_stmt|;
name|md
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mld_hdr
argument_list|)
expr_stmt|;
name|mld
operator|=
name|mtod
argument_list|(
name|md
argument_list|,
expr|struct
name|mld_hdr
operator|*
argument_list|)
expr_stmt|;
name|mld
operator|->
name|mld_type
operator|=
name|type
expr_stmt|;
name|mld
operator|->
name|mld_code
operator|=
literal|0
expr_stmt|;
name|mld
operator|->
name|mld_cksum
operator|=
literal|0
expr_stmt|;
name|mld
operator|->
name|mld_maxdelay
operator|=
literal|0
expr_stmt|;
name|mld
operator|->
name|mld_reserved
operator|=
literal|0
expr_stmt|;
name|mld
operator|->
name|mld_addr
operator|=
name|in6m
operator|->
name|in6m_addr
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|mld
operator|->
name|mld_addr
argument_list|)
expr_stmt|;
name|mld
operator|->
name|mld_cksum
operator|=
name|in6_cksum
argument_list|(
name|mh
argument_list|,
name|IPPROTO_ICMPV6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mld_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|mld_save_context
argument_list|(
name|mh
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_flags
operator||=
name|M_MLDV1
expr_stmt|;
name|mld_dispatch_packet
argument_list|(
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a state change from the upper layer for the given IPv6 group.  *  * Each socket holds a reference on the in_multi in its own ip_moptions.  * The socket layer will have made the necessary updates to.the group  * state, it is now up to MLD to issue a state change report if there  * has been any change between T0 (when the last state-change was issued)  * and T1 (now).  *  * We use the MLDv2 state machine at group level. The MLd module  * however makes the decision as to which MLD protocol version to speak.  * A state change *from* INCLUDE {} always means an initial join.  * A state change *to* INCLUDE {} always means a final leave.  *  * If delay is non-zero, and the state change is an initial multicast  * join, the state change report will be delayed by 'delay' ticks  * in units of PR_FASTHZ if MLDv1 is active on the link; otherwise  * the initial MLDv2 state change report will be delayed by whichever  * is sooner, a pending state-change timer or delay itself.  *  * VIMAGE: curvnet should have been set by caller, as this routine  * is called from the socket option handlers.  */
end_comment

begin_function
name|int
name|mld_change_state
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|,
specifier|const
name|int
name|delay
parameter_list|)
block|{
name|struct
name|mld_ifinfo
modifier|*
name|mli
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Try to detect if the upper layer just asked us to change state 	 * for an interface which has now gone away. 	 */
name|KASSERT
argument_list|(
name|inm
operator|->
name|in6m_ifma
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no ifma"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|inm
operator|->
name|in6m_ifma
operator|->
name|ifma_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Sanity check that netinet6's notion of ifp is the 		 * same as net's. 		 */
name|KASSERT
argument_list|(
name|inm
operator|->
name|in6m_ifp
operator|==
name|ifp
argument_list|,
operator|(
literal|"%s: bad ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
name|MLD_LOCK
argument_list|()
expr_stmt|;
name|mli
operator|=
name|MLD_IFINFO
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mli
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no mld_ifinfo for ifp %p"
operator|,
name|__func__
operator|,
name|ifp
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we detect a state transition to or from MCAST_UNDEFINED 	 * for this group, then we are starting or finishing an MLD 	 * life cycle for this group. 	 */
if|if
condition|(
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
operator|!=
name|inm
operator|->
name|in6m_st
index|[
literal|0
index|]
operator|.
name|iss_fmode
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: inm transition %d -> %d"
argument_list|,
name|__func__
argument_list|,
name|inm
operator|->
name|in6m_st
index|[
literal|0
index|]
operator|.
name|iss_fmode
argument_list|,
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|in6m_st
index|[
literal|0
index|]
operator|.
name|iss_fmode
operator|==
name|MCAST_UNDEFINED
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: initial join"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|mld_initial_join
argument_list|(
name|inm
argument_list|,
name|mli
argument_list|,
name|delay
argument_list|)
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
elseif|else
if|if
condition|(
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
operator|==
name|MCAST_UNDEFINED
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: final leave"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mld_final_leave
argument_list|(
name|inm
argument_list|,
name|mli
argument_list|)
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
block|}
else|else
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: filter set change"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|mld_handle_state_change
argument_list|(
name|inm
argument_list|,
name|mli
argument_list|)
expr_stmt|;
name|out_locked
label|:
name|MLD_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform the initial join for an MLD group.  *  * When joining a group:  *  If the group should have its MLD traffic suppressed, do nothing.  *  MLDv1 starts sending MLDv1 host membership reports.  *  MLDv2 will schedule an MLDv2 state-change report containing the  *  initial state of the membership.  *  * If the delay argument is non-zero, then we must delay sending the  * initial state change for delay ticks (in units of PR_FASTHZ).  */
end_comment

begin_function
specifier|static
name|int
name|mld_initial_join
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|,
name|struct
name|mld_ifinfo
modifier|*
name|mli
parameter_list|,
specifier|const
name|int
name|delay
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|ifq
decl_stmt|;
name|int
name|error
decl_stmt|,
name|retval
decl_stmt|,
name|syncstates
decl_stmt|;
name|int
name|odelay
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|CTR4
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: initial join %s on ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|in6m_ifp
argument_list|,
name|if_name
argument_list|(
name|inm
operator|->
name|in6m_ifp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|syncstates
operator|=
literal|1
expr_stmt|;
name|ifp
operator|=
name|inm
operator|->
name|in6m_ifp
expr_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|MLD_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|mli
operator|&&
name|mli
operator|->
name|mli_ifp
operator|==
name|ifp
argument_list|,
operator|(
literal|"%s: inconsistent ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Groups joined on loopback or marked as 'not reported', 	 * enter the MLD_SILENT_MEMBER state and 	 * are never reported in any protocol exchanges. 	 * All other groups enter the appropriate state machine 	 * for the version in use on this link. 	 * A link marked as MLIF_SILENT causes MLD to be completely 	 * disabled for the link. 	 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|||
operator|(
name|mli
operator|->
name|mli_flags
operator|&
name|MLIF_SILENT
operator|)
operator|||
operator|!
name|mld_is_addr_reported
argument_list|(
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: not kicking state machine for silent group"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_SILENT_MEMBER
expr_stmt|;
name|inm
operator|->
name|in6m_timer
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Deal with overlapping in_multi lifecycle. 		 * If this group was LEAVING, then make sure 		 * we drop the reference we picked up to keep the 		 * group around for the final INCLUDE {} enqueue. 		 */
if|if
condition|(
name|mli
operator|->
name|mli_version
operator|==
name|MLD_VERSION_2
operator|&&
name|inm
operator|->
name|in6m_state
operator|==
name|MLD_LEAVING_MEMBER
condition|)
name|in6m_release_locked
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_REPORTING_MEMBER
expr_stmt|;
switch|switch
condition|(
name|mli
operator|->
name|mli_version
condition|)
block|{
case|case
name|MLD_VERSION_1
case|:
comment|/* 			 * If a delay was provided, only use it if 			 * it is greater than the delay normally 			 * used for an MLDv1 state change report, 			 * and delay sending the initial MLDv1 report 			 * by not transitioning to the IDLE state. 			 */
name|odelay
operator|=
name|MLD_RANDOM_DELAY
argument_list|(
name|MLD_V1_MAX_RI
operator|*
name|PR_FASTHZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
condition|)
block|{
name|inm
operator|->
name|in6m_timer
operator|=
name|max
argument_list|(
name|delay
argument_list|,
name|odelay
argument_list|)
expr_stmt|;
name|V_current_state_timers_running6
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_IDLE_MEMBER
expr_stmt|;
name|error
operator|=
name|mld_v1_transmit_report
argument_list|(
name|inm
argument_list|,
name|MLD_LISTENER_REPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|inm
operator|->
name|in6m_timer
operator|=
name|odelay
expr_stmt|;
name|V_current_state_timers_running6
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MLD_VERSION_2
case|:
comment|/* 			 * Defer update of T0 to T1, until the first copy 			 * of the state change has been transmitted. 			 */
name|syncstates
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Immediately enqueue a State-Change Report for 			 * this interface, freeing any previous reports. 			 * Don't kick the timers if there is nothing to do, 			 * or if an error occurred. 			 */
name|ifq
operator|=
operator|&
name|inm
operator|->
name|in6m_scq
expr_stmt|;
name|_IF_DRAIN
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mld_v2_enqueue_group_record
argument_list|(
name|ifq
argument_list|,
name|inm
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|mli
operator|->
name|mli_flags
operator|&
name|MLIF_USEALLOW
operator|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: enqueue record = %d"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<=
literal|0
condition|)
block|{
name|error
operator|=
name|retval
operator|*
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 			 * Schedule transmission of pending state-change 			 * report up to RV times for this link. The timer 			 * will fire at the next mld_fasttimo (~200ms), 			 * giving us an opportunity to merge the reports. 			 * 			 * If a delay was provided to this function, only 			 * use this delay if sooner than the existing one. 			 */
name|KASSERT
argument_list|(
name|mli
operator|->
name|mli_rv
operator|>
literal|1
argument_list|,
operator|(
literal|"%s: invalid robustness %d"
operator|,
name|__func__
operator|,
name|mli
operator|->
name|mli_rv
operator|)
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_scrv
operator|=
name|mli
operator|->
name|mli_rv
expr_stmt|;
if|if
condition|(
name|delay
condition|)
block|{
if|if
condition|(
name|inm
operator|->
name|in6m_sctimer
operator|>
literal|1
condition|)
block|{
name|inm
operator|->
name|in6m_sctimer
operator|=
name|min
argument_list|(
name|inm
operator|->
name|in6m_sctimer
argument_list|,
name|delay
argument_list|)
expr_stmt|;
block|}
else|else
name|inm
operator|->
name|in6m_sctimer
operator|=
name|delay
expr_stmt|;
block|}
else|else
name|inm
operator|->
name|in6m_sctimer
operator|=
literal|1
expr_stmt|;
name|V_state_change_timers_running6
operator|=
literal|1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Only update the T0 state if state change is atomic, 	 * i.e. we don't need to wait for a timer to fire before we 	 * can consider the state change to have been communicated. 	 */
if|if
condition|(
name|syncstates
condition|)
block|{
name|in6m_commit
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: T1 -> T0 for %s/%s"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
argument_list|,
name|if_name
argument_list|(
name|inm
operator|->
name|in6m_ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Issue an intermediate state change during the life-cycle.  */
end_comment

begin_function
specifier|static
name|int
name|mld_handle_state_change
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|,
name|struct
name|mld_ifinfo
modifier|*
name|mli
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|retval
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|CTR4
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: state change for %s on ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|in6m_ifp
argument_list|,
name|if_name
argument_list|(
name|inm
operator|->
name|in6m_ifp
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|inm
operator|->
name|in6m_ifp
expr_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|MLD_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|mli
operator|&&
name|mli
operator|->
name|mli_ifp
operator|==
name|ifp
argument_list|,
operator|(
literal|"%s: inconsistent ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|||
operator|(
name|mli
operator|->
name|mli_flags
operator|&
name|MLIF_SILENT
operator|)
operator|||
operator|!
name|mld_is_addr_reported
argument_list|(
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
operator|||
operator|(
name|mli
operator|->
name|mli_version
operator|!=
name|MLD_VERSION_2
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|mld_is_addr_reported
argument_list|(
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: not kicking state machine for silent group"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: nothing to do"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|in6m_commit
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: T1 -> T0 for %s/%s"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
argument_list|,
name|if_name
argument_list|(
name|inm
operator|->
name|in6m_ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|_IF_DRAIN
argument_list|(
operator|&
name|inm
operator|->
name|in6m_scq
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mld_v2_enqueue_group_record
argument_list|(
operator|&
name|inm
operator|->
name|in6m_scq
argument_list|,
name|inm
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|mli
operator|->
name|mli_flags
operator|&
name|MLIF_USEALLOW
operator|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: enqueue record = %d"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
name|retval
operator|)
return|;
comment|/* 	 * If record(s) were enqueued, start the state-change 	 * report timer for this group. 	 */
name|inm
operator|->
name|in6m_scrv
operator|=
name|mli
operator|->
name|mli_rv
expr_stmt|;
name|inm
operator|->
name|in6m_sctimer
operator|=
literal|1
expr_stmt|;
name|V_state_change_timers_running6
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform the final leave for a multicast address.  *  * When leaving a group:  *  MLDv1 sends a DONE message, if and only if we are the reporter.  *  MLDv2 enqueues a state-change report containing a transition  *  to INCLUDE {} for immediate transmission.  */
end_comment

begin_function
specifier|static
name|void
name|mld_final_leave
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|,
name|struct
name|mld_ifinfo
modifier|*
name|mli
parameter_list|)
block|{
name|int
name|syncstates
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|syncstates
operator|=
literal|1
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: final leave %s on ifp %p(%s)"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|in6m_ifp
argument_list|,
name|if_name
argument_list|(
name|inm
operator|->
name|in6m_ifp
argument_list|)
argument_list|)
expr_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|MLD_LOCK_ASSERT
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|inm
operator|->
name|in6m_state
condition|)
block|{
case|case
name|MLD_NOT_MEMBER
case|:
case|case
name|MLD_SILENT_MEMBER
case|:
case|case
name|MLD_LEAVING_MEMBER
case|:
comment|/* Already leaving or left; do nothing. */
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: not kicking state machine for silent group"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLD_REPORTING_MEMBER
case|:
case|case
name|MLD_IDLE_MEMBER
case|:
case|case
name|MLD_G_QUERY_PENDING_MEMBER
case|:
case|case
name|MLD_SG_QUERY_PENDING_MEMBER
case|:
if|if
condition|(
name|mli
operator|->
name|mli_version
operator|==
name|MLD_VERSION_1
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|inm
operator|->
name|in6m_state
operator|==
name|MLD_G_QUERY_PENDING_MEMBER
operator|||
name|inm
operator|->
name|in6m_state
operator|==
name|MLD_SG_QUERY_PENDING_MEMBER
condition|)
name|panic
argument_list|(
literal|"%s: MLDv2 state reached, not MLDv2 mode"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mld_v1_transmit_report
argument_list|(
name|inm
argument_list|,
name|MLD_LISTENER_DONE
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_NOT_MEMBER
expr_stmt|;
name|V_current_state_timers_running6
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mli
operator|->
name|mli_version
operator|==
name|MLD_VERSION_2
condition|)
block|{
comment|/* 			 * Stop group timer and all pending reports. 			 * Immediately enqueue a state-change report 			 * TO_IN {} to be sent on the next fast timeout, 			 * giving us an opportunity to merge reports. 			 */
name|_IF_DRAIN
argument_list|(
operator|&
name|inm
operator|->
name|in6m_scq
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_timer
operator|=
literal|0
expr_stmt|;
name|inm
operator|->
name|in6m_scrv
operator|=
name|mli
operator|->
name|mli_rv
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: Leaving %s/%s with %d "
literal|"pending retransmissions."
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
argument_list|,
name|if_name
argument_list|(
name|inm
operator|->
name|in6m_ifp
argument_list|)
argument_list|,
name|inm
operator|->
name|in6m_scrv
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|in6m_scrv
operator|==
literal|0
condition|)
block|{
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_NOT_MEMBER
expr_stmt|;
name|inm
operator|->
name|in6m_sctimer
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|retval
decl_stmt|;
name|in6m_acquire_locked
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mld_v2_enqueue_group_record
argument_list|(
operator|&
name|inm
operator|->
name|in6m_scq
argument_list|,
name|inm
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|mli
operator|->
name|mli_flags
operator|&
name|MLIF_USEALLOW
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|retval
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: enqueue record = %d"
operator|,
name|__func__
operator|,
name|retval
operator|)
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_LEAVING_MEMBER
expr_stmt|;
name|inm
operator|->
name|in6m_sctimer
operator|=
literal|1
expr_stmt|;
name|V_state_change_timers_running6
operator|=
literal|1
expr_stmt|;
name|syncstates
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
name|MLD_LAZY_MEMBER
case|:
case|case
name|MLD_SLEEPING_MEMBER
case|:
case|case
name|MLD_AWAKENING_MEMBER
case|:
comment|/* Our reports are suppressed; do nothing. */
break|break;
block|}
if|if
condition|(
name|syncstates
condition|)
block|{
name|in6m_commit
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: T1 -> T0 for %s/%s"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
argument_list|,
name|if_name
argument_list|(
name|inm
operator|->
name|in6m_ifp
argument_list|)
argument_list|)
expr_stmt|;
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: T1 now MCAST_UNDEFINED for %p/%s"
argument_list|,
name|__func__
argument_list|,
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|,
name|if_name
argument_list|(
name|inm
operator|->
name|in6m_ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Enqueue an MLDv2 group record to the given output queue.  *  * If is_state_change is zero, a current-state record is appended.  * If is_state_change is non-zero, a state-change report is appended.  *  * If is_group_query is non-zero, an mbuf packet chain is allocated.  * If is_group_query is zero, and if there is a packet with free space  * at the tail of the queue, it will be appended to providing there  * is enough free space.  * Otherwise a new mbuf packet chain is allocated.  *  * If is_source_query is non-zero, each source is checked to see if  * it was recorded for a Group-Source query, and will be omitted if  * it is not both in-mode and recorded.  *  * If use_block_allow is non-zero, state change reports for initial join  * and final leave, on an inclusive mode group with a source list, will be  * rewritten to use the ALLOW_NEW and BLOCK_OLD record types, respectively.  *  * The function will attempt to allocate leading space in the packet  * for the IPv6+ICMP headers to be prepended without fragmenting the chain.  *  * If successful the size of all data appended to the queue is returned,  * otherwise an error code less than zero is returned, or zero if  * no record(s) were appended.  */
end_comment

begin_function
specifier|static
name|int
name|mld_v2_enqueue_group_record
parameter_list|(
name|struct
name|ifqueue
modifier|*
name|ifq
parameter_list|,
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|,
specifier|const
name|int
name|is_state_change
parameter_list|,
specifier|const
name|int
name|is_group_query
parameter_list|,
specifier|const
name|int
name|is_source_query
parameter_list|,
specifier|const
name|int
name|use_block_allow
parameter_list|)
block|{
name|struct
name|mldv2_record
name|mr
decl_stmt|;
name|struct
name|mldv2_record
modifier|*
name|pmr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|nims
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
name|md
decl_stmt|;
name|int
name|error
decl_stmt|,
name|is_filter_list_change
decl_stmt|;
name|int
name|minrec0len
decl_stmt|,
name|m0srcs
decl_stmt|,
name|msrcs
decl_stmt|,
name|nbytes
decl_stmt|,
name|off
decl_stmt|;
name|int
name|record_has_sources
decl_stmt|;
name|int
name|now
decl_stmt|;
name|int
name|type
decl_stmt|;
name|uint8_t
name|mode
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ifp
operator|=
name|inm
operator|->
name|in6m_ifp
expr_stmt|;
name|is_filter_list_change
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
name|m0srcs
operator|=
literal|0
expr_stmt|;
name|msrcs
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|=
literal|0
expr_stmt|;
name|nims
operator|=
name|NULL
expr_stmt|;
name|record_has_sources
operator|=
literal|1
expr_stmt|;
name|pmr
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|MLD_DO_NOTHING
expr_stmt|;
name|mode
operator|=
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
expr_stmt|;
comment|/* 	 * If we did not transition out of ASM mode during t0->t1, 	 * and there are no source nodes to process, we can skip 	 * the generation of source records. 	 */
if|if
condition|(
name|inm
operator|->
name|in6m_st
index|[
literal|0
index|]
operator|.
name|iss_asm
operator|>
literal|0
operator|&&
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_asm
operator|>
literal|0
operator|&&
name|inm
operator|->
name|in6m_nsrc
operator|==
literal|0
condition|)
name|record_has_sources
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_state_change
condition|)
block|{
comment|/* 		 * Queue a state change record. 		 * If the mode did not change, and there are non-ASM 		 * listeners or source filters present, 		 * we potentially need to issue two records for the group. 		 * If there are ASM listeners, and there was no filter 		 * mode transition of any kind, do nothing. 		 * 		 * If we are transitioning to MCAST_UNDEFINED, we need 		 * not send any sources. A transition to/from this state is 		 * considered inclusive with some special treatment. 		 * 		 * If we are rewriting initial joins/leaves to use 		 * ALLOW/BLOCK, and the group's membership is inclusive, 		 * we need to send sources in all cases. 		 */
if|if
condition|(
name|mode
operator|!=
name|inm
operator|->
name|in6m_st
index|[
literal|0
index|]
operator|.
name|iss_fmode
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|MCAST_EXCLUDE
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: change to EXCLUDE"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|type
operator|=
name|MLD_CHANGE_TO_EXCLUDE_MODE
expr_stmt|;
block|}
else|else
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: change to INCLUDE"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_block_allow
condition|)
block|{
comment|/* 					 * XXX 					 * Here we're interested in state 					 * edges either direction between 					 * MCAST_UNDEFINED and MCAST_INCLUDE. 					 * Perhaps we should just check 					 * the group state, rather than 					 * the filter mode. 					 */
if|if
condition|(
name|mode
operator|==
name|MCAST_UNDEFINED
condition|)
block|{
name|type
operator|=
name|MLD_BLOCK_OLD_SOURCES
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|MLD_ALLOW_NEW_SOURCES
expr_stmt|;
block|}
block|}
else|else
block|{
name|type
operator|=
name|MLD_CHANGE_TO_INCLUDE_MODE
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|MCAST_UNDEFINED
condition|)
name|record_has_sources
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|record_has_sources
condition|)
block|{
name|is_filter_list_change
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|MLD_DO_NOTHING
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * Queue a current state record. 		 */
if|if
condition|(
name|mode
operator|==
name|MCAST_EXCLUDE
condition|)
block|{
name|type
operator|=
name|MLD_MODE_IS_EXCLUDE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|MCAST_INCLUDE
condition|)
block|{
name|type
operator|=
name|MLD_MODE_IS_INCLUDE
expr_stmt|;
name|KASSERT
argument_list|(
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_asm
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: inm %p is INCLUDE but ASM count is %d"
operator|,
name|__func__
operator|,
name|inm
operator|,
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_asm
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Generate the filter list changes using a separate function. 	 */
if|if
condition|(
name|is_filter_list_change
condition|)
return|return
operator|(
name|mld_v2_enqueue_filter_change
argument_list|(
name|ifq
argument_list|,
name|inm
argument_list|)
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|MLD_DO_NOTHING
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: nothing to do for %s/%s"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
argument_list|,
name|if_name
argument_list|(
name|inm
operator|->
name|in6m_ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If any sources are present, we must be able to fit at least 	 * one in the trailing space of the tail packet's mbuf, 	 * ideally more. 	 */
name|minrec0len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
expr_stmt|;
if|if
condition|(
name|record_has_sources
condition|)
name|minrec0len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: queueing %s for %s/%s"
argument_list|,
name|__func__
argument_list|,
name|mld_rec_type_to_str
argument_list|(
name|type
argument_list|)
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|inm
operator|->
name|in6m_addr
argument_list|)
argument_list|,
name|if_name
argument_list|(
name|inm
operator|->
name|in6m_ifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we have a packet in the tail of the queue for this 	 * group into which the first group record for this group will fit. 	 * Otherwise allocate a new packet. 	 * Always allocate leading space for IP6+RA+ICMPV6+REPORT. 	 * Note: Group records for G/GSR query responses MUST be sent 	 * in their own packet. 	 */
name|m0
operator|=
name|ifq
operator|->
name|ifq_tail
expr_stmt|;
if|if
condition|(
operator|!
name|is_group_query
operator|&&
name|m0
operator|!=
name|NULL
operator|&&
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|+
literal|1
operator|<=
name|MLD_V2_REPORT_MAXRECS
operator|)
operator|&&
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|minrec0len
operator|)
operator|<
operator|(
name|ifp
operator|->
name|if_mtu
operator|-
name|MLD_MTUSPACE
operator|)
condition|)
block|{
name|m0srcs
operator|=
operator|(
name|ifp
operator|->
name|if_mtu
operator|-
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: use existing packet"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_IF_QFULL
argument_list|(
name|ifq
argument_list|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: outbound queue full"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|m
operator|=
name|NULL
expr_stmt|;
name|m0srcs
operator|=
operator|(
name|ifp
operator|->
name|if_mtu
operator|-
name|MLD_MTUSPACE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_state_change
operator|&&
operator|!
name|is_group_query
condition|)
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|mld_save_context
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: allocated first packet"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Append group record. 	 * If we have sources, we don't know how many yet. 	 */
name|mr
operator|.
name|mr_type
operator|=
name|type
expr_stmt|;
name|mr
operator|.
name|mr_datalen
operator|=
literal|0
expr_stmt|;
name|mr
operator|.
name|mr_numsrc
operator|=
literal|0
expr_stmt|;
name|mr
operator|.
name|mr_addr
operator|=
name|inm
operator|->
name|in6m_addr
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|mr
operator|.
name|mr_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_append
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|mr
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: m_append() failed."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|nbytes
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
expr_stmt|;
comment|/* 	 * Append as many sources as will fit in the first packet. 	 * If we are appending to a new packet, the chain allocation 	 * may potentially use clusters; use m_getptr() in this case. 	 * If we are appending to an existing packet, we need to obtain 	 * a pointer to the group record after m_append(), in case a new 	 * mbuf was allocated. 	 * 	 * Only append sources which are in-mode at t1. If we are 	 * transitioning to MCAST_UNDEFINED state on the group, and 	 * use_block_allow is zero, do not include source entries. 	 * Otherwise, we need to include this source in the report. 	 * 	 * Only report recorded sources in our filter set when responding 	 * to a group-source query. 	 */
if|if
condition|(
name|record_has_sources
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|m0
condition|)
block|{
name|md
operator|=
name|m_last
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmr
operator|=
operator|(
expr|struct
name|mldv2_record
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|md
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|md
operator|->
name|m_len
operator|-
name|nbytes
operator|)
expr_stmt|;
block|}
else|else
block|{
name|md
operator|=
name|m_getptr
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|pmr
operator|=
operator|(
expr|struct
name|mldv2_record
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|md
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
block|}
name|msrcs
operator|=
literal|0
expr_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|&inm->in6m_srcs
argument_list|,
argument|nims
argument_list|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: visit node %s"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|ims
operator|->
name|im6s_addr
argument_list|)
argument_list|)
expr_stmt|;
name|now
operator|=
name|im6s_get_mode
argument_list|(
name|inm
argument_list|,
name|ims
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: node is %d"
argument_list|,
name|__func__
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|now
operator|!=
name|mode
operator|)
operator|||
operator|(
name|now
operator|==
name|mode
operator|&&
operator|(
operator|!
name|use_block_allow
operator|&&
name|mode
operator|==
name|MCAST_UNDEFINED
operator|)
operator|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: skip node"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|is_source_query
operator|&&
name|ims
operator|->
name|im6s_stp
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: skip unrecorded node"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: append node"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_append
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ims
operator|->
name|im6s_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: m_append() failed."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|nbytes
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
operator|++
name|msrcs
expr_stmt|;
if|if
condition|(
name|msrcs
operator|==
name|m0srcs
condition|)
break|break;
block|}
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: msrcs is %d this packet"
argument_list|,
name|__func__
argument_list|,
name|msrcs
argument_list|)
expr_stmt|;
name|pmr
operator|->
name|mr_numsrc
operator|=
name|htons
argument_list|(
name|msrcs
argument_list|)
expr_stmt|;
name|nbytes
operator|+=
operator|(
name|msrcs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|is_source_query
operator|&&
name|msrcs
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: no recorded sources to report"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We are good to go with first packet. 	 */
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: enqueueing first packet"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|=
literal|1
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|++
expr_stmt|;
comment|/* 	 * No further work needed if no source list in packet(s). 	 */
if|if
condition|(
operator|!
name|record_has_sources
condition|)
return|return
operator|(
name|nbytes
operator|)
return|;
comment|/* 	 * Whilst sources remain to be announced, we need to allocate 	 * a new packet and fill out as many sources as will fit. 	 * Always try for a cluster first. 	 */
while|while
condition|(
name|nims
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|_IF_QFULL
argument_list|(
name|ifq
argument_list|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: outbound queue full"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|mld_save_context
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|md
operator|=
name|m_getptr
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|pmr
operator|=
operator|(
expr|struct
name|mldv2_record
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|md
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: allocated next packet"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_append
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|mr
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: m_append() failed."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|=
literal|1
expr_stmt|;
name|nbytes
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
expr_stmt|;
name|m0srcs
operator|=
operator|(
name|ifp
operator|->
name|if_mtu
operator|-
name|MLD_MTUSPACE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|msrcs
operator|=
literal|0
expr_stmt|;
name|RB_FOREACH_FROM
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|nims
argument_list|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: visit node %s"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|ims
operator|->
name|im6s_addr
argument_list|)
argument_list|)
expr_stmt|;
name|now
operator|=
name|im6s_get_mode
argument_list|(
name|inm
argument_list|,
name|ims
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|now
operator|!=
name|mode
operator|)
operator|||
operator|(
name|now
operator|==
name|mode
operator|&&
operator|(
operator|!
name|use_block_allow
operator|&&
name|mode
operator|==
name|MCAST_UNDEFINED
operator|)
operator|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: skip node"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|is_source_query
operator|&&
name|ims
operator|->
name|im6s_stp
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: skip unrecorded node"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: append node"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_append
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ims
operator|->
name|im6s_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: m_append() failed."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
operator|++
name|msrcs
expr_stmt|;
if|if
condition|(
name|msrcs
operator|==
name|m0srcs
condition|)
break|break;
block|}
name|pmr
operator|->
name|mr_numsrc
operator|=
name|htons
argument_list|(
name|msrcs
argument_list|)
expr_stmt|;
name|nbytes
operator|+=
operator|(
name|msrcs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: enqueueing next packet"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nbytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Type used to mark record pass completion.  * We exploit the fact we can cast to this easily from the  * current filter modes on each ip_msource node.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|REC_NONE
init|=
literal|0x00
block|,
comment|/* MCAST_UNDEFINED */
name|REC_ALLOW
init|=
literal|0x01
block|,
comment|/* MCAST_INCLUDE */
name|REC_BLOCK
init|=
literal|0x02
block|,
comment|/* MCAST_EXCLUDE */
name|REC_FULL
init|=
name|REC_ALLOW
operator||
name|REC_BLOCK
block|}
name|rectype_t
typedef|;
end_typedef

begin_comment
comment|/*  * Enqueue an MLDv2 filter list change to the given output queue.  *  * Source list filter state is held in an RB-tree. When the filter list  * for a group is changed without changing its mode, we need to compute  * the deltas between T0 and T1 for each source in the filter set,  * and enqueue the appropriate ALLOW_NEW/BLOCK_OLD records.  *  * As we may potentially queue two record types, and the entire R-B tree  * needs to be walked at once, we break this out into its own function  * so we can generate a tightly packed queue of packets.  *  * XXX This could be written to only use one tree walk, although that makes  * serializing into the mbuf chains a bit harder. For now we do two walks  * which makes things easier on us, and it may or may not be harder on  * the L2 cache.  *  * If successful the size of all data appended to the queue is returned,  * otherwise an error code less than zero is returned, or zero if  * no record(s) were appended.  */
end_comment

begin_function
specifier|static
name|int
name|mld_v2_enqueue_filter_change
parameter_list|(
name|struct
name|ifqueue
modifier|*
name|ifq
parameter_list|,
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|MINRECLEN
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mldv2_record
name|mr
decl_stmt|;
name|struct
name|mldv2_record
modifier|*
name|pmr
decl_stmt|;
name|struct
name|ip6_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|nims
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
name|md
decl_stmt|;
name|int
name|m0srcs
decl_stmt|,
name|nbytes
decl_stmt|,
name|npbytes
decl_stmt|,
name|off
decl_stmt|,
name|rsrcs
decl_stmt|,
name|schanged
decl_stmt|;
name|int
name|nallow
decl_stmt|,
name|nblock
decl_stmt|;
name|uint8_t
name|mode
decl_stmt|,
name|now
decl_stmt|,
name|then
decl_stmt|;
name|rectype_t
name|crt
decl_stmt|,
name|drt
decl_stmt|,
name|nrt
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|char
name|ip6tbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|in6m_nsrc
operator|==
literal|0
operator|||
operator|(
name|inm
operator|->
name|in6m_st
index|[
literal|0
index|]
operator|.
name|iss_asm
operator|>
literal|0
operator|&&
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_asm
operator|>
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ifp
operator|=
name|inm
operator|->
name|in6m_ifp
expr_stmt|;
comment|/* interface */
name|mode
operator|=
name|inm
operator|->
name|in6m_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
expr_stmt|;
comment|/* filter mode at t1 */
name|crt
operator|=
name|REC_NONE
expr_stmt|;
comment|/* current group record type */
name|drt
operator|=
name|REC_NONE
expr_stmt|;
comment|/* mask of completed group record types */
name|nrt
operator|=
name|REC_NONE
expr_stmt|;
comment|/* record type for current node */
name|m0srcs
operator|=
literal|0
expr_stmt|;
comment|/* # source which will fit in current mbuf chain */
name|npbytes
operator|=
literal|0
expr_stmt|;
comment|/* # of bytes appended this packet */
name|nbytes
operator|=
literal|0
expr_stmt|;
comment|/* # of bytes appended to group's state-change queue */
name|rsrcs
operator|=
literal|0
expr_stmt|;
comment|/* # sources encoded in current record */
name|schanged
operator|=
literal|0
expr_stmt|;
comment|/* # nodes encoded in overall filter change */
name|nallow
operator|=
literal|0
expr_stmt|;
comment|/* # of source entries in ALLOW_NEW */
name|nblock
operator|=
literal|0
expr_stmt|;
comment|/* # of source entries in BLOCK_OLD */
name|nims
operator|=
name|NULL
expr_stmt|;
comment|/* next tree node pointer */
comment|/* 	 * For each possible filter record mode. 	 * The first kind of source we encounter tells us which 	 * is the first kind of record we start appending. 	 * If a node transitioned to UNDEFINED at t1, its mode is treated 	 * as the inverse of the group's filter mode. 	 */
while|while
condition|(
name|drt
operator|!=
name|REC_FULL
condition|)
block|{
do|do
block|{
name|m0
operator|=
name|ifq
operator|->
name|ifq_tail
expr_stmt|;
if|if
condition|(
name|m0
operator|!=
name|NULL
operator|&&
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|+
literal|1
operator|<=
name|MLD_V2_REPORT_MAXRECS
operator|)
operator|&&
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|MINRECLEN
operator|)
operator|<
operator|(
name|ifp
operator|->
name|if_mtu
operator|-
name|MLD_MTUSPACE
operator|)
condition|)
block|{
name|m
operator|=
name|m0
expr_stmt|;
name|m0srcs
operator|=
operator|(
name|ifp
operator|->
name|if_mtu
operator|-
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: use previous packet"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: m_get*() failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|=
literal|0
expr_stmt|;
name|mld_save_context
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|m0srcs
operator|=
operator|(
name|ifp
operator|->
name|if_mtu
operator|-
name|MLD_MTUSPACE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|npbytes
operator|=
literal|0
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: allocated new packet"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Append the MLD group record header to the 			 * current packet's data area. 			 * Recalculate pointer to free space for next 			 * group record, in case m_append() allocated 			 * a new mbuf or cluster. 			 */
name|memset
argument_list|(
operator|&
name|mr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mr
argument_list|)
argument_list|)
expr_stmt|;
name|mr
operator|.
name|mr_addr
operator|=
name|inm
operator|->
name|in6m_addr
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|mr
operator|.
name|mr_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_append
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|mr
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|mr
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: m_append() failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|npbytes
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
block|{
comment|/* new packet; offset in chain */
name|md
operator|=
name|m_getptr
argument_list|(
name|m
argument_list|,
name|npbytes
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|pmr
operator|=
operator|(
expr|struct
name|mldv2_record
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|md
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* current packet; offset from last append */
name|md
operator|=
name|m_last
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmr
operator|=
operator|(
expr|struct
name|mldv2_record
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|md
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|md
operator|->
name|m_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* 			 * Begin walking the tree for this record type 			 * pass, or continue from where we left off 			 * previously if we had to allocate a new packet. 			 * Only report deltas in-mode at t1. 			 * We need not report included sources as allowed 			 * if we are in inclusive mode on the group, 			 * however the converse is not true. 			 */
name|rsrcs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nims
operator|==
name|NULL
condition|)
block|{
name|nims
operator|=
name|RB_MIN
argument_list|(
name|ip6_msource_tree
argument_list|,
operator|&
name|inm
operator|->
name|in6m_srcs
argument_list|)
expr_stmt|;
block|}
name|RB_FOREACH_FROM
argument_list|(
argument|ims
argument_list|,
argument|ip6_msource_tree
argument_list|,
argument|nims
argument_list|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: visit node %s"
argument_list|,
name|__func__
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6tbuf
argument_list|,
operator|&
name|ims
operator|->
name|im6s_addr
argument_list|)
argument_list|)
expr_stmt|;
name|now
operator|=
name|im6s_get_mode
argument_list|(
name|inm
argument_list|,
name|ims
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|then
operator|=
name|im6s_get_mode
argument_list|(
name|inm
argument_list|,
name|ims
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: mode: t0 %d, t1 %d"
argument_list|,
name|__func__
argument_list|,
name|then
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|==
name|then
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: skip unchanged"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mode
operator|==
name|MCAST_EXCLUDE
operator|&&
name|now
operator|==
name|MCAST_INCLUDE
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: skip IN src on EX group"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nrt
operator|=
operator|(
name|rectype_t
operator|)
name|now
expr_stmt|;
if|if
condition|(
name|nrt
operator|==
name|REC_NONE
condition|)
name|nrt
operator|=
call|(
name|rectype_t
call|)
argument_list|(
operator|~
name|mode
operator|&
name|REC_FULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|schanged
operator|++
operator|==
literal|0
condition|)
block|{
name|crt
operator|=
name|nrt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crt
operator|!=
name|nrt
condition|)
continue|continue;
if|if
condition|(
operator|!
name|m_append
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ims
operator|->
name|im6s_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: m_append() failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|nallow
operator|+=
operator|!
operator|!
operator|(
name|crt
operator|==
name|REC_ALLOW
operator|)
expr_stmt|;
name|nblock
operator|+=
operator|!
operator|!
operator|(
name|crt
operator|==
name|REC_BLOCK
operator|)
expr_stmt|;
if|if
condition|(
operator|++
name|rsrcs
operator|==
name|m0srcs
condition|)
break|break;
block|}
comment|/* 			 * If we did not append any tree nodes on this 			 * pass, back out of allocations. 			 */
if|if
condition|(
name|rsrcs
operator|==
literal|0
condition|)
block|{
name|npbytes
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: m_free(m)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: m_adj(m, -mr)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
operator|(
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_record
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|npbytes
operator|+=
operator|(
name|rsrcs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|crt
operator|==
name|REC_ALLOW
condition|)
name|pmr
operator|->
name|mr_type
operator|=
name|MLD_ALLOW_NEW_SOURCES
expr_stmt|;
elseif|else
if|if
condition|(
name|crt
operator|==
name|REC_BLOCK
condition|)
name|pmr
operator|->
name|mr_type
operator|=
name|MLD_BLOCK_OLD_SOURCES
expr_stmt|;
name|pmr
operator|->
name|mr_numsrc
operator|=
name|htons
argument_list|(
name|rsrcs
argument_list|)
expr_stmt|;
comment|/* 			 * Count the new group record, and enqueue this 			 * packet if it wasn't already queued. 			 */
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|++
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|m0
condition|)
name|_IF_ENQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|nbytes
operator|+=
name|npbytes
expr_stmt|;
block|}
do|while
condition|(
name|nims
operator|!=
name|NULL
condition|)
do|;
name|drt
operator||=
name|crt
expr_stmt|;
name|crt
operator|=
operator|(
operator|~
name|crt
operator|&
name|REC_FULL
operator|)
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: queued %d ALLOW_NEW, %d BLOCK_OLD"
argument_list|,
name|__func__
argument_list|,
name|nallow
argument_list|,
name|nblock
argument_list|)
expr_stmt|;
return|return
operator|(
name|nbytes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mld_v2_merge_state_changes
parameter_list|(
name|struct
name|in6_multi
modifier|*
name|inm
parameter_list|,
name|struct
name|ifqueue
modifier|*
name|ifscq
parameter_list|)
block|{
name|struct
name|ifqueue
modifier|*
name|gq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* pending state-change */
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
comment|/* copy of pending state-change */
name|struct
name|mbuf
modifier|*
name|mt
decl_stmt|;
comment|/* last state-change in packet */
name|int
name|docopy
decl_stmt|,
name|domerge
decl_stmt|;
name|u_int
name|recslen
decl_stmt|;
name|docopy
operator|=
literal|0
expr_stmt|;
name|domerge
operator|=
literal|0
expr_stmt|;
name|recslen
operator|=
literal|0
expr_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|MLD_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* 	 * If there are further pending retransmissions, make a writable 	 * copy of each queued state-change message before merging. 	 */
if|if
condition|(
name|inm
operator|->
name|in6m_scrv
operator|>
literal|0
condition|)
name|docopy
operator|=
literal|1
expr_stmt|;
name|gq
operator|=
operator|&
name|inm
operator|->
name|in6m_scq
expr_stmt|;
ifdef|#
directive|ifdef
name|KTR
if|if
condition|(
name|gq
operator|->
name|ifq_head
operator|==
name|NULL
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: WARNING: queue for inm %p is empty"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|=
name|gq
operator|->
name|ifq_head
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Only merge the report into the current packet if 		 * there is sufficient space to do so; an MLDv2 report 		 * packet may only contain 65,535 group records. 		 * Always use a simple mbuf chain concatentation to do this, 		 * as large state changes for single groups may have 		 * allocated clusters. 		 */
name|domerge
operator|=
literal|0
expr_stmt|;
name|mt
operator|=
name|ifscq
operator|->
name|ifq_tail
expr_stmt|;
if|if
condition|(
name|mt
operator|!=
name|NULL
condition|)
block|{
name|recslen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mt
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|<=
name|MLD_V2_REPORT_MAXRECS
operator|)
operator|&&
operator|(
name|mt
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|recslen
operator|<=
operator|(
name|inm
operator|->
name|in6m_ifp
operator|->
name|if_mtu
operator|-
name|MLD_MTUSPACE
operator|)
operator|)
condition|)
name|domerge
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|domerge
operator|&&
name|_IF_QFULL
argument_list|(
name|gq
argument_list|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: outbound queue full, skipping whole packet %p"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mt
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
operator|!
name|docopy
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|mt
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|docopy
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: dequeueing %p"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|_IF_DEQUEUE
argument_list|(
name|gq
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|m
operator|=
name|m0
operator|->
name|m_nextpkt
expr_stmt|;
block|}
else|else
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: copying %p"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m0
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|m0
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|domerge
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: queueing %p to ifscq %p)"
argument_list|,
name|__func__
argument_list|,
name|m0
argument_list|,
name|ifscq
argument_list|)
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
name|ifscq
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|mtl
decl_stmt|;
comment|/* last mbuf of packet mt */
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: merging %p with ifscq tail %p)"
argument_list|,
name|__func__
argument_list|,
name|m0
argument_list|,
name|mt
argument_list|)
expr_stmt|;
name|mtl
operator|=
name|m_last
argument_list|(
name|mt
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|mt
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|recslen
expr_stmt|;
name|mt
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|+=
name|m0
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
expr_stmt|;
name|mtl
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Respond to a pending MLDv2 General Query.  */
end_comment

begin_function
specifier|static
name|void
name|mld_v2_dispatch_general_query
parameter_list|(
name|struct
name|mld_ifinfo
modifier|*
name|mli
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|inm
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|IN6_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|MLD_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|mli
operator|->
name|mli_version
operator|==
name|MLD_VERSION_2
argument_list|,
operator|(
literal|"%s: called when version %d"
operator|,
name|__func__
operator|,
name|mli
operator|->
name|mli_version
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|mli
operator|->
name|mli_ifp
expr_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
operator|||
name|ifma
operator|->
name|ifma_protospec
operator|==
name|NULL
condition|)
continue|continue;
name|inm
operator|=
operator|(
expr|struct
name|in6_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
name|KASSERT
argument_list|(
name|ifp
operator|==
name|inm
operator|->
name|in6m_ifp
argument_list|,
operator|(
literal|"%s: inconsistent ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inm
operator|->
name|in6m_state
condition|)
block|{
case|case
name|MLD_NOT_MEMBER
case|:
case|case
name|MLD_SILENT_MEMBER
case|:
break|break;
case|case
name|MLD_REPORTING_MEMBER
case|:
case|case
name|MLD_IDLE_MEMBER
case|:
case|case
name|MLD_LAZY_MEMBER
case|:
case|case
name|MLD_SLEEPING_MEMBER
case|:
case|case
name|MLD_AWAKENING_MEMBER
case|:
name|inm
operator|->
name|in6m_state
operator|=
name|MLD_REPORTING_MEMBER
expr_stmt|;
name|retval
operator|=
name|mld_v2_enqueue_group_record
argument_list|(
operator|&
name|mli
operator|->
name|mli_gq
argument_list|,
name|inm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: enqueue record = %d"
argument_list|,
name|__func__
argument_list|,
name|retval
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLD_G_QUERY_PENDING_MEMBER
case|:
case|case
name|MLD_SG_QUERY_PENDING_MEMBER
case|:
case|case
name|MLD_LEAVING_MEMBER
case|:
break|break;
block|}
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mld_dispatch_queue
argument_list|(
operator|&
name|mli
operator|->
name|mli_gq
argument_list|,
name|MLD_MAX_RESPONSE_BURST
argument_list|)
expr_stmt|;
comment|/* 	 * Slew transmission of bursts over 500ms intervals. 	 */
if|if
condition|(
name|mli
operator|->
name|mli_gq
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
block|{
name|mli
operator|->
name|mli_v2_timer
operator|=
literal|1
operator|+
name|MLD_RANDOM_DELAY
argument_list|(
name|MLD_RESPONSE_BURST_INTERVAL
argument_list|)
expr_stmt|;
name|V_interface_timers_running6
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Transmit the next pending message in the output queue.  *  * VIMAGE: Needs to store/restore vnet pointer on a per-mbuf-chain basis.  * MRT: Nothing needs to be done, as MLD traffic is always local to  * a link and uses a link-scope multicast address.  */
end_comment

begin_function
specifier|static
name|void
name|mld_dispatch_packet
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ip6_moptions
name|im6o
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|oifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|mld_hdr
modifier|*
name|mld
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|type
decl_stmt|;
name|uint32_t
name|ifindex
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: transmit %p"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Set VNET image pointer from enqueued mbuf chain 	 * before doing anything else. Whilst we use interface 	 * indexes to guard against interface detach, they are 	 * unique to each VIMAGE and must be retrieved. 	 */
name|ifindex
operator|=
name|mld_restore_context
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the ifnet still exists. This limits the scope of 	 * any race in the absence of a global ifp lock for low cost 	 * (an array lookup). 	 */
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: dropped %p as ifindex %u went away."
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|ifindex
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IP6STAT_INC
argument_list|(
name|ip6s_noroute
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|im6o
operator|.
name|im6o_multicast_hlim
operator|=
literal|1
expr_stmt|;
name|im6o
operator|.
name|im6o_multicast_loop
operator|=
operator|(
name|V_ip6_mrouter
operator|!=
name|NULL
operator|)
expr_stmt|;
name|im6o
operator|.
name|im6o_multicast_ifp
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_MLDV1
condition|)
block|{
name|m0
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|m0
operator|=
name|mld_v2_encap_report
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: dropped %p"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IP6STAT_INC
argument_list|(
name|ip6s_odropped
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|mld_scrub_context
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m_clrprotoflags
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|V_loif
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|(void)in6_setscope(&ip6->ip6_dst, ifp, NULL);
comment|/* XXX LOR */
else|#
directive|else
comment|/* 	 * XXX XXX Break some KPI rules to prevent an LOR which would 	 * occur if we called in6_setscope() at transmission. 	 * See comments at top of file. 	 */
name|MLD_EMBEDSCOPE
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|ifp
operator|->
name|if_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Retrieve the ICMPv6 type before handoff to ip6_output(), 	 * so we can bump the stats. 	 */
name|md
operator|=
name|m_getptr
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|mld
operator|=
operator|(
expr|struct
name|mld_hdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|md
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|type
operator|=
name|mld
operator|->
name|mld_type
expr_stmt|;
name|error
operator|=
name|ip6_output
argument_list|(
name|m0
argument_list|,
operator|&
name|mld_po
argument_list|,
name|NULL
argument_list|,
name|IPV6_UNSPECSRC
argument_list|,
operator|&
name|im6o
argument_list|,
operator|&
name|oifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: ip6_output(%p) = %d"
argument_list|,
name|__func__
argument_list|,
name|m0
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ICMP6STAT_INC
argument_list|(
name|icp6s_outhist
index|[
name|type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|oifp
operator|!=
name|NULL
condition|)
block|{
name|icmp6_ifstat_inc
argument_list|(
name|oifp
argument_list|,
name|ifs6_out_msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MLD_LISTENER_REPORT
case|:
case|case
name|MLDV2_LISTENER_REPORT
case|:
name|icmp6_ifstat_inc
argument_list|(
name|oifp
argument_list|,
name|ifs6_out_mldreport
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLD_LISTENER_DONE
case|:
name|icmp6_ifstat_inc
argument_list|(
name|oifp
argument_list|,
name|ifs6_out_mlddone
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
return|return;
block|}
end_function

begin_comment
comment|/*  * Encapsulate an MLDv2 report.  *  * KAME IPv6 requires that hop-by-hop options be passed separately,  * and that the IPv6 header be prepended in a separate mbuf.  *  * Returns a pointer to the new mbuf chain head, or NULL if the  * allocation failed.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|mld_v2_encap_report
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mh
decl_stmt|;
name|struct
name|mldv2_report
modifier|*
name|mld
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia
decl_stmt|;
name|int
name|mldreclen
decl_stmt|;
name|KASSERT
argument_list|(
name|ifp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: null ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
argument_list|,
operator|(
literal|"%s: mbuf chain %p is !M_PKTHDR"
operator|,
name|__func__
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * RFC3590: OK to send as :: or tentative during DAD. 	 */
name|ia
operator|=
name|in6ifa_ifpforlinklocal
argument_list|(
name|ifp
argument_list|,
name|IN6_IFF_NOTREADY
operator||
name|IN6_IFF_ANYCAST
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|==
name|NULL
condition|)
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: warning: ia is NULL"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mh
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|MH_ALIGN
argument_list|(
name|mh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_report
argument_list|)
argument_list|)
expr_stmt|;
name|mldreclen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: mldreclen is %d"
argument_list|,
name|__func__
argument_list|,
name|mldreclen
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_report
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_report
argument_list|)
operator|+
name|mldreclen
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|mh
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|ip6
operator|->
name|ip6_flow
operator|=
literal|0
expr_stmt|;
name|ip6
operator|->
name|ip6_vfc
operator|&=
operator|~
name|IPV6_VERSION_MASK
expr_stmt|;
name|ip6
operator|->
name|ip6_vfc
operator||=
name|IPV6_VERSION
expr_stmt|;
name|ip6
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_ICMPV6
expr_stmt|;
name|ip6
operator|->
name|ip6_src
operator|=
name|ia
condition|?
name|ia
operator|->
name|ia_addr
operator|.
name|sin6_addr
else|:
name|in6addr_any
expr_stmt|;
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
name|ip6
operator|->
name|ip6_dst
operator|=
name|in6addr_linklocal_allv2routers
expr_stmt|;
comment|/* scope ID will be set in netisr */
name|mld
operator|=
operator|(
expr|struct
name|mldv2_report
operator|*
operator|)
operator|(
name|ip6
operator|+
literal|1
operator|)
expr_stmt|;
name|mld
operator|->
name|mld_type
operator|=
name|MLDV2_LISTENER_REPORT
expr_stmt|;
name|mld
operator|->
name|mld_code
operator|=
literal|0
expr_stmt|;
name|mld
operator|->
name|mld_cksum
operator|=
literal|0
expr_stmt|;
name|mld
operator|->
name|mld_v2_reserved
operator|=
literal|0
expr_stmt|;
name|mld
operator|->
name|mld_v2_numrecs
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_vt
operator|.
name|vt_nrecs
operator|=
literal|0
expr_stmt|;
name|mh
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|mld
operator|->
name|mld_cksum
operator|=
name|in6_cksum
argument_list|(
name|mh
argument_list|,
name|IPPROTO_ICMPV6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mldv2_report
argument_list|)
operator|+
name|mldreclen
argument_list|)
expr_stmt|;
return|return
operator|(
name|mh
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_function
specifier|static
name|char
modifier|*
name|mld_rec_type_to_str
parameter_list|(
specifier|const
name|int
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MLD_CHANGE_TO_EXCLUDE_MODE
case|:
return|return
literal|"TO_EX"
return|;
break|break;
case|case
name|MLD_CHANGE_TO_INCLUDE_MODE
case|:
return|return
literal|"TO_IN"
return|;
break|break;
case|case
name|MLD_MODE_IS_EXCLUDE
case|:
return|return
literal|"MODE_EX"
return|;
break|break;
case|case
name|MLD_MODE_IS_INCLUDE
case|:
return|return
literal|"MODE_IN"
return|;
break|break;
case|case
name|MLD_ALLOW_NEW_SOURCES
case|:
return|return
literal|"ALLOW_NEW"
return|;
break|break;
case|case
name|MLD_BLOCK_OLD_SOURCES
case|:
return|return
literal|"BLOCK_OLD"
return|;
break|break;
default|default:
break|break;
block|}
return|return
literal|"unknown"
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|mld_init
parameter_list|(
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: initializing"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|MLD_LOCK_INIT
argument_list|()
expr_stmt|;
name|ip6_initpktopts
argument_list|(
operator|&
name|mld_po
argument_list|)
expr_stmt|;
name|mld_po
operator|.
name|ip6po_hlim
operator|=
literal|1
expr_stmt|;
name|mld_po
operator|.
name|ip6po_hbh
operator|=
operator|&
name|mld_ra
operator|.
name|hbh
expr_stmt|;
name|mld_po
operator|.
name|ip6po_prefer_tempaddr
operator|=
name|IP6PO_TEMPADDR_NOTPREFER
expr_stmt|;
name|mld_po
operator|.
name|ip6po_flags
operator|=
name|IP6PO_DONTFRAG
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|mld_init
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|mld_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|mld_uninit
parameter_list|(
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: tearing down"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|MLD_LOCK_DESTROY
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|mld_uninit
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|mld_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|vnet_mld_init
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: initializing"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|V_mli_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSINIT
argument_list|(
name|vnet_mld_init
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|vnet_mld_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|vnet_mld_uninit
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_MLD
argument_list|,
literal|"%s: tearing down"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|V_mli_head
argument_list|)
argument_list|,
operator|(
literal|"%s: mli list not empty; ifnets not detached?"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSUNINIT
argument_list|(
name|vnet_mld_uninit
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|vnet_mld_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mld_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
case|case
name|MOD_UNLOAD
case|:
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|mld_mod
init|=
block|{
literal|"mld"
block|,
name|mld_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|mld
argument_list|,
name|mld_mod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

