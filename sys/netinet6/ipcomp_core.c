begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$KAME: ipcomp_core.c,v 1.12 2000/05/05 11:01:01 sumikawa Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1999 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * RFC2393 IP payload compression protocol (IPComp).  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/zlib.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ipcomp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipcomp6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet6/ipsec.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<net/net_osdep.h>
end_include

begin_decl_stmt
specifier|static
name|void
modifier|*
name|deflate_alloc
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|u_int
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|deflate_free
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|deflate_common
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|size_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|deflate_compress
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|deflate_decompress
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We need to use default window size (2^15 = 32Kbytes as of writing) for  * inbound case.  Otherwise we get interop problem.  * Use negative value to avoid Adler32 checksum.  This is an undocumented  * feature in zlib (see ipsec wg mailing list archive in January 2000).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deflate_policy
init|=
name|Z_DEFAULT_COMPRESSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|deflate_window_out
init|=
operator|-
literal|12
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|deflate_window_in
init|=
operator|-
literal|1
operator|*
name|MAX_WBITS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't change it */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deflate_memlevel
init|=
name|MAX_MEM_LEVEL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ipcomp_algorithm
name|ipcomp_algorithms
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|,
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
operator|-
literal|1
block|}
block|,
block|{
name|deflate_compress
block|,
name|deflate_decompress
block|,
literal|90
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|90
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|deflate_alloc
parameter_list|(
name|aux
parameter_list|,
name|items
parameter_list|,
name|siz
parameter_list|)
name|void
modifier|*
name|aux
decl_stmt|;
name|u_int
name|items
decl_stmt|;
name|u_int
name|siz
decl_stmt|;
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|MALLOC
argument_list|(
name|ptr
argument_list|,
name|void
operator|*
argument_list|,
name|items
operator|*
name|siz
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|deflate_free
parameter_list|(
name|aux
parameter_list|,
name|ptr
parameter_list|)
name|void
modifier|*
name|aux
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
name|FREE
argument_list|(
name|ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|deflate_common
parameter_list|(
name|m
parameter_list|,
name|md
parameter_list|,
name|lenp
parameter_list|,
name|mode
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|size_t
modifier|*
name|lenp
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* 0: compress 1: decompress */
block|{
name|struct
name|mbuf
modifier|*
name|mprev
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|p
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|,
modifier|*
name|n0
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|np
decl_stmt|;
name|z_stream
name|zs
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|zerror
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|int
name|firsttime
decl_stmt|,
name|final
decl_stmt|,
name|flush
decl_stmt|;
for|for
control|(
name|mprev
operator|=
name|m
init|;
name|mprev
operator|&&
name|mprev
operator|->
name|m_next
operator|!=
name|md
condition|;
name|mprev
operator|=
name|mprev
operator|->
name|m_next
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|mprev
condition|)
name|panic
argument_list|(
literal|"md is not in m in deflate_common"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|zs
argument_list|,
sizeof|sizeof
argument_list|(
name|zs
argument_list|)
argument_list|)
expr_stmt|;
name|zs
operator|.
name|zalloc
operator|=
name|deflate_alloc
expr_stmt|;
name|zs
operator|.
name|zfree
operator|=
name|deflate_free
expr_stmt|;
name|zerror
operator|=
name|mode
condition|?
name|inflateInit2
argument_list|(
operator|&
name|zs
argument_list|,
name|deflate_window_in
argument_list|)
else|:
name|deflateInit2
argument_list|(
operator|&
name|zs
argument_list|,
name|deflate_policy
argument_list|,
name|Z_DEFLATED
argument_list|,
name|deflate_window_out
argument_list|,
name|deflate_memlevel
argument_list|,
name|Z_DEFAULT_STRATEGY
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerror
operator|!=
name|Z_OK
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|n0
operator|=
name|n
operator|=
name|NULL
expr_stmt|;
name|np
operator|=
operator|&
name|n0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|firsttime
operator|=
literal|1
expr_stmt|;
name|final
operator|=
literal|0
expr_stmt|;
name|flush
operator|=
name|Z_NO_FLUSH
expr_stmt|;
name|zerror
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|md
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 		 * first time, we need to setup the buffer before calling 		 * compression function. 		 */
if|if
condition|(
name|firsttime
condition|)
name|firsttime
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|zerror
operator|=
name|mode
condition|?
name|inflate
argument_list|(
operator|&
name|zs
argument_list|,
name|flush
argument_list|)
else|:
name|deflate
argument_list|(
operator|&
name|zs
argument_list|,
name|flush
argument_list|)
expr_stmt|;
block|}
comment|/* get input buffer */
if|if
condition|(
name|p
operator|&&
name|zs
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|zs
operator|.
name|next_in
operator|=
name|mtod
argument_list|(
name|p
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|zs
operator|.
name|avail_in
operator|=
name|p
operator|->
name|m_len
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|final
operator|=
literal|1
expr_stmt|;
name|flush
operator|=
name|Z_PARTIAL_FLUSH
expr_stmt|;
block|}
block|}
comment|/* get output buffer */
if|if
condition|(
name|zs
operator|.
name|next_out
operator|==
name|NULL
operator|||
name|zs
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
comment|/* keep the reply buffer into our chain */
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|m_len
operator|=
name|zs
operator|.
name|total_out
operator|-
name|offset
expr_stmt|;
name|offset
operator|=
name|zs
operator|.
name|total_out
expr_stmt|;
operator|*
name|np
operator|=
name|n
expr_stmt|;
name|np
operator|=
operator|&
name|n
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* get a fresh reply buffer */
name|MGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|n
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * if this is the first reply buffer, reserve 			 * region for ipcomp header. 			 */
if|if
condition|(
operator|*
name|np
operator|==
name|NULL
condition|)
block|{
name|n
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ipcomp
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ipcomp
argument_list|)
expr_stmt|;
block|}
name|zs
operator|.
name|next_out
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|zs
operator|.
name|avail_out
operator|=
name|n
operator|->
name|m_len
expr_stmt|;
block|}
if|if
condition|(
name|zerror
operator|==
name|Z_OK
condition|)
block|{
comment|/* 			 * to terminate deflate/inflate process, we need to 			 * call {in,de}flate() with different flushing methods. 			 * 			 * deflate() needs at least one Z_PARTIAL_FLUSH, 			 * then use Z_FINISH until we get to the end. 			 * (if we use Z_FLUSH without Z_PARTIAL_FLUSH, deflate() 			 * will assume contiguous single output buffer, and that 			 * is not what we want) 			 * inflate() does not care about flushing method, but 			 * needs output buffer until it gets to the end. 			 * 			 * the most outer loop will be terminated with 			 * Z_STREAM_END. 			 */
if|if
condition|(
name|final
operator|==
literal|1
condition|)
block|{
comment|/* reached end of mbuf chain */
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|final
operator|=
literal|2
expr_stmt|;
else|else
name|final
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|final
operator|==
literal|2
condition|)
block|{
comment|/* terminate deflate case */
name|flush
operator|=
name|Z_FINISH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|final
operator|==
literal|3
condition|)
block|{
comment|/* terminate inflate case */
empty_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|zerror
operator|==
name|Z_STREAM_END
condition|)
break|break;
else|else
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_ERR
operator|,
literal|"ipcomp_%scompress: %sflate: %s\n"
operator|,
name|mode
condition|?
literal|"de"
else|:
literal|""
operator|,
name|mode
condition|?
literal|"in"
else|:
literal|"de"
operator|,
name|zs
operator|.
name|msg
condition|?
name|zs
operator|.
name|msg
else|:
literal|"unknown error"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|zerror
operator|=
name|mode
condition|?
name|inflateEnd
argument_list|(
operator|&
name|zs
argument_list|)
else|:
name|deflateEnd
argument_list|(
operator|&
name|zs
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerror
operator|!=
name|Z_OK
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_ERR
operator|,
literal|"ipcomp_%scompress: %sflate: %s\n"
operator|,
name|mode
condition|?
literal|"de"
else|:
literal|""
operator|,
name|mode
condition|?
literal|"in"
else|:
literal|"de"
operator|,
name|zs
operator|.
name|msg
condition|?
name|zs
operator|.
name|msg
else|:
literal|"unknown error"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* keep the final reply buffer into our chain */
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|m_len
operator|=
name|zs
operator|.
name|total_out
operator|-
name|offset
expr_stmt|;
name|offset
operator|=
name|zs
operator|.
name|total_out
expr_stmt|;
operator|*
name|np
operator|=
name|n
expr_stmt|;
name|np
operator|=
operator|&
name|n
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* switch the mbuf to the new one */
name|mprev
operator|->
name|m_next
operator|=
name|n0
expr_stmt|;
name|m_freem
argument_list|(
name|md
argument_list|)
expr_stmt|;
operator|*
name|lenp
operator|=
name|zs
operator|.
name|total_out
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|n0
condition|)
name|m_freem
argument_list|(
name|n0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|deflate_compress
parameter_list|(
name|m
parameter_list|,
name|md
parameter_list|,
name|lenp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|size_t
modifier|*
name|lenp
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|m
condition|)
name|panic
argument_list|(
literal|"m == NULL in deflate_compress"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|md
condition|)
name|panic
argument_list|(
literal|"md == NULL in deflate_compress"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lenp
condition|)
name|panic
argument_list|(
literal|"lenp == NULL in deflate_compress"
argument_list|)
expr_stmt|;
return|return
name|deflate_common
argument_list|(
name|m
argument_list|,
name|md
argument_list|,
name|lenp
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|deflate_decompress
parameter_list|(
name|m
parameter_list|,
name|md
parameter_list|,
name|lenp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|size_t
modifier|*
name|lenp
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|m
condition|)
name|panic
argument_list|(
literal|"m == NULL in deflate_decompress"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|md
condition|)
name|panic
argument_list|(
literal|"md == NULL in deflate_decompress"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lenp
condition|)
name|panic
argument_list|(
literal|"lenp == NULL in deflate_decompress"
argument_list|)
expr_stmt|;
return|return
name|deflate_common
argument_list|(
name|m
argument_list|,
name|md
argument_list|,
name|lenp
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

end_unit

