begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$KAME: ipcomp_core.c,v 1.25 2001/07/26 06:53:17 jinmei Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1999 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * RFC2393 IP payload compression protocol (IPComp).  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/zlib.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ipcomp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipcomp6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet6/ipsec.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<net/net_osdep.h>
end_include

begin_decl_stmt
specifier|static
name|void
modifier|*
name|deflate_alloc
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|u_int
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|deflate_free
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|deflate_common
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|size_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|deflate_compress
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|deflate_decompress
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We need to use default window size (2^15 = 32Kbytes as of writing) for  * inbound case.  Otherwise we get interop problem.  * Use negative value to avoid Adler32 checksum.  This is an undocumented  * feature in zlib (see ipsec wg mailing list archive in January 2000).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deflate_policy
init|=
name|Z_DEFAULT_COMPRESSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|deflate_window_out
init|=
operator|-
literal|12
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|deflate_window_in
init|=
operator|-
literal|1
operator|*
name|MAX_WBITS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't change it */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deflate_memlevel
init|=
name|MAX_MEM_LEVEL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ipcomp_algorithm
name|ipcomp_algorithms
index|[]
init|=
block|{
block|{
name|deflate_compress
block|,
name|deflate_decompress
block|,
literal|90
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|struct
name|ipcomp_algorithm
modifier|*
name|ipcomp_algorithm_lookup
parameter_list|(
name|idx
parameter_list|)
name|int
name|idx
decl_stmt|;
block|{
if|if
condition|(
name|idx
operator|==
name|SADB_X_CALG_DEFLATE
condition|)
return|return
operator|&
name|ipcomp_algorithms
index|[
literal|0
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|deflate_alloc
parameter_list|(
name|aux
parameter_list|,
name|items
parameter_list|,
name|siz
parameter_list|)
name|void
modifier|*
name|aux
decl_stmt|;
name|u_int
name|items
decl_stmt|;
name|u_int
name|siz
decl_stmt|;
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|malloc
argument_list|(
name|items
operator|*
name|siz
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|deflate_free
parameter_list|(
name|aux
parameter_list|,
name|ptr
parameter_list|)
name|void
modifier|*
name|aux
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
name|free
argument_list|(
name|ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|deflate_common
parameter_list|(
name|m
parameter_list|,
name|md
parameter_list|,
name|lenp
parameter_list|,
name|mode
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|size_t
modifier|*
name|lenp
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* 0: compress 1: decompress */
block|{
name|struct
name|mbuf
modifier|*
name|mprev
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|p
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
init|=
name|NULL
decl_stmt|,
modifier|*
name|n0
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|np
decl_stmt|;
name|z_stream
name|zs
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|zerror
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
define|#
directive|define
name|MOREBLOCK
parameter_list|()
define|\
value|do { \
comment|/* keep the reply buffer into our chain */
value|\ 	if (n) {						\ 		n->m_len = zs.total_out - offset;		\ 		offset = zs.total_out;				\ 		*np = n;					\ 		np =&n->m_next;				\ 		n = NULL;					\ 	}							\ 								\
comment|/* get a fresh reply buffer */
value|\ 	MGET(n, M_DONTWAIT, MT_DATA);				\ 	if (n) {						\ 		MCLGET(n, M_DONTWAIT);				\ 	}							\ 	if (!n) {						\ 		error = ENOBUFS;				\ 		goto fail;					\ 	}							\ 	n->m_len = 0;						\ 	n->m_len = M_TRAILINGSPACE(n);				\ 	n->m_next = NULL;					\
comment|/* 							\ 	 * if this is the first reply buffer, reserve		\ 	 * region for ipcomp header.				\ 	 */
value|\ 	if (*np == NULL) {					\ 		n->m_len -= sizeof(struct ipcomp);		\ 		n->m_data += sizeof(struct ipcomp);		\ 	}							\ 								\ 	zs.next_out = mtod(n, u_int8_t *);			\ 	zs.avail_out = n->m_len;				\ } while (0)
for|for
control|(
name|mprev
operator|=
name|m
init|;
name|mprev
operator|&&
name|mprev
operator|->
name|m_next
operator|!=
name|md
condition|;
name|mprev
operator|=
name|mprev
operator|->
name|m_next
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|mprev
condition|)
name|panic
argument_list|(
literal|"md is not in m in deflate_common"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|zs
argument_list|,
sizeof|sizeof
argument_list|(
name|zs
argument_list|)
argument_list|)
expr_stmt|;
name|zs
operator|.
name|zalloc
operator|=
name|deflate_alloc
expr_stmt|;
name|zs
operator|.
name|zfree
operator|=
name|deflate_free
expr_stmt|;
name|zerror
operator|=
name|mode
condition|?
name|inflateInit2
argument_list|(
operator|&
name|zs
argument_list|,
name|deflate_window_in
argument_list|)
else|:
name|deflateInit2
argument_list|(
operator|&
name|zs
argument_list|,
name|deflate_policy
argument_list|,
name|Z_DEFLATED
argument_list|,
name|deflate_window_out
argument_list|,
name|deflate_memlevel
argument_list|,
name|Z_DEFAULT_STRATEGY
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerror
operator|!=
name|Z_OK
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|n0
operator|=
name|n
operator|=
name|NULL
expr_stmt|;
name|np
operator|=
operator|&
name|n0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|zerror
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|md
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* input stream and output stream are available */
while|while
condition|(
name|p
operator|&&
name|zs
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
comment|/* get input buffer */
if|if
condition|(
name|p
operator|&&
name|zs
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|zs
operator|.
name|next_in
operator|=
name|mtod
argument_list|(
name|p
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|zs
operator|.
name|avail_in
operator|=
name|p
operator|->
name|m_len
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|m_next
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|m_next
expr_stmt|;
block|}
block|}
comment|/* get output buffer */
if|if
condition|(
name|zs
operator|.
name|next_out
operator|==
name|NULL
operator|||
name|zs
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
name|MOREBLOCK
argument_list|()
expr_stmt|;
block|}
name|zerror
operator|=
name|mode
condition|?
name|inflate
argument_list|(
operator|&
name|zs
argument_list|,
name|Z_NO_FLUSH
argument_list|)
else|:
name|deflate
argument_list|(
operator|&
name|zs
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerror
operator|==
name|Z_STREAM_END
condition|)
empty_stmt|;
comment|/* once more. */
elseif|else
if|if
condition|(
name|zerror
operator|==
name|Z_OK
condition|)
block|{
comment|/* inflate: Z_OK can indicate the end of decode */
if|if
condition|(
name|mode
operator|&&
operator|!
name|p
operator|&&
name|zs
operator|.
name|avail_out
operator|!=
literal|0
condition|)
goto|goto
name|terminate
goto|;
else|else
empty_stmt|;
comment|/* once more. */
block|}
else|else
block|{
if|if
condition|(
name|zs
operator|.
name|msg
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_ERR
operator|,
literal|"ipcomp_%scompress: "
literal|"%sflate(Z_NO_FLUSH): %s\n"
operator|,
name|mode
condition|?
literal|"de"
else|:
literal|""
operator|,
name|mode
condition|?
literal|"in"
else|:
literal|"de"
operator|,
name|zs
operator|.
name|msg
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_ERR
operator|,
literal|"ipcomp_%scompress: "
literal|"%sflate(Z_NO_FLUSH): unknown error (%d)\n"
operator|,
name|mode
condition|?
literal|"de"
else|:
literal|""
operator|,
name|mode
condition|?
literal|"in"
else|:
literal|"de"
operator|,
name|zerror
operator|)
argument_list|)
expr_stmt|;
block|}
name|mode
condition|?
name|inflateEnd
argument_list|(
operator|&
name|zs
argument_list|)
else|:
name|deflateEnd
argument_list|(
operator|&
name|zs
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
name|zerror
operator|==
name|Z_STREAM_END
condition|)
goto|goto
name|terminate
goto|;
comment|/* termination */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* get output buffer */
if|if
condition|(
name|zs
operator|.
name|next_out
operator|==
name|NULL
operator|||
name|zs
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
name|MOREBLOCK
argument_list|()
expr_stmt|;
block|}
name|zerror
operator|=
name|mode
condition|?
name|inflate
argument_list|(
operator|&
name|zs
argument_list|,
name|Z_SYNC_FLUSH
argument_list|)
else|:
name|deflate
argument_list|(
operator|&
name|zs
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerror
operator|==
name|Z_STREAM_END
condition|)
break|break;
elseif|else
if|if
condition|(
name|zerror
operator|==
name|Z_OK
condition|)
block|{
if|if
condition|(
name|mode
operator|&&
name|zs
operator|.
name|avail_out
operator|!=
literal|0
condition|)
goto|goto
name|terminate
goto|;
else|else
empty_stmt|;
comment|/* once more. */
block|}
else|else
block|{
if|if
condition|(
name|zs
operator|.
name|msg
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_ERR
operator|,
literal|"ipcomp_%scompress: "
literal|"%sflate(Z_FINISH): %s\n"
operator|,
name|mode
condition|?
literal|"de"
else|:
literal|""
operator|,
name|mode
condition|?
literal|"in"
else|:
literal|"de"
operator|,
name|zs
operator|.
name|msg
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_ERR
operator|,
literal|"ipcomp_%scompress: "
literal|"%sflate(Z_FINISH): unknown error (%d)\n"
operator|,
name|mode
condition|?
literal|"de"
else|:
literal|""
operator|,
name|mode
condition|?
literal|"in"
else|:
literal|"de"
operator|,
name|zerror
operator|)
argument_list|)
expr_stmt|;
block|}
name|mode
condition|?
name|inflateEnd
argument_list|(
operator|&
name|zs
argument_list|)
else|:
name|deflateEnd
argument_list|(
operator|&
name|zs
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|terminate
label|:
name|zerror
operator|=
name|mode
condition|?
name|inflateEnd
argument_list|(
operator|&
name|zs
argument_list|)
else|:
name|deflateEnd
argument_list|(
operator|&
name|zs
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerror
operator|!=
name|Z_OK
condition|)
block|{
if|if
condition|(
name|zs
operator|.
name|msg
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_ERR
operator|,
literal|"ipcomp_%scompress: "
literal|"%sflateEnd: %s\n"
operator|,
name|mode
condition|?
literal|"de"
else|:
literal|""
operator|,
name|mode
condition|?
literal|"in"
else|:
literal|"de"
operator|,
name|zs
operator|.
name|msg
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_ERR
operator|,
literal|"ipcomp_%scompress: "
literal|"%sflateEnd: unknown error (%d)\n"
operator|,
name|mode
condition|?
literal|"de"
else|:
literal|""
operator|,
name|mode
condition|?
literal|"in"
else|:
literal|"de"
operator|,
name|zerror
operator|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* keep the final reply buffer into our chain */
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|m_len
operator|=
name|zs
operator|.
name|total_out
operator|-
name|offset
expr_stmt|;
name|offset
operator|=
name|zs
operator|.
name|total_out
expr_stmt|;
operator|*
name|np
operator|=
name|n
expr_stmt|;
name|np
operator|=
operator|&
name|n
operator|->
name|m_next
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* switch the mbuf to the new one */
name|mprev
operator|->
name|m_next
operator|=
name|n0
expr_stmt|;
name|m_freem
argument_list|(
name|md
argument_list|)
expr_stmt|;
operator|*
name|lenp
operator|=
name|zs
operator|.
name|total_out
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n0
condition|)
name|m_freem
argument_list|(
name|n0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|MOREBLOCK
block|}
end_function

begin_function
specifier|static
name|int
name|deflate_compress
parameter_list|(
name|m
parameter_list|,
name|md
parameter_list|,
name|lenp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|size_t
modifier|*
name|lenp
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|m
condition|)
name|panic
argument_list|(
literal|"m == NULL in deflate_compress"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|md
condition|)
name|panic
argument_list|(
literal|"md == NULL in deflate_compress"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lenp
condition|)
name|panic
argument_list|(
literal|"lenp == NULL in deflate_compress"
argument_list|)
expr_stmt|;
return|return
name|deflate_common
argument_list|(
name|m
argument_list|,
name|md
argument_list|,
name|lenp
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|deflate_decompress
parameter_list|(
name|m
parameter_list|,
name|md
parameter_list|,
name|lenp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|size_t
modifier|*
name|lenp
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|m
condition|)
name|panic
argument_list|(
literal|"m == NULL in deflate_decompress"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|md
condition|)
name|panic
argument_list|(
literal|"md == NULL in deflate_decompress"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lenp
condition|)
name|panic
argument_list|(
literal|"lenp == NULL in deflate_decompress"
argument_list|)
expr_stmt|;
return|return
name|deflate_common
argument_list|(
name|m
argument_list|,
name|md
argument_list|,
name|lenp
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

end_unit

