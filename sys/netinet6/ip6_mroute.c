begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$KAME: ip6_mroute.c,v 1.58 2001/12/18 02:36:31 itojun Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (C) 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*	BSDI ip_mroute.c,v 2.10 1996/11/14 00:29:52 jch Exp	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1989 Stephen Deering  * Copyright (c) 1992, 1993  *      The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Stephen Deering of Stanford University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      @(#)ip_mroute.c 8.2 (Berkeley) 11/15/93  */
end_comment

begin_comment
comment|/*  * IP multicast forwarding procedures  *  * Written by David Waitzman, BBN Labs, August 1988.  * Modified by Steve Deering, Stanford, February 1989.  * Modified by Mark J. Steiglitz, Stanford, May, 1991  * Modified by Van Jacobson, LBL, January 1993  * Modified by Ajit Thyagarajan, PARC, August 1993  * Modified by Bill Fenner, PARC, April 1994  *  * MROUTING Revision: 3.5.1.2 + PIM-SMv2 (pimd) Support  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/raw_cb.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/scope6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_mroute.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6protosw.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/pim6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/pim6_var.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MRTABLE6
argument_list|,
literal|"mf6c"
argument_list|,
literal|"multicast forwarding cache entry"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|M_HASCL
parameter_list|(
name|m
parameter_list|)
value|((m)->m_flags& M_EXT)
end_define

begin_decl_stmt
specifier|static
name|int
name|ip6_mdq
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|mf6c
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|phyint_send
name|__P
argument_list|(
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|,
expr|struct
name|mif6
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_pim6
name|__P
argument_list|(
operator|(
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|socket_send
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|sockaddr_in6
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|register_send
name|__P
argument_list|(
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|,
expr|struct
name|mif6
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|inet6domain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX: referenced from ip_mroute.c for dynamically loading this code. */
end_comment

begin_decl_stmt
name|struct
name|ip6protosw
name|in6_pim_protosw
init|=
block|{
operator|.
name|pr_type
operator|=
name|SOCK_RAW
block|,
operator|.
name|pr_domain
operator|=
operator|&
name|inet6domain
block|,
operator|.
name|pr_protocol
operator|=
name|IPPROTO_PIM
block|,
operator|.
name|pr_flags
operator|=
name|PR_ATOMIC
operator||
name|PR_ADDR
operator||
name|PR_LASTHDR
block|,
operator|.
name|pr_input
operator|=
name|pim6_input
block|,
operator|.
name|pr_output
operator|=
name|rip6_output
block|,
operator|.
name|pr_ctloutput
operator|=
name|rip6_ctloutput
block|,
operator|.
name|pr_usrreqs
operator|=
operator|&
name|rip6_usrreqs
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip6_mrouter_ver
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet6
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet6_ip6
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet6
argument_list|,
name|IPPROTO_PIM
argument_list|,
name|pim
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"PIM"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mrt6stat
name|mrt6stat
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_net_inet6_ip6
argument_list|,
name|OID_AUTO
argument_list|,
name|mrt6stat
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mrt6stat
argument_list|,
name|mrt6stat
argument_list|,
literal|"Multicast Routing Statistics (struct mrt6stat, netinet6/ip6_mroute.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NO_RTE_FOUND
value|0x1
end_define

begin_define
define|#
directive|define
name|RTE_FOUND
value|0x2
end_define

begin_decl_stmt
specifier|static
name|struct
name|mf6c
modifier|*
name|mf6ctable
index|[
name|MF6CTBLSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_OPAQUE
argument_list|(
name|_net_inet6_ip6
argument_list|,
name|OID_AUTO
argument_list|,
name|mf6ctable
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mf6ctable
argument_list|,
sizeof|sizeof
argument_list|(
name|mf6ctable
argument_list|)
argument_list|,
literal|"S,*mf6ctable[MF6CTBLSIZ]"
argument_list|,
literal|"Multicast Forwarding Table (struct *mf6ctable[MF6CTBLSIZ], "
literal|"netinet6/ip6_mroute.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_char
name|n6expire
index|[
name|MF6CTBLSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mif6
name|mif6table
index|[
name|MAXMIFS
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_OPAQUE
argument_list|(
name|_net_inet6_ip6
argument_list|,
name|OID_AUTO
argument_list|,
name|mif6table
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mif6table
argument_list|,
sizeof|sizeof
argument_list|(
name|mif6table
argument_list|)
argument_list|,
literal|"S,vif[MAXMIFS]"
argument_list|,
literal|"Multicast Interfaces (struct mif[MAXMIFS], netinet6/ip6_mroute.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MRT6DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|u_int
name|mrt6debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug level */
end_comment

begin_define
define|#
directive|define
name|DEBUG_MFC
value|0x02
end_define

begin_define
define|#
directive|define
name|DEBUG_FORWARD
value|0x04
end_define

begin_define
define|#
directive|define
name|DEBUG_EXPIRE
value|0x08
end_define

begin_define
define|#
directive|define
name|DEBUG_XMIT
value|0x10
end_define

begin_define
define|#
directive|define
name|DEBUG_REG
value|0x20
end_define

begin_define
define|#
directive|define
name|DEBUG_PIM
value|0x40
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|expire_upcalls
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EXPIRE_TIMEOUT
value|(hz / 4)
end_define

begin_comment
comment|/* 4x / second */
end_comment

begin_define
define|#
directive|define
name|UPCALL_EXPIRE
value|6
end_define

begin_comment
comment|/* number of timeouts */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|MROUTING
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|socket
modifier|*
name|ip_mrouter
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * 'Interfaces' associated with decapsulator (so we can tell  * packets that went through it from ones that get reflected  * by a broken gateway).  Different from IPv4 register_if,  * these interfaces are linked into the system ifnet list,  * because per-interface IPv6 statistics are maintained in  * ifp->if_afdata.  But it does not have any routes point   * to them.  I.e., packets can't be sent this way.  They  * only exist as a placeholder for multicast source   * verification.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ifnet
modifier|*
name|multicast_register_if6
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ENCAP_HOPS
value|64
end_define

begin_comment
comment|/*  * Private variables.  */
end_comment

begin_decl_stmt
specifier|static
name|mifi_t
name|nummifs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mifi_t
name|reg_mif_num
init|=
operator|(
name|mifi_t
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pim6stat
name|pim6stat
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_net_inet6_pim
argument_list|,
name|PIM6CTL_STATS
argument_list|,
name|stats
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pim6stat
argument_list|,
name|pim6stat
argument_list|,
literal|"PIM Statistics (struct pim6stat, netinet6/pim_var.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pim6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Hash function for a source, group entry  */
end_comment

begin_define
define|#
directive|define
name|MF6CHASH
parameter_list|(
name|a
parameter_list|,
name|g
parameter_list|)
value|MF6CHASHMOD((a).s6_addr32[0] ^ (a).s6_addr32[1] ^ \ 				   (a).s6_addr32[2] ^ (a).s6_addr32[3] ^ \ 				   (g).s6_addr32[0] ^ (g).s6_addr32[1] ^ \ 				   (g).s6_addr32[2] ^ (g).s6_addr32[3])
end_define

begin_comment
comment|/*  * Find a route for a given origin IPv6 address and Multicast group address.  * Quality of service parameter to be added in the future!!!  */
end_comment

begin_define
define|#
directive|define
name|MF6CFIND
parameter_list|(
name|o
parameter_list|,
name|g
parameter_list|,
name|rt
parameter_list|)
value|do { \ 	struct mf6c *_rt = mf6ctable[MF6CHASH(o,g)]; \ 	rt = NULL; \ 	mrt6stat.mrt6s_mfc_lookups++; \ 	while (_rt) { \ 		if (IN6_ARE_ADDR_EQUAL(&_rt->mf6c_origin.sin6_addr,&(o))&& \ 		    IN6_ARE_ADDR_EQUAL(&_rt->mf6c_mcastgrp.sin6_addr,&(g))&& \ 		    (_rt->mf6c_stall == NULL)) { \ 			rt = _rt; \ 			break; \ 		} \ 		_rt = _rt->mf6c_next; \ 	} \ 	if (rt == NULL) { \ 		mrt6stat.mrt6s_mfc_misses++; \ 	} \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_comment
comment|/*  * Macros to compute elapsed time efficiently  * Borrowed from Van Jacobson's scheduling code  */
end_comment

begin_define
define|#
directive|define
name|TV_DELTA
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|delta
parameter_list|)
value|do { \ 	    int xxs; \ 		\ 	    delta = (a).tv_usec - (b).tv_usec; \ 	    if ((xxs = (a).tv_sec - (b).tv_sec)) { \ 	       switch (xxs) { \ 		      case 2: \ 			  delta += 1000000; \
comment|/* FALLTHROUGH */
value|\ 		      case 1: \ 			  delta += 1000000; \ 			  break; \ 		      default: \ 			  delta += (1000000 * xxs); \ 	       } \ 	    } \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|TV_LT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a).tv_usec< (b).tv_usec&& \ 	      (a).tv_sec<= (b).tv_sec) || (a).tv_sec< (b).tv_sec)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|UPCALL_TIMING
end_ifdef

begin_define
define|#
directive|define
name|UPCALL_MAX
value|50
end_define

begin_decl_stmt
specifier|static
name|u_long
name|upcall_data
index|[
name|UPCALL_MAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|collate
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UPCALL_TIMING */
end_comment

begin_decl_stmt
specifier|static
name|int
name|get_sg_cnt
name|__P
argument_list|(
operator|(
expr|struct
name|sioc_sg_req6
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_mif6_cnt
name|__P
argument_list|(
operator|(
expr|struct
name|sioc_mif_req6
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip6_mrouter_init
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_m6if
name|__P
argument_list|(
operator|(
expr|struct
name|mif6ctl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|del_m6if
name|__P
argument_list|(
operator|(
name|mifi_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_m6fc
name|__P
argument_list|(
operator|(
expr|struct
name|mf6cctl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|del_m6fc
name|__P
argument_list|(
operator|(
expr|struct
name|mf6cctl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout
name|expire_upcalls_ch
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|X_ip6_mforward
parameter_list|(
name|struct
name|ip6_hdr
modifier|*
name|ip6
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|X_ip6_mrouter_done
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|X_ip6_mrouter_set
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|X_ip6_mrouter_get
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|X_mrt6_ioctl
parameter_list|(
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Handle MRT setsockopt commands to modify the multicast routing tables.  */
end_comment

begin_function
name|int
name|X_ip6_mrouter_set
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|optval
decl_stmt|;
name|struct
name|mif6ctl
name|mifc
decl_stmt|;
name|struct
name|mf6cctl
name|mfcc
decl_stmt|;
name|mifi_t
name|mifi
decl_stmt|;
if|if
condition|(
name|so
operator|!=
name|ip6_mrouter
operator|&&
name|sopt
operator|->
name|sopt_name
operator|!=
name|MRT6_INIT
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|MRT6_INIT
case|:
ifdef|#
directive|ifdef
name|MRT6_OINIT
case|case
name|MRT6_OINIT
case|:
endif|#
directive|endif
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|ip6_mrouter_init
argument_list|(
name|so
argument_list|,
name|optval
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT6_DONE
case|:
name|error
operator|=
name|X_ip6_mrouter_done
argument_list|()
expr_stmt|;
break|break;
case|case
name|MRT6_ADD_MIF
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mifc
argument_list|,
sizeof|sizeof
argument_list|(
name|mifc
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|mifc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|add_m6if
argument_list|(
operator|&
name|mifc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT6_ADD_MFC
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mfcc
argument_list|,
sizeof|sizeof
argument_list|(
name|mfcc
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|mfcc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|add_m6fc
argument_list|(
operator|&
name|mfcc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT6_DEL_MFC
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mfcc
argument_list|,
sizeof|sizeof
argument_list|(
name|mfcc
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|mfcc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|del_m6fc
argument_list|(
operator|&
name|mfcc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT6_DEL_MIF
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mifi
argument_list|,
sizeof|sizeof
argument_list|(
name|mifi
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|mifi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|del_m6if
argument_list|(
operator|&
name|mifi
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT6_PIM
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|set_pim6
argument_list|(
operator|&
name|optval
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle MRT getsockopt commands  */
end_comment

begin_function
name|int
name|X_ip6_mrouter_get
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|so
operator|!=
name|ip6_mrouter
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|MRT6_PIM
case|:
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|pim6
argument_list|,
sizeof|sizeof
argument_list|(
name|pim6
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle ioctl commands to obtain information from the cache  */
end_comment

begin_function
name|int
name|X_mrt6_ioctl
parameter_list|(
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGETSGCNT_IN6
case|:
return|return
operator|(
name|get_sg_cnt
argument_list|(
operator|(
expr|struct
name|sioc_sg_req6
operator|*
operator|)
name|data
argument_list|)
operator|)
return|;
case|case
name|SIOCGETMIFCNT_IN6
case|:
return|return
operator|(
name|get_mif6_cnt
argument_list|(
operator|(
expr|struct
name|sioc_mif_req6
operator|*
operator|)
name|data
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * returns the packet, byte, rpf-failure count for the source group provided  */
end_comment

begin_function
specifier|static
name|int
name|get_sg_cnt
parameter_list|(
name|req
parameter_list|)
name|struct
name|sioc_sg_req6
modifier|*
name|req
decl_stmt|;
block|{
name|struct
name|mf6c
modifier|*
name|rt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|MF6CFIND
argument_list|(
name|req
operator|->
name|src
operator|.
name|sin6_addr
argument_list|,
name|req
operator|->
name|grp
operator|.
name|sin6_addr
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
name|req
operator|->
name|pktcnt
operator|=
name|rt
operator|->
name|mf6c_pkt_cnt
expr_stmt|;
name|req
operator|->
name|bytecnt
operator|=
name|rt
operator|->
name|mf6c_byte_cnt
expr_stmt|;
name|req
operator|->
name|wrong_if
operator|=
name|rt
operator|->
name|mf6c_wrong_if
expr_stmt|;
block|}
else|else
return|return
operator|(
name|ESRCH
operator|)
return|;
if|#
directive|if
literal|0
block|req->pktcnt = req->bytecnt = req->wrong_if = 0xffffffff;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns the input and output packet and byte counts on the mif provided  */
end_comment

begin_function
specifier|static
name|int
name|get_mif6_cnt
parameter_list|(
name|req
parameter_list|)
name|struct
name|sioc_mif_req6
modifier|*
name|req
decl_stmt|;
block|{
name|mifi_t
name|mifi
init|=
name|req
operator|->
name|mifi
decl_stmt|;
if|if
condition|(
name|mifi
operator|>=
name|nummifs
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|req
operator|->
name|icount
operator|=
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_pkt_in
expr_stmt|;
name|req
operator|->
name|ocount
operator|=
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_pkt_out
expr_stmt|;
name|req
operator|->
name|ibytes
operator|=
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_bytes_in
expr_stmt|;
name|req
operator|->
name|obytes
operator|=
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_bytes_out
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_pim6
parameter_list|(
name|i
parameter_list|)
name|int
modifier|*
name|i
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|i
operator|!=
literal|1
operator|)
operator|&&
operator|(
operator|*
name|i
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pim6
operator|=
operator|*
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable multicast routing  */
end_comment

begin_function
specifier|static
name|int
name|ip6_mrouter_init
parameter_list|(
name|so
parameter_list|,
name|v
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|v
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip6_mrouter_init: so_type = %d, pr_protocol = %d\n"
argument_list|,
name|so
operator|->
name|so_type
argument_list|,
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_RAW
operator|||
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_ICMPV6
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|v
operator|!=
literal|1
condition|)
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
if|if
condition|(
name|ip6_mrouter
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
name|ip6_mrouter
operator|=
name|so
expr_stmt|;
name|ip6_mrouter_ver
operator|=
name|cmd
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mf6ctable
argument_list|,
sizeof|sizeof
argument_list|(
name|mf6ctable
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|n6expire
argument_list|,
sizeof|sizeof
argument_list|(
name|n6expire
argument_list|)
argument_list|)
expr_stmt|;
name|pim6
operator|=
literal|0
expr_stmt|;
comment|/* used for stubbing out/in pim stuff */
name|callout_init
argument_list|(
operator|&
name|expire_upcalls_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|expire_upcalls_ch
argument_list|,
name|EXPIRE_TIMEOUT
argument_list|,
name|expire_upcalls
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip6_mrouter_init\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disable multicast routing  */
end_comment

begin_function
name|int
name|X_ip6_mrouter_done
parameter_list|(
name|void
parameter_list|)
block|{
name|mifi_t
name|mifi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|mf6c
modifier|*
name|rt
decl_stmt|;
name|struct
name|rtdetq
modifier|*
name|rte
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* 	 * For each phyint in use, disable promiscuous reception of all IPv6 	 * multicasts. 	 */
ifdef|#
directive|ifdef
name|INET
ifdef|#
directive|ifdef
name|MROUTING
comment|/* 	 * If there is still IPv4 multicast routing daemon, 	 * we remain interfaces to receive all muliticasted packets. 	 * XXX: there may be an interface in which the IPv4 multicast 	 * daemon is not interested... 	 */
if|if
condition|(
operator|!
name|ip_mrouter
condition|)
endif|#
directive|endif
endif|#
directive|endif
block|{
for|for
control|(
name|mifi
operator|=
literal|0
init|;
name|mifi
operator|<
name|nummifs
condition|;
name|mifi
operator|++
control|)
block|{
if|if
condition|(
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_ifp
operator|&&
operator|!
operator|(
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_flags
operator|&
name|MIFF_REGISTER
operator|)
condition|)
block|{
name|if_allmulti
argument_list|(
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|notyet
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|qtable
argument_list|,
sizeof|sizeof
argument_list|(
name|qtable
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|tbftable
argument_list|,
sizeof|sizeof
argument_list|(
name|tbftable
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mif6table
argument_list|,
sizeof|sizeof
argument_list|(
name|mif6table
argument_list|)
argument_list|)
expr_stmt|;
name|nummifs
operator|=
literal|0
expr_stmt|;
name|pim6
operator|=
literal|0
expr_stmt|;
comment|/* used to stub out/in pim specific code */
name|callout_stop
argument_list|(
operator|&
name|expire_upcalls_ch
argument_list|)
expr_stmt|;
comment|/* 	 * Free all multicast forwarding cache entries. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MF6CTBLSIZ
condition|;
name|i
operator|++
control|)
block|{
name|rt
operator|=
name|mf6ctable
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|rt
condition|)
block|{
name|struct
name|mf6c
modifier|*
name|frt
decl_stmt|;
for|for
control|(
name|rte
operator|=
name|rt
operator|->
name|mf6c_stall
init|;
name|rte
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|rtdetq
modifier|*
name|n
init|=
name|rte
operator|->
name|next
decl_stmt|;
name|m_free
argument_list|(
name|rte
operator|->
name|m
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE6
argument_list|)
expr_stmt|;
name|rte
operator|=
name|n
expr_stmt|;
block|}
name|frt
operator|=
name|rt
expr_stmt|;
name|rt
operator|=
name|rt
operator|->
name|mf6c_next
expr_stmt|;
name|free
argument_list|(
name|frt
argument_list|,
name|M_MRTABLE6
argument_list|)
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mf6ctable
argument_list|,
sizeof|sizeof
argument_list|(
name|mf6ctable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Reset register interface 	 */
if|if
condition|(
name|reg_mif_num
operator|!=
operator|(
name|mifi_t
operator|)
operator|-
literal|1
operator|&&
name|multicast_register_if6
operator|!=
name|NULL
condition|)
block|{
name|if_detach
argument_list|(
name|multicast_register_if6
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|multicast_register_if6
argument_list|)
expr_stmt|;
name|reg_mif_num
operator|=
operator|(
name|mifi_t
operator|)
operator|-
literal|1
expr_stmt|;
name|multicast_register_if6
operator|=
name|NULL
expr_stmt|;
block|}
name|ip6_mrouter
operator|=
name|NULL
expr_stmt|;
name|ip6_mrouter_ver
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip6_mrouter_done\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in6
name|sin6
init|=
block|{
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Add a mif to the mif table  */
end_comment

begin_function
specifier|static
name|int
name|add_m6if
parameter_list|(
name|mifcp
parameter_list|)
name|struct
name|mif6ctl
modifier|*
name|mifcp
decl_stmt|;
block|{
name|struct
name|mif6
modifier|*
name|mifp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|struct
name|tbf
modifier|*
name|m_tbf
init|=
name|tbftable
operator|+
name|mifcp
operator|->
name|mif6c_mifi
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mifcp
operator|->
name|mif6c_mifi
operator|>=
name|MAXMIFS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mifp
operator|=
name|mif6table
operator|+
name|mifcp
operator|->
name|mif6c_mifi
expr_stmt|;
if|if
condition|(
name|mifp
operator|->
name|m6_ifp
condition|)
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
comment|/* XXX: is it appropriate? */
if|if
condition|(
name|mifcp
operator|->
name|mif6c_pifi
operator|==
literal|0
operator|||
name|mifcp
operator|->
name|mif6c_pifi
operator|>
name|if_index
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|mifcp
operator|->
name|mif6c_pifi
argument_list|)
expr_stmt|;
if|if
condition|(
name|mifcp
operator|->
name|mif6c_flags
operator|&
name|MIFF_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_mif_num
operator|==
operator|(
name|mifi_t
operator|)
operator|-
literal|1
condition|)
block|{
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_OTHER
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"register_mif"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_LOOPBACK
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|multicast_register_if6
operator|=
name|ifp
expr_stmt|;
name|reg_mif_num
operator|=
name|mifcp
operator|->
name|mif6c_mifi
expr_stmt|;
comment|/*  			 * it is impossible to guess the ifindex of the  			 * register interface.  So mif6c_pifi is automatically 			 * calculated. 			 */
name|mifcp
operator|->
name|mif6c_pifi
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|=
name|multicast_register_if6
expr_stmt|;
block|}
block|}
comment|/* if REGISTER */
else|else
block|{
comment|/* Make sure the interface supports multicast */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|error
operator|=
name|if_allmulti
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|mifp
operator|->
name|m6_flags
operator|=
name|mifcp
operator|->
name|mif6c_flags
expr_stmt|;
name|mifp
operator|->
name|m6_ifp
operator|=
name|ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* scaling up here allows division by 1024 in critical code */
name|mifp
operator|->
name|m6_rate_limit
operator|=
name|mifcp
operator|->
name|mif6c_rate_limit
operator|*
literal|1024
operator|/
literal|1000
expr_stmt|;
endif|#
directive|endif
comment|/* initialize per mif pkt counters */
name|mifp
operator|->
name|m6_pkt_in
operator|=
literal|0
expr_stmt|;
name|mifp
operator|->
name|m6_pkt_out
operator|=
literal|0
expr_stmt|;
name|mifp
operator|->
name|m6_bytes_in
operator|=
literal|0
expr_stmt|;
name|mifp
operator|->
name|m6_bytes_out
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Adjust nummifs up if the mifi is higher than nummifs */
if|if
condition|(
name|nummifs
operator|<=
name|mifcp
operator|->
name|mif6c_mifi
condition|)
name|nummifs
operator|=
name|mifcp
operator|->
name|mif6c_mifi
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"add_mif #%d, phyint %s\n"
argument_list|,
name|mifcp
operator|->
name|mif6c_mifi
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a mif from the mif table  */
end_comment

begin_function
specifier|static
name|int
name|del_m6if
parameter_list|(
name|mifip
parameter_list|)
name|mifi_t
modifier|*
name|mifip
decl_stmt|;
block|{
name|struct
name|mif6
modifier|*
name|mifp
init|=
name|mif6table
operator|+
operator|*
name|mifip
decl_stmt|;
name|mifi_t
name|mifi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|*
name|mifip
operator|>=
name|nummifs
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|mifp
operator|->
name|m6_ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mifp
operator|->
name|m6_flags
operator|&
name|MIFF_REGISTER
operator|)
condition|)
block|{
comment|/* 		 * XXX: what if there is yet IPv4 multicast daemon 		 *      using the interface? 		 */
name|ifp
operator|=
name|mifp
operator|->
name|m6_ifp
expr_stmt|;
name|if_allmulti
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reg_mif_num
operator|!=
operator|(
name|mifi_t
operator|)
operator|-
literal|1
operator|&&
name|multicast_register_if6
operator|!=
name|NULL
condition|)
block|{
name|if_detach
argument_list|(
name|multicast_register_if6
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|multicast_register_if6
argument_list|)
expr_stmt|;
name|reg_mif_num
operator|=
operator|(
name|mifi_t
operator|)
operator|-
literal|1
expr_stmt|;
name|multicast_register_if6
operator|=
name|NULL
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|notyet
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|qtable
index|[
operator|*
name|mifip
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|qtable
index|[
operator|*
name|mifip
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mifp
operator|->
name|m6_tbf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|mifp
operator|->
name|m6_tbf
operator|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mifp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Adjust nummifs down */
for|for
control|(
name|mifi
operator|=
name|nummifs
init|;
name|mifi
operator|>
literal|0
condition|;
name|mifi
operator|--
control|)
if|if
condition|(
name|mif6table
index|[
name|mifi
operator|-
literal|1
index|]
operator|.
name|m6_ifp
condition|)
break|break;
name|nummifs
operator|=
name|mifi
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"del_m6if %d, nummifs %d\n"
argument_list|,
operator|*
name|mifip
argument_list|,
name|nummifs
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an mfc entry  */
end_comment

begin_function
specifier|static
name|int
name|add_m6fc
parameter_list|(
name|mfccp
parameter_list|)
name|struct
name|mf6cctl
modifier|*
name|mfccp
decl_stmt|;
block|{
name|struct
name|mf6c
modifier|*
name|rt
decl_stmt|;
name|u_long
name|hash
decl_stmt|;
name|struct
name|rtdetq
modifier|*
name|rte
decl_stmt|;
name|u_short
name|nstl
decl_stmt|;
name|int
name|s
decl_stmt|;
name|char
name|ip6bufo
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|,
name|ip6bufg
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|MF6CFIND
argument_list|(
name|mfccp
operator|->
name|mf6cc_origin
operator|.
name|sin6_addr
argument_list|,
name|mfccp
operator|->
name|mf6cc_mcastgrp
operator|.
name|sin6_addr
argument_list|,
name|rt
argument_list|)
expr_stmt|;
comment|/* If an entry already exists, just update the fields */
if|if
condition|(
name|rt
condition|)
block|{
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_MFC
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"add_m6fc no upcall h %d o %s g %s p %x\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufo
argument_list|,
operator|&
name|mfccp
operator|->
name|mf6cc_origin
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufg
argument_list|,
operator|&
name|mfccp
operator|->
name|mf6cc_mcastgrp
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|mfccp
operator|->
name|mf6cc_parent
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|rt
operator|->
name|mf6c_parent
operator|=
name|mfccp
operator|->
name|mf6cc_parent
expr_stmt|;
name|rt
operator|->
name|mf6c_ifset
operator|=
name|mfccp
operator|->
name|mf6cc_ifset
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Find the entry for which the upcall was made and update 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|hash
operator|=
name|MF6CHASH
argument_list|(
name|mfccp
operator|->
name|mf6cc_origin
operator|.
name|sin6_addr
argument_list|,
name|mfccp
operator|->
name|mf6cc_mcastgrp
operator|.
name|sin6_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|rt
operator|=
name|mf6ctable
index|[
name|hash
index|]
operator|,
name|nstl
operator|=
literal|0
init|;
name|rt
condition|;
name|rt
operator|=
name|rt
operator|->
name|mf6c_next
control|)
block|{
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|rt
operator|->
name|mf6c_origin
operator|.
name|sin6_addr
argument_list|,
operator|&
name|mfccp
operator|->
name|mf6cc_origin
operator|.
name|sin6_addr
argument_list|)
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|rt
operator|->
name|mf6c_mcastgrp
operator|.
name|sin6_addr
argument_list|,
operator|&
name|mfccp
operator|->
name|mf6cc_mcastgrp
operator|.
name|sin6_addr
argument_list|)
operator|&&
operator|(
name|rt
operator|->
name|mf6c_stall
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|nstl
operator|++
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"add_m6fc: %s o %s g %s p %x dbx %p\n"
argument_list|,
literal|"multiple kernel entries"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufo
argument_list|,
operator|&
name|mfccp
operator|->
name|mf6cc_origin
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufg
argument_list|,
operator|&
name|mfccp
operator|->
name|mf6cc_mcastgrp
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|mfccp
operator|->
name|mf6cc_parent
argument_list|,
name|rt
operator|->
name|mf6c_stall
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_MFC
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"add_m6fc o %s g %s p %x dbg %x\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufo
argument_list|,
operator|&
name|mfccp
operator|->
name|mf6cc_origin
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufg
argument_list|,
operator|&
name|mfccp
operator|->
name|mf6cc_mcastgrp
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|mfccp
operator|->
name|mf6cc_parent
argument_list|,
name|rt
operator|->
name|mf6c_stall
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rt
operator|->
name|mf6c_origin
operator|=
name|mfccp
operator|->
name|mf6cc_origin
expr_stmt|;
name|rt
operator|->
name|mf6c_mcastgrp
operator|=
name|mfccp
operator|->
name|mf6cc_mcastgrp
expr_stmt|;
name|rt
operator|->
name|mf6c_parent
operator|=
name|mfccp
operator|->
name|mf6cc_parent
expr_stmt|;
name|rt
operator|->
name|mf6c_ifset
operator|=
name|mfccp
operator|->
name|mf6cc_ifset
expr_stmt|;
comment|/* initialize pkt counters per src-grp */
name|rt
operator|->
name|mf6c_pkt_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mf6c_byte_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mf6c_wrong_if
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mf6c_expire
operator|=
literal|0
expr_stmt|;
comment|/* Don't clean this guy up */
name|n6expire
index|[
name|hash
index|]
operator|--
expr_stmt|;
comment|/* free packets Qed at the end of this entry */
for|for
control|(
name|rte
operator|=
name|rt
operator|->
name|mf6c_stall
init|;
name|rte
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|rtdetq
modifier|*
name|n
init|=
name|rte
operator|->
name|next
decl_stmt|;
name|ip6_mdq
argument_list|(
name|rte
operator|->
name|m
argument_list|,
name|rte
operator|->
name|ifp
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rte
operator|->
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UPCALL_TIMING
name|collate
argument_list|(
operator|&
operator|(
name|rte
operator|->
name|t
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UPCALL_TIMING */
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE6
argument_list|)
expr_stmt|;
name|rte
operator|=
name|n
expr_stmt|;
block|}
name|rt
operator|->
name|mf6c_stall
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * It is possible that an entry is being inserted without an upcall 	 */
if|if
condition|(
name|nstl
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_MFC
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"add_mfc no upcall h %d o %s g %s p %x\n"
argument_list|,
name|hash
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufo
argument_list|,
operator|&
name|mfccp
operator|->
name|mf6cc_origin
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufg
argument_list|,
operator|&
name|mfccp
operator|->
name|mf6cc_mcastgrp
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|mfccp
operator|->
name|mf6cc_parent
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|rt
operator|=
name|mf6ctable
index|[
name|hash
index|]
init|;
name|rt
condition|;
name|rt
operator|=
name|rt
operator|->
name|mf6c_next
control|)
block|{
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|rt
operator|->
name|mf6c_origin
operator|.
name|sin6_addr
argument_list|,
operator|&
name|mfccp
operator|->
name|mf6cc_origin
operator|.
name|sin6_addr
argument_list|)
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|rt
operator|->
name|mf6c_mcastgrp
operator|.
name|sin6_addr
argument_list|,
operator|&
name|mfccp
operator|->
name|mf6cc_mcastgrp
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|rt
operator|->
name|mf6c_origin
operator|=
name|mfccp
operator|->
name|mf6cc_origin
expr_stmt|;
name|rt
operator|->
name|mf6c_mcastgrp
operator|=
name|mfccp
operator|->
name|mf6cc_mcastgrp
expr_stmt|;
name|rt
operator|->
name|mf6c_parent
operator|=
name|mfccp
operator|->
name|mf6cc_parent
expr_stmt|;
name|rt
operator|->
name|mf6c_ifset
operator|=
name|mfccp
operator|->
name|mf6cc_ifset
expr_stmt|;
comment|/* initialize pkt counters per src-grp */
name|rt
operator|->
name|mf6c_pkt_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mf6c_byte_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mf6c_wrong_if
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|mf6c_expire
condition|)
name|n6expire
index|[
name|hash
index|]
operator|--
expr_stmt|;
name|rt
operator|->
name|mf6c_expire
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
comment|/* no upcall, so make a new entry */
name|rt
operator|=
operator|(
expr|struct
name|mf6c
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
argument_list|,
name|M_MRTABLE6
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* insert new entry at head of hash chain */
name|rt
operator|->
name|mf6c_origin
operator|=
name|mfccp
operator|->
name|mf6cc_origin
expr_stmt|;
name|rt
operator|->
name|mf6c_mcastgrp
operator|=
name|mfccp
operator|->
name|mf6cc_mcastgrp
expr_stmt|;
name|rt
operator|->
name|mf6c_parent
operator|=
name|mfccp
operator|->
name|mf6cc_parent
expr_stmt|;
name|rt
operator|->
name|mf6c_ifset
operator|=
name|mfccp
operator|->
name|mf6cc_ifset
expr_stmt|;
comment|/* initialize pkt counters per src-grp */
name|rt
operator|->
name|mf6c_pkt_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mf6c_byte_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mf6c_wrong_if
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mf6c_expire
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mf6c_stall
operator|=
name|NULL
expr_stmt|;
comment|/* link into table */
name|rt
operator|->
name|mf6c_next
operator|=
name|mf6ctable
index|[
name|hash
index|]
expr_stmt|;
name|mf6ctable
index|[
name|hash
index|]
operator|=
name|rt
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UPCALL_TIMING
end_ifdef

begin_comment
comment|/*  * collect delay statistics on the upcalls  */
end_comment

begin_function
specifier|static
name|void
name|collate
parameter_list|(
name|t
parameter_list|)
name|struct
name|timeval
modifier|*
name|t
decl_stmt|;
block|{
name|u_long
name|d
decl_stmt|;
name|struct
name|timeval
name|tp
decl_stmt|;
name|u_long
name|delta
decl_stmt|;
name|GET_TIME
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TV_LT
argument_list|(
operator|*
name|t
argument_list|,
name|tp
argument_list|)
condition|)
block|{
name|TV_DELTA
argument_list|(
name|tp
argument_list|,
operator|*
name|t
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|d
operator|=
name|delta
operator|>>
literal|10
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|UPCALL_MAX
condition|)
name|d
operator|=
name|UPCALL_MAX
expr_stmt|;
operator|++
name|upcall_data
index|[
name|d
index|]
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UPCALL_TIMING */
end_comment

begin_comment
comment|/*  * Delete an mfc entry  */
end_comment

begin_function
specifier|static
name|int
name|del_m6fc
parameter_list|(
name|mfccp
parameter_list|)
name|struct
name|mf6cctl
modifier|*
name|mfccp
decl_stmt|;
block|{
name|struct
name|sockaddr_in6
name|origin
decl_stmt|;
name|struct
name|sockaddr_in6
name|mcastgrp
decl_stmt|;
name|struct
name|mf6c
modifier|*
name|rt
decl_stmt|;
name|struct
name|mf6c
modifier|*
modifier|*
name|nptr
decl_stmt|;
name|u_long
name|hash
decl_stmt|;
name|int
name|s
decl_stmt|;
name|origin
operator|=
name|mfccp
operator|->
name|mf6cc_origin
expr_stmt|;
name|mcastgrp
operator|=
name|mfccp
operator|->
name|mf6cc_mcastgrp
expr_stmt|;
name|hash
operator|=
name|MF6CHASH
argument_list|(
name|origin
operator|.
name|sin6_addr
argument_list|,
name|mcastgrp
operator|.
name|sin6_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_MFC
condition|)
block|{
name|char
name|ip6bufo
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|,
name|ip6bufg
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"del_m6fc orig %s mcastgrp %s\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufo
argument_list|,
operator|&
name|origin
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufg
argument_list|,
operator|&
name|mcastgrp
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|nptr
operator|=
operator|&
name|mf6ctable
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|rt
operator|=
operator|*
name|nptr
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|origin
operator|.
name|sin6_addr
argument_list|,
operator|&
name|rt
operator|->
name|mf6c_origin
operator|.
name|sin6_addr
argument_list|)
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|mcastgrp
operator|.
name|sin6_addr
argument_list|,
operator|&
name|rt
operator|->
name|mf6c_mcastgrp
operator|.
name|sin6_addr
argument_list|)
operator|&&
name|rt
operator|->
name|mf6c_stall
operator|==
name|NULL
condition|)
break|break;
name|nptr
operator|=
operator|&
name|rt
operator|->
name|mf6c_next
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
operator|*
name|nptr
operator|=
name|rt
operator|->
name|mf6c_next
expr_stmt|;
name|free
argument_list|(
name|rt
argument_list|,
name|M_MRTABLE6
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|socket_send
parameter_list|(
name|s
parameter_list|,
name|mm
parameter_list|,
name|src
parameter_list|)
name|struct
name|socket
modifier|*
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|;
block|{
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|sbappendaddr
argument_list|(
operator|&
name|s
operator|->
name|so_rcv
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|src
argument_list|,
name|mm
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sorwakeup
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|m_freem
argument_list|(
name|mm
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IPv6 multicast forwarding function. This function assumes that the packet  * pointed to by "ip6" has arrived on (or is about to be sent to) the interface  * pointed to by "ifp", and the packet is to be relayed to other networks  * that have members of the packet's destination IPv6 multicast group.  *  * The packet is returned unscathed to the caller, unless it is  * erroneous, in which case a non-zero return value tells the caller to  * discard it.  *  * NOTE: this implementation assumes that m->m_pkthdr.rcvif is NULL iff  * this function is called in the originating context (i.e., not when  * forwarding a packet from other node).  ip6_output(), which is currently the  * only function that calls this function is called in the originating context,  * explicitly ensures this condition.  It is caller's responsibility to ensure  * that if this function is called from somewhere else in the originating  * context in the future.  */
end_comment

begin_function
name|int
name|X_ip6_mforward
parameter_list|(
name|struct
name|ip6_hdr
modifier|*
name|ip6
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mf6c
modifier|*
name|rt
decl_stmt|;
name|struct
name|mif6
modifier|*
name|mifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
name|int
name|s
decl_stmt|;
name|mifi_t
name|mifi
decl_stmt|;
name|char
name|ip6bufs
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|,
name|ip6bufd
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_FORWARD
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip6_mforward: src %s, dst %s, ifindex %d\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufs
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufd
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Don't forward a packet with Hop limit of zero or one, 	 * or a packet destined to a local-only group. 	 */
if|if
condition|(
name|ip6
operator|->
name|ip6_hlim
operator|<=
literal|1
operator|||
name|IN6_IS_ADDR_MC_INTFACELOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ip6
operator|->
name|ip6_hlim
operator|--
expr_stmt|;
comment|/* 	 * Source address check: do not forward packets with unspecified 	 * source. It was discussed in July 2000, on ipngwg mailing list. 	 * This is rather more serious than unicast cases, because some 	 * MLD packets can be sent with the unspecified source address 	 * (although such packets must normally set 1 to the hop limit field). 	 */
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_cantforward
operator|++
expr_stmt|;
if|if
condition|(
name|ip6_log_time
operator|+
name|ip6_log_interval
operator|<
name|time_second
condition|)
block|{
name|ip6_log_time
operator|=
name|time_second
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"cannot forward "
literal|"from %s to %s nxt %d received on %s\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufs
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufd
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
argument_list|,
name|ip6
operator|->
name|ip6_nxt
argument_list|,
name|if_name
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Determine forwarding mifs from the forwarding cache table 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|MF6CFIND
argument_list|(
name|ip6
operator|->
name|ip6_src
argument_list|,
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|rt
argument_list|)
expr_stmt|;
comment|/* Entry exists, so forward if necessary */
if|if
condition|(
name|rt
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ip6_mdq
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|,
name|rt
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * If we don't have a route for packet's origin, 		 * Make a copy of the packet& 		 * send message to routing daemon 		 */
name|struct
name|mbuf
modifier|*
name|mb0
decl_stmt|;
name|struct
name|rtdetq
modifier|*
name|rte
decl_stmt|;
name|u_long
name|hash
decl_stmt|;
comment|/*		int i, npkts;*/
ifdef|#
directive|ifdef
name|UPCALL_TIMING
name|struct
name|timeval
name|tp
decl_stmt|;
name|GET_TIME
argument_list|(
name|tp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UPCALL_TIMING */
name|mrt6stat
operator|.
name|mrt6s_no_route
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
operator|(
name|DEBUG_FORWARD
operator||
name|DEBUG_MFC
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip6_mforward: no rte s %s g %s\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufs
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufd
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Allocate mbufs early so that we don't do extra work if we 		 * are just going to fail anyway. 		 */
name|rte
operator|=
operator|(
expr|struct
name|rtdetq
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rte
argument_list|)
argument_list|,
name|M_MRTABLE6
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rte
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|mb0
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
expr_stmt|;
comment|/* 		 * Pullup packet header if needed before storing it, 		 * as other references may modify it in the meantime. 		 */
if|if
condition|(
name|mb0
operator|&&
operator|(
name|M_HASCL
argument_list|(
name|mb0
argument_list|)
operator|||
name|mb0
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|)
condition|)
name|mb0
operator|=
name|m_pullup
argument_list|(
name|mb0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb0
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE6
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* is there an upcall waiting for this packet? */
name|hash
operator|=
name|MF6CHASH
argument_list|(
name|ip6
operator|->
name|ip6_src
argument_list|,
name|ip6
operator|->
name|ip6_dst
argument_list|)
expr_stmt|;
for|for
control|(
name|rt
operator|=
name|mf6ctable
index|[
name|hash
index|]
init|;
name|rt
condition|;
name|rt
operator|=
name|rt
operator|->
name|mf6c_next
control|)
block|{
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
operator|&
name|rt
operator|->
name|mf6c_origin
operator|.
name|sin6_addr
argument_list|)
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
operator|&
name|rt
operator|->
name|mf6c_mcastgrp
operator|.
name|sin6_addr
argument_list|)
operator|&&
operator|(
name|rt
operator|->
name|mf6c_stall
operator|!=
name|NULL
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|struct
name|mrt6msg
modifier|*
name|im
decl_stmt|;
ifdef|#
directive|ifdef
name|MRT6_OINIT
name|struct
name|omrt6msg
modifier|*
name|oim
decl_stmt|;
endif|#
directive|endif
comment|/* no upcall, so make a new entry */
name|rt
operator|=
operator|(
expr|struct
name|mf6c
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
argument_list|,
name|M_MRTABLE6
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE6
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 			 * Make a copy of the header to send to the user 			 * level process 			 */
name|mm
operator|=
name|m_copy
argument_list|(
name|mb0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE6
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rt
argument_list|,
name|M_MRTABLE6
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 			 * Send message to routing daemon 			 */
name|sin6
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|im
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6_OINIT
name|oim
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ip6_mrouter_ver
condition|)
block|{
ifdef|#
directive|ifdef
name|MRT6_OINIT
case|case
name|MRT6_OINIT
case|:
name|oim
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|omrt6msg
operator|*
argument_list|)
expr_stmt|;
name|oim
operator|->
name|im6_msgtype
operator|=
name|MRT6MSG_NOCACHE
expr_stmt|;
name|oim
operator|->
name|im6_mbz
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|MRT6_INIT
case|:
name|im
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|mrt6msg
operator|*
argument_list|)
expr_stmt|;
name|im
operator|->
name|im6_msgtype
operator|=
name|MRT6MSG_NOCACHE
expr_stmt|;
name|im
operator|->
name|im6_mbz
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE6
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rt
argument_list|,
name|M_MRTABLE6
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_FORWARD
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"getting the iif info in the kernel\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|mifp
operator|=
name|mif6table
operator|,
name|mifi
operator|=
literal|0
init|;
name|mifi
operator|<
name|nummifs
operator|&&
name|mifp
operator|->
name|m6_ifp
operator|!=
name|ifp
condition|;
name|mifp
operator|++
operator|,
name|mifi
operator|++
control|)
empty_stmt|;
switch|switch
condition|(
name|ip6_mrouter_ver
condition|)
block|{
ifdef|#
directive|ifdef
name|MRT6_OINIT
case|case
name|MRT6_OINIT
case|:
name|oim
operator|->
name|im6_mif
operator|=
name|mifi
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|MRT6_INIT
case|:
name|im
operator|->
name|im6_mif
operator|=
name|mifi
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|socket_send
argument_list|(
name|ip6_mrouter
argument_list|,
name|mm
argument_list|,
operator|&
name|sin6
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"ip6_mforward: ip6_mrouter "
literal|"socket queue full\n"
argument_list|)
expr_stmt|;
name|mrt6stat
operator|.
name|mrt6s_upq_sockfull
operator|++
expr_stmt|;
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE6
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rt
argument_list|,
name|M_MRTABLE6
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|mrt6stat
operator|.
name|mrt6s_upcalls
operator|++
expr_stmt|;
comment|/* insert new entry at head of hash chain */
name|bzero
argument_list|(
name|rt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|mf6c_origin
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|rt
operator|->
name|mf6c_origin
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|rt
operator|->
name|mf6c_origin
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|rt
operator|->
name|mf6c_mcastgrp
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|rt
operator|->
name|mf6c_mcastgrp
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|rt
operator|->
name|mf6c_mcastgrp
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|rt
operator|->
name|mf6c_expire
operator|=
name|UPCALL_EXPIRE
expr_stmt|;
name|n6expire
index|[
name|hash
index|]
operator|++
expr_stmt|;
name|rt
operator|->
name|mf6c_parent
operator|=
name|MF6C_INCOMPLETE_PARENT
expr_stmt|;
comment|/* link into table */
name|rt
operator|->
name|mf6c_next
operator|=
name|mf6ctable
index|[
name|hash
index|]
expr_stmt|;
name|mf6ctable
index|[
name|hash
index|]
operator|=
name|rt
expr_stmt|;
comment|/* Add this entry to the end of the queue */
name|rt
operator|->
name|mf6c_stall
operator|=
name|rte
expr_stmt|;
block|}
else|else
block|{
comment|/* determine if q has overflowed */
name|struct
name|rtdetq
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
name|npkts
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|rt
operator|->
name|mf6c_stall
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|++
name|npkts
operator|>
name|MAX_UPQ6
condition|)
block|{
name|mrt6stat
operator|.
name|mrt6s_upq_ovflw
operator|++
expr_stmt|;
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE6
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Add this entry to the end of the queue */
operator|*
name|p
operator|=
name|rte
expr_stmt|;
block|}
name|rte
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|rte
operator|->
name|m
operator|=
name|mb0
expr_stmt|;
name|rte
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|UPCALL_TIMING
name|rte
operator|->
name|t
operator|=
name|tp
expr_stmt|;
endif|#
directive|endif
comment|/* UPCALL_TIMING */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clean up cache entries if upcalls are not serviced  * Call from the Slow Timeout mechanism, every half second.  */
end_comment

begin_function
specifier|static
name|void
name|expire_upcalls
parameter_list|(
name|unused
parameter_list|)
name|void
modifier|*
name|unused
decl_stmt|;
block|{
name|struct
name|rtdetq
modifier|*
name|rte
decl_stmt|;
name|struct
name|mf6c
modifier|*
name|mfc
decl_stmt|,
modifier|*
modifier|*
name|nptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MF6CTBLSIZ
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|n6expire
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|nptr
operator|=
operator|&
name|mf6ctable
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|mfc
operator|=
operator|*
name|nptr
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rte
operator|=
name|mfc
operator|->
name|mf6c_stall
expr_stmt|;
comment|/* 			 * Skip real cache entries 			 * Make sure it wasn't marked to not expire (shouldn't happen) 			 * If it expires now 			 */
if|if
condition|(
name|rte
operator|!=
name|NULL
operator|&&
name|mfc
operator|->
name|mf6c_expire
operator|!=
literal|0
operator|&&
operator|--
name|mfc
operator|->
name|mf6c_expire
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_EXPIRE
condition|)
block|{
name|char
name|ip6bufo
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|char
name|ip6bufg
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"expire_upcalls: expiring (%s %s)\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufo
argument_list|,
operator|&
name|mfc
operator|->
name|mf6c_origin
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufg
argument_list|,
operator|&
name|mfc
operator|->
name|mf6c_mcastgrp
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 				 * drop all the packets 				 * free the mbuf with the pkt, if, timing info 				 */
do|do
block|{
name|struct
name|rtdetq
modifier|*
name|n
init|=
name|rte
operator|->
name|next
decl_stmt|;
name|m_freem
argument_list|(
name|rte
operator|->
name|m
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE6
argument_list|)
expr_stmt|;
name|rte
operator|=
name|n
expr_stmt|;
block|}
do|while
condition|(
name|rte
operator|!=
name|NULL
condition|)
do|;
name|mrt6stat
operator|.
name|mrt6s_cache_cleanups
operator|++
expr_stmt|;
name|n6expire
index|[
name|i
index|]
operator|--
expr_stmt|;
operator|*
name|nptr
operator|=
name|mfc
operator|->
name|mf6c_next
expr_stmt|;
name|free
argument_list|(
name|mfc
argument_list|,
name|M_MRTABLE6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nptr
operator|=
operator|&
name|mfc
operator|->
name|mf6c_next
expr_stmt|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|expire_upcalls_ch
argument_list|,
name|EXPIRE_TIMEOUT
argument_list|,
name|expire_upcalls
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Packet forwarding routine once entry in the cache is made  */
end_comment

begin_function
specifier|static
name|int
name|ip6_mdq
parameter_list|(
name|m
parameter_list|,
name|ifp
parameter_list|,
name|rt
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mf6c
modifier|*
name|rt
decl_stmt|;
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
name|mifi_t
name|mifi
decl_stmt|,
name|iif
decl_stmt|;
name|struct
name|mif6
modifier|*
name|mifp
decl_stmt|;
name|int
name|plen
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
decl_stmt|;
name|struct
name|in6_addr
name|src0
decl_stmt|,
name|dst0
decl_stmt|;
comment|/* copies for local work */
name|u_int32_t
name|iszone
decl_stmt|,
name|idzone
decl_stmt|,
name|oszone
decl_stmt|,
name|odzone
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/*  * Macro to send packet on mif.  Since RSVP packets don't get counted on  * input, they shouldn't get counted on output, so statistics keeping is  * separate.  */
define|#
directive|define
name|MC6_SEND
parameter_list|(
name|ip6
parameter_list|,
name|mifp
parameter_list|,
name|m
parameter_list|)
value|do {				\ 	if ((mifp)->m6_flags& MIFF_REGISTER)			\ 		register_send((ip6), (mifp), (m));		\ 	else							\ 		phyint_send((ip6), (mifp), (m));		\ } while (
comment|/*CONSTCOND*/
value|0)
comment|/* 	 * Don't forward if it didn't arrive from the parent mif 	 * for its origin. 	 */
name|mifi
operator|=
name|rt
operator|->
name|mf6c_parent
expr_stmt|;
if|if
condition|(
operator|(
name|mifi
operator|>=
name|nummifs
operator|)
operator|||
operator|(
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_ifp
operator|!=
name|ifp
operator|)
condition|)
block|{
comment|/* came in the wrong interface */
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_FORWARD
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"wrong if: ifid %d mifi %d mififid %x\n"
argument_list|,
name|ifp
operator|->
name|if_index
argument_list|,
name|mifi
argument_list|,
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_ifp
operator|->
name|if_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mrt6stat
operator|.
name|mrt6s_wrong_if
operator|++
expr_stmt|;
name|rt
operator|->
name|mf6c_wrong_if
operator|++
expr_stmt|;
comment|/* 		 * If we are doing PIM processing, and we are forwarding 		 * packets on this interface, send a message to the 		 * routing daemon. 		 */
comment|/* have to make sure this is a valid mif */
if|if
condition|(
name|mifi
operator|<
name|nummifs
operator|&&
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_ifp
condition|)
if|if
condition|(
name|pim6
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_LOOP
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Check the M_LOOP flag to avoid an 				 * unnecessary PIM assert. 				 * XXX: M_LOOP is an ad-hoc hack... 				 */
specifier|static
name|struct
name|sockaddr_in6
name|sin6
init|=
block|{
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
name|struct
name|mrt6msg
modifier|*
name|im
decl_stmt|;
ifdef|#
directive|ifdef
name|MRT6_OINIT
name|struct
name|omrt6msg
modifier|*
name|oim
decl_stmt|;
endif|#
directive|endif
name|mm
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|&&
operator|(
name|M_HASCL
argument_list|(
name|mm
argument_list|)
operator|||
name|mm
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|)
condition|)
name|mm
operator|=
name|m_pullup
argument_list|(
name|mm
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
ifdef|#
directive|ifdef
name|MRT6_OINIT
name|oim
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|im
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|ip6_mrouter_ver
condition|)
block|{
ifdef|#
directive|ifdef
name|MRT6_OINIT
case|case
name|MRT6_OINIT
case|:
name|oim
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|omrt6msg
operator|*
argument_list|)
expr_stmt|;
name|oim
operator|->
name|im6_msgtype
operator|=
name|MRT6MSG_WRONGMIF
expr_stmt|;
name|oim
operator|->
name|im6_mbz
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|MRT6_INIT
case|:
name|im
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|mrt6msg
operator|*
argument_list|)
expr_stmt|;
name|im
operator|->
name|im6_msgtype
operator|=
name|MRT6MSG_WRONGMIF
expr_stmt|;
name|im
operator|->
name|im6_mbz
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|m_freem
argument_list|(
name|mm
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
for|for
control|(
name|mifp
operator|=
name|mif6table
operator|,
name|iif
operator|=
literal|0
init|;
name|iif
operator|<
name|nummifs
operator|&&
name|mifp
operator|&&
name|mifp
operator|->
name|m6_ifp
operator|!=
name|ifp
condition|;
name|mifp
operator|++
operator|,
name|iif
operator|++
control|)
empty_stmt|;
switch|switch
condition|(
name|ip6_mrouter_ver
condition|)
block|{
ifdef|#
directive|ifdef
name|MRT6_OINIT
case|case
name|MRT6_OINIT
case|:
name|oim
operator|->
name|im6_mif
operator|=
name|iif
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|=
name|oim
operator|->
name|im6_src
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|MRT6_INIT
case|:
name|im
operator|->
name|im6_mif
operator|=
name|iif
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|=
name|im
operator|->
name|im6_src
expr_stmt|;
break|break;
block|}
name|mrt6stat
operator|.
name|mrt6s_upcalls
operator|++
expr_stmt|;
if|if
condition|(
name|socket_send
argument_list|(
name|ip6_mrouter
argument_list|,
name|mm
argument_list|,
operator|&
name|sin6
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"mdq, ip6_mrouter socket queue full\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|mrt6stat
operator|.
name|mrt6s_upq_sockfull
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* if socket Q full */
block|}
comment|/* if PIM */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* if wrong iif */
comment|/* If I sourced this packet, it counts as output, else it was input. */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
name|NULL
condition|)
block|{
comment|/* XXX: is rcvif really NULL when output?? */
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_pkt_out
operator|++
expr_stmt|;
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_bytes_out
operator|+=
name|plen
expr_stmt|;
block|}
else|else
block|{
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_pkt_in
operator|++
expr_stmt|;
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_bytes_in
operator|+=
name|plen
expr_stmt|;
block|}
name|rt
operator|->
name|mf6c_pkt_cnt
operator|++
expr_stmt|;
name|rt
operator|->
name|mf6c_byte_cnt
operator|+=
name|plen
expr_stmt|;
comment|/* 	 * For each mif, forward a copy of the packet if there are group 	 * members downstream on the interface. 	 */
name|src0
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|dst0
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|in6_setscope
argument_list|(
operator|&
name|src0
argument_list|,
name|ifp
argument_list|,
operator|&
name|iszone
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|in6_setscope
argument_list|(
operator|&
name|dst0
argument_list|,
name|ifp
argument_list|,
operator|&
name|idzone
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|mifp
operator|=
name|mif6table
operator|,
name|mifi
operator|=
literal|0
init|;
name|mifi
operator|<
name|nummifs
condition|;
name|mifp
operator|++
operator|,
name|mifi
operator|++
control|)
block|{
if|if
condition|(
name|IF_ISSET
argument_list|(
name|mifi
argument_list|,
operator|&
name|rt
operator|->
name|mf6c_ifset
argument_list|)
condition|)
block|{
comment|/* 			 * check if the outgoing packet is going to break 			 * a scope boundary. 			 * XXX For packets through PIM register tunnel 			 * interface, we believe a routing daemon. 			 */
if|if
condition|(
operator|!
operator|(
name|mif6table
index|[
name|rt
operator|->
name|mf6c_parent
index|]
operator|.
name|m6_flags
operator|&
name|MIFF_REGISTER
operator|)
operator|&&
operator|!
operator|(
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_flags
operator|&
name|MIFF_REGISTER
operator|)
condition|)
block|{
if|if
condition|(
name|in6_setscope
argument_list|(
operator|&
name|src0
argument_list|,
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_ifp
argument_list|,
operator|&
name|oszone
argument_list|)
operator|||
name|in6_setscope
argument_list|(
operator|&
name|dst0
argument_list|,
name|mif6table
index|[
name|mifi
index|]
operator|.
name|m6_ifp
argument_list|,
operator|&
name|odzone
argument_list|)
operator|||
name|iszone
operator|!=
name|oszone
operator|||
name|idzone
operator|!=
name|odzone
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
name|mifp
operator|->
name|m6_pkt_out
operator|++
expr_stmt|;
name|mifp
operator|->
name|m6_bytes_out
operator|+=
name|plen
expr_stmt|;
name|MC6_SEND
argument_list|(
name|ip6
argument_list|,
name|mifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|phyint_send
parameter_list|(
name|ip6
parameter_list|,
name|mifp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|mif6
modifier|*
name|mifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|mb_copy
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|mifp
operator|->
name|m6_ifp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* needs to protect static "ro" below. */
specifier|static
name|struct
name|route_in6
name|ro
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|in6m
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|dst6
decl_stmt|;
name|u_long
name|linkmtu
decl_stmt|;
comment|/* 	 * Make a new reference to the packet; make sure that 	 * the IPv6 header is actually copied, not just referenced, 	 * so that ip6_output() only scribbles on the copy. 	 */
name|mb_copy
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|&&
operator|(
name|M_HASCL
argument_list|(
name|mb_copy
argument_list|)
operator|||
name|mb_copy
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|)
condition|)
name|mb_copy
operator|=
name|m_pullup
argument_list|(
name|mb_copy
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* set MCAST flag to the outgoing packet */
name|mb_copy
operator|->
name|m_flags
operator||=
name|M_MCAST
expr_stmt|;
comment|/* 	 * If we sourced the packet, call ip6_output since we may devide 	 * the packet into fragments when the packet is too big for the 	 * outgoing interface. 	 * Otherwise, we can simply send the packet to the interface 	 * sending queue. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
name|NULL
condition|)
block|{
name|struct
name|ip6_moptions
name|im6o
decl_stmt|;
name|im6o
operator|.
name|im6o_multicast_ifp
operator|=
name|ifp
expr_stmt|;
comment|/* XXX: ip6_output will override ip6->ip6_hlim */
name|im6o
operator|.
name|im6o_multicast_hlim
operator|=
name|ip6
operator|->
name|ip6_hlim
expr_stmt|;
name|im6o
operator|.
name|im6o_multicast_loop
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|ip6_output
argument_list|(
name|mb_copy
argument_list|,
name|NULL
argument_list|,
operator|&
name|ro
argument_list|,
name|IPV6_FORWARDING
argument_list|,
operator|&
name|im6o
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_XMIT
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"phyint_send on mif %d err %d\n"
argument_list|,
name|mifp
operator|-
name|mif6table
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we belong to the destination multicast group 	 * on the outgoing interface, loop back a copy. 	 */
name|dst6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro
operator|.
name|ro_dst
expr_stmt|;
name|IN6_LOOKUP_MULTI
argument_list|(
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|ifp
argument_list|,
name|in6m
argument_list|)
expr_stmt|;
if|if
condition|(
name|in6m
operator|!=
name|NULL
condition|)
block|{
name|dst6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|dst6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|dst6
operator|->
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|ip6_mloopback
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro
operator|.
name|ro_dst
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Put the packet into the sending queue of the outgoing interface 	 * if it would fit in the MTU of the interface. 	 */
name|linkmtu
operator|=
name|IN6_LINKMTU
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|linkmtu
operator|||
name|linkmtu
operator|<
name|IPV6_MMTU
condition|)
block|{
name|dst6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|dst6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|dst6
operator|->
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
comment|/* 		 * We just call if_output instead of nd6_output here, since 		 * we need no ND for a multicast forwarded packet...right? 		 */
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|mb_copy
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ro
operator|.
name|ro_dst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_XMIT
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"phyint_send on mif %d err %d\n"
argument_list|,
name|mifp
operator|-
name|mif6table
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * pMTU discovery is intentionally disabled by default, since 		 * various router may notify pMTU in multicast, which can be 		 * a DDoS to a router 		 */
if|if
condition|(
name|ip6_mcast_pmtu
condition|)
name|icmp6_error
argument_list|(
name|mb_copy
argument_list|,
name|ICMP6_PACKET_TOO_BIG
argument_list|,
literal|0
argument_list|,
name|linkmtu
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_XMIT
condition|)
block|{
name|char
name|ip6bufs
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|char
name|ip6bufd
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"phyint_send: packet too big on %s o %s "
literal|"g %s size %d(discarded)\n"
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufs
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufd
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
argument_list|,
name|mb_copy
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MRT6DEBUG */
name|m_freem
argument_list|(
name|mb_copy
argument_list|)
expr_stmt|;
comment|/* simply discard the packet */
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|register_send
parameter_list|(
name|ip6
parameter_list|,
name|mif
parameter_list|,
name|m
parameter_list|)
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|mif6
modifier|*
name|mif
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in6
name|sin6
init|=
block|{
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
name|struct
name|mrt6msg
modifier|*
name|im6
decl_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
condition|)
block|{
name|char
name|ip6bufs
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|,
name|ip6bufd
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"** IPv6 register_send **\n src %s dst %s\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufs
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufd
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|++
name|pim6stat
operator|.
name|pim6s_snd_registers
expr_stmt|;
comment|/* Make a copy of the packet to send to the user level process */
name|MGETHDR
argument_list|(
name|mm
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|mm
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|mm
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|mm
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mm
operator|->
name|m_next
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mm
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|i
operator|=
name|MHLEN
operator|-
name|M_LEADINGSPACE
argument_list|(
name|mm
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|len
condition|)
name|i
operator|=
name|len
expr_stmt|;
name|mm
operator|=
name|m_pullup
argument_list|(
name|mm
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* TODO: check it! */
name|mm
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
comment|/* 	 * Send message to routing daemon 	 */
name|sin6
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|im6
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|mrt6msg
operator|*
argument_list|)
expr_stmt|;
name|im6
operator|->
name|im6_msgtype
operator|=
name|MRT6MSG_WHOLEPKT
expr_stmt|;
name|im6
operator|->
name|im6_mbz
operator|=
literal|0
expr_stmt|;
name|im6
operator|->
name|im6_mif
operator|=
name|mif
operator|-
name|mif6table
expr_stmt|;
comment|/* iif info is not given for reg. encap.n */
name|mrt6stat
operator|.
name|mrt6s_upcalls
operator|++
expr_stmt|;
if|if
condition|(
name|socket_send
argument_list|(
name|ip6_mrouter
argument_list|,
name|mm
argument_list|,
operator|&
name|sin6
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"register_send: ip6_mrouter socket queue full\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|mrt6stat
operator|.
name|mrt6s_upq_sockfull
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PIM sparse mode hook  * Receives the pim control messages, and passes them up to the listening  * socket, using rip6_input.  * The only message processed is the REGISTER pim message; the pim header  * is stripped off, and the inner packet is passed to register_mforward.  */
end_comment

begin_function
name|int
name|pim6_input
parameter_list|(
name|mp
parameter_list|,
name|offp
parameter_list|,
name|proto
parameter_list|)
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
modifier|*
name|offp
decl_stmt|,
name|proto
decl_stmt|;
block|{
name|struct
name|pim
modifier|*
name|pim
decl_stmt|;
comment|/* pointer to a pim struct */
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|int
name|pimlen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|int
name|minlen
decl_stmt|;
name|int
name|off
init|=
operator|*
name|offp
decl_stmt|;
operator|++
name|pim6stat
operator|.
name|pim6s_rcv_total
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|pimlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|*
name|offp
expr_stmt|;
comment|/* 	 * Validate lengths 	 */
if|if
condition|(
name|pimlen
operator|<
name|PIM_MINLEN
condition|)
block|{
operator|++
name|pim6stat
operator|.
name|pim6s_rcv_tooshort
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_PIM
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"pim6_input: PIM packet too short\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* 	 * if the packet is at least as big as a REGISTER, go ahead 	 * and grab the PIM REGISTER header size, to avoid another 	 * possible m_pullup() later. 	 * 	 * PIM_MINLEN       == pimhdr + u_int32 == 8 	 * PIM6_REG_MINLEN   == pimhdr + reghdr + eip6hdr == 4 + 4 + 40 	 */
name|minlen
operator|=
operator|(
name|pimlen
operator|>=
name|PIM6_REG_MINLEN
operator|)
condition|?
name|PIM6_REG_MINLEN
else|:
name|PIM_MINLEN
expr_stmt|;
comment|/* 	 * Make sure that the IP6 and PIM headers in contiguous memory, and 	 * possibly the PIM REGISTER header 	 */
ifndef|#
directive|ifndef
name|PULLDOWN_TEST
name|IP6_EXTHDR_CHECK
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|minlen
argument_list|,
name|IPPROTO_DONE
argument_list|)
expr_stmt|;
comment|/* adjust pointer */
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
comment|/* adjust mbuf to point to the PIM header */
name|pim
operator|=
operator|(
expr|struct
name|pim
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6
operator|+
name|off
operator|)
expr_stmt|;
else|#
directive|else
name|IP6_EXTHDR_GET
argument_list|(
name|pim
argument_list|,
expr|struct
name|pim
operator|*
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|minlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pim
operator|==
name|NULL
condition|)
block|{
name|pim6stat
operator|.
name|pim6s_rcv_tooshort
operator|++
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
endif|#
directive|endif
define|#
directive|define
name|PIM6_CHECKSUM
ifdef|#
directive|ifdef
name|PIM6_CHECKSUM
block|{
name|int
name|cksumlen
decl_stmt|;
comment|/* 		 * Validate checksum. 		 * If PIM REGISTER, exclude the data packet 		 */
if|if
condition|(
name|pim
operator|->
name|pim_type
operator|==
name|PIM_REGISTER
condition|)
name|cksumlen
operator|=
name|PIM_MINLEN
expr_stmt|;
else|else
name|cksumlen
operator|=
name|pimlen
expr_stmt|;
if|if
condition|(
name|in6_cksum
argument_list|(
name|m
argument_list|,
name|IPPROTO_PIM
argument_list|,
name|off
argument_list|,
name|cksumlen
argument_list|)
condition|)
block|{
operator|++
name|pim6stat
operator|.
name|pim6s_rcv_badsum
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_PIM
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"pim6_input: invalid checksum\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* PIM_CHECKSUM */
comment|/* PIM version check */
if|if
condition|(
name|pim
operator|->
name|pim_ver
operator|!=
name|PIM_VERSION
condition|)
block|{
operator|++
name|pim6stat
operator|.
name|pim6s_rcv_badversion
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pim6_input: incorrect version %d, expecting %d\n"
argument_list|,
name|pim
operator|->
name|pim_ver
argument_list|,
name|PIM_VERSION
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
if|if
condition|(
name|pim
operator|->
name|pim_type
operator|==
name|PIM_REGISTER
condition|)
block|{
comment|/* 		 * since this is a REGISTER, we'll make a copy of the register 		 * headers ip6+pim+u_int32_t+encap_ip6, to be passed up to the 		 * routing daemon. 		 */
specifier|static
name|struct
name|sockaddr_in6
name|dst
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mcp
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|eip6
decl_stmt|;
name|u_int32_t
modifier|*
name|reghdr
decl_stmt|;
name|int
name|rc
decl_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
name|char
name|ip6bufs
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|,
name|ip6bufd
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
operator|++
name|pim6stat
operator|.
name|pim6s_rcv_registers
expr_stmt|;
if|if
condition|(
operator|(
name|reg_mif_num
operator|>=
name|nummifs
operator|)
operator|||
operator|(
name|reg_mif_num
operator|==
operator|(
name|mifi_t
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_PIM
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"pim6_input: register mif not set: %d\n"
argument_list|,
name|reg_mif_num
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
name|reghdr
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|pim
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntohl
argument_list|(
operator|*
name|reghdr
argument_list|)
operator|&
name|PIM_NULL_REGISTER
operator|)
condition|)
goto|goto
name|pim6_input_to_daemon
goto|;
comment|/* 		 * Validate length 		 */
if|if
condition|(
name|pimlen
operator|<
name|PIM6_REG_MINLEN
condition|)
block|{
operator|++
name|pim6stat
operator|.
name|pim6s_rcv_tooshort
expr_stmt|;
operator|++
name|pim6stat
operator|.
name|pim6s_rcv_badregisters
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pim6_input: register packet size too "
literal|"small %d from %s\n"
argument_list|,
name|pimlen
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufs
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
name|eip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|reghdr
operator|+
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_PIM
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"pim6_input[register], eip6: %s -> %s, "
literal|"eip6 plen %d\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufs
argument_list|,
operator|&
name|eip6
operator|->
name|ip6_src
argument_list|)
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufd
argument_list|,
operator|&
name|eip6
operator|->
name|ip6_dst
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|eip6
operator|->
name|ip6_plen
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* verify the version number of the inner packet */
if|if
condition|(
operator|(
name|eip6
operator|->
name|ip6_vfc
operator|&
name|IPV6_VERSION_MASK
operator|)
operator|!=
name|IPV6_VERSION
condition|)
block|{
operator|++
name|pim6stat
operator|.
name|pim6s_rcv_badregisters
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"pim6_input: invalid IP version (%d) "
literal|"of the inner packet\n"
argument_list|,
operator|(
name|eip6
operator|->
name|ip6_vfc
operator|&
name|IPV6_VERSION
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_NONE
operator|)
return|;
block|}
comment|/* verify the inner packet is destined to a mcast group */
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|eip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
operator|++
name|pim6stat
operator|.
name|pim6s_rcv_badregisters
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_PIM
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"pim6_input: inner packet of register "
literal|"is not multicast %s\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufd
argument_list|,
operator|&
name|eip6
operator|->
name|ip6_dst
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* 		 * make a copy of the whole header to pass to the daemon later. 		 */
name|mcp
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|off
operator|+
name|PIM6_REG_MINLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcp
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|MRT6DEBUG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pim6_input: pim register: "
literal|"could not copy register head\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* 		 * forward the inner ip6 packet; point m_data at the inner ip6. 		 */
name|m_adj
argument_list|(
name|m
argument_list|,
name|off
operator|+
name|PIM_MINLEN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MRT6DEBUG
if|if
condition|(
name|mrt6debug
operator|&
name|DEBUG_PIM
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"pim6_input: forwarding decapsulated register: "
literal|"src %s, dst %s, mif %d\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufs
argument_list|,
operator|&
name|eip6
operator|->
name|ip6_src
argument_list|)
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6bufd
argument_list|,
operator|&
name|eip6
operator|->
name|ip6_dst
argument_list|)
argument_list|,
name|reg_mif_num
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|rc
operator|=
name|if_simloop
argument_list|(
name|mif6table
index|[
name|reg_mif_num
index|]
operator|.
name|m6_ifp
argument_list|,
name|m
argument_list|,
name|dst
operator|.
name|sin6_family
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* prepare the register head to send to the mrouting daemon */
name|m
operator|=
name|mcp
expr_stmt|;
block|}
comment|/* 	 * Pass the PIM message up to the daemon; if it is a register message 	 * pass the 'head' only up to the daemon. This includes the 	 * encapsulator ip6 header, pim header, register header and the 	 * encapsulated ip6 header. 	 */
name|pim6_input_to_daemon
label|:
name|rip6_input
argument_list|(
operator|&
name|m
argument_list|,
name|offp
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
end_function

end_unit

