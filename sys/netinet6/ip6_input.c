begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$KAME: ip6_input.c,v 1.259 2002/01/21 04:58:09 jinmei Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)ip_input.c	8.2 (Berkeley) 1/4/94  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/pfil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/scope6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_ifattach.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FAST_IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<netipsec/ipsec.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipsec6.h>
end_include

begin_define
define|#
directive|define
name|IPSEC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FAST_IPSEC */
end_comment

begin_include
include|#
directive|include
file|<netinet6/ip6protosw.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|inet6domain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|ip6_protox
index|[
name|IPPROTO_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ifqueue
name|ip6intrq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip6qmaxlen
init|=
name|IFQ_MAXLEN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in6_ifaddr
modifier|*
name|in6_ifaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|callout
name|in6_tmpaddrtimer_ch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ip6_forward_srcrt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|int
name|ip6_sourcecheck
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|int
name|ip6_sourcecheck_interval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|int
name|ip6_ours_check_algorithm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pfil_head
name|inet6_pfil_hook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ip6stat
name|ip6stat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ip6_init2
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ip6aux
modifier|*
name|ip6_setdstifaddr
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|in6_ifaddr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip6_hopopts_input
name|__P
argument_list|(
operator|(
name|u_int32_t
operator|*
operator|,
name|u_int32_t
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PULLDOWN_TEST
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|ip6_pullexthdr
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
name|size_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * IP6 initialization: fill in IP6 protocol switch table.  * All protocols not implemented in kernel go to raw IP6 protocol handler.  */
end_comment

begin_function
name|void
name|ip6_init
parameter_list|()
block|{
name|struct
name|ip6protosw
modifier|*
name|pr
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|protosw
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6protosw
argument_list|)
condition|)
name|panic
argument_list|(
literal|"sizeof(protosw) != sizeof(ip6protosw)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pr
operator|=
operator|(
expr|struct
name|ip6protosw
operator|*
operator|)
name|pffindproto
argument_list|(
name|PF_INET6
argument_list|,
name|IPPROTO_RAW
argument_list|,
name|SOCK_RAW
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ip6_init"
argument_list|)
expr_stmt|;
comment|/* Initialize the entire ip_protox[] array to IPPROTO_RAW. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPPROTO_MAX
condition|;
name|i
operator|++
control|)
name|ip6_protox
index|[
name|i
index|]
operator|=
name|pr
operator|-
name|inet6sw
expr_stmt|;
comment|/* 	 * Cycle through IP protocols and put them into the appropriate place 	 * in ip6_protox[]. 	 */
for|for
control|(
name|pr
operator|=
operator|(
expr|struct
name|ip6protosw
operator|*
operator|)
name|inet6domain
operator|.
name|dom_protosw
init|;
name|pr
operator|<
operator|(
expr|struct
name|ip6protosw
operator|*
operator|)
name|inet6domain
operator|.
name|dom_protoswNPROTOSW
condition|;
name|pr
operator|++
control|)
if|if
condition|(
name|pr
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|PF_INET6
operator|&&
name|pr
operator|->
name|pr_protocol
operator|&&
name|pr
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_RAW
condition|)
block|{
comment|/* Be careful to only index valid IP protocols. */
if|if
condition|(
name|pr
operator|->
name|pr_protocol
operator|<
name|IPPROTO_MAX
condition|)
name|ip6_protox
index|[
name|pr
operator|->
name|pr_protocol
index|]
operator|=
name|pr
operator|-
name|inet6sw
expr_stmt|;
block|}
comment|/* Initialize packet filter hooks. */
name|inet6_pfil_hook
operator|.
name|ph_type
operator|=
name|PFIL_TYPE_AF
expr_stmt|;
name|inet6_pfil_hook
operator|.
name|ph_af
operator|=
name|AF_INET6
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|pfil_head_register
argument_list|(
operator|&
name|inet6_pfil_hook
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: WARNING: unable to register pfil hook, "
literal|"error %d\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ip6intrq
operator|.
name|ifq_maxlen
operator|=
name|ip6qmaxlen
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ip6intrq
operator|.
name|ifq_mtx
argument_list|,
literal|"ip6_inq"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|netisr_register
argument_list|(
name|NETISR_IPV6
argument_list|,
name|ip6_input
argument_list|,
operator|&
name|ip6intrq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scope6_init
argument_list|()
expr_stmt|;
name|addrsel_policy_init
argument_list|()
expr_stmt|;
name|nd6_init
argument_list|()
expr_stmt|;
name|frag6_init
argument_list|()
expr_stmt|;
name|ip6_desync_factor
operator|=
name|arc4random
argument_list|()
operator|%
name|MAX_TEMP_DESYNC_FACTOR
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ip6_init2
parameter_list|(
name|dummy
parameter_list|)
name|void
modifier|*
name|dummy
decl_stmt|;
block|{
comment|/* nd6_timer_init */
name|callout_init
argument_list|(
operator|&
name|nd6_timer_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nd6_timer_ch
argument_list|,
name|hz
argument_list|,
name|nd6_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* timer for regeneranation of temporary addresses randomize ID */
name|callout_init
argument_list|(
operator|&
name|in6_tmpaddrtimer_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|in6_tmpaddrtimer_ch
argument_list|,
operator|(
name|ip6_temp_preferred_lifetime
operator|-
name|ip6_desync_factor
operator|-
name|ip6_temp_regen_advance
operator|)
operator|*
name|hz
argument_list|,
name|in6_tmpaddrtimer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cheat */
end_comment

begin_comment
comment|/* This must be after route_init(), which is now SI_ORDER_THIRD */
end_comment

begin_expr_stmt
name|SYSINIT
argument_list|(
name|netinet6init2
argument_list|,
name|SI_SUB_PROTO_DOMAIN
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|ip6_init2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|struct
name|route_in6
name|ip6_forward_rt
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ip6_input
parameter_list|(
name|m
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|int
name|off
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
decl_stmt|,
name|nest
decl_stmt|;
name|u_int32_t
name|plen
decl_stmt|;
name|u_int32_t
name|rtalert
init|=
operator|~
literal|0
decl_stmt|;
name|int
name|nxt
decl_stmt|,
name|ours
init|=
literal|0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|deliverifp
init|=
name|NULL
decl_stmt|;
name|struct
name|in6_addr
name|odst
decl_stmt|;
name|int
name|srcrt
init|=
literal|0
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
comment|/* XXX for now */
ifdef|#
directive|ifdef
name|IPSEC
comment|/* 	 * should the inner packet be considered authentic? 	 * see comment in ah4_input(). 	 */
if|if
condition|(
name|m
condition|)
block|{
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_AUTHIPHDR
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_AUTHIPDGM
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * make sure we don't have onion peering information into m_tag. 	 */
name|ip6_delaux
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * mbuf statistics 	 */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
name|ip6stat
operator|.
name|ip6s_mext2m
operator|++
expr_stmt|;
else|else
name|ip6stat
operator|.
name|ip6s_mext1
operator|++
expr_stmt|;
block|}
else|else
block|{
define|#
directive|define
name|M2MMAX
value|(sizeof(ip6stat.ip6s_m2m)/sizeof(ip6stat.ip6s_m2m[0]))
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_LOOP
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_m2m
index|[
name|loif
index|[
literal|0
index|]
operator|.
name|if_index
index|]
operator|++
expr_stmt|;
comment|/* XXX */
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_index
operator|<
name|M2MMAX
condition|)
name|ip6stat
operator|.
name|ip6s_m2m
index|[
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_index
index|]
operator|++
expr_stmt|;
else|else
name|ip6stat
operator|.
name|ip6s_m2m
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
else|else
name|ip6stat
operator|.
name|ip6s_m1
operator|++
expr_stmt|;
undef|#
directive|undef
name|M2MMAX
block|}
comment|/* drop the packet if IPv6 operation is disabled on the IF */
if|if
condition|(
operator|(
name|ND_IFINFO
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_receive
argument_list|)
expr_stmt|;
name|ip6stat
operator|.
name|ip6s_total
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|PULLDOWN_TEST
comment|/* 	 * L2 bridge code and some other code can return mbuf chain 	 * that does not conform to KAME requirement.  too bad. 	 * XXX: fails to join if interface MTU> MCLBYTES.  jumbogram? 	 */
if|if
condition|(
name|m
operator|&&
name|m
operator|->
name|m_next
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|MCLBYTES
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|M_MOVE_PKTHDR
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
comment|/* ENOBUFS */
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|n
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
name|IP6_EXTHDR_CHECK
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
comment|/* nothing */
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|inifp
decl_stmt|;
name|inifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|inifp
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ip6
operator|->
name|ip6_vfc
operator|&
name|IPV6_VERSION_MASK
operator|)
operator|!=
name|IPV6_VERSION
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badvers
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip6stat
operator|.
name|ip6s_nxthist
index|[
name|ip6
operator|->
name|ip6_nxt
index|]
operator|++
expr_stmt|;
comment|/* 	 * Check against address spoofing/corruption. 	 */
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|||
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
comment|/* 		 * XXX: "badscope" is not very suitable for a multicast source. 		 */
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_addrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_MC_INTFACELOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|&&
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_LOOP
operator|)
condition|)
block|{
comment|/* 		 * In this case, the packet should come from the loopback 		 * interface.  However, we cannot just check the if_flags, 		 * because ip6_mloopback() passes the "actual" interface 		 * as the outgoing/incoming interface. 		 */
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_addrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|ALTQ
if|if
condition|(
name|altq_input
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|altq_input
call|)
argument_list|(
name|m
argument_list|,
name|AF_INET6
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* packet is dropped by traffic conditioner */
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * The following check is not documented in specs.  A malicious 	 * party may be able to use IPv4 mapped addr to confuse tcp/udp stack 	 * and bypass security checks (act as if it was from 127.0.0.1 by using 	 * IPv6 src ::ffff:127.0.0.1).  Be cautious. 	 * 	 * This check chokes if we are in an SIIT cloud.  As none of BSDs 	 * support IPv4-less kernel compilation, we cannot support SIIT 	 * environment at all.  So, it makes more sense for us to reject any 	 * malicious packets for non-SIIT environment, than try to do a 	 * partial support for SIIT environment. 	 */
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|||
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_addrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|#
directive|if
literal|0
comment|/* 	 * Reject packets with IPv4 compatible addresses (auto tunnel). 	 * 	 * The code forbids auto tunnel relay case in RFC1933 (the check is 	 * stronger than RFC1933).  We may want to re-enable it if mech-xx 	 * is revised to forbid relaying case. 	 */
block|if (IN6_IS_ADDR_V4COMPAT(&ip6->ip6_src) || 	    IN6_IS_ADDR_V4COMPAT(&ip6->ip6_dst)) { 		ip6stat.ip6s_badscope++; 		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_addrerr); 		goto bad; 	}
endif|#
directive|endif
comment|/* 	 * Run through list of hooks for input packets. 	 * 	 * NB: Beware of the destination address changing 	 *     (e.g. by NAT rewriting).  When this happens, 	 *     tell ip6_forward to do the right thing. 	 */
name|odst
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
comment|/* Jump over all PFIL processing if hooks are not active. */
if|if
condition|(
operator|!
name|PFIL_HOOKED
argument_list|(
operator|&
name|inet6_pfil_hook
argument_list|)
condition|)
goto|goto
name|passin
goto|;
if|if
condition|(
name|pfil_run_hooks
argument_list|(
operator|&
name|inet6_pfil_hook
argument_list|,
operator|&
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|PFIL_IN
argument_list|,
name|NULL
argument_list|)
condition|)
return|return;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
comment|/* consumed by filter */
return|return;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|srcrt
operator|=
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|odst
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
expr_stmt|;
name|passin
label|:
comment|/* 	 * Disambiguate address scope zones (if there is ambiguity). 	 * We first make sure that the original source or destination address 	 * is not in our internal form for scoped addresses.  Such addresses 	 * are not necessarily invalid spec-wise, but we cannot accept them due 	 * to the usage conflict. 	 * in6_setscope() then also checks and rejects the cases where src or 	 * dst are the loopback address and the receiving interface 	 * is not loopback. 	 */
if|if
condition|(
name|in6_clearscope
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|||
name|in6_clearscope
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
comment|/* XXX */
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|in6_setscope
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|NULL
argument_list|)
operator|||
name|in6_setscope
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Multicast check 	 */
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|struct
name|in6_multi
modifier|*
name|in6m
init|=
literal|0
decl_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_mcast
argument_list|)
expr_stmt|;
comment|/* 		 * See if we belong to the destination multicast group on the 		 * arrival interface. 		 */
name|IN6_LOOKUP_MULTI
argument_list|(
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|in6m
argument_list|)
expr_stmt|;
if|if
condition|(
name|in6m
condition|)
name|ours
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ip6_mrouter
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_notmember
operator|++
expr_stmt|;
name|ip6stat
operator|.
name|ip6s_cantforward
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_discard
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|deliverifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
goto|goto
name|hbhcheck
goto|;
block|}
comment|/* 	 *  Unicast check 	 */
if|if
condition|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|!=
name|NULL
operator|&&
operator|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|!=
literal|0
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
operator|&
name|ip6_forward_rt
operator|.
name|ro_dst
operator|)
operator|)
operator|->
name|sin6_addr
argument_list|)
condition|)
name|ip6stat
operator|.
name|ip6s_forward_cachehit
operator|++
expr_stmt|;
else|else
block|{
name|struct
name|sockaddr_in6
modifier|*
name|dst6
decl_stmt|;
if|if
condition|(
name|ip6_forward_rt
operator|.
name|ro_rt
condition|)
block|{
comment|/* route is down or destination is different */
name|ip6stat
operator|.
name|ip6s_forward_cachemiss
operator|++
expr_stmt|;
name|RTFREE
argument_list|(
name|ip6_forward_rt
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|ip6_forward_rt
operator|.
name|ro_rt
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|ip6_forward_rt
operator|.
name|ro_dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|dst6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ip6_forward_rt
operator|.
name|ro_dst
expr_stmt|;
name|dst6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|dst6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|dst6
operator|->
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|rtalloc
argument_list|(
operator|(
expr|struct
name|route
operator|*
operator|)
operator|&
name|ip6_forward_rt
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|rt6_key
parameter_list|(
name|r
parameter_list|)
value|((struct sockaddr_in6 *)((r)->rt_nodes->rn_key))
comment|/* 	 * Accept the packet if the forwarding interface to the destination 	 * according to the routing table is the loopback interface, 	 * unless the associated route has a gateway. 	 * Note that this approach causes to accept a packet if there is a 	 * route to the loopback interface for the destination of the packet. 	 * But we think it's even useful in some situations, e.g. when using 	 * a special daemon which wants to intercept the packet. 	 * 	 * XXX: some OSes automatically make a cloned route for the destination 	 * of an outgoing packet.  If the outgoing interface of the packet 	 * is a loopback one, the kernel would consider the packet to be 	 * accepted, even if we have no such address assinged on the interface. 	 * We check the cloned flag of the route entry to reject such cases, 	 * assuming that route entries for our own addresses are not made by 	 * cloning (it should be true because in6_addloop explicitly installs 	 * the host route).  However, we might have to do an explicit check 	 * while it would be less efficient.  Or, should we rather install a 	 * reject route for such a case? 	 */
if|if
condition|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|&&
operator|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_HOST
operator||
name|RTF_GATEWAY
operator|)
operator|)
operator|==
name|RTF_HOST
operator|&&
ifdef|#
directive|ifdef
name|RTF_WASCLONED
operator|!
operator|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_WASCLONED
operator|)
operator|&&
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTF_CLONED
operator|!
operator|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_CLONED
operator|)
operator|&&
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* 	     * The check below is redundant since the comparison of 	     * the destination and the key of the rtentry has 	     * already done through looking up the routing table. 	     */
expr|IN6_ARE_ADDR_EQUAL(&ip6->ip6_dst,&rt6_key(ip6_forward_rt.ro_rt)->sin6_addr)
endif|#
directive|endif
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_type
operator|==
name|IFT_LOOP
condition|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ia6
init|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifa
decl_stmt|;
comment|/* 		 * record address information into m_tag. 		 */
operator|(
name|void
operator|)
name|ip6_setdstifaddr
argument_list|(
name|m
argument_list|,
name|ia6
argument_list|)
expr_stmt|;
comment|/* 		 * packets to a tentative, duplicated, or somehow invalid 		 * address must not be accepted. 		 */
if|if
condition|(
operator|!
operator|(
name|ia6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_NOTREADY
operator|)
condition|)
block|{
comment|/* this address is ready */
name|ours
operator|=
literal|1
expr_stmt|;
name|deliverifp
operator|=
name|ia6
operator|->
name|ia_ifp
expr_stmt|;
comment|/* correct? */
comment|/* Count the packet in the ip address stats */
name|ia6
operator|->
name|ia_ifa
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|ia6
operator|->
name|ia_ifa
operator|.
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
goto|goto
name|hbhcheck
goto|;
block|}
else|else
block|{
name|char
name|ip6bufs
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|char
name|ip6bufd
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
comment|/* address is not ready, so discard the packet. */
name|nd6log
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ip6_input: packet to an unready address %s->%s\n"
operator|,
name|ip6_sprintf
argument_list|(
name|ip6bufs
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|,
name|ip6_sprintf
argument_list|(
name|ip6bufd
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
comment|/* 	 * FAITH (Firewall Aided Internet Translator) 	 */
if|if
condition|(
name|ip6_keepfaith
condition|)
block|{
if|if
condition|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|&&
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|&&
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_type
operator|==
name|IFT_FAITH
condition|)
block|{
comment|/* XXX do we need more sanity checks? */
name|ours
operator|=
literal|1
expr_stmt|;
name|deliverifp
operator|=
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
comment|/* faith */
goto|goto
name|hbhcheck
goto|;
block|}
block|}
comment|/* 	 * Now there is no reason to process the packet if it's not our own 	 * and we're not a router. 	 */
if|if
condition|(
operator|!
name|ip6_forwarding
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_cantforward
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_discard
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|hbhcheck
label|:
comment|/* 	 * record address information into m_tag, if we don't have one yet. 	 * note that we are unable to record it, if the address is not listed 	 * as our interface address (e.g. multicast addresses, addresses 	 * within FAITH prefixes and such). 	 */
if|if
condition|(
name|deliverifp
operator|&&
operator|!
name|ip6_getdstifaddr
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|;
name|ia6
operator|=
name|in6_ifawithifp
argument_list|(
name|deliverifp
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia6
condition|)
block|{
if|if
condition|(
operator|!
name|ip6_setdstifaddr
argument_list|(
name|m
argument_list|,
name|ia6
argument_list|)
condition|)
block|{
comment|/* 				 * XXX maybe we should drop the packet here, 				 * as we could not provide enough information 				 * to the upper layers. 				 */
block|}
block|}
block|}
comment|/* 	 * Process Hop-by-Hop options header if it's contained. 	 * m may be modified in ip6_hopopts_input(). 	 * If a JumboPayload option is included, plen will also be modified. 	 */
name|plen
operator|=
operator|(
name|u_int32_t
operator|)
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6
operator|->
name|ip6_nxt
operator|==
name|IPPROTO_HOPOPTS
condition|)
block|{
name|struct
name|ip6_hbh
modifier|*
name|hbh
decl_stmt|;
if|if
condition|(
name|ip6_hopopts_input
argument_list|(
operator|&
name|plen
argument_list|,
operator|&
name|rtalert
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|off
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/*touches NULL pointer*/
block|in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_discard);
endif|#
directive|endif
return|return;
comment|/* m have already been freed */
block|}
comment|/* adjust pointer */
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
comment|/* 		 * if the payload length field is 0 and the next header field 		 * indicates Hop-by-Hop Options header, then a Jumbo Payload 		 * option MUST be included. 		 */
if|if
condition|(
name|ip6
operator|->
name|ip6_plen
operator|==
literal|0
operator|&&
name|plen
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Note that if a valid jumbo payload option is 			 * contained, ip6_hopopts_input() must set a valid 			 * (non-zero) payload length to the variable plen. 			 */
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_discard
argument_list|)
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_HEADER
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6
operator|->
name|ip6_plen
operator|-
operator|(
name|caddr_t
operator|)
name|ip6
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|PULLDOWN_TEST
comment|/* ip6_hopopts_input() ensures that mbuf is contiguous */
name|hbh
operator|=
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
operator|(
name|ip6
operator|+
literal|1
operator|)
expr_stmt|;
else|#
directive|else
name|IP6_EXTHDR_GET
argument_list|(
name|hbh
argument_list|,
expr|struct
name|ip6_hbh
operator|*
argument_list|,
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hbh
operator|==
name|NULL
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|nxt
operator|=
name|hbh
operator|->
name|ip6h_nxt
expr_stmt|;
comment|/* 		 * accept the packet if a router alert option is included 		 * and we act as an IPv6 router. 		 */
if|if
condition|(
name|rtalert
operator|!=
operator|~
literal|0
operator|&&
name|ip6_forwarding
condition|)
name|ours
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|nxt
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
comment|/* 	 * Check that the amount of data in the buffers 	 * is as at least much as the IPv6 header would have us expect. 	 * Trim mbufs if longer than we expect. 	 * Drop packet if shorter than we expect. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|<
name|plen
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_truncated
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
expr_stmt|;
block|}
else|else
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Forward if desirable. 	 */
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
comment|/* 		 * If we are acting as a multicast router, all 		 * incoming multicast packets are passed to the 		 * kernel-level multicast forwarding function. 		 * The packet is returned (relatively) intact; if 		 * ip6_mforward() returns a non-zero value, the packet 		 * must be discarded, else it may be accepted below. 		 */
if|if
condition|(
name|ip6_mrouter
operator|&&
name|ip6_mforward
argument_list|(
name|ip6
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_cantforward
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ours
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ours
condition|)
block|{
name|ip6_forward
argument_list|(
name|m
argument_list|,
name|srcrt
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Malicious party may be able to use IPv4 mapped addr to confuse 	 * tcp/udp stack and bypass security checks (act as if it was from 	 * 127.0.0.1 by using IPv6 src ::ffff:127.0.0.1).  Be cautious. 	 * 	 * For SIIT end node behavior, you may want to disable the check. 	 * However, you will  become vulnerable to attacks using IPv4 mapped 	 * source. 	 */
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|||
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_addrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Tell launch routine the next header 	 */
name|ip6stat
operator|.
name|ip6s_delivered
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|deliverifp
argument_list|,
name|ifs6_in_deliver
argument_list|)
expr_stmt|;
name|nest
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nxt
operator|!=
name|IPPROTO_DONE
condition|)
block|{
if|if
condition|(
name|ip6_hdrnestlimit
operator|&&
operator|(
operator|++
name|nest
operator|>
name|ip6_hdrnestlimit
operator|)
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toomanyhdr
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * protection against faulty packet - there should be 		 * more sanity checks in header chain processing. 		 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_truncated
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|IPSEC
comment|/* 		 * enforce IPsec policy checking if we are seeing last header. 		 * note that we do not visit this with protocols with pcb layer 		 * code - like udp/tcp/raw ip. 		 */
if|if
condition|(
operator|(
name|inet6sw
index|[
name|ip6_protox
index|[
name|nxt
index|]
index|]
operator|.
name|pr_flags
operator|&
name|PR_LASTHDR
operator|)
operator|!=
literal|0
operator|&&
name|ipsec6_in_reject
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ipsec6stat
operator|.
name|in_polvio
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
name|nxt
operator|=
operator|(
operator|*
name|inet6sw
index|[
name|ip6_protox
index|[
name|nxt
index|]
index|]
operator|.
name|pr_input
operator|)
operator|(
operator|&
name|m
operator|,
operator|&
name|off
operator|,
name|nxt
operator|)
expr_stmt|;
block|}
return|return;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set/grab in6_ifaddr correspond to IPv6 destination address.  * XXX backward compatibility wrapper  */
end_comment

begin_function
specifier|static
name|struct
name|ip6aux
modifier|*
name|ip6_setdstifaddr
parameter_list|(
name|m
parameter_list|,
name|ia6
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|;
block|{
name|struct
name|ip6aux
modifier|*
name|ip6a
decl_stmt|;
name|ip6a
operator|=
name|ip6_addaux
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6a
condition|)
name|ip6a
operator|->
name|ip6a_dstia6
operator|=
name|ia6
expr_stmt|;
return|return
name|ip6a
return|;
comment|/* NULL if failed to set */
block|}
end_function

begin_function
name|struct
name|in6_ifaddr
modifier|*
name|ip6_getdstifaddr
parameter_list|(
name|m
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|ip6aux
modifier|*
name|ip6a
decl_stmt|;
name|ip6a
operator|=
name|ip6_findaux
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6a
condition|)
return|return
name|ip6a
operator|->
name|ip6a_dstia6
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Hop-by-Hop options header processing. If a valid jumbo payload option is  * included, the real payload length will be stored in plenp.  */
end_comment

begin_function
specifier|static
name|int
name|ip6_hopopts_input
parameter_list|(
name|plenp
parameter_list|,
name|rtalertp
parameter_list|,
name|mp
parameter_list|,
name|offp
parameter_list|)
name|u_int32_t
modifier|*
name|plenp
decl_stmt|;
name|u_int32_t
modifier|*
name|rtalertp
decl_stmt|;
comment|/* XXX: should be stored more smart way */
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
modifier|*
name|offp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|int
name|off
init|=
operator|*
name|offp
decl_stmt|,
name|hbhlen
decl_stmt|;
name|struct
name|ip6_hbh
modifier|*
name|hbh
decl_stmt|;
name|u_int8_t
modifier|*
name|opt
decl_stmt|;
comment|/* validation of the length of the header */
ifndef|#
directive|ifndef
name|PULLDOWN_TEST
name|IP6_EXTHDR_CHECK
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hbh
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hbh
operator|=
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|hbhlen
operator|=
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|IP6_EXTHDR_CHECK
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|hbhlen
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hbh
operator|=
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
else|#
directive|else
name|IP6_EXTHDR_GET
argument_list|(
name|hbh
argument_list|,
expr|struct
name|ip6_hbh
operator|*
argument_list|,
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hbh
operator|==
name|NULL
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|hbhlen
operator|=
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|IP6_EXTHDR_GET
argument_list|(
name|hbh
argument_list|,
expr|struct
name|ip6_hbh
operator|*
argument_list|,
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|hbhlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|hbh
operator|==
name|NULL
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
name|off
operator|+=
name|hbhlen
expr_stmt|;
name|hbhlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
expr_stmt|;
name|opt
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|hbh
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6_process_hopopts
argument_list|(
name|m
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|hbh
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
argument_list|,
name|hbhlen
argument_list|,
name|rtalertp
argument_list|,
name|plenp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|offp
operator|=
name|off
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search header for all Hop-by-hop options and process each option.  * This function is separate from ip6_hopopts_input() in order to  * handle a case where the sending node itself process its hop-by-hop  * options header. In such a case, the function is called from ip6_output().  *  * The function assumes that hbh header is located right after the IPv6 header  * (RFC2460 p7), opthead is pointer into data content in m, and opthead to  * opthead + hbhlen is located in continuous memory region.  */
end_comment

begin_function
name|int
name|ip6_process_hopopts
parameter_list|(
name|m
parameter_list|,
name|opthead
parameter_list|,
name|hbhlen
parameter_list|,
name|rtalertp
parameter_list|,
name|plenp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int8_t
modifier|*
name|opthead
decl_stmt|;
name|int
name|hbhlen
decl_stmt|;
name|u_int32_t
modifier|*
name|rtalertp
decl_stmt|;
name|u_int32_t
modifier|*
name|plenp
decl_stmt|;
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|int
name|optlen
init|=
literal|0
decl_stmt|;
name|u_int8_t
modifier|*
name|opt
init|=
name|opthead
decl_stmt|;
name|u_int16_t
name|rtalert_val
decl_stmt|;
name|u_int32_t
name|jumboplen
decl_stmt|;
specifier|const
name|int
name|erroff
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|hbhlen
operator|>
literal|0
condition|;
name|hbhlen
operator|-=
name|optlen
operator|,
name|opt
operator|+=
name|optlen
control|)
block|{
switch|switch
condition|(
operator|*
name|opt
condition|)
block|{
case|case
name|IP6OPT_PAD1
case|:
name|optlen
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IP6OPT_PADN
case|:
if|if
condition|(
name|hbhlen
operator|<
name|IP6OPT_MINLEN
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|optlen
operator|=
operator|*
operator|(
name|opt
operator|+
literal|1
operator|)
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|IP6OPT_ROUTER_ALERT
case|:
comment|/* XXX may need check for alignment */
if|if
condition|(
name|hbhlen
operator|<
name|IP6OPT_RTALERT_LEN
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|*
operator|(
name|opt
operator|+
literal|1
operator|)
operator|!=
name|IP6OPT_RTALERT_LEN
operator|-
literal|2
condition|)
block|{
comment|/* XXX stat */
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_HEADER
argument_list|,
name|erroff
operator|+
name|opt
operator|+
literal|1
operator|-
name|opthead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|optlen
operator|=
name|IP6OPT_RTALERT_LEN
expr_stmt|;
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|opt
operator|+
literal|2
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rtalert_val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|*
name|rtalertp
operator|=
name|ntohs
argument_list|(
name|rtalert_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP6OPT_JUMBO
case|:
comment|/* XXX may need check for alignment */
if|if
condition|(
name|hbhlen
operator|<
name|IP6OPT_JUMBO_LEN
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|*
operator|(
name|opt
operator|+
literal|1
operator|)
operator|!=
name|IP6OPT_JUMBO_LEN
operator|-
literal|2
condition|)
block|{
comment|/* XXX stat */
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_HEADER
argument_list|,
name|erroff
operator|+
name|opt
operator|+
literal|1
operator|-
name|opthead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|optlen
operator|=
name|IP6OPT_JUMBO_LEN
expr_stmt|;
comment|/* 			 * IPv6 packets that have non 0 payload length 			 * must not contain a jumbo payload option. 			 */
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6
operator|->
name|ip6_plen
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_HEADER
argument_list|,
name|erroff
operator|+
name|opt
operator|-
name|opthead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 			 * We may see jumbolen in unaligned location, so 			 * we'd need to perform bcopy(). 			 */
name|bcopy
argument_list|(
name|opt
operator|+
literal|2
argument_list|,
operator|&
name|jumboplen
argument_list|,
sizeof|sizeof
argument_list|(
name|jumboplen
argument_list|)
argument_list|)
expr_stmt|;
name|jumboplen
operator|=
operator|(
name|u_int32_t
operator|)
name|htonl
argument_list|(
name|jumboplen
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* 			 * if there are multiple jumbo payload options, 			 * *plenp will be non-zero and the packet will be 			 * rejected. 			 * the behavior may need some debate in ipngwg - 			 * multiple options does not make sense, however, 			 * there's no explicit mention in specification. 			 */
if|if
condition|(
operator|*
name|plenp
operator|!=
literal|0
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_HEADER
argument_list|,
name|erroff
operator|+
name|opt
operator|+
literal|2
operator|-
name|opthead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 			 * jumbo payload length must be larger than 65535. 			 */
if|if
condition|(
name|jumboplen
operator|<=
name|IPV6_MAXPACKET
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_HEADER
argument_list|,
name|erroff
operator|+
name|opt
operator|+
literal|2
operator|-
name|opthead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|plenp
operator|=
name|jumboplen
expr_stmt|;
break|break;
default|default:
comment|/* unknown option */
if|if
condition|(
name|hbhlen
operator|<
name|IP6OPT_MINLEN
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|optlen
operator|=
name|ip6_unknown_opt
argument_list|(
name|opt
argument_list|,
name|m
argument_list|,
name|erroff
operator|+
name|opt
operator|-
name|opthead
argument_list|)
expr_stmt|;
if|if
condition|(
name|optlen
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|optlen
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unknown option processing.  * The third argument `off' is the offset from the IPv6 header to the option,  * which is necessary if the IPv6 header the and option header and IPv6 header  * is not continuous in order to return an ICMPv6 error.  */
end_comment

begin_function
name|int
name|ip6_unknown_opt
parameter_list|(
name|optp
parameter_list|,
name|m
parameter_list|,
name|off
parameter_list|)
name|u_int8_t
modifier|*
name|optp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
switch|switch
condition|(
name|IP6OPT_TYPE
argument_list|(
operator|*
name|optp
argument_list|)
condition|)
block|{
case|case
name|IP6OPT_TYPE_SKIP
case|:
comment|/* ignore the option */
return|return
operator|(
operator|(
name|int
operator|)
operator|*
operator|(
name|optp
operator|+
literal|1
operator|)
operator|)
return|;
case|case
name|IP6OPT_TYPE_DISCARD
case|:
comment|/* silently discard */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|IP6OPT_TYPE_FORCEICMP
case|:
comment|/* send ICMP even if multicasted */
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_OPTION
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|IP6OPT_TYPE_ICMP
case|:
comment|/* send ICMP if not multicasted */
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|||
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_OPTION
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* XXX: NOTREACHED */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the "control" list for this pcb.  * The function will not modify mbuf chain at all.  *  * with KAME mbuf chain restriction:  * The routine will be called from upper layer handlers like tcp6_input().  * Thus the routine assumes that the caller (tcp6_input) have already  * called IP6_EXTHDR_CHECK() and all the extension headers are located in the  * very first mbuf on the mbuf chain.  */
end_comment

begin_function
name|void
name|ip6_savecontrol
parameter_list|(
name|in6p
parameter_list|,
name|m
parameter_list|,
name|mp
parameter_list|)
name|struct
name|inpcb
modifier|*
name|in6p
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
decl|*
modifier|*
name|mp
decl_stmt|;
end_function

begin_block
block|{
define|#
directive|define
name|IS2292
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((in6p->in6p_flags& IN6P_RFC2292) ? (x) : (y))
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SO_TIMESTAMP
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_socket
operator|->
name|so_options
operator|&
name|SO_TIMESTAMP
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|,
name|SCM_TIMESTAMP
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ip6
operator|->
name|ip6_vfc
operator|&
name|IPV6_VERSION_MASK
operator|)
operator|!=
name|IPV6_VERSION
condition|)
return|return;
comment|/* RFC 2292 sec. 5 */
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_PKTINFO
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|in6_pktinfo
name|pi6
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
operator|&
name|pi6
operator|.
name|ipi6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|pi6
operator|.
name|ipi6_addr
argument_list|)
expr_stmt|;
comment|/* XXX */
name|pi6
operator|.
name|ipi6_ifindex
operator|=
operator|(
name|m
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|)
condition|?
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_index
else|:
literal|0
expr_stmt|;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|pi6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|,
name|IS2292
argument_list|(
name|IPV6_2292PKTINFO
argument_list|,
name|IPV6_PKTINFO
argument_list|)
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_HOPLIMIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|hlim
init|=
name|ip6
operator|->
name|ip6_hlim
operator|&
literal|0xff
decl_stmt|;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|hlim
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|IS2292
argument_list|(
name|IPV6_2292HOPLIMIT
argument_list|,
name|IPV6_HOPLIMIT
argument_list|)
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_TCLASS
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int32_t
name|flowinfo
decl_stmt|;
name|int
name|tclass
decl_stmt|;
name|flowinfo
operator|=
operator|(
name|u_int32_t
operator|)
name|ntohl
argument_list|(
name|ip6
operator|->
name|ip6_flow
operator|&
name|IPV6_FLOWINFO_MASK
argument_list|)
expr_stmt|;
name|flowinfo
operator|>>=
literal|20
expr_stmt|;
name|tclass
operator|=
name|flowinfo
operator|&
literal|0xff
expr_stmt|;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tclass
argument_list|,
sizeof|sizeof
argument_list|(
name|tclass
argument_list|)
argument_list|,
name|IPV6_TCLASS
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* 	 * IPV6_HOPOPTS socket option.  Recall that we required super-user 	 * privilege for the option (see ip6_ctloutput), but it might be too 	 * strict, since there might be some hop-by-hop options which can be 	 * returned to normal user. 	 * See also RFC 2292 section 6 (or RFC 3542 section 8). 	 */
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_HOPOPTS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Check if a hop-by-hop options header is contatined in the 		 * received packet, and if so, store the options as ancillary 		 * data. Note that a hop-by-hop options header must be 		 * just after the IPv6 header, which is assured through the 		 * IPv6 input processing. 		 */
if|if
condition|(
name|ip6
operator|->
name|ip6_nxt
operator|==
name|IPPROTO_HOPOPTS
condition|)
block|{
name|struct
name|ip6_hbh
modifier|*
name|hbh
decl_stmt|;
name|int
name|hbhlen
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PULLDOWN_TEST
name|struct
name|mbuf
modifier|*
name|ext
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PULLDOWN_TEST
name|hbh
operator|=
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
operator|(
name|ip6
operator|+
literal|1
operator|)
expr_stmt|;
name|hbhlen
operator|=
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
else|#
directive|else
name|ext
operator|=
name|ip6_pullexthdr
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|ip6
operator|->
name|ip6_nxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|==
name|NULL
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
return|return;
block|}
name|hbh
operator|=
name|mtod
argument_list|(
name|ext
argument_list|,
expr|struct
name|ip6_hbh
operator|*
argument_list|)
expr_stmt|;
name|hbhlen
operator|=
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|hbhlen
operator|!=
name|ext
operator|->
name|m_len
condition|)
block|{
name|m_freem
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 			 * XXX: We copy the whole header even if a 			 * jumbo payload option is included, the option which 			 * is to be removed before returning according to 			 * RFC2292. 			 * Note: this constraint is removed in RFC3542 			 */
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
name|hbh
argument_list|,
name|hbhlen
argument_list|,
name|IS2292
argument_list|(
name|IPV6_2292HOPOPTS
argument_list|,
name|IPV6_HOPOPTS
argument_list|)
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
ifdef|#
directive|ifdef
name|PULLDOWN_TEST
name|m_freem
argument_list|(
name|ext
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_flags
operator|&
operator|(
name|IN6P_RTHDR
operator||
name|IN6P_DSTOPTS
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|nxt
init|=
name|ip6
operator|->
name|ip6_nxt
decl_stmt|,
name|off
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
decl_stmt|;
comment|/* 		 * Search for destination options headers or routing 		 * header(s) through the header chain, and stores each 		 * header as ancillary data. 		 * Note that the order of the headers remains in 		 * the chain of ancillary data. 		 */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* is explicit loop prevention necessary? */
name|struct
name|ip6_ext
modifier|*
name|ip6e
init|=
name|NULL
decl_stmt|;
name|int
name|elen
decl_stmt|;
ifdef|#
directive|ifdef
name|PULLDOWN_TEST
name|struct
name|mbuf
modifier|*
name|ext
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* 			 * if it is not an extension header, don't try to 			 * pull it from the chain. 			 */
switch|switch
condition|(
name|nxt
condition|)
block|{
case|case
name|IPPROTO_DSTOPTS
case|:
case|case
name|IPPROTO_ROUTING
case|:
case|case
name|IPPROTO_HOPOPTS
case|:
case|case
name|IPPROTO_AH
case|:
comment|/* is it possible? */
break|break;
default|default:
goto|goto
name|loopend
goto|;
block|}
ifndef|#
directive|ifndef
name|PULLDOWN_TEST
if|if
condition|(
name|off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6e
argument_list|)
operator|>
name|m
operator|->
name|m_len
condition|)
goto|goto
name|loopend
goto|;
name|ip6e
operator|=
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
if|if
condition|(
name|nxt
operator|==
name|IPPROTO_AH
condition|)
name|elen
operator|=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
else|else
name|elen
operator|=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|elen
operator|>
name|m
operator|->
name|m_len
condition|)
goto|goto
name|loopend
goto|;
else|#
directive|else
name|ext
operator|=
name|ip6_pullexthdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|==
name|NULL
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
return|return;
block|}
name|ip6e
operator|=
name|mtod
argument_list|(
name|ext
argument_list|,
expr|struct
name|ip6_ext
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxt
operator|==
name|IPPROTO_AH
condition|)
name|elen
operator|=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
else|else
name|elen
operator|=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|elen
operator|!=
name|ext
operator|->
name|m_len
condition|)
block|{
name|m_freem
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|nxt
condition|)
block|{
case|case
name|IPPROTO_DSTOPTS
case|:
if|if
condition|(
operator|!
operator|(
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_DSTOPTS
operator|)
condition|)
break|break;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip6e
argument_list|,
name|elen
argument_list|,
name|IS2292
argument_list|(
name|IPV6_2292DSTOPTS
argument_list|,
name|IPV6_DSTOPTS
argument_list|)
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
break|break;
case|case
name|IPPROTO_ROUTING
case|:
if|if
condition|(
operator|!
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_RTHDR
condition|)
break|break;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip6e
argument_list|,
name|elen
argument_list|,
name|IS2292
argument_list|(
name|IPV6_2292RTHDR
argument_list|,
name|IPV6_RTHDR
argument_list|)
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
break|break;
case|case
name|IPPROTO_HOPOPTS
case|:
case|case
name|IPPROTO_AH
case|:
comment|/* is it possible? */
break|break;
default|default:
comment|/* 			 	 * other cases have been filtered in the above. 				 * none will visit this case.  here we supply 				 * the code just in case (nxt overwritten or 				 * other cases). 				 */
ifdef|#
directive|ifdef
name|PULLDOWN_TEST
name|m_freem
argument_list|(
name|ext
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|loopend
goto|;
block|}
comment|/* proceed with the next header. */
name|off
operator|+=
name|elen
expr_stmt|;
name|nxt
operator|=
name|ip6e
operator|->
name|ip6e_nxt
expr_stmt|;
name|ip6e
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|PULLDOWN_TEST
name|m_freem
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|ext
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
name|loopend
label|:
empty_stmt|;
block|}
undef|#
directive|undef
name|IS2292
block|}
end_block

begin_function
name|void
name|ip6_notify_pmtu
parameter_list|(
name|in6p
parameter_list|,
name|dst
parameter_list|,
name|mtu
parameter_list|)
name|struct
name|inpcb
modifier|*
name|in6p
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|dst
decl_stmt|;
name|u_int32_t
modifier|*
name|mtu
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_mtu
decl_stmt|;
name|struct
name|ip6_mtuinfo
name|mtuctl
decl_stmt|;
name|so
operator|=
name|in6p
operator|->
name|inp_socket
expr_stmt|;
if|if
condition|(
name|mtu
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
comment|/* I believe this is impossible */
name|panic
argument_list|(
literal|"ip6_notify_pmtu: socket is NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
operator|&
name|mtuctl
argument_list|,
sizeof|sizeof
argument_list|(
name|mtuctl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero-clear for safety */
name|mtuctl
operator|.
name|ip6m_mtu
operator|=
operator|*
name|mtu
expr_stmt|;
name|mtuctl
operator|.
name|ip6m_addr
operator|=
operator|*
name|dst
expr_stmt|;
if|if
condition|(
name|sa6_recoverscope
argument_list|(
operator|&
name|mtuctl
operator|.
name|ip6m_addr
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|m_mtu
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|mtuctl
argument_list|,
sizeof|sizeof
argument_list|(
name|mtuctl
argument_list|)
argument_list|,
name|IPV6_PATHMTU
argument_list|,
name|IPPROTO_IPV6
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|sbappendaddr
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
argument_list|,
name|NULL
argument_list|,
name|m_mtu
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m_mtu
argument_list|)
expr_stmt|;
comment|/* XXX: should count statistics */
block|}
else|else
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PULLDOWN_TEST
end_ifdef

begin_comment
comment|/*  * pull single extension header from mbuf chain.  returns single mbuf that  * contains the result, or NULL on error.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ip6_pullexthdr
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|,
name|nxt
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|size_t
name|off
decl_stmt|;
name|int
name|nxt
decl_stmt|;
block|{
name|struct
name|ip6_ext
name|ip6e
decl_stmt|;
name|size_t
name|elen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
switch|switch
condition|(
name|nxt
condition|)
block|{
case|case
name|IPPROTO_DSTOPTS
case|:
case|case
name|IPPROTO_ROUTING
case|:
case|case
name|IPPROTO_HOPOPTS
case|:
case|case
name|IPPROTO_AH
case|:
comment|/* is it possible? */
break|break;
default|default:
name|printf
argument_list|(
literal|"ip6_pullexthdr: invalid nxt=%d\n"
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6e
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6e
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxt
operator|==
name|IPPROTO_AH
condition|)
name|elen
operator|=
operator|(
name|ip6e
operator|.
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
else|else
name|elen
operator|=
operator|(
name|ip6e
operator|.
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|MGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|elen
operator|>=
name|MLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|NULL
return|;
name|n
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|elen
operator|>=
name|M_TRAILINGSPACE
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|m_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|elen
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|elen
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get pointer to the previous header followed by the header  * currently processed.  * XXX: This function supposes that  *	M includes all headers,  *	the next header field and the header length field of each header  *	are valid, and  *	the sum of each header length equals to OFF.  * Because of these assumptions, this function must be called very  * carefully. Moreover, it will not be used in the near future when  * we develop `neater' mechanism to process extension headers.  */
end_comment

begin_function
name|char
modifier|*
name|ip6_get_prevhdr
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|off
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
return|return
operator|(
operator|&
name|ip6
operator|->
name|ip6_nxt
operator|)
return|;
else|else
block|{
name|int
name|len
decl_stmt|,
name|nxt
decl_stmt|;
name|struct
name|ip6_ext
modifier|*
name|ip6e
init|=
name|NULL
decl_stmt|;
name|nxt
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|off
condition|)
block|{
name|ip6e
operator|=
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|len
operator|)
expr_stmt|;
switch|switch
condition|(
name|nxt
condition|)
block|{
case|case
name|IPPROTO_FRAGMENT
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_AH
case|:
name|len
operator|+=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
break|break;
default|default:
name|len
operator|+=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
break|break;
block|}
name|nxt
operator|=
name|ip6e
operator|->
name|ip6e_nxt
expr_stmt|;
block|}
if|if
condition|(
name|ip6e
condition|)
return|return
operator|(
operator|&
name|ip6e
operator|->
name|ip6e_nxt
operator|)
return|;
else|else
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * get next header offset.  m will be retained.  */
end_comment

begin_function
name|int
name|ip6_nexthdr
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|,
name|proto
parameter_list|,
name|nxtp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|proto
decl_stmt|;
name|int
modifier|*
name|nxtp
decl_stmt|;
block|{
name|struct
name|ip6_hdr
name|ip6
decl_stmt|;
name|struct
name|ip6_ext
name|ip6e
decl_stmt|;
name|struct
name|ip6_frag
name|fh
decl_stmt|;
comment|/* just in case */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ip6_nexthdr: m == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
operator|||
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_IPV6
case|:
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
operator|+
sizeof|sizeof
argument_list|(
name|ip6
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxtp
condition|)
operator|*
name|nxtp
operator|=
name|ip6
operator|.
name|ip6_nxt
expr_stmt|;
name|off
operator|+=
sizeof|sizeof
argument_list|(
name|ip6
argument_list|)
expr_stmt|;
return|return
name|off
return|;
case|case
name|IPPROTO_FRAGMENT
case|:
comment|/* 		 * terminate parsing if it is not the first fragment, 		 * it does not make sense to parse through it. 		 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
operator|+
sizeof|sizeof
argument_list|(
name|fh
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|fh
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|fh
argument_list|)
expr_stmt|;
comment|/* IP6F_OFF_MASK = 0xfff8(BigEndian), 0xf8ff(LittleEndian) */
if|if
condition|(
name|fh
operator|.
name|ip6f_offlg
operator|&
name|IP6F_OFF_MASK
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|nxtp
condition|)
operator|*
name|nxtp
operator|=
name|fh
operator|.
name|ip6f_nxt
expr_stmt|;
name|off
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
return|return
name|off
return|;
case|case
name|IPPROTO_AH
case|:
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
operator|+
sizeof|sizeof
argument_list|(
name|ip6e
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6e
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6e
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxtp
condition|)
operator|*
name|nxtp
operator|=
name|ip6e
operator|.
name|ip6e_nxt
expr_stmt|;
name|off
operator|+=
operator|(
name|ip6e
operator|.
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
return|return
name|off
return|;
case|case
name|IPPROTO_HOPOPTS
case|:
case|case
name|IPPROTO_ROUTING
case|:
case|case
name|IPPROTO_DSTOPTS
case|:
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
operator|+
sizeof|sizeof
argument_list|(
name|ip6e
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6e
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6e
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxtp
condition|)
operator|*
name|nxtp
operator|=
name|ip6e
operator|.
name|ip6e_nxt
expr_stmt|;
name|off
operator|+=
operator|(
name|ip6e
operator|.
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
return|return
name|off
return|;
case|case
name|IPPROTO_NONE
case|:
case|case
name|IPPROTO_ESP
case|:
case|case
name|IPPROTO_IPCOMP
case|:
comment|/* give up */
return|return
operator|-
literal|1
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * get offset for the last header in the chain.  m will be kept untainted.  */
end_comment

begin_function
name|int
name|ip6_lasthdr
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|,
name|proto
parameter_list|,
name|nxtp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|proto
decl_stmt|;
name|int
modifier|*
name|nxtp
decl_stmt|;
block|{
name|int
name|newoff
decl_stmt|;
name|int
name|nxt
decl_stmt|;
if|if
condition|(
operator|!
name|nxtp
condition|)
block|{
name|nxt
operator|=
operator|-
literal|1
expr_stmt|;
name|nxtp
operator|=
operator|&
name|nxt
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|newoff
operator|=
name|ip6_nexthdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|proto
argument_list|,
name|nxtp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newoff
operator|<
literal|0
condition|)
return|return
name|off
return|;
elseif|else
if|if
condition|(
name|newoff
operator|<
name|off
condition|)
return|return
operator|-
literal|1
return|;
comment|/* invalid */
elseif|else
if|if
condition|(
name|newoff
operator|==
name|off
condition|)
return|return
name|newoff
return|;
name|off
operator|=
name|newoff
expr_stmt|;
name|proto
operator|=
operator|*
name|nxtp
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|ip6aux
modifier|*
name|ip6_addaux
parameter_list|(
name|m
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|mtag
operator|=
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_IPV6_INPUT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtag
condition|)
block|{
name|mtag
operator|=
name|m_tag_get
argument_list|(
name|PACKET_TAG_IPV6_INPUT
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6aux
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
condition|)
block|{
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mtag
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6aux
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|mtag
condition|?
operator|(
expr|struct
name|ip6aux
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|ip6aux
modifier|*
name|ip6_findaux
parameter_list|(
name|m
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|mtag
operator|=
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_IPV6_INPUT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|mtag
condition|?
operator|(
expr|struct
name|ip6aux
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|ip6_delaux
parameter_list|(
name|m
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|mtag
operator|=
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_IPV6_INPUT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
condition|)
name|m_tag_delete
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * System control for IP6  */
end_comment

begin_decl_stmt
name|u_char
name|inet6ctlerrmap
index|[
name|PRC_NCMDS
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|EMSGSIZE
block|,
name|EHOSTDOWN
block|,
name|EHOSTUNREACH
block|,
name|EHOSTUNREACH
block|,
name|EHOSTUNREACH
block|,
name|ECONNREFUSED
block|,
name|ECONNREFUSED
block|,
name|EMSGSIZE
block|,
name|EHOSTUNREACH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|ENOPROTOOPT
block|}
decl_stmt|;
end_decl_stmt

end_unit

