begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$KAME: ip6_input.c,v 1.194 2001/05/27 13:28:35 itojun Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)ip_input.c	8.2 (Berkeley) 1/4/94  */
end_comment

begin_include
include|#
directive|include
file|"opt_ip6fw.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/intrq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*INET*/
end_comment

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_ifattach.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_prefix.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet6/ip6_fw.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6protosw.h>
end_include

begin_comment
comment|/* we need it for NLOOP. */
end_comment

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_include
include|#
directive|include
file|"faith.h"
end_include

begin_include
include|#
directive|include
file|<net/net_osdep.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|inet6domain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ip6protosw
name|inet6sw
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|ip6_protox
index|[
name|IPPROTO_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip6qmaxlen
init|=
name|IFQ_MAXLEN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in6_ifaddr
modifier|*
name|in6_ifaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|callout
name|in6_tmpaddrtimer_ch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ip6_forward_srcrt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|int
name|ip6_sourcecheck
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|int
name|ip6_sourcecheck_interval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
specifier|const
name|int
name|int6intrq_present
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ip6_ours_check_algorithm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* firewall hooks */
end_comment

begin_decl_stmt
name|ip6_fw_chk_t
modifier|*
name|ip6_fw_chk_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ip6_fw_ctl_t
modifier|*
name|ip6_fw_ctl_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ip6_fw_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ip6stat
name|ip6stat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ip6_init2
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|ip6_setdstifaddr
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|in6_ifaddr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip6_hopopts_input
name|__P
argument_list|(
operator|(
name|u_int32_t
operator|*
operator|,
name|u_int32_t
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PULLDOWN_TEST
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|ip6_pullexthdr
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
name|size_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * IP6 initialization: fill in IP6 protocol switch table.  * All protocols not implemented in kernel go to raw IP6 protocol handler.  */
end_comment

begin_function
name|void
name|ip6_init
parameter_list|()
block|{
name|struct
name|ip6protosw
modifier|*
name|pr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|protosw
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6protosw
argument_list|)
condition|)
name|panic
argument_list|(
literal|"sizeof(protosw) != sizeof(ip6protosw)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pr
operator|=
operator|(
expr|struct
name|ip6protosw
operator|*
operator|)
name|pffindproto
argument_list|(
name|PF_INET6
argument_list|,
name|IPPROTO_RAW
argument_list|,
name|SOCK_RAW
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ip6_init"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPPROTO_MAX
condition|;
name|i
operator|++
control|)
name|ip6_protox
index|[
name|i
index|]
operator|=
name|pr
operator|-
name|inet6sw
expr_stmt|;
for|for
control|(
name|pr
operator|=
operator|(
expr|struct
name|ip6protosw
operator|*
operator|)
name|inet6domain
operator|.
name|dom_protosw
init|;
name|pr
operator|<
operator|(
expr|struct
name|ip6protosw
operator|*
operator|)
name|inet6domain
operator|.
name|dom_protoswNPROTOSW
condition|;
name|pr
operator|++
control|)
if|if
condition|(
name|pr
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|PF_INET6
operator|&&
name|pr
operator|->
name|pr_protocol
operator|&&
name|pr
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_RAW
condition|)
name|ip6_protox
index|[
name|pr
operator|->
name|pr_protocol
index|]
operator|=
name|pr
operator|-
name|inet6sw
expr_stmt|;
name|ip6intrq
operator|.
name|ifq_maxlen
operator|=
name|ip6qmaxlen
expr_stmt|;
name|register_netisr
argument_list|(
name|NETISR_IPV6
argument_list|,
name|ip6intr
argument_list|)
expr_stmt|;
name|nd6_init
argument_list|()
expr_stmt|;
name|frag6_init
argument_list|()
expr_stmt|;
comment|/* 	 * in many cases, random() here does NOT return random number 	 * as initialization during bootstrap time occur in fixed order. 	 */
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|ip6_flow_seq
operator|=
name|random
argument_list|()
operator|^
name|tv
operator|.
name|tv_usec
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|ip6_desync_factor
operator|=
operator|(
name|random
argument_list|()
operator|^
name|tv
operator|.
name|tv_usec
operator|)
operator|%
name|MAX_TEMP_DESYNC_FACTOR
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ip6_init2
parameter_list|(
name|dummy
parameter_list|)
name|void
modifier|*
name|dummy
decl_stmt|;
block|{
comment|/* 	 * to route local address of p2p link to loopback, 	 * assign loopback address first. 	 */
name|in6_ifattach
argument_list|(
operator|&
name|loif
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* nd6_timer_init */
name|callout_init
argument_list|(
operator|&
name|nd6_timer_ch
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nd6_timer_ch
argument_list|,
name|hz
argument_list|,
name|nd6_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* router renumbering prefix list maintenance */
name|callout_init
argument_list|(
operator|&
name|in6_rr_timer_ch
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|in6_rr_timer_ch
argument_list|,
name|hz
argument_list|,
name|in6_rr_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* timer for regeneranation of temporary addresses randomize ID */
name|callout_reset
argument_list|(
operator|&
name|in6_tmpaddrtimer_ch
argument_list|,
operator|(
name|ip6_temp_preferred_lifetime
operator|-
name|ip6_desync_factor
operator|-
name|ip6_temp_regen_advance
operator|)
operator|*
name|hz
argument_list|,
name|in6_tmpaddrtimer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cheat */
end_comment

begin_comment
comment|/* This must be after route_init(), which is now SI_ORDER_THIRD */
end_comment

begin_expr_stmt
name|SYSINIT
argument_list|(
name|netinet6init2
argument_list|,
name|SI_SUB_PROTO_DOMAIN
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|ip6_init2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * IP6 input interrupt handling. Just pass the packet to ip6_input.  */
end_comment

begin_function
name|void
name|ip6intr
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|ip6intrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|ip6_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|extern
name|struct
name|route_in6
name|ip6_forward_rt
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ip6_input
parameter_list|(
name|m
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|int
name|off
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
decl_stmt|,
name|nest
decl_stmt|;
name|u_int32_t
name|plen
decl_stmt|;
name|u_int32_t
name|rtalert
init|=
operator|~
literal|0
decl_stmt|;
name|int
name|nxt
decl_stmt|,
name|ours
init|=
literal|0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|deliverifp
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|IPSEC
comment|/* 	 * should the inner packet be considered authentic? 	 * see comment in ah4_input(). 	 */
if|if
condition|(
name|m
condition|)
block|{
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_AUTHIPHDR
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_AUTHIPDGM
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * make sure we don't have onion peering information into m_aux. 	 */
name|ip6_delaux
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * mbuf statistics by kazu 	 */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
name|ip6stat
operator|.
name|ip6s_mext2m
operator|++
expr_stmt|;
else|else
name|ip6stat
operator|.
name|ip6s_mext1
operator|++
expr_stmt|;
block|}
else|else
block|{
define|#
directive|define
name|M2MMAX
value|(sizeof(ip6stat.ip6s_m2m)/sizeof(ip6stat.ip6s_m2m[0]))
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_LOOP
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_m2m
index|[
name|loif
index|[
literal|0
index|]
operator|.
name|if_index
index|]
operator|++
expr_stmt|;
comment|/*XXX*/
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_index
operator|<
name|M2MMAX
condition|)
name|ip6stat
operator|.
name|ip6s_m2m
index|[
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_index
index|]
operator|++
expr_stmt|;
else|else
name|ip6stat
operator|.
name|ip6s_m2m
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
else|else
name|ip6stat
operator|.
name|ip6s_m1
operator|++
expr_stmt|;
undef|#
directive|undef
name|M2MMAX
block|}
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_receive
argument_list|)
expr_stmt|;
name|ip6stat
operator|.
name|ip6s_total
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|PULLDOWN_TEST
comment|/* 	 * L2 bridge code and some other code can return mbuf chain 	 * that does not conform to KAME requirement.  too bad. 	 * XXX: fails to join if interface MTU> MCLBYTES.  jumbogram? 	 */
if|if
condition|(
name|m
operator|&&
name|m
operator|->
name|m_next
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|MCLBYTES
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|M_COPY_PKTHDR
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
comment|/*ENOBUFS*/
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
name|IP6_EXTHDR_CHECK
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
comment|/*nothing*/
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|inifp
decl_stmt|;
name|inifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|inifp
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ip6
operator|->
name|ip6_vfc
operator|&
name|IPV6_VERSION_MASK
operator|)
operator|!=
name|IPV6_VERSION
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badvers
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip6stat
operator|.
name|ip6s_nxthist
index|[
name|ip6
operator|->
name|ip6_nxt
index|]
operator|++
expr_stmt|;
comment|/* 	 * Check with the firewall... 	 */
if|if
condition|(
name|ip6_fw_enable
operator|&&
name|ip6_fw_chk_ptr
condition|)
block|{
name|u_short
name|port
init|=
literal|0
decl_stmt|;
comment|/* If ipfw says divert, we have to just drop packet */
comment|/* use port as a dummy argument */
if|if
condition|(
call|(
modifier|*
name|ip6_fw_chk_ptr
call|)
argument_list|(
operator|&
name|ip6
argument_list|,
name|NULL
argument_list|,
operator|&
name|port
argument_list|,
operator|&
name|m
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|m
condition|)
return|return;
block|}
comment|/* 	 * Check against address spoofing/corruption. 	 */
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|||
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
comment|/* 		 * XXX: "badscope" is not very suitable for a multicast source. 		 */
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_addrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|||
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|==
literal|0
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_addrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * The following check is not documented in specs.  A malicious 	 * party may be able to use IPv4 mapped addr to confuse tcp/udp stack 	 * and bypass security checks (act as if it was from 127.0.0.1 by using 	 * IPv6 src ::ffff:127.0.0.1).	Be cautious. 	 * 	 * This check chokes if we are in an SIIT cloud.  As none of BSDs 	 * support IPv4-less kernel compilation, we cannot support SIIT 	 * environment at all.  So, it makes more sense for us to reject any 	 * malicious packets for non-SIIT environment, than try to do a 	 * partical support for SIIT environment. 	 */
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|||
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_addrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|#
directive|if
literal|0
comment|/* 	 * Reject packets with IPv4 compatible addresses (auto tunnel). 	 * 	 * The code forbids auto tunnel relay case in RFC1933 (the check is 	 * stronger than RFC1933).  We may want to re-enable it if mech-xx 	 * is revised to forbid relaying case. 	 */
block|if (IN6_IS_ADDR_V4COMPAT(&ip6->ip6_src) || 	    IN6_IS_ADDR_V4COMPAT(&ip6->ip6_dst)) { 		ip6stat.ip6s_badscope++; 		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_addrerr); 		goto bad; 	}
endif|#
directive|endif
comment|/* drop packets if interface ID portion is already filled */
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|&&
name|ip6
operator|->
name|ip6_src
operator|.
name|s6_addr16
index|[
literal|1
index|]
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|&&
name|ip6
operator|->
name|ip6_dst
operator|.
name|s6_addr16
index|[
literal|1
index|]
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
name|ip6
operator|->
name|ip6_src
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
name|ip6
operator|->
name|ip6_dst
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_index
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* this case seems to be unnecessary. (jinmei, 20010401) */
comment|/* 	 * We use rt->rt_ifp to determine if the address is ours or not. 	 * If rt_ifp is lo0, the address is ours. 	 * The problem here is, rt->rt_ifp for fe80::%lo0/64 is set to lo0, 	 * so any address under fe80::%lo0/64 will be mistakenly considered 	 * local.  The special case is supplied to handle the case properly 	 * by actually looking at interface addresses 	 * (using in6ifa_ifpwithaddr). 	 */
block|if ((m->m_pkthdr.rcvif->if_flags& IFF_LOOPBACK) != 0&& 	    IN6_IS_ADDR_LINKLOCAL(&ip6->ip6_dst)) { 		if (!in6ifa_ifpwithaddr(m->m_pkthdr.rcvif,&ip6->ip6_dst)) { 			icmp6_error(m, ICMP6_DST_UNREACH, 			    ICMP6_DST_UNREACH_ADDR, 0);
comment|/* m is already freed */
block|return; 		}  		ours = 1; 		deliverifp = m->m_pkthdr.rcvif; 		goto hbhcheck; 	}
endif|#
directive|endif
comment|/* 	 * Multicast check 	 */
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|struct
name|in6_multi
modifier|*
name|in6m
init|=
literal|0
decl_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_mcast
argument_list|)
expr_stmt|;
comment|/* 		 * See if we belong to the destination multicast group on the 		 * arrival interface. 		 */
name|IN6_LOOKUP_MULTI
argument_list|(
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|in6m
argument_list|)
expr_stmt|;
if|if
condition|(
name|in6m
condition|)
name|ours
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ip6_mrouter
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_notmember
operator|++
expr_stmt|;
name|ip6stat
operator|.
name|ip6s_cantforward
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_discard
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|deliverifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
goto|goto
name|hbhcheck
goto|;
block|}
comment|/* 	 *  Unicast check 	 */
switch|switch
condition|(
name|ip6_ours_check_algorithm
condition|)
block|{
default|default:
comment|/* 		 * XXX: I intentionally broke our indentation rule here, 		 *      since this switch-case is just for measurement and 		 *      therefore should soon be removed. 		 */
if|if
condition|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|!=
name|NULL
operator|&&
operator|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|!=
literal|0
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
operator|&
name|ip6_forward_rt
operator|.
name|ro_dst
operator|)
operator|)
operator|->
name|sin6_addr
argument_list|)
condition|)
name|ip6stat
operator|.
name|ip6s_forward_cachehit
operator|++
expr_stmt|;
else|else
block|{
name|struct
name|sockaddr_in6
modifier|*
name|dst6
decl_stmt|;
if|if
condition|(
name|ip6_forward_rt
operator|.
name|ro_rt
condition|)
block|{
comment|/* route is down or destination is different */
name|ip6stat
operator|.
name|ip6s_forward_cachemiss
operator|++
expr_stmt|;
name|RTFREE
argument_list|(
name|ip6_forward_rt
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|ip6_forward_rt
operator|.
name|ro_rt
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|ip6_forward_rt
operator|.
name|ro_dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|dst6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ip6_forward_rt
operator|.
name|ro_dst
expr_stmt|;
name|dst6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|dst6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|dst6
operator|->
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
ifdef|#
directive|ifdef
name|SCOPEDROUTING
name|ip6_forward_rt
operator|.
name|ro_dst
operator|.
name|sin6_scope_id
operator|=
name|in6_addr2scopeid
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rtalloc_ign
argument_list|(
operator|(
expr|struct
name|route
operator|*
operator|)
operator|&
name|ip6_forward_rt
argument_list|,
name|RTF_PRCLONING
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|rt6_key
parameter_list|(
name|r
parameter_list|)
value|((struct sockaddr_in6 *)((r)->rt_nodes->rn_key))
comment|/* 	 * Accept the packet if the forwarding interface to the destination 	 * according to the routing table is the loopback interface, 	 * unless the associated route has a gateway. 	 * Note that this approach causes to accept a packet if there is a 	 * route to the loopback interface for the destination of the packet. 	 * But we think it's even useful in some situations, e.g. when using 	 * a special daemon which wants to intercept the packet. 	 * 	 * XXX: some OSes automatically make a cloned route for the destination 	 * of an outgoing packet.  If the outgoing interface of the packet 	 * is a loopback one, the kernel would consider the packet to be 	 * accepted, even if we have no such address assinged on the interface. 	 * We check the cloned flag of the route entry to reject such cases, 	 * assuming that route entries for our own addresses are not made by 	 * cloning (it should be true because in6_addloop explicitly installs 	 * the host route).  However, we might have to do an explicit check 	 * while it would be less efficient.  Or, should we rather install a 	 * reject route for such a case? 	 */
if|if
condition|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|&&
operator|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_HOST
operator||
name|RTF_GATEWAY
operator|)
operator|)
operator|==
name|RTF_HOST
operator|&&
ifdef|#
directive|ifdef
name|RTF_WASCLONED
operator|!
operator|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_WASCLONED
operator|)
operator|&&
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTF_CLONED
operator|!
operator|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_CLONED
operator|)
operator|&&
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* 	     * The check below is redundant since the comparison of 	     * the destination and the key of the rtentry has 	     * already done through looking up the routing table. 	     */
expr|IN6_ARE_ADDR_EQUAL(&ip6->ip6_dst,&rt6_key(ip6_forward_rt.ro_rt)->sin6_addr)
endif|#
directive|endif
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_type
operator|==
name|IFT_LOOP
condition|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ia6
init|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifa
decl_stmt|;
comment|/* 		 * record address information into m_aux. 		 */
operator|(
name|void
operator|)
name|ip6_setdstifaddr
argument_list|(
name|m
argument_list|,
name|ia6
argument_list|)
expr_stmt|;
comment|/* 		 * packets to a tentative, duplicated, or somehow invalid 		 * address must not be accepted. 		 */
if|if
condition|(
operator|!
operator|(
name|ia6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_NOTREADY
operator|)
condition|)
block|{
comment|/* this address is ready */
name|ours
operator|=
literal|1
expr_stmt|;
name|deliverifp
operator|=
name|ia6
operator|->
name|ia_ifp
expr_stmt|;
comment|/* correct? */
comment|/* Count the packet in the ip address stats */
name|ia6
operator|->
name|ia_ifa
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|ia6
operator|->
name|ia_ifa
operator|.
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
goto|goto
name|hbhcheck
goto|;
block|}
else|else
block|{
comment|/* address is not ready, so discard the packet. */
name|nd6log
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ip6_input: packet to an unready address %s->%s\n"
operator|,
name|ip6_sprintf
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|,
name|ip6_sprintf
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
block|}
comment|/* XXX indentation (see above) */
comment|/* 	 * FAITH(Firewall Aided Internet Translator) 	 */
if|#
directive|if
name|defined
argument_list|(
name|NFAITH
argument_list|)
operator|&&
literal|0
operator|<
name|NFAITH
if|if
condition|(
name|ip6_keepfaith
condition|)
block|{
if|if
condition|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|&&
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|&&
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_type
operator|==
name|IFT_FAITH
condition|)
block|{
comment|/* XXX do we need more sanity checks? */
name|ours
operator|=
literal|1
expr_stmt|;
name|deliverifp
operator|=
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
comment|/*faith*/
goto|goto
name|hbhcheck
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Now there is no reason to process the packet if it's not our own 	 * and we're not a router. 	 */
if|if
condition|(
operator|!
name|ip6_forwarding
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_cantforward
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_discard
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|hbhcheck
label|:
comment|/* 	 * record address information into m_aux, if we don't have one yet. 	 * note that we are unable to record it, if the address is not listed 	 * as our interface address (e.g. multicast addresses, addresses 	 * within FAITH prefixes and such). 	 */
if|if
condition|(
name|deliverifp
operator|&&
operator|!
name|ip6_getdstifaddr
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|;
name|ia6
operator|=
name|in6_ifawithifp
argument_list|(
name|deliverifp
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia6
condition|)
block|{
if|if
condition|(
operator|!
name|ip6_setdstifaddr
argument_list|(
name|m
argument_list|,
name|ia6
argument_list|)
condition|)
block|{
comment|/* 				 * XXX maybe we should drop the packet here, 				 * as we could not provide enough information 				 * to the upper layers. 				 */
block|}
block|}
block|}
comment|/* 	 * Process Hop-by-Hop options header if it's contained. 	 * m may be modified in ip6_hopopts_input(). 	 * If a JumboPayload option is included, plen will also be modified. 	 */
name|plen
operator|=
operator|(
name|u_int32_t
operator|)
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6
operator|->
name|ip6_nxt
operator|==
name|IPPROTO_HOPOPTS
condition|)
block|{
name|struct
name|ip6_hbh
modifier|*
name|hbh
decl_stmt|;
if|if
condition|(
name|ip6_hopopts_input
argument_list|(
operator|&
name|plen
argument_list|,
operator|&
name|rtalert
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|off
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/*touches NULL pointer*/
block|in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_discard);
endif|#
directive|endif
return|return;
comment|/* m have already been freed */
block|}
comment|/* adjust pointer */
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
comment|/* 		 * if the payload length field is 0 and the next header field   		 * indicates Hop-by-Hop Options header, then a Jumbo Payload 		 * option MUST be included. 		 */
if|if
condition|(
name|ip6
operator|->
name|ip6_plen
operator|==
literal|0
operator|&&
name|plen
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Note that if a valid jumbo payload option is 			 * contained, ip6_hoptops_input() must set a valid 			 * (non-zero) payload length to the variable plen.  			 */
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_discard
argument_list|)
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_HEADER
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6
operator|->
name|ip6_plen
operator|-
operator|(
name|caddr_t
operator|)
name|ip6
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|PULLDOWN_TEST
comment|/* ip6_hopopts_input() ensures that mbuf is contiguous */
name|hbh
operator|=
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
operator|(
name|ip6
operator|+
literal|1
operator|)
expr_stmt|;
else|#
directive|else
name|IP6_EXTHDR_GET
argument_list|(
name|hbh
argument_list|,
expr|struct
name|ip6_hbh
operator|*
argument_list|,
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hbh
operator|==
name|NULL
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|nxt
operator|=
name|hbh
operator|->
name|ip6h_nxt
expr_stmt|;
comment|/* 		 * accept the packet if a router alert option is included 		 * and we act as an IPv6 router. 		 */
if|if
condition|(
name|rtalert
operator|!=
operator|~
literal|0
operator|&&
name|ip6_forwarding
condition|)
name|ours
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|nxt
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
comment|/* 	 * Check that the amount of data in the buffers 	 * is as at least much as the IPv6 header would have us expect. 	 * Trim mbufs if longer than we expect. 	 * Drop packet if shorter than we expect. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|<
name|plen
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_truncated
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
expr_stmt|;
block|}
else|else
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Forward if desirable. 	 */
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
comment|/* 		 * If we are acting as a multicast router, all 		 * incoming multicast packets are passed to the 		 * kernel-level multicast forwarding function. 		 * The packet is returned (relatively) intact; if 		 * ip6_mforward() returns a non-zero value, the packet 		 * must be discarded, else it may be accepted below. 		 */
if|if
condition|(
name|ip6_mrouter
operator|&&
name|ip6_mforward
argument_list|(
name|ip6
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_cantforward
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ours
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ours
condition|)
block|{
name|ip6_forward
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Malicious party may be able to use IPv4 mapped addr to confuse 	 * tcp/udp stack and bypass security checks (act as if it was from 	 * 127.0.0.1 by using IPv6 src ::ffff:127.0.0.1).  Be cautious. 	 * 	 * For SIIT end node behavior, you may want to disable the check. 	 * However, you will  become vulnerable to attacks using IPv4 mapped 	 * source. 	 */
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|||
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_addrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Tell launch routine the next header 	 */
name|ip6stat
operator|.
name|ip6s_delivered
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|deliverifp
argument_list|,
name|ifs6_in_deliver
argument_list|)
expr_stmt|;
name|nest
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nxt
operator|!=
name|IPPROTO_DONE
condition|)
block|{
if|if
condition|(
name|ip6_hdrnestlimit
operator|&&
operator|(
operator|++
name|nest
operator|>
name|ip6_hdrnestlimit
operator|)
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toomanyhdr
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * protection against faulty packet - there should be 		 * more sanity checks in header chain processing. 		 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_truncated
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|#
directive|if
literal|0
comment|/* 		 * do we need to do it for every header?  yeah, other 		 * functions can play with it (like re-allocate and copy). 		 */
block|mhist = ip6_addaux(m); 		if (mhist&& M_TRAILINGSPACE(mhist)>= sizeof(nxt)) { 			hist = mtod(mhist, caddr_t) + mhist->m_len; 			bcopy(&nxt, hist, sizeof(nxt)); 			mhist->m_len += sizeof(nxt); 		} else { 			ip6stat.ip6s_toomanyhdr++; 			goto bad; 		}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPSEC
comment|/* 		 * enforce IPsec policy checking if we are seeing last header. 		 * note that we do not visit this with protocols with pcb layer 		 * code - like udp/tcp/raw ip. 		 */
if|if
condition|(
operator|(
name|inet6sw
index|[
name|ip6_protox
index|[
name|nxt
index|]
index|]
operator|.
name|pr_flags
operator|&
name|PR_LASTHDR
operator|)
operator|!=
literal|0
operator|&&
name|ipsec6_in_reject
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ipsec6stat
operator|.
name|in_polvio
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
name|nxt
operator|=
operator|(
operator|*
name|inet6sw
index|[
name|ip6_protox
index|[
name|nxt
index|]
index|]
operator|.
name|pr_input
operator|)
operator|(
operator|&
name|m
operator|,
operator|&
name|off
operator|,
name|nxt
operator|)
expr_stmt|;
block|}
return|return;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set/grab in6_ifaddr correspond to IPv6 destination address.  * XXX backward compatibility wrapper  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ip6_setdstifaddr
parameter_list|(
name|m
parameter_list|,
name|ia6
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|ip6_addaux
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|ip6aux
operator|*
argument_list|)
operator|->
name|ip6a_dstia6
operator|=
name|ia6
expr_stmt|;
return|return
name|n
return|;
comment|/* NULL if failed to set */
block|}
end_function

begin_function
name|struct
name|in6_ifaddr
modifier|*
name|ip6_getdstifaddr
parameter_list|(
name|m
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|ip6_findaux
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|ip6aux
operator|*
argument_list|)
operator|->
name|ip6a_dstia6
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Hop-by-Hop options header processing. If a valid jumbo payload option is  * included, the real payload length will be stored in plenp.  */
end_comment

begin_function
specifier|static
name|int
name|ip6_hopopts_input
parameter_list|(
name|plenp
parameter_list|,
name|rtalertp
parameter_list|,
name|mp
parameter_list|,
name|offp
parameter_list|)
name|u_int32_t
modifier|*
name|plenp
decl_stmt|;
name|u_int32_t
modifier|*
name|rtalertp
decl_stmt|;
comment|/* XXX: should be stored more smart way */
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
modifier|*
name|offp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|int
name|off
init|=
operator|*
name|offp
decl_stmt|,
name|hbhlen
decl_stmt|;
name|struct
name|ip6_hbh
modifier|*
name|hbh
decl_stmt|;
name|u_int8_t
modifier|*
name|opt
decl_stmt|;
comment|/* validation of the length of the header */
ifndef|#
directive|ifndef
name|PULLDOWN_TEST
name|IP6_EXTHDR_CHECK
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hbh
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hbh
operator|=
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|hbhlen
operator|=
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|IP6_EXTHDR_CHECK
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|hbhlen
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hbh
operator|=
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
else|#
directive|else
name|IP6_EXTHDR_GET
argument_list|(
name|hbh
argument_list|,
expr|struct
name|ip6_hbh
operator|*
argument_list|,
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hbh
operator|==
name|NULL
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|hbhlen
operator|=
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|IP6_EXTHDR_GET
argument_list|(
name|hbh
argument_list|,
expr|struct
name|ip6_hbh
operator|*
argument_list|,
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|hbhlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|hbh
operator|==
name|NULL
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
name|off
operator|+=
name|hbhlen
expr_stmt|;
name|hbhlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
expr_stmt|;
name|opt
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|hbh
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6_process_hopopts
argument_list|(
name|m
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|hbh
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
argument_list|,
name|hbhlen
argument_list|,
name|rtalertp
argument_list|,
name|plenp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|offp
operator|=
name|off
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search header for all Hop-by-hop options and process each option.  * This function is separate from ip6_hopopts_input() in order to  * handle a case where the sending node itself process its hop-by-hop  * options header. In such a case, the function is called from ip6_output().  *  * The function assumes that hbh header is located right after the IPv6 header  * (RFC2460 p7), opthead is pointer into data content in m, and opthead to  * opthead + hbhlen is located in continuous memory region.  */
end_comment

begin_function
name|int
name|ip6_process_hopopts
parameter_list|(
name|m
parameter_list|,
name|opthead
parameter_list|,
name|hbhlen
parameter_list|,
name|rtalertp
parameter_list|,
name|plenp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int8_t
modifier|*
name|opthead
decl_stmt|;
name|int
name|hbhlen
decl_stmt|;
name|u_int32_t
modifier|*
name|rtalertp
decl_stmt|;
name|u_int32_t
modifier|*
name|plenp
decl_stmt|;
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|int
name|optlen
init|=
literal|0
decl_stmt|;
name|u_int8_t
modifier|*
name|opt
init|=
name|opthead
decl_stmt|;
name|u_int16_t
name|rtalert_val
decl_stmt|;
name|u_int32_t
name|jumboplen
decl_stmt|;
specifier|const
name|int
name|erroff
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|hbhlen
operator|>
literal|0
condition|;
name|hbhlen
operator|-=
name|optlen
operator|,
name|opt
operator|+=
name|optlen
control|)
block|{
switch|switch
condition|(
operator|*
name|opt
condition|)
block|{
case|case
name|IP6OPT_PAD1
case|:
name|optlen
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IP6OPT_PADN
case|:
if|if
condition|(
name|hbhlen
operator|<
name|IP6OPT_MINLEN
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|optlen
operator|=
operator|*
operator|(
name|opt
operator|+
literal|1
operator|)
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|IP6OPT_RTALERT
case|:
comment|/* XXX may need check for alignment */
if|if
condition|(
name|hbhlen
operator|<
name|IP6OPT_RTALERT_LEN
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|*
operator|(
name|opt
operator|+
literal|1
operator|)
operator|!=
name|IP6OPT_RTALERT_LEN
operator|-
literal|2
condition|)
block|{
comment|/* XXX stat */
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_HEADER
argument_list|,
name|erroff
operator|+
name|opt
operator|+
literal|1
operator|-
name|opthead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|optlen
operator|=
name|IP6OPT_RTALERT_LEN
expr_stmt|;
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|opt
operator|+
literal|2
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rtalert_val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|*
name|rtalertp
operator|=
name|ntohs
argument_list|(
name|rtalert_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP6OPT_JUMBO
case|:
comment|/* XXX may need check for alignment */
if|if
condition|(
name|hbhlen
operator|<
name|IP6OPT_JUMBO_LEN
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|*
operator|(
name|opt
operator|+
literal|1
operator|)
operator|!=
name|IP6OPT_JUMBO_LEN
operator|-
literal|2
condition|)
block|{
comment|/* XXX stat */
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_HEADER
argument_list|,
name|erroff
operator|+
name|opt
operator|+
literal|1
operator|-
name|opthead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|optlen
operator|=
name|IP6OPT_JUMBO_LEN
expr_stmt|;
comment|/* 			 * IPv6 packets that have non 0 payload length 			 * must not contain a jumbo payload option. 			 */
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6
operator|->
name|ip6_plen
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_HEADER
argument_list|,
name|erroff
operator|+
name|opt
operator|-
name|opthead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 			 * We may see jumbolen in unaligned location, so 			 * we'd need to perform bcopy(). 			 */
name|bcopy
argument_list|(
name|opt
operator|+
literal|2
argument_list|,
operator|&
name|jumboplen
argument_list|,
sizeof|sizeof
argument_list|(
name|jumboplen
argument_list|)
argument_list|)
expr_stmt|;
name|jumboplen
operator|=
operator|(
name|u_int32_t
operator|)
name|htonl
argument_list|(
name|jumboplen
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* 			 * if there are multiple jumbo payload options, 			 * *plenp will be non-zero and the packet will be 			 * rejected. 			 * the behavior may need some debate in ipngwg - 			 * multiple options does not make sense, however, 			 * there's no explicit mention in specification. 			 */
if|if
condition|(
operator|*
name|plenp
operator|!=
literal|0
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_HEADER
argument_list|,
name|erroff
operator|+
name|opt
operator|+
literal|2
operator|-
name|opthead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 			 * jumbo payload length must be larger than 65535. 			 */
if|if
condition|(
name|jumboplen
operator|<=
name|IPV6_MAXPACKET
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_HEADER
argument_list|,
name|erroff
operator|+
name|opt
operator|+
literal|2
operator|-
name|opthead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|plenp
operator|=
name|jumboplen
expr_stmt|;
break|break;
default|default:
comment|/* unknown option */
if|if
condition|(
name|hbhlen
operator|<
name|IP6OPT_MINLEN
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|optlen
operator|=
name|ip6_unknown_opt
argument_list|(
name|opt
argument_list|,
name|m
argument_list|,
name|erroff
operator|+
name|opt
operator|-
name|opthead
argument_list|)
expr_stmt|;
if|if
condition|(
name|optlen
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|optlen
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unknown option processing.  * The third argument `off' is the offset from the IPv6 header to the option,  * which is necessary if the IPv6 header the and option header and IPv6 header  * is not continuous in order to return an ICMPv6 error.  */
end_comment

begin_function
name|int
name|ip6_unknown_opt
parameter_list|(
name|optp
parameter_list|,
name|m
parameter_list|,
name|off
parameter_list|)
name|u_int8_t
modifier|*
name|optp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
switch|switch
condition|(
name|IP6OPT_TYPE
argument_list|(
operator|*
name|optp
argument_list|)
condition|)
block|{
case|case
name|IP6OPT_TYPE_SKIP
case|:
comment|/* ignore the option */
return|return
operator|(
operator|(
name|int
operator|)
operator|*
operator|(
name|optp
operator|+
literal|1
operator|)
operator|)
return|;
case|case
name|IP6OPT_TYPE_DISCARD
case|:
comment|/* silently discard */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|IP6OPT_TYPE_FORCEICMP
case|:
comment|/* send ICMP even if multicasted */
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_OPTION
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|IP6OPT_TYPE_ICMP
case|:
comment|/* send ICMP if not multicasted */
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|||
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_OPTION
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* XXX: NOTREACHED */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the "control" list for this pcb.  * The function will not modify mbuf chain at all.  *  * with KAME mbuf chain restriction:  * The routine will be called from upper layer handlers like tcp6_input().  * Thus the routine assumes that the caller (tcp6_input) have already  * called IP6_EXTHDR_CHECK() and all the extension headers are located in the  * very first mbuf on the mbuf chain.  */
end_comment

begin_function
name|void
name|ip6_savecontrol
parameter_list|(
name|in6p
parameter_list|,
name|mp
parameter_list|,
name|ip6
parameter_list|,
name|m
parameter_list|)
name|struct
name|inpcb
modifier|*
name|in6p
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
name|int
name|privileged
init|=
literal|0
decl_stmt|;
name|int
name|rthdr_exist
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|&&
operator|!
name|suser
argument_list|(
name|p
argument_list|)
condition|)
name|privileged
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SO_TIMESTAMP
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_socket
operator|->
name|so_options
operator|&
name|SO_TIMESTAMP
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|,
name|SCM_TIMESTAMP
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
block|{
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* RFC 2292 sec. 5 */
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_PKTINFO
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|in6_pktinfo
name|pi6
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
operator|&
name|pi6
operator|.
name|ipi6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|pi6
operator|.
name|ipi6_addr
argument_list|)
condition|)
name|pi6
operator|.
name|ipi6_addr
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pi6
operator|.
name|ipi6_ifindex
operator|=
operator|(
name|m
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|)
condition|?
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_index
else|:
literal|0
expr_stmt|;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|pi6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|,
name|IPV6_PKTINFO
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_HOPLIMIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|hlim
init|=
name|ip6
operator|->
name|ip6_hlim
operator|&
literal|0xff
decl_stmt|;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|hlim
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|IPV6_HOPLIMIT
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* 	 * IPV6_HOPOPTS socket option. We require super-user privilege 	 * for the option, but it might be too strict, since there might 	 * be some hop-by-hop options which can be returned to normal user. 	 * See RFC 2292 section 6. 	 */
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_HOPOPTS
operator|)
operator|!=
literal|0
operator|&&
name|privileged
condition|)
block|{
comment|/* 		 * Check if a hop-by-hop options header is contatined in the 		 * received packet, and if so, store the options as ancillary 		 * data. Note that a hop-by-hop options header must be 		 * just after the IPv6 header, which fact is assured through 		 * the IPv6 input processing. 		 */
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip6
operator|->
name|ip6_nxt
operator|==
name|IPPROTO_HOPOPTS
condition|)
block|{
name|struct
name|ip6_hbh
modifier|*
name|hbh
decl_stmt|;
name|int
name|hbhlen
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PULLDOWN_TEST
name|struct
name|mbuf
modifier|*
name|ext
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PULLDOWN_TEST
name|hbh
operator|=
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
operator|(
name|ip6
operator|+
literal|1
operator|)
expr_stmt|;
name|hbhlen
operator|=
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
else|#
directive|else
name|ext
operator|=
name|ip6_pullexthdr
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|ip6
operator|->
name|ip6_nxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|==
name|NULL
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
return|return;
block|}
name|hbh
operator|=
name|mtod
argument_list|(
name|ext
argument_list|,
expr|struct
name|ip6_hbh
operator|*
argument_list|)
expr_stmt|;
name|hbhlen
operator|=
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|hbhlen
operator|!=
name|ext
operator|->
name|m_len
condition|)
block|{
name|m_freem
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 			 * XXX: We copy whole the header even if a jumbo 			 * payload option is included, which option is to 			 * be removed before returning in the RFC 2292. 			 * Note: this constraint is removed in 2292bis. 			 */
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
name|hbh
argument_list|,
name|hbhlen
argument_list|,
name|IPV6_HOPOPTS
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
ifdef|#
directive|ifdef
name|PULLDOWN_TEST
name|m_freem
argument_list|(
name|ext
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* IPV6_DSTOPTS and IPV6_RTHDR socket options */
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_flags
operator|&
operator|(
name|IN6P_DSTOPTS
operator||
name|IN6P_RTHDRDSTOPTS
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|proto
decl_stmt|,
name|off
decl_stmt|,
name|nxt
decl_stmt|;
comment|/* 		 * go through the header chain to see if a routing header is 		 * contained in the packet. We need this information to store 		 * destination options headers (if any) properly. 		 * XXX: performance issue. We should record this info when 		 * processing extension headers in incoming routine. 		 * (todo) use m_aux?  		 */
name|proto
operator|=
name|IPPROTO_IPV6
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|nxt
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|newoff
decl_stmt|;
name|newoff
operator|=
name|ip6_nexthdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|proto
argument_list|,
operator|&
name|nxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|newoff
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|newoff
operator|<
name|off
condition|)
comment|/* invalid, check for safety */
break|break;
if|if
condition|(
operator|(
name|proto
operator|=
name|nxt
operator|)
operator|==
name|IPPROTO_ROUTING
condition|)
block|{
name|rthdr_exist
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|off
operator|=
name|newoff
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_flags
operator|&
operator|(
name|IN6P_RTHDR
operator||
name|IN6P_DSTOPTS
operator||
name|IN6P_RTHDRDSTOPTS
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
name|int
name|nxt
init|=
name|ip6
operator|->
name|ip6_nxt
decl_stmt|,
name|off
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
decl_stmt|;
comment|/* 		 * Search for destination options headers or routing 		 * header(s) through the header chain, and stores each 		 * header as ancillary data. 		 * Note that the order of the headers remains in 		 * the chain of ancillary data. 		 */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* is explicit loop prevention necessary? */
name|struct
name|ip6_ext
modifier|*
name|ip6e
init|=
name|NULL
decl_stmt|;
name|int
name|elen
decl_stmt|;
ifdef|#
directive|ifdef
name|PULLDOWN_TEST
name|struct
name|mbuf
modifier|*
name|ext
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* 			 * if it is not an extension header, don't try to 			 * pull it from the chain. 			 */
switch|switch
condition|(
name|nxt
condition|)
block|{
case|case
name|IPPROTO_DSTOPTS
case|:
case|case
name|IPPROTO_ROUTING
case|:
case|case
name|IPPROTO_HOPOPTS
case|:
case|case
name|IPPROTO_AH
case|:
comment|/* is it possible? */
break|break;
default|default:
goto|goto
name|loopend
goto|;
block|}
ifndef|#
directive|ifndef
name|PULLDOWN_TEST
if|if
condition|(
name|off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6e
argument_list|)
operator|>
name|m
operator|->
name|m_len
condition|)
goto|goto
name|loopend
goto|;
name|ip6e
operator|=
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
if|if
condition|(
name|nxt
operator|==
name|IPPROTO_AH
condition|)
name|elen
operator|=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
else|else
name|elen
operator|=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|elen
operator|>
name|m
operator|->
name|m_len
condition|)
goto|goto
name|loopend
goto|;
else|#
directive|else
name|ext
operator|=
name|ip6_pullexthdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|==
name|NULL
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
return|return;
block|}
name|ip6e
operator|=
name|mtod
argument_list|(
name|ext
argument_list|,
expr|struct
name|ip6_ext
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxt
operator|==
name|IPPROTO_AH
condition|)
name|elen
operator|=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
else|else
name|elen
operator|=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|elen
operator|!=
name|ext
operator|->
name|m_len
condition|)
block|{
name|m_freem
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|nxt
condition|)
block|{
case|case
name|IPPROTO_DSTOPTS
case|:
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_DSTOPTS
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 				 * We also require super-user privilege for 				 * the option. 				 * See the comments on IN6_HOPOPTS. 				 */
if|if
condition|(
operator|!
name|privileged
condition|)
break|break;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip6e
argument_list|,
name|elen
argument_list|,
name|IPV6_DSTOPTS
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
break|break;
case|case
name|IPPROTO_ROUTING
case|:
if|if
condition|(
operator|!
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_RTHDR
condition|)
break|break;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip6e
argument_list|,
name|elen
argument_list|,
name|IPV6_RTHDR
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
break|break;
case|case
name|IPPROTO_HOPOPTS
case|:
case|case
name|IPPROTO_AH
case|:
comment|/* is it possible? */
break|break;
default|default:
comment|/* 			 	 * other cases have been filtered in the above. 				 * none will visit this case.  here we supply 				 * the code just in case (nxt overwritten or 				 * other cases). 				 */
ifdef|#
directive|ifdef
name|PULLDOWN_TEST
name|m_freem
argument_list|(
name|ext
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|loopend
goto|;
block|}
comment|/* proceed with the next header. */
name|off
operator|+=
name|elen
expr_stmt|;
name|nxt
operator|=
name|ip6e
operator|->
name|ip6e_nxt
expr_stmt|;
name|ip6e
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|PULLDOWN_TEST
name|m_freem
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|ext
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
name|loopend
label|:
empty_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PULLDOWN_TEST
end_ifdef

begin_comment
comment|/*  * pull single extension header from mbuf chain.  returns single mbuf that  * contains the result, or NULL on error.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ip6_pullexthdr
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|,
name|nxt
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|size_t
name|off
decl_stmt|;
name|int
name|nxt
decl_stmt|;
block|{
name|struct
name|ip6_ext
name|ip6e
decl_stmt|;
name|size_t
name|elen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
switch|switch
condition|(
name|nxt
condition|)
block|{
case|case
name|IPPROTO_DSTOPTS
case|:
case|case
name|IPPROTO_ROUTING
case|:
case|case
name|IPPROTO_HOPOPTS
case|:
case|case
name|IPPROTO_AH
case|:
comment|/* is it possible? */
break|break;
default|default:
name|printf
argument_list|(
literal|"ip6_pullexthdr: invalid nxt=%d\n"
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6e
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6e
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxt
operator|==
name|IPPROTO_AH
condition|)
name|elen
operator|=
operator|(
name|ip6e
operator|.
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
else|else
name|elen
operator|=
operator|(
name|ip6e
operator|.
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|MGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|elen
operator|>=
name|MLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|NULL
return|;
name|n
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|elen
operator|>=
name|M_TRAILINGSPACE
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|m_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|elen
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|elen
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get pointer to the previous header followed by the header  * currently processed.  * XXX: This function supposes that  *	M includes all headers,  *	the next header field and the header length field of each header  *	are valid, and  *	the sum of each header length equals to OFF.  * Because of these assumptions, this function must be called very  * carefully. Moreover, it will not be used in the near future when  * we develop `neater' mechanism to process extension headers.  */
end_comment

begin_function
name|char
modifier|*
name|ip6_get_prevhdr
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|off
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
return|return
operator|(
operator|&
name|ip6
operator|->
name|ip6_nxt
operator|)
return|;
else|else
block|{
name|int
name|len
decl_stmt|,
name|nxt
decl_stmt|;
name|struct
name|ip6_ext
modifier|*
name|ip6e
init|=
name|NULL
decl_stmt|;
name|nxt
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|off
condition|)
block|{
name|ip6e
operator|=
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|len
operator|)
expr_stmt|;
switch|switch
condition|(
name|nxt
condition|)
block|{
case|case
name|IPPROTO_FRAGMENT
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_AH
case|:
name|len
operator|+=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
break|break;
default|default:
name|len
operator|+=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
break|break;
block|}
name|nxt
operator|=
name|ip6e
operator|->
name|ip6e_nxt
expr_stmt|;
block|}
if|if
condition|(
name|ip6e
condition|)
return|return
operator|(
operator|&
name|ip6e
operator|->
name|ip6e_nxt
operator|)
return|;
else|else
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * get next header offset.  m will be retained.  */
end_comment

begin_function
name|int
name|ip6_nexthdr
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|,
name|proto
parameter_list|,
name|nxtp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|proto
decl_stmt|;
name|int
modifier|*
name|nxtp
decl_stmt|;
block|{
name|struct
name|ip6_hdr
name|ip6
decl_stmt|;
name|struct
name|ip6_ext
name|ip6e
decl_stmt|;
name|struct
name|ip6_frag
name|fh
decl_stmt|;
comment|/* just in case */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ip6_nexthdr: m == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
operator|||
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_IPV6
case|:
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
operator|+
sizeof|sizeof
argument_list|(
name|ip6
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxtp
condition|)
operator|*
name|nxtp
operator|=
name|ip6
operator|.
name|ip6_nxt
expr_stmt|;
name|off
operator|+=
sizeof|sizeof
argument_list|(
name|ip6
argument_list|)
expr_stmt|;
return|return
name|off
return|;
case|case
name|IPPROTO_FRAGMENT
case|:
comment|/* 		 * terminate parsing if it is not the first fragment, 		 * it does not make sense to parse through it. 		 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
operator|+
sizeof|sizeof
argument_list|(
name|fh
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|fh
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|fh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|fh
operator|.
name|ip6f_offlg
argument_list|)
operator|&
name|IP6F_OFF_MASK
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|nxtp
condition|)
operator|*
name|nxtp
operator|=
name|fh
operator|.
name|ip6f_nxt
expr_stmt|;
name|off
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
return|return
name|off
return|;
case|case
name|IPPROTO_AH
case|:
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
operator|+
sizeof|sizeof
argument_list|(
name|ip6e
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6e
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6e
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxtp
condition|)
operator|*
name|nxtp
operator|=
name|ip6e
operator|.
name|ip6e_nxt
expr_stmt|;
name|off
operator|+=
operator|(
name|ip6e
operator|.
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
return|return
name|off
return|;
case|case
name|IPPROTO_HOPOPTS
case|:
case|case
name|IPPROTO_ROUTING
case|:
case|case
name|IPPROTO_DSTOPTS
case|:
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
operator|+
sizeof|sizeof
argument_list|(
name|ip6e
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6e
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6e
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxtp
condition|)
operator|*
name|nxtp
operator|=
name|ip6e
operator|.
name|ip6e_nxt
expr_stmt|;
name|off
operator|+=
operator|(
name|ip6e
operator|.
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
return|return
name|off
return|;
case|case
name|IPPROTO_NONE
case|:
case|case
name|IPPROTO_ESP
case|:
case|case
name|IPPROTO_IPCOMP
case|:
comment|/* give up */
return|return
operator|-
literal|1
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * get offset for the last header in the chain.  m will be kept untainted.  */
end_comment

begin_function
name|int
name|ip6_lasthdr
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|,
name|proto
parameter_list|,
name|nxtp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|proto
decl_stmt|;
name|int
modifier|*
name|nxtp
decl_stmt|;
block|{
name|int
name|newoff
decl_stmt|;
name|int
name|nxt
decl_stmt|;
if|if
condition|(
operator|!
name|nxtp
condition|)
block|{
name|nxt
operator|=
operator|-
literal|1
expr_stmt|;
name|nxtp
operator|=
operator|&
name|nxt
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|newoff
operator|=
name|ip6_nexthdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|proto
argument_list|,
name|nxtp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newoff
operator|<
literal|0
condition|)
return|return
name|off
return|;
elseif|else
if|if
condition|(
name|newoff
operator|<
name|off
condition|)
return|return
operator|-
literal|1
return|;
comment|/* invalid */
elseif|else
if|if
condition|(
name|newoff
operator|==
name|off
condition|)
return|return
name|newoff
return|;
name|off
operator|=
name|newoff
expr_stmt|;
name|proto
operator|=
operator|*
name|nxtp
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|ip6_addaux
parameter_list|(
name|m
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6aux
argument_list|)
operator|>
name|MHLEN
condition|)
name|panic
argument_list|(
literal|"assumption failed on sizeof(ip6aux)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|m_aux_find
argument_list|(
name|m
argument_list|,
name|AF_INET6
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6aux
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"conflicting use of ip6aux"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|n
operator|=
name|m_aux_add
argument_list|(
name|m
argument_list|,
name|AF_INET6
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6aux
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|n
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|ip6_findaux
parameter_list|(
name|m
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|m_aux_find
argument_list|(
name|m
argument_list|,
name|AF_INET6
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6aux
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"conflicting use of ip6aux"
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
name|void
name|ip6_delaux
parameter_list|(
name|m
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|m_aux_find
argument_list|(
name|m
argument_list|,
name|AF_INET6
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|m_aux_delete
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * System control for IP6  */
end_comment

begin_decl_stmt
name|u_char
name|inet6ctlerrmap
index|[
name|PRC_NCMDS
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|EMSGSIZE
block|,
name|EHOSTDOWN
block|,
name|EHOSTUNREACH
block|,
name|EHOSTUNREACH
block|,
name|EHOSTUNREACH
block|,
name|ECONNREFUSED
block|,
name|ECONNREFUSED
block|,
name|EMSGSIZE
block|,
name|EHOSTUNREACH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|ENOPROTOOPT
block|}
decl_stmt|;
end_decl_stmt

end_unit

