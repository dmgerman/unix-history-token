begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)ip_input.c	8.2 (Berkeley) 1/4/94  */
end_comment

begin_include
include|#
directive|include
file|"opt_ip6fw.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*INET*/
end_comment

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_ifattach.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_prefix.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPV6FIREWALL
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ip6_fw.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ
end_ifdef

begin_include
include|#
directive|include
file|<netinet/altq_cdnr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet6/ip6protosw.h>
end_include

begin_comment
comment|/* we need it for NLOOP. */
end_comment

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_comment
comment|/* #include "faith.h" */
end_comment

begin_comment
comment|/* #include "gif.h" */
end_comment

begin_include
include|#
directive|include
file|<net/net_osdep.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|inet6domain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ip6protosw
name|inet6sw
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|ip6_protox
index|[
name|IPPROTO_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip6qmaxlen
init|=
name|IFQ_MAXLEN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in6_ifaddr
modifier|*
name|in6_ifaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ifqueue
name|ip6intrq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ip6_forward_srcrt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|int
name|ip6_sourcecheck
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|int
name|ip6_sourcecheck_interval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IPV6FIREWALL
end_ifdef

begin_comment
comment|/* firewall hooks */
end_comment

begin_decl_stmt
name|ip6_fw_chk_t
modifier|*
name|ip6_fw_chk_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ip6_fw_ctl_t
modifier|*
name|ip6_fw_ctl_ptr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|ip6stat
name|ip6stat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ip6_init2
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip6_hopopts_input
name|__P
argument_list|(
operator|(
name|u_int32_t
operator|*
operator|,
name|u_int32_t
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PTR
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|ip6_protocol_tr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ptr_in6
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ip_forward
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * IP6 initialization: fill in IP6 protocol switch table.  * All protocols not implemented in kernel go to raw IP6 protocol handler.  */
end_comment

begin_function
name|void
name|ip6_init
parameter_list|()
block|{
specifier|register
name|struct
name|ip6protosw
modifier|*
name|pr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|pr
operator|=
operator|(
expr|struct
name|ip6protosw
operator|*
operator|)
name|pffindproto
argument_list|(
name|PF_INET6
argument_list|,
name|IPPROTO_RAW
argument_list|,
name|SOCK_RAW
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ip6_init"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPPROTO_MAX
condition|;
name|i
operator|++
control|)
name|ip6_protox
index|[
name|i
index|]
operator|=
name|pr
operator|-
name|inet6sw
expr_stmt|;
for|for
control|(
name|pr
operator|=
operator|(
expr|struct
name|ip6protosw
operator|*
operator|)
name|inet6domain
operator|.
name|dom_protosw
init|;
name|pr
operator|<
operator|(
expr|struct
name|ip6protosw
operator|*
operator|)
name|inet6domain
operator|.
name|dom_protoswNPROTOSW
condition|;
name|pr
operator|++
control|)
if|if
condition|(
name|pr
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|PF_INET6
operator|&&
name|pr
operator|->
name|pr_protocol
operator|&&
name|pr
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_RAW
condition|)
name|ip6_protox
index|[
name|pr
operator|->
name|pr_protocol
index|]
operator|=
name|pr
operator|-
name|inet6sw
expr_stmt|;
name|ip6intrq
operator|.
name|ifq_maxlen
operator|=
name|ip6qmaxlen
expr_stmt|;
name|nd6_init
argument_list|()
expr_stmt|;
name|frag6_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|IPV6FIREWALL
name|ip6_fw_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * in many cases, random() here does NOT return random number 	 * as initialization during bootstrap time occur in fixed order. 	 */
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|ip6_flow_seq
operator|=
name|random
argument_list|()
operator|^
name|tv
operator|.
name|tv_usec
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ip6_init2
parameter_list|(
name|dummy
parameter_list|)
name|void
modifier|*
name|dummy
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* get EUI64 from somewhere */
name|ret
operator|=
name|in6_ifattach_getifid
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * to route local address of p2p link to loopback, 	 * assign loopback address first. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NLOOP
condition|;
name|i
operator|++
control|)
name|in6_ifattach
argument_list|(
operator|&
name|loif
index|[
name|i
index|]
argument_list|,
name|IN6_IFT_LOOP
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* attach pseudo interfaces */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|in6_ifattach_p2p
argument_list|()
expr_stmt|;
comment|/* nd6_timer_init */
name|timeout
argument_list|(
name|nd6_timer
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* router renumbering prefix list maintenance */
name|timeout
argument_list|(
name|in6_rr_timer
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cheat */
end_comment

begin_expr_stmt
name|SYSINIT
argument_list|(
name|netinet6init2
argument_list|,
name|SI_SUB_PROTO_DOMAIN
argument_list|,
name|SI_ORDER_THIRD
argument_list|,
name|ip6_init2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * IP6 input interrupt handling. Just pass the packet to ip6_input.  */
end_comment

begin_function
name|void
name|ip6intr
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|ip6intrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|ip6_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|NETISR_SET
argument_list|(
name|NETISR_IPV6
argument_list|,
name|ip6intr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|struct
name|route_in6
name|ip6_forward_rt
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ip6_input
parameter_list|(
name|m
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|int
name|off
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
decl_stmt|,
name|nest
decl_stmt|;
name|u_int32_t
name|plen
decl_stmt|;
name|u_int32_t
name|rtalert
init|=
operator|~
literal|0
decl_stmt|;
name|int
name|nxt
decl_stmt|,
name|ours
init|=
literal|0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|deliverifp
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|IPSEC
comment|/* 	 * should the inner packet be considered authentic? 	 * see comment in ah4_input(). 	 */
if|if
condition|(
name|m
condition|)
block|{
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_AUTHIPHDR
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_AUTHIPDGM
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * mbuf statistics by kazu 	 */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
name|ip6stat
operator|.
name|ip6s_mext2m
operator|++
expr_stmt|;
else|else
name|ip6stat
operator|.
name|ip6s_mext1
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_LOOP
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_m2m
index|[
name|loif
index|[
literal|0
index|]
operator|.
name|if_index
index|]
operator|++
expr_stmt|;
comment|/*XXX*/
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_index
operator|<=
literal|31
condition|)
name|ip6stat
operator|.
name|ip6s_m2m
index|[
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_index
index|]
operator|++
expr_stmt|;
else|else
name|ip6stat
operator|.
name|ip6s_m2m
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
else|else
name|ip6stat
operator|.
name|ip6s_m1
operator|++
expr_stmt|;
block|}
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_receive
argument_list|)
expr_stmt|;
name|ip6stat
operator|.
name|ip6s_total
operator|++
expr_stmt|;
name|IP6_EXTHDR_CHECK
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
comment|/*nothing*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|inifp
decl_stmt|;
name|inifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|inifp
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ip6
operator|->
name|ip6_vfc
operator|&
name|IPV6_VERSION_MASK
operator|)
operator|!=
name|IPV6_VERSION
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badvers
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip6stat
operator|.
name|ip6s_nxthist
index|[
name|ip6
operator|->
name|ip6_nxt
index|]
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|IPV6FIREWALL
comment|/* 	 * Check with the firewall... 	 */
if|if
condition|(
name|ip6_fw_chk_ptr
condition|)
block|{
name|u_short
name|port
init|=
literal|0
decl_stmt|;
comment|/* If ipfw says divert, we have to just drop packet */
comment|/* use port as a dummy argument */
if|if
condition|(
call|(
modifier|*
name|ip6_fw_chk_ptr
call|)
argument_list|(
operator|&
name|ip6
argument_list|,
name|NULL
argument_list|,
operator|&
name|port
argument_list|,
operator|&
name|m
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|m
condition|)
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALTQ
if|if
condition|(
name|altq_input
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|altq_input
call|)
argument_list|(
name|m
argument_list|,
name|AF_INET6
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* packet is dropped by traffic conditioner */
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * Scope check 	 */
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|||
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_addrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|||
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
condition|)
block|{
name|ours
operator|=
literal|1
expr_stmt|;
name|deliverifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
goto|goto
name|hbhcheck
goto|;
block|}
else|else
block|{
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_addrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
condition|)
block|{
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|ours
operator|=
literal|1
expr_stmt|;
name|deliverifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
goto|goto
name|hbhcheck
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
name|ip6
operator|->
name|ip6_src
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
name|ip6
operator|->
name|ip6_dst
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_index
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PTR
argument_list|)
comment|/* 	 * 	 */
if|if
condition|(
name|ip6_protocol_tr
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m1
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|ptr_in6
argument_list|(
name|m
argument_list|,
operator|&
name|m1
argument_list|)
condition|)
block|{
case|case
name|IPPROTO_IP
case|:
goto|goto
name|mcastcheck
goto|;
case|case
name|IPPROTO_IPV4
case|:
name|ip_forward
argument_list|(
name|m1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_IPV6
case|:
name|ip6_forward
argument_list|(
name|m1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_MAX
case|:
comment|/* discard this packet	*/
default|default:
block|}
if|if
condition|(
name|m
operator|!=
name|m1
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|mcastcheck
label|:
endif|#
directive|endif
comment|/* 	 * Multicast check 	 */
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|struct
name|in6_multi
modifier|*
name|in6m
init|=
literal|0
decl_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_mcast
argument_list|)
expr_stmt|;
comment|/* 		 * See if we belong to the destination multicast group on the 		 * arrival interface. 		 */
name|IN6_LOOKUP_MULTI
argument_list|(
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|in6m
argument_list|)
expr_stmt|;
if|if
condition|(
name|in6m
condition|)
name|ours
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|ip6stat
operator|.
name|ip6s_notmember
operator|++
expr_stmt|;
name|ip6stat
operator|.
name|ip6s_cantforward
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_discard
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|deliverifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
goto|goto
name|hbhcheck
goto|;
block|}
comment|/* 	 *  Unicast check 	 */
if|if
condition|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|==
literal|0
operator|||
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
operator|&
name|ip6_forward_rt
operator|.
name|ro_dst
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|ip6_forward_rt
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|ip6_forward_rt
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|ip6_forward_rt
operator|.
name|ro_rt
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|ip6_forward_rt
operator|.
name|ro_dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|ip6_forward_rt
operator|.
name|ro_dst
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|ip6_forward_rt
operator|.
name|ro_dst
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|ip6_forward_rt
operator|.
name|ro_dst
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|rtalloc_ign
argument_list|(
operator|(
expr|struct
name|route
operator|*
operator|)
operator|&
name|ip6_forward_rt
argument_list|,
name|RTF_PRCLONING
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|rt6_key
parameter_list|(
name|r
parameter_list|)
value|((struct sockaddr_in6 *)((r)->rt_nodes->rn_key))
comment|/* 	 * Accept the packet if the forwarding interface to the destination 	 * according to the routing table is the loopback interface, 	 * unless the associated route has a gateway. 	 * Note that this approach causes to accept a packet if there is a 	 * route to the loopback interface for the destination of the packet. 	 * But we think it's even useful in some situations, e.g. when using 	 * a special daemon which wants to intercept the packet. 	 */
if|if
condition|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|&&
operator|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_HOST
operator||
name|RTF_GATEWAY
operator|)
operator|)
operator|==
name|RTF_HOST
operator|&&
comment|/* 	     * The comparison of the destination and the key of the rtentry 	     * has already done through looking up the routing table, 	     * so no need to do such a comparison here again. 	     */
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_type
operator|==
name|IFT_LOOP
condition|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ia6
init|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifa
decl_stmt|;
comment|/* packet to tentative address must not be received */
if|if
condition|(
name|ia6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_ANYCAST
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_ANYCAST6
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ia6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_NOTREADY
operator|)
condition|)
block|{
comment|/* this interface is ready */
name|ours
operator|=
literal|1
expr_stmt|;
name|deliverifp
operator|=
name|ia6
operator|->
name|ia_ifp
expr_stmt|;
comment|/* correct? */
goto|goto
name|hbhcheck
goto|;
block|}
else|else
block|{
comment|/* this interface is not ready, fall through */
block|}
block|}
comment|/* 	 * FAITH(Firewall Aided Internet Translator) 	 */
if|#
directive|if
name|defined
argument_list|(
name|NFAITH
argument_list|)
operator|&&
literal|0
operator|<
name|NFAITH
if|if
condition|(
name|ip6_keepfaith
condition|)
block|{
if|if
condition|(
name|ip6_forward_rt
operator|.
name|ro_rt
operator|&&
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|&&
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_type
operator|==
name|IFT_FAITH
condition|)
block|{
comment|/* XXX do we need more sanity checks? */
name|ours
operator|=
literal|1
expr_stmt|;
name|deliverifp
operator|=
name|ip6_forward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
comment|/*faith*/
goto|goto
name|hbhcheck
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Now there is no reason to process the packet if it's not our own 	 * and we're not a router. 	 */
if|if
condition|(
operator|!
name|ip6_forwarding
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_cantforward
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_discard
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|hbhcheck
label|:
comment|/* 	 * Process Hop-by-Hop options header if it's contained. 	 * m may be modified in ip6_hopopts_input(). 	 * If a JumboPayload option is included, plen will also be modified. 	 */
name|plen
operator|=
operator|(
name|u_int32_t
operator|)
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6
operator|->
name|ip6_nxt
operator|==
name|IPPROTO_HOPOPTS
condition|)
block|{
if|if
condition|(
name|ip6_hopopts_input
argument_list|(
operator|&
name|plen
argument_list|,
operator|&
name|rtalert
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|off
argument_list|)
condition|)
block|{
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_discard
argument_list|)
expr_stmt|;
return|return;
comment|/* m have already been freed */
block|}
comment|/* adjust pointer */
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|nxt
operator|=
operator|(
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
operator|(
name|ip6
operator|+
literal|1
operator|)
operator|)
operator|->
name|ip6h_nxt
expr_stmt|;
comment|/* 		 * accept the packet if a router alert option is included 		 * and we act as an IPv6 router. 		 */
if|if
condition|(
name|rtalert
operator|!=
operator|~
literal|0
operator|&&
name|ip6_forwarding
condition|)
name|ours
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|nxt
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
comment|/* 	 * Check that the amount of data in the buffers 	 * is as at least much as the IPv6 header would have us expect. 	 * Trim mbufs if longer than we expect. 	 * Drop packet if shorter than we expect. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|<
name|plen
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_truncated
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
expr_stmt|;
block|}
else|else
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Forward if desirable. 	 */
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ours
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ours
condition|)
block|{
name|ip6_forward
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Tell launch routine the next header 	 */
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|IFA_STATS
argument_list|)
if|if
condition|(
name|IFA_STATS
operator|&&
name|deliverifp
operator|!=
name|NULL
condition|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|ia6
operator|=
name|in6_ifawithifp
argument_list|(
name|deliverifp
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia6
condition|)
name|ia6
operator|->
name|ia_ifa
operator|.
name|ifa_data
operator|.
name|ifad_inbytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
endif|#
directive|endif
name|ip6stat
operator|.
name|ip6s_delivered
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|deliverifp
argument_list|,
name|ifs6_in_deliver
argument_list|)
expr_stmt|;
name|nest
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nxt
operator|!=
name|IPPROTO_DONE
condition|)
block|{
if|if
condition|(
name|ip6_hdrnestlimit
operator|&&
operator|(
operator|++
name|nest
operator|>
name|ip6_hdrnestlimit
operator|)
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toomanyhdr
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * protection against faulty packet - there should be 		 * more sanity checks in header chain processing. 		 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_tooshort
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_truncated
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|nxt
operator|=
operator|(
operator|*
name|inet6sw
index|[
name|ip6_protox
index|[
name|nxt
index|]
index|]
operator|.
name|pr_input
operator|)
operator|(
operator|&
name|m
operator|,
operator|&
name|off
operator|,
name|nxt
operator|)
expr_stmt|;
block|}
return|return;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hop-by-Hop options header processing. If a valid jumbo payload option is  * included, the real payload length will be stored in plenp.  */
end_comment

begin_function
specifier|static
name|int
name|ip6_hopopts_input
parameter_list|(
name|plenp
parameter_list|,
name|rtalertp
parameter_list|,
name|mp
parameter_list|,
name|offp
parameter_list|)
name|u_int32_t
modifier|*
name|plenp
decl_stmt|;
name|u_int32_t
modifier|*
name|rtalertp
decl_stmt|;
comment|/* XXX: should be stored more smart way */
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
modifier|*
name|offp
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|int
name|off
init|=
operator|*
name|offp
decl_stmt|,
name|hbhlen
decl_stmt|;
name|struct
name|ip6_hbh
modifier|*
name|hbh
decl_stmt|;
name|u_int8_t
modifier|*
name|opt
decl_stmt|;
comment|/* validation of the length of the header */
name|IP6_EXTHDR_CHECK
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hbh
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hbh
operator|=
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|hbhlen
operator|=
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|IP6_EXTHDR_CHECK
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|hbhlen
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hbh
operator|=
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|off
operator|+=
name|hbhlen
expr_stmt|;
name|hbhlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
expr_stmt|;
name|opt
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|hbh
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6_process_hopopts
argument_list|(
name|m
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|hbh
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
argument_list|,
name|hbhlen
argument_list|,
name|rtalertp
argument_list|,
name|plenp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|offp
operator|=
name|off
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search header for all Hop-by-hop options and process each option.  * This function is separate from ip6_hopopts_input() in order to  * handle a case where the sending node itself process its hop-by-hop  * options header. In such a case, the function is called from ip6_output().  */
end_comment

begin_function
name|int
name|ip6_process_hopopts
parameter_list|(
name|m
parameter_list|,
name|opthead
parameter_list|,
name|hbhlen
parameter_list|,
name|rtalertp
parameter_list|,
name|plenp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int8_t
modifier|*
name|opthead
decl_stmt|;
name|int
name|hbhlen
decl_stmt|;
name|u_int32_t
modifier|*
name|rtalertp
decl_stmt|;
name|u_int32_t
modifier|*
name|plenp
decl_stmt|;
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|int
name|optlen
init|=
literal|0
decl_stmt|;
name|u_int8_t
modifier|*
name|opt
init|=
name|opthead
decl_stmt|;
name|u_int16_t
name|rtalert_val
decl_stmt|;
for|for
control|(
init|;
name|hbhlen
operator|>
literal|0
condition|;
name|hbhlen
operator|-=
name|optlen
operator|,
name|opt
operator|+=
name|optlen
control|)
block|{
switch|switch
condition|(
operator|*
name|opt
condition|)
block|{
case|case
name|IP6OPT_PAD1
case|:
name|optlen
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IP6OPT_PADN
case|:
if|if
condition|(
name|hbhlen
operator|<
name|IP6OPT_MINLEN
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|optlen
operator|=
operator|*
operator|(
name|opt
operator|+
literal|1
operator|)
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|IP6OPT_RTALERT
case|:
comment|/* XXX may need check for alignment */
if|if
condition|(
name|hbhlen
operator|<
name|IP6OPT_RTALERT_LEN
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|*
operator|(
name|opt
operator|+
literal|1
operator|)
operator|!=
name|IP6OPT_RTALERT_LEN
operator|-
literal|2
condition|)
comment|/* XXX: should we discard the packet? */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"length of router alert opt is inconsitent(%d)"
argument_list|,
operator|*
operator|(
name|opt
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|optlen
operator|=
name|IP6OPT_RTALERT_LEN
expr_stmt|;
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|opt
operator|+
literal|2
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rtalert_val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|*
name|rtalertp
operator|=
name|ntohs
argument_list|(
name|rtalert_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP6OPT_JUMBO
case|:
comment|/* XXX may need check for alignment */
if|if
condition|(
name|hbhlen
operator|<
name|IP6OPT_JUMBO_LEN
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|*
operator|(
name|opt
operator|+
literal|1
operator|)
operator|!=
name|IP6OPT_JUMBO_LEN
operator|-
literal|2
condition|)
comment|/* XXX: should we discard the packet? */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"length of jumbopayload opt "
literal|"is inconsistent(%d)"
argument_list|,
operator|*
operator|(
name|opt
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|optlen
operator|=
name|IP6OPT_JUMBO_LEN
expr_stmt|;
name|bcopy
argument_list|(
name|opt
operator|+
literal|2
argument_list|,
name|plenp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|plenp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|plenp
operator|=
name|htonl
argument_list|(
operator|*
name|plenp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|plenp
operator|<=
name|IPV6_MAXPACKET
condition|)
block|{
comment|/* 				  * jumbo payload length must be larger 				  * than 65535 				  */
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_HEADER
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
operator|+
name|opt
operator|+
literal|2
operator|-
name|opthead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6
operator|->
name|ip6_plen
condition|)
block|{
comment|/* 				  * IPv6 packets that have non 0 payload length 				  * must not contain a jumbo paylod option. 				  */
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_HEADER
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
operator|+
name|opt
operator|-
name|opthead
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
default|default:
comment|/* unknown option */
if|if
condition|(
name|hbhlen
operator|<
name|IP6OPT_MINLEN
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|optlen
operator|=
name|ip6_unknown_opt
argument_list|(
name|opt
argument_list|,
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
operator|+
name|opt
operator|-
name|opthead
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|optlen
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unknown option processing.  * The third argument `off' is the offset from the IPv6 header to the option,  * which is necessary if the IPv6 header the and option header and IPv6 header  * is not continuous in order to return an ICMPv6 error.  */
end_comment

begin_function
name|int
name|ip6_unknown_opt
parameter_list|(
name|optp
parameter_list|,
name|m
parameter_list|,
name|off
parameter_list|)
name|u_int8_t
modifier|*
name|optp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
switch|switch
condition|(
name|IP6OPT_TYPE
argument_list|(
operator|*
name|optp
argument_list|)
condition|)
block|{
case|case
name|IP6OPT_TYPE_SKIP
case|:
comment|/* ignore the option */
return|return
operator|(
operator|(
name|int
operator|)
operator|*
operator|(
name|optp
operator|+
literal|1
operator|)
operator|)
return|;
case|case
name|IP6OPT_TYPE_DISCARD
case|:
comment|/* silently discard */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|IP6OPT_TYPE_FORCEICMP
case|:
comment|/* send ICMP even if multicasted */
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_OPTION
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|IP6OPT_TYPE_ICMP
case|:
comment|/* send ICMP if not multicasted */
name|ip6stat
operator|.
name|ip6s_badoptions
operator|++
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|||
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_OPTION
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* XXX: NOTREACHED */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the "control" list for this pcb  */
end_comment

begin_function
name|void
name|ip6_savecontrol
parameter_list|(
name|in6p
parameter_list|,
name|mp
parameter_list|,
name|ip6
parameter_list|,
name|m
parameter_list|)
specifier|register
name|struct
name|inpcb
modifier|*
name|in6p
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
name|int
name|privileged
decl_stmt|;
name|privileged
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|!
name|suser
argument_list|(
name|p
argument_list|)
condition|)
name|privileged
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SO_TIMESTAMP
if|if
condition|(
name|in6p
operator|->
name|in6p_socket
operator|->
name|so_options
operator|&
name|SO_TIMESTAMP
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|,
name|SCM_TIMESTAMP
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_RECVDSTADDR
condition|)
block|{
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
name|IPV6_RECVDSTADDR
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* RFC 2292 sec. 5 */
if|if
condition|(
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_PKTINFO
condition|)
block|{
name|struct
name|in6_pktinfo
name|pi6
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
operator|&
name|pi6
operator|.
name|ipi6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|pi6
operator|.
name|ipi6_addr
argument_list|)
condition|)
name|pi6
operator|.
name|ipi6_addr
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pi6
operator|.
name|ipi6_ifindex
operator|=
operator|(
name|m
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|)
condition|?
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_index
else|:
literal|0
expr_stmt|;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|pi6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|,
name|IPV6_PKTINFO
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_HOPLIMIT
condition|)
block|{
name|int
name|hlim
init|=
name|ip6
operator|->
name|ip6_hlim
operator|&
literal|0xff
decl_stmt|;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|hlim
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|IPV6_HOPLIMIT
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* IN6P_NEXTHOP - for outgoing packet only */
comment|/* 	 * IPV6_HOPOPTS socket option. We require super-user privilege 	 * for the option, but it might be too strict, since there might 	 * be some hop-by-hop options which can be returned to normal user. 	 * See RFC 2292 section 6. 	 */
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_HOPOPTS
operator|)
operator|&&
name|privileged
condition|)
block|{
comment|/* 		 * Check if a hop-by-hop options header is contatined in the 		 * received packet, and if so, store the options as ancillary 		 * data. Note that a hop-by-hop options header must be 		 * just after the IPv6 header, which fact is assured through 		 * the IPv6 input processing. 		 */
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip6
operator|->
name|ip6_nxt
operator|==
name|IPPROTO_HOPOPTS
condition|)
block|{
name|struct
name|ip6_hbh
modifier|*
name|hbh
init|=
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
operator|(
name|ip6
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* 			 * XXX: We copy whole the header even if a jumbo 			 * payload option is included, which option is to 			 * be removed before returning in the RFC 2292. 			 * But it's too painful operation... 			 */
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
name|hbh
argument_list|,
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
argument_list|,
name|IPV6_HOPOPTS
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
block|}
comment|/* IPV6_DSTOPTS and IPV6_RTHDR socket options */
if|if
condition|(
name|in6p
operator|->
name|in6p_flags
operator|&
operator|(
name|IN6P_DSTOPTS
operator||
name|IN6P_RTHDR
operator|)
condition|)
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
name|int
name|nxt
init|=
name|ip6
operator|->
name|ip6_nxt
decl_stmt|,
name|off
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
decl_stmt|;
empty_stmt|;
comment|/* 		 * Search for destination options headers or routing 		 * header(s) through the header chain, and stores each 		 * header as ancillary data. 		 * Note that the order of the headers remains in 		 * the chain of ancillary data. 		 */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* is explicit loop prevention necessary? */
name|struct
name|ip6_ext
modifier|*
name|ip6e
init|=
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
decl_stmt|;
switch|switch
condition|(
name|nxt
condition|)
block|{
case|case
name|IPPROTO_DSTOPTS
case|:
if|if
condition|(
operator|!
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_DSTOPTS
condition|)
break|break;
comment|/* 				  * We also require super-user privilege for 				  * the option. 				  * See the comments on IN6_HOPOPTS. 				  */
if|if
condition|(
operator|!
name|privileged
condition|)
break|break;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip6e
argument_list|,
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
argument_list|,
name|IPV6_DSTOPTS
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
break|break;
case|case
name|IPPROTO_ROUTING
case|:
if|if
condition|(
operator|!
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_RTHDR
condition|)
break|break;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip6e
argument_list|,
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
argument_list|,
name|IPV6_RTHDR
argument_list|,
name|IPPROTO_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
case|case
name|IPPROTO_TCP
case|:
case|case
name|IPPROTO_ICMPV6
case|:
default|default:
comment|/* 				  * stop search if we encounter an upper 				  * layer protocol headers. 				  */
goto|goto
name|loopend
goto|;
case|case
name|IPPROTO_HOPOPTS
case|:
case|case
name|IPPROTO_AH
case|:
comment|/* is it possible? */
break|break;
block|}
comment|/* proceed with the next header. */
if|if
condition|(
name|nxt
operator|==
name|IPPROTO_AH
condition|)
name|off
operator|+=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
else|else
name|off
operator|+=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|nxt
operator|=
name|ip6e
operator|->
name|ip6e_nxt
expr_stmt|;
block|}
name|loopend
label|:
block|}
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_HOPOPTS
operator|)
operator|&&
name|privileged
condition|)
block|{
comment|/* to be done */
block|}
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_flags
operator|&
name|IN6P_DSTOPTS
operator|)
operator|&&
name|privileged
condition|)
block|{
comment|/* to be done */
block|}
comment|/* IN6P_RTHDR - to be done */
block|}
end_function

begin_comment
comment|/*  * Get pointer to the previous header followed by the header  * currently processed.  * XXX: This function supposes that  *	M includes all headers,  *	the next header field and the header length field of each header  *	are valid, and  *	the sum of each header length equals to OFF.  * Because of these assumptions, this function must be called very  * carefully. Moreover, it will not be used in the near future when  * we develop `neater' mechanism to process extension headers.  */
end_comment

begin_function
name|char
modifier|*
name|ip6_get_prevhdr
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|off
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
return|return
operator|(
operator|&
name|ip6
operator|->
name|ip6_nxt
operator|)
return|;
else|else
block|{
name|int
name|len
decl_stmt|,
name|nxt
decl_stmt|;
name|struct
name|ip6_ext
modifier|*
name|ip6e
init|=
name|NULL
decl_stmt|;
name|nxt
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|off
condition|)
block|{
name|ip6e
operator|=
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|len
operator|)
expr_stmt|;
switch|switch
condition|(
name|nxt
condition|)
block|{
case|case
name|IPPROTO_FRAGMENT
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_AH
case|:
name|len
operator|+=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
break|break;
default|default:
name|len
operator|+=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
break|break;
block|}
name|nxt
operator|=
name|ip6e
operator|->
name|ip6e_nxt
expr_stmt|;
block|}
if|if
condition|(
name|ip6e
condition|)
return|return
operator|(
operator|&
name|ip6e
operator|->
name|ip6e_nxt
operator|)
return|;
else|else
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * System control for IP6  */
end_comment

begin_decl_stmt
name|u_char
name|inet6ctlerrmap
index|[
name|PRC_NCMDS
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|EMSGSIZE
block|,
name|EHOSTDOWN
block|,
name|EHOSTUNREACH
block|,
name|EHOSTUNREACH
block|,
name|EHOSTUNREACH
block|,
name|ECONNREFUSED
block|,
name|ECONNREFUSED
block|,
name|EMSGSIZE
block|,
name|EHOSTUNREACH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|ENOPROTOOPT
block|}
decl_stmt|;
end_decl_stmt

end_unit

