begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$KAME: ip6_output.c,v 1.279 2002/01/26 06:12:30 jinmei Exp $  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1988, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)ip_output.c	8.3 (Berkeley) 1/21/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|"opt_sctp.h"
end_include

begin_include
include|#
directive|include
file|"opt_route.h"
end_include

begin_include
include|#
directive|include
file|"opt_rss.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llatbl.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/pfil.h>
end_include

begin_include
include|#
directive|include
file|<net/rss_config.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_fib.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_rss.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipsec_support.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP
end_ifdef

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_crc32.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet6/ip6protosw.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/scope6_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FLOWTABLE
end_ifdef

begin_include
include|#
directive|include
file|<net/flowtable.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|in6_mcast_loop
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ip6_exthdrs
block|{
name|struct
name|mbuf
modifier|*
name|ip6e_ip6
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ip6e_hbh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ip6e_dest1
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ip6e_rthdr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ip6e_dest2
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IP6OPT
argument_list|,
literal|"ip6opt"
argument_list|,
literal|"IPv6 options"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|ip6_pcbopt
parameter_list|(
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ip6_pktopts
modifier|*
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip6_pcbopts
parameter_list|(
name|struct
name|ip6_pktopts
modifier|*
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip6_getpcbopt
parameter_list|(
name|struct
name|ip6_pktopts
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip6_setpktopt
parameter_list|(
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ip6_pktopts
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip6_copyexthdr
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip6_insertfraghdr
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ip6_frag
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip6_insert_jumboopt
parameter_list|(
name|struct
name|ip6_exthdrs
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip6_splithdr
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ip6_exthdrs
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip6_getpmtu
parameter_list|(
name|struct
name|route_in6
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
parameter_list|,
name|u_long
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip6_calcmtu
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|u_long
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip6_getpmtu_ctl
parameter_list|(
name|u_int
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
parameter_list|,
name|u_long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|copypktopts
parameter_list|(
name|struct
name|ip6_pktopts
modifier|*
parameter_list|,
name|struct
name|ip6_pktopts
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Make an extension header from option data.  hp is the source, and  * mp is the destination.  */
end_comment

begin_define
define|#
directive|define
name|MAKE_EXTHDR
parameter_list|(
name|hp
parameter_list|,
name|mp
parameter_list|)
define|\
value|do {								\ 	if (hp) {							\ 		struct ip6_ext *eh = (struct ip6_ext *)(hp);		\ 		error = ip6_copyexthdr((mp), (caddr_t)(hp),		\ 		    ((eh)->ip6e_len + 1)<< 3);				\ 		if (error)						\ 			goto freehdrs;					\ 	}								\     } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_comment
comment|/*  * Form a chain of extension headers.  * m is the extension header mbuf  * mp is the previous mbuf in the chain  * p is the next header  * i is the type of option.  */
end_comment

begin_define
define|#
directive|define
name|MAKE_CHAIN
parameter_list|(
name|m
parameter_list|,
name|mp
parameter_list|,
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|do {\ 	if (m) {\ 		if (!hdrsplit) \ 			panic("assumption failed: hdr not split"); \ 		*mtod((m), u_char *) = *(p);\ 		*(p) = (i);\ 		p = mtod((m), u_char *);\ 		(m)->m_next = (mp)->m_next;\ 		(mp)->m_next = (m);\ 		(mp) = (m);\ 	}\     } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_function
name|void
name|in6_delayed_cksum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|plen
parameter_list|,
name|u_short
name|offset
parameter_list|)
block|{
name|u_short
name|csum
decl_stmt|;
name|csum
operator|=
name|in_cksum_skip
argument_list|(
name|m
argument_list|,
name|offset
operator|+
name|plen
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP_IPV6
operator|&&
name|csum
operator|==
literal|0
condition|)
name|csum
operator|=
literal|0xffff
expr_stmt|;
name|offset
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
comment|/* checksum offset */
if|if
condition|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|>
name|m
operator|->
name|m_len
condition|)
block|{
name|printf
argument_list|(
literal|"%s: delayed m_pullup, m->len: %d plen %u off %u "
literal|"csum_flags=%b\n"
argument_list|,
name|__func__
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|plen
argument_list|,
name|offset
argument_list|,
operator|(
name|int
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
argument_list|,
name|CSUM_BITS
argument_list|)
expr_stmt|;
comment|/* 		 * XXX this should not happen, but if it does, the correct 		 * behavior may be to insert the checksum in the appropriate 		 * next mbuf in the chain. 		 */
return|return;
block|}
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|offset
operator|)
operator|=
name|csum
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ip6_fragment
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|hlen
parameter_list|,
name|u_char
name|nextproto
parameter_list|,
name|int
name|mtu
parameter_list|,
name|uint32_t
name|id
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mnext
decl_stmt|,
modifier|*
name|m_frgpart
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|,
modifier|*
name|mhip6
decl_stmt|;
name|struct
name|ip6_frag
modifier|*
name|ip6f
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|tlen
init|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|mtu
operator|%
literal|8
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"Fragment length must be a multiple of 8"
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|mnext
operator|=
operator|&
name|m
operator|->
name|m_nextpkt
expr_stmt|;
for|for
control|(
name|off
operator|=
name|hlen
init|;
name|off
operator|<
name|tlen
condition|;
name|off
operator|+=
name|mtu
control|)
block|{
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|IP6STAT_INC
argument_list|(
name|ip6s_odropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|->
name|m_flags
operator|=
name|m0
operator|->
name|m_flags
operator|&
name|M_COPYFLAGS
expr_stmt|;
operator|*
name|mnext
operator|=
name|m
expr_stmt|;
name|mnext
operator|=
operator|&
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|mhip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
operator|*
name|mhip6
operator|=
operator|*
name|ip6
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mhip6
argument_list|)
expr_stmt|;
name|error
operator|=
name|ip6_insertfraghdr
argument_list|(
name|m0
argument_list|,
name|m
argument_list|,
name|hlen
argument_list|,
operator|&
name|ip6f
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IP6STAT_INC
argument_list|(
name|ip6s_odropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ip6f
operator|->
name|ip6f_offlg
operator|=
name|htons
argument_list|(
call|(
name|u_short
call|)
argument_list|(
operator|(
name|off
operator|-
name|hlen
operator|)
operator|&
operator|~
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|mtu
operator|>=
name|tlen
condition|)
name|mtu
operator|=
name|tlen
operator|-
name|off
expr_stmt|;
else|else
name|ip6f
operator|->
name|ip6f_offlg
operator||=
name|IP6F_MORE_FRAG
expr_stmt|;
name|mhip6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
call|(
name|u_short
call|)
argument_list|(
name|mtu
operator|+
name|hlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6f
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m_frgpart
operator|=
name|m_copy
argument_list|(
name|m0
argument_list|,
name|off
argument_list|,
name|mtu
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|IP6STAT_INC
argument_list|(
name|ip6s_odropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m_cat
argument_list|(
name|m
argument_list|,
name|m_frgpart
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mtu
operator|+
name|hlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6f
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|fibnum
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|fibnum
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|ip6f
operator|->
name|ip6f_reserved
operator|=
literal|0
expr_stmt|;
name|ip6f
operator|->
name|ip6f_ident
operator|=
name|id
expr_stmt|;
name|ip6f
operator|->
name|ip6f_nxt
operator|=
name|nextproto
expr_stmt|;
name|IP6STAT_INC
argument_list|(
name|ip6s_ofragments
argument_list|)
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_fragcreat
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IP6 output. The packet in mbuf chain m contains a skeletal IP6  * header (with pri, len, nxt, hlim, src, dst).  * This function may modify ver and hlim only.  * The mbuf chain containing the packet will be freed.  * The mbuf opt, if present, will not be freed.  * If route_in6 ro is present and has ro_rt initialized, route lookup would be  * skipped and ro->ro_rt would be used. If ro is present but ro->ro_rt is NULL,  * then result of route lookup is stored in ro->ro_rt.  *  * type of "mtu": rt_mtu is u_long, ifnet.ifr_mtu is int, and  * nd_ifinfo.linkmtu is u_int32_t.  so we use u_long to hold largest one,  * which is rt_mtu.  *  * ifpp - XXX: just for statistics  */
end_comment

begin_comment
comment|/*  * XXX TODO: no flowid is assigned for outbound flows?  */
end_comment

begin_function
name|int
name|ip6_output
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|struct
name|ip6_pktopts
modifier|*
name|opt
parameter_list|,
name|struct
name|route_in6
modifier|*
name|ro
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|ip6_moptions
modifier|*
name|im6o
parameter_list|,
name|struct
name|ifnet
modifier|*
modifier|*
name|ifpp
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|origifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mprev
init|=
name|NULL
decl_stmt|;
name|int
name|hlen
decl_stmt|,
name|tlen
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|route_in6
name|ip6route
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|dst
decl_stmt|,
name|src_sa
decl_stmt|,
name|dst_sa
decl_stmt|;
name|struct
name|in6_addr
name|odst
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia
init|=
name|NULL
decl_stmt|;
name|u_long
name|mtu
decl_stmt|;
name|int
name|alwaysfrag
decl_stmt|,
name|dontfrag
decl_stmt|;
name|u_int32_t
name|optlen
init|=
literal|0
decl_stmt|,
name|plen
init|=
literal|0
decl_stmt|,
name|unfragpartlen
init|=
literal|0
decl_stmt|;
name|struct
name|ip6_exthdrs
name|exthdrs
decl_stmt|;
name|struct
name|in6_addr
name|src0
decl_stmt|,
name|dst0
decl_stmt|;
name|u_int32_t
name|zone
decl_stmt|;
name|struct
name|route_in6
modifier|*
name|ro_pmtu
init|=
name|NULL
decl_stmt|;
name|int
name|hdrsplit
init|=
literal|0
decl_stmt|;
name|int
name|sw_csum
decl_stmt|,
name|tso
decl_stmt|;
name|int
name|needfiblookup
decl_stmt|;
name|uint32_t
name|fibnum
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|fwd_tag
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
block|{
name|M_SETFIB
argument_list|(
name|m
argument_list|,
name|inp
operator|->
name|inp_inc
operator|.
name|inc_fibnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|IP_NODEFAULTFLOWID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* unconditionally set flowid */
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|inp
operator|->
name|inp_flowid
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|m
argument_list|,
name|inp
operator|->
name|inp_flowtype
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|IPSEC
argument_list|)
operator|||
name|defined
argument_list|(
name|IPSEC_SUPPORT
argument_list|)
comment|/* 	 * IPSec checking which handles several cases. 	 * FAST IPSEC: We re-injected the packet. 	 * XXX: need scope argument. 	 */
if|if
condition|(
name|IPSEC_ENABLED
argument_list|(
name|ipv6
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|IPSEC_OUTPUT
argument_list|(
name|ipv6
argument_list|,
name|m
argument_list|,
name|inp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* IPSEC */
name|bzero
argument_list|(
operator|&
name|exthdrs
argument_list|,
sizeof|sizeof
argument_list|(
name|exthdrs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
condition|)
block|{
comment|/* Hop-by-Hop options header */
name|MAKE_EXTHDR
argument_list|(
name|opt
operator|->
name|ip6po_hbh
argument_list|,
operator|&
name|exthdrs
operator|.
name|ip6e_hbh
argument_list|)
expr_stmt|;
comment|/* Destination options header(1st part) */
if|if
condition|(
name|opt
operator|->
name|ip6po_rthdr
condition|)
block|{
comment|/* 			 * Destination options header(1st part) 			 * This only makes sense with a routing header. 			 * See Section 9.2 of RFC 3542. 			 * Disabling this part just for MIP6 convenience is 			 * a bad idea.  We need to think carefully about a 			 * way to make the advanced API coexist with MIP6 			 * options, which might automatically be inserted in 			 * the kernel. 			 */
name|MAKE_EXTHDR
argument_list|(
name|opt
operator|->
name|ip6po_dest1
argument_list|,
operator|&
name|exthdrs
operator|.
name|ip6e_dest1
argument_list|)
expr_stmt|;
block|}
comment|/* Routing header */
name|MAKE_EXTHDR
argument_list|(
name|opt
operator|->
name|ip6po_rthdr
argument_list|,
operator|&
name|exthdrs
operator|.
name|ip6e_rthdr
argument_list|)
expr_stmt|;
comment|/* Destination options header(2nd part) */
name|MAKE_EXTHDR
argument_list|(
name|opt
operator|->
name|ip6po_dest2
argument_list|,
operator|&
name|exthdrs
operator|.
name|ip6e_dest2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Calculate the total length of the extension header chain. 	 * Keep the length of the unfragmentable part for fragmentation. 	 */
name|optlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_hbh
condition|)
name|optlen
operator|+=
name|exthdrs
operator|.
name|ip6e_hbh
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_dest1
condition|)
name|optlen
operator|+=
name|exthdrs
operator|.
name|ip6e_dest1
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_rthdr
condition|)
name|optlen
operator|+=
name|exthdrs
operator|.
name|ip6e_rthdr
operator|->
name|m_len
expr_stmt|;
name|unfragpartlen
operator|=
name|optlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
comment|/* NOTE: we don't add AH/ESP length here (done in ip6_ipsec_output) */
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_dest2
condition|)
name|optlen
operator|+=
name|exthdrs
operator|.
name|ip6e_dest2
operator|->
name|m_len
expr_stmt|;
comment|/* 	 * If there is at least one extension header, 	 * separate IP6 header from the payload. 	 */
if|if
condition|(
name|optlen
operator|&&
operator|!
name|hdrsplit
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|ip6_splithdr
argument_list|(
name|m
argument_list|,
operator|&
name|exthdrs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
goto|goto
name|freehdrs
goto|;
block|}
name|m
operator|=
name|exthdrs
operator|.
name|ip6e_ip6
expr_stmt|;
name|hdrsplit
operator|++
expr_stmt|;
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
comment|/* adjust mbuf packet header length */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|optlen
expr_stmt|;
name|plen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
expr_stmt|;
comment|/* If this is a jumbo payload, insert a jumbo payload option. */
if|if
condition|(
name|plen
operator|>
name|IPV6_MAXPACKET
condition|)
block|{
if|if
condition|(
operator|!
name|hdrsplit
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|ip6_splithdr
argument_list|(
name|m
argument_list|,
operator|&
name|exthdrs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
goto|goto
name|freehdrs
goto|;
block|}
name|m
operator|=
name|exthdrs
operator|.
name|ip6e_ip6
expr_stmt|;
name|hdrsplit
operator|++
expr_stmt|;
block|}
comment|/* adjust pointer */
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ip6_insert_jumboopt
argument_list|(
operator|&
name|exthdrs
argument_list|,
name|plen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|freehdrs
goto|;
name|ip6
operator|->
name|ip6_plen
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ip6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
comment|/* 	 * Concatenate headers and fill in next header fields. 	 * Here we have, on "m" 	 *	IPv6 payload 	 * and we insert headers accordingly.  Finally, we should be getting: 	 *	IPv6 hbh dest1 rthdr ah* [esp* dest2 payload] 	 * 	 * during the header composing process, "m" points to IPv6 header. 	 * "mprev" points to an extension header prior to esp. 	 */
name|u_char
modifier|*
name|nexthdrp
init|=
operator|&
name|ip6
operator|->
name|ip6_nxt
decl_stmt|;
name|mprev
operator|=
name|m
expr_stmt|;
comment|/* 	 * we treat dest2 specially.  this makes IPsec processing 	 * much easier.  the goal here is to make mprev point the 	 * mbuf prior to dest2. 	 * 	 * result: IPv6 dest2 payload 	 * m and mprev will point to IPv6 header. 	 */
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_dest2
condition|)
block|{
if|if
condition|(
operator|!
name|hdrsplit
condition|)
name|panic
argument_list|(
literal|"assumption failed: hdr not split"
argument_list|)
expr_stmt|;
name|exthdrs
operator|.
name|ip6e_dest2
operator|->
name|m_next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|exthdrs
operator|.
name|ip6e_dest2
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_dest2
argument_list|,
name|u_char
operator|*
argument_list|)
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|ip6
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_DSTOPTS
expr_stmt|;
block|}
comment|/* 	 * result: IPv6 hbh dest1 rthdr dest2 payload 	 * m will point to IPv6 header.  mprev will point to the 	 * extension header prior to dest2 (rthdr in the above case). 	 */
name|MAKE_CHAIN
argument_list|(
name|exthdrs
operator|.
name|ip6e_hbh
argument_list|,
name|mprev
argument_list|,
name|nexthdrp
argument_list|,
name|IPPROTO_HOPOPTS
argument_list|)
expr_stmt|;
name|MAKE_CHAIN
argument_list|(
name|exthdrs
operator|.
name|ip6e_dest1
argument_list|,
name|mprev
argument_list|,
name|nexthdrp
argument_list|,
name|IPPROTO_DSTOPTS
argument_list|)
expr_stmt|;
name|MAKE_CHAIN
argument_list|(
name|exthdrs
operator|.
name|ip6e_rthdr
argument_list|,
name|mprev
argument_list|,
name|nexthdrp
argument_list|,
name|IPPROTO_ROUTING
argument_list|)
expr_stmt|;
comment|/* 	 * If there is a routing header, discard the packet. 	 */
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_rthdr
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Source address validation */
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|IPV6_UNSPECSRC
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
name|IP6STAT_INC
argument_list|(
name|ip6s_badscope
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
name|IP6STAT_INC
argument_list|(
name|ip6s_badscope
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|IP6STAT_INC
argument_list|(
name|ip6s_localout
argument_list|)
expr_stmt|;
comment|/* 	 * Route packet. 	 */
if|if
condition|(
name|ro
operator|==
name|NULL
condition|)
block|{
name|ro
operator|=
operator|&
name|ip6route
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ro
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ro
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ro_pmtu
operator|=
name|ro
expr_stmt|;
if|if
condition|(
name|opt
operator|&&
name|opt
operator|->
name|ip6po_rthdr
condition|)
name|ro
operator|=
operator|&
name|opt
operator|->
name|ip6po_route
expr_stmt|;
name|dst
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOWTABLE
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|flowtable_lookup
argument_list|(
name|AF_INET6
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|route
operator|*
operator|)
name|ro
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fibnum
operator|=
operator|(
name|inp
operator|!=
name|NULL
operator|)
condition|?
name|inp
operator|->
name|inp_inc
operator|.
name|inc_fibnum
else|:
name|M_GETFIB
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|again
label|:
comment|/* 	 * if specified, try to fill in the traffic class field. 	 * do not override if a non-zero value is already set. 	 * we check the diffserv field and the ecn field separately. 	 */
if|if
condition|(
name|opt
operator|&&
name|opt
operator|->
name|ip6po_tclass
operator|>=
literal|0
condition|)
block|{
name|int
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|ip6
operator|->
name|ip6_flow
operator|&
name|htonl
argument_list|(
literal|0xfc
operator|<<
literal|20
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|mask
operator||=
literal|0xfc
expr_stmt|;
if|if
condition|(
operator|(
name|ip6
operator|->
name|ip6_flow
operator|&
name|htonl
argument_list|(
literal|0x03
operator|<<
literal|20
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|mask
operator||=
literal|0x03
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
name|ip6
operator|->
name|ip6_flow
operator||=
name|htonl
argument_list|(
operator|(
name|opt
operator|->
name|ip6po_tclass
operator|&
name|mask
operator|)
operator|<<
literal|20
argument_list|)
expr_stmt|;
block|}
comment|/* fill in or override the hop limit field, if necessary. */
if|if
condition|(
name|opt
operator|&&
name|opt
operator|->
name|ip6po_hlim
operator|!=
operator|-
literal|1
condition|)
name|ip6
operator|->
name|ip6_hlim
operator|=
name|opt
operator|->
name|ip6po_hlim
operator|&
literal|0xff
expr_stmt|;
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
if|if
condition|(
name|im6o
operator|!=
name|NULL
condition|)
name|ip6
operator|->
name|ip6_hlim
operator|=
name|im6o
operator|->
name|im6o_multicast_hlim
expr_stmt|;
else|else
name|ip6
operator|->
name|ip6_hlim
operator|=
name|V_ip6_defmcasthlim
expr_stmt|;
block|}
comment|/* 	 * Validate route against routing table additions; 	 * a better/more specific route might have been added. 	 * Make sure address family is set in route. 	 */
if|if
condition|(
name|inp
condition|)
block|{
name|ro
operator|->
name|ro_dst
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|RT_VALIDATE
argument_list|(
operator|(
expr|struct
name|route
operator|*
operator|)
name|ro
argument_list|,
operator|&
name|inp
operator|->
name|inp_rt_cookie
argument_list|,
name|fibnum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|&&
name|fwd_tag
operator|==
name|NULL
operator|&&
operator|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|&&
name|ro
operator|->
name|ro_dst
operator|.
name|sin6_family
operator|==
name|AF_INET6
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ro
operator|->
name|ro_dst
operator|.
name|sin6_addr
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|rt
operator|=
name|ro
operator|->
name|ro_rt
expr_stmt|;
name|ifp
operator|=
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ro
operator|->
name|ro_lle
condition|)
name|LLE_FREE
argument_list|(
name|ro
operator|->
name|ro_lle
argument_list|)
expr_stmt|;
comment|/* zeros ro_lle */
name|ro
operator|->
name|ro_lle
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fwd_tag
operator|==
name|NULL
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|dst_sa
argument_list|,
sizeof|sizeof
argument_list|(
name|dst_sa
argument_list|)
argument_list|)
expr_stmt|;
name|dst_sa
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|dst_sa
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|dst_sa
argument_list|)
expr_stmt|;
name|dst_sa
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
block|}
name|error
operator|=
name|in6_selectroute_fib
argument_list|(
operator|&
name|dst_sa
argument_list|,
name|opt
argument_list|,
name|im6o
argument_list|,
name|ro
argument_list|,
operator|&
name|ifp
argument_list|,
operator|&
name|rt
argument_list|,
name|fibnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_discard
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If in6_selectroute() does not return a route entry, 		 * dst may not have been updated. 		 */
operator|*
name|dst
operator|=
name|dst_sa
expr_stmt|;
comment|/* XXX */
block|}
comment|/* 	 * then rt (for unicast) and ifp must be non-NULL valid values. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|IPV6_FORWARDING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX: the FORWARDING flag can be set for mrouting. */
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_request
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
name|ia
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
operator|(
name|rt
operator|->
name|rt_ifa
operator|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|rt
operator|->
name|rt_pksent
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The outgoing interface must be in the zone of source and 	 * destination addresses. 	 */
name|origifp
operator|=
name|ifp
expr_stmt|;
name|src0
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
if|if
condition|(
name|in6_setscope
argument_list|(
operator|&
name|src0
argument_list|,
name|origifp
argument_list|,
operator|&
name|zone
argument_list|)
condition|)
goto|goto
name|badscope
goto|;
name|bzero
argument_list|(
operator|&
name|src_sa
argument_list|,
sizeof|sizeof
argument_list|(
name|src_sa
argument_list|)
argument_list|)
expr_stmt|;
name|src_sa
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|src_sa
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|src_sa
argument_list|)
expr_stmt|;
name|src_sa
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
if|if
condition|(
name|sa6_recoverscope
argument_list|(
operator|&
name|src_sa
argument_list|)
operator|||
name|zone
operator|!=
name|src_sa
operator|.
name|sin6_scope_id
condition|)
goto|goto
name|badscope
goto|;
name|dst0
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
if|if
condition|(
name|in6_setscope
argument_list|(
operator|&
name|dst0
argument_list|,
name|origifp
argument_list|,
operator|&
name|zone
argument_list|)
condition|)
goto|goto
name|badscope
goto|;
comment|/* re-initialize to be sure */
name|bzero
argument_list|(
operator|&
name|dst_sa
argument_list|,
sizeof|sizeof
argument_list|(
name|dst_sa
argument_list|)
argument_list|)
expr_stmt|;
name|dst_sa
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|dst_sa
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|dst_sa
argument_list|)
expr_stmt|;
name|dst_sa
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
if|if
condition|(
name|sa6_recoverscope
argument_list|(
operator|&
name|dst_sa
argument_list|)
operator|||
name|zone
operator|!=
name|dst_sa
operator|.
name|sin6_scope_id
condition|)
block|{
goto|goto
name|badscope
goto|;
block|}
comment|/* We should use ia_ifp to support the case of 	 * sending packets to an address of our own. 	 */
if|if
condition|(
name|ia
operator|!=
name|NULL
operator|&&
name|ia
operator|->
name|ia_ifp
condition|)
name|ifp
operator|=
name|ia
operator|->
name|ia_ifp
expr_stmt|;
comment|/* scope check is done. */
goto|goto
name|routefound
goto|;
name|badscope
label|:
name|IP6STAT_INC
argument_list|(
name|ip6s_badscope
argument_list|)
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|origifp
argument_list|,
name|ifs6_out_discard
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|EHOSTUNREACH
expr_stmt|;
comment|/* XXX */
goto|goto
name|bad
goto|;
name|routefound
label|:
if|if
condition|(
name|rt
operator|&&
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
if|if
condition|(
name|opt
operator|&&
name|opt
operator|->
name|ip6po_nextroute
operator|.
name|ro_rt
condition|)
block|{
comment|/* 			 * The nexthop is explicitly specified by the 			 * application.  We assume the next hop is an IPv6 			 * address. 			 */
name|dst
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|opt
operator|->
name|ip6po_nexthop
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
operator|)
condition|)
name|dst
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|m
operator|->
name|m_flags
operator|&=
operator|~
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
expr_stmt|;
comment|/* just in case */
block|}
else|else
block|{
name|m
operator|->
name|m_flags
operator|=
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|~
name|M_BCAST
operator|)
operator||
name|M_MCAST
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_mcast
argument_list|)
expr_stmt|;
comment|/* 		 * Confirm that the outgoing interface supports multicast. 		 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
condition|)
block|{
name|IP6STAT_INC
argument_list|(
name|ip6s_noroute
argument_list|)
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_discard
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENETUNREACH
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|im6o
operator|==
name|NULL
operator|&&
name|in6_mcast_loop
operator|)
operator|||
operator|(
name|im6o
operator|&&
name|im6o
operator|->
name|im6o_multicast_loop
operator|)
condition|)
block|{
comment|/* 			 * Loop back multicast datagram if not expressly 			 * forbidden to do so, even if we have not joined 			 * the address; protocols will filter it later, 			 * thus deferring a hash lookup and lock acquisition 			 * at the expense of an m_copym(). 			 */
name|ip6_mloopback
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If we are acting as a multicast router, perform 			 * multicast forwarding as if the packet had just 			 * arrived on the interface to which we are about 			 * to send.  The multicast forwarding function 			 * recursively calls this function, using the 			 * IPV6_FORWARDING flag to prevent infinite recursion. 			 * 			 * Multicasts that are looped back by ip6_mloopback(), 			 * above, will be forwarded by the ip6_input() routine, 			 * if necessary. 			 */
if|if
condition|(
name|V_ip6_mrouter
operator|&&
operator|(
name|flags
operator|&
name|IPV6_FORWARDING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * XXX: ip6_mforward expects that rcvif is NULL 				 * when it is called from the originating path. 				 * However, it may not always be the case. 				 */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ip6_mforward
argument_list|(
name|ip6
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
comment|/* 		 * Multicasts with a hoplimit of zero may be looped back, 		 * above, but must not be transmitted on a network. 		 * Also, multicasts addressed to the loopback interface 		 * are not sent -- the above call to ip6_mloopback() will 		 * loop back a copy if this host actually belongs to the 		 * destination group on the loopback interface. 		 */
if|if
condition|(
name|ip6
operator|->
name|ip6_hlim
operator|==
literal|0
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|||
name|IN6_IS_ADDR_MC_INTFACELOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 	 * Fill the outgoing inteface to tell the upper layer 	 * to increment per-interface statistics. 	 */
if|if
condition|(
name|ifpp
condition|)
operator|*
name|ifpp
operator|=
name|ifp
expr_stmt|;
comment|/* Determine path MTU. */
if|if
condition|(
operator|(
name|error
operator|=
name|ip6_getpmtu
argument_list|(
name|ro_pmtu
argument_list|,
name|ro
operator|!=
name|ro_pmtu
argument_list|,
name|ifp
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
operator|&
name|mtu
argument_list|,
operator|&
name|alwaysfrag
argument_list|,
name|fibnum
argument_list|,
operator|*
name|nexthdrp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * The caller of this function may specify to use the minimum MTU 	 * in some cases. 	 * An advanced API option (IPV6_USE_MIN_MTU) can also override MTU 	 * setting.  The logic is a bit complicated; by default, unicast 	 * packets will follow path MTU while multicast packets will be sent at 	 * the minimum MTU.  If IP6PO_MINMTU_ALL is specified, all packets 	 * including unicast ones will be sent at the minimum MTU.  Multicast 	 * packets will always be sent at the minimum MTU unless 	 * IP6PO_MINMTU_DISABLE is explicitly specified. 	 * See RFC 3542 for more details. 	 */
if|if
condition|(
name|mtu
operator|>
name|IPV6_MMTU
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|IPV6_MINMTU
operator|)
condition|)
name|mtu
operator|=
name|IPV6_MMTU
expr_stmt|;
elseif|else
if|if
condition|(
name|opt
operator|&&
name|opt
operator|->
name|ip6po_minmtu
operator|==
name|IP6PO_MINMTU_ALL
condition|)
name|mtu
operator|=
name|IPV6_MMTU
expr_stmt|;
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|&&
operator|(
name|opt
operator|==
name|NULL
operator|||
name|opt
operator|->
name|ip6po_minmtu
operator|!=
name|IP6PO_MINMTU_DISABLE
operator|)
condition|)
block|{
name|mtu
operator|=
name|IPV6_MMTU
expr_stmt|;
block|}
block|}
comment|/* 	 * clear embedded scope identifiers if necessary. 	 * in6_clearscope will touch the addresses only when necessary. 	 */
name|in6_clearscope
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
expr_stmt|;
comment|/* 	 * If the outgoing packet contains a hop-by-hop options header, 	 * it must be examined and processed even by the source node. 	 * (RFC 2460, section 4.) 	 */
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_hbh
condition|)
block|{
name|struct
name|ip6_hbh
modifier|*
name|hbh
init|=
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_hbh
argument_list|,
expr|struct
name|ip6_hbh
operator|*
argument_list|)
decl_stmt|;
name|u_int32_t
name|dummy
decl_stmt|;
comment|/* XXX unused */
name|u_int32_t
name|plen
init|=
literal|0
decl_stmt|;
comment|/* XXX: ip6_process will check the value */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
operator|>
name|exthdrs
operator|.
name|ip6e_hbh
operator|->
name|m_len
condition|)
name|panic
argument_list|(
literal|"ip6e_hbh is not contiguous"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 *  XXX: if we have to send an ICMPv6 error to the sender, 		 *       we need the M_LOOP flag since icmp6_error() expects 		 *       the IPv6 and the hop-by-hop options header are 		 *       contiguous unless the flag is set. 		 */
name|m
operator|->
name|m_flags
operator||=
name|M_LOOP
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|ip6_process_hopopts
argument_list|(
name|m
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|hbh
operator|+
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|plen
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* m was already freed at this point */
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* better error? */
goto|goto
name|done
goto|;
block|}
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_LOOP
expr_stmt|;
comment|/* XXX */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Jump over all PFIL processing if hooks are not active. */
if|if
condition|(
operator|!
name|PFIL_HOOKED
argument_list|(
operator|&
name|V_inet6_pfil_hook
argument_list|)
condition|)
goto|goto
name|passout
goto|;
name|odst
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
comment|/* Run through list of hooks for output packets. */
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|V_inet6_pfil_hook
argument_list|,
operator|&
name|m
argument_list|,
name|ifp
argument_list|,
name|PFIL_OUT
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|m
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
comment|/* adjust pointer */
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|needfiblookup
operator|=
literal|0
expr_stmt|;
comment|/* See if destination IP address was changed by packet filter. */
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|odst
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|m
operator|->
name|m_flags
operator||=
name|M_SKIP_FIREWALL
expr_stmt|;
comment|/* If destination is now ourself drop to ip6_input(). */
if|if
condition|(
name|in6_localip
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|m
operator|->
name|m_flags
operator||=
name|M_FASTFWD_OURS
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
name|NULL
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|V_loif
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA_IPV6
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID_IPV6
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_SCTP_IPV6
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_SCTP_VALID
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|netisr_queue
argument_list|(
name|NETISR_IPV6
argument_list|,
name|m
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|RO_RTFREE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|needfiblookup
operator|=
literal|1
expr_stmt|;
comment|/* Redo the routing table lookup. */
if|if
condition|(
name|ro
operator|->
name|ro_lle
condition|)
name|LLE_FREE
argument_list|(
name|ro
operator|->
name|ro_lle
argument_list|)
expr_stmt|;
comment|/* zeros ro_lle */
name|ro
operator|->
name|ro_lle
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* See if fib was changed by packet filter. */
if|if
condition|(
name|fibnum
operator|!=
name|M_GETFIB
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|m
operator|->
name|m_flags
operator||=
name|M_SKIP_FIREWALL
expr_stmt|;
name|fibnum
operator|=
name|M_GETFIB
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|RO_RTFREE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|needfiblookup
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ro
operator|->
name|ro_lle
condition|)
name|LLE_FREE
argument_list|(
name|ro
operator|->
name|ro_lle
argument_list|)
expr_stmt|;
comment|/* zeros ro_lle */
name|ro
operator|->
name|ro_lle
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|needfiblookup
condition|)
goto|goto
name|again
goto|;
comment|/* See if local, if yes, send it to netisr. */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_FASTFWD_OURS
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
name|NULL
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|V_loif
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA_IPV6
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID_IPV6
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_SCTP_IPV6
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_SCTP_VALID
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|netisr_queue
argument_list|(
name|NETISR_IPV6
argument_list|,
name|m
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Or forward to some other address? */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_IP6_NEXTHOP
operator|)
operator|&&
operator|(
name|fwd_tag
operator|=
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_IPFORWARD
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dst
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|fwd_tag
operator|+
literal|1
operator|)
argument_list|,
operator|&
name|dst_sa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_SKIP_FIREWALL
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_IP6_NEXTHOP
expr_stmt|;
name|m_tag_delete
argument_list|(
name|m
argument_list|,
name|fwd_tag
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|passout
label|:
comment|/* 	 * Send the packet to the outgoing interface. 	 * If necessary, do IPv6 fragmentation before sending. 	 * 	 * the logic here is rather complex: 	 * 1: normal case (dontfrag == 0, alwaysfrag == 0) 	 * 1-a:	send as is if tlen<= path mtu 	 * 1-b:	fragment if tlen> path mtu 	 * 	 * 2: if user asks us not to fragment (dontfrag == 1) 	 * 2-a:	send as is if tlen<= interface mtu 	 * 2-b:	error if tlen> interface mtu 	 * 	 * 3: if we always need to attach fragment header (alwaysfrag == 1) 	 *	always fragment 	 * 	 * 4: if dontfrag == 1&& alwaysfrag == 1 	 *	error, as we cannot handle this conflicting request 	 */
name|sw_csum
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
expr_stmt|;
if|if
condition|(
operator|!
name|hdrsplit
condition|)
block|{
name|tso
operator|=
operator|(
operator|(
name|sw_csum
operator|&
name|ifp
operator|->
name|if_hwassist
operator|&
name|CSUM_TSO
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|sw_csum
operator|&=
operator|~
name|ifp
operator|->
name|if_hwassist
expr_stmt|;
block|}
else|else
name|tso
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we added extension headers, we will not do TSO and calculate the 	 * checksums ourselves for now. 	 * XXX-BZ  Need a framework to know when the NIC can handle it, even 	 * with ext. hdrs. 	 */
if|if
condition|(
name|sw_csum
operator|&
name|CSUM_DELAY_DATA_IPV6
condition|)
block|{
name|sw_csum
operator|&=
operator|~
name|CSUM_DELAY_DATA_IPV6
expr_stmt|;
name|in6_delayed_cksum
argument_list|(
name|m
argument_list|,
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP
if|if
condition|(
name|sw_csum
operator|&
name|CSUM_SCTP_IPV6
condition|)
block|{
name|sw_csum
operator|&=
operator|~
name|CSUM_SCTP_IPV6
expr_stmt|;
name|sctp_delayed_cksum
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
name|ifp
operator|->
name|if_hwassist
expr_stmt|;
name|tlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|opt
operator|&&
operator|(
name|opt
operator|->
name|ip6po_flags
operator|&
name|IP6PO_DONTFRAG
operator|)
operator|)
operator|||
name|tso
condition|)
name|dontfrag
operator|=
literal|1
expr_stmt|;
else|else
name|dontfrag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dontfrag
operator|&&
name|alwaysfrag
condition|)
block|{
comment|/* case 4 */
comment|/* conflicting request - can't transmit */
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|dontfrag
operator|&&
name|tlen
operator|>
name|IN6_LINKMTU
argument_list|(
name|ifp
argument_list|)
operator|&&
operator|!
name|tso
condition|)
block|{
comment|/* case 2-b */
comment|/* 		 * Even if the DONTFRAG option is specified, we cannot send the 		 * packet when the data length is larger than the MTU of the 		 * outgoing interface. 		 * Notify the error by sending IPV6_PATHMTU ancillary data if 		 * application wanted to know the MTU value. Also return an 		 * error code (this is not described in the API spec). 		 */
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
name|ip6_notify_pmtu
argument_list|(
name|inp
argument_list|,
operator|&
name|dst_sa
argument_list|,
operator|(
name|u_int32_t
operator|)
name|mtu
argument_list|)
expr_stmt|;
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * transmit packet without fragmentation 	 */
if|if
condition|(
name|dontfrag
operator|||
operator|(
operator|!
name|alwaysfrag
operator|&&
name|tlen
operator|<=
name|mtu
operator|)
condition|)
block|{
comment|/* case 1-a and 2-a */
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|ia6
operator|=
name|in6_ifawithifp
argument_list|(
name|ifp
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia6
condition|)
block|{
comment|/* Record statistics for this interface address. */
name|counter_u64_add
argument_list|(
name|ia6
operator|->
name|ia_ifa
operator|.
name|ifa_opackets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|ia6
operator|->
name|ia_ifa
operator|.
name|ifa_obytes
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|ifa_free
argument_list|(
operator|&
name|ia6
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nd6_output_ifp
argument_list|(
name|ifp
argument_list|,
name|origifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
operator|(
expr|struct
name|route
operator|*
operator|)
name|ro
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * try to fragment the packet.  case 1-b and 3 	 */
if|if
condition|(
name|mtu
operator|<
name|IPV6_MMTU
condition|)
block|{
comment|/* path MTU cannot be less than IPV6_MMTU */
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_fragfail
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
elseif|else
if|if
condition|(
name|ip6
operator|->
name|ip6_plen
operator|==
literal|0
condition|)
block|{
comment|/* jumbo payload cannot be fragmented */
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_fragfail
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
else|else
block|{
name|u_char
name|nextproto
decl_stmt|;
comment|/* 		 * Too large for the destination or interface; 		 * fragment if possible. 		 * Must be able to put at least 8 bytes per fragment. 		 */
name|hlen
operator|=
name|unfragpartlen
expr_stmt|;
if|if
condition|(
name|mtu
operator|>
name|IPV6_MAXPACKET
condition|)
name|mtu
operator|=
name|IPV6_MAXPACKET
expr_stmt|;
name|len
operator|=
operator|(
name|mtu
operator|-
name|hlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|8
condition|)
block|{
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_fragfail
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * If the interface will not calculate checksums on 		 * fragmented packets, then do it here. 		 * XXX-BZ handle the hw offloading case.  Need flags. 		 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA_IPV6
condition|)
block|{
name|in6_delayed_cksum
argument_list|(
name|m
argument_list|,
name|plen
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_DELAY_DATA_IPV6
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_SCTP_IPV6
condition|)
block|{
name|sctp_delayed_cksum
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_SCTP_IPV6
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * Change the next header field of the last header in the 		 * unfragmentable part. 		 */
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_rthdr
condition|)
block|{
name|nextproto
operator|=
operator|*
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_rthdr
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_rthdr
argument_list|,
name|u_char
operator|*
argument_list|)
operator|=
name|IPPROTO_FRAGMENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_dest1
condition|)
block|{
name|nextproto
operator|=
operator|*
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_dest1
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_dest1
argument_list|,
name|u_char
operator|*
argument_list|)
operator|=
name|IPPROTO_FRAGMENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_hbh
condition|)
block|{
name|nextproto
operator|=
operator|*
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_hbh
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_hbh
argument_list|,
name|u_char
operator|*
argument_list|)
operator|=
name|IPPROTO_FRAGMENT
expr_stmt|;
block|}
else|else
block|{
name|nextproto
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|ip6
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_FRAGMENT
expr_stmt|;
block|}
comment|/* 		 * Loop through length of segment after first fragment, 		 * make new header and copy data of each part and link onto 		 * chain. 		 */
name|m0
operator|=
name|m
expr_stmt|;
name|id
operator|=
name|htonl
argument_list|(
name|ip6_randomid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ip6_fragment
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|hlen
argument_list|,
name|nextproto
argument_list|,
name|len
argument_list|,
name|id
argument_list|)
operator|)
condition|)
goto|goto
name|sendorfree
goto|;
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_fragok
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Remove leading garbages. 	 */
name|sendorfree
label|:
name|m
operator|=
name|m0
operator|->
name|m_nextpkt
expr_stmt|;
name|m0
operator|->
name|m_nextpkt
operator|=
literal|0
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
for|for
control|(
name|m0
operator|=
name|m
init|;
name|m
condition|;
name|m
operator|=
name|m0
control|)
block|{
name|m0
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* Record statistics for this interface address. */
if|if
condition|(
name|ia
condition|)
block|{
name|counter_u64_add
argument_list|(
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_opackets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_obytes
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nd6_output_ifp
argument_list|(
name|ifp
argument_list|,
name|origifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
operator|(
expr|struct
name|route
operator|*
operator|)
name|ro
argument_list|)
expr_stmt|;
block|}
else|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|IP6STAT_INC
argument_list|(
name|ip6s_fragmented
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* 	 * Release the route if using our private route, or if 	 * (with flowtable) we don't have our own reference. 	 */
if|if
condition|(
name|ro
operator|==
operator|&
name|ip6route
operator|||
operator|(
name|ro
operator|!=
name|NULL
operator|&&
name|ro
operator|->
name|ro_flags
operator|&
name|RT_NORTREF
operator|)
condition|)
name|RO_RTFREE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|freehdrs
label|:
name|m_freem
argument_list|(
name|exthdrs
operator|.
name|ip6e_hbh
argument_list|)
expr_stmt|;
comment|/* m_freem will check if mbuf is 0 */
name|m_freem
argument_list|(
name|exthdrs
operator|.
name|ip6e_dest1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|exthdrs
operator|.
name|ip6e_rthdr
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|exthdrs
operator|.
name|ip6e_dest2
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
name|bad
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
end_function

begin_function
specifier|static
name|int
name|ip6_copyexthdr
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|caddr_t
name|hdr
parameter_list|,
name|int
name|hlen
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|hlen
operator|>
name|MCLBYTES
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* XXX */
if|if
condition|(
name|hlen
operator|>
name|MLEN
condition|)
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|m_get
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m
operator|->
name|m_len
operator|=
name|hlen
expr_stmt|;
if|if
condition|(
name|hdr
condition|)
name|bcopy
argument_list|(
name|hdr
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert jumbo payload option.  */
end_comment

begin_function
specifier|static
name|int
name|ip6_insert_jumboopt
parameter_list|(
name|struct
name|ip6_exthdrs
modifier|*
name|exthdrs
parameter_list|,
name|u_int32_t
name|plen
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mopt
decl_stmt|;
name|u_char
modifier|*
name|optbuf
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
define|#
directive|define
name|JUMBOOPTLEN
value|8
comment|/* length of jumbo payload option and padding */
comment|/* 	 * If there is no hop-by-hop options header, allocate new one. 	 * If there is one but it doesn't have enough space to store the 	 * jumbo payload option, allocate a cluster to store the whole options. 	 * Otherwise, use it to store the options. 	 */
if|if
condition|(
name|exthdrs
operator|->
name|ip6e_hbh
operator|==
name|NULL
condition|)
block|{
name|mopt
operator|=
name|m_get
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mopt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|mopt
operator|->
name|m_len
operator|=
name|JUMBOOPTLEN
expr_stmt|;
name|optbuf
operator|=
name|mtod
argument_list|(
name|mopt
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|optbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* = ((JUMBOOPTLEN)>> 3) - 1 */
name|exthdrs
operator|->
name|ip6e_hbh
operator|=
name|mopt
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ip6_hbh
modifier|*
name|hbh
decl_stmt|;
name|mopt
operator|=
name|exthdrs
operator|->
name|ip6e_hbh
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|mopt
argument_list|)
operator|<
name|JUMBOOPTLEN
condition|)
block|{
comment|/* 			 * XXX assumption: 			 * - exthdrs->ip6e_hbh is not referenced from places 			 *   other than exthdrs. 			 * - exthdrs->ip6e_hbh is not an mbuf chain. 			 */
name|int
name|oldoptlen
init|=
name|mopt
operator|->
name|m_len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* 			 * XXX: give up if the whole (new) hbh header does 			 * not fit even in an mbuf cluster. 			 */
if|if
condition|(
name|oldoptlen
operator|+
name|JUMBOOPTLEN
operator|>
name|MCLBYTES
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* 			 * As a consequence, we must always prepare a cluster 			 * at this point. 			 */
name|n
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|n
operator|->
name|m_len
operator|=
name|oldoptlen
operator|+
name|JUMBOOPTLEN
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|mopt
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|oldoptlen
argument_list|)
expr_stmt|;
name|optbuf
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|oldoptlen
expr_stmt|;
name|m_freem
argument_list|(
name|mopt
argument_list|)
expr_stmt|;
name|mopt
operator|=
name|exthdrs
operator|->
name|ip6e_hbh
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|optbuf
operator|=
name|mtod
argument_list|(
name|mopt
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|mopt
operator|->
name|m_len
expr_stmt|;
name|mopt
operator|->
name|m_len
operator|+=
name|JUMBOOPTLEN
expr_stmt|;
block|}
name|optbuf
index|[
literal|0
index|]
operator|=
name|IP6OPT_PADN
expr_stmt|;
name|optbuf
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Adjust the header length according to the pad and 		 * the jumbo payload option. 		 */
name|hbh
operator|=
name|mtod
argument_list|(
name|mopt
argument_list|,
expr|struct
name|ip6_hbh
operator|*
argument_list|)
expr_stmt|;
name|hbh
operator|->
name|ip6h_len
operator|+=
operator|(
name|JUMBOOPTLEN
operator|>>
literal|3
operator|)
expr_stmt|;
block|}
comment|/* fill in the option. */
name|optbuf
index|[
literal|2
index|]
operator|=
name|IP6OPT_JUMBO
expr_stmt|;
name|optbuf
index|[
literal|3
index|]
operator|=
literal|4
expr_stmt|;
name|v
operator|=
operator|(
name|u_int32_t
operator|)
name|htonl
argument_list|(
name|plen
operator|+
name|JUMBOOPTLEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|optbuf
index|[
literal|4
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* finally, adjust the packet header length */
name|exthdrs
operator|->
name|ip6e_ip6
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|JUMBOOPTLEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|JUMBOOPTLEN
block|}
end_function

begin_comment
comment|/*  * Insert fragment header and copy unfragmentable header portions.  */
end_comment

begin_function
specifier|static
name|int
name|ip6_insertfraghdr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|hlen
parameter_list|,
name|struct
name|ip6_frag
modifier|*
modifier|*
name|frghdrp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|,
modifier|*
name|mlast
decl_stmt|;
if|if
condition|(
name|hlen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_copym
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|hlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m
operator|->
name|m_next
operator|=
name|n
expr_stmt|;
block|}
else|else
name|n
operator|=
name|m
expr_stmt|;
comment|/* Search for the last mbuf of unfragmentable part. */
for|for
control|(
name|mlast
operator|=
name|n
init|;
name|mlast
operator|->
name|m_next
condition|;
name|mlast
operator|=
name|mlast
operator|->
name|m_next
control|)
empty_stmt|;
if|if
condition|(
name|M_WRITABLE
argument_list|(
name|mlast
argument_list|)
operator|&&
name|M_TRAILINGSPACE
argument_list|(
name|mlast
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
condition|)
block|{
comment|/* use the trailing space of the last mbuf for the fragment hdr */
operator|*
name|frghdrp
operator|=
operator|(
expr|struct
name|ip6_frag
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|mlast
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mlast
operator|->
name|m_len
operator|)
expr_stmt|;
name|mlast
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* allocate a new mbuf for the fragment header */
name|struct
name|mbuf
modifier|*
name|mfrg
decl_stmt|;
name|mfrg
operator|=
name|m_get
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfrg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|mfrg
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
operator|*
name|frghdrp
operator|=
name|mtod
argument_list|(
name|mfrg
argument_list|,
expr|struct
name|ip6_frag
operator|*
argument_list|)
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|mfrg
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculates IPv6 path mtu for destination @dst.  * Resulting MTU is stored in @mtup.  *  * Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|ip6_getpmtu_ctl
parameter_list|(
name|u_int
name|fibnum
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
name|dst
parameter_list|,
name|u_long
modifier|*
name|mtup
parameter_list|)
block|{
name|struct
name|nhop6_extended
name|nh6
decl_stmt|;
name|struct
name|in6_addr
name|kdst
decl_stmt|;
name|uint32_t
name|scopeid
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|mtu
decl_stmt|;
name|int
name|error
decl_stmt|;
name|in6_splitscope
argument_list|(
name|dst
argument_list|,
operator|&
name|kdst
argument_list|,
operator|&
name|scopeid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fib6_lookup_nh_ext
argument_list|(
name|fibnum
argument_list|,
operator|&
name|kdst
argument_list|,
name|scopeid
argument_list|,
name|NHR_REF
argument_list|,
literal|0
argument_list|,
operator|&
name|nh6
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
name|ifp
operator|=
name|nh6
operator|.
name|nh_ifp
expr_stmt|;
name|mtu
operator|=
name|nh6
operator|.
name|nh_mtu
expr_stmt|;
name|error
operator|=
name|ip6_calcmtu
argument_list|(
name|ifp
argument_list|,
name|dst
argument_list|,
name|mtu
argument_list|,
name|mtup
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fib6_free_nh_ext
argument_list|(
name|fibnum
argument_list|,
operator|&
name|nh6
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculates IPv6 path MTU for @dst based on transmit @ifp,  * and cached data in @ro_pmtu.  * MTU from (successful) route lookup is saved (along with dst)  * inside @ro_pmtu to avoid subsequent route lookups after packet  * filter processing.  *  * Stores mtu and always-frag value into @mtup and @alwaysfragp.  * Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|ip6_getpmtu
parameter_list|(
name|struct
name|route_in6
modifier|*
name|ro_pmtu
parameter_list|,
name|int
name|do_lookup
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
name|dst
parameter_list|,
name|u_long
modifier|*
name|mtup
parameter_list|,
name|int
modifier|*
name|alwaysfragp
parameter_list|,
name|u_int
name|fibnum
parameter_list|,
name|u_int
name|proto
parameter_list|)
block|{
name|struct
name|nhop6_basic
name|nh6
decl_stmt|;
name|struct
name|in6_addr
name|kdst
decl_stmt|;
name|uint32_t
name|scopeid
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sa6_dst
decl_stmt|;
name|u_long
name|mtu
decl_stmt|;
name|mtu
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|do_lookup
condition|)
block|{
comment|/* 		 * Here ro_pmtu has final destination address, while 		 * ro might represent immediate destination. 		 * Use ro_pmtu destination since mtu might differ. 		 */
name|sa6_dst
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro_pmtu
operator|->
name|ro_dst
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|sa6_dst
operator|->
name|sin6_addr
argument_list|,
name|dst
argument_list|)
condition|)
name|ro_pmtu
operator|->
name|ro_mtu
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ro_pmtu
operator|->
name|ro_mtu
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|sa6_dst
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa6_dst
argument_list|)
argument_list|)
expr_stmt|;
name|sa6_dst
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sa6_dst
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sa6_dst
operator|->
name|sin6_addr
operator|=
operator|*
name|dst
expr_stmt|;
name|in6_splitscope
argument_list|(
name|dst
argument_list|,
operator|&
name|kdst
argument_list|,
operator|&
name|scopeid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fib6_lookup_nh_basic
argument_list|(
name|fibnum
argument_list|,
operator|&
name|kdst
argument_list|,
name|scopeid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|nh6
argument_list|)
operator|==
literal|0
condition|)
name|ro_pmtu
operator|->
name|ro_mtu
operator|=
name|nh6
operator|.
name|nh_mtu
expr_stmt|;
block|}
name|mtu
operator|=
name|ro_pmtu
operator|->
name|ro_mtu
expr_stmt|;
block|}
if|if
condition|(
name|ro_pmtu
operator|->
name|ro_rt
condition|)
name|mtu
operator|=
name|ro_pmtu
operator|->
name|ro_rt
operator|->
name|rt_mtu
expr_stmt|;
return|return
operator|(
name|ip6_calcmtu
argument_list|(
name|ifp
argument_list|,
name|dst
argument_list|,
name|mtu
argument_list|,
name|mtup
argument_list|,
name|alwaysfragp
argument_list|,
name|proto
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate MTU based on transmit @ifp, route mtu @rt_mtu and  * hostcache data for @dst.  * Stores mtu and always-frag value into @mtup and @alwaysfragp.  *  * Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|ip6_calcmtu
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
name|dst
parameter_list|,
name|u_long
name|rt_mtu
parameter_list|,
name|u_long
modifier|*
name|mtup
parameter_list|,
name|int
modifier|*
name|alwaysfragp
parameter_list|,
name|u_int
name|proto
parameter_list|)
block|{
name|u_long
name|mtu
init|=
literal|0
decl_stmt|;
name|int
name|alwaysfrag
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rt_mtu
operator|>
literal|0
condition|)
block|{
name|u_int32_t
name|ifmtu
decl_stmt|;
name|struct
name|in_conninfo
name|inc
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|inc
argument_list|,
sizeof|sizeof
argument_list|(
name|inc
argument_list|)
argument_list|)
expr_stmt|;
name|inc
operator|.
name|inc_flags
operator||=
name|INC_ISIPV6
expr_stmt|;
name|inc
operator|.
name|inc6_faddr
operator|=
operator|*
name|dst
expr_stmt|;
name|ifmtu
operator|=
name|IN6_LINKMTU
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* TCP is known to react to pmtu changes so skip hc */
if|if
condition|(
name|proto
operator|!=
name|IPPROTO_TCP
condition|)
name|mtu
operator|=
name|tcp_hc_getmtu
argument_list|(
operator|&
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu
condition|)
name|mtu
operator|=
name|min
argument_list|(
name|mtu
argument_list|,
name|rt_mtu
argument_list|)
expr_stmt|;
else|else
name|mtu
operator|=
name|rt_mtu
expr_stmt|;
if|if
condition|(
name|mtu
operator|==
literal|0
condition|)
name|mtu
operator|=
name|ifmtu
expr_stmt|;
elseif|else
if|if
condition|(
name|mtu
operator|<
name|IPV6_MMTU
condition|)
block|{
comment|/* 			 * RFC2460 section 5, last paragraph: 			 * if we record ICMPv6 too big message with 			 * mtu< IPV6_MMTU, transmit packets sized IPV6_MMTU 			 * or smaller, with framgent header attached. 			 * (fragment header is needed regardless from the 			 * packet size, for translators to identify packets) 			 */
name|alwaysfrag
operator|=
literal|1
expr_stmt|;
name|mtu
operator|=
name|IPV6_MMTU
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ifp
condition|)
block|{
name|mtu
operator|=
name|IN6_LINKMTU
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EHOSTUNREACH
expr_stmt|;
comment|/* XXX */
operator|*
name|mtup
operator|=
name|mtu
expr_stmt|;
if|if
condition|(
name|alwaysfragp
condition|)
operator|*
name|alwaysfragp
operator|=
name|alwaysfrag
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IP6 socket option processing.  */
end_comment

begin_function
name|int
name|ip6_ctloutput
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|int
name|optdatalen
decl_stmt|,
name|uproto
decl_stmt|;
name|void
modifier|*
name|optdata
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|in6p
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|,
name|optval
decl_stmt|;
name|int
name|level
decl_stmt|,
name|op
decl_stmt|,
name|optname
decl_stmt|;
name|int
name|optlen
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|uint32_t
name|rss_bucket
decl_stmt|;
name|int
name|retval
decl_stmt|;
endif|#
directive|endif
comment|/*  * Don't use more than a quarter of mbuf clusters.  N.B.:  * nmbclusters is an int, but nmbclusters * MCLBYTES may overflow  * on LP64 architectures, so cast to u_long to avoid undefined  * behavior.  ILP32 architectures cannot have nmbclusters  * large enough to overflow for other reasons.  */
define|#
directive|define
name|IPV6_PKTOPTIONS_MBUF_LIMIT
value|((u_long)nmbclusters * MCLBYTES / 4)
name|level
operator|=
name|sopt
operator|->
name|sopt_level
expr_stmt|;
name|op
operator|=
name|sopt
operator|->
name|sopt_dir
expr_stmt|;
name|optname
operator|=
name|sopt
operator|->
name|sopt_name
expr_stmt|;
name|optlen
operator|=
name|sopt
operator|->
name|sopt_valsize
expr_stmt|;
name|td
operator|=
name|sopt
operator|->
name|sopt_td
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|optval
operator|=
literal|0
expr_stmt|;
name|uproto
operator|=
operator|(
name|int
operator|)
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
expr_stmt|;
if|if
condition|(
name|level
operator|!=
name|IPPROTO_IPV6
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|==
name|SOL_SOCKET
operator|&&
name|sopt
operator|->
name|sopt_dir
operator|==
name|SOPT_SET
condition|)
block|{
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|SO_REUSEADDR
case|:
name|INP_WLOCK
argument_list|(
name|in6p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_REUSEADDR
operator|)
operator|!=
literal|0
condition|)
name|in6p
operator|->
name|inp_flags2
operator||=
name|INP_REUSEADDR
expr_stmt|;
else|else
name|in6p
operator|->
name|inp_flags2
operator|&=
operator|~
name|INP_REUSEADDR
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|in6p
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SO_REUSEPORT
case|:
name|INP_WLOCK
argument_list|(
name|in6p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_REUSEPORT
operator|)
operator|!=
literal|0
condition|)
name|in6p
operator|->
name|inp_flags2
operator||=
name|INP_REUSEPORT
expr_stmt|;
else|else
name|in6p
operator|->
name|inp_flags2
operator|&=
operator|~
name|INP_REUSEPORT
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|in6p
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SO_SETFIB
case|:
name|INP_WLOCK
argument_list|(
name|in6p
argument_list|)
expr_stmt|;
name|in6p
operator|->
name|inp_inc
operator|.
name|inc_fibnum
operator|=
name|so
operator|->
name|so_fibnum
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|in6p
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* level == IPPROTO_IPV6 */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SOPT_SET
case|:
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_2292PKTOPTIONS
case|:
ifdef|#
directive|ifdef
name|IPV6_PKTOPTIONS
case|case
name|IPV6_PKTOPTIONS
case|:
endif|#
directive|endif
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|optlen
operator|>
name|IPV6_PKTOPTIONS_MBUF_LIMIT
condition|)
block|{
name|printf
argument_list|(
literal|"ip6_ctloutput: mbuf limit hit\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|soopt_getm
argument_list|(
name|sopt
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|error
operator|=
name|soopt_mcopyin
argument_list|(
name|sopt
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|error
operator|=
name|ip6_pcbopts
argument_list|(
operator|&
name|in6p
operator|->
name|in6p_outputopts
argument_list|,
name|m
argument_list|,
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
block|}
comment|/* 			 * Use of some Hop-by-Hop options or some 			 * Destination options, might require special 			 * privilege.  That is, normal applications 			 * (without special privilege) might be forbidden 			 * from setting certain options in outgoing packets, 			 * and might never see certain options in received 			 * packets. [RFC 2292 Section 6] 			 * KAME specific note: 			 *  KAME prevents non-privileged users from sending or 			 *  receiving ANY hbh/dst options in order to avoid 			 *  overhead of parsing options in the kernel. 			 */
case|case
name|IPV6_RECVHOPOPTS
case|:
case|case
name|IPV6_RECVDSTOPTS
case|:
case|case
name|IPV6_RECVRTHDRDSTOPTS
case|:
if|if
condition|(
name|td
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NETINET_SETHDROPTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|IPV6_UNICAST_HOPS
case|:
case|case
name|IPV6_HOPLIMIT
case|:
case|case
name|IPV6_RECVPKTINFO
case|:
case|case
name|IPV6_RECVHOPLIMIT
case|:
case|case
name|IPV6_RECVRTHDR
case|:
case|case
name|IPV6_RECVPATHMTU
case|:
case|case
name|IPV6_RECVTCLASS
case|:
case|case
name|IPV6_RECVFLOWID
case|:
ifdef|#
directive|ifdef
name|RSS
case|case
name|IPV6_RECVRSSBUCKETID
case|:
endif|#
directive|endif
case|case
name|IPV6_V6ONLY
case|:
case|case
name|IPV6_AUTOFLOWLABEL
case|:
case|case
name|IPV6_BINDANY
case|:
case|case
name|IPV6_BINDMULTI
case|:
ifdef|#
directive|ifdef
name|RSS
case|case
name|IPV6_RSS_LISTEN_BUCKET
case|:
endif|#
directive|endif
if|if
condition|(
name|optname
operator|==
name|IPV6_BINDANY
operator|&&
name|td
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NETINET_BINDANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
if|if
condition|(
name|optlen
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_UNICAST_HOPS
case|:
if|if
condition|(
name|optval
operator|<
operator|-
literal|1
operator|||
name|optval
operator|>=
literal|256
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
comment|/* -1 = kernel default */
name|in6p
operator|->
name|in6p_hops
operator|=
name|optval
expr_stmt|;
if|if
condition|(
operator|(
name|in6p
operator|->
name|inp_vflag
operator|&
name|INP_IPV4
operator|)
operator|!=
literal|0
condition|)
name|in6p
operator|->
name|inp_ip_ttl
operator|=
name|optval
expr_stmt|;
block|}
break|break;
define|#
directive|define
name|OPTSET
parameter_list|(
name|bit
parameter_list|)
define|\
value|do { \ 	INP_WLOCK(in6p); \ 	if (optval) \ 		in6p->inp_flags |= (bit); \ 	else \ 		in6p->inp_flags&= ~(bit); \ 	INP_WUNLOCK(in6p); \ } while (
comment|/*CONSTCOND*/
value|0)
define|#
directive|define
name|OPTSET2292
parameter_list|(
name|bit
parameter_list|)
define|\
value|do { \ 	INP_WLOCK(in6p); \ 	in6p->inp_flags |= IN6P_RFC2292; \ 	if (optval) \ 		in6p->inp_flags |= (bit); \ 	else \ 		in6p->inp_flags&= ~(bit); \ 	INP_WUNLOCK(in6p); \ } while (
comment|/*CONSTCOND*/
value|0)
define|#
directive|define
name|OPTBIT
parameter_list|(
name|bit
parameter_list|)
value|(in6p->inp_flags& (bit) ? 1 : 0)
define|#
directive|define
name|OPTSET2
parameter_list|(
name|bit
parameter_list|,
name|val
parameter_list|)
value|do {						\ 	INP_WLOCK(in6p);						\ 	if (val)							\ 		in6p->inp_flags2 |= bit;				\ 	else								\ 		in6p->inp_flags2&= ~bit;				\ 	INP_WUNLOCK(in6p);						\ } while (0)
define|#
directive|define
name|OPTBIT2
parameter_list|(
name|bit
parameter_list|)
value|(in6p->inp_flags2& (bit) ? 1 : 0)
case|case
name|IPV6_RECVPKTINFO
case|:
comment|/* cannot mix with RFC2292 */
if|if
condition|(
name|OPTBIT
argument_list|(
name|IN6P_RFC2292
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|OPTSET
argument_list|(
name|IN6P_PKTINFO
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_HOPLIMIT
case|:
block|{
name|struct
name|ip6_pktopts
modifier|*
modifier|*
name|optp
decl_stmt|;
comment|/* cannot mix with RFC2292 */
if|if
condition|(
name|OPTBIT
argument_list|(
name|IN6P_RFC2292
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|optp
operator|=
operator|&
name|in6p
operator|->
name|in6p_outputopts
expr_stmt|;
name|error
operator|=
name|ip6_pcbopt
argument_list|(
name|IPV6_HOPLIMIT
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|,
name|optp
argument_list|,
operator|(
name|td
operator|!=
name|NULL
operator|)
condition|?
name|td
operator|->
name|td_ucred
else|:
name|NULL
argument_list|,
name|uproto
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IPV6_RECVHOPLIMIT
case|:
comment|/* cannot mix with RFC2292 */
if|if
condition|(
name|OPTBIT
argument_list|(
name|IN6P_RFC2292
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|OPTSET
argument_list|(
name|IN6P_HOPLIMIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_RECVHOPOPTS
case|:
comment|/* cannot mix with RFC2292 */
if|if
condition|(
name|OPTBIT
argument_list|(
name|IN6P_RFC2292
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|OPTSET
argument_list|(
name|IN6P_HOPOPTS
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_RECVDSTOPTS
case|:
comment|/* cannot mix with RFC2292 */
if|if
condition|(
name|OPTBIT
argument_list|(
name|IN6P_RFC2292
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|OPTSET
argument_list|(
name|IN6P_DSTOPTS
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_RECVRTHDRDSTOPTS
case|:
comment|/* cannot mix with RFC2292 */
if|if
condition|(
name|OPTBIT
argument_list|(
name|IN6P_RFC2292
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|OPTSET
argument_list|(
name|IN6P_RTHDRDSTOPTS
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_RECVRTHDR
case|:
comment|/* cannot mix with RFC2292 */
if|if
condition|(
name|OPTBIT
argument_list|(
name|IN6P_RFC2292
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|OPTSET
argument_list|(
name|IN6P_RTHDR
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_RECVPATHMTU
case|:
comment|/* 					 * We ignore this option for TCP 					 * sockets. 					 * (RFC3542 leaves this case 					 * unspecified.) 					 */
if|if
condition|(
name|uproto
operator|!=
name|IPPROTO_TCP
condition|)
name|OPTSET
argument_list|(
name|IN6P_MTU
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_RECVFLOWID
case|:
name|OPTSET2
argument_list|(
name|INP_RECVFLOWID
argument_list|,
name|optval
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|RSS
case|case
name|IPV6_RECVRSSBUCKETID
case|:
name|OPTSET2
argument_list|(
name|INP_RECVRSSBUCKETID
argument_list|,
name|optval
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|IPV6_V6ONLY
case|:
comment|/* 					 * make setsockopt(IPV6_V6ONLY) 					 * available only prior to bind(2). 					 * see ipng mailing list, Jun 22 2001. 					 */
if|if
condition|(
name|in6p
operator|->
name|inp_lport
operator|||
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|in6p
operator|->
name|in6p_laddr
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|OPTSET
argument_list|(
name|IN6P_IPV6_V6ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|optval
condition|)
name|in6p
operator|->
name|inp_vflag
operator|&=
operator|~
name|INP_IPV4
expr_stmt|;
else|else
name|in6p
operator|->
name|inp_vflag
operator||=
name|INP_IPV4
expr_stmt|;
break|break;
case|case
name|IPV6_RECVTCLASS
case|:
comment|/* cannot mix with RFC2292 XXX */
if|if
condition|(
name|OPTBIT
argument_list|(
name|IN6P_RFC2292
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|OPTSET
argument_list|(
name|IN6P_TCLASS
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_AUTOFLOWLABEL
case|:
name|OPTSET
argument_list|(
name|IN6P_AUTOFLOWLABEL
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_BINDANY
case|:
name|OPTSET
argument_list|(
name|INP_BINDANY
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_BINDMULTI
case|:
name|OPTSET2
argument_list|(
name|INP_BINDMULTI
argument_list|,
name|optval
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|RSS
case|case
name|IPV6_RSS_LISTEN_BUCKET
case|:
if|if
condition|(
operator|(
name|optval
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|optval
operator|<
name|rss_getnumbuckets
argument_list|()
operator|)
condition|)
block|{
name|in6p
operator|->
name|inp_rss_listen_bucket
operator|=
name|optval
expr_stmt|;
name|OPTSET2
argument_list|(
name|INP_RSS_BUCKET_SET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
block|}
break|break;
case|case
name|IPV6_TCLASS
case|:
case|case
name|IPV6_DONTFRAG
case|:
case|case
name|IPV6_USE_MIN_MTU
case|:
case|case
name|IPV6_PREFER_TEMPADDR
case|:
if|if
condition|(
name|optlen
operator|!=
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|{
name|struct
name|ip6_pktopts
modifier|*
modifier|*
name|optp
decl_stmt|;
name|optp
operator|=
operator|&
name|in6p
operator|->
name|in6p_outputopts
expr_stmt|;
name|error
operator|=
name|ip6_pcbopt
argument_list|(
name|optname
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|,
name|optp
argument_list|,
operator|(
name|td
operator|!=
name|NULL
operator|)
condition|?
name|td
operator|->
name|td_ucred
else|:
name|NULL
argument_list|,
name|uproto
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IPV6_2292PKTINFO
case|:
case|case
name|IPV6_2292HOPLIMIT
case|:
case|case
name|IPV6_2292HOPOPTS
case|:
case|case
name|IPV6_2292DSTOPTS
case|:
case|case
name|IPV6_2292RTHDR
case|:
comment|/* RFC 2292 */
if|if
condition|(
name|optlen
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_2292PKTINFO
case|:
name|OPTSET2292
argument_list|(
name|IN6P_PKTINFO
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_2292HOPLIMIT
case|:
name|OPTSET2292
argument_list|(
name|IN6P_HOPLIMIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_2292HOPOPTS
case|:
comment|/* 					 * Check super-user privilege. 					 * See comments for IPV6_RECVHOPOPTS. 					 */
if|if
condition|(
name|td
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NETINET_SETHDROPTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|OPTSET2292
argument_list|(
name|IN6P_HOPOPTS
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_2292DSTOPTS
case|:
if|if
condition|(
name|td
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NETINET_SETHDROPTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|OPTSET2292
argument_list|(
name|IN6P_DSTOPTS
operator||
name|IN6P_RTHDRDSTOPTS
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|IPV6_2292RTHDR
case|:
name|OPTSET2292
argument_list|(
name|IN6P_RTHDR
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IPV6_PKTINFO
case|:
case|case
name|IPV6_HOPOPTS
case|:
case|case
name|IPV6_RTHDR
case|:
case|case
name|IPV6_DSTOPTS
case|:
case|case
name|IPV6_RTHDRDSTOPTS
case|:
case|case
name|IPV6_NEXTHOP
case|:
block|{
comment|/* new advanced API (RFC3542) */
name|u_char
modifier|*
name|optbuf
decl_stmt|;
name|u_char
name|optbuf_storage
index|[
name|MCLBYTES
index|]
decl_stmt|;
name|int
name|optlen
decl_stmt|;
name|struct
name|ip6_pktopts
modifier|*
modifier|*
name|optp
decl_stmt|;
comment|/* cannot mix with RFC2292 */
if|if
condition|(
name|OPTBIT
argument_list|(
name|IN6P_RFC2292
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 				 * We only ensure valsize is not too large 				 * here.  Further validation will be done 				 * later. 				 */
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
name|optbuf_storage
argument_list|,
sizeof|sizeof
argument_list|(
name|optbuf_storage
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|optlen
operator|=
name|sopt
operator|->
name|sopt_valsize
expr_stmt|;
name|optbuf
operator|=
name|optbuf_storage
expr_stmt|;
name|optp
operator|=
operator|&
name|in6p
operator|->
name|in6p_outputopts
expr_stmt|;
name|error
operator|=
name|ip6_pcbopt
argument_list|(
name|optname
argument_list|,
name|optbuf
argument_list|,
name|optlen
argument_list|,
name|optp
argument_list|,
operator|(
name|td
operator|!=
name|NULL
operator|)
condition|?
name|td
operator|->
name|td_ucred
else|:
name|NULL
argument_list|,
name|uproto
argument_list|)
expr_stmt|;
break|break;
block|}
undef|#
directive|undef
name|OPTSET
case|case
name|IPV6_MULTICAST_IF
case|:
case|case
name|IPV6_MULTICAST_HOPS
case|:
case|case
name|IPV6_MULTICAST_LOOP
case|:
case|case
name|IPV6_JOIN_GROUP
case|:
case|case
name|IPV6_LEAVE_GROUP
case|:
case|case
name|IPV6_MSFILTER
case|:
case|case
name|MCAST_BLOCK_SOURCE
case|:
case|case
name|MCAST_UNBLOCK_SOURCE
case|:
case|case
name|MCAST_JOIN_GROUP
case|:
case|case
name|MCAST_LEAVE_GROUP
case|:
case|case
name|MCAST_JOIN_SOURCE_GROUP
case|:
case|case
name|MCAST_LEAVE_SOURCE_GROUP
case|:
name|error
operator|=
name|ip6_setmoptions
argument_list|(
name|in6p
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_PORTRANGE
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|INP_WLOCK
argument_list|(
name|in6p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|optval
condition|)
block|{
case|case
name|IPV6_PORTRANGE_DEFAULT
case|:
name|in6p
operator|->
name|inp_flags
operator|&=
operator|~
operator|(
name|INP_LOWPORT
operator|)
expr_stmt|;
name|in6p
operator|->
name|inp_flags
operator|&=
operator|~
operator|(
name|INP_HIGHPORT
operator|)
expr_stmt|;
break|break;
case|case
name|IPV6_PORTRANGE_HIGH
case|:
name|in6p
operator|->
name|inp_flags
operator|&=
operator|~
operator|(
name|INP_LOWPORT
operator|)
expr_stmt|;
name|in6p
operator|->
name|inp_flags
operator||=
name|INP_HIGHPORT
expr_stmt|;
break|break;
case|case
name|IPV6_PORTRANGE_LOW
case|:
name|in6p
operator|->
name|inp_flags
operator|&=
operator|~
operator|(
name|INP_HIGHPORT
operator|)
expr_stmt|;
name|in6p
operator|->
name|inp_flags
operator||=
name|INP_LOWPORT
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|INP_WUNLOCK
argument_list|(
name|in6p
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|IPSEC
argument_list|)
operator|||
name|defined
argument_list|(
name|IPSEC_SUPPORT
argument_list|)
case|case
name|IPV6_IPSEC_POLICY
case|:
if|if
condition|(
name|IPSEC_ENABLED
argument_list|(
name|ipv6
argument_list|)
condition|)
block|{
name|error
operator|=
name|IPSEC_PCBCTL
argument_list|(
name|ipv6
argument_list|,
name|in6p
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
endif|#
directive|endif
comment|/* IPSEC */
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SOPT_GET
case|:
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_2292PKTOPTIONS
case|:
ifdef|#
directive|ifdef
name|IPV6_PKTOPTIONS
case|case
name|IPV6_PKTOPTIONS
case|:
endif|#
directive|endif
comment|/* 				 * RFC3542 (effectively) deprecated the 				 * semantics of the 2292-style pktoptions. 				 * Since it was not reliable in nature (i.e., 				 * applications had to expect the lack of some 				 * information after all), it would make sense 				 * to simplify this part by always returning 				 * empty data. 				 */
name|sopt
operator|->
name|sopt_valsize
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPV6_RECVHOPOPTS
case|:
case|case
name|IPV6_RECVDSTOPTS
case|:
case|case
name|IPV6_RECVRTHDRDSTOPTS
case|:
case|case
name|IPV6_UNICAST_HOPS
case|:
case|case
name|IPV6_RECVPKTINFO
case|:
case|case
name|IPV6_RECVHOPLIMIT
case|:
case|case
name|IPV6_RECVRTHDR
case|:
case|case
name|IPV6_RECVPATHMTU
case|:
case|case
name|IPV6_V6ONLY
case|:
case|case
name|IPV6_PORTRANGE
case|:
case|case
name|IPV6_RECVTCLASS
case|:
case|case
name|IPV6_AUTOFLOWLABEL
case|:
case|case
name|IPV6_BINDANY
case|:
case|case
name|IPV6_FLOWID
case|:
case|case
name|IPV6_FLOWTYPE
case|:
case|case
name|IPV6_RECVFLOWID
case|:
ifdef|#
directive|ifdef
name|RSS
case|case
name|IPV6_RSSBUCKETID
case|:
case|case
name|IPV6_RECVRSSBUCKETID
case|:
endif|#
directive|endif
case|case
name|IPV6_BINDMULTI
case|:
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_RECVHOPOPTS
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_HOPOPTS
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_RECVDSTOPTS
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_DSTOPTS
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_RECVRTHDRDSTOPTS
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_RTHDRDSTOPTS
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_UNICAST_HOPS
case|:
name|optval
operator|=
name|in6p
operator|->
name|in6p_hops
expr_stmt|;
break|break;
case|case
name|IPV6_RECVPKTINFO
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_PKTINFO
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_RECVHOPLIMIT
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_HOPLIMIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_RECVRTHDR
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_RTHDR
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_RECVPATHMTU
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_MTU
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_V6ONLY
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_IPV6_V6ONLY
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_PORTRANGE
case|:
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|in6p
operator|->
name|inp_flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|INP_HIGHPORT
condition|)
name|optval
operator|=
name|IPV6_PORTRANGE_HIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|INP_LOWPORT
condition|)
name|optval
operator|=
name|IPV6_PORTRANGE_LOW
expr_stmt|;
else|else
name|optval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|IPV6_RECVTCLASS
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_TCLASS
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_AUTOFLOWLABEL
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_AUTOFLOWLABEL
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_BINDANY
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|INP_BINDANY
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_FLOWID
case|:
name|optval
operator|=
name|in6p
operator|->
name|inp_flowid
expr_stmt|;
break|break;
case|case
name|IPV6_FLOWTYPE
case|:
name|optval
operator|=
name|in6p
operator|->
name|inp_flowtype
expr_stmt|;
break|break;
case|case
name|IPV6_RECVFLOWID
case|:
name|optval
operator|=
name|OPTBIT2
argument_list|(
name|INP_RECVFLOWID
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|RSS
case|case
name|IPV6_RSSBUCKETID
case|:
name|retval
operator|=
name|rss_hash2bucket
argument_list|(
name|in6p
operator|->
name|inp_flowid
argument_list|,
name|in6p
operator|->
name|inp_flowtype
argument_list|,
operator|&
name|rss_bucket
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|optval
operator|=
name|rss_bucket
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|IPV6_RECVRSSBUCKETID
case|:
name|optval
operator|=
name|OPTBIT2
argument_list|(
name|INP_RECVRSSBUCKETID
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|IPV6_BINDMULTI
case|:
name|optval
operator|=
name|OPTBIT2
argument_list|(
name|INP_BINDMULTI
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_PATHMTU
case|:
block|{
name|u_long
name|pmtu
init|=
literal|0
decl_stmt|;
name|struct
name|ip6_mtuinfo
name|mtuinfo
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
condition|)
return|return
operator|(
name|ENOTCONN
operator|)
return|;
comment|/* 				 * XXX: we dot not consider the case of source 				 * routing, or optional information to specify 				 * the outgoing interface. 				 */
name|error
operator|=
name|ip6_getpmtu_ctl
argument_list|(
name|so
operator|->
name|so_fibnum
argument_list|,
operator|&
name|in6p
operator|->
name|in6p_faddr
argument_list|,
operator|&
name|pmtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|pmtu
operator|>
name|IPV6_MAXPACKET
condition|)
name|pmtu
operator|=
name|IPV6_MAXPACKET
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|mtuinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|mtuinfo
argument_list|)
argument_list|)
expr_stmt|;
name|mtuinfo
operator|.
name|ip6m_mtu
operator|=
operator|(
name|u_int32_t
operator|)
name|pmtu
expr_stmt|;
name|optdata
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|mtuinfo
expr_stmt|;
name|optdatalen
operator|=
sizeof|sizeof
argument_list|(
name|mtuinfo
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
name|optdata
argument_list|,
name|optdatalen
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IPV6_2292PKTINFO
case|:
case|case
name|IPV6_2292HOPLIMIT
case|:
case|case
name|IPV6_2292HOPOPTS
case|:
case|case
name|IPV6_2292RTHDR
case|:
case|case
name|IPV6_2292DSTOPTS
case|:
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_2292PKTINFO
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_PKTINFO
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_2292HOPLIMIT
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_HOPLIMIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_2292HOPOPTS
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_HOPOPTS
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_2292RTHDR
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_RTHDR
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_2292DSTOPTS
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_DSTOPTS
operator||
name|IN6P_RTHDRDSTOPTS
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_PKTINFO
case|:
case|case
name|IPV6_HOPOPTS
case|:
case|case
name|IPV6_RTHDR
case|:
case|case
name|IPV6_DSTOPTS
case|:
case|case
name|IPV6_RTHDRDSTOPTS
case|:
case|case
name|IPV6_NEXTHOP
case|:
case|case
name|IPV6_TCLASS
case|:
case|case
name|IPV6_DONTFRAG
case|:
case|case
name|IPV6_USE_MIN_MTU
case|:
case|case
name|IPV6_PREFER_TEMPADDR
case|:
name|error
operator|=
name|ip6_getpcbopt
argument_list|(
name|in6p
operator|->
name|in6p_outputopts
argument_list|,
name|optname
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_MULTICAST_IF
case|:
case|case
name|IPV6_MULTICAST_HOPS
case|:
case|case
name|IPV6_MULTICAST_LOOP
case|:
case|case
name|IPV6_MSFILTER
case|:
name|error
operator|=
name|ip6_getmoptions
argument_list|(
name|in6p
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|IPSEC
argument_list|)
operator|||
name|defined
argument_list|(
name|IPSEC_SUPPORT
argument_list|)
case|case
name|IPV6_IPSEC_POLICY
case|:
if|if
condition|(
name|IPSEC_ENABLED
argument_list|(
name|ipv6
argument_list|)
condition|)
block|{
name|error
operator|=
name|IPSEC_PCBCTL
argument_list|(
name|ipv6
argument_list|,
name|in6p
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
endif|#
directive|endif
comment|/* IPSEC */
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ip6_raw_ctloutput
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|,
name|optval
decl_stmt|,
name|optlen
decl_stmt|;
specifier|const
name|int
name|icmp6off
init|=
name|offsetof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|,
name|icmp6_cksum
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|in6p
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|level
decl_stmt|,
name|op
decl_stmt|,
name|optname
decl_stmt|;
name|level
operator|=
name|sopt
operator|->
name|sopt_level
expr_stmt|;
name|op
operator|=
name|sopt
operator|->
name|sopt_dir
expr_stmt|;
name|optname
operator|=
name|sopt
operator|->
name|sopt_name
expr_stmt|;
name|optlen
operator|=
name|sopt
operator|->
name|sopt_valsize
expr_stmt|;
if|if
condition|(
name|level
operator|!=
name|IPPROTO_IPV6
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_CHECKSUM
case|:
comment|/* 		 * For ICMPv6 sockets, no modification allowed for checksum 		 * offset, permit "no change" values to help existing apps. 		 * 		 * RFC3542 says: "An attempt to set IPV6_CHECKSUM 		 * for an ICMPv6 socket will fail." 		 * The current behavior does not meet RFC3542. 		 */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SOPT_SET
case|:
if|if
condition|(
name|optlen
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
operator|(
name|optval
operator|%
literal|2
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* the API assumes even offset values */
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_ICMPV6
condition|)
block|{
if|if
condition|(
name|optval
operator|!=
name|icmp6off
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
name|in6p
operator|->
name|in6p_cksum
operator|=
name|optval
expr_stmt|;
break|break;
case|case
name|SOPT_GET
case|:
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_ICMPV6
condition|)
name|optval
operator|=
name|icmp6off
expr_stmt|;
else|else
name|optval
operator|=
name|in6p
operator|->
name|in6p_cksum
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up IP6 options in pcb for insertion in output packets or  * specifying behavior of outgoing packets.  */
end_comment

begin_function
specifier|static
name|int
name|ip6_pcbopts
parameter_list|(
name|struct
name|ip6_pktopts
modifier|*
modifier|*
name|pktopt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|ip6_pktopts
modifier|*
name|opt
init|=
operator|*
name|pktopt
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|sopt
operator|->
name|sopt_td
decl_stmt|;
comment|/* turn off any old options. */
if|if
condition|(
name|opt
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|opt
operator|->
name|ip6po_pktinfo
operator|||
name|opt
operator|->
name|ip6po_nexthop
operator|||
name|opt
operator|->
name|ip6po_hbh
operator|||
name|opt
operator|->
name|ip6po_dest1
operator|||
name|opt
operator|->
name|ip6po_dest2
operator|||
name|opt
operator|->
name|ip6po_rhinfo
operator|.
name|ip6po_rhi_rthdr
condition|)
name|printf
argument_list|(
literal|"ip6_pcbopts: all specified options are cleared.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ip6_clearpktopts
argument_list|(
name|opt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|opt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|opt
argument_list|)
argument_list|,
name|M_IP6OPT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|*
name|pktopt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Only turning off any previous options, regardless of 		 * whether the opt is just created or given. 		 */
name|free
argument_list|(
name|opt
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  set options specified by user. */
if|if
condition|(
operator|(
name|error
operator|=
name|ip6_setpktopts
argument_list|(
name|m
argument_list|,
name|opt
argument_list|,
name|NULL
argument_list|,
operator|(
name|td
operator|!=
name|NULL
operator|)
condition|?
name|td
operator|->
name|td_ucred
else|:
name|NULL
argument_list|,
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ip6_clearpktopts
argument_list|(
name|opt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX: discard all options */
name|free
argument_list|(
name|opt
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|pktopt
operator|=
name|opt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * initialize ip6_pktopts.  beware that there are non-zero default values in  * the struct.  */
end_comment

begin_function
name|void
name|ip6_initpktopts
parameter_list|(
name|struct
name|ip6_pktopts
modifier|*
name|opt
parameter_list|)
block|{
name|bzero
argument_list|(
name|opt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|opt
operator|->
name|ip6po_hlim
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* -1 means default hop limit */
name|opt
operator|->
name|ip6po_tclass
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* -1 means default traffic class */
name|opt
operator|->
name|ip6po_minmtu
operator|=
name|IP6PO_MINMTU_MCASTONLY
expr_stmt|;
name|opt
operator|->
name|ip6po_prefer_tempaddr
operator|=
name|IP6PO_TEMPADDR_SYSTEM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ip6_pcbopt
parameter_list|(
name|int
name|optname
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|ip6_pktopts
modifier|*
modifier|*
name|pktopt
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|uproto
parameter_list|)
block|{
name|struct
name|ip6_pktopts
modifier|*
name|opt
decl_stmt|;
if|if
condition|(
operator|*
name|pktopt
operator|==
name|NULL
condition|)
block|{
operator|*
name|pktopt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_pktopts
argument_list|)
argument_list|,
name|M_IP6OPT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ip6_initpktopts
argument_list|(
operator|*
name|pktopt
argument_list|)
expr_stmt|;
block|}
name|opt
operator|=
operator|*
name|pktopt
expr_stmt|;
return|return
operator|(
name|ip6_setpktopt
argument_list|(
name|optname
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|opt
argument_list|,
name|cred
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|uproto
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ip6_getpcbopt
parameter_list|(
name|struct
name|ip6_pktopts
modifier|*
name|pktopt
parameter_list|,
name|int
name|optname
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|void
modifier|*
name|optdata
init|=
name|NULL
decl_stmt|;
name|int
name|optdatalen
init|=
literal|0
decl_stmt|;
name|struct
name|ip6_ext
modifier|*
name|ip6e
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|in6_pktinfo
name|null_pktinfo
decl_stmt|;
name|int
name|deftclass
init|=
literal|0
decl_stmt|,
name|on
decl_stmt|;
name|int
name|defminmtu
init|=
name|IP6PO_MINMTU_MCASTONLY
decl_stmt|;
name|int
name|defpreftemp
init|=
name|IP6PO_TEMPADDR_SYSTEM
decl_stmt|;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_PKTINFO
case|:
name|optdata
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|null_pktinfo
expr_stmt|;
if|if
condition|(
name|pktopt
operator|&&
name|pktopt
operator|->
name|ip6po_pktinfo
condition|)
block|{
name|bcopy
argument_list|(
name|pktopt
operator|->
name|ip6po_pktinfo
argument_list|,
operator|&
name|null_pktinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|null_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|null_pktinfo
operator|.
name|ipi6_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX: we don't have to do this every time... */
name|bzero
argument_list|(
operator|&
name|null_pktinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|null_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|optdatalen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_TCLASS
case|:
if|if
condition|(
name|pktopt
operator|&&
name|pktopt
operator|->
name|ip6po_tclass
operator|>=
literal|0
condition|)
name|optdata
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|pktopt
operator|->
name|ip6po_tclass
expr_stmt|;
else|else
name|optdata
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|deftclass
expr_stmt|;
name|optdatalen
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_HOPOPTS
case|:
if|if
condition|(
name|pktopt
operator|&&
name|pktopt
operator|->
name|ip6po_hbh
condition|)
block|{
name|optdata
operator|=
operator|(
name|void
operator|*
operator|)
name|pktopt
operator|->
name|ip6po_hbh
expr_stmt|;
name|ip6e
operator|=
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
name|pktopt
operator|->
name|ip6po_hbh
expr_stmt|;
name|optdatalen
operator|=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
block|}
break|break;
case|case
name|IPV6_RTHDR
case|:
if|if
condition|(
name|pktopt
operator|&&
name|pktopt
operator|->
name|ip6po_rthdr
condition|)
block|{
name|optdata
operator|=
operator|(
name|void
operator|*
operator|)
name|pktopt
operator|->
name|ip6po_rthdr
expr_stmt|;
name|ip6e
operator|=
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
name|pktopt
operator|->
name|ip6po_rthdr
expr_stmt|;
name|optdatalen
operator|=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
block|}
break|break;
case|case
name|IPV6_RTHDRDSTOPTS
case|:
if|if
condition|(
name|pktopt
operator|&&
name|pktopt
operator|->
name|ip6po_dest1
condition|)
block|{
name|optdata
operator|=
operator|(
name|void
operator|*
operator|)
name|pktopt
operator|->
name|ip6po_dest1
expr_stmt|;
name|ip6e
operator|=
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
name|pktopt
operator|->
name|ip6po_dest1
expr_stmt|;
name|optdatalen
operator|=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
block|}
break|break;
case|case
name|IPV6_DSTOPTS
case|:
if|if
condition|(
name|pktopt
operator|&&
name|pktopt
operator|->
name|ip6po_dest2
condition|)
block|{
name|optdata
operator|=
operator|(
name|void
operator|*
operator|)
name|pktopt
operator|->
name|ip6po_dest2
expr_stmt|;
name|ip6e
operator|=
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
name|pktopt
operator|->
name|ip6po_dest2
expr_stmt|;
name|optdatalen
operator|=
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
block|}
break|break;
case|case
name|IPV6_NEXTHOP
case|:
if|if
condition|(
name|pktopt
operator|&&
name|pktopt
operator|->
name|ip6po_nexthop
condition|)
block|{
name|optdata
operator|=
operator|(
name|void
operator|*
operator|)
name|pktopt
operator|->
name|ip6po_nexthop
expr_stmt|;
name|optdatalen
operator|=
name|pktopt
operator|->
name|ip6po_nexthop
operator|->
name|sa_len
expr_stmt|;
block|}
break|break;
case|case
name|IPV6_USE_MIN_MTU
case|:
if|if
condition|(
name|pktopt
condition|)
name|optdata
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|pktopt
operator|->
name|ip6po_minmtu
expr_stmt|;
else|else
name|optdata
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|defminmtu
expr_stmt|;
name|optdatalen
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_DONTFRAG
case|:
if|if
condition|(
name|pktopt
operator|&&
operator|(
operator|(
name|pktopt
operator|->
name|ip6po_flags
operator|)
operator|&
name|IP6PO_DONTFRAG
operator|)
condition|)
name|on
operator|=
literal|1
expr_stmt|;
else|else
name|on
operator|=
literal|0
expr_stmt|;
name|optdata
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|on
expr_stmt|;
name|optdatalen
operator|=
sizeof|sizeof
argument_list|(
name|on
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_PREFER_TEMPADDR
case|:
if|if
condition|(
name|pktopt
condition|)
name|optdata
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|pktopt
operator|->
name|ip6po_prefer_tempaddr
expr_stmt|;
else|else
name|optdata
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|defpreftemp
expr_stmt|;
name|optdatalen
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* should not happen */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|panic
argument_list|(
literal|"ip6_getpcbopt: unexpected option\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
block|}
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
name|optdata
argument_list|,
name|optdatalen
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ip6_clearpktopts
parameter_list|(
name|struct
name|ip6_pktopts
modifier|*
name|pktopt
parameter_list|,
name|int
name|optname
parameter_list|)
block|{
if|if
condition|(
name|pktopt
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|optname
operator|==
operator|-
literal|1
operator|||
name|optname
operator|==
name|IPV6_PKTINFO
condition|)
block|{
if|if
condition|(
name|pktopt
operator|->
name|ip6po_pktinfo
condition|)
name|free
argument_list|(
name|pktopt
operator|->
name|ip6po_pktinfo
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
name|pktopt
operator|->
name|ip6po_pktinfo
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|optname
operator|==
operator|-
literal|1
operator|||
name|optname
operator|==
name|IPV6_HOPLIMIT
condition|)
name|pktopt
operator|->
name|ip6po_hlim
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|optname
operator|==
operator|-
literal|1
operator|||
name|optname
operator|==
name|IPV6_TCLASS
condition|)
name|pktopt
operator|->
name|ip6po_tclass
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|optname
operator|==
operator|-
literal|1
operator|||
name|optname
operator|==
name|IPV6_NEXTHOP
condition|)
block|{
if|if
condition|(
name|pktopt
operator|->
name|ip6po_nextroute
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|pktopt
operator|->
name|ip6po_nextroute
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|pktopt
operator|->
name|ip6po_nextroute
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pktopt
operator|->
name|ip6po_nexthop
condition|)
name|free
argument_list|(
name|pktopt
operator|->
name|ip6po_nexthop
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
name|pktopt
operator|->
name|ip6po_nexthop
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|optname
operator|==
operator|-
literal|1
operator|||
name|optname
operator|==
name|IPV6_HOPOPTS
condition|)
block|{
if|if
condition|(
name|pktopt
operator|->
name|ip6po_hbh
condition|)
name|free
argument_list|(
name|pktopt
operator|->
name|ip6po_hbh
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
name|pktopt
operator|->
name|ip6po_hbh
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|optname
operator|==
operator|-
literal|1
operator|||
name|optname
operator|==
name|IPV6_RTHDRDSTOPTS
condition|)
block|{
if|if
condition|(
name|pktopt
operator|->
name|ip6po_dest1
condition|)
name|free
argument_list|(
name|pktopt
operator|->
name|ip6po_dest1
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
name|pktopt
operator|->
name|ip6po_dest1
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|optname
operator|==
operator|-
literal|1
operator|||
name|optname
operator|==
name|IPV6_RTHDR
condition|)
block|{
if|if
condition|(
name|pktopt
operator|->
name|ip6po_rhinfo
operator|.
name|ip6po_rhi_rthdr
condition|)
name|free
argument_list|(
name|pktopt
operator|->
name|ip6po_rhinfo
operator|.
name|ip6po_rhi_rthdr
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
name|pktopt
operator|->
name|ip6po_rhinfo
operator|.
name|ip6po_rhi_rthdr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pktopt
operator|->
name|ip6po_route
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|pktopt
operator|->
name|ip6po_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|pktopt
operator|->
name|ip6po_route
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optname
operator|==
operator|-
literal|1
operator|||
name|optname
operator|==
name|IPV6_DSTOPTS
condition|)
block|{
if|if
condition|(
name|pktopt
operator|->
name|ip6po_dest2
condition|)
name|free
argument_list|(
name|pktopt
operator|->
name|ip6po_dest2
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
name|pktopt
operator|->
name|ip6po_dest2
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|PKTOPT_EXTHDRCPY
parameter_list|(
name|type
parameter_list|)
define|\
value|do {\ 	if (src->type) {\ 		int hlen = (((struct ip6_ext *)src->type)->ip6e_len + 1)<< 3;\ 		dst->type = malloc(hlen, M_IP6OPT, canwait);\ 		if (dst->type == NULL&& canwait == M_NOWAIT)\ 			goto bad;\ 		bcopy(src->type, dst->type, hlen);\ 	}\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_function
specifier|static
name|int
name|copypktopts
parameter_list|(
name|struct
name|ip6_pktopts
modifier|*
name|dst
parameter_list|,
name|struct
name|ip6_pktopts
modifier|*
name|src
parameter_list|,
name|int
name|canwait
parameter_list|)
block|{
if|if
condition|(
name|dst
operator|==
name|NULL
operator|||
name|src
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ip6_clearpktopts: invalid argument\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|dst
operator|->
name|ip6po_hlim
operator|=
name|src
operator|->
name|ip6po_hlim
expr_stmt|;
name|dst
operator|->
name|ip6po_tclass
operator|=
name|src
operator|->
name|ip6po_tclass
expr_stmt|;
name|dst
operator|->
name|ip6po_flags
operator|=
name|src
operator|->
name|ip6po_flags
expr_stmt|;
name|dst
operator|->
name|ip6po_minmtu
operator|=
name|src
operator|->
name|ip6po_minmtu
expr_stmt|;
name|dst
operator|->
name|ip6po_prefer_tempaddr
operator|=
name|src
operator|->
name|ip6po_prefer_tempaddr
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|ip6po_pktinfo
condition|)
block|{
name|dst
operator|->
name|ip6po_pktinfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dst
operator|->
name|ip6po_pktinfo
argument_list|)
argument_list|,
name|M_IP6OPT
argument_list|,
name|canwait
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|ip6po_pktinfo
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
operator|*
name|dst
operator|->
name|ip6po_pktinfo
operator|=
operator|*
name|src
operator|->
name|ip6po_pktinfo
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|->
name|ip6po_nexthop
condition|)
block|{
name|dst
operator|->
name|ip6po_nexthop
operator|=
name|malloc
argument_list|(
name|src
operator|->
name|ip6po_nexthop
operator|->
name|sa_len
argument_list|,
name|M_IP6OPT
argument_list|,
name|canwait
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|ip6po_nexthop
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|bcopy
argument_list|(
name|src
operator|->
name|ip6po_nexthop
argument_list|,
name|dst
operator|->
name|ip6po_nexthop
argument_list|,
name|src
operator|->
name|ip6po_nexthop
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
name|PKTOPT_EXTHDRCPY
argument_list|(
name|ip6po_hbh
argument_list|)
expr_stmt|;
name|PKTOPT_EXTHDRCPY
argument_list|(
name|ip6po_dest1
argument_list|)
expr_stmt|;
name|PKTOPT_EXTHDRCPY
argument_list|(
name|ip6po_dest2
argument_list|)
expr_stmt|;
name|PKTOPT_EXTHDRCPY
argument_list|(
name|ip6po_rthdr
argument_list|)
expr_stmt|;
comment|/* not copy the cached route */
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|ip6_clearpktopts
argument_list|(
name|dst
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|PKTOPT_EXTHDRCPY
end_undef

begin_function
name|struct
name|ip6_pktopts
modifier|*
name|ip6_copypktopts
parameter_list|(
name|struct
name|ip6_pktopts
modifier|*
name|src
parameter_list|,
name|int
name|canwait
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ip6_pktopts
modifier|*
name|dst
decl_stmt|;
name|dst
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|,
name|M_IP6OPT
argument_list|,
name|canwait
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ip6_initpktopts
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copypktopts
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|canwait
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|dst
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|dst
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ip6_freepcbopts
parameter_list|(
name|struct
name|ip6_pktopts
modifier|*
name|pktopt
parameter_list|)
block|{
if|if
condition|(
name|pktopt
operator|==
name|NULL
condition|)
return|return;
name|ip6_clearpktopts
argument_list|(
name|pktopt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pktopt
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set IPv6 outgoing packet options based on advanced API.  */
end_comment

begin_function
name|int
name|ip6_setpktopts
parameter_list|(
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|ip6_pktopts
modifier|*
name|opt
parameter_list|,
name|struct
name|ip6_pktopts
modifier|*
name|stickyopt
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|uproto
parameter_list|)
block|{
name|struct
name|cmsghdr
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
operator|||
name|opt
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ip6_initpktopts
argument_list|(
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|stickyopt
condition|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 		 * If stickyopt is provided, make a local copy of the options 		 * for this particular packet, then override them by ancillary 		 * objects. 		 * XXX: copypktopts() does not copy the cached route to a next 		 * hop (if any).  This is not very good in terms of efficiency, 		 * but we can allow this since this option should be rarely 		 * used. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|copypktopts
argument_list|(
name|opt
argument_list|,
name|stickyopt
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * XXX: Currently, we assume all the optional information is stored 	 * in a single mbuf. 	 */
if|if
condition|(
name|control
operator|->
name|m_next
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
init|;
name|control
operator|->
name|m_len
operator|>
literal|0
condition|;
name|control
operator|->
name|m_data
operator|+=
name|CMSG_ALIGN
argument_list|(
name|cm
operator|->
name|cmsg_len
argument_list|)
operator|,
name|control
operator|->
name|m_len
operator|-=
name|CMSG_ALIGN
argument_list|(
name|cm
operator|->
name|cmsg_len
argument_list|)
control|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|control
operator|->
name|m_len
operator|<
name|CMSG_LEN
argument_list|(
literal|0
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cm
operator|=
name|mtod
argument_list|(
name|control
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|==
literal|0
operator|||
name|cm
operator|->
name|cmsg_len
operator|>
name|control
operator|->
name|m_len
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|!=
name|IPPROTO_IPV6
condition|)
continue|continue;
name|error
operator|=
name|ip6_setpktopt
argument_list|(
name|cm
operator|->
name|cmsg_type
argument_list|,
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
argument_list|,
name|cm
operator|->
name|cmsg_len
operator|-
name|CMSG_LEN
argument_list|(
literal|0
argument_list|)
argument_list|,
name|opt
argument_list|,
name|cred
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|uproto
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set a particular packet option, as a sticky option or an ancillary data  * item.  "len" can be 0 only when it's a sticky option.  * We have 4 cases of combination of "sticky" and "cmsg":  * "sticky=0, cmsg=0": impossible  * "sticky=0, cmsg=1": RFC2292 or RFC3542 ancillary data  * "sticky=1, cmsg=0": RFC3542 socket option  * "sticky=1, cmsg=1": RFC2292 socket option  */
end_comment

begin_function
specifier|static
name|int
name|ip6_setpktopt
parameter_list|(
name|int
name|optname
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|ip6_pktopts
modifier|*
name|opt
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|sticky
parameter_list|,
name|int
name|cmsg
parameter_list|,
name|int
name|uproto
parameter_list|)
block|{
name|int
name|minmtupolicy
decl_stmt|,
name|preftemp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|sticky
operator|&&
operator|!
name|cmsg
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"ip6_setpktopt: impossible case\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * IPV6_2292xxx is for backward compatibility to RFC2292, and should 	 * not be specified in the context of RFC3542.  Conversely, 	 * RFC3542 types should not be specified in the context of RFC2292. 	 */
if|if
condition|(
operator|!
name|cmsg
condition|)
block|{
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_2292PKTINFO
case|:
case|case
name|IPV6_2292HOPLIMIT
case|:
case|case
name|IPV6_2292NEXTHOP
case|:
case|case
name|IPV6_2292HOPOPTS
case|:
case|case
name|IPV6_2292DSTOPTS
case|:
case|case
name|IPV6_2292RTHDR
case|:
case|case
name|IPV6_2292PKTOPTIONS
case|:
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
block|}
block|}
if|if
condition|(
name|sticky
operator|&&
name|cmsg
condition|)
block|{
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_PKTINFO
case|:
case|case
name|IPV6_HOPLIMIT
case|:
case|case
name|IPV6_NEXTHOP
case|:
case|case
name|IPV6_HOPOPTS
case|:
case|case
name|IPV6_DSTOPTS
case|:
case|case
name|IPV6_RTHDRDSTOPTS
case|:
case|case
name|IPV6_RTHDR
case|:
case|case
name|IPV6_USE_MIN_MTU
case|:
case|case
name|IPV6_DONTFRAG
case|:
case|case
name|IPV6_TCLASS
case|:
case|case
name|IPV6_PREFER_TEMPADDR
case|:
comment|/* XXX: not an RFC3542 option */
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_2292PKTINFO
case|:
case|case
name|IPV6_PKTINFO
case|:
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
decl_stmt|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pktinfo
operator|=
operator|(
expr|struct
name|in6_pktinfo
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* 		 * An application can clear any sticky IPV6_PKTINFO option by 		 * doing a "regular" setsockopt with ipi6_addr being 		 * in6addr_any and ipi6_ifindex being zero. 		 * [RFC 3542, Section 6] 		 */
if|if
condition|(
name|optname
operator|==
name|IPV6_PKTINFO
operator|&&
name|opt
operator|->
name|ip6po_pktinfo
operator|&&
name|pktinfo
operator|->
name|ipi6_ifindex
operator|==
literal|0
operator|&&
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|pktinfo
operator|->
name|ipi6_addr
argument_list|)
condition|)
block|{
name|ip6_clearpktopts
argument_list|(
name|opt
argument_list|,
name|optname
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|uproto
operator|==
name|IPPROTO_TCP
operator|&&
name|optname
operator|==
name|IPV6_PKTINFO
operator|&&
name|sticky
operator|&&
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|pktinfo
operator|->
name|ipi6_addr
argument_list|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|pktinfo
operator|->
name|ipi6_addr
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* validate the interface index if specified. */
if|if
condition|(
name|pktinfo
operator|->
name|ipi6_ifindex
operator|>
name|V_if_index
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|pktinfo
operator|->
name|ipi6_ifindex
condition|)
block|{
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|pktinfo
operator|->
name|ipi6_ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|ifp
operator|!=
name|NULL
operator|&&
operator|(
name|ifp
operator|->
name|if_afdata
index|[
name|AF_INET6
index|]
operator|==
name|NULL
operator|||
operator|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|ENETDOWN
operator|)
return|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
operator|&&
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|pktinfo
operator|->
name|ipi6_addr
argument_list|)
condition|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ia
decl_stmt|;
name|in6_setscope
argument_list|(
operator|&
name|pktinfo
operator|->
name|ipi6_addr
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ia
operator|=
name|in6ifa_ifpwithaddr
argument_list|(
name|ifp
argument_list|,
operator|&
name|pktinfo
operator|->
name|ipi6_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|==
name|NULL
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We store the address anyway, and let in6_selectsrc() 		 * validate the specified address.  This is because ipi6_addr 		 * may not have enough information about its scope zone, and 		 * we may need additional information (such as outgoing 		 * interface or the scope zone of a destination address) to 		 * disambiguate the scope. 		 * XXX: the delay of the validation may confuse the 		 * application when it is used as a sticky option. 		 */
if|if
condition|(
name|opt
operator|->
name|ip6po_pktinfo
operator|==
name|NULL
condition|)
block|{
name|opt
operator|->
name|ip6po_pktinfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pktinfo
argument_list|)
argument_list|,
name|M_IP6OPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|ip6po_pktinfo
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|pktinfo
argument_list|,
name|opt
operator|->
name|ip6po_pktinfo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pktinfo
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IPV6_2292HOPLIMIT
case|:
case|case
name|IPV6_HOPLIMIT
case|:
block|{
name|int
modifier|*
name|hlimp
decl_stmt|;
comment|/* 		 * RFC 3542 deprecated the usage of sticky IPV6_HOPLIMIT 		 * to simplify the ordering among hoplimit options. 		 */
if|if
condition|(
name|optname
operator|==
name|IPV6_HOPLIMIT
operator|&&
name|sticky
condition|)
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hlimp
operator|=
operator|(
name|int
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
operator|*
name|hlimp
operator|<
operator|-
literal|1
operator|||
operator|*
name|hlimp
operator|>
literal|255
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|opt
operator|->
name|ip6po_hlim
operator|=
operator|*
name|hlimp
expr_stmt|;
break|break;
block|}
case|case
name|IPV6_TCLASS
case|:
block|{
name|int
name|tclass
decl_stmt|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tclass
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|tclass
operator|<
operator|-
literal|1
operator|||
name|tclass
operator|>
literal|255
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|opt
operator|->
name|ip6po_tclass
operator|=
name|tclass
expr_stmt|;
break|break;
block|}
case|case
name|IPV6_2292NEXTHOP
case|:
case|case
name|IPV6_NEXTHOP
case|:
if|if
condition|(
name|cred
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_NETINET_SETHDROPTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* just remove the option */
name|ip6_clearpktopts
argument_list|(
name|opt
argument_list|,
name|IPV6_NEXTHOP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* check if cmsg_len is large enough for sa_len */
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
operator|||
name|len
operator|<
operator|*
name|buf
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|buf
operator|)
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sa6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sa6
operator|->
name|sin6_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
operator|||
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|sa6_embedscope
argument_list|(
name|sa6
argument_list|,
name|V_ip6_use_defzone
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
break|break;
block|}
case|case
name|AF_LINK
case|:
comment|/* should eventually be supported */
default|default:
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
comment|/* turn off the previous option, then set the new option. */
name|ip6_clearpktopts
argument_list|(
name|opt
argument_list|,
name|IPV6_NEXTHOP
argument_list|)
expr_stmt|;
name|opt
operator|->
name|ip6po_nexthop
operator|=
name|malloc
argument_list|(
operator|*
name|buf
argument_list|,
name|M_IP6OPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|ip6po_nexthop
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|opt
operator|->
name|ip6po_nexthop
argument_list|,
operator|*
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_2292HOPOPTS
case|:
case|case
name|IPV6_HOPOPTS
case|:
block|{
name|struct
name|ip6_hbh
modifier|*
name|hbh
decl_stmt|;
name|int
name|hbhlen
decl_stmt|;
comment|/* 		 * XXX: We don't allow a non-privileged user to set ANY HbH 		 * options, since per-option restriction has too much 		 * overhead. 		 */
if|if
condition|(
name|cred
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_NETINET_SETHDROPTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|ip6_clearpktopts
argument_list|(
name|opt
argument_list|,
name|IPV6_HOPOPTS
argument_list|)
expr_stmt|;
break|break;
comment|/* just remove the option */
block|}
comment|/* message length validation */
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hbh
operator|=
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
name|buf
expr_stmt|;
name|hbhlen
operator|=
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|hbhlen
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* turn off the previous option, then set the new option. */
name|ip6_clearpktopts
argument_list|(
name|opt
argument_list|,
name|IPV6_HOPOPTS
argument_list|)
expr_stmt|;
name|opt
operator|->
name|ip6po_hbh
operator|=
name|malloc
argument_list|(
name|hbhlen
argument_list|,
name|M_IP6OPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|ip6po_hbh
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|bcopy
argument_list|(
name|hbh
argument_list|,
name|opt
operator|->
name|ip6po_hbh
argument_list|,
name|hbhlen
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IPV6_2292DSTOPTS
case|:
case|case
name|IPV6_DSTOPTS
case|:
case|case
name|IPV6_RTHDRDSTOPTS
case|:
block|{
name|struct
name|ip6_dest
modifier|*
name|dest
decl_stmt|,
modifier|*
modifier|*
name|newdest
init|=
name|NULL
decl_stmt|;
name|int
name|destlen
decl_stmt|;
if|if
condition|(
name|cred
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX: see the comment for IPV6_HOPOPTS */
name|error
operator|=
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_NETINET_SETHDROPTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|ip6_clearpktopts
argument_list|(
name|opt
argument_list|,
name|optname
argument_list|)
expr_stmt|;
break|break;
comment|/* just remove the option */
block|}
comment|/* message length validation */
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_dest
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|dest
operator|=
operator|(
expr|struct
name|ip6_dest
operator|*
operator|)
name|buf
expr_stmt|;
name|destlen
operator|=
operator|(
name|dest
operator|->
name|ip6d_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|destlen
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 		 * Determine the position that the destination options header 		 * should be inserted; before or after the routing header. 		 */
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_2292DSTOPTS
case|:
comment|/* 			 * The old advacned API is ambiguous on this point. 			 * Our approach is to determine the position based 			 * according to the existence of a routing header. 			 * Note, however, that this depends on the order of the 			 * extension headers in the ancillary data; the 1st 			 * part of the destination options header must appear 			 * before the routing header in the ancillary data, 			 * too. 			 * RFC3542 solved the ambiguity by introducing 			 * separate ancillary data or option types. 			 */
if|if
condition|(
name|opt
operator|->
name|ip6po_rthdr
operator|==
name|NULL
condition|)
name|newdest
operator|=
operator|&
name|opt
operator|->
name|ip6po_dest1
expr_stmt|;
else|else
name|newdest
operator|=
operator|&
name|opt
operator|->
name|ip6po_dest2
expr_stmt|;
break|break;
case|case
name|IPV6_RTHDRDSTOPTS
case|:
name|newdest
operator|=
operator|&
name|opt
operator|->
name|ip6po_dest1
expr_stmt|;
break|break;
case|case
name|IPV6_DSTOPTS
case|:
name|newdest
operator|=
operator|&
name|opt
operator|->
name|ip6po_dest2
expr_stmt|;
break|break;
block|}
comment|/* turn off the previous option, then set the new option. */
name|ip6_clearpktopts
argument_list|(
name|opt
argument_list|,
name|optname
argument_list|)
expr_stmt|;
operator|*
name|newdest
operator|=
name|malloc
argument_list|(
name|destlen
argument_list|,
name|M_IP6OPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|newdest
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|bcopy
argument_list|(
name|dest
argument_list|,
operator|*
name|newdest
argument_list|,
name|destlen
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IPV6_2292RTHDR
case|:
case|case
name|IPV6_RTHDR
case|:
block|{
name|struct
name|ip6_rthdr
modifier|*
name|rth
decl_stmt|;
name|int
name|rthlen
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|ip6_clearpktopts
argument_list|(
name|opt
argument_list|,
name|IPV6_RTHDR
argument_list|)
expr_stmt|;
break|break;
comment|/* just remove the option */
block|}
comment|/* message length validation */
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_rthdr
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rth
operator|=
operator|(
expr|struct
name|ip6_rthdr
operator|*
operator|)
name|buf
expr_stmt|;
name|rthlen
operator|=
operator|(
name|rth
operator|->
name|ip6r_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|rthlen
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|rth
operator|->
name|ip6r_type
condition|)
block|{
case|case
name|IPV6_RTHDR_TYPE_0
case|:
if|if
condition|(
name|rth
operator|->
name|ip6r_len
operator|==
literal|0
condition|)
comment|/* must contain one addr */
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|rth
operator|->
name|ip6r_len
operator|%
literal|2
condition|)
comment|/* length must be even */
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|rth
operator|->
name|ip6r_len
operator|/
literal|2
operator|!=
name|rth
operator|->
name|ip6r_segleft
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* not supported */
block|}
comment|/* turn off the previous option */
name|ip6_clearpktopts
argument_list|(
name|opt
argument_list|,
name|IPV6_RTHDR
argument_list|)
expr_stmt|;
name|opt
operator|->
name|ip6po_rthdr
operator|=
name|malloc
argument_list|(
name|rthlen
argument_list|,
name|M_IP6OPT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|ip6po_rthdr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|bcopy
argument_list|(
name|rth
argument_list|,
name|opt
operator|->
name|ip6po_rthdr
argument_list|,
name|rthlen
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IPV6_USE_MIN_MTU
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|minmtupolicy
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|minmtupolicy
operator|!=
name|IP6PO_MINMTU_MCASTONLY
operator|&&
name|minmtupolicy
operator|!=
name|IP6PO_MINMTU_DISABLE
operator|&&
name|minmtupolicy
operator|!=
name|IP6PO_MINMTU_ALL
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|opt
operator|->
name|ip6po_minmtu
operator|=
name|minmtupolicy
expr_stmt|;
break|break;
case|case
name|IPV6_DONTFRAG
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uproto
operator|==
name|IPPROTO_TCP
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|buf
operator|==
literal|0
condition|)
block|{
comment|/* 			 * we ignore this option for TCP sockets. 			 * (RFC3542 leaves this case unspecified.) 			 */
name|opt
operator|->
name|ip6po_flags
operator|&=
operator|~
name|IP6PO_DONTFRAG
expr_stmt|;
block|}
else|else
name|opt
operator|->
name|ip6po_flags
operator||=
name|IP6PO_DONTFRAG
expr_stmt|;
break|break;
case|case
name|IPV6_PREFER_TEMPADDR
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|preftemp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|preftemp
operator|!=
name|IP6PO_TEMPADDR_SYSTEM
operator|&&
name|preftemp
operator|!=
name|IP6PO_TEMPADDR_NOTPREFER
operator|&&
name|preftemp
operator|!=
name|IP6PO_TEMPADDR_PREFER
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|opt
operator|->
name|ip6po_prefer_tempaddr
operator|=
name|preftemp
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
block|}
comment|/* end of switch */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routine called from ip6_output() to loop back a copy of an IP6 multicast  * packet to the input queue of a specified interface.  Note that this  * calls the output routine of the loopback "driver", but with an interface  * pointer that might NOT be&loif -- easier than replicating that code here.  */
end_comment

begin_function
name|void
name|ip6_mloopback
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|copym
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|copym
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|copym
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Make sure to deep-copy IPv6 header portion in case the data 	 * is in an mbuf cluster, so that we can safely override the IPv6 	 * header portion later. 	 */
if|if
condition|(
operator|!
name|M_WRITABLE
argument_list|(
name|copym
argument_list|)
operator|||
name|copym
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|copym
operator|=
name|m_pullup
argument_list|(
name|copym
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copym
operator|==
name|NULL
condition|)
return|return;
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|copym
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * clear embedded scope identifiers if necessary. 	 * in6_clearscope will touch the addresses only when necessary. 	 */
name|in6_clearscope
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|copym
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA_IPV6
condition|)
block|{
name|copym
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID_IPV6
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|copym
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
name|if_simloop
argument_list|(
name|ifp
argument_list|,
name|copym
argument_list|,
name|AF_INET6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Chop IPv6 header off from the payload.  */
end_comment

begin_function
specifier|static
name|int
name|ip6_splithdr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ip6_exthdrs
modifier|*
name|exthdrs
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mh
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
condition|)
block|{
name|mh
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m_move_pkthdr
argument_list|(
name|mh
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|M_ALIGN
argument_list|(
name|mh
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|mh
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip6
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exthdrs
operator|->
name|ip6e_ip6
operator|=
name|m
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Compute IPv6 extension header length.  */
end_comment

begin_function
name|int
name|ip6_optlen
parameter_list|(
name|struct
name|inpcb
modifier|*
name|in6p
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|in6p
operator|->
name|in6p_outputopts
condition|)
return|return
literal|0
return|;
name|len
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|elen
parameter_list|(
name|x
parameter_list|)
define|\
value|(((struct ip6_ext *)(x)) ? (((struct ip6_ext *)(x))->ip6e_len + 1)<< 3 : 0)
name|len
operator|+=
name|elen
argument_list|(
name|in6p
operator|->
name|in6p_outputopts
operator|->
name|ip6po_hbh
argument_list|)
expr_stmt|;
if|if
condition|(
name|in6p
operator|->
name|in6p_outputopts
operator|->
name|ip6po_rthdr
condition|)
comment|/* dest1 is valid with rthdr only */
name|len
operator|+=
name|elen
argument_list|(
name|in6p
operator|->
name|in6p_outputopts
operator|->
name|ip6po_dest1
argument_list|)
expr_stmt|;
name|len
operator|+=
name|elen
argument_list|(
name|in6p
operator|->
name|in6p_outputopts
operator|->
name|ip6po_rthdr
argument_list|)
expr_stmt|;
name|len
operator|+=
name|elen
argument_list|(
name|in6p
operator|->
name|in6p_outputopts
operator|->
name|ip6po_dest2
argument_list|)
expr_stmt|;
return|return
name|len
return|;
undef|#
directive|undef
name|elen
block|}
end_function

end_unit

