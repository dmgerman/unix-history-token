begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$KAME: ip6_output.c,v 1.180 2001/05/21 05:37:50 jinmei Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1988, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)ip_output.c	8.3 (Berkeley) 1/21/94  */
end_comment

begin_include
include|#
directive|include
file|"opt_ip6fw.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netkey/key.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPSEC */
end_comment

begin_include
include|#
directive|include
file|<netinet6/ip6_fw.h>
end_include

begin_include
include|#
directive|include
file|<net/net_osdep.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IPMOPTS
argument_list|,
literal|"ip6_moptions"
argument_list|,
literal|"internet multicast options"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|ip6_exthdrs
block|{
name|struct
name|mbuf
modifier|*
name|ip6e_ip6
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ip6e_hbh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ip6e_dest1
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ip6e_rthdr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ip6e_dest2
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|ip6_pcbopts
name|__P
argument_list|(
operator|(
expr|struct
name|ip6_pktopts
operator|*
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|sockopt
operator|*
name|sopt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip6_setmoptions
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|ip6_moptions
operator|*
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip6_getmoptions
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|ip6_moptions
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip6_copyexthdr
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|,
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip6_insertfraghdr
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|int
operator|,
expr|struct
name|ip6_frag
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip6_insert_jumboopt
name|__P
argument_list|(
operator|(
expr|struct
name|ip6_exthdrs
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip6_splithdr
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|ip6_exthdrs
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * IP6 output. The packet in mbuf chain m contains a skeletal IP6  * header (with pri, len, nxt, hlim, src, dst).  * This function may modify ver and hlim only.  * The mbuf chain containing the packet will be freed.  * The mbuf opt, if present, will not be freed.  *  * type of "mtu": rt_rmx.rmx_mtu is u_long, ifnet.ifr_mtu is int, and  * nd_ifinfo.linkmtu is u_int32_t.  so we use u_long to hold largest one,  * which is rt_rmx.rmx_mtu.  */
end_comment

begin_function
name|int
name|ip6_output
parameter_list|(
name|m0
parameter_list|,
name|opt
parameter_list|,
name|ro
parameter_list|,
name|flags
parameter_list|,
name|im6o
parameter_list|,
name|ifpp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|ip6_pktopts
modifier|*
name|opt
decl_stmt|;
name|struct
name|route_in6
modifier|*
name|ro
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|ip6_moptions
modifier|*
name|im6o
decl_stmt|;
name|struct
name|ifnet
modifier|*
modifier|*
name|ifpp
decl_stmt|;
comment|/* XXX: just for statistics */
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|,
modifier|*
name|mhip6
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|origifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|int
name|hlen
decl_stmt|,
name|tlen
decl_stmt|,
name|len
decl_stmt|,
name|off
decl_stmt|;
name|struct
name|route_in6
name|ip6route
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|dst
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia
init|=
name|NULL
decl_stmt|;
name|u_long
name|mtu
decl_stmt|;
name|u_int32_t
name|optlen
init|=
literal|0
decl_stmt|,
name|plen
init|=
literal|0
decl_stmt|,
name|unfragpartlen
init|=
literal|0
decl_stmt|;
name|struct
name|ip6_exthdrs
name|exthdrs
decl_stmt|;
name|struct
name|in6_addr
name|finaldst
decl_stmt|;
name|struct
name|route_in6
modifier|*
name|ro_pmtu
init|=
name|NULL
decl_stmt|;
name|int
name|hdrsplit
init|=
literal|0
decl_stmt|;
name|int
name|needipsec
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|IPSEC
name|int
name|needipsectun
init|=
literal|0
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
init|=
name|NULL
decl_stmt|;
comment|/* for AH processing. stupid to have "socket" variable in IP layer... */
name|so
operator|=
name|ipsec_getsocket
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ipsec_setsocket
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IPSEC */
define|#
directive|define
name|MAKE_EXTHDR
parameter_list|(
name|hp
parameter_list|,
name|mp
parameter_list|)
define|\
value|do {								\ 	if (hp) {							\ 		struct ip6_ext *eh = (struct ip6_ext *)(hp);		\ 		error = ip6_copyexthdr((mp), (caddr_t)(hp), 		\ 				       ((eh)->ip6e_len + 1)<< 3);	\ 		if (error)						\ 			goto freehdrs;					\ 	}								\     } while (0)
name|bzero
argument_list|(
operator|&
name|exthdrs
argument_list|,
sizeof|sizeof
argument_list|(
name|exthdrs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
condition|)
block|{
comment|/* Hop-by-Hop options header */
name|MAKE_EXTHDR
argument_list|(
name|opt
operator|->
name|ip6po_hbh
argument_list|,
operator|&
name|exthdrs
operator|.
name|ip6e_hbh
argument_list|)
expr_stmt|;
comment|/* Destination options header(1st part) */
name|MAKE_EXTHDR
argument_list|(
name|opt
operator|->
name|ip6po_dest1
argument_list|,
operator|&
name|exthdrs
operator|.
name|ip6e_dest1
argument_list|)
expr_stmt|;
comment|/* Routing header */
name|MAKE_EXTHDR
argument_list|(
name|opt
operator|->
name|ip6po_rthdr
argument_list|,
operator|&
name|exthdrs
operator|.
name|ip6e_rthdr
argument_list|)
expr_stmt|;
comment|/* Destination options header(2nd part) */
name|MAKE_EXTHDR
argument_list|(
name|opt
operator|->
name|ip6po_dest2
argument_list|,
operator|&
name|exthdrs
operator|.
name|ip6e_dest2
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPSEC
comment|/* get a security policy for this packet */
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
name|sp
operator|=
name|ipsec6_getpolicybyaddr
argument_list|(
name|m
argument_list|,
name|IPSEC_DIR_OUTBOUND
argument_list|,
literal|0
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
else|else
name|sp
operator|=
name|ipsec6_getpolicybysock
argument_list|(
name|m
argument_list|,
name|IPSEC_DIR_OUTBOUND
argument_list|,
name|so
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|ipsec6stat
operator|.
name|out_inval
operator|++
expr_stmt|;
goto|goto
name|freehdrs
goto|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
comment|/* check policy */
switch|switch
condition|(
name|sp
operator|->
name|policy
condition|)
block|{
case|case
name|IPSEC_POLICY_DISCARD
case|:
comment|/* 		 * This packet is just discarded. 		 */
name|ipsec6stat
operator|.
name|out_polvio
operator|++
expr_stmt|;
goto|goto
name|freehdrs
goto|;
case|case
name|IPSEC_POLICY_BYPASS
case|:
case|case
name|IPSEC_POLICY_NONE
case|:
comment|/* no need to do IPsec. */
name|needipsec
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPSEC_POLICY_IPSEC
case|:
if|if
condition|(
name|sp
operator|->
name|req
operator|==
name|NULL
condition|)
block|{
comment|/* acquire a policy */
name|error
operator|=
name|key_spdacquire
argument_list|(
name|sp
argument_list|)
expr_stmt|;
goto|goto
name|freehdrs
goto|;
block|}
name|needipsec
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IPSEC_POLICY_ENTRUST
case|:
default|default:
name|printf
argument_list|(
literal|"ip6_output: Invalid policy found. %d\n"
argument_list|,
name|sp
operator|->
name|policy
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPSEC */
comment|/* 	 * Calculate the total length of the extension header chain. 	 * Keep the length of the unfragmentable part for fragmentation. 	 */
name|optlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_hbh
condition|)
name|optlen
operator|+=
name|exthdrs
operator|.
name|ip6e_hbh
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_dest1
condition|)
name|optlen
operator|+=
name|exthdrs
operator|.
name|ip6e_dest1
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_rthdr
condition|)
name|optlen
operator|+=
name|exthdrs
operator|.
name|ip6e_rthdr
operator|->
name|m_len
expr_stmt|;
name|unfragpartlen
operator|=
name|optlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
comment|/* NOTE: we don't add AH/ESP length here. do that later. */
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_dest2
condition|)
name|optlen
operator|+=
name|exthdrs
operator|.
name|ip6e_dest2
operator|->
name|m_len
expr_stmt|;
comment|/* 	 * If we need IPsec, or there is at least one extension header, 	 * separate IP6 header from the payload. 	 */
if|if
condition|(
operator|(
name|needipsec
operator|||
name|optlen
operator|)
operator|&&
operator|!
name|hdrsplit
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|ip6_splithdr
argument_list|(
name|m
argument_list|,
operator|&
name|exthdrs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
goto|goto
name|freehdrs
goto|;
block|}
name|m
operator|=
name|exthdrs
operator|.
name|ip6e_ip6
expr_stmt|;
name|hdrsplit
operator|++
expr_stmt|;
block|}
comment|/* adjust pointer */
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
comment|/* adjust mbuf packet header length */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|optlen
expr_stmt|;
name|plen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
expr_stmt|;
comment|/* If this is a jumbo payload, insert a jumbo payload option. */
if|if
condition|(
name|plen
operator|>
name|IPV6_MAXPACKET
condition|)
block|{
if|if
condition|(
operator|!
name|hdrsplit
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|ip6_splithdr
argument_list|(
name|m
argument_list|,
operator|&
name|exthdrs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
goto|goto
name|freehdrs
goto|;
block|}
name|m
operator|=
name|exthdrs
operator|.
name|ip6e_ip6
expr_stmt|;
name|hdrsplit
operator|++
expr_stmt|;
block|}
comment|/* adjust pointer */
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ip6_insert_jumboopt
argument_list|(
operator|&
name|exthdrs
argument_list|,
name|plen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|freehdrs
goto|;
name|ip6
operator|->
name|ip6_plen
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ip6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
comment|/* 	 * Concatenate headers and fill in next header fields. 	 * Here we have, on "m" 	 *	IPv6 payload 	 * and we insert headers accordingly.  Finally, we should be getting: 	 *	IPv6 hbh dest1 rthdr ah* [esp* dest2 payload] 	 * 	 * during the header composing process, "m" points to IPv6 header. 	 * "mprev" points to an extension header prior to esp. 	 */
block|{
name|u_char
modifier|*
name|nexthdrp
init|=
operator|&
name|ip6
operator|->
name|ip6_nxt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mprev
init|=
name|m
decl_stmt|;
comment|/* 		 * we treat dest2 specially.  this makes IPsec processing 		 * much easier. 		 * 		 * result: IPv6 dest2 payload 		 * m and mprev will point to IPv6 header. 		 */
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_dest2
condition|)
block|{
if|if
condition|(
operator|!
name|hdrsplit
condition|)
name|panic
argument_list|(
literal|"assumption failed: hdr not split"
argument_list|)
expr_stmt|;
name|exthdrs
operator|.
name|ip6e_dest2
operator|->
name|m_next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|exthdrs
operator|.
name|ip6e_dest2
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_dest2
argument_list|,
name|u_char
operator|*
argument_list|)
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|ip6
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_DSTOPTS
expr_stmt|;
block|}
define|#
directive|define
name|MAKE_CHAIN
parameter_list|(
name|m
parameter_list|,
name|mp
parameter_list|,
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|do {\ 	if (m) {\ 		if (!hdrsplit) \ 			panic("assumption failed: hdr not split"); \ 		*mtod((m), u_char *) = *(p);\ 		*(p) = (i);\ 		p = mtod((m), u_char *);\ 		(m)->m_next = (mp)->m_next;\ 		(mp)->m_next = (m);\ 		(mp) = (m);\ 	}\     } while (0)
comment|/* 		 * result: IPv6 hbh dest1 rthdr dest2 payload 		 * m will point to IPv6 header.  mprev will point to the 		 * extension header prior to dest2 (rthdr in the above case). 		 */
name|MAKE_CHAIN
argument_list|(
name|exthdrs
operator|.
name|ip6e_hbh
argument_list|,
name|mprev
argument_list|,
name|nexthdrp
argument_list|,
name|IPPROTO_HOPOPTS
argument_list|)
expr_stmt|;
name|MAKE_CHAIN
argument_list|(
name|exthdrs
operator|.
name|ip6e_dest1
argument_list|,
name|mprev
argument_list|,
name|nexthdrp
argument_list|,
name|IPPROTO_DSTOPTS
argument_list|)
expr_stmt|;
name|MAKE_CHAIN
argument_list|(
name|exthdrs
operator|.
name|ip6e_rthdr
argument_list|,
name|mprev
argument_list|,
name|nexthdrp
argument_list|,
name|IPPROTO_ROUTING
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC
if|if
condition|(
operator|!
name|needipsec
condition|)
goto|goto
name|skip_ipsec2
goto|;
comment|/* 		 * pointers after IPsec headers are not valid any more. 		 * other pointers need a great care too. 		 * (IPsec routines should not mangle mbufs prior to AH/ESP) 		 */
name|exthdrs
operator|.
name|ip6e_dest2
operator|=
name|NULL
expr_stmt|;
block|{
name|struct
name|ip6_rthdr
modifier|*
name|rh
init|=
name|NULL
decl_stmt|;
name|int
name|segleft_org
init|=
literal|0
decl_stmt|;
name|struct
name|ipsec_output_state
name|state
decl_stmt|;
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_rthdr
condition|)
block|{
name|rh
operator|=
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_rthdr
argument_list|,
expr|struct
name|ip6_rthdr
operator|*
argument_list|)
expr_stmt|;
name|segleft_org
operator|=
name|rh
operator|->
name|ip6r_segleft
expr_stmt|;
name|rh
operator|->
name|ip6r_segleft
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|.
name|m
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|ipsec6_output_trans
argument_list|(
operator|&
name|state
argument_list|,
name|nexthdrp
argument_list|,
name|mprev
argument_list|,
name|sp
argument_list|,
name|flags
argument_list|,
operator|&
name|needipsectun
argument_list|)
expr_stmt|;
name|m
operator|=
name|state
operator|.
name|m
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* mbuf is already reclaimed in ipsec6_output_trans. */
name|m
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|EHOSTUNREACH
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|EMSGSIZE
case|:
case|case
name|ENOBUFS
case|:
case|case
name|ENOMEM
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"ip6_output (ipsec): error code %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/*fall through*/
case|case
name|ENOENT
case|:
comment|/* don't show these error codes to the user */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_rthdr
condition|)
block|{
comment|/* ah6_output doesn't modify mbuf chain */
name|rh
operator|->
name|ip6r_segleft
operator|=
name|segleft_org
expr_stmt|;
block|}
block|}
name|skip_ipsec2
label|:
empty_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * If there is a routing header, replace destination address field 	 * with the first hop of the routing header. 	 */
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_rthdr
condition|)
block|{
name|struct
name|ip6_rthdr
modifier|*
name|rh
init|=
operator|(
expr|struct
name|ip6_rthdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_rthdr
argument_list|,
expr|struct
name|ip6_rthdr
operator|*
argument_list|)
operator|)
decl_stmt|;
name|struct
name|ip6_rthdr0
modifier|*
name|rh0
decl_stmt|;
name|finaldst
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
switch|switch
condition|(
name|rh
operator|->
name|ip6r_type
condition|)
block|{
case|case
name|IPV6_RTHDR_TYPE_0
case|:
name|rh0
operator|=
operator|(
expr|struct
name|ip6_rthdr0
operator|*
operator|)
name|rh
expr_stmt|;
name|ip6
operator|->
name|ip6_dst
operator|=
name|rh0
operator|->
name|ip6r0_addr
index|[
literal|0
index|]
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rh0
operator|->
name|ip6r0_addr
index|[
literal|1
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rh0
operator|->
name|ip6r0_addr
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|*
operator|(
name|rh0
operator|->
name|ip6r0_segleft
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|rh0
operator|->
name|ip6r0_addr
index|[
name|rh0
operator|->
name|ip6r0_segleft
operator|-
literal|1
index|]
operator|=
name|finaldst
expr_stmt|;
break|break;
default|default:
comment|/* is it possible? */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
comment|/* Source address validation */
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|IPV6_DADOUTPUT
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip6stat
operator|.
name|ip6s_localout
operator|++
expr_stmt|;
comment|/* 	 * Route packet. 	 */
if|if
condition|(
name|ro
operator|==
literal|0
condition|)
block|{
name|ro
operator|=
operator|&
name|ip6route
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ro
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ro
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ro_pmtu
operator|=
name|ro
expr_stmt|;
if|if
condition|(
name|opt
operator|&&
name|opt
operator|->
name|ip6po_rthdr
condition|)
name|ro
operator|=
operator|&
name|opt
operator|->
name|ip6po_route
expr_stmt|;
name|dst
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
expr_stmt|;
comment|/* 	 * If there is a cached route, 	 * check that it is to the same destination 	 * and is still up. If not, free it and try again. 	 */
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|&&
operator|(
operator|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
operator|||
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|)
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|dst
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
ifdef|#
directive|ifdef
name|SCOPEDROUTING
comment|/* XXX: sin6_scope_id should already be fixed at this point */
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|)
condition|)
name|dst
operator|->
name|sin6_scope_id
operator|=
name|ntohs
argument_list|(
name|dst
operator|->
name|sin6_addr
operator|.
name|s6_addr16
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|IPSEC
if|if
condition|(
name|needipsec
operator|&&
name|needipsectun
condition|)
block|{
name|struct
name|ipsec_output_state
name|state
decl_stmt|;
comment|/* 		 * All the extension headers will become inaccessible 		 * (since they can be encrypted). 		 * Don't panic, we need no more updates to extension headers 		 * on inner IPv6 packet (since they are now encapsulated). 		 * 		 * IPv6 [ESP|AH] IPv6 [extension headers] payload 		 */
name|bzero
argument_list|(
operator|&
name|exthdrs
argument_list|,
sizeof|sizeof
argument_list|(
name|exthdrs
argument_list|)
argument_list|)
expr_stmt|;
name|exthdrs
operator|.
name|ip6e_ip6
operator|=
name|m
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|.
name|m
operator|=
name|m
expr_stmt|;
name|state
operator|.
name|ro
operator|=
operator|(
expr|struct
name|route
operator|*
operator|)
name|ro
expr_stmt|;
name|state
operator|.
name|dst
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
expr_stmt|;
name|error
operator|=
name|ipsec6_output_tunnel
argument_list|(
operator|&
name|state
argument_list|,
name|sp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|m
operator|=
name|state
operator|.
name|m
expr_stmt|;
name|ro
operator|=
operator|(
expr|struct
name|route_in6
operator|*
operator|)
name|state
operator|.
name|ro
expr_stmt|;
name|dst
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|state
operator|.
name|dst
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* mbuf is already reclaimed in ipsec6_output_tunnel. */
name|m0
operator|=
name|m
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|EHOSTUNREACH
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|EMSGSIZE
case|:
case|case
name|ENOBUFS
case|:
case|case
name|ENOMEM
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"ip6_output (ipsec): error code %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/*fall through*/
case|case
name|ENOENT
case|:
comment|/* don't show these error codes to the user */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
goto|goto
name|bad
goto|;
block|}
name|exthdrs
operator|.
name|ip6e_ip6
operator|=
name|m
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*IPSEC*/
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
comment|/* Unicast */
define|#
directive|define
name|ifatoia6
parameter_list|(
name|ifa
parameter_list|)
value|((struct in6_ifaddr *)(ifa))
define|#
directive|define
name|sin6tosa
parameter_list|(
name|sin6
parameter_list|)
value|((struct sockaddr *)(sin6))
comment|/* xxx 		 * interface selection comes here 		 * if an interface is specified from an upper layer, 		 * ifp must point it. 		 */
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
literal|0
condition|)
block|{
comment|/* 			 * non-bsdi always clone routes, if parent is 			 * PRF_CLONING. 			 */
name|rtalloc
argument_list|(
operator|(
expr|struct
name|route
operator|*
operator|)
name|ro
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
literal|0
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_noroute
operator|++
expr_stmt|;
name|error
operator|=
name|EHOSTUNREACH
expr_stmt|;
comment|/* XXX in6_ifstat_inc(ifp, ifs6_out_discard); */
goto|goto
name|bad
goto|;
block|}
name|ia
operator|=
name|ifatoia6
argument_list|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifa
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|->
name|rt_use
operator|++
expr_stmt|;
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
name|dst
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ro
operator|->
name|ro_rt
operator|->
name|rt_gateway
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
expr_stmt|;
comment|/* just in case */
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_request
argument_list|)
expr_stmt|;
comment|/* 		 * Check if the outgoing interface conflicts with 		 * the interface specified by ifi6_ifindex (if specified). 		 * Note that loopback interface is always okay. 		 * (this may happen when we are sending a packet to one of 		 *  our own addresses.) 		 */
if|if
condition|(
name|opt
operator|&&
name|opt
operator|->
name|ip6po_pktinfo
operator|&&
name|opt
operator|->
name|ip6po_pktinfo
operator|->
name|ipi6_ifindex
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|&&
name|ifp
operator|->
name|if_index
operator|!=
name|opt
operator|->
name|ip6po_pktinfo
operator|->
name|ipi6_ifindex
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_noroute
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_discard
argument_list|)
expr_stmt|;
name|error
operator|=
name|EHOSTUNREACH
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|opt
operator|&&
name|opt
operator|->
name|ip6po_hlim
operator|!=
operator|-
literal|1
condition|)
name|ip6
operator|->
name|ip6_hlim
operator|=
name|opt
operator|->
name|ip6po_hlim
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
comment|/* Multicast */
name|struct
name|in6_multi
modifier|*
name|in6m
decl_stmt|;
name|m
operator|->
name|m_flags
operator|=
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|~
name|M_BCAST
operator|)
operator||
name|M_MCAST
expr_stmt|;
comment|/* 		 * See if the caller provided any multicast options 		 */
name|ifp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|im6o
operator|!=
name|NULL
condition|)
block|{
name|ip6
operator|->
name|ip6_hlim
operator|=
name|im6o
operator|->
name|im6o_multicast_hlim
expr_stmt|;
if|if
condition|(
name|im6o
operator|->
name|im6o_multicast_ifp
operator|!=
name|NULL
condition|)
name|ifp
operator|=
name|im6o
operator|->
name|im6o_multicast_ifp
expr_stmt|;
block|}
else|else
name|ip6
operator|->
name|ip6_hlim
operator|=
name|ip6_defmcasthlim
expr_stmt|;
comment|/* 		 * See if the caller provided the outgoing interface 		 * as an ancillary data. 		 * Boundary check for ifindex is assumed to be already done. 		 */
if|if
condition|(
name|opt
operator|&&
name|opt
operator|->
name|ip6po_pktinfo
operator|&&
name|opt
operator|->
name|ip6po_pktinfo
operator|->
name|ipi6_ifindex
condition|)
name|ifp
operator|=
name|ifindex2ifnet
index|[
name|opt
operator|->
name|ip6po_pktinfo
operator|->
name|ipi6_ifindex
index|]
expr_stmt|;
comment|/* 		 * If the destination is a node-local scope multicast, 		 * the packet should be loop-backed only. 		 */
if|if
condition|(
name|IN6_IS_ADDR_MC_NODELOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
comment|/* 			 * If the outgoing interface is already specified, 			 * it should be a loopback interface. 			 */
if|if
condition|(
name|ifp
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|==
literal|0
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badscope
operator|++
expr_stmt|;
name|error
operator|=
name|ENETUNREACH
expr_stmt|;
comment|/* XXX: better error? */
comment|/* XXX correct ifp? */
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_discard
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
else|else
block|{
name|ifp
operator|=
operator|&
name|loif
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|opt
operator|&&
name|opt
operator|->
name|ip6po_hlim
operator|!=
operator|-
literal|1
condition|)
name|ip6
operator|->
name|ip6_hlim
operator|=
name|opt
operator|->
name|ip6po_hlim
operator|&
literal|0xff
expr_stmt|;
comment|/* 		 * If caller did not provide an interface lookup a 		 * default in the routing table.  This is either a 		 * default for the speicfied group (i.e. a host 		 * route), or a multicast default (a route for the 		 * ``net'' ff00::/8). 		 */
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
literal|0
condition|)
block|{
name|ro
operator|->
name|ro_rt
operator|=
name|rtalloc1
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
argument_list|,
literal|0
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
literal|0
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_noroute
operator|++
expr_stmt|;
name|error
operator|=
name|EHOSTUNREACH
expr_stmt|;
comment|/* XXX in6_ifstat_inc(ifp, ifs6_out_discard) */
goto|goto
name|bad
goto|;
block|}
name|ia
operator|=
name|ifatoia6
argument_list|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifa
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|->
name|rt_use
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|IPV6_FORWARDING
operator|)
operator|==
literal|0
condition|)
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_request
argument_list|)
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_mcast
argument_list|)
expr_stmt|;
comment|/* 		 * Confirm that the outgoing interface supports multicast. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_noroute
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_discard
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENETUNREACH
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|IN6_LOOKUP_MULTI
argument_list|(
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|ifp
argument_list|,
name|in6m
argument_list|)
expr_stmt|;
if|if
condition|(
name|in6m
operator|!=
name|NULL
operator|&&
operator|(
name|im6o
operator|==
name|NULL
operator|||
name|im6o
operator|->
name|im6o_multicast_loop
operator|)
condition|)
block|{
comment|/* 			 * If we belong to the destination multicast group 			 * on the outgoing interface, and the caller did not 			 * forbid loopback, loop back a copy. 			 */
name|ip6_mloopback
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If we are acting as a multicast router, perform 			 * multicast forwarding as if the packet had just 			 * arrived on the interface to which we are about 			 * to send.  The multicast forwarding function 			 * recursively calls this function, using the 			 * IPV6_FORWARDING flag to prevent infinite recursion. 			 * 			 * Multicasts that are looped back by ip6_mloopback(), 			 * above, will be forwarded by the ip6_input() routine, 			 * if necessary. 			 */
if|if
condition|(
name|ip6_mrouter
operator|&&
operator|(
name|flags
operator|&
name|IPV6_FORWARDING
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ip6_mforward
argument_list|(
name|ip6
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
comment|/* 		 * Multicasts with a hoplimit of zero may be looped back, 		 * above, but must not be transmitted on a network. 		 * Also, multicasts addressed to the loopback interface 		 * are not sent -- the above call to ip6_mloopback() will 		 * loop back a copy if this host actually belongs to the 		 * destination group on the loopback interface. 		 */
if|if
condition|(
name|ip6
operator|->
name|ip6_hlim
operator|==
literal|0
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 	 * Fill the outgoing inteface to tell the upper layer 	 * to increment per-interface statistics. 	 */
if|if
condition|(
name|ifpp
condition|)
operator|*
name|ifpp
operator|=
name|ifp
expr_stmt|;
comment|/* 	 * Determine path MTU. 	 */
if|if
condition|(
name|ro_pmtu
operator|!=
name|ro
condition|)
block|{
comment|/* The first hop and the final destination may differ. */
name|struct
name|sockaddr_in6
modifier|*
name|sin6_fin
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro_pmtu
operator|->
name|ro_dst
decl_stmt|;
if|if
condition|(
name|ro_pmtu
operator|->
name|ro_rt
operator|&&
operator|(
operator|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
operator|||
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|sin6_fin
operator|->
name|sin6_addr
argument_list|,
operator|&
name|finaldst
argument_list|)
operator|)
condition|)
block|{
name|RTFREE
argument_list|(
name|ro_pmtu
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro_pmtu
operator|->
name|ro_rt
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ro_pmtu
operator|->
name|ro_rt
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|sin6_fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin6_fin
argument_list|)
argument_list|)
expr_stmt|;
name|sin6_fin
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6_fin
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6_fin
operator|->
name|sin6_addr
operator|=
name|finaldst
expr_stmt|;
name|rtalloc
argument_list|(
operator|(
expr|struct
name|route
operator|*
operator|)
name|ro_pmtu
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ro_pmtu
operator|->
name|ro_rt
operator|!=
name|NULL
condition|)
block|{
name|u_int32_t
name|ifmtu
init|=
name|nd_ifinfo
index|[
name|ifp
operator|->
name|if_index
index|]
operator|.
name|linkmtu
decl_stmt|;
name|mtu
operator|=
name|ro_pmtu
operator|->
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
expr_stmt|;
if|if
condition|(
name|mtu
operator|>
name|ifmtu
operator|||
name|mtu
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The MTU on the route is larger than the MTU on 			 * the interface!  This shouldn't happen, unless the 			 * MTU of the interface has been changed after the 			 * interface was brought up.  Change the MTU in the 			 * route to match the interface MTU (as long as the 			 * field isn't locked). 			 * 			 * if MTU on the route is 0, we need to fix the MTU. 			 * this case happens with path MTU discovery timeouts. 			 */
name|mtu
operator|=
name|ifmtu
expr_stmt|;
if|if
condition|(
operator|(
name|ro_pmtu
operator|->
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_locks
operator|&
name|RTV_MTU
operator|)
operator|==
literal|0
condition|)
name|ro_pmtu
operator|->
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|=
name|mtu
expr_stmt|;
comment|/* XXX */
block|}
block|}
else|else
block|{
name|mtu
operator|=
name|nd_ifinfo
index|[
name|ifp
operator|->
name|if_index
index|]
operator|.
name|linkmtu
expr_stmt|;
block|}
comment|/* 	 * advanced API (IPV6_USE_MIN_MTU) overrides mtu setting 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|IPV6_MINMTU
operator|)
operator|!=
literal|0
operator|&&
name|mtu
operator|>
name|IPV6_MMTU
condition|)
name|mtu
operator|=
name|IPV6_MMTU
expr_stmt|;
comment|/* Fake scoped addresses */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If source or destination address is a scoped address, and 		 * the packet is going to be sent to a loopback interface, 		 * we should keep the original interface. 		 */
comment|/* 		 * XXX: this is a very experimental and temporary solution. 		 * We eventually have sockaddr_in6 and use the sin6_scope_id 		 * field of the structure here. 		 * We rely on the consistency between two scope zone ids 		 * of source add destination, which should already be assured 		 * larger scopes than link will be supported in the near 		 * future. 		 */
name|origifp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
name|origifp
operator|=
name|ifindex2ifnet
index|[
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_src
operator|.
name|s6_addr16
index|[
literal|1
index|]
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
name|origifp
operator|=
name|ifindex2ifnet
index|[
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_dst
operator|.
name|s6_addr16
index|[
literal|1
index|]
argument_list|)
index|]
expr_stmt|;
comment|/* 		 * XXX: origifp can be NULL even in those two cases above. 		 * For example, if we remove the (only) link-local address 		 * from the loopback interface, and try to send a link-local 		 * address without link-id information.  Then the source 		 * address is ::1, and the destination address is the 		 * link-local address with its s6_addr16[1] being zero. 		 * What is worse, if the packet goes to the loopback interface 		 * by a default rejected route, the null pointer would be 		 * passed to looutput, and the kernel would hang. 		 * The following last resort would prevent such disaster. 		 */
if|if
condition|(
name|origifp
operator|==
name|NULL
condition|)
name|origifp
operator|=
name|ifp
expr_stmt|;
block|}
else|else
name|origifp
operator|=
name|ifp
expr_stmt|;
ifndef|#
directive|ifndef
name|SCOPEDROUTING
comment|/* 	 * clear embedded scope identifiers if necessary. 	 * in6_clearscope will touch the addresses only when necessary. 	 */
name|in6_clearscope
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Check with the firewall... 	 */
if|if
condition|(
name|ip6_fw_enable
operator|&&
name|ip6_fw_chk_ptr
condition|)
block|{
name|u_short
name|port
init|=
literal|0
decl_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
comment|/*XXX*/
comment|/* If ipfw says divert, we have to just drop packet */
if|if
condition|(
call|(
modifier|*
name|ip6_fw_chk_ptr
call|)
argument_list|(
operator|&
name|ip6
argument_list|,
name|ifp
argument_list|,
operator|&
name|port
argument_list|,
operator|&
name|m
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 	 * If the outgoing packet contains a hop-by-hop options header, 	 * it must be examined and processed even by the source node. 	 * (RFC 2460, section 4.) 	 */
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_hbh
condition|)
block|{
name|struct
name|ip6_hbh
modifier|*
name|hbh
init|=
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_hbh
argument_list|,
expr|struct
name|ip6_hbh
operator|*
argument_list|)
decl_stmt|;
name|u_int32_t
name|dummy1
decl_stmt|;
comment|/* XXX unused */
name|u_int32_t
name|dummy2
decl_stmt|;
comment|/* XXX unused */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
operator|>
name|exthdrs
operator|.
name|ip6e_hbh
operator|->
name|m_len
condition|)
name|panic
argument_list|(
literal|"ip6e_hbh is not continuous"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 *  XXX: if we have to send an ICMPv6 error to the sender, 		 *       we need the M_LOOP flag since icmp6_error() expects 		 *       the IPv6 and the hop-by-hop options header are 		 *       continuous unless the flag is set. 		 */
name|m
operator|->
name|m_flags
operator||=
name|M_LOOP
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|ip6_process_hopopts
argument_list|(
name|m
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|hbh
operator|+
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
argument_list|,
operator|&
name|dummy1
argument_list|,
operator|&
name|dummy2
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* m was already freed at this point */
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* better error? */
goto|goto
name|done
goto|;
block|}
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_LOOP
expr_stmt|;
comment|/* XXX */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Send the packet to the outgoing interface. 	 * If necessary, do IPv6 fragmentation before sending. 	 */
name|tlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|tlen
operator|<=
name|mtu
ifdef|#
directive|ifdef
name|notyet
comment|/* 	     * On any link that cannot convey a 1280-octet packet in one piece, 	     * link-specific fragmentation and reassembly must be provided at 	     * a layer below IPv6. [RFC 2460, sec.5] 	     * Thus if the interface has ability of link-level fragmentation, 	     * we can just send the packet even if the packet size is 	     * larger than the link's MTU. 	     * XXX: IFF_FRAGMENTABLE (or such) flag has not been defined yet... 	     */
operator|||
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_FRAGMENTABLE
endif|#
directive|endif
condition|)
block|{
comment|/* Record statistics for this interface address. */
if|if
condition|(
name|ia
operator|&&
operator|!
operator|(
name|flags
operator|&
name|IPV6_FORWARDING
operator|)
condition|)
block|{
name|ia
operator|->
name|ia_ifa
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|ia
operator|->
name|ia_ifa
operator|.
name|if_obytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPSEC
comment|/* clean ipsec history once it goes out of the node */
name|ipsec_delaux
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|nd6_output
argument_list|(
name|ifp
argument_list|,
name|origifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|mtu
operator|<
name|IPV6_MMTU
condition|)
block|{
comment|/* 		 * note that path MTU is never less than IPV6_MMTU 		 * (see icmp6_input). 		 */
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_fragfail
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
elseif|else
if|if
condition|(
name|ip6
operator|->
name|ip6_plen
operator|==
literal|0
condition|)
block|{
comment|/* jumbo payload cannot be fragmented */
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_fragfail
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
modifier|*
name|mnext
decl_stmt|,
modifier|*
name|m_frgpart
decl_stmt|;
name|struct
name|ip6_frag
modifier|*
name|ip6f
decl_stmt|;
name|u_int32_t
name|id
init|=
name|htonl
argument_list|(
name|ip6_id
operator|++
argument_list|)
decl_stmt|;
name|u_char
name|nextproto
decl_stmt|;
comment|/* 		 * Too large for the destination or interface; 		 * fragment if possible. 		 * Must be able to put at least 8 bytes per fragment. 		 */
name|hlen
operator|=
name|unfragpartlen
expr_stmt|;
if|if
condition|(
name|mtu
operator|>
name|IPV6_MAXPACKET
condition|)
name|mtu
operator|=
name|IPV6_MAXPACKET
expr_stmt|;
name|len
operator|=
operator|(
name|mtu
operator|-
name|hlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|8
condition|)
block|{
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_fragfail
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|mnext
operator|=
operator|&
name|m
operator|->
name|m_nextpkt
expr_stmt|;
comment|/* 		 * Change the next header field of the last header in the 		 * unfragmentable part. 		 */
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_rthdr
condition|)
block|{
name|nextproto
operator|=
operator|*
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_rthdr
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_rthdr
argument_list|,
name|u_char
operator|*
argument_list|)
operator|=
name|IPPROTO_FRAGMENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_dest1
condition|)
block|{
name|nextproto
operator|=
operator|*
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_dest1
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_dest1
argument_list|,
name|u_char
operator|*
argument_list|)
operator|=
name|IPPROTO_FRAGMENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exthdrs
operator|.
name|ip6e_hbh
condition|)
block|{
name|nextproto
operator|=
operator|*
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_hbh
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|exthdrs
operator|.
name|ip6e_hbh
argument_list|,
name|u_char
operator|*
argument_list|)
operator|=
name|IPPROTO_FRAGMENT
expr_stmt|;
block|}
else|else
block|{
name|nextproto
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|ip6
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_FRAGMENT
expr_stmt|;
block|}
comment|/* 		 * Loop through length of segment after first fragment, 		 * make new header and copy data of each part and link onto chain. 		 */
name|m0
operator|=
name|m
expr_stmt|;
for|for
control|(
name|off
operator|=
name|hlen
init|;
name|off
operator|<
name|tlen
condition|;
name|off
operator|+=
name|len
control|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
name|ip6stat
operator|.
name|ip6s_odropped
operator|++
expr_stmt|;
goto|goto
name|sendorfree
goto|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_flags
operator|=
name|m0
operator|->
name|m_flags
operator|&
name|M_COPYFLAGS
expr_stmt|;
operator|*
name|mnext
operator|=
name|m
expr_stmt|;
name|mnext
operator|=
operator|&
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|mhip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
operator|*
name|mhip6
operator|=
operator|*
name|ip6
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mhip6
argument_list|)
expr_stmt|;
name|error
operator|=
name|ip6_insertfraghdr
argument_list|(
name|m0
argument_list|,
name|m
argument_list|,
name|hlen
argument_list|,
operator|&
name|ip6f
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_odropped
operator|++
expr_stmt|;
goto|goto
name|sendorfree
goto|;
block|}
name|ip6f
operator|->
name|ip6f_offlg
operator|=
name|htons
argument_list|(
call|(
name|u_short
call|)
argument_list|(
operator|(
name|off
operator|-
name|hlen
operator|)
operator|&
operator|~
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|len
operator|>=
name|tlen
condition|)
name|len
operator|=
name|tlen
operator|-
name|off
expr_stmt|;
else|else
name|ip6f
operator|->
name|ip6f_offlg
operator||=
name|IP6F_MORE_FRAG
expr_stmt|;
name|mhip6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
call|(
name|u_short
call|)
argument_list|(
name|len
operator|+
name|hlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6f
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m_frgpart
operator|=
name|m_copy
argument_list|(
name|m0
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
name|ip6stat
operator|.
name|ip6s_odropped
operator|++
expr_stmt|;
goto|goto
name|sendorfree
goto|;
block|}
name|m_cat
argument_list|(
name|m
argument_list|,
name|m_frgpart
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
operator|+
name|hlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6f
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
literal|0
expr_stmt|;
name|ip6f
operator|->
name|ip6f_reserved
operator|=
literal|0
expr_stmt|;
name|ip6f
operator|->
name|ip6f_ident
operator|=
name|id
expr_stmt|;
name|ip6f
operator|->
name|ip6f_nxt
operator|=
name|nextproto
expr_stmt|;
name|ip6stat
operator|.
name|ip6s_ofragments
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_fragcreat
argument_list|)
expr_stmt|;
block|}
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_out_fragok
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Remove leading garbages. 	 */
name|sendorfree
label|:
name|m
operator|=
name|m0
operator|->
name|m_nextpkt
expr_stmt|;
name|m0
operator|->
name|m_nextpkt
operator|=
literal|0
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
for|for
control|(
name|m0
operator|=
name|m
init|;
name|m
condition|;
name|m
operator|=
name|m0
control|)
block|{
name|m0
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* Record statistics for this interface address. */
if|if
condition|(
name|ia
condition|)
block|{
name|ia
operator|->
name|ia_ifa
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|ia
operator|->
name|ia_ifa
operator|.
name|if_obytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPSEC
comment|/* clean ipsec history once it goes out of the node */
name|ipsec_delaux
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|nd6_output
argument_list|(
name|ifp
argument_list|,
name|origifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
block|}
else|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ip6stat
operator|.
name|ip6s_fragmented
operator|++
expr_stmt|;
name|done
label|:
if|if
condition|(
name|ro
operator|==
operator|&
name|ip6route
operator|&&
name|ro
operator|->
name|ro_rt
condition|)
block|{
comment|/* brace necessary for RTFREE */
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ro_pmtu
operator|==
operator|&
name|ip6route
operator|&&
name|ro_pmtu
operator|->
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|ro_pmtu
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPSEC
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
name|key_freesp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IPSEC */
return|return
operator|(
name|error
operator|)
return|;
name|freehdrs
label|:
name|m_freem
argument_list|(
name|exthdrs
operator|.
name|ip6e_hbh
argument_list|)
expr_stmt|;
comment|/* m_freem will check if mbuf is 0 */
name|m_freem
argument_list|(
name|exthdrs
operator|.
name|ip6e_dest1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|exthdrs
operator|.
name|ip6e_rthdr
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|exthdrs
operator|.
name|ip6e_dest2
argument_list|)
expr_stmt|;
comment|/* fall through */
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
end_function

begin_function
specifier|static
name|int
name|ip6_copyexthdr
parameter_list|(
name|mp
parameter_list|,
name|hdr
parameter_list|,
name|hlen
parameter_list|)
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|caddr_t
name|hdr
decl_stmt|;
name|int
name|hlen
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|hlen
operator|>
name|MCLBYTES
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* XXX */
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
if|if
condition|(
name|hlen
operator|>
name|MLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
name|m
operator|->
name|m_len
operator|=
name|hlen
expr_stmt|;
if|if
condition|(
name|hdr
condition|)
name|bcopy
argument_list|(
name|hdr
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert jumbo payload option.  */
end_comment

begin_function
specifier|static
name|int
name|ip6_insert_jumboopt
parameter_list|(
name|exthdrs
parameter_list|,
name|plen
parameter_list|)
name|struct
name|ip6_exthdrs
modifier|*
name|exthdrs
decl_stmt|;
name|u_int32_t
name|plen
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|mopt
decl_stmt|;
name|u_char
modifier|*
name|optbuf
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
define|#
directive|define
name|JUMBOOPTLEN
value|8
comment|/* length of jumbo payload option and padding */
comment|/* 	 * If there is no hop-by-hop options header, allocate new one. 	 * If there is one but it doesn't have enough space to store the 	 * jumbo payload option, allocate a cluster to store the whole options. 	 * Otherwise, use it to store the options. 	 */
if|if
condition|(
name|exthdrs
operator|->
name|ip6e_hbh
operator|==
literal|0
condition|)
block|{
name|MGET
argument_list|(
name|mopt
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mopt
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|mopt
operator|->
name|m_len
operator|=
name|JUMBOOPTLEN
expr_stmt|;
name|optbuf
operator|=
name|mtod
argument_list|(
name|mopt
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|optbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* = ((JUMBOOPTLEN)>> 3) - 1 */
name|exthdrs
operator|->
name|ip6e_hbh
operator|=
name|mopt
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ip6_hbh
modifier|*
name|hbh
decl_stmt|;
name|mopt
operator|=
name|exthdrs
operator|->
name|ip6e_hbh
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|mopt
argument_list|)
operator|<
name|JUMBOOPTLEN
condition|)
block|{
comment|/* 			 * XXX assumption: 			 * - exthdrs->ip6e_hbh is not referenced from places 			 *   other than exthdrs. 			 * - exthdrs->ip6e_hbh is not an mbuf chain. 			 */
name|int
name|oldoptlen
init|=
name|mopt
operator|->
name|m_len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* 			 * XXX: give up if the whole (new) hbh header does 			 * not fit even in an mbuf cluster. 			 */
if|if
condition|(
name|oldoptlen
operator|+
name|JUMBOOPTLEN
operator|>
name|MCLBYTES
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* 			 * As a consequence, we must always prepare a cluster 			 * at this point. 			 */
name|MGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|n
operator|->
name|m_len
operator|=
name|oldoptlen
operator|+
name|JUMBOOPTLEN
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|mopt
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|oldoptlen
argument_list|)
expr_stmt|;
name|optbuf
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|oldoptlen
expr_stmt|;
name|m_freem
argument_list|(
name|mopt
argument_list|)
expr_stmt|;
name|mopt
operator|=
name|exthdrs
operator|->
name|ip6e_hbh
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|optbuf
operator|=
name|mtod
argument_list|(
name|mopt
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|mopt
operator|->
name|m_len
expr_stmt|;
name|mopt
operator|->
name|m_len
operator|+=
name|JUMBOOPTLEN
expr_stmt|;
block|}
name|optbuf
index|[
literal|0
index|]
operator|=
name|IP6OPT_PADN
expr_stmt|;
name|optbuf
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Adjust the header length according to the pad and 		 * the jumbo payload option. 		 */
name|hbh
operator|=
name|mtod
argument_list|(
name|mopt
argument_list|,
expr|struct
name|ip6_hbh
operator|*
argument_list|)
expr_stmt|;
name|hbh
operator|->
name|ip6h_len
operator|+=
operator|(
name|JUMBOOPTLEN
operator|>>
literal|3
operator|)
expr_stmt|;
block|}
comment|/* fill in the option. */
name|optbuf
index|[
literal|2
index|]
operator|=
name|IP6OPT_JUMBO
expr_stmt|;
name|optbuf
index|[
literal|3
index|]
operator|=
literal|4
expr_stmt|;
name|v
operator|=
operator|(
name|u_int32_t
operator|)
name|htonl
argument_list|(
name|plen
operator|+
name|JUMBOOPTLEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|optbuf
index|[
literal|4
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* finally, adjust the packet header length */
name|exthdrs
operator|->
name|ip6e_ip6
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|JUMBOOPTLEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|JUMBOOPTLEN
block|}
end_function

begin_comment
comment|/*  * Insert fragment header and copy unfragmentable header portions.  */
end_comment

begin_function
specifier|static
name|int
name|ip6_insertfraghdr
parameter_list|(
name|m0
parameter_list|,
name|m
parameter_list|,
name|hlen
parameter_list|,
name|frghdrp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
decl|*
name|m
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|hlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ip6_frag
modifier|*
modifier|*
name|frghdrp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|,
modifier|*
name|mlast
decl_stmt|;
if|if
condition|(
name|hlen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_copym
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|hlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m
operator|->
name|m_next
operator|=
name|n
expr_stmt|;
block|}
else|else
name|n
operator|=
name|m
expr_stmt|;
comment|/* Search for the last mbuf of unfragmentable part. */
for|for
control|(
name|mlast
operator|=
name|n
init|;
name|mlast
operator|->
name|m_next
condition|;
name|mlast
operator|=
name|mlast
operator|->
name|m_next
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|mlast
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
operator|&&
name|M_TRAILINGSPACE
argument_list|(
name|mlast
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
condition|)
block|{
comment|/* use the trailing space of the last mbuf for the fragment hdr */
operator|*
name|frghdrp
operator|=
operator|(
expr|struct
name|ip6_frag
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|mlast
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mlast
operator|->
name|m_len
operator|)
expr_stmt|;
name|mlast
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* allocate a new mbuf for the fragment header */
name|struct
name|mbuf
modifier|*
name|mfrg
decl_stmt|;
name|MGET
argument_list|(
name|mfrg
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfrg
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|mfrg
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
operator|*
name|frghdrp
operator|=
name|mtod
argument_list|(
name|mfrg
argument_list|,
expr|struct
name|ip6_frag
operator|*
argument_list|)
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|mfrg
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * IP6 socket option processing.  */
end_comment

begin_function
name|int
name|ip6_ctloutput
parameter_list|(
name|so
parameter_list|,
name|sopt
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
block|{
name|int
name|privileged
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|in6p
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|,
name|optval
decl_stmt|;
name|int
name|level
decl_stmt|,
name|op
decl_stmt|,
name|optname
decl_stmt|;
name|int
name|optlen
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|sopt
condition|)
block|{
name|level
operator|=
name|sopt
operator|->
name|sopt_level
expr_stmt|;
name|op
operator|=
name|sopt
operator|->
name|sopt_dir
expr_stmt|;
name|optname
operator|=
name|sopt
operator|->
name|sopt_name
expr_stmt|;
name|optlen
operator|=
name|sopt
operator|->
name|sopt_valsize
expr_stmt|;
name|p
operator|=
name|sopt
operator|->
name|sopt_p
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"ip6_ctloutput: arg soopt is NULL"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|optval
operator|=
literal|0
expr_stmt|;
name|privileged
operator|=
operator|(
name|p
operator|==
literal|0
operator|||
name|suser
argument_list|(
name|p
argument_list|)
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|IPPROTO_IPV6
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SOPT_SET
case|:
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_PKTOPTIONS
case|:
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|error
operator|=
name|soopt_getm
argument_list|(
name|sopt
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|error
operator|!=
name|NULL
condition|)
break|break;
name|error
operator|=
name|soopt_mcopyin
argument_list|(
name|sopt
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|error
operator|!=
name|NULL
condition|)
break|break;
name|error
operator|=
name|ip6_pcbopts
argument_list|(
operator|&
name|in6p
operator|->
name|in6p_outputopts
argument_list|,
name|m
argument_list|,
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
block|}
comment|/* 			 * Use of some Hop-by-Hop options or some 			 * Destination options, might require special 			 * privilege.  That is, normal applications 			 * (without special privilege) might be forbidden 			 * from setting certain options in outgoing packets, 			 * and might never see certain options in received 			 * packets. [RFC 2292 Section 6] 			 * KAME specific note: 			 *  KAME prevents non-privileged users from sending or 			 *  receiving ANY hbh/dst options in order to avoid 			 *  overhead of parsing options in the kernel. 			 */
case|case
name|IPV6_UNICAST_HOPS
case|:
case|case
name|IPV6_CHECKSUM
case|:
case|case
name|IPV6_FAITH
case|:
case|case
name|IPV6_V6ONLY
case|:
if|if
condition|(
name|optlen
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_UNICAST_HOPS
case|:
if|if
condition|(
name|optval
operator|<
operator|-
literal|1
operator|||
name|optval
operator|>=
literal|256
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
comment|/* -1 = kernel default */
name|in6p
operator|->
name|in6p_hops
operator|=
name|optval
expr_stmt|;
if|if
condition|(
operator|(
name|in6p
operator|->
name|in6p_vflag
operator|&
name|INP_IPV4
operator|)
operator|!=
literal|0
condition|)
name|in6p
operator|->
name|inp_ip_ttl
operator|=
name|optval
expr_stmt|;
block|}
break|break;
define|#
directive|define
name|OPTSET
parameter_list|(
name|bit
parameter_list|)
define|\
value|do { \ 	if (optval) \ 		in6p->in6p_flags |= (bit); \ 	else \ 		in6p->in6p_flags&= ~(bit); \ } while (0)
define|#
directive|define
name|OPTBIT
parameter_list|(
name|bit
parameter_list|)
value|(in6p->in6p_flags& (bit) ? 1 : 0)
case|case
name|IPV6_CHECKSUM
case|:
name|in6p
operator|->
name|in6p_cksum
operator|=
name|optval
expr_stmt|;
break|break;
case|case
name|IPV6_FAITH
case|:
name|OPTSET
argument_list|(
name|IN6P_FAITH
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_V6ONLY
case|:
comment|/* 					 * make setsockopt(IPV6_V6ONLY) 					 * available only prior to bind(2). 					 * see ipng mailing list, Jun 22 2001. 					 */
if|if
condition|(
name|in6p
operator|->
name|in6p_lport
operator|||
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|in6p
operator|->
name|in6p_laddr
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 					 * XXX: BINDV6ONLY should be integrated 					 * into V6ONLY. 					 */
name|OPTSET
argument_list|(
name|IN6P_BINDV6ONLY
argument_list|)
expr_stmt|;
name|OPTSET
argument_list|(
name|IN6P_IPV6_V6ONLY
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IPV6_PKTINFO
case|:
case|case
name|IPV6_HOPLIMIT
case|:
case|case
name|IPV6_HOPOPTS
case|:
case|case
name|IPV6_DSTOPTS
case|:
case|case
name|IPV6_RTHDR
case|:
comment|/* RFC 2292 */
if|if
condition|(
name|optlen
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_PKTINFO
case|:
name|OPTSET
argument_list|(
name|IN6P_PKTINFO
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_HOPLIMIT
case|:
name|OPTSET
argument_list|(
name|IN6P_HOPLIMIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_HOPOPTS
case|:
comment|/* 					 * Check super-user privilege. 					 * See comments for IPV6_RECVHOPOPTS. 					 */
if|if
condition|(
operator|!
name|privileged
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|OPTSET
argument_list|(
name|IN6P_HOPOPTS
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_DSTOPTS
case|:
if|if
condition|(
operator|!
name|privileged
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|OPTSET
argument_list|(
name|IN6P_DSTOPTS
operator||
name|IN6P_RTHDRDSTOPTS
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|IPV6_RTHDR
case|:
name|OPTSET
argument_list|(
name|IN6P_RTHDR
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
undef|#
directive|undef
name|OPTSET
case|case
name|IPV6_MULTICAST_IF
case|:
case|case
name|IPV6_MULTICAST_HOPS
case|:
case|case
name|IPV6_MULTICAST_LOOP
case|:
case|case
name|IPV6_JOIN_GROUP
case|:
case|case
name|IPV6_LEAVE_GROUP
case|:
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|>
name|MLEN
condition|)
block|{
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
break|break;
block|}
comment|/* XXX */
name|MGET
argument_list|(
name|m
argument_list|,
name|sopt
operator|->
name|sopt_p
condition|?
name|M_WAIT
else|:
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|m
operator|->
name|m_len
operator|=
name|sopt
operator|->
name|sopt_valsize
expr_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|ip6_setmoptions
argument_list|(
name|sopt
operator|->
name|sopt_name
argument_list|,
operator|&
name|in6p
operator|->
name|in6p_moptions
argument_list|,
name|m
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IPV6_PORTRANGE
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
switch|switch
condition|(
name|optval
condition|)
block|{
case|case
name|IPV6_PORTRANGE_DEFAULT
case|:
name|in6p
operator|->
name|in6p_flags
operator|&=
operator|~
operator|(
name|IN6P_LOWPORT
operator|)
expr_stmt|;
name|in6p
operator|->
name|in6p_flags
operator|&=
operator|~
operator|(
name|IN6P_HIGHPORT
operator|)
expr_stmt|;
break|break;
case|case
name|IPV6_PORTRANGE_HIGH
case|:
name|in6p
operator|->
name|in6p_flags
operator|&=
operator|~
operator|(
name|IN6P_LOWPORT
operator|)
expr_stmt|;
name|in6p
operator|->
name|in6p_flags
operator||=
name|IN6P_HIGHPORT
expr_stmt|;
break|break;
case|case
name|IPV6_PORTRANGE_LOW
case|:
name|in6p
operator|->
name|in6p_flags
operator|&=
operator|~
operator|(
name|IN6P_HIGHPORT
operator|)
expr_stmt|;
name|in6p
operator|->
name|in6p_flags
operator||=
name|IN6P_LOWPORT
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
ifdef|#
directive|ifdef
name|IPSEC
case|case
name|IPV6_IPSEC_POLICY
case|:
block|{
name|caddr_t
name|req
init|=
name|NULL
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|soopt_getm
argument_list|(
name|sopt
argument_list|,
operator|&
name|m
argument_list|)
operator|)
operator|!=
literal|0
condition|)
comment|/* XXX */
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|soopt_mcopyin
argument_list|(
name|sopt
argument_list|,
name|m
argument_list|)
operator|)
operator|!=
literal|0
condition|)
comment|/* XXX */
break|break;
if|if
condition|(
name|m
condition|)
block|{
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|error
operator|=
name|ipsec6_set_policy
argument_list|(
name|in6p
argument_list|,
name|optname
argument_list|,
name|req
argument_list|,
name|len
argument_list|,
name|privileged
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* KAME IPSEC */
case|case
name|IPV6_FW_ADD
case|:
case|case
name|IPV6_FW_DEL
case|:
case|case
name|IPV6_FW_FLUSH
case|:
case|case
name|IPV6_FW_ZERO
case|:
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
init|=
operator|&
name|m
decl_stmt|;
if|if
condition|(
name|ip6_fw_ctl_ptr
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
comment|/* XXX */
if|if
condition|(
operator|(
name|error
operator|=
name|soopt_getm
argument_list|(
name|sopt
argument_list|,
operator|&
name|m
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* XXX */
if|if
condition|(
operator|(
name|error
operator|=
name|soopt_mcopyin
argument_list|(
name|sopt
argument_list|,
name|m
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|error
operator|=
call|(
modifier|*
name|ip6_fw_ctl_ptr
call|)
argument_list|(
name|optname
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SOPT_GET
case|:
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_PKTOPTIONS
case|:
if|if
condition|(
name|in6p
operator|->
name|in6p_options
condition|)
block|{
name|error
operator|=
name|soopt_mcopyout
argument_list|(
name|sopt
argument_list|,
name|in6p
operator|->
name|in6p_options
argument_list|)
expr_stmt|;
block|}
else|else
name|sopt
operator|->
name|sopt_valsize
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPV6_UNICAST_HOPS
case|:
case|case
name|IPV6_CHECKSUM
case|:
case|case
name|IPV6_FAITH
case|:
case|case
name|IPV6_V6ONLY
case|:
case|case
name|IPV6_PORTRANGE
case|:
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_UNICAST_HOPS
case|:
name|optval
operator|=
name|in6p
operator|->
name|in6p_hops
expr_stmt|;
break|break;
case|case
name|IPV6_CHECKSUM
case|:
name|optval
operator|=
name|in6p
operator|->
name|in6p_cksum
expr_stmt|;
break|break;
case|case
name|IPV6_FAITH
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_FAITH
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_V6ONLY
case|:
comment|/* XXX: see the setopt case. */
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_BINDV6ONLY
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_PORTRANGE
case|:
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|in6p
operator|->
name|in6p_flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IN6P_HIGHPORT
condition|)
name|optval
operator|=
name|IPV6_PORTRANGE_HIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|IN6P_LOWPORT
condition|)
name|optval
operator|=
name|IPV6_PORTRANGE_LOW
expr_stmt|;
else|else
name|optval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_PKTINFO
case|:
case|case
name|IPV6_HOPLIMIT
case|:
case|case
name|IPV6_HOPOPTS
case|:
case|case
name|IPV6_RTHDR
case|:
case|case
name|IPV6_DSTOPTS
case|:
if|if
condition|(
name|optname
operator|==
name|IPV6_HOPOPTS
operator|||
name|optname
operator|==
name|IPV6_DSTOPTS
operator|||
operator|!
name|privileged
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_PKTINFO
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_PKTINFO
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_HOPLIMIT
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_HOPLIMIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_HOPOPTS
case|:
if|if
condition|(
operator|!
name|privileged
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_HOPOPTS
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_RTHDR
case|:
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_RTHDR
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_DSTOPTS
case|:
if|if
condition|(
operator|!
name|privileged
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|optval
operator|=
name|OPTBIT
argument_list|(
name|IN6P_DSTOPTS
operator||
name|IN6P_RTHDRDSTOPTS
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_MULTICAST_IF
case|:
case|case
name|IPV6_MULTICAST_HOPS
case|:
case|case
name|IPV6_MULTICAST_LOOP
case|:
case|case
name|IPV6_JOIN_GROUP
case|:
case|case
name|IPV6_LEAVE_GROUP
case|:
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|error
operator|=
name|ip6_getmoptions
argument_list|(
name|sopt
operator|->
name|sopt_name
argument_list|,
name|in6p
operator|->
name|in6p_moptions
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|IPSEC
case|case
name|IPV6_IPSEC_POLICY
case|:
block|{
name|caddr_t
name|req
init|=
name|NULL
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
init|=
operator|&
name|m
decl_stmt|;
name|error
operator|=
name|soopt_getm
argument_list|(
name|sopt
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|error
operator|!=
name|NULL
condition|)
break|break;
name|error
operator|=
name|soopt_mcopyin
argument_list|(
name|sopt
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|error
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|m
condition|)
block|{
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|error
operator|=
name|ipsec6_get_policy
argument_list|(
name|in6p
argument_list|,
name|req
argument_list|,
name|len
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|soopt_mcopyout
argument_list|(
name|sopt
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/*XXX*/
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* KAME IPSEC */
case|case
name|IPV6_FW_GET
case|:
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
init|=
operator|&
name|m
decl_stmt|;
if|if
condition|(
name|ip6_fw_ctl_ptr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|m
condition|)
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
call|(
modifier|*
name|ip6_fw_ctl_ptr
call|)
argument_list|(
name|optname
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|soopt_mcopyout
argument_list|(
name|sopt
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up IP6 options in pcb for insertion in output packets or  * specifying behavior of outgoing packets.  */
end_comment

begin_function
specifier|static
name|int
name|ip6_pcbopts
parameter_list|(
name|pktopt
parameter_list|,
name|m
parameter_list|,
name|so
parameter_list|,
name|sopt
parameter_list|)
name|struct
name|ip6_pktopts
modifier|*
modifier|*
name|pktopt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
block|{
name|struct
name|ip6_pktopts
modifier|*
name|opt
init|=
operator|*
name|pktopt
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|sopt
operator|->
name|sopt_p
decl_stmt|;
name|int
name|priv
init|=
literal|0
decl_stmt|;
comment|/* turn off any old options. */
if|if
condition|(
name|opt
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|opt
operator|->
name|ip6po_pktinfo
operator|||
name|opt
operator|->
name|ip6po_nexthop
operator|||
name|opt
operator|->
name|ip6po_hbh
operator|||
name|opt
operator|->
name|ip6po_dest1
operator|||
name|opt
operator|->
name|ip6po_dest2
operator|||
name|opt
operator|->
name|ip6po_rhinfo
operator|.
name|ip6po_rhi_rthdr
condition|)
name|printf
argument_list|(
literal|"ip6_pcbopts: all specified options are cleared.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ip6_clearpktopts
argument_list|(
name|opt
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|opt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|opt
argument_list|)
argument_list|,
name|M_IP6OPT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|*
name|pktopt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Only turning off any previous options. 		 */
if|if
condition|(
name|opt
condition|)
name|free
argument_list|(
name|opt
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  set options specified by user. */
if|if
condition|(
name|p
operator|&&
operator|!
name|suser
argument_list|(
name|p
argument_list|)
condition|)
name|priv
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ip6_setpktoptions
argument_list|(
name|m
argument_list|,
name|opt
argument_list|,
name|priv
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ip6_clearpktopts
argument_list|(
name|opt
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX: discard all options */
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|pktopt
operator|=
name|opt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * initialize ip6_pktopts.  beware that there are non-zero default values in  * the struct.  */
end_comment

begin_function
name|void
name|init_ip6pktopts
parameter_list|(
name|opt
parameter_list|)
name|struct
name|ip6_pktopts
modifier|*
name|opt
decl_stmt|;
block|{
name|bzero
argument_list|(
name|opt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|opt
operator|->
name|ip6po_hlim
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* -1 means default hop limit */
block|}
end_function

begin_function
name|void
name|ip6_clearpktopts
parameter_list|(
name|pktopt
parameter_list|,
name|needfree
parameter_list|,
name|optname
parameter_list|)
name|struct
name|ip6_pktopts
modifier|*
name|pktopt
decl_stmt|;
name|int
name|needfree
decl_stmt|,
name|optname
decl_stmt|;
block|{
if|if
condition|(
name|pktopt
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|optname
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|needfree
operator|&&
name|pktopt
operator|->
name|ip6po_pktinfo
condition|)
name|free
argument_list|(
name|pktopt
operator|->
name|ip6po_pktinfo
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
name|pktopt
operator|->
name|ip6po_pktinfo
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|optname
operator|==
operator|-
literal|1
condition|)
name|pktopt
operator|->
name|ip6po_hlim
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|optname
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|needfree
operator|&&
name|pktopt
operator|->
name|ip6po_nexthop
condition|)
name|free
argument_list|(
name|pktopt
operator|->
name|ip6po_nexthop
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
name|pktopt
operator|->
name|ip6po_nexthop
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|optname
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|needfree
operator|&&
name|pktopt
operator|->
name|ip6po_hbh
condition|)
name|free
argument_list|(
name|pktopt
operator|->
name|ip6po_hbh
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
name|pktopt
operator|->
name|ip6po_hbh
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|optname
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|needfree
operator|&&
name|pktopt
operator|->
name|ip6po_dest1
condition|)
name|free
argument_list|(
name|pktopt
operator|->
name|ip6po_dest1
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
name|pktopt
operator|->
name|ip6po_dest1
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|optname
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|needfree
operator|&&
name|pktopt
operator|->
name|ip6po_rhinfo
operator|.
name|ip6po_rhi_rthdr
condition|)
name|free
argument_list|(
name|pktopt
operator|->
name|ip6po_rhinfo
operator|.
name|ip6po_rhi_rthdr
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
name|pktopt
operator|->
name|ip6po_rhinfo
operator|.
name|ip6po_rhi_rthdr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pktopt
operator|->
name|ip6po_route
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|pktopt
operator|->
name|ip6po_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|pktopt
operator|->
name|ip6po_route
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optname
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|needfree
operator|&&
name|pktopt
operator|->
name|ip6po_dest2
condition|)
name|free
argument_list|(
name|pktopt
operator|->
name|ip6po_dest2
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
name|pktopt
operator|->
name|ip6po_dest2
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|PKTOPT_EXTHDRCPY
parameter_list|(
name|type
parameter_list|)
define|\
value|do {\ 	if (src->type) {\ 		int hlen =\ 			(((struct ip6_ext *)src->type)->ip6e_len + 1)<< 3;\ 		dst->type = malloc(hlen, M_IP6OPT, canwait);\ 		if (dst->type == NULL&& canwait == M_NOWAIT)\ 			goto bad;\ 		bcopy(src->type, dst->type, hlen);\ 	}\ } while (0)
end_define

begin_function
name|struct
name|ip6_pktopts
modifier|*
name|ip6_copypktopts
parameter_list|(
name|src
parameter_list|,
name|canwait
parameter_list|)
name|struct
name|ip6_pktopts
modifier|*
name|src
decl_stmt|;
name|int
name|canwait
decl_stmt|;
block|{
name|struct
name|ip6_pktopts
modifier|*
name|dst
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ip6_clearpktopts: invalid argument\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dst
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|,
name|M_IP6OPT
argument_list|,
name|canwait
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
operator|&&
name|canwait
operator|==
name|M_NOWAIT
condition|)
goto|goto
name|bad
goto|;
name|bzero
argument_list|(
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|->
name|ip6po_hlim
operator|=
name|src
operator|->
name|ip6po_hlim
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|ip6po_pktinfo
condition|)
block|{
name|dst
operator|->
name|ip6po_pktinfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dst
operator|->
name|ip6po_pktinfo
argument_list|)
argument_list|,
name|M_IP6OPT
argument_list|,
name|canwait
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|ip6po_pktinfo
operator|==
name|NULL
operator|&&
name|canwait
operator|==
name|M_NOWAIT
condition|)
goto|goto
name|bad
goto|;
operator|*
name|dst
operator|->
name|ip6po_pktinfo
operator|=
operator|*
name|src
operator|->
name|ip6po_pktinfo
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|->
name|ip6po_nexthop
condition|)
block|{
name|dst
operator|->
name|ip6po_nexthop
operator|=
name|malloc
argument_list|(
name|src
operator|->
name|ip6po_nexthop
operator|->
name|sa_len
argument_list|,
name|M_IP6OPT
argument_list|,
name|canwait
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|ip6po_nexthop
operator|==
name|NULL
operator|&&
name|canwait
operator|==
name|M_NOWAIT
condition|)
goto|goto
name|bad
goto|;
name|bcopy
argument_list|(
name|src
operator|->
name|ip6po_nexthop
argument_list|,
name|dst
operator|->
name|ip6po_nexthop
argument_list|,
name|src
operator|->
name|ip6po_nexthop
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
name|PKTOPT_EXTHDRCPY
argument_list|(
name|ip6po_hbh
argument_list|)
expr_stmt|;
name|PKTOPT_EXTHDRCPY
argument_list|(
name|ip6po_dest1
argument_list|)
expr_stmt|;
name|PKTOPT_EXTHDRCPY
argument_list|(
name|ip6po_dest2
argument_list|)
expr_stmt|;
name|PKTOPT_EXTHDRCPY
argument_list|(
name|ip6po_rthdr
argument_list|)
expr_stmt|;
comment|/* not copy the cached route */
return|return
operator|(
name|dst
operator|)
return|;
name|bad
label|:
name|printf
argument_list|(
literal|"ip6_copypktopts: copy failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|ip6po_pktinfo
condition|)
name|free
argument_list|(
name|dst
operator|->
name|ip6po_pktinfo
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|ip6po_nexthop
condition|)
name|free
argument_list|(
name|dst
operator|->
name|ip6po_nexthop
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|ip6po_hbh
condition|)
name|free
argument_list|(
name|dst
operator|->
name|ip6po_hbh
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|ip6po_dest1
condition|)
name|free
argument_list|(
name|dst
operator|->
name|ip6po_dest1
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|ip6po_dest2
condition|)
name|free
argument_list|(
name|dst
operator|->
name|ip6po_dest2
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|ip6po_rthdr
condition|)
name|free
argument_list|(
name|dst
operator|->
name|ip6po_rthdr
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|PKTOPT_EXTHDRCPY
end_undef

begin_function
name|void
name|ip6_freepcbopts
parameter_list|(
name|pktopt
parameter_list|)
name|struct
name|ip6_pktopts
modifier|*
name|pktopt
decl_stmt|;
block|{
if|if
condition|(
name|pktopt
operator|==
name|NULL
condition|)
return|return;
name|ip6_clearpktopts
argument_list|(
name|pktopt
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pktopt
argument_list|,
name|M_IP6OPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the IP6 multicast options in response to user setsockopt().  */
end_comment

begin_function
specifier|static
name|int
name|ip6_setmoptions
parameter_list|(
name|optname
parameter_list|,
name|im6op
parameter_list|,
name|m
parameter_list|)
name|int
name|optname
decl_stmt|;
name|struct
name|ip6_moptions
modifier|*
modifier|*
name|im6op
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int
name|loop
decl_stmt|,
name|ifindex
decl_stmt|;
name|struct
name|ipv6_mreq
modifier|*
name|mreq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ip6_moptions
modifier|*
name|im6o
init|=
operator|*
name|im6op
decl_stmt|;
name|struct
name|route_in6
name|ro
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|dst
decl_stmt|;
name|struct
name|in6_multi_mship
modifier|*
name|imm
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
if|if
condition|(
name|im6o
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No multicast option buffer attached to the pcb; 		 * allocate one and initialize to default values. 		 */
name|im6o
operator|=
operator|(
expr|struct
name|ip6_moptions
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|im6o
argument_list|)
argument_list|,
name|M_IPMOPTS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|im6o
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
operator|*
name|im6op
operator|=
name|im6o
expr_stmt|;
name|im6o
operator|->
name|im6o_multicast_ifp
operator|=
name|NULL
expr_stmt|;
name|im6o
operator|->
name|im6o_multicast_hlim
operator|=
name|ip6_defmcasthlim
expr_stmt|;
name|im6o
operator|->
name|im6o_multicast_loop
operator|=
name|IPV6_DEFAULT_MULTICAST_LOOP
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|im6o
operator|->
name|im6o_memberships
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_MULTICAST_IF
case|:
comment|/* 		 * Select the interface for outgoing multicast packets. 		 */
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|m_len
operator|!=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int
operator|*
argument_list|)
argument_list|,
operator|&
name|ifindex
argument_list|,
sizeof|sizeof
argument_list|(
name|ifindex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifindex
operator|<
literal|0
operator|||
name|if_index
operator|<
name|ifindex
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
comment|/* XXX EINVAL? */
break|break;
block|}
name|ifp
operator|=
name|ifindex2ifnet
index|[
name|ifindex
index|]
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
break|break;
block|}
name|im6o
operator|->
name|im6o_multicast_ifp
operator|=
name|ifp
expr_stmt|;
break|break;
case|case
name|IPV6_MULTICAST_HOPS
case|:
block|{
comment|/* 		 * Set the IP6 hoplimit for outgoing multicast packets. 		 */
name|int
name|optval
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|m_len
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int
operator|*
argument_list|)
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optval
operator|<
operator|-
literal|1
operator|||
name|optval
operator|>=
literal|256
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|optval
operator|==
operator|-
literal|1
condition|)
name|im6o
operator|->
name|im6o_multicast_hlim
operator|=
name|ip6_defmcasthlim
expr_stmt|;
else|else
name|im6o
operator|->
name|im6o_multicast_hlim
operator|=
name|optval
expr_stmt|;
break|break;
block|}
case|case
name|IPV6_MULTICAST_LOOP
case|:
comment|/* 		 * Set the loopback flag for outgoing multicast packets. 		 * Must be zero or one. 		 */
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|m_len
operator|!=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int
operator|*
argument_list|)
argument_list|,
operator|&
name|loop
argument_list|,
sizeof|sizeof
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|>
literal|1
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|im6o
operator|->
name|im6o_multicast_loop
operator|=
name|loop
expr_stmt|;
break|break;
case|case
name|IPV6_JOIN_GROUP
case|:
comment|/* 		 * Add a multicast group membership. 		 * Group must be a valid IP6 multicast address. 		 */
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|m_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ipv6_mreq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mreq
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ipv6_mreq
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|mreq
operator|->
name|ipv6mr_multiaddr
argument_list|)
condition|)
block|{
comment|/* 			 * We use the unspecified address to specify to accept 			 * all multicast addresses. Only super user is allowed 			 * to do this. 			 */
if|if
condition|(
name|suser
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|mreq
operator|->
name|ipv6mr_multiaddr
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * If the interface is specified, validate it. 		 */
if|if
condition|(
name|mreq
operator|->
name|ipv6mr_interface
operator|<
literal|0
operator|||
name|if_index
operator|<
name|mreq
operator|->
name|ipv6mr_interface
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
comment|/* XXX EINVAL? */
break|break;
block|}
comment|/* 		 * If no interface was explicitly specified, choose an 		 * appropriate one according to the given multicast address. 		 */
if|if
condition|(
name|mreq
operator|->
name|ipv6mr_interface
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If the multicast address is in node-local scope, 			 * the interface should be a loopback interface. 			 * Otherwise, look up the routing table for the 			 * address, and choose the outgoing interface. 			 *   XXX: is it a good approach? 			 */
if|if
condition|(
name|IN6_IS_ADDR_MC_NODELOCAL
argument_list|(
operator|&
name|mreq
operator|->
name|ipv6mr_multiaddr
argument_list|)
condition|)
block|{
name|ifp
operator|=
operator|&
name|loif
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|ro
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
name|dst
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro
operator|.
name|ro_dst
expr_stmt|;
name|bzero
argument_list|(
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|dst
operator|->
name|sin6_addr
operator|=
name|mreq
operator|->
name|ipv6mr_multiaddr
expr_stmt|;
name|rtalloc
argument_list|(
operator|(
expr|struct
name|route
operator|*
operator|)
operator|&
name|ro
argument_list|)
expr_stmt|;
if|if
condition|(
name|ro
operator|.
name|ro_rt
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
break|break;
block|}
name|ifp
operator|=
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
name|rtfree
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ifp
operator|=
name|ifindex2ifnet
index|[
name|mreq
operator|->
name|ipv6mr_interface
index|]
expr_stmt|;
comment|/* 		 * See if we found an interface, and confirm that it 		 * supports multicast 		 */
if|if
condition|(
name|ifp
operator|==
name|NULL
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Put interface index into the multicast address, 		 * if the address has link-local scope. 		 */
if|if
condition|(
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
name|mreq
operator|->
name|ipv6mr_multiaddr
argument_list|)
condition|)
block|{
name|mreq
operator|->
name|ipv6mr_multiaddr
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|mreq
operator|->
name|ipv6mr_interface
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * See if the membership already exists. 		 */
for|for
control|(
name|imm
operator|=
name|im6o
operator|->
name|im6o_memberships
operator|.
name|lh_first
init|;
name|imm
operator|!=
name|NULL
condition|;
name|imm
operator|=
name|imm
operator|->
name|i6mm_chain
operator|.
name|le_next
control|)
if|if
condition|(
name|imm
operator|->
name|i6mm_maddr
operator|->
name|in6m_ifp
operator|==
name|ifp
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|imm
operator|->
name|i6mm_maddr
operator|->
name|in6m_addr
argument_list|,
operator|&
name|mreq
operator|->
name|ipv6mr_multiaddr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|imm
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EADDRINUSE
expr_stmt|;
break|break;
block|}
comment|/* 		 * Everything looks good; add a new record to the multicast 		 * address list for the given interface. 		 */
name|imm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|imm
argument_list|)
argument_list|,
name|M_IPMADDR
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|imm
operator|->
name|i6mm_maddr
operator|=
name|in6_addmulti
argument_list|(
operator|&
name|mreq
operator|->
name|ipv6mr_multiaddr
argument_list|,
name|ifp
argument_list|,
operator|&
name|error
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|imm
argument_list|,
name|M_IPMADDR
argument_list|)
expr_stmt|;
break|break;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|im6o
operator|->
name|im6o_memberships
argument_list|,
name|imm
argument_list|,
name|i6mm_chain
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_LEAVE_GROUP
case|:
comment|/* 		 * Drop a multicast group membership. 		 * Group must be a valid IP6 multicast address. 		 */
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|m_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ipv6_mreq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mreq
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ipv6_mreq
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|mreq
operator|->
name|ipv6mr_multiaddr
argument_list|)
condition|)
block|{
if|if
condition|(
name|suser
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|mreq
operator|->
name|ipv6mr_multiaddr
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * If an interface address was specified, get a pointer 		 * to its ifnet structure. 		 */
if|if
condition|(
name|mreq
operator|->
name|ipv6mr_interface
operator|<
literal|0
operator|||
name|if_index
operator|<
name|mreq
operator|->
name|ipv6mr_interface
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
comment|/* XXX EINVAL? */
break|break;
block|}
name|ifp
operator|=
name|ifindex2ifnet
index|[
name|mreq
operator|->
name|ipv6mr_interface
index|]
expr_stmt|;
comment|/* 		 * Put interface index into the multicast address, 		 * if the address has link-local scope. 		 */
if|if
condition|(
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
name|mreq
operator|->
name|ipv6mr_multiaddr
argument_list|)
condition|)
block|{
name|mreq
operator|->
name|ipv6mr_multiaddr
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|mreq
operator|->
name|ipv6mr_interface
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Find the membership in the membership list. 		 */
for|for
control|(
name|imm
operator|=
name|im6o
operator|->
name|im6o_memberships
operator|.
name|lh_first
init|;
name|imm
operator|!=
name|NULL
condition|;
name|imm
operator|=
name|imm
operator|->
name|i6mm_chain
operator|.
name|le_next
control|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|==
name|NULL
operator|||
name|imm
operator|->
name|i6mm_maddr
operator|->
name|in6m_ifp
operator|==
name|ifp
operator|)
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|imm
operator|->
name|i6mm_maddr
operator|->
name|in6m_addr
argument_list|,
operator|&
name|mreq
operator|->
name|ipv6mr_multiaddr
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|imm
operator|==
name|NULL
condition|)
block|{
comment|/* Unable to resolve interface */
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Give up the multicast address record to which the 		 * membership points. 		 */
name|LIST_REMOVE
argument_list|(
name|imm
argument_list|,
name|i6mm_chain
argument_list|)
expr_stmt|;
name|in6_delmulti
argument_list|(
name|imm
operator|->
name|i6mm_maddr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imm
argument_list|,
name|M_IPMADDR
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
comment|/* 	 * If all options have default values, no need to keep the mbuf. 	 */
if|if
condition|(
name|im6o
operator|->
name|im6o_multicast_ifp
operator|==
name|NULL
operator|&&
name|im6o
operator|->
name|im6o_multicast_hlim
operator|==
name|ip6_defmcasthlim
operator|&&
name|im6o
operator|->
name|im6o_multicast_loop
operator|==
name|IPV6_DEFAULT_MULTICAST_LOOP
operator|&&
name|im6o
operator|->
name|im6o_memberships
operator|.
name|lh_first
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|*
name|im6op
argument_list|,
name|M_IPMOPTS
argument_list|)
expr_stmt|;
operator|*
name|im6op
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the IP6 multicast options in response to user getsockopt().  */
end_comment

begin_function
specifier|static
name|int
name|ip6_getmoptions
parameter_list|(
name|optname
parameter_list|,
name|im6o
parameter_list|,
name|mp
parameter_list|)
name|int
name|optname
decl_stmt|;
name|struct
name|ip6_moptions
modifier|*
name|im6o
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
block|{
name|u_int
modifier|*
name|hlim
decl_stmt|,
modifier|*
name|loop
decl_stmt|,
modifier|*
name|ifindex
decl_stmt|;
operator|*
name|mp
operator|=
name|m_get
argument_list|(
name|M_WAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
comment|/*XXX*/
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|IPV6_MULTICAST_IF
case|:
name|ifindex
operator|=
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
name|u_int
operator|*
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|im6o
operator|==
name|NULL
operator|||
name|im6o
operator|->
name|im6o_multicast_ifp
operator|==
name|NULL
condition|)
operator|*
name|ifindex
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|ifindex
operator|=
name|im6o
operator|->
name|im6o_multicast_ifp
operator|->
name|if_index
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|IPV6_MULTICAST_HOPS
case|:
name|hlim
operator|=
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
name|u_int
operator|*
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|im6o
operator|==
name|NULL
condition|)
operator|*
name|hlim
operator|=
name|ip6_defmcasthlim
expr_stmt|;
else|else
operator|*
name|hlim
operator|=
name|im6o
operator|->
name|im6o_multicast_hlim
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|IPV6_MULTICAST_LOOP
case|:
name|loop
operator|=
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
name|u_int
operator|*
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|im6o
operator|==
name|NULL
condition|)
operator|*
name|loop
operator|=
name|ip6_defmcasthlim
expr_stmt|;
else|else
operator|*
name|loop
operator|=
name|im6o
operator|->
name|im6o_multicast_loop
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Discard the IP6 multicast options.  */
end_comment

begin_function
name|void
name|ip6_freemoptions
parameter_list|(
name|im6o
parameter_list|)
name|struct
name|ip6_moptions
modifier|*
name|im6o
decl_stmt|;
block|{
name|struct
name|in6_multi_mship
modifier|*
name|imm
decl_stmt|;
if|if
condition|(
name|im6o
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
operator|(
name|imm
operator|=
name|im6o
operator|->
name|im6o_memberships
operator|.
name|lh_first
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|imm
argument_list|,
name|i6mm_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|->
name|i6mm_maddr
condition|)
name|in6_delmulti
argument_list|(
name|imm
operator|->
name|i6mm_maddr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imm
argument_list|,
name|M_IPMADDR
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|im6o
argument_list|,
name|M_IPMOPTS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set IPv6 outgoing packet options based on advanced API.  */
end_comment

begin_function
name|int
name|ip6_setpktoptions
parameter_list|(
name|control
parameter_list|,
name|opt
parameter_list|,
name|priv
parameter_list|,
name|needcopy
parameter_list|)
name|struct
name|mbuf
modifier|*
name|control
decl_stmt|;
name|struct
name|ip6_pktopts
modifier|*
name|opt
decl_stmt|;
name|int
name|priv
decl_stmt|,
name|needcopy
decl_stmt|;
block|{
name|struct
name|cmsghdr
modifier|*
name|cm
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|control
operator|==
literal|0
operator|||
name|opt
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|init_ip6pktopts
argument_list|(
name|opt
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: Currently, we assume all the optional information is stored 	 * in a single mbuf. 	 */
if|if
condition|(
name|control
operator|->
name|m_next
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
init|;
name|control
operator|->
name|m_len
condition|;
name|control
operator|->
name|m_data
operator|+=
name|CMSG_ALIGN
argument_list|(
name|cm
operator|->
name|cmsg_len
argument_list|)
operator|,
name|control
operator|->
name|m_len
operator|-=
name|CMSG_ALIGN
argument_list|(
name|cm
operator|->
name|cmsg_len
argument_list|)
control|)
block|{
name|cm
operator|=
name|mtod
argument_list|(
name|control
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|==
literal|0
operator|||
name|cm
operator|->
name|cmsg_len
operator|>
name|control
operator|->
name|m_len
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|!=
name|IPPROTO_IPV6
condition|)
continue|continue;
comment|/* 		 * XXX should check if RFC2292 API is mixed with 2292bis API 		 */
switch|switch
condition|(
name|cm
operator|->
name|cmsg_type
condition|)
block|{
case|case
name|IPV6_PKTINFO
case|:
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|!=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|needcopy
condition|)
block|{
comment|/* XXX: Is it really WAITOK? */
name|opt
operator|->
name|ip6po_pktinfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|,
name|M_IP6OPT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
argument_list|,
name|opt
operator|->
name|ip6po_pktinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|opt
operator|->
name|ip6po_pktinfo
operator|=
operator|(
expr|struct
name|in6_pktinfo
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|ip6po_pktinfo
operator|->
name|ipi6_ifindex
operator|&&
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|opt
operator|->
name|ip6po_pktinfo
operator|->
name|ipi6_addr
argument_list|)
condition|)
name|opt
operator|->
name|ip6po_pktinfo
operator|->
name|ipi6_addr
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|opt
operator|->
name|ip6po_pktinfo
operator|->
name|ipi6_ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|ip6po_pktinfo
operator|->
name|ipi6_ifindex
operator|>
name|if_index
operator|||
name|opt
operator|->
name|ip6po_pktinfo
operator|->
name|ipi6_ifindex
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 			 * Check if the requested source address is indeed a 			 * unicast address assigned to the node, and can be 			 * used as the packet's source address. 			 */
if|if
condition|(
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|opt
operator|->
name|ip6po_pktinfo
operator|->
name|ipi6_addr
argument_list|)
condition|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|=
name|opt
operator|->
name|ip6po_pktinfo
operator|->
name|ipi6_addr
expr_stmt|;
name|ia6
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa_ifwithaddr
argument_list|(
name|sin6tosa
argument_list|(
operator|&
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia6
operator|==
name|NULL
operator|||
operator|(
name|ia6
operator|->
name|ia6_flags
operator|&
operator|(
name|IN6_IFF_ANYCAST
operator||
name|IN6_IFF_NOTREADY
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
break|break;
case|case
name|IPV6_HOPLIMIT
case|:
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|!=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|opt
operator|->
name|ip6po_hlim
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|ip6po_hlim
operator|<
operator|-
literal|1
operator|||
name|opt
operator|->
name|ip6po_hlim
operator|>
literal|255
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|IPV6_NEXTHOP
case|:
if|if
condition|(
operator|!
name|priv
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|<
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|||
comment|/* check if cmsg_len is large enough for sa_len */
name|cm
operator|->
name|cmsg_len
operator|<
name|CMSG_LEN
argument_list|(
operator|*
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|needcopy
condition|)
block|{
name|opt
operator|->
name|ip6po_nexthop
operator|=
name|malloc
argument_list|(
operator|*
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
argument_list|,
name|M_IP6OPT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
argument_list|,
name|opt
operator|->
name|ip6po_nexthop
argument_list|,
operator|*
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|opt
operator|->
name|ip6po_nexthop
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPV6_HOPOPTS
case|:
block|{
name|struct
name|ip6_hbh
modifier|*
name|hbh
decl_stmt|;
name|int
name|hbhlen
decl_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|<
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hbh
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hbh
operator|=
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|hbhlen
operator|=
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|!=
name|CMSG_LEN
argument_list|(
name|hbhlen
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|needcopy
condition|)
block|{
name|opt
operator|->
name|ip6po_hbh
operator|=
name|malloc
argument_list|(
name|hbhlen
argument_list|,
name|M_IP6OPT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hbh
argument_list|,
name|opt
operator|->
name|ip6po_hbh
argument_list|,
name|hbhlen
argument_list|)
expr_stmt|;
block|}
else|else
name|opt
operator|->
name|ip6po_hbh
operator|=
name|hbh
expr_stmt|;
break|break;
block|}
case|case
name|IPV6_DSTOPTS
case|:
block|{
name|struct
name|ip6_dest
modifier|*
name|dest
decl_stmt|,
modifier|*
modifier|*
name|newdest
decl_stmt|;
name|int
name|destlen
decl_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|<
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_dest
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|dest
operator|=
operator|(
expr|struct
name|ip6_dest
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|destlen
operator|=
operator|(
name|dest
operator|->
name|ip6d_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|!=
name|CMSG_LEN
argument_list|(
name|destlen
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*  			 * The old advacned API is ambiguous on this 			 * point. Our approach is to determine the 			 * position based according to the existence 			 * of a routing header. Note, however, that 			 * this depends on the order of the extension 			 * headers in the ancillary data; the 1st part 			 * of the destination options header must 			 * appear before the routing header in the 			 * ancillary data, too. 			 * RFC2292bis solved the ambiguity by 			 * introducing separate cmsg types. 			 */
if|if
condition|(
name|opt
operator|->
name|ip6po_rthdr
operator|==
name|NULL
condition|)
name|newdest
operator|=
operator|&
name|opt
operator|->
name|ip6po_dest1
expr_stmt|;
else|else
name|newdest
operator|=
operator|&
name|opt
operator|->
name|ip6po_dest2
expr_stmt|;
if|if
condition|(
name|needcopy
condition|)
block|{
operator|*
name|newdest
operator|=
name|malloc
argument_list|(
name|destlen
argument_list|,
name|M_IP6OPT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dest
argument_list|,
operator|*
name|newdest
argument_list|,
name|destlen
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|newdest
operator|=
name|dest
expr_stmt|;
break|break;
block|}
case|case
name|IPV6_RTHDR
case|:
block|{
name|struct
name|ip6_rthdr
modifier|*
name|rth
decl_stmt|;
name|int
name|rthlen
decl_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|<
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_rthdr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rth
operator|=
operator|(
expr|struct
name|ip6_rthdr
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|rthlen
operator|=
operator|(
name|rth
operator|->
name|ip6r_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|!=
name|CMSG_LEN
argument_list|(
name|rthlen
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|rth
operator|->
name|ip6r_type
condition|)
block|{
case|case
name|IPV6_RTHDR_TYPE_0
case|:
comment|/* must contain one addr */
if|if
condition|(
name|rth
operator|->
name|ip6r_len
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* length must be even */
if|if
condition|(
name|rth
operator|->
name|ip6r_len
operator|%
literal|2
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|rth
operator|->
name|ip6r_len
operator|/
literal|2
operator|!=
name|rth
operator|->
name|ip6r_segleft
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* not supported */
block|}
if|if
condition|(
name|needcopy
condition|)
block|{
name|opt
operator|->
name|ip6po_rthdr
operator|=
name|malloc
argument_list|(
name|rthlen
argument_list|,
name|M_IP6OPT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|rth
argument_list|,
name|opt
operator|->
name|ip6po_rthdr
argument_list|,
name|rthlen
argument_list|)
expr_stmt|;
block|}
else|else
name|opt
operator|->
name|ip6po_rthdr
operator|=
name|rth
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routine called from ip6_output() to loop back a copy of an IP6 multicast  * packet to the input queue of a specified interface.  Note that this  * calls the output routine of the loopback "driver", but with an interface  * pointer that might NOT be&loif -- easier than replicating that code here.  */
end_comment

begin_function
name|void
name|ip6_mloopback
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|,
name|dst
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|dst
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|copym
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|copym
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|copym
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Make sure to deep-copy IPv6 header portion in case the data 	 * is in an mbuf cluster, so that we can safely override the IPv6 	 * header portion later. 	 */
if|if
condition|(
operator|(
name|copym
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|!=
literal|0
operator|||
name|copym
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|copym
operator|=
name|m_pullup
argument_list|(
name|copym
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copym
operator|==
name|NULL
condition|)
return|return;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|copym
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|copym
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|ip6
operator|=
name|mtod
argument_list|(
name|copym
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SCOPEDROUTING
comment|/* 	 * clear embedded scope identifiers if necessary. 	 * in6_clearscope will touch the addresses only when necessary. 	 */
name|in6_clearscope
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|if_simloop
argument_list|(
name|ifp
argument_list|,
name|copym
argument_list|,
name|dst
operator|->
name|sin6_family
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Chop IPv6 header off from the payload.  */
end_comment

begin_function
specifier|static
name|int
name|ip6_splithdr
parameter_list|(
name|m
parameter_list|,
name|exthdrs
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ip6_exthdrs
modifier|*
name|exthdrs
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|mh
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
condition|)
block|{
name|MGETHDR
argument_list|(
name|mh
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|M_COPY_PKTHDR
argument_list|(
name|mh
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|MH_ALIGN
argument_list|(
name|mh
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|mh
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip6
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exthdrs
operator|->
name|ip6e_ip6
operator|=
name|m
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Compute IPv6 extension header length.  */
end_comment

begin_function
name|int
name|ip6_optlen
parameter_list|(
name|in6p
parameter_list|)
name|struct
name|in6pcb
modifier|*
name|in6p
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|in6p
operator|->
name|in6p_outputopts
condition|)
return|return
literal|0
return|;
name|len
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|elen
parameter_list|(
name|x
parameter_list|)
define|\
value|(((struct ip6_ext *)(x)) ? (((struct ip6_ext *)(x))->ip6e_len + 1)<< 3 : 0)
name|len
operator|+=
name|elen
argument_list|(
name|in6p
operator|->
name|in6p_outputopts
operator|->
name|ip6po_hbh
argument_list|)
expr_stmt|;
if|if
condition|(
name|in6p
operator|->
name|in6p_outputopts
operator|->
name|ip6po_rthdr
condition|)
comment|/* dest1 is valid with rthdr only */
name|len
operator|+=
name|elen
argument_list|(
name|in6p
operator|->
name|in6p_outputopts
operator|->
name|ip6po_dest1
argument_list|)
expr_stmt|;
name|len
operator|+=
name|elen
argument_list|(
name|in6p
operator|->
name|in6p_outputopts
operator|->
name|ip6po_rthdr
argument_list|)
expr_stmt|;
name|len
operator|+=
name|elen
argument_list|(
name|in6p
operator|->
name|in6p_outputopts
operator|->
name|ip6po_dest2
argument_list|)
expr_stmt|;
return|return
name|len
return|;
undef|#
directive|undef
name|elen
block|}
end_function

end_unit

