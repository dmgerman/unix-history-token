begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************* Copyright (c) 2003-2007  Cavium Networks (support@cavium.com). All rights reserved.   Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright       notice, this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above       copyright notice, this list of conditions and the following       disclaimer in the documentation and/or other materials provided       with the distribution.      * Neither the name of Cavium Networks nor the names of       its contributors may be used to endorse or promote products       derived from this software without specific prior written       permission.  This Software, including technical data, may be subject to U.S. export  control laws, including the U.S. Export Administration Act and its  associated regulations, and may be subject to export or import  regulations in other countries.  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU. *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|"wrapper-cvmx-includes.h"
end_include

begin_include
include|#
directive|include
file|"ethernet-headers.h"
end_include

begin_include
include|#
directive|include
file|"octebusvar.h"
end_include

begin_comment
comment|/*  * XXX/juli  * Convert 0444 to tunables, 0644 to sysctls.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CAVIUM_OCTEON_NUM_PACKET_BUFFERS
argument_list|)
operator|&&
name|CONFIG_CAVIUM_OCTEON_NUM_PACKET_BUFFERS
end_if

begin_decl_stmt
name|int
name|num_packet_buffers
init|=
name|CONFIG_CAVIUM_OCTEON_NUM_PACKET_BUFFERS
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|num_packet_buffers
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.octe.num_packet_buffers"
argument_list|,
operator|&
name|num_packet_buffers
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 		 "\t\tNumber of packet buffers to allocate and store in the\n" 		 "\t\tFPA. By default, 1024 packet buffers are used unless\n" 		 "\t\tCONFIG_CAVIUM_OCTEON_NUM_PACKET_BUFFERS is defined." */
end_comment

begin_decl_stmt
name|int
name|pow_receive_group
init|=
literal|15
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.octe.pow_receive_group"
argument_list|,
operator|&
name|pow_receive_group
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 		 "\t\tPOW group to receive packets from. All ethernet hardware\n" 		 "\t\twill be configured to send incomming packets to this POW\n" 		 "\t\tgroup. Also any other software can submit packets to this\n" 		 "\t\tgroup for the kernel to process." */
end_comment

begin_comment
comment|/**  * Periodic timer to check auto negotiation  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|callout
name|cvm_oct_poll_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Array of every ethernet device owned by this driver indexed by  * the ipd input port number.  */
end_comment

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|cvm_oct_device
index|[
name|TOTAL_NUMBER_OF_PORTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Task to handle link status changes.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|taskqueue
modifier|*
name|cvm_oct_link_taskq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Number of buffers in output buffer pool.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cvm_oct_num_output_buffers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Function to update link status.  */
end_comment

begin_function
specifier|static
name|void
name|cvm_oct_update_link
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|cvm_oct_private_t
modifier|*
name|priv
init|=
operator|(
name|cvm_oct_private_t
operator|*
operator|)
name|context
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|priv
operator|->
name|ifp
decl_stmt|;
name|cvmx_helper_link_info_t
name|link_info
decl_stmt|;
name|link_info
operator|.
name|u64
operator|=
name|priv
operator|->
name|link_info
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|s
operator|.
name|link_up
condition|)
block|{
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
name|DEBUGPRINT
argument_list|(
literal|"%s: %u Mbps %s duplex, port %2d, queue %2d\n"
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|link_info
operator|.
name|s
operator|.
name|speed
argument_list|,
operator|(
name|link_info
operator|.
name|s
operator|.
name|full_duplex
operator|)
condition|?
literal|"Full"
else|:
literal|"Half"
argument_list|,
name|priv
operator|->
name|port
argument_list|,
name|priv
operator|->
name|queue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|DEBUGPRINT
argument_list|(
literal|"%s: Link down\n"
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|priv
operator|->
name|need_link_update
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Periodic timer tick for slow management operations  *  * @param arg    Device to check  */
end_comment

begin_function
specifier|static
name|void
name|cvm_do_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|static
name|int
name|port
decl_stmt|;
specifier|static
name|int
name|updated
decl_stmt|;
if|if
condition|(
name|port
operator|<
name|CVMX_PIP_NUM_INPUT_PORTS
condition|)
block|{
if|if
condition|(
name|cvm_oct_device
index|[
name|port
index|]
condition|)
block|{
name|int
name|queues_per_port
decl_stmt|;
name|int
name|qos
decl_stmt|;
name|cvm_oct_private_t
modifier|*
name|priv
init|=
operator|(
name|cvm_oct_private_t
operator|*
operator|)
name|cvm_oct_device
index|[
name|port
index|]
operator|->
name|if_softc
decl_stmt|;
name|cvm_oct_common_poll
argument_list|(
name|priv
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|need_link_update
condition|)
block|{
name|updated
operator|++
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|cvm_oct_link_taskq
argument_list|,
operator|&
name|priv
operator|->
name|link_task
argument_list|)
expr_stmt|;
block|}
name|queues_per_port
operator|=
name|cvmx_pko_get_num_queues
argument_list|(
name|port
argument_list|)
expr_stmt|;
comment|/* Drain any pending packets in the free list */
for|for
control|(
name|qos
operator|=
literal|0
init|;
name|qos
operator|<
name|queues_per_port
condition|;
name|qos
operator|++
control|)
block|{
if|if
condition|(
name|_IF_QLEN
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|IF_LOCK
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|_IF_QLEN
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
operator|>
name|cvmx_fau_fetch_and_add32
argument_list|(
name|priv
operator|->
name|fau
operator|+
name|qos
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|_IF_DEQUEUE
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|IF_UNLOCK
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
expr_stmt|;
comment|/* 					 * XXX locking! 					 */
name|priv
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
block|}
block|}
name|port
operator|++
expr_stmt|;
comment|/* Poll the next port in a 50th of a second. 		   This spreads the polling of ports out a little bit */
name|callout_reset
argument_list|(
operator|&
name|cvm_oct_poll_timer
argument_list|,
name|hz
operator|/
literal|50
argument_list|,
name|cvm_do_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|port
operator|=
literal|0
expr_stmt|;
comment|/* If any updates were made in this run, continue iterating at 		 * 1/50th of a second, so that if a link has merely gone down 		 * temporarily (e.g. because of interface reinitialization) it 		 * will not be forced to stay down for an entire second. 		 */
if|if
condition|(
name|updated
operator|>
literal|0
condition|)
block|{
name|updated
operator|=
literal|0
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|cvm_oct_poll_timer
argument_list|,
name|hz
operator|/
literal|50
argument_list|,
name|cvm_do_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* All ports have been polled. Start the next iteration through 			   the ports in one second */
name|callout_reset
argument_list|(
operator|&
name|cvm_oct_poll_timer
argument_list|,
name|hz
argument_list|,
name|cvm_do_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Configure common hardware for all interfaces  */
end_comment

begin_function
specifier|static
name|void
name|cvm_oct_configure_common_hw
parameter_list|(
name|device_t
name|bus
parameter_list|)
block|{
name|struct
name|octebus_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|pko_queues
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/* Setup the FPA */
name|cvmx_fpa_enable
argument_list|()
expr_stmt|;
name|cvm_oct_mem_fill_fpa
argument_list|(
name|CVMX_FPA_PACKET_POOL
argument_list|,
name|CVMX_FPA_PACKET_POOL_SIZE
argument_list|,
name|num_packet_buffers
argument_list|)
expr_stmt|;
name|cvm_oct_mem_fill_fpa
argument_list|(
name|CVMX_FPA_WQE_POOL
argument_list|,
name|CVMX_FPA_WQE_POOL_SIZE
argument_list|,
name|num_packet_buffers
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVMX_FPA_OUTPUT_BUFFER_POOL
operator|!=
name|CVMX_FPA_PACKET_POOL
condition|)
block|{
comment|/* 		 * If the FPA uses different pools for output buffers and 		 * packets, size the output buffer pool based on the number 		 * of PKO queues. 		 */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
condition|)
name|pko_queues
operator|=
literal|128
expr_stmt|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
name|pko_queues
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
name|pko_queues
operator|=
literal|32
expr_stmt|;
else|else
name|pko_queues
operator|=
literal|256
expr_stmt|;
name|cvm_oct_num_output_buffers
operator|=
literal|4
operator|*
name|pko_queues
expr_stmt|;
name|cvm_oct_mem_fill_fpa
argument_list|(
name|CVMX_FPA_OUTPUT_BUFFER_POOL
argument_list|,
name|CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE
argument_list|,
name|cvm_oct_num_output_buffers
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|USE_RED
condition|)
name|cvmx_helper_setup_red
argument_list|(
name|num_packet_buffers
operator|/
literal|4
argument_list|,
name|num_packet_buffers
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* Enable the MII interface */
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|!=
name|CVMX_BOARD_TYPE_SIM
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_SMI_EN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Register an IRQ hander for to receive POW interrupts */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rx_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|bus
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|OCTEON_IRQ_WORKQ0
operator|+
name|pow_receive_group
argument_list|,
name|OCTEON_IRQ_WORKQ0
operator|+
name|pow_receive_group
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rx_irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|bus
argument_list|,
literal|"could not allocate workq irq"
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|bus
argument_list|,
name|sc
operator|->
name|sc_rx_irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|cvm_oct_do_interrupt
argument_list|,
name|NULL
argument_list|,
name|cvm_oct_device
argument_list|,
operator|&
name|sc
operator|->
name|sc_rx_intr_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|bus
argument_list|,
literal|"could not setup workq irq"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|SMP
block|{
name|cvmx_ciu_intx0_t
name|en
decl_stmt|;
name|int
name|core
decl_stmt|;
name|CPU_FOREACH
argument_list|(
argument|core
argument_list|)
block|{
if|if
condition|(
name|core
operator|==
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
condition|)
continue|continue;
name|en
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
name|core
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|en
operator|.
name|s
operator|.
name|workq
operator||=
operator|(
literal|1
operator|<<
name|pow_receive_group
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
name|core
operator|*
literal|2
argument_list|)
argument_list|,
name|en
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * Free a work queue entry received in a intercept callback.  *  * @param work_queue_entry  *               Work queue entry to free  * @return Zero on success, Negative on failure.  */
end_comment

begin_function
name|int
name|cvm_oct_free_work
parameter_list|(
name|void
modifier|*
name|work_queue_entry
parameter_list|)
block|{
name|cvmx_wqe_t
modifier|*
name|work
init|=
name|work_queue_entry
decl_stmt|;
name|int
name|segments
init|=
name|work
operator|->
name|word2
operator|.
name|s
operator|.
name|bufs
decl_stmt|;
name|cvmx_buf_ptr_t
name|segment_ptr
init|=
name|work
operator|->
name|packet_ptr
decl_stmt|;
while|while
condition|(
name|segments
operator|--
condition|)
block|{
name|cvmx_buf_ptr_t
name|next_ptr
init|=
operator|*
operator|(
name|cvmx_buf_ptr_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|segment_ptr
operator|.
name|s
operator|.
name|addr
operator|-
literal|8
argument_list|)
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|segment_ptr
operator|.
name|s
operator|.
name|i
argument_list|)
condition|)
name|cvmx_fpa_free
argument_list|(
name|cvm_oct_get_buffer_ptr
argument_list|(
name|segment_ptr
argument_list|)
argument_list|,
name|segment_ptr
operator|.
name|s
operator|.
name|pool
argument_list|,
name|DONT_WRITEBACK
argument_list|(
name|CVMX_FPA_PACKET_POOL_SIZE
operator|/
literal|128
argument_list|)
argument_list|)
expr_stmt|;
name|segment_ptr
operator|=
name|next_ptr
expr_stmt|;
block|}
name|cvmx_fpa_free
argument_list|(
name|work
argument_list|,
name|CVMX_FPA_WQE_POOL
argument_list|,
name|DONT_WRITEBACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Module/ driver initialization. Creates the linux network  * devices.  *  * @return Zero on success  */
end_comment

begin_function
name|int
name|cvm_oct_init_module
parameter_list|(
name|device_t
name|bus
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|ifnum
decl_stmt|;
name|int
name|num_interfaces
decl_stmt|;
name|int
name|interface
decl_stmt|;
name|int
name|fau
init|=
name|FAU_NUM_PACKET_BUFFERS_TO_FREE
decl_stmt|;
name|int
name|qos
decl_stmt|;
name|cvm_oct_rx_initialize
argument_list|()
expr_stmt|;
name|cvm_oct_configure_common_hw
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|cvmx_helper_initialize_packet_io_global
argument_list|()
expr_stmt|;
comment|/* Change the input group for all ports before input is enabled */
name|num_interfaces
operator|=
name|cvmx_helper_get_number_of_interfaces
argument_list|()
expr_stmt|;
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
name|num_interfaces
condition|;
name|interface
operator|++
control|)
block|{
name|int
name|num_ports
init|=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
decl_stmt|;
name|int
name|port
decl_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|cvmx_pip_prt_tagx_t
name|pip_prt_tagx
decl_stmt|;
name|int
name|pkind
init|=
name|cvmx_helper_get_ipd_port
argument_list|(
name|interface
argument_list|,
name|port
argument_list|)
decl_stmt|;
name|pip_prt_tagx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_PRT_TAGX
argument_list|(
name|pkind
argument_list|)
argument_list|)
expr_stmt|;
name|pip_prt_tagx
operator|.
name|s
operator|.
name|grp
operator|=
name|pow_receive_group
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_PRT_TAGX
argument_list|(
name|pkind
argument_list|)
argument_list|,
name|pip_prt_tagx
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
name|cvmx_helper_ipd_and_packet_input_enable
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|cvm_oct_device
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cvm_oct_device
argument_list|)
argument_list|)
expr_stmt|;
name|cvm_oct_link_taskq
operator|=
name|taskqueue_create
argument_list|(
literal|"octe link"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|cvm_oct_link_taskq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|cvm_oct_link_taskq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"octe link taskq"
argument_list|)
expr_stmt|;
comment|/* Initialize the FAU used for counting packet buffers that need to be freed */
name|cvmx_fau_atomic_write32
argument_list|(
name|FAU_NUM_PACKET_BUFFERS_TO_FREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifnum
operator|=
literal|0
expr_stmt|;
name|num_interfaces
operator|=
name|cvmx_helper_get_number_of_interfaces
argument_list|()
expr_stmt|;
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
name|num_interfaces
condition|;
name|interface
operator|++
control|)
block|{
name|cvmx_helper_interface_mode_t
name|imode
init|=
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
decl_stmt|;
name|int
name|num_ports
init|=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
decl_stmt|;
name|int
name|port
decl_stmt|;
for|for
control|(
name|port
operator|=
name|cvmx_helper_get_ipd_port
argument_list|(
name|interface
argument_list|,
literal|0
argument_list|)
init|;
name|port
operator|<
name|cvmx_helper_get_ipd_port
argument_list|(
name|interface
argument_list|,
name|num_ports
argument_list|)
condition|;
name|ifnum
operator|++
operator|,
name|port
operator|++
control|)
block|{
name|cvm_oct_private_t
modifier|*
name|priv
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|dev
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|bus
argument_list|,
literal|0
argument_list|,
literal|"octe"
argument_list|,
name|ifnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
operator|||
name|ifp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to allocate ethernet device for interface %d port %d\n"
argument_list|,
name|interface
argument_list|,
name|port
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Initialize the device private structure. */
name|device_probe
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|priv
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|priv
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|priv
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|priv
operator|->
name|imode
operator|=
name|imode
expr_stmt|;
name|priv
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|priv
operator|->
name|queue
operator|=
name|cvmx_pko_get_base_queue
argument_list|(
name|priv
operator|->
name|port
argument_list|)
expr_stmt|;
name|priv
operator|->
name|fau
operator|=
name|fau
operator|-
name|cvmx_pko_get_num_queues
argument_list|(
name|port
argument_list|)
operator|*
literal|4
expr_stmt|;
for|for
control|(
name|qos
operator|=
literal|0
init|;
name|qos
operator|<
name|cvmx_pko_get_num_queues
argument_list|(
name|port
argument_list|)
condition|;
name|qos
operator|++
control|)
name|cvmx_fau_atomic_write32
argument_list|(
name|priv
operator|->
name|fau
operator|+
name|qos
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|priv
operator|->
name|link_task
argument_list|,
literal|0
argument_list|,
name|cvm_oct_update_link
argument_list|,
name|priv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|priv
operator|->
name|imode
condition|)
block|{
comment|/* These types don't support ports to IPD/PKO */
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
name|priv
operator|->
name|init
operator|=
name|cvm_oct_common_init
expr_stmt|;
name|priv
operator|->
name|uninit
operator|=
name|cvm_oct_common_uninit
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Cavium Octeon NPI Ethernet"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
name|priv
operator|->
name|init
operator|=
name|cvm_oct_xaui_init
expr_stmt|;
name|priv
operator|->
name|uninit
operator|=
name|cvm_oct_common_uninit
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Cavium Octeon XAUI Ethernet"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
name|priv
operator|->
name|init
operator|=
name|cvm_oct_common_init
expr_stmt|;
name|priv
operator|->
name|uninit
operator|=
name|cvm_oct_common_uninit
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Cavium Octeon LOOP Ethernet"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
name|priv
operator|->
name|init
operator|=
name|cvm_oct_sgmii_init
expr_stmt|;
name|priv
operator|->
name|uninit
operator|=
name|cvm_oct_common_uninit
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Cavium Octeon SGMII Ethernet"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
name|priv
operator|->
name|init
operator|=
name|cvm_oct_spi_init
expr_stmt|;
name|priv
operator|->
name|uninit
operator|=
name|cvm_oct_spi_uninit
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Cavium Octeon SPI Ethernet"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
name|priv
operator|->
name|init
operator|=
name|cvm_oct_rgmii_init
expr_stmt|;
name|priv
operator|->
name|uninit
operator|=
name|cvm_oct_rgmii_uninit
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Cavium Octeon RGMII Ethernet"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
name|priv
operator|->
name|init
operator|=
name|cvm_oct_rgmii_init
expr_stmt|;
name|priv
operator|->
name|uninit
operator|=
name|cvm_oct_rgmii_uninit
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Cavium Octeon GMII Ethernet"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|priv
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|init
condition|)
block|{
name|printf
argument_list|(
literal|"octe%d: unsupported device type interface %d, port %d\n"
argument_list|,
name|ifnum
argument_list|,
name|interface
argument_list|,
name|priv
operator|->
name|port
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|priv
operator|->
name|init
argument_list|(
name|ifp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"octe%d: failed to register device for interface %d, port %d\n"
argument_list|,
name|ifnum
argument_list|,
name|interface
argument_list|,
name|priv
operator|->
name|port
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvm_oct_device
index|[
name|priv
operator|->
name|port
index|]
operator|=
name|ifp
expr_stmt|;
name|fau
operator|-=
name|cvmx_pko_get_num_queues
argument_list|(
name|priv
operator|->
name|port
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|INTERRUPT_LIMIT
condition|)
block|{
comment|/* Set the POW timer rate to give an interrupt at most INTERRUPT_LIMIT times per second */
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_WQ_INT_PC
argument_list|,
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|/
operator|(
name|INTERRUPT_LIMIT
operator|*
literal|16
operator|*
literal|256
operator|)
operator|<<
literal|8
argument_list|)
expr_stmt|;
comment|/* Enable POW timer interrupt. It will count when there are packets available */
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_WQ_INT_THRX
argument_list|(
name|pow_receive_group
argument_list|)
argument_list|,
literal|0x1ful
operator|<<
literal|24
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Enable POW interrupt when our port has at least one packet */
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_WQ_INT_THRX
argument_list|(
name|pow_receive_group
argument_list|)
argument_list|,
literal|0x1001
argument_list|)
expr_stmt|;
block|}
name|callout_init
argument_list|(
operator|&
name|cvm_oct_poll_timer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|cvm_oct_poll_timer
argument_list|,
name|hz
argument_list|,
name|cvm_do_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Module / driver shutdown  *  * @return Zero on success  */
end_comment

begin_function
name|void
name|cvm_oct_cleanup_module
parameter_list|(
name|device_t
name|bus
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|struct
name|octebus_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
decl_stmt|;
comment|/* Disable POW interrupt */
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_WQ_INT_THRX
argument_list|(
name|pow_receive_group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Free the interrupt handler */
name|bus_teardown_intr
argument_list|(
name|bus
argument_list|,
name|sc
operator|->
name|sc_rx_irq
argument_list|,
name|sc
operator|->
name|sc_rx_intr_cookie
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|cvm_oct_poll_timer
argument_list|)
expr_stmt|;
name|cvm_oct_rx_shutdown
argument_list|()
expr_stmt|;
name|cvmx_helper_shutdown_packet_io_global
argument_list|()
expr_stmt|;
comment|/* Free the ethernet devices */
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|TOTAL_NUMBER_OF_PORTS
condition|;
name|port
operator|++
control|)
block|{
if|if
condition|(
name|cvm_oct_device
index|[
name|port
index|]
condition|)
block|{
name|cvm_oct_tx_shutdown
argument_list|(
name|cvm_oct_device
index|[
name|port
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|unregister_netdev(cvm_oct_device[port]); 			kfree(cvm_oct_device[port]);
else|#
directive|else
name|panic
argument_list|(
literal|"%s: need to detach and free interface."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvm_oct_device
index|[
name|port
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Free the HW pools */
name|cvm_oct_mem_empty_fpa
argument_list|(
name|CVMX_FPA_PACKET_POOL
argument_list|,
name|CVMX_FPA_PACKET_POOL_SIZE
argument_list|,
name|num_packet_buffers
argument_list|)
expr_stmt|;
name|cvm_oct_mem_empty_fpa
argument_list|(
name|CVMX_FPA_WQE_POOL
argument_list|,
name|CVMX_FPA_WQE_POOL_SIZE
argument_list|,
name|num_packet_buffers
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVMX_FPA_OUTPUT_BUFFER_POOL
operator|!=
name|CVMX_FPA_PACKET_POOL
condition|)
name|cvm_oct_mem_empty_fpa
argument_list|(
name|CVMX_FPA_OUTPUT_BUFFER_POOL
argument_list|,
name|CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE
argument_list|,
name|cvm_oct_num_output_buffers
argument_list|)
expr_stmt|;
comment|/* Disable FPA, all buffers are free, not done by helper shutdown. */
name|cvmx_fpa_disable
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

