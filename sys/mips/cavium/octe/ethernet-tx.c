begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************* Copyright (c) 2003-2007  Cavium Networks (support@cavium.com). All rights reserved.   Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright       notice, this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above       copyright notice, this list of conditions and the following       disclaimer in the documentation and/or other materials provided       with the distribution.      * Neither the name of Cavium Networks nor the names of       its contributors may be used to endorse or promote products       derived from this software without specific prior written       permission.  This Software, including technical data, may be subject to U.S. export  control laws, including the U.S. Export Administration Act and its  associated regulations, and may be subject to export or import  regulations in other countries.  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|"wrapper-cvmx-includes.h"
end_include

begin_include
include|#
directive|include
file|"ethernet-headers.h"
end_include

begin_comment
comment|/* You can define GET_MBUF_QOS() to override how the mbuf output function    determines which output queue is used. The default implementation    always uses the base queue for the port. If, for example, you wanted    to use the m->priority fieid, define GET_MBUF_QOS as:    #define GET_MBUF_QOS(m) ((m)->priority) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GET_MBUF_QOS
end_ifndef

begin_define
define|#
directive|define
name|GET_MBUF_QOS
parameter_list|(
name|m
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|pow_send_group
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Packet transmit  *  * @param m    Packet to send  * @param dev    Device info structure  * @return Always returns zero  */
end_comment

begin_function
name|int
name|cvm_oct_xmit
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|cvmx_pko_command_word0_t
name|pko_command
decl_stmt|;
name|cvmx_buf_ptr_t
name|hw_buffer
decl_stmt|;
name|uint64_t
name|old_scratch
decl_stmt|;
name|uint64_t
name|old_scratch2
decl_stmt|;
name|int
name|dropped
decl_stmt|;
name|int
name|qos
decl_stmt|;
name|cvm_oct_private_t
modifier|*
name|priv
init|=
operator|(
name|cvm_oct_private_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int32_t
name|in_use
decl_stmt|;
name|int32_t
name|buffers_to_free
decl_stmt|;
name|cvmx_wqe_t
modifier|*
name|work
decl_stmt|;
comment|/* Prefetch the private data structure. 	   It is larger that one cache line */
name|CVMX_PREFETCH
argument_list|(
name|priv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Start off assuming no drop */
name|dropped
operator|=
literal|0
expr_stmt|;
comment|/* The check on CVMX_PKO_QUEUES_PER_PORT_* is designed to completely 	   remove "qos" in the event neither interface supports multiple queues 	   per port */
if|if
condition|(
operator|(
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE0
operator|>
literal|1
operator|)
operator|||
operator|(
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE1
operator|>
literal|1
operator|)
condition|)
block|{
name|qos
operator|=
name|GET_MBUF_QOS
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|qos
operator|<=
literal|0
condition|)
name|qos
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|qos
operator|>=
name|cvmx_pko_get_num_queues
argument_list|(
name|priv
operator|->
name|port
argument_list|)
condition|)
name|qos
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|qos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|USE_ASYNC_IOBDMA
condition|)
block|{
comment|/* Save scratch in case userspace is using it */
name|CVMX_SYNCIOBDMA
expr_stmt|;
name|old_scratch
operator|=
name|cvmx_scratch_read64
argument_list|(
name|CVMX_SCR_SCRATCH
argument_list|)
expr_stmt|;
name|old_scratch2
operator|=
name|cvmx_scratch_read64
argument_list|(
name|CVMX_SCR_SCRATCH
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* Assume we're going to be able t osend this packet. Fetch and increment 		   the number of pending packets for output */
name|cvmx_fau_async_fetch_and_add32
argument_list|(
name|CVMX_SCR_SCRATCH
operator|+
literal|8
argument_list|,
name|FAU_NUM_PACKET_BUFFERS_TO_FREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_fau_async_fetch_and_add32
argument_list|(
name|CVMX_SCR_SCRATCH
argument_list|,
name|priv
operator|->
name|fau
operator|+
name|qos
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* The CN3XXX series of parts has an errata (GMX-401) which causes the 	   GMX block to hang if a collision occurs towards the end of a<68 byte packet. As a workaround for this, we pad packets to be 	   68 bytes whenever we are in half duplex mode. We don't handle 	   the case of having a small packet but no room to add the padding. 	   The kernel should always give us at least a cache line */
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|64
argument_list|)
operator|&&
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
block|{
name|cvmx_gmxx_prtx_cfg_t
name|gmx_prt_cfg
decl_stmt|;
name|int
name|interface
init|=
name|INTERFACE
argument_list|(
name|priv
operator|->
name|port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|INDEX
argument_list|(
name|priv
operator|->
name|port
argument_list|)
decl_stmt|;
if|if
condition|(
name|interface
operator|<
literal|2
condition|)
block|{
comment|/* We only need to pad packet in half duplex mode */
name|gmx_prt_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmx_prt_cfg
operator|.
name|s
operator|.
name|duplex
operator|==
literal|0
condition|)
block|{
specifier|static
name|uint8_t
name|pad
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|m_append
argument_list|(
name|m
argument_list|,
sizeof|sizeof
name|pad
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|pad
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s: unable to padd small packet."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If the packet is not fragmented. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
name|m
operator|->
name|m_len
condition|)
block|{
comment|/* Build the PKO buffer pointer */
name|hw_buffer
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|addr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|pool
operator|=
literal|0
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|size
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
comment|/* Build the PKO command */
name|pko_command
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|segs
operator|=
literal|1
expr_stmt|;
name|work
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|unsigned
name|segs
decl_stmt|;
name|uint64_t
modifier|*
name|gp
decl_stmt|;
comment|/* 		 * The packet is fragmented, we need to send a list of segments 		 * in memory we borrow from the WQE pool. 		 */
name|work
operator|=
name|cvmx_fpa_alloc
argument_list|(
name|CVMX_FPA_WQE_POOL
argument_list|)
expr_stmt|;
name|gp
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|work
expr_stmt|;
name|segs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|m
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|segs
operator|==
name|CVMX_FPA_WQE_POOL_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: too many segments in packet; call m_collapse()."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Build the PKO buffer pointer */
name|hw_buffer
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|addr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|n
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|pool
operator|=
literal|0
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|size
operator|=
name|n
operator|->
name|m_len
expr_stmt|;
operator|*
name|gp
operator|++
operator|=
name|hw_buffer
operator|.
name|u64
expr_stmt|;
name|segs
operator|++
expr_stmt|;
block|}
comment|/* Build the PKO buffer gather list pointer */
name|hw_buffer
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|addr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|pool
operator|=
name|CVMX_FPA_WQE_POOL
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|size
operator|=
name|segs
expr_stmt|;
comment|/* Build the PKO command */
name|pko_command
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|segs
operator|=
name|segs
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|gather
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Finish building the PKO command */
name|pko_command
operator|.
name|s
operator|.
name|n2
operator|=
literal|1
expr_stmt|;
comment|/* Don't pollute L2 with the outgoing packet */
name|pko_command
operator|.
name|s
operator|.
name|dontfree
operator|=
literal|1
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|reg0
operator|=
name|priv
operator|->
name|fau
operator|+
name|qos
operator|*
literal|4
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|reg0
operator|=
name|priv
operator|->
name|fau
operator|+
name|qos
operator|*
literal|4
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|total_bytes
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|size0
operator|=
name|CVMX_FAU_OP_SIZE_32
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|subone0
operator|=
literal|1
expr_stmt|;
comment|/* Check if we can use the hardware checksumming */
if|if
condition|(
name|USE_HW_TCPUDP_CHECKSUM
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Use hardware checksum calc */
name|pko_command
operator|.
name|s
operator|.
name|ipoffp1
operator|=
name|ETHER_HDR_LEN
operator|+
literal|1
expr_stmt|;
block|}
name|IF_LOCK
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|USE_ASYNC_IOBDMA
condition|)
block|{
comment|/* Get the number of mbufs in use by the hardware */
name|CVMX_SYNCIOBDMA
expr_stmt|;
name|in_use
operator|=
name|cvmx_scratch_read64
argument_list|(
name|CVMX_SCR_SCRATCH
argument_list|)
expr_stmt|;
name|buffers_to_free
operator|=
name|cvmx_scratch_read64
argument_list|(
name|CVMX_SCR_SCRATCH
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Get the number of mbufs in use by the hardware */
name|in_use
operator|=
name|cvmx_fau_fetch_and_add32
argument_list|(
name|priv
operator|->
name|fau
operator|+
name|qos
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buffers_to_free
operator|=
name|cvmx_fau_fetch_and_add32
argument_list|(
name|FAU_NUM_PACKET_BUFFERS_TO_FREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cvmx_pko_send_packet_prepare
argument_list|(
name|priv
operator|->
name|port
argument_list|,
name|priv
operator|->
name|queue
operator|+
name|qos
argument_list|,
name|CVMX_PKO_LOCK_CMD_QUEUE
argument_list|)
expr_stmt|;
comment|/* Drop this packet if we have too many already queued to the HW */
if|if
condition|(
name|_IF_QFULL
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
condition|)
block|{
name|dropped
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Send the packet to the output queue */
elseif|else
if|if
condition|(
name|__predict_false
argument_list|(
name|cvmx_pko_send_packet_finish
argument_list|(
name|priv
operator|->
name|port
argument_list|,
name|priv
operator|->
name|queue
operator|+
name|qos
argument_list|,
name|pko_command
argument_list|,
name|hw_buffer
argument_list|,
name|CVMX_PKO_LOCK_CMD_QUEUE
argument_list|)
argument_list|)
condition|)
block|{
name|DEBUGPRINT
argument_list|(
literal|"%s: Failed to send the packet\n"
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|dropped
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|USE_ASYNC_IOBDMA
condition|)
block|{
comment|/* Restore the scratch area */
name|cvmx_scratch_write64
argument_list|(
name|CVMX_SCR_SCRATCH
argument_list|,
name|old_scratch
argument_list|)
expr_stmt|;
name|cvmx_scratch_write64
argument_list|(
name|CVMX_SCR_SCRATCH
operator|+
literal|8
argument_list|,
name|old_scratch2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|dropped
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|cvmx_fau_atomic_add32
argument_list|(
name|priv
operator|->
name|fau
operator|+
name|qos
operator|*
literal|4
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Put this packet on the queue to be freed later */
name|_IF_ENQUEUE
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Pass it to any BPF listeners.  */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|work
operator|!=
name|NULL
condition|)
name|cvmx_fpa_free
argument_list|(
name|work
argument_list|,
name|CVMX_FPA_WQE_POOL
argument_list|,
name|DONT_WRITEBACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free mbufs not in use by the hardware */
if|if
condition|(
name|_IF_QLEN
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
operator|>
name|in_use
condition|)
block|{
while|while
condition|(
name|_IF_QLEN
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
operator|>
name|in_use
condition|)
block|{
name|_IF_DEQUEUE
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|IF_UNLOCK
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
expr_stmt|;
return|return
name|dropped
return|;
block|}
end_function

begin_comment
comment|/**  * Packet transmit to the POW  *  * @param m    Packet to send  * @param dev    Device info structure  * @return Always returns zero  */
end_comment

begin_function
name|int
name|cvm_oct_xmit_pow
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|cvm_oct_private_t
modifier|*
name|priv
init|=
operator|(
name|cvm_oct_private_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|char
modifier|*
name|packet_buffer
decl_stmt|;
name|char
modifier|*
name|copy_location
decl_stmt|;
comment|/* Get a work queue entry */
name|cvmx_wqe_t
modifier|*
name|work
init|=
name|cvmx_fpa_alloc
argument_list|(
name|CVMX_FPA_WQE_POOL
argument_list|)
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|work
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|DEBUGPRINT
argument_list|(
literal|"%s: Failed to allocate a work queue entry\n"
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Get a packet buffer */
name|packet_buffer
operator|=
name|cvmx_fpa_alloc
argument_list|(
name|CVMX_FPA_PACKET_POOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|packet_buffer
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|DEBUGPRINT
argument_list|(
literal|"%s: Failed to allocate a packet buffer\n"
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_fpa_free
argument_list|(
name|work
argument_list|,
name|CVMX_FPA_WQE_POOL
argument_list|,
name|DONT_WRITEBACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Calculate where we need to copy the data to. We need to leave 8 bytes 	   for a next pointer (unused). We also need to include any configure 	   skip. Then we need to align the IP packet src and dest into the same 	   64bit word. The below calculation may add a little extra, but that 	   doesn't hurt */
name|copy_location
operator|=
name|packet_buffer
operator|+
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|copy_location
operator|+=
operator|(
operator|(
name|CVMX_HELPER_FIRST_MBUFF_SKIP
operator|+
literal|7
operator|)
operator|&
literal|0xfff8
operator|)
operator|+
literal|6
expr_stmt|;
comment|/* We have to copy the packet since whoever processes this packet 	   will free it to a hardware pool. We can't use the trick of 	   counting outstanding packets like in cvm_oct_xmit */
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|copy_location
argument_list|)
expr_stmt|;
comment|/* Fill in some of the work queue fields. We may need to add more 	   if the software at the other end needs them */
if|#
directive|if
literal|0
block|work->hw_chksum     = m->csum;
endif|#
directive|endif
name|work
operator|->
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|work
operator|->
name|ipprt
operator|=
name|priv
operator|->
name|port
expr_stmt|;
name|work
operator|->
name|qos
operator|=
name|priv
operator|->
name|port
operator|&
literal|0x7
expr_stmt|;
name|work
operator|->
name|grp
operator|=
name|pow_send_group
expr_stmt|;
name|work
operator|->
name|tag_type
operator|=
name|CVMX_HELPER_INPUT_TAG_TYPE
expr_stmt|;
name|work
operator|->
name|tag
operator|=
name|pow_send_group
expr_stmt|;
comment|/* FIXME */
name|work
operator|->
name|word2
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
comment|/* Default to zero. Sets of zero later are commented out */
name|work
operator|->
name|word2
operator|.
name|s
operator|.
name|bufs
operator|=
literal|1
expr_stmt|;
name|work
operator|->
name|packet_ptr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|work
operator|->
name|packet_ptr
operator|.
name|s
operator|.
name|addr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|copy_location
argument_list|)
expr_stmt|;
name|work
operator|->
name|packet_ptr
operator|.
name|s
operator|.
name|pool
operator|=
name|CVMX_FPA_PACKET_POOL
expr_stmt|;
name|work
operator|->
name|packet_ptr
operator|.
name|s
operator|.
name|size
operator|=
name|CVMX_FPA_PACKET_POOL_SIZE
expr_stmt|;
name|work
operator|->
name|packet_ptr
operator|.
name|s
operator|.
name|back
operator|=
operator|(
name|copy_location
operator|-
name|packet_buffer
operator|)
operator|>>
literal|7
expr_stmt|;
name|panic
argument_list|(
literal|"%s: POW transmit not quite implemented yet."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (m->protocol == htons(ETH_P_IP)) { 		work->word2.s.ip_offset     = 14;
if|#
directive|if
literal|0
block|work->word2.s.vlan_valid  = 0;
comment|/* FIXME */
block|work->word2.s.vlan_cfi    = 0;
comment|/* FIXME */
block|work->word2.s.vlan_id     = 0;
comment|/* FIXME */
block|work->word2.s.dec_ipcomp  = 0;
comment|/* FIXME */
endif|#
directive|endif
block|work->word2.s.tcp_or_udp    = (ip_hdr(m)->protocol == IP_PROTOCOL_TCP) || (ip_hdr(m)->protocol == IP_PROTOCOL_UDP);
if|#
directive|if
literal|0
block|work->word2.s.dec_ipsec   = 0;
comment|/* FIXME */
block|work->word2.s.is_v6       = 0;
comment|/* We only support IPv4 right now */
block|work->word2.s.software    = 0;
comment|/* Hardware would set to zero */
block|work->word2.s.L4_error    = 0;
comment|/* No error, packet is internal */
endif|#
directive|endif
block|work->word2.s.is_frag       = !((ip_hdr(m)->frag_off == 0) || (ip_hdr(m)->frag_off == 1<<14));
if|#
directive|if
literal|0
block|work->word2.s.IP_exc      = 0;
comment|/* Assume Linux is sending a good packet */
endif|#
directive|endif
block|work->word2.s.is_bcast      = (m->pkt_type == PACKET_BROADCAST); 		work->word2.s.is_mcast      = (m->pkt_type == PACKET_MULTICAST);
if|#
directive|if
literal|0
block|work->word2.s.not_IP      = 0;
comment|/* This is an IP packet */
block|work->word2.s.rcv_error   = 0;
comment|/* No error, packet is internal */
block|work->word2.s.err_code    = 0;
comment|/* No error, packet is internal */
endif|#
directive|endif
comment|/* When copying the data, include 4 bytes of the ethernet header to 		   align the same way hardware does */
block|memcpy(work->packet_data, m->data + 10, sizeof(work->packet_data)); 	} else {
if|#
directive|if
literal|0
block|work->word2.snoip.vlan_valid  = 0;
comment|/* FIXME */
block|work->word2.snoip.vlan_cfi    = 0;
comment|/* FIXME */
block|work->word2.snoip.vlan_id     = 0;
comment|/* FIXME */
block|work->word2.snoip.software    = 0;
comment|/* Hardware would set to zero */
endif|#
directive|endif
block|work->word2.snoip.is_rarp       = m->protocol == htons(ETH_P_RARP); 		work->word2.snoip.is_arp        = m->protocol == htons(ETH_P_ARP); 		work->word2.snoip.is_bcast      = (m->pkt_type == PACKET_BROADCAST); 		work->word2.snoip.is_mcast      = (m->pkt_type == PACKET_MULTICAST); 		work->word2.snoip.not_IP        = 1;
comment|/* IP was done up above */
if|#
directive|if
literal|0
block|work->word2.snoip.rcv_error   = 0;
comment|/* No error, packet is internal */
block|work->word2.snoip.err_code    = 0;
comment|/* No error, packet is internal */
endif|#
directive|endif
block|memcpy(work->packet_data, m->data, sizeof(work->packet_data)); 	}
endif|#
directive|endif
comment|/* Submit the packet to the POW */
name|cvmx_pow_work_submit
argument_list|(
name|work
argument_list|,
name|work
operator|->
name|tag
argument_list|,
name|work
operator|->
name|tag_type
argument_list|,
name|work
operator|->
name|qos
argument_list|,
name|work
operator|->
name|grp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * This function frees all mbufs that are currenty queued for TX.  *  * @param dev    Device being shutdown  */
end_comment

begin_function
name|void
name|cvm_oct_tx_shutdown
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|cvm_oct_private_t
modifier|*
name|priv
init|=
operator|(
name|cvm_oct_private_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|qos
decl_stmt|;
for|for
control|(
name|qos
operator|=
literal|0
init|;
name|qos
operator|<
literal|16
condition|;
name|qos
operator|++
control|)
block|{
name|IF_DRAIN
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

