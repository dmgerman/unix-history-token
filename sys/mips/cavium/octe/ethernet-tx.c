begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************* Copyright (c) 2003-2007  Cavium Networks (support@cavium.com). All rights reserved.   Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright       notice, this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above       copyright notice, this list of conditions and the following       disclaimer in the documentation and/or other materials provided       with the distribution.      * Neither the name of Cavium Networks nor the names of       its contributors may be used to endorse or promote products       derived from this software without specific prior written       permission.  This Software, including technical data, may be subject to U.S. export  control laws, including the U.S. Export Administration Act and its  associated regulations, and may be subject to export or import  regulations in other countries.  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|"wrapper-cvmx-includes.h"
end_include

begin_include
include|#
directive|include
file|"ethernet-headers.h"
end_include

begin_comment
comment|/* You can define GET_MBUF_QOS() to override how the mbuf output function    determines which output queue is used. The default implementation    always uses the base queue for the port. If, for example, you wanted    to use the m->priority fieid, define GET_MBUF_QOS as:    #define GET_MBUF_QOS(m) ((m)->priority) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GET_MBUF_QOS
end_ifndef

begin_define
define|#
directive|define
name|GET_MBUF_QOS
parameter_list|(
name|m
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Packet transmit  *  * @param m    Packet to send  * @param dev    Device info structure  * @return Always returns zero  */
end_comment

begin_function
name|int
name|cvm_oct_xmit
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|cvmx_pko_command_word0_t
name|pko_command
decl_stmt|;
name|cvmx_buf_ptr_t
name|hw_buffer
decl_stmt|;
name|int
name|dropped
decl_stmt|;
name|int
name|qos
decl_stmt|;
name|cvm_oct_private_t
modifier|*
name|priv
init|=
operator|(
name|cvm_oct_private_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int32_t
name|in_use
decl_stmt|;
name|int32_t
name|buffers_to_free
decl_stmt|;
name|cvmx_wqe_t
modifier|*
name|work
decl_stmt|;
comment|/* Prefetch the private data structure. 	   It is larger that one cache line */
name|CVMX_PREFETCH
argument_list|(
name|priv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Start off assuming no drop */
name|dropped
operator|=
literal|0
expr_stmt|;
comment|/* The check on CVMX_PKO_QUEUES_PER_PORT_* is designed to completely 	   remove "qos" in the event neither interface supports multiple queues 	   per port */
if|if
condition|(
operator|(
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE0
operator|>
literal|1
operator|)
operator|||
operator|(
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE1
operator|>
literal|1
operator|)
condition|)
block|{
name|qos
operator|=
name|GET_MBUF_QOS
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|qos
operator|<=
literal|0
condition|)
name|qos
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|qos
operator|>=
name|cvmx_pko_get_num_queues
argument_list|(
name|priv
operator|->
name|port
argument_list|)
condition|)
name|qos
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|qos
operator|=
literal|0
expr_stmt|;
comment|/* The CN3XXX series of parts has an errata (GMX-401) which causes the 	   GMX block to hang if a collision occurs towards the end of a<68 byte packet. As a workaround for this, we pad packets to be 	   68 bytes whenever we are in half duplex mode. We don't handle 	   the case of having a small packet but no room to add the padding. 	   The kernel should always give us at least a cache line */
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|64
argument_list|)
operator|&&
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
block|{
name|cvmx_gmxx_prtx_cfg_t
name|gmx_prt_cfg
decl_stmt|;
name|int
name|interface
init|=
name|INTERFACE
argument_list|(
name|priv
operator|->
name|port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|INDEX
argument_list|(
name|priv
operator|->
name|port
argument_list|)
decl_stmt|;
if|if
condition|(
name|interface
operator|<
literal|2
condition|)
block|{
comment|/* We only need to pad packet in half duplex mode */
name|gmx_prt_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmx_prt_cfg
operator|.
name|s
operator|.
name|duplex
operator|==
literal|0
condition|)
block|{
specifier|static
name|uint8_t
name|pad
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|m_append
argument_list|(
name|m
argument_list|,
sizeof|sizeof
name|pad
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|pad
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s: unable to padd small packet."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|OCTEON_VENDOR_RADISYS
comment|/* 	 * The RSYS4GBE will hang if asked to transmit a packet less than 60 bytes. 	 */
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|60
argument_list|)
operator|&&
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_CUST_RADISYS_RSYS4GBE
condition|)
block|{
specifier|static
name|uint8_t
name|pad
index|[
literal|60
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|m_append
argument_list|(
name|m
argument_list|,
sizeof|sizeof
name|pad
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|pad
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s: unable to pad small packet."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * If the packet is not fragmented. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
name|m
operator|->
name|m_len
condition|)
block|{
comment|/* Build the PKO buffer pointer */
name|hw_buffer
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|addr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|pool
operator|=
literal|0
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|size
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
comment|/* Build the PKO command */
name|pko_command
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|segs
operator|=
literal|1
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|dontfree
operator|=
literal|1
expr_stmt|;
comment|/* Do not put this buffer into the FPA.  */
name|work
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|unsigned
name|segs
decl_stmt|;
name|uint64_t
modifier|*
name|gp
decl_stmt|;
comment|/* 		 * The packet is fragmented, we need to send a list of segments 		 * in memory we borrow from the WQE pool. 		 */
name|work
operator|=
name|cvmx_fpa_alloc
argument_list|(
name|CVMX_FPA_WQE_POOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|segs
operator|=
literal|0
expr_stmt|;
name|gp
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|work
expr_stmt|;
for|for
control|(
name|n
operator|=
name|m
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|segs
operator|==
name|CVMX_FPA_WQE_POOL_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: too many segments in packet; call m_collapse()."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Build the PKO buffer pointer */
name|hw_buffer
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|i
operator|=
literal|1
expr_stmt|;
comment|/* Do not put this buffer into the FPA.  */
name|hw_buffer
operator|.
name|s
operator|.
name|addr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|n
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|pool
operator|=
literal|0
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|size
operator|=
name|n
operator|->
name|m_len
expr_stmt|;
operator|*
name|gp
operator|++
operator|=
name|hw_buffer
operator|.
name|u64
expr_stmt|;
name|segs
operator|++
expr_stmt|;
block|}
comment|/* Build the PKO buffer gather list pointer */
name|hw_buffer
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|addr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|pool
operator|=
name|CVMX_FPA_WQE_POOL
expr_stmt|;
name|hw_buffer
operator|.
name|s
operator|.
name|size
operator|=
name|segs
expr_stmt|;
comment|/* Build the PKO command */
name|pko_command
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|segs
operator|=
name|segs
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|gather
operator|=
literal|1
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|dontfree
operator|=
literal|0
expr_stmt|;
comment|/* Put the WQE above back into the FPA.  */
block|}
comment|/* Finish building the PKO command */
name|pko_command
operator|.
name|s
operator|.
name|n2
operator|=
literal|1
expr_stmt|;
comment|/* Don't pollute L2 with the outgoing packet */
name|pko_command
operator|.
name|s
operator|.
name|reg0
operator|=
name|priv
operator|->
name|fau
operator|+
name|qos
operator|*
literal|4
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|total_bytes
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|size0
operator|=
name|CVMX_FAU_OP_SIZE_32
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|subone0
operator|=
literal|1
expr_stmt|;
comment|/* Check if we can use the hardware checksumming */
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Use hardware checksum calc */
name|pko_command
operator|.
name|s
operator|.
name|ipoffp1
operator|=
name|ETHER_HDR_LEN
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	 * XXX 	 * Could use a different free queue (and different FAU address) per 	 * core instead of per QoS, to reduce contention here. 	 */
name|IF_LOCK
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
expr_stmt|;
comment|/* Get the number of mbufs in use by the hardware */
name|in_use
operator|=
name|cvmx_fau_fetch_and_add32
argument_list|(
name|priv
operator|->
name|fau
operator|+
name|qos
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buffers_to_free
operator|=
name|cvmx_fau_fetch_and_add32
argument_list|(
name|FAU_NUM_PACKET_BUFFERS_TO_FREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_pko_send_packet_prepare
argument_list|(
name|priv
operator|->
name|port
argument_list|,
name|priv
operator|->
name|queue
operator|+
name|qos
argument_list|,
name|CVMX_PKO_LOCK_CMD_QUEUE
argument_list|)
expr_stmt|;
comment|/* Drop this packet if we have too many already queued to the HW */
if|if
condition|(
name|_IF_QFULL
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
condition|)
block|{
name|dropped
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Send the packet to the output queue */
elseif|else
if|if
condition|(
name|__predict_false
argument_list|(
name|cvmx_pko_send_packet_finish
argument_list|(
name|priv
operator|->
name|port
argument_list|,
name|priv
operator|->
name|queue
operator|+
name|qos
argument_list|,
name|pko_command
argument_list|,
name|hw_buffer
argument_list|,
name|CVMX_PKO_LOCK_CMD_QUEUE
argument_list|)
argument_list|)
condition|)
block|{
name|DEBUGPRINT
argument_list|(
literal|"%s: Failed to send the packet\n"
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|dropped
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|dropped
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|cvmx_fau_atomic_add32
argument_list|(
name|priv
operator|->
name|fau
operator|+
name|qos
operator|*
literal|4
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Put this packet on the queue to be freed later */
name|_IF_ENQUEUE
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Pass it to any BPF listeners.  */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OBYTES
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Free mbufs not in use by the hardware */
if|if
condition|(
name|_IF_QLEN
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
operator|>
name|in_use
condition|)
block|{
while|while
condition|(
name|_IF_QLEN
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
operator|>
name|in_use
condition|)
block|{
name|_IF_DEQUEUE
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|IF_UNLOCK
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
expr_stmt|;
return|return
name|dropped
return|;
block|}
end_function

begin_comment
comment|/**  * This function frees all mbufs that are currenty queued for TX.  *  * @param dev    Device being shutdown  */
end_comment

begin_function
name|void
name|cvm_oct_tx_shutdown
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|cvm_oct_private_t
modifier|*
name|priv
init|=
operator|(
name|cvm_oct_private_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|qos
decl_stmt|;
for|for
control|(
name|qos
operator|=
literal|0
init|;
name|qos
operator|<
literal|16
condition|;
name|qos
operator|++
control|)
block|{
name|IF_DRAIN
argument_list|(
operator|&
name|priv
operator|->
name|tx_free_queue
index|[
name|qos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

