begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************* Copyright (c) 2003-2007  Cavium Networks (support@cavium.com). All rights reserved.   Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright       notice, this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above       copyright notice, this list of conditions and the following       disclaimer in the documentation and/or other materials provided       with the distribution.      * Neither the name of Cavium Networks nor the names of       its contributors may be used to endorse or promote products       derived from this software without specific prior written       permission.  This Software, including technical data, may be subject to U.S. export  control laws, including the U.S. Export Administration Act and its  associated regulations, and may be subject to export or import  regulations in other countries.  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|"wrapper-cvmx-includes.h"
end_include

begin_include
include|#
directive|include
file|"ethernet-headers.h"
end_include

begin_include
include|#
directive|include
file|"octebusvar.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|number_spi_ports
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|need_retrain
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|cvm_oct_spi_rml_interrupt
parameter_list|(
name|void
modifier|*
name|dev_id
parameter_list|)
block|{
name|int
name|return_status
init|=
name|FILTER_STRAY
decl_stmt|;
name|cvmx_npi_rsl_int_blocks_t
name|rsl_int_blocks
decl_stmt|;
comment|/* Check and see if this interrupt was caused by the GMX block */
name|rsl_int_blocks
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_NPI_RSL_INT_BLOCKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|.
name|s
operator|.
name|spx1
condition|)
block|{
comment|/* 19 - SPX1_INT_REG& STX1_INT_REG */
name|cvmx_spxx_int_reg_t
name|spx_int_reg
decl_stmt|;
name|cvmx_stxx_int_reg_t
name|stx_int_reg
decl_stmt|;
name|spx_int_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SPXX_INT_REG
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_INT_REG
argument_list|(
literal|1
argument_list|)
argument_list|,
name|spx_int_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_retrain
index|[
literal|1
index|]
condition|)
block|{
name|spx_int_reg
operator|.
name|u64
operator|&=
name|cvmx_read_csr
argument_list|(
name|CVMX_SPXX_INT_MSK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|spf
condition|)
name|printf
argument_list|(
literal|"SPI1: SRX Spi4 interface down\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|calerr
condition|)
name|printf
argument_list|(
literal|"SPI1: SRX Spi4 Calendar table parity error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|syncerr
condition|)
name|printf
argument_list|(
literal|"SPI1: SRX Consecutive Spi4 DIP4 errors have exceeded SPX_ERR_CTL[ERRCNT]\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|diperr
condition|)
name|printf
argument_list|(
literal|"SPI1: SRX Spi4 DIP4 error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|tpaovr
condition|)
name|printf
argument_list|(
literal|"SPI1: SRX Selected port has hit TPA overflow\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|rsverr
condition|)
name|printf
argument_list|(
literal|"SPI1: SRX Spi4 reserved control word detected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|drwnng
condition|)
name|printf
argument_list|(
literal|"SPI1: SRX Spi4 receive FIFO drowning/overflow\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|clserr
condition|)
name|printf
argument_list|(
literal|"SPI1: SRX Spi4 packet closed on non-16B alignment without EOP\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|spiovr
condition|)
name|printf
argument_list|(
literal|"SPI1: SRX Spi4 async FIFO overflow\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|abnorm
condition|)
name|printf
argument_list|(
literal|"SPI1: SRX Abnormal packet termination (ERR bit)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|prtnxa
condition|)
name|printf
argument_list|(
literal|"SPI1: SRX Port out of range\n"
argument_list|)
expr_stmt|;
block|}
name|stx_int_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_STXX_INT_REG
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_INT_REG
argument_list|(
literal|1
argument_list|)
argument_list|,
name|stx_int_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_retrain
index|[
literal|1
index|]
condition|)
block|{
name|stx_int_reg
operator|.
name|u64
operator|&=
name|cvmx_read_csr
argument_list|(
name|CVMX_STXX_INT_MSK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|syncerr
condition|)
name|printf
argument_list|(
literal|"SPI1: STX Interface encountered a fatal error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|frmerr
condition|)
name|printf
argument_list|(
literal|"SPI1: STX FRMCNT has exceeded STX_DIP_CNT[MAXFRM]\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|unxfrm
condition|)
name|printf
argument_list|(
literal|"SPI1: STX Unexpected framing sequence\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|nosync
condition|)
name|printf
argument_list|(
literal|"SPI1: STX ERRCNT has exceeded STX_DIP_CNT[MAXDIP]\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|diperr
condition|)
name|printf
argument_list|(
literal|"SPI1: STX DIP2 error on the Spi4 Status channel\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|datovr
condition|)
name|printf
argument_list|(
literal|"SPI1: STX Spi4 FIFO overflow error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|ovrbst
condition|)
name|printf
argument_list|(
literal|"SPI1: STX Transmit packet burst too big\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|calpar1
condition|)
name|printf
argument_list|(
literal|"SPI1: STX Calendar Table Parity Error Bank1\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|calpar0
condition|)
name|printf
argument_list|(
literal|"SPI1: STX Calendar Table Parity Error Bank0\n"
argument_list|)
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_INT_MSK
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_INT_MSK
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|need_retrain
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|return_status
operator|=
name|FILTER_HANDLED
expr_stmt|;
block|}
if|if
condition|(
name|rsl_int_blocks
operator|.
name|s
operator|.
name|spx0
condition|)
block|{
comment|/* 18 - SPX0_INT_REG& STX0_INT_REG */
name|cvmx_spxx_int_reg_t
name|spx_int_reg
decl_stmt|;
name|cvmx_stxx_int_reg_t
name|stx_int_reg
decl_stmt|;
name|spx_int_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SPXX_INT_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_INT_REG
argument_list|(
literal|0
argument_list|)
argument_list|,
name|spx_int_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_retrain
index|[
literal|0
index|]
condition|)
block|{
name|spx_int_reg
operator|.
name|u64
operator|&=
name|cvmx_read_csr
argument_list|(
name|CVMX_SPXX_INT_MSK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|spf
condition|)
name|printf
argument_list|(
literal|"SPI0: SRX Spi4 interface down\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|calerr
condition|)
name|printf
argument_list|(
literal|"SPI0: SRX Spi4 Calendar table parity error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|syncerr
condition|)
name|printf
argument_list|(
literal|"SPI0: SRX Consecutive Spi4 DIP4 errors have exceeded SPX_ERR_CTL[ERRCNT]\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|diperr
condition|)
name|printf
argument_list|(
literal|"SPI0: SRX Spi4 DIP4 error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|tpaovr
condition|)
name|printf
argument_list|(
literal|"SPI0: SRX Selected port has hit TPA overflow\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|rsverr
condition|)
name|printf
argument_list|(
literal|"SPI0: SRX Spi4 reserved control word detected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|drwnng
condition|)
name|printf
argument_list|(
literal|"SPI0: SRX Spi4 receive FIFO drowning/overflow\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|clserr
condition|)
name|printf
argument_list|(
literal|"SPI0: SRX Spi4 packet closed on non-16B alignment without EOP\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|spiovr
condition|)
name|printf
argument_list|(
literal|"SPI0: SRX Spi4 async FIFO overflow\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|abnorm
condition|)
name|printf
argument_list|(
literal|"SPI0: SRX Abnormal packet termination (ERR bit)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_int_reg
operator|.
name|s
operator|.
name|prtnxa
condition|)
name|printf
argument_list|(
literal|"SPI0: SRX Port out of range\n"
argument_list|)
expr_stmt|;
block|}
name|stx_int_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_STXX_INT_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_INT_REG
argument_list|(
literal|0
argument_list|)
argument_list|,
name|stx_int_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_retrain
index|[
literal|0
index|]
condition|)
block|{
name|stx_int_reg
operator|.
name|u64
operator|&=
name|cvmx_read_csr
argument_list|(
name|CVMX_STXX_INT_MSK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|syncerr
condition|)
name|printf
argument_list|(
literal|"SPI0: STX Interface encountered a fatal error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|frmerr
condition|)
name|printf
argument_list|(
literal|"SPI0: STX FRMCNT has exceeded STX_DIP_CNT[MAXFRM]\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|unxfrm
condition|)
name|printf
argument_list|(
literal|"SPI0: STX Unexpected framing sequence\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|nosync
condition|)
name|printf
argument_list|(
literal|"SPI0: STX ERRCNT has exceeded STX_DIP_CNT[MAXDIP]\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|diperr
condition|)
name|printf
argument_list|(
literal|"SPI0: STX DIP2 error on the Spi4 Status channel\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|datovr
condition|)
name|printf
argument_list|(
literal|"SPI0: STX Spi4 FIFO overflow error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|ovrbst
condition|)
name|printf
argument_list|(
literal|"SPI0: STX Transmit packet burst too big\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|calpar1
condition|)
name|printf
argument_list|(
literal|"SPI0: STX Calendar Table Parity Error Bank1\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stx_int_reg
operator|.
name|s
operator|.
name|calpar0
condition|)
name|printf
argument_list|(
literal|"SPI0: STX Calendar Table Parity Error Bank0\n"
argument_list|)
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_INT_MSK
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_INT_MSK
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|need_retrain
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|return_status
operator|=
name|FILTER_HANDLED
expr_stmt|;
block|}
return|return
name|return_status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvm_oct_spi_enable_error_reporting
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|cvmx_spxx_int_msk_t
name|spxx_int_msk
decl_stmt|;
name|cvmx_stxx_int_msk_t
name|stxx_int_msk
decl_stmt|;
name|spxx_int_msk
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SPXX_INT_MSK
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|spxx_int_msk
operator|.
name|s
operator|.
name|calerr
operator|=
literal|1
expr_stmt|;
name|spxx_int_msk
operator|.
name|s
operator|.
name|syncerr
operator|=
literal|1
expr_stmt|;
name|spxx_int_msk
operator|.
name|s
operator|.
name|diperr
operator|=
literal|1
expr_stmt|;
name|spxx_int_msk
operator|.
name|s
operator|.
name|tpaovr
operator|=
literal|1
expr_stmt|;
name|spxx_int_msk
operator|.
name|s
operator|.
name|rsverr
operator|=
literal|1
expr_stmt|;
name|spxx_int_msk
operator|.
name|s
operator|.
name|drwnng
operator|=
literal|1
expr_stmt|;
name|spxx_int_msk
operator|.
name|s
operator|.
name|clserr
operator|=
literal|1
expr_stmt|;
name|spxx_int_msk
operator|.
name|s
operator|.
name|spiovr
operator|=
literal|1
expr_stmt|;
name|spxx_int_msk
operator|.
name|s
operator|.
name|abnorm
operator|=
literal|1
expr_stmt|;
name|spxx_int_msk
operator|.
name|s
operator|.
name|prtnxa
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_INT_MSK
argument_list|(
name|interface
argument_list|)
argument_list|,
name|spxx_int_msk
operator|.
name|u64
argument_list|)
expr_stmt|;
name|stxx_int_msk
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_STXX_INT_MSK
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|stxx_int_msk
operator|.
name|s
operator|.
name|frmerr
operator|=
literal|1
expr_stmt|;
name|stxx_int_msk
operator|.
name|s
operator|.
name|unxfrm
operator|=
literal|1
expr_stmt|;
name|stxx_int_msk
operator|.
name|s
operator|.
name|nosync
operator|=
literal|1
expr_stmt|;
name|stxx_int_msk
operator|.
name|s
operator|.
name|diperr
operator|=
literal|1
expr_stmt|;
name|stxx_int_msk
operator|.
name|s
operator|.
name|datovr
operator|=
literal|1
expr_stmt|;
name|stxx_int_msk
operator|.
name|s
operator|.
name|ovrbst
operator|=
literal|1
expr_stmt|;
name|stxx_int_msk
operator|.
name|s
operator|.
name|calpar1
operator|=
literal|1
expr_stmt|;
name|stxx_int_msk
operator|.
name|s
operator|.
name|calpar0
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_INT_MSK
argument_list|(
name|interface
argument_list|)
argument_list|,
name|stxx_int_msk
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvm_oct_spi_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
specifier|static
name|int
name|spi4000_port
decl_stmt|;
name|cvm_oct_private_t
modifier|*
name|priv
init|=
operator|(
name|cvm_oct_private_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|interface
decl_stmt|;
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
literal|2
condition|;
name|interface
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|priv
operator|->
name|port
operator|==
name|interface
operator|*
literal|16
operator|)
operator|&&
name|need_retrain
index|[
name|interface
index|]
condition|)
block|{
if|if
condition|(
name|cvmx_spi_restart_interface
argument_list|(
name|interface
argument_list|,
name|CVMX_SPI_MODE_DUPLEX
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
name|need_retrain
index|[
name|interface
index|]
operator|=
literal|0
expr_stmt|;
name|cvm_oct_spi_enable_error_reporting
argument_list|(
name|interface
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The SPI4000 TWSI interface is very slow. In order not to 		   bring the system to a crawl, we only poll a single port 		   every second. This means negotiation speed changes 		   take up to 10 seconds, but at least we don't waste 		   absurd amounts of time waiting for TWSI */
if|if
condition|(
name|priv
operator|->
name|port
operator|==
name|spi4000_port
condition|)
block|{
comment|/* This function does nothing if it is called on an 			   interface without a SPI4000 */
name|cvmx_spi4000_check_speed
argument_list|(
name|interface
argument_list|,
name|priv
operator|->
name|port
argument_list|)
expr_stmt|;
comment|/* Normal ordering increments. By decrementing 			   we only match once per iteration */
name|spi4000_port
operator|--
expr_stmt|;
if|if
condition|(
name|spi4000_port
operator|<
literal|0
condition|)
name|spi4000_port
operator|=
literal|10
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|cvm_oct_spi_init
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|octebus_softc
modifier|*
name|sc
decl_stmt|;
name|cvm_oct_private_t
modifier|*
name|priv
init|=
operator|(
name|cvm_oct_private_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|rid
decl_stmt|;
if|if
condition|(
name|number_spi_ports
operator|==
literal|0
condition|)
block|{
name|sc
operator|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|priv
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_spi_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|OCTEON_IRQ_RML
argument_list|,
name|OCTEON_IRQ_RML
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_spi_irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate SPI irq"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_spi_irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|cvm_oct_spi_rml_interrupt
argument_list|,
name|NULL
argument_list|,
operator|&
name|number_spi_ports
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not setup SPI irq"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|number_spi_ports
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|priv
operator|->
name|port
operator|==
literal|0
operator|)
operator|||
operator|(
name|priv
operator|->
name|port
operator|==
literal|16
operator|)
condition|)
block|{
name|cvm_oct_spi_enable_error_reporting
argument_list|(
name|INTERFACE
argument_list|(
name|priv
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|poll
operator|=
name|cvm_oct_spi_poll
expr_stmt|;
block|}
if|if
condition|(
name|cvm_oct_common_init
argument_list|(
name|ifp
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|cvm_oct_spi_uninit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|interface
decl_stmt|;
name|cvm_oct_common_uninit
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|number_spi_ports
operator|--
expr_stmt|;
if|if
condition|(
name|number_spi_ports
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
literal|2
condition|;
name|interface
operator|++
control|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_INT_MSK
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_INT_MSK
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"%s: IRQ release not yet implemented."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

