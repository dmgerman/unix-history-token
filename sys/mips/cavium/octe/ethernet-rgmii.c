begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************* Copyright (c) 2003-2007  Cavium Networks (support@cavium.com). All rights reserved.   Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright       notice, this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above       copyright notice, this list of conditions and the following       disclaimer in the documentation and/or other materials provided       with the distribution.      * Neither the name of Cavium Networks nor the names of       its contributors may be used to endorse or promote products       derived from this software without specific prior written       permission.  This Software, including technical data, may be subject to U.S. export  control laws, including the U.S. Export Administration Act and its  associated regulations, and may be subject to export or import  regulations in other countries.  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|"wrapper-cvmx-includes.h"
end_include

begin_include
include|#
directive|include
file|"ethernet-headers.h"
end_include

begin_include
include|#
directive|include
file|"octebusvar.h"
end_include

begin_function_decl
specifier|extern
name|int
name|octeon_is_simulation
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|ifnet
modifier|*
name|cvm_oct_device
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|global_register_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|global_register_lock
argument_list|,
operator|&
name|global_register_lock
argument_list|,
literal|"RGMII Global"
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|number_rgmii_ports
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|cvm_oct_rgmii_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|cvm_oct_private_t
modifier|*
name|priv
init|=
operator|(
name|cvm_oct_private_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|cvmx_helper_link_info_t
name|link_info
decl_stmt|;
comment|/* Take the global register lock since we are going to touch 	   registers that affect more than one port */
name|mtx_lock_spin
argument_list|(
operator|&
name|global_register_lock
argument_list|)
expr_stmt|;
name|link_info
operator|=
name|cvmx_helper_link_get
argument_list|(
name|priv
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|u64
operator|==
name|priv
operator|->
name|link_info
condition|)
block|{
comment|/* If the 10Mbps preamble workaround is supported and we're 		   at 10Mbps we may need to do some special checking */
if|if
condition|(
name|USE_10MBPS_PREAMBLE_WORKAROUND
operator|&&
operator|(
name|link_info
operator|.
name|s
operator|.
name|speed
operator|==
literal|10
operator|)
condition|)
block|{
comment|/* Read the GMXX_RXX_INT_REG[PCTERR] bit and 			   see if we are getting preamble errors */
name|int
name|interface
init|=
name|INTERFACE
argument_list|(
name|priv
operator|->
name|port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|INDEX
argument_list|(
name|priv
operator|->
name|port
argument_list|)
decl_stmt|;
name|cvmx_gmxx_rxx_int_reg_t
name|gmxx_rxx_int_reg
decl_stmt|;
name|gmxx_rxx_int_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmxx_rxx_int_reg
operator|.
name|s
operator|.
name|pcterr
condition|)
block|{
comment|/* We are getting preamble errors at 10Mbps. 				   Most likely the PHY is giving us packets 				   with mis aligned preambles. In order to get 				   these packets we need to disable preamble 				   checking and do it in software */
name|cvmx_gmxx_rxx_frm_ctl_t
name|gmxx_rxx_frm_ctl
decl_stmt|;
name|cvmx_ipd_sub_port_fcs_t
name|ipd_sub_port_fcs
decl_stmt|;
comment|/* Disable preamble checking */
name|gmxx_rxx_frm_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_FRM_CTL
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmxx_rxx_frm_ctl
operator|.
name|s
operator|.
name|pre_chk
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_FRM_CTL
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmxx_rxx_frm_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Disable FCS stripping */
name|ipd_sub_port_fcs
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_IPD_SUB_PORT_FCS
argument_list|)
expr_stmt|;
name|ipd_sub_port_fcs
operator|.
name|s
operator|.
name|port_bit
operator|&=
literal|0xffffffffull
operator|^
operator|(
literal|1ull
operator|<<
name|priv
operator|->
name|port
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_SUB_PORT_FCS
argument_list|,
name|ipd_sub_port_fcs
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Clear any error bits */
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmxx_rxx_int_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|DEBUGPRINT
argument_list|(
literal|"%s: Using 10Mbps with software preamble removal\n"
argument_list|,
name|if_name
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|global_register_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the 10Mbps preamble workaround is allowed we need to on 	   preamble checking, FCS stripping, and clear error bits on 	   every speed change. If errors occur during 10Mbps operation 	   the above code will change this stuff */
if|if
condition|(
name|USE_10MBPS_PREAMBLE_WORKAROUND
condition|)
block|{
name|cvmx_gmxx_rxx_frm_ctl_t
name|gmxx_rxx_frm_ctl
decl_stmt|;
name|cvmx_ipd_sub_port_fcs_t
name|ipd_sub_port_fcs
decl_stmt|;
name|cvmx_gmxx_rxx_int_reg_t
name|gmxx_rxx_int_reg
decl_stmt|;
name|int
name|interface
init|=
name|INTERFACE
argument_list|(
name|priv
operator|->
name|port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|INDEX
argument_list|(
name|priv
operator|->
name|port
argument_list|)
decl_stmt|;
comment|/* Enable preamble checking */
name|gmxx_rxx_frm_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_FRM_CTL
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmxx_rxx_frm_ctl
operator|.
name|s
operator|.
name|pre_chk
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_FRM_CTL
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmxx_rxx_frm_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Enable FCS stripping */
name|ipd_sub_port_fcs
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_IPD_SUB_PORT_FCS
argument_list|)
expr_stmt|;
name|ipd_sub_port_fcs
operator|.
name|s
operator|.
name|port_bit
operator||=
literal|1ull
operator|<<
name|priv
operator|->
name|port
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_SUB_PORT_FCS
argument_list|,
name|ipd_sub_port_fcs
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Clear any error bits */
name|gmxx_rxx_int_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmxx_rxx_int_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|priv
operator|->
name|miibus
operator|==
name|NULL
condition|)
block|{
name|link_info
operator|=
name|cvmx_helper_link_autoconf
argument_list|(
name|priv
operator|->
name|port
argument_list|)
expr_stmt|;
name|priv
operator|->
name|link_info
operator|=
name|link_info
operator|.
name|u64
expr_stmt|;
name|priv
operator|->
name|need_link_update
operator|=
literal|1
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|global_register_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cvm_oct_rgmii_rml_interrupt
parameter_list|(
name|void
modifier|*
name|dev_id
parameter_list|)
block|{
name|cvmx_npi_rsl_int_blocks_t
name|rsl_int_blocks
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|return_status
init|=
name|FILTER_STRAY
decl_stmt|;
name|rsl_int_blocks
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_NPI_RSL_INT_BLOCKS
argument_list|)
expr_stmt|;
comment|/* Check and see if this interrupt was caused by the GMX0 block */
if|if
condition|(
name|rsl_int_blocks
operator|.
name|s
operator|.
name|gmx0
condition|)
block|{
name|int
name|interface
init|=
literal|0
decl_stmt|;
comment|/* Loop through every port of this interface */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
condition|;
name|index
operator|++
control|)
block|{
comment|/* Read the GMX interrupt status bits */
name|cvmx_gmxx_rxx_int_reg_t
name|gmx_rx_int_reg
decl_stmt|;
name|gmx_rx_int_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_rx_int_reg
operator|.
name|u64
operator|&=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_EN
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Poll the port if inband status changed */
if|if
condition|(
name|gmx_rx_int_reg
operator|.
name|s
operator|.
name|phy_dupx
operator|||
name|gmx_rx_int_reg
operator|.
name|s
operator|.
name|phy_link
operator|||
name|gmx_rx_int_reg
operator|.
name|s
operator|.
name|phy_spd
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|cvm_oct_device
index|[
name|cvmx_helper_get_ipd_port
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|ifp
condition|)
name|cvm_oct_rgmii_poll
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|gmx_rx_int_reg
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|gmx_rx_int_reg
operator|.
name|s
operator|.
name|phy_dupx
operator|=
literal|1
expr_stmt|;
name|gmx_rx_int_reg
operator|.
name|s
operator|.
name|phy_link
operator|=
literal|1
expr_stmt|;
name|gmx_rx_int_reg
operator|.
name|s
operator|.
name|phy_spd
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_rx_int_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|return_status
operator|=
name|FILTER_HANDLED
expr_stmt|;
block|}
block|}
block|}
comment|/* Check and see if this interrupt was caused by the GMX1 block */
if|if
condition|(
name|rsl_int_blocks
operator|.
name|s
operator|.
name|gmx1
condition|)
block|{
name|int
name|interface
init|=
literal|1
decl_stmt|;
comment|/* Loop through every port of this interface */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
condition|;
name|index
operator|++
control|)
block|{
comment|/* Read the GMX interrupt status bits */
name|cvmx_gmxx_rxx_int_reg_t
name|gmx_rx_int_reg
decl_stmt|;
name|gmx_rx_int_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_rx_int_reg
operator|.
name|u64
operator|&=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_EN
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Poll the port if inband status changed */
if|if
condition|(
name|gmx_rx_int_reg
operator|.
name|s
operator|.
name|phy_dupx
operator|||
name|gmx_rx_int_reg
operator|.
name|s
operator|.
name|phy_link
operator|||
name|gmx_rx_int_reg
operator|.
name|s
operator|.
name|phy_spd
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|cvm_oct_device
index|[
name|cvmx_helper_get_ipd_port
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|ifp
condition|)
name|cvm_oct_rgmii_poll
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|gmx_rx_int_reg
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|gmx_rx_int_reg
operator|.
name|s
operator|.
name|phy_dupx
operator|=
literal|1
expr_stmt|;
name|gmx_rx_int_reg
operator|.
name|s
operator|.
name|phy_link
operator|=
literal|1
expr_stmt|;
name|gmx_rx_int_reg
operator|.
name|s
operator|.
name|phy_spd
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_rx_int_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|return_status
operator|=
name|FILTER_HANDLED
expr_stmt|;
block|}
block|}
block|}
return|return
name|return_status
return|;
block|}
end_function

begin_function
name|int
name|cvm_oct_rgmii_init
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|octebus_softc
modifier|*
name|sc
decl_stmt|;
name|cvm_oct_private_t
modifier|*
name|priv
init|=
operator|(
name|cvm_oct_private_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|rid
decl_stmt|;
if|if
condition|(
name|cvm_oct_common_init
argument_list|(
name|ifp
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
name|priv
operator|->
name|open
operator|=
name|cvm_oct_common_open
expr_stmt|;
name|priv
operator|->
name|stop
operator|=
name|cvm_oct_common_stop
expr_stmt|;
name|priv
operator|->
name|stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Due to GMX errata in CN3XXX series chips, it is necessary to take the 	   link down immediately whne the PHY changes state. In order to do this 	   we call the poll function every time the RGMII inband status changes. 	   This may cause problems if the PHY doesn't implement inband status 	   properly */
if|if
condition|(
name|number_rgmii_ports
operator|==
literal|0
condition|)
block|{
name|sc
operator|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|priv
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rgmii_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|OCTEON_IRQ_RML
argument_list|,
name|OCTEON_IRQ_RML
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rgmii_irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate RGMII irq"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_rgmii_irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|cvm_oct_rgmii_rml_interrupt
argument_list|,
name|NULL
argument_list|,
operator|&
name|number_rgmii_ports
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not setup RGMII irq"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|number_rgmii_ports
operator|++
expr_stmt|;
comment|/* Only true RGMII ports need to be polled. In GMII mode, port 0 is really 	   a RGMII port */
if|if
condition|(
operator|(
operator|(
name|priv
operator|->
name|imode
operator|==
name|CVMX_HELPER_INTERFACE_MODE_GMII
operator|)
operator|&&
operator|(
name|priv
operator|->
name|port
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|priv
operator|->
name|imode
operator|==
name|CVMX_HELPER_INTERFACE_MODE_RGMII
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|octeon_is_simulation
argument_list|()
condition|)
block|{
name|cvmx_gmxx_rxx_int_en_t
name|gmx_rx_int_en
decl_stmt|;
name|int
name|interface
init|=
name|INTERFACE
argument_list|(
name|priv
operator|->
name|port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|INDEX
argument_list|(
name|priv
operator|->
name|port
argument_list|)
decl_stmt|;
comment|/* Enable interrupts on inband status changes for this port */
name|gmx_rx_int_en
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_EN
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_rx_int_en
operator|.
name|s
operator|.
name|phy_dupx
operator|=
literal|1
expr_stmt|;
name|gmx_rx_int_en
operator|.
name|s
operator|.
name|phy_link
operator|=
literal|1
expr_stmt|;
name|gmx_rx_int_en
operator|.
name|s
operator|.
name|phy_spd
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_EN
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_rx_int_en
operator|.
name|u64
argument_list|)
expr_stmt|;
name|priv
operator|->
name|poll
operator|=
name|cvm_oct_rgmii_poll
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|cvm_oct_rgmii_uninit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|cvm_oct_private_t
modifier|*
name|priv
init|=
operator|(
name|cvm_oct_private_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|cvm_oct_common_uninit
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Only true RGMII ports need to be polled. In GMII mode, port 0 is really 	   a RGMII port */
if|if
condition|(
operator|(
operator|(
name|priv
operator|->
name|imode
operator|==
name|CVMX_HELPER_INTERFACE_MODE_GMII
operator|)
operator|&&
operator|(
name|priv
operator|->
name|port
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|priv
operator|->
name|imode
operator|==
name|CVMX_HELPER_INTERFACE_MODE_RGMII
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|octeon_is_simulation
argument_list|()
condition|)
block|{
name|cvmx_gmxx_rxx_int_en_t
name|gmx_rx_int_en
decl_stmt|;
name|int
name|interface
init|=
name|INTERFACE
argument_list|(
name|priv
operator|->
name|port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|INDEX
argument_list|(
name|priv
operator|->
name|port
argument_list|)
decl_stmt|;
comment|/* Disable interrupts on inband status changes for this port */
name|gmx_rx_int_en
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_EN
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_rx_int_en
operator|.
name|s
operator|.
name|phy_dupx
operator|=
literal|0
expr_stmt|;
name|gmx_rx_int_en
operator|.
name|s
operator|.
name|phy_link
operator|=
literal|0
expr_stmt|;
name|gmx_rx_int_en
operator|.
name|s
operator|.
name|phy_spd
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_EN
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_rx_int_en
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remove the interrupt handler when the last port is removed */
name|number_rgmii_ports
operator|--
expr_stmt|;
if|if
condition|(
name|number_rgmii_ports
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: need to implement IRQ release."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

