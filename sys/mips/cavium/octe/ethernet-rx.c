begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************* Copyright (c) 2003-2007  Cavium Networks (support@cavium.com). All rights reserved.   Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright       notice, this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above       copyright notice, this list of conditions and the following       disclaimer in the documentation and/or other materials provided       with the distribution.      * Neither the name of Cavium Networks nor the names of       its contributors may be used to endorse or promote products       derived from this software without specific prior written       permission.  This Software, including technical data, may be subject to U.S. export  control laws, including the U.S. Export Administration Act and its  associated regulations, and may be subject to export or import  regulations in other countries.  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|"wrapper-cvmx-includes.h"
end_include

begin_include
include|#
directive|include
file|"ethernet-headers.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|pow_receive_group
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ifnet
modifier|*
name|cvm_oct_device
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|task
name|cvm_oct_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|taskqueue
modifier|*
name|cvm_oct_taskq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cvm_oct_rx_active
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Interrupt handler. The interrupt occurs whenever the POW  * transitions from 0->1 packets in our group.  *  * @param cpl  * @param dev_id  * @param regs  * @return  */
end_comment

begin_function
name|int
name|cvm_oct_do_interrupt
parameter_list|(
name|void
modifier|*
name|dev_id
parameter_list|)
block|{
comment|/* Acknowledge the interrupt */
if|if
condition|(
name|INTERRUPT_LIMIT
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_WQ_INT
argument_list|,
literal|1
operator|<<
name|pow_receive_group
argument_list|)
expr_stmt|;
else|else
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_WQ_INT
argument_list|,
literal|0x10001
operator|<<
name|pow_receive_group
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule task if there isn't one running. 	 */
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|cvm_oct_rx_active
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|cvm_oct_taskq
argument_list|,
operator|&
name|cvm_oct_task
argument_list|)
expr_stmt|;
return|return
name|FILTER_HANDLED
return|;
block|}
end_function

begin_comment
comment|/**  * This is called on receive errors, and determines if the packet  * can be dropped early-on in cvm_oct_tasklet_rx().  *  * @param work Work queue entry pointing to the packet.  * @return Non-zero if the packet can be dropped, zero otherwise.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|cvm_oct_check_rcv_error
parameter_list|(
name|cvmx_wqe_t
modifier|*
name|work
parameter_list|)
block|{
if|if
condition|(
operator|(
name|work
operator|->
name|word2
operator|.
name|snoip
operator|.
name|err_code
operator|==
literal|10
operator|)
operator|&&
operator|(
name|work
operator|->
name|word1
operator|.
name|s
operator|.
name|len
operator|<=
literal|64
operator|)
condition|)
block|{
comment|/* Ignore length errors on min size packets. Some equipment 		   incorrectly pads packets to 64+4FCS instead of 60+4FCS. 		   Note these packets still get counted as frame errors. */
block|}
elseif|else
if|if
condition|(
name|USE_10MBPS_PREAMBLE_WORKAROUND
operator|&&
operator|(
operator|(
name|work
operator|->
name|word2
operator|.
name|snoip
operator|.
name|err_code
operator|==
literal|5
operator|)
operator|||
operator|(
name|work
operator|->
name|word2
operator|.
name|snoip
operator|.
name|err_code
operator|==
literal|7
operator|)
operator|)
condition|)
block|{
comment|/* We received a packet with either an alignment error or a 		   FCS error. This may be signalling that we are running 		   10Mbps with GMXX_RXX_FRM_CTL[PRE_CHK} off. If this is the 		   case we need to parse the packet to determine if we can 		   remove a non spec preamble and generate a correct packet */
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|work
operator|->
name|word1
operator|.
name|cn38xx
operator|.
name|ipprt
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|work
operator|->
name|word1
operator|.
name|cn38xx
operator|.
name|ipprt
argument_list|)
decl_stmt|;
name|cvmx_gmxx_rxx_frm_ctl_t
name|gmxx_rxx_frm_ctl
decl_stmt|;
name|gmxx_rxx_frm_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_FRM_CTL
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmxx_rxx_frm_ctl
operator|.
name|s
operator|.
name|pre_chk
operator|==
literal|0
condition|)
block|{
name|uint8_t
modifier|*
name|ptr
init|=
name|cvmx_phys_to_ptr
argument_list|(
name|work
operator|->
name|packet_ptr
operator|.
name|s
operator|.
name|addr
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|work
operator|->
name|word1
operator|.
name|s
operator|.
name|len
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|0x55
condition|)
break|break;
name|ptr
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ptr
operator|==
literal|0xd5
condition|)
block|{
comment|/* 				DEBUGPRINT("Port %d received 0xd5 preamble\n", work->word1.cn38xx.ipprt); 				*/
name|work
operator|->
name|packet_ptr
operator|.
name|s
operator|.
name|addr
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
name|work
operator|->
name|word1
operator|.
name|s
operator|.
name|len
operator|-=
name|i
operator|+
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|ptr
operator|&
literal|0xf
operator|)
operator|==
literal|0xd
condition|)
block|{
comment|/* 				DEBUGPRINT("Port %d received 0x?d preamble\n", work->word1.cn38xx.ipprt); 				*/
name|work
operator|->
name|packet_ptr
operator|.
name|s
operator|.
name|addr
operator|+=
name|i
expr_stmt|;
name|work
operator|->
name|word1
operator|.
name|s
operator|.
name|len
operator|-=
name|i
operator|+
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|work
operator|->
name|word1
operator|.
name|s
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ptr
operator|=
operator|(
operator|(
operator|*
name|ptr
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|DEBUGPRINT
argument_list|(
literal|"Port %d unknown preamble, packet dropped\n"
argument_list|,
name|work
operator|->
name|word1
operator|.
name|cn38xx
operator|.
name|ipprt
argument_list|)
expr_stmt|;
comment|/* 				cvmx_helper_dump_packet(work); 				*/
name|cvm_oct_free_work
argument_list|(
name|work
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
else|else
block|{
name|DEBUGPRINT
argument_list|(
literal|"Port %d receive error code %d, packet dropped\n"
argument_list|,
name|work
operator|->
name|word1
operator|.
name|cn38xx
operator|.
name|ipprt
argument_list|,
name|work
operator|->
name|word2
operator|.
name|snoip
operator|.
name|err_code
argument_list|)
expr_stmt|;
name|cvm_oct_free_work
argument_list|(
name|work
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Tasklet function that is scheduled on a core when an interrupt occurs.  *  * @param unused  */
end_comment

begin_function
name|void
name|cvm_oct_tasklet_rx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|int
name|coreid
decl_stmt|;
name|uint64_t
name|old_group_mask
decl_stmt|;
name|int
name|rx_count
init|=
literal|0
decl_stmt|;
name|int
name|number_to_free
decl_stmt|;
name|int
name|num_freed
decl_stmt|;
name|int
name|packet_not_copied
decl_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
name|coreid
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
comment|/* Prefetch cvm_oct_device since we know we need it soon */
name|CVMX_PREFETCH
argument_list|(
name|cvm_oct_device
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Only allow work for our group (and preserve priorities) */
name|old_group_mask
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_POW_PP_GRP_MSKX
argument_list|(
name|coreid
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_PP_GRP_MSKX
argument_list|(
name|coreid
argument_list|)
argument_list|,
operator|(
name|old_group_mask
operator|&
operator|~
literal|0xFFFFull
operator|)
operator||
literal|1
operator|<<
name|pow_receive_group
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
name|mbuf_in_hw
decl_stmt|;
name|cvmx_wqe_t
modifier|*
name|work
decl_stmt|;
if|if
condition|(
operator|(
name|INTERRUPT_LIMIT
operator|==
literal|0
operator|)
operator|||
operator|(
name|rx_count
operator|<
name|MAX_RX_PACKETS
operator|)
condition|)
name|work
operator|=
name|cvmx_pow_work_request_sync
argument_list|(
name|CVMX_POW_NO_WAIT
argument_list|)
expr_stmt|;
else|else
name|work
operator|=
name|NULL
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|work
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|NULL
condition|)
break|break;
name|mbuf_in_hw
operator|=
name|work
operator|->
name|word2
operator|.
name|s
operator|.
name|bufs
operator|==
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|mbuf_in_hw
operator|)
condition|)
block|{
name|m
operator|=
operator|*
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
operator|(
name|cvm_oct_get_buffer_ptr
argument_list|(
name|work
operator|->
name|packet_ptr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|m
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|mbuf
argument_list|,
name|m_data
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|m
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|mbuf
argument_list|,
name|m_pkthdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CVMX_PREFETCH
argument_list|(
name|cvm_oct_device
index|[
name|work
operator|->
name|word1
operator|.
name|cn38xx
operator|.
name|ipprt
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//CVMX_PREFETCH(m, 0);
name|rx_count
operator|++
expr_stmt|;
comment|/* Immediately throw away all packets with receive errors */
if|if
condition|(
operator|(
name|work
operator|->
name|word2
operator|.
name|snoip
operator|.
name|rcv_error
operator|)
condition|)
block|{
if|if
condition|(
name|cvm_oct_check_rcv_error
argument_list|(
name|work
argument_list|)
condition|)
continue|continue;
block|}
comment|/* We can only use the zero copy path if mbufs are in the FPA pool 		   and the packet fits in a single buffer */
if|if
condition|(
operator|(
name|mbuf_in_hw
operator|)
condition|)
block|{
name|CVMX_PREFETCH
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|work
operator|->
name|word1
operator|.
name|s
operator|.
name|len
expr_stmt|;
name|packet_not_copied
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Adjust the data pointer based on the offset 			 * of the packet within the buffer. 			 */
name|m
operator|->
name|m_data
operator|+=
operator|(
name|work
operator|->
name|packet_ptr
operator|.
name|s
operator|.
name|back
operator|<<
literal|7
operator|)
operator|+
operator|(
name|work
operator|->
name|packet_ptr
operator|.
name|s
operator|.
name|addr
operator|&
literal|0x7f
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We have to copy the packet. First allocate an 			   mbuf for it */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DEBUGPRINT
argument_list|(
literal|"Port %d failed to allocate mbuf, packet dropped\n"
argument_list|,
name|work
operator|->
name|word1
operator|.
name|cn38xx
operator|.
name|ipprt
argument_list|)
expr_stmt|;
name|cvm_oct_free_work
argument_list|(
name|work
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Check if we've received a packet that was entirely 			   stored in the work entry. This is untested */
if|if
condition|(
operator|(
name|work
operator|->
name|word2
operator|.
name|s
operator|.
name|bufs
operator|==
literal|0
operator|)
condition|)
block|{
name|uint8_t
modifier|*
name|ptr
init|=
name|work
operator|->
name|packet_data
decl_stmt|;
if|if
condition|(
name|cvmx_likely
argument_list|(
operator|!
name|work
operator|->
name|word2
operator|.
name|s
operator|.
name|not_IP
argument_list|)
condition|)
block|{
comment|/* The beginning of the packet moves 					   for IP packets */
if|if
condition|(
name|work
operator|->
name|word2
operator|.
name|s
operator|.
name|is_v6
condition|)
name|ptr
operator|+=
literal|2
expr_stmt|;
else|else
name|ptr
operator|+=
literal|6
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"%s: not yet implemented; copy in small packet."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* No packet buffers to free */
block|}
else|else
block|{
name|int
name|segments
init|=
name|work
operator|->
name|word2
operator|.
name|s
operator|.
name|bufs
decl_stmt|;
name|cvmx_buf_ptr_t
name|segment_ptr
init|=
name|work
operator|->
name|packet_ptr
decl_stmt|;
name|int
name|len
init|=
name|work
operator|->
name|word1
operator|.
name|s
operator|.
name|len
decl_stmt|;
while|while
condition|(
name|segments
operator|--
condition|)
block|{
name|cvmx_buf_ptr_t
name|next_ptr
init|=
operator|*
operator|(
name|cvmx_buf_ptr_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|segment_ptr
operator|.
name|s
operator|.
name|addr
operator|-
literal|8
argument_list|)
decl_stmt|;
comment|/* Octeon Errata PKI-100: The segment 					   size is wrong. Until it is fixed, 					   calculate the segment size based on 					   the packet pool buffer size. When 					   it is fixed, the following line 					   should be replaced with this one: 					int segment_size = segment_ptr.s.size; */
name|int
name|segment_size
init|=
name|CVMX_FPA_PACKET_POOL_SIZE
operator|-
operator|(
name|segment_ptr
operator|.
name|s
operator|.
name|addr
operator|-
operator|(
operator|(
operator|(
name|segment_ptr
operator|.
name|s
operator|.
name|addr
operator|>>
literal|7
operator|)
operator|-
name|segment_ptr
operator|.
name|s
operator|.
name|back
operator|)
operator|<<
literal|7
operator|)
operator|)
decl_stmt|;
comment|/* Don't copy more than what is left 					   in the packet */
if|if
condition|(
name|segment_size
operator|>
name|len
condition|)
name|segment_size
operator|=
name|len
expr_stmt|;
comment|/* Copy the data into the packet */
name|panic
argument_list|(
literal|"%s: not yet implemented; copy in packet segments."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|memcpy(m_put(m, segment_size), cvmx_phys_to_ptr(segment_ptr.s.addr), segment_size);
endif|#
directive|endif
comment|/* Reduce the amount of bytes left 					   to copy */
name|len
operator|-=
name|segment_size
expr_stmt|;
name|segment_ptr
operator|=
name|next_ptr
expr_stmt|;
block|}
block|}
name|packet_not_copied
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|work
operator|->
name|word1
operator|.
name|cn38xx
operator|.
name|ipprt
operator|<
name|TOTAL_NUMBER_OF_PORTS
operator|)
operator|&&
name|cvm_oct_device
index|[
name|work
operator|->
name|word1
operator|.
name|cn38xx
operator|.
name|ipprt
index|]
operator|)
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|cvm_oct_device
index|[
name|work
operator|->
name|word1
operator|.
name|cn38xx
operator|.
name|ipprt
index|]
decl_stmt|;
comment|/* Only accept packets for devices 			   that are currently up */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|work
operator|->
name|word2
operator|.
name|s
operator|.
name|not_IP
operator|||
name|work
operator|->
name|word2
operator|.
name|s
operator|.
name|IP_exc
operator|||
name|work
operator|->
name|word2
operator|.
name|s
operator|.
name|L4_error
operator|)
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
else|else
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
else|else
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Drop any packet received for a device that isn't up */
comment|/* 				DEBUGPRINT("%s: Device not up, packet dropped\n", 					   if_name(ifp)); 				*/
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Drop any packet received for a device that 			   doesn't exist */
name|DEBUGPRINT
argument_list|(
literal|"Port %d not controlled by Linux, packet dropped\n"
argument_list|,
name|work
operator|->
name|word1
operator|.
name|cn38xx
operator|.
name|ipprt
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Check to see if the mbuf and work share 		   the same packet buffer */
if|if
condition|(
operator|(
name|packet_not_copied
operator|)
condition|)
block|{
comment|/* This buffer needs to be replaced, increment 			the number of buffers we need to free by one */
name|cvmx_fau_atomic_add32
argument_list|(
name|FAU_NUM_PACKET_BUFFERS_TO_FREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvmx_fpa_free
argument_list|(
name|work
argument_list|,
name|CVMX_FPA_WQE_POOL
argument_list|,
name|DONT_WRITEBACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|cvm_oct_free_work
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we hit our limit, schedule another task while we clean up. 	 */
if|if
condition|(
name|INTERRUPT_LIMIT
operator|!=
literal|0
operator|&&
name|rx_count
operator|==
name|MAX_RX_PACKETS
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|cvm_oct_taskq
argument_list|,
operator|&
name|cvm_oct_task
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * No more packets, all done. 		 */
if|if
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|cvm_oct_rx_active
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: inconsistent rx active state."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the original POW group mask */
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_PP_GRP_MSKX
argument_list|(
name|coreid
argument_list|)
argument_list|,
name|old_group_mask
argument_list|)
expr_stmt|;
comment|/* Refill the packet buffer pool */
name|number_to_free
operator|=
name|cvmx_fau_fetch_and_add32
argument_list|(
name|FAU_NUM_PACKET_BUFFERS_TO_FREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_to_free
operator|>
literal|0
condition|)
block|{
name|cvmx_fau_atomic_add32
argument_list|(
name|FAU_NUM_PACKET_BUFFERS_TO_FREE
argument_list|,
operator|-
name|number_to_free
argument_list|)
expr_stmt|;
name|num_freed
operator|=
name|cvm_oct_mem_fill_fpa
argument_list|(
name|CVMX_FPA_PACKET_POOL
argument_list|,
name|CVMX_FPA_PACKET_POOL_SIZE
argument_list|,
name|number_to_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_freed
operator|!=
name|number_to_free
condition|)
block|{
name|cvmx_fau_atomic_add32
argument_list|(
name|FAU_NUM_PACKET_BUFFERS_TO_FREE
argument_list|,
name|number_to_free
operator|-
name|num_freed
argument_list|)
expr_stmt|;
block|}
block|}
name|sched_unpin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cvm_oct_rx_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|TASK_INIT
argument_list|(
operator|&
name|cvm_oct_task
argument_list|,
literal|0
argument_list|,
name|cvm_oct_tasklet_rx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvm_oct_taskq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"oct_rx"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|cvm_oct_taskq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|cvm_oct_taskq
argument_list|,
name|min
argument_list|(
name|mp_ncpus
argument_list|,
name|MAXCPU
argument_list|)
argument_list|,
name|PI_NET
argument_list|,
literal|"octe taskq"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cvm_oct_rx_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|panic
argument_list|(
literal|"%s: not yet implemented."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

