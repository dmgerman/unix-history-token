begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * octeon_rgmx.c     RGMII  Ethernet Interfaces on Octeon  *  */
end_comment

begin_comment
comment|/*  * Driver for the Reduced Gigabit Media Independent Interface (RGMII)  * present on the Cavium Networks' Octeon chip.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/power.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/timetc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/locore.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<mips/octeon1/octeon_pcmap_regs.h>
end_include

begin_include
include|#
directive|include
file|"octeon_fau.h"
end_include

begin_include
include|#
directive|include
file|"octeon_fpa.h"
end_include

begin_include
include|#
directive|include
file|"octeon_ipd.h"
end_include

begin_include
include|#
directive|include
file|"octeon_pko.h"
end_include

begin_include
include|#
directive|include
file|"octeon_pip.h"
end_include

begin_include
include|#
directive|include
file|"octeon_rgmx.h"
end_include

begin_comment
comment|/* The "battleship" boards have 8 ports */
end_comment

begin_define
define|#
directive|define
name|OCTEON_RGMX_NUM_PORTS_MAX
value|8
end_define

begin_define
define|#
directive|define
name|NUM_TX_PACKETS
value|80
end_define

begin_define
define|#
directive|define
name|NUM_RX_PACKETS
value|300
end_define

begin_define
define|#
directive|define
name|MAX_RX_BUFS
value|(NUM_RX_PACKETS) * (OCTEON_RGMX_NUM_PORTS_MAX)
end_define

begin_define
define|#
directive|define
name|MAX_TX_BUFS
value|(NUM_TX_PACKETS)
end_define

begin_define
define|#
directive|define
name|OCTEON_RGMX_DEV_NAME
value|"rgmx"
end_define

begin_define
define|#
directive|define
name|OCTEON_RGMX_MIN_PORT
value|0
end_define

begin_define
define|#
directive|define
name|OCTEON_RGMX_MAX_PORT
value|19
end_define

begin_define
define|#
directive|define
name|OCTEON_RGMX_OQUEUE_PER_PORT
value|8
end_define

begin_define
define|#
directive|define
name|OCTEON_RGMX_SCHEDULED_ISRS
value|1
end_define

begin_comment
comment|/*  Use Scheduled ISRs from kernel tasks */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|POW_MAX_LOOP
end_ifndef

begin_define
define|#
directive|define
name|POW_MAX_LOOP
value|0x800
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * CIU related stuff for enabling POW interrupts  */
end_comment

begin_define
define|#
directive|define
name|OCTEON_RGMX_CIU_INTX
value|CIU_INT_0
end_define

begin_define
define|#
directive|define
name|OCTEON_RGMX_CIU_ENX
value|CIU_EN_0
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_RGMII_WQE
argument_list|,
literal|"rgmii_wqe"
argument_list|,
literal|"FPA pool for WQEs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Driver data */
end_comment

begin_struct
struct|struct
name|rgmx_softc_dev
block|{
name|device_t
name|sc_dev
decl_stmt|;
comment|/* Device ID */
name|uint64_t
name|link_status
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|sc_unit
decl_stmt|;
name|u_int
name|port
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
name|u_char
name|ieee
index|[
literal|6
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|typestr
decl_stmt|;
comment|/* printable name of the interface.  */
name|u_short
name|txb_size
decl_stmt|;
comment|/* size of TX buffer, in bytes  */
comment|/* Transmission buffer management.  */
name|u_short
name|txb_free
decl_stmt|;
comment|/* free bytes in TX buffer  */
name|u_char
name|txb_count
decl_stmt|;
comment|/* number of packets in TX buffer  */
name|u_char
name|txb_sched
decl_stmt|;
comment|/* number of scheduled packets  */
comment|/* Media information.  */
name|struct
name|ifmedia
name|media
decl_stmt|;
comment|/* used by if_media.  */
name|u_short
name|mbitmap
decl_stmt|;
comment|/* bitmap for supported media; see bit2media */
name|int
name|defmedia
decl_stmt|;
comment|/* default media  */
name|struct
name|ifqueue
name|tx_pending_queue
decl_stmt|;
comment|/* Queue of mbuf given to PKO currently */
name|octeon_pko_sw_queue_info_t
modifier|*
name|outq_ptr
decl_stmt|;
name|struct
name|mtx
name|mtx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Device methods  */
end_comment

begin_function_decl
specifier|static
name|int
name|rgmii_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rgmii_identify
parameter_list|(
name|driver_t
modifier|*
parameter_list|,
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rgmii_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Octeon specific routines  */
end_comment

begin_function_decl
specifier|static
name|int
name|octeon_has_4ports
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_config_rgmii_port
parameter_list|(
name|u_int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_rgmx_config_pip
parameter_list|(
name|u_int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_line_status_loop
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_rx_loop
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_config_hw_units_post_ports
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_config_hw_units_pre_ports
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_config_hw_units_port
parameter_list|(
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
parameter_list|,
name|u_int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|rgmx_softc_dev
modifier|*
name|get_rgmx_softc
parameter_list|(
name|u_int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_rgmx_start_port
parameter_list|(
name|u_int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|octeon_rgmx_stop_port
parameter_list|(
name|u_int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|get_rgmx_port_ordinal
parameter_list|(
name|u_int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_rgmx_set_mac
parameter_list|(
name|u_int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_rgmx_init_sc
parameter_list|(
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|num_devices
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|octeon_rgmx_init_ifnet
parameter_list|(
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_rgmx_mark_ready
parameter_list|(
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_rgmx_stop
parameter_list|(
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_rgmx_config_speed
parameter_list|(
name|u_int
name|port
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_RGMX_DUMP
end_ifdef

begin_function_decl
specifier|static
name|void
name|octeon_dump_rgmx_stats
parameter_list|(
name|u_int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_dump_pow_stats
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__not_used__
end_ifdef

begin_function_decl
specifier|static
name|void
name|rgmx_timer_periodic
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|octeon_rgmx_enable_RED_all
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|OCTEON_RGMX_SCHEDULED_ISRS
end_ifdef

begin_function_decl
specifier|static
name|void
name|octeon_rgmx_isr_link
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_rgmx_isr_rxtx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|octeon_rgmx_intr_fast
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|octeon_rgmx_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Standard driver entry points.  These can be static.  */
end_comment

begin_function_decl
specifier|static
name|void
name|octeon_rgmx_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//static driver_intr_t    rgmx_intr;
end_comment

begin_function_decl
specifier|static
name|int
name|octeon_rgmx_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_rgmx_output_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_rgmx_output_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void  octeon_rgmx_watchdog     (struct ifnet *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|octeon_rgmx_medchange
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|octeon_rgmx_medstat
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Mapping between media bitmap (in fe_softc.mbitmap) and ifm_media.  */
end_comment

begin_decl_stmt
specifier|static
name|int
specifier|const
name|bit2media
index|[]
init|=
block|{
name|IFM_ETHER
operator||
name|IFM_AUTO
block|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
block|,
name|IFM_ETHER
operator||
name|IFM_10_T
block|,
name|IFM_ETHER
operator||
name|IFM_10_2
block|,
name|IFM_ETHER
operator||
name|IFM_10_5
block|,
name|IFM_ETHER
operator||
name|IFM_10_FL
block|,
name|IFM_ETHER
operator||
name|IFM_10_T
block|,
comment|/* More can be added here... */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping between media bitmap (in fe_softc.mbitmap) and ifm_media.  */
end_comment

begin_define
define|#
directive|define
name|MB_HA
value|0x0001
end_define

begin_define
define|#
directive|define
name|MB_HM
value|0x0002
end_define

begin_define
define|#
directive|define
name|MB_HT
value|0x0004
end_define

begin_define
define|#
directive|define
name|MB_H2
value|0x0008
end_define

begin_define
define|#
directive|define
name|MB_H5
value|0x0010
end_define

begin_define
define|#
directive|define
name|MB_HF
value|0x0020
end_define

begin_define
define|#
directive|define
name|MB_FT
value|0x0040
end_define

begin_define
define|#
directive|define
name|LEBLEN
value|(ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN)
end_define

begin_decl_stmt
specifier|static
name|struct
name|rgmx_softc_dev
modifier|*
name|rgmx_scdev_array
index|[
name|OCTEON_RGMX_NUM_PORTS_MAX
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|port_array
index|[
name|OCTEON_RGMX_NUM_PORTS_MAX
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|num_devices
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|octeon_pko_sw_queue_info_t
name|output_queues_array
index|[
name|OCTEON_RGMX_NUM_PORTS_MAX
operator|*
name|OCTEON_RGMX_OQUEUE_PER_PORT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|resource
modifier|*
name|irq_res
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interrupt resource. */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|int_handler_tag
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OCTEON_RGMX_SCHEDULED_ISRS
end_ifdef

begin_decl_stmt
name|struct
name|task
name|link_isr_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|task
name|rxtx_isr_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|taskqueue
modifier|*
name|tq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* private task queue */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|u_int
name|get_rgmx_port_ordinal
parameter_list|(
name|u_int
name|port
parameter_list|)
block|{
name|u_int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|OCTEON_RGMX_NUM_PORTS_MAX
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|port_array
index|[
name|idx
index|]
operator|==
name|port
condition|)
block|{
return|return
operator|(
name|idx
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|rgmx_softc_dev
modifier|*
name|get_rgmx_softc
parameter_list|(
name|u_int
name|port
parameter_list|)
block|{
name|u_int
name|idx
decl_stmt|;
name|idx
operator|=
name|get_rgmx_port_ordinal
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|rgmx_scdev_array
index|[
name|idx
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|octeon_rgmx_init_sc
parameter_list|(
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|num_devices
parameter_list|)
block|{
name|int
name|ii
decl_stmt|;
comment|/* No software-controllable media selection.  */
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HM
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|MB_HM
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|sc
operator|->
name|idx
operator|=
name|num_devices
expr_stmt|;
name|sc
operator|->
name|link_status
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_unit
operator|=
name|num_devices
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HT
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|MB_HT
expr_stmt|;
name|sc
operator|->
name|tx_pending_queue
operator|.
name|ifq_maxlen
operator|=
name|NUM_TX_PACKETS
expr_stmt|;
name|sc
operator|->
name|tx_pending_queue
operator|.
name|ifq_head
operator|=
name|sc
operator|->
name|tx_pending_queue
operator|.
name|ifq_tail
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|tx_pending_queue
operator|.
name|ifq_len
operator|=
name|sc
operator|->
name|tx_pending_queue
operator|.
name|ifq_drops
operator|=
literal|0
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|tx_pending_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"if->sc->txpq.ifqmtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|outq_ptr
operator|=
operator|&
operator|(
name|output_queues_array
index|[
name|num_devices
operator|*
name|OCTEON_RGMX_OQUEUE_PER_PORT
index|]
operator|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|6
condition|;
name|ii
operator|++
control|)
block|{
name|sc
operator|->
name|ieee
index|[
name|ii
index|]
operator|=
name|octeon_mac_addr
index|[
name|ii
index|]
expr_stmt|;
block|}
name|sc
operator|->
name|ieee
index|[
literal|5
index|]
operator|+=
name|get_rgmx_port_ordinal
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|octeon_rgmx_init_ifnet
parameter_list|(
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ifp
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can not ifalloc for rgmx port\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
comment|/*          * Initialize ifnet structure          */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|octeon_rgmx_output_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|octeon_rgmx_ioctl
expr_stmt|;
comment|/* Watchdog interface is now deprecated.         ifp->if_watchdog = octeon_rgmx_watchdog;         */
name|ifp
operator|->
name|if_hwassist
operator|=
name|CSUM_TCP
operator||
name|CSUM_UDP
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|octeon_rgmx_init
expr_stmt|;
name|ifp
operator|->
name|if_linkmib
operator|=
name|NULL
expr_stmt|;
comment|//&sc->mibdata;
name|ifp
operator|->
name|if_linkmiblen
operator|=
literal|0
expr_stmt|;
comment|// sizeof (sc->mibdata);
comment|/*          * Set fixed interface flags.          */
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
comment|//                        | IFF_NEEDSGIANT;
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
literal|0
argument_list|,
name|octeon_rgmx_medchange
argument_list|,
name|octeon_rgmx_medstat
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|bit2media
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|bit2media
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|sc
operator|->
name|ieee
argument_list|)
expr_stmt|;
comment|/* Print additional info when attached.  */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"type %s, full duplex\n"
argument_list|,
name|sc
operator|->
name|typestr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Driver methods */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------- *  *                      rgmii_identify()                               *  * ------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|rgmii_identify
parameter_list|(
name|driver_t
modifier|*
name|drv
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"rgmii"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------- *  *                      rgmii_probe()                                  *  * ------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int
name|rgmii_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"can't probe/attach more rgmii devices\n"
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Octeon RGMII"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------- *  *                      rgmii_attach()                                 *  * ------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int
name|rgmii_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|int
name|iface
decl_stmt|,
name|port
decl_stmt|,
name|nr_ports
decl_stmt|,
name|error
decl_stmt|;
name|void
modifier|*
name|softc
decl_stmt|;
name|int
name|irq_rid
decl_stmt|;
name|octeon_config_hw_units_pre_ports
argument_list|()
expr_stmt|;
comment|/* Count interfaces and ports*/
name|octeon_gmxx_inf_mode_t
name|iface_mode
decl_stmt|;
name|iface_mode
operator|.
name|word64
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|iface
operator|=
literal|0
init|;
name|iface
operator|<
literal|2
condition|;
name|iface
operator|++
control|)
block|{
name|iface_mode
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_RGMX_INF_MODE
argument_list|(
name|iface
argument_list|)
argument_list|)
expr_stmt|;
comment|/* interface is either disabled or SPI */
if|if
condition|(
operator|!
name|iface_mode
operator|.
name|bits
operator|.
name|en
condition|)
continue|continue;
if|if
condition|(
name|octeon_get_chipid
argument_list|()
operator|==
name|OCTEON_CN3020_CHIP
condition|)
block|{
name|nr_ports
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|nr_ports
operator|=
operator|(
name|octeon_has_4ports
argument_list|()
operator|)
condition|?
literal|4
else|:
literal|3
expr_stmt|;
if|if
condition|(
name|iface_mode
operator|.
name|bits
operator|.
name|type
condition|)
block|{
if|if
condition|(
name|octeon_get_chipid
argument_list|()
operator|==
name|OCTEON_CN5020_CHIP
condition|)
name|nr_ports
operator|=
literal|2
expr_stmt|;
else|else
continue|continue;
block|}
block|}
name|oct_write64
argument_list|(
name|OCTEON_RGMX_TX_PRTS
argument_list|(
name|iface
argument_list|)
argument_list|,
name|nr_ports
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
name|iface
operator|*
literal|16
init|;
name|port
operator|<
name|iface
operator|*
literal|16
operator|+
name|nr_ports
condition|;
name|port
operator|++
control|)
block|{
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|OCTEON_RGMX_DEV_NAME
argument_list|,
name|num_devices
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: device_add_child() failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|softc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rgmx_softc_dev
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|softc
condition|)
block|{
name|panic
argument_list|(
literal|"%s malloc failed for softc\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|device_set_softc
argument_list|(
name|child
argument_list|,
name|softc
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|child
argument_list|,
literal|"Octeon RGMII"
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
block|{
name|printf
argument_list|(
literal|" No sc\n"
argument_list|)
expr_stmt|;
name|num_devices
operator|++
expr_stmt|;
continue|continue;
block|}
name|port_array
index|[
name|num_devices
index|]
operator|=
name|port
expr_stmt|;
name|rgmx_scdev_array
index|[
name|num_devices
index|]
operator|=
name|sc
expr_stmt|;
name|RGMX_LOCK_INIT
argument_list|(
name|sc
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|octeon_rgmx_init_sc
argument_list|(
name|sc
argument_list|,
name|child
argument_list|,
name|port
argument_list|,
name|num_devices
argument_list|)
expr_stmt|;
name|octeon_config_hw_units_port
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|octeon_rgmx_init_ifnet
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  ifinit failed for rgmx port %u\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
comment|/*  * Don't call octeon_rgmx_mark_ready()  * ifnet will call it indirectly via  octeon_rgmx_init()  *  *                         octeon_rgmx_mark_ready(sc);  */
name|num_devices
operator|++
expr_stmt|;
block|}
block|}
name|octeon_config_hw_units_post_ports
argument_list|()
expr_stmt|;
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|irq_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|irq_rid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate irq\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|OCTEON_RGMX_SCHEDULED_ISRS
comment|/*          * Single task queues for all child devices. Since POW gives us a unified          * interrupt based on POW groups, not based on PORTs.          */
name|TASK_INIT
argument_list|(
operator|&
name|rxtx_isr_task
argument_list|,
literal|0
argument_list|,
name|octeon_rgmx_isr_rxtx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|link_isr_task
argument_list|,
literal|0
argument_list|,
name|octeon_rgmx_isr_link
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"octeon_rgmx_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|irq_res
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|octeon_rgmx_intr_fast
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|int_handler_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_setup_intr returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|tq
argument_list|)
expr_stmt|;
name|tq
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|#
directive|else
comment|/* OCTEON_RGMX_SCHEDULED_ISRS */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|irq_res
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|octeon_rgmx_intr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|int_handler_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_setup_intr returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|tq
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* OCTEON_RGMX_SCHEDULED_ISRS */
return|return
operator|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OCTEON_MAX_RGMX_PORT_NUMS
value|32
end_define

begin_define
define|#
directive|define
name|OCTEON_POW_RX_GROUP_NUM
value|0
end_define

begin_define
define|#
directive|define
name|OCTEON_POW_TX_GROUP_NUM
value|1
end_define

begin_comment
comment|/* If using TX WQE from PKO */
end_comment

begin_define
define|#
directive|define
name|OCTEON_POW_RX_GROUP_MASK
value|(1<< OCTEON_POW_RX_GROUP_NUM)
end_define

begin_define
define|#
directive|define
name|OCTEON_POW_TX_GROUP_MASK
value|(1<< OCTEON_POW_TX_GROUP_NUM)
end_define

begin_define
define|#
directive|define
name|OCTEON_POW_ALL_OUR_GROUPS_MASK
value|(OCTEON_POW_RX_GROUP_MASK | OCTEON_POW_RX_GROUP_MASK)
end_define

begin_define
define|#
directive|define
name|OCTEON_POW_ALL_GROUPS_MASK
value|0xffff
end_define

begin_define
define|#
directive|define
name|OCTEON_POW_WORKQUEUE_INT
value|(0x8001670000000200ull)
end_define

begin_define
define|#
directive|define
name|OCTEON_POW_WORKQUEUE_INT_PC
value|(0x8001670000000208ull)
end_define

begin_define
define|#
directive|define
name|OCTEON_POW_WORKQUEUE_INT_THRESHOLD
parameter_list|(
name|group_num
parameter_list|)
value|((0x8001670000000080ull+((group_num)*0x8)))
end_define

begin_define
define|#
directive|define
name|OCTEON_RGMX_POW_NOS_CNT
value|(0x8001670000000228ull)
end_define

begin_define
define|#
directive|define
name|OCTEON_POW_INT_CNTR
parameter_list|(
name|core
parameter_list|)
value|(0x8001670000000100ull+((core)*0x8))
end_define

begin_define
define|#
directive|define
name|OCTEON_POW_INPT_Q_ALL_QOS
value|(0x8001670000000388ull)
end_define

begin_define
define|#
directive|define
name|OCTEON_POW_INPT_QOS_GRP
parameter_list|(
name|grp
parameter_list|)
value|(0x8001670000000340ull + ((grp) * 0x8))
end_define

begin_define
define|#
directive|define
name|NUM_RX_PACKETS_CTL
value|(MAX_RX_BUFS + 3000)
end_define

begin_define
define|#
directive|define
name|NUM_TX_PACKETS_CTL
value|40
end_define

begin_define
define|#
directive|define
name|FPA_NOPOOL
value|0
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_RX_PACKET_POOL
value|0
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_RX_PACKET_POOL_WORDS
value|208
end_define

begin_comment
comment|/* 2048 bytes */
end_comment

begin_define
define|#
directive|define
name|OCTEON_FPA_RX_PACKET_POOL_ELEM_SIZE
value|(OCTEON_FPA_RX_PACKET_POOL_WORDS)
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_RX_PACKET_POOL_ELEMENTS
value|(MAX_RX_BUFS)
end_define

begin_define
define|#
directive|define
name|OCTEON_RX_MAX_SIZE
value|(OCTEON_FPA_RX_PACKET_POOL_WORDS * sizeof(uint64_t))
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_WQE_RX_POOL
value|1
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_WQE_RX_WORDS
value|(OCTEON_CACHE_LINE_SIZE/8)
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_WQE_RX_POOL_ELEM_SIZE
value|(OCTEON_FPA_WQE_RX_WORDS)
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_WQE_RX_POOL_ELEMENTS
value|(NUM_RX_PACKETS_CTL)
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_TX_PACKET_POOL
value|2
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_TX_PACKET_POOL_WORDS
value|208
end_define

begin_comment
comment|/* 2048 bytes */
end_comment

begin_define
define|#
directive|define
name|OCTEON_FPA_TX_PACKET_POOL_ELEM_SIZE
value|(OCTEON_FPA_TX_PACKET_POOL_WORDS)
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_TX_PACKET_POOL_ELEMENTS
value|(MAX_TX_BUFS)
end_define

begin_define
define|#
directive|define
name|OCTEON_TX_MAX_SIZE
value|(OCTEON_FPA_TX_PACKET_POOL_WORDS * sizeof(uint64_t))
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_TX_CMDBUF_POOL
value|3
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_TX_CMD_SIZE
value|2
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_TX_CMD_NUM
value|300
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_TX_CMDBUF_POOL_WORDS
value|(OCTEON_FPA_TX_CMD_SIZE * OCTEON_FPA_TX_CMD_NUM)
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_TX_CMDBUF_POOL_ELEM_SIZE
value|(OCTEON_FPA_TX_CMDBUF_POOL_WORDS +1)
end_define

begin_define
define|#
directive|define
name|OCTEON_FPA_TX_CMDBUF_POOL_ELEMENTS
value|(30 * OCTEON_RGMX_NUM_PORTS_MAX)
end_define

begin_define
define|#
directive|define
name|FIRST_PARTICLE_SKIP
value|0
end_define

begin_define
define|#
directive|define
name|NOT_FIRST_PARTICLE_SKIP
value|0
end_define

begin_define
define|#
directive|define
name|ENABLE_BACK_PRESSURE
value|0
end_define

begin_define
define|#
directive|define
name|RGMX_MAX_PAK_RECEIVE
value|5000000
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|OCTEON_RGMX_SCHEDULED_ISRS
end_ifdef

begin_function
specifier|static
name|void
name|octeon_rgmx_isr_link
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|octeon_line_status_loop
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|octeon_rgmx_isr_rxtx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|octeon_rx_loop
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Fast Interrupt Service routine  *  *********************************************************************/
end_comment

begin_comment
comment|//#define OCTEON_RGMX_POW_TIME_THR_INTS 1
end_comment

begin_function
specifier|static
name|int
name|octeon_rgmx_intr_fast
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|handled_flag
init|=
literal|0
decl_stmt|;
name|uint64_t
name|ciu_summary
decl_stmt|;
name|ciu_summary
operator|=
name|ciu_get_int_summary
argument_list|(
name|CIU_THIS_CORE
argument_list|,
name|OCTEON_RGMX_CIU_INTX
argument_list|,
name|OCTEON_RGMX_CIU_ENX
argument_list|)
expr_stmt|;
if|if
condition|(
name|ciu_summary
operator|&
name|CIU_GENTIMER_BITS_ENABLE
argument_list|(
name|CIU_GENTIMER_NUM_1
argument_list|)
condition|)
block|{
comment|/*                  * Timer Interrupt for link status checks                  * Acknowledging it will mask it for this cycle.                  */
name|ciu_clear_int_summary
argument_list|(
name|CIU_THIS_CORE
argument_list|,
name|OCTEON_RGMX_CIU_INTX
argument_list|,
name|OCTEON_RGMX_CIU_ENX
argument_list|,
name|CIU_GENTIMER_BITS_ENABLE
argument_list|(
name|CIU_GENTIMER_NUM_1
argument_list|)
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_fast
argument_list|,
operator|&
name|link_isr_task
argument_list|)
expr_stmt|;
name|handled_flag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ciu_summary
operator|&
name|OCTEON_POW_ALL_GROUPS_MASK
condition|)
block|{
ifndef|#
directive|ifndef
name|OCTEON_RGMX_POW_TIME_THR_INTS
comment|/*                  * When using POW IQ/DSQ size based interrupts, then                  *    ack the interrupts right away.  So they don't interrupt                  *    until the queue size goes to 0 again.                  */
name|oct_write64
argument_list|(
name|OCTEON_POW_WORKQUEUE_INT
argument_list|,
literal|0x10001
operator|<<
name|OCTEON_POW_RX_GROUP_NUM
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/*                  * We use POW thresholds based interrupt signalled on timer                  *   countdown. Acknowledge it now so that it doesn't                  *   interrupt us until next countdown to zero.                  */
name|oct_write64
argument_list|(
name|OCTEON_POW_WORKQUEUE_INT
argument_list|,
literal|0x1
operator|<<
name|OCTEON_POW_RX_GROUP_NUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|taskqueue_enqueue
argument_list|(
name|tq
argument_list|,
operator|&
name|rxtx_isr_task
argument_list|)
expr_stmt|;
name|handled_flag
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|handled_flag
operator|)
condition|?
name|FILTER_HANDLED
else|:
name|FILTER_STRAY
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  ! OCTEON_RGMX_SCHEDULED_ISRS */
end_comment

begin_comment
comment|/*  * octeon_rgmx_intr  *  * This is direct inline isr. Will do all its work and heavy-lifting in interrupt context.  *  * Also note that the  RGMX_LOCK/UNLOCK code will have to checked/added, since that is new and  * was not supported with this model.  */
end_comment

begin_function
specifier|static
name|int
name|octeon_rgmx_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|uint64_t
name|ciu_summary
decl_stmt|;
comment|/*          * read ciu to see if any bits are pow          */
while|while
condition|(
literal|1
condition|)
block|{
name|ciu_summary
operator|=
name|ciu_get_int_summary
argument_list|(
name|CIU_THIS_CORE
argument_list|,
name|OCTEON_RGMX_CIU_INTX
argument_list|,
name|OCTEON_RGMX_CIU_ENX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ciu_summary
operator|&
operator|(
name|OCTEON_POW_ALL_GROUPS_MASK
operator||
name|CIU_GENTIMER_BITS_ENABLE
argument_list|(
name|CIU_GENTIMER_NUM_1
argument_list|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ciu_summary
operator|&
name|OCTEON_POW_ALL_GROUPS_MASK
condition|)
block|{
name|octeon_rx_loop
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/*                          * Acknowledge the interrupt after processing queues.                          */
name|oct_write64
argument_list|(
name|OCTEON_POW_WORKQUEUE_INT
argument_list|,
name|OCTEON_POW_RX_GROUP_MASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ciu_summary
operator|&
name|CIU_GENTIMER_BITS_ENABLE
argument_list|(
name|CIU_GENTIMER_NUM_1
argument_list|)
condition|)
block|{
name|octeon_line_status_loop
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ciu_clear_int_summary
argument_list|(
name|CIU_THIS_CORE
argument_list|,
name|OCTEON_RGMX_CIU_INTX
argument_list|,
name|OCTEON_RGMX_CIU_ENX
argument_list|,
name|CIU_GENTIMER_BITS_ENABLE
argument_list|(
name|CIU_GENTIMER_NUM_1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|(
name|flag
operator|)
condition|?
name|FILTER_HANDLED
else|:
name|FILTER_STRAY
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  OCTEON_RGMX_SCHEDULED_ISRS */
end_comment

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|octeon_rgmx_build_new_rx_mbuf
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|void
modifier|*
name|data_start
parameter_list|,
name|u_int
name|totlen
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|octeon_rgmx_build_new_rx_mbuf
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|void
modifier|*
name|data_start
parameter_list|,
name|u_int
name|totlen
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
name|newm
decl_stmt|;
name|caddr_t
name|newdata
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|totlen
operator|<=
name|ETHER_HDR_LEN
operator|||
name|totlen
operator|>
name|LEBLEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
ifdef|#
directive|ifdef
name|LEDEBUG
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"invalid packet size %d; dropping\n"
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Initialize packet header info.  */
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
name|len
operator|=
name|MHLEN
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|totlen
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
goto|goto
name|octeon_rgmx_build_new_rx_mbuf_bad
goto|;
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|m0
condition|)
block|{
name|newdata
operator|=
operator|(
name|caddr_t
operator|)
name|ALIGN
argument_list|(
name|m
operator|->
name|m_data
operator|+
name|ETHER_HDR_LEN
argument_list|)
operator|-
name|ETHER_HDR_LEN
expr_stmt|;
name|len
operator|-=
name|newdata
operator|-
name|m
operator|->
name|m_data
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|newdata
expr_stmt|;
block|}
comment|/* Set the length of this mbuf.  */
name|m
operator|->
name|m_len
operator|=
name|len
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data_start
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|data_start
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
call|(
name|u_long
call|)
argument_list|(
name|data_start
argument_list|)
operator|)
operator|+
name|len
operator|)
expr_stmt|;
name|totlen
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
name|MGET
argument_list|(
name|newm
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|newm
operator|==
literal|0
condition|)
goto|goto
name|octeon_rgmx_build_new_rx_mbuf_bad
goto|;
name|len
operator|=
name|MLEN
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
operator|=
name|newm
expr_stmt|;
block|}
block|}
return|return
operator|(
name|m0
operator|)
return|;
name|octeon_rgmx_build_new_rx_mbuf_bad
label|:
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|//#define DEBUG_RX 1
end_comment

begin_function
specifier|static
name|void
name|octeon_rgmx_rx_process_work
parameter_list|(
name|octeon_wqe_t
modifier|*
name|work
parameter_list|,
name|u_int
name|port
parameter_list|)
block|{
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|void
modifier|*
name|data_start
decl_stmt|,
modifier|*
name|new_data_start
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
comment|//#define DEBUG_RX_PKT_DUMP 1
ifdef|#
directive|ifdef
name|DEBUG_RX_PKT_DUMP
name|int
name|i
decl_stmt|;
name|u_char
modifier|*
name|dc
decl_stmt|;
endif|#
directive|endif
name|data_start
operator|=
name|octeon_pow_pktptr_to_kbuffer
argument_list|(
name|work
operator|->
name|packet_ptr
argument_list|)
expr_stmt|;
comment|//#define DEBUG_RX2
ifdef|#
directive|ifdef
name|DEBUG_RX2
name|printf
argument_list|(
literal|" WQE 0x%X: port:%u  "
argument_list|,
name|work
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Grp: %u, %llX  Tag: %u  %llX  type: %u 0x%llx\n"
argument_list|,
name|work
operator|->
name|grp
argument_list|,
name|work
operator|->
name|grp
argument_list|,
name|work
operator|->
name|tag
argument_list|,
name|work
operator|->
name|tag
argument_list|,
name|work
operator|->
name|tag_type
argument_list|,
name|work
operator|->
name|tag_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|port
operator|>=
name|OCTEON_RGMX_MIN_PORT
operator|)
operator|||
operator|(
name|port
operator|<=
name|OCTEON_RGMX_MAX_PORT
operator|)
condition|)
block|{
name|sc
operator|=
name|get_rgmx_softc
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|||
operator|!
name|sc
operator|->
name|ifp
condition|)
block|{
name|printf
argument_list|(
literal|" octeon_rgmx_rx_process_work No sc or sc->ifp -  port:%u"
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
if|if
condition|(
operator|!
name|work
operator|->
name|word2
operator|.
name|bits
operator|.
name|rcv_error
condition|)
block|{
name|len
operator|=
name|work
operator|->
name|len
expr_stmt|;
comment|/*                                      * We cannot pass the same FPA phys-buffer higher up.                                      * User space will not be able to use this phys-buffer.                                      *                                      * Start building a mbuf packet here using  data_start& len.                                      */
name|new_data_start
operator|=
name|data_start
expr_stmt|;
if|if
condition|(
operator|!
name|work
operator|->
name|word2
operator|.
name|bits
operator|.
name|not_IP
condition|)
block|{
name|new_data_start
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|new_data_start
argument_list|)
operator|)
operator|+
literal|14
operator|)
expr_stmt|;
comment|/* mark it as checksum checked */
block|}
else|else
block|{
name|new_data_start
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|new_data_start
argument_list|)
operator|)
operator|+
literal|8
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_RX_PKT_DUMP
name|dc
operator|=
name|new_data_start
expr_stmt|;
name|printf
argument_list|(
literal|"In:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|16
operator|)
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %02X"
argument_list|,
name|dc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mbuf
operator|=
name|octeon_rgmx_build_new_rx_mbuf
argument_list|(
name|ifp
argument_list|,
name|new_data_start
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbuf
condition|)
block|{
comment|//                                    	printf(" Passing pkt to ifp: pkt_len: %u len: %u ", mbuf->m_pkthdr.len, mbuf->m_len);
ifdef|#
directive|ifdef
name|DEBUG_RX_PKT_DUMP
name|dc
operator|=
name|mtod
argument_list|(
name|mbuf
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"In: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mbuf
operator|->
name|m_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
literal|16
operator|)
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %02X"
argument_list|,
name|dc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Feed the packet to upper layer.  */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* mbuf error */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"mbuf rx construct error\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" mbuf rx construct error\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
comment|/*  mbuf error */
block|}
else|else
block|{
comment|/*  rcv_error */
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
comment|/*  rcv_error */
block|}
comment|/* IFF_DRV_RUNNING */
block|}
comment|/*  sc&& sc->ifp */
block|}
else|else
block|{
comment|/* port number */
name|printf
argument_list|(
literal|" rgmx_rx:%u bad port\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|octeon_fpa_free
argument_list|(
name|data_start
argument_list|,
name|OCTEON_FPA_RX_PACKET_POOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|octeon_fpa_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|work
argument_list|,
name|OCTEON_FPA_WQE_RX_POOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------- *  *                      octeon_rx_loop()                               *  * ------------------------------------------------------------------- */
end_comment

begin_comment
comment|//#define OCTEON_VISUAL_RGMX 1
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OCTEON_VISUAL_RGMX
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|where0
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|where1
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|octeon_rx_loop
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|u_int
name|core_id
decl_stmt|;
name|uint64_t
name|prev_grp_mask
decl_stmt|;
name|u_int
name|pak_count
decl_stmt|;
name|octeon_wqe_t
modifier|*
name|work
decl_stmt|;
name|core_id
operator|=
name|octeon_get_core_num
argument_list|()
expr_stmt|;
name|pak_count
operator|=
literal|0
expr_stmt|;
comment|/* Only allow work for our group */
name|prev_grp_mask
operator|=
name|oct_read64
argument_list|(
name|OCTEON_POW_CORE_GROUP_MASK
argument_list|(
name|core_id
argument_list|)
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_POW_CORE_GROUP_MASK
argument_list|(
name|core_id
argument_list|)
argument_list|,
name|OCTEON_POW_ALL_GROUPS_MASK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OCTEON_VISUAL_RGMX
name|octeon_led_run_wheel
argument_list|(
operator|&
name|where0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|pak_count
operator|++
operator|>
name|RGMX_MAX_PAK_RECEIVE
condition|)
block|{
break|break;
block|}
name|work
operator|=
name|octeon_pow_work_request_sync
argument_list|(
name|OCTEON_POW_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|NULL
condition|)
block|{
comment|/*                          * No more incoming packets. We can take a break now.                          */
break|break;
block|}
ifdef|#
directive|ifdef
name|OCTEON_VISUAL_RGMX
name|octeon_led_run_wheel
argument_list|(
operator|&
name|where1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|octeon_rgmx_rx_process_work
argument_list|(
name|work
argument_list|,
name|work
operator|->
name|ipprt
argument_list|)
expr_stmt|;
block|}
name|oct_write64
argument_list|(
name|OCTEON_POW_CORE_GROUP_MASK
argument_list|(
name|core_id
argument_list|)
argument_list|,
name|prev_grp_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|octeon_rgmx_write_mbufs_to_fpa_buff
parameter_list|(
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|void
modifier|*
name|data_area
decl_stmt|;
name|u_char
modifier|*
name|write_offset
decl_stmt|;
comment|/*          * FIXME          *          * Compare len with max FPA-tx-packet size. Or else we will possibly corrupt the next pkt.          */
comment|/*          * Get an FPA buffer from Xmit-packets FPA pool          */
name|data_area
operator|=
name|octeon_fpa_alloc
argument_list|(
name|OCTEON_FPA_TX_PACKET_POOL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data_area
condition|)
block|{
comment|/*                  * Fail.  No room. No resources.                  */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*          * Transfer the data from mbuf chain to the transmission buffer.          */
name|write_offset
operator|=
name|data_area
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
operator|!=
literal|0
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_len
condition|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|write_offset
argument_list|,
name|mp
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|write_offset
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|(
operator|(
name|u_long
operator|)
name|write_offset
operator|)
operator|+
name|mp
operator|->
name|m_len
operator|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|data_area
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|octeon_rgmx_pko_xmit_packet
parameter_list|(
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|out_buff
parameter_list|,
name|u_int
name|len
parameter_list|,
name|u_int
name|checksum
parameter_list|)
block|{
name|octeon_pko_command_word0_t
name|pko_cmd
decl_stmt|;
name|octeon_pko_packet_ptr_t
name|pko_pkt_word
decl_stmt|;
name|u_long
name|temp
decl_stmt|;
name|u_short
name|xmit_cmd_index
decl_stmt|;
name|uint64_t
modifier|*
name|xmit_cmd_ptr
decl_stmt|;
name|uint64_t
name|xmit_cmd_state
decl_stmt|;
name|int
name|queue
init|=
literal|0
decl_stmt|;
comment|// we should randomize queue # based on core num. Using same
comment|// queue 0 for this port, by all cores on is less efficient.
comment|/*      * Prepare the PKO buffer and command word.      *   Cmd Buf Word 0      *   No FAU      *   Set #-segs and #-bytes      */
name|pko_cmd
operator|.
name|word64
operator|=
literal|0
expr_stmt|;
name|pko_cmd
operator|.
name|bits
operator|.
name|segs
operator|=
literal|1
expr_stmt|;
name|pko_cmd
operator|.
name|bits
operator|.
name|total_bytes
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
name|pko_cmd
operator|.
name|bits
operator|.
name|ipoffp1
operator|=
name|ETHER_HDR_LEN
operator|+
literal|1
expr_stmt|;
comment|/* IPOffP1 is +1 based.  1 means offset 0 */
block|}
comment|/*      * Build the PKO buffer pointer. PKO Cmd Buf Word 1      */
name|pko_pkt_word
operator|.
name|word64
operator|=
literal|0
expr_stmt|;
name|pko_pkt_word
operator|.
name|bits
operator|.
name|addr
operator|=
name|OCTEON_PTR2PHYS
argument_list|(
name|out_buff
argument_list|)
expr_stmt|;
name|pko_pkt_word
operator|.
name|bits
operator|.
name|pool
operator|=
name|OCTEON_FPA_TX_PACKET_POOL
expr_stmt|;
name|pko_pkt_word
operator|.
name|bits
operator|.
name|size
operator|=
literal|2048
expr_stmt|;
comment|// dummy. Actual len is above.
ifdef|#
directive|ifdef
name|DEBUG_TX
name|printf
argument_list|(
literal|" PKO: 0x%llX  0x%llX "
argument_list|,
name|pko_cmd
operator|.
name|word64
argument_list|,
name|pko_pkt_word
operator|.
name|word64
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Get the queue command ptr location from the per port per queue, pko info struct.      */
name|octeon_spinlock_lock
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|outq_ptr
index|[
name|queue
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_TX
name|printf
argument_list|(
literal|" xmit: sc->outq_ptr[queue].xmit_command_state: 0x%llX  "
argument_list|,
name|sc
operator|->
name|outq_ptr
index|[
name|queue
index|]
operator|.
name|xmit_command_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xmit_cmd_state
operator|=
name|sc
operator|->
name|outq_ptr
index|[
name|queue
index|]
operator|.
name|xmit_command_state
expr_stmt|;
name|sc
operator|->
name|outq_ptr
index|[
name|queue
index|]
operator|.
name|xmit_command_state
operator|=
name|xmit_cmd_state
operator|+
literal|2
expr_stmt|;
name|temp
operator|=
call|(
name|u_long
call|)
argument_list|(
name|xmit_cmd_state
operator|>>
name|OCTEON_PKO_INDEX_BITS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_TX
name|printf
argument_list|(
literal|" temp: 0x%X "
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xmit_cmd_ptr
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|MIPS_PHYS_TO_KSEG0
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|xmit_cmd_index
operator|=
name|xmit_cmd_state
operator|&
name|OCTEON_PKO_INDEX_MASK
expr_stmt|;
name|xmit_cmd_ptr
operator|+=
name|xmit_cmd_index
expr_stmt|;
comment|/*      * We end the PKO cmd buffer at odd boundary. Towards the end we will have      * 4 or 3 or 2 or 1 or 0 word remaining.  Case of 4, 2, or 0 can never happen.      * We only care when we have 3 words remaining. In this case we write our 2 words      * for PKO command and 3rd word as chain for next PKO cmd buffer.      */
name|xmit_cmd_ptr
index|[
literal|0
index|]
operator|=
name|pko_cmd
operator|.
name|word64
expr_stmt|;
if|if
condition|(
name|xmit_cmd_index
operator|<
operator|(
name|OCTEON_FPA_TX_CMDBUF_POOL_WORDS
operator|-
literal|2
operator|)
condition|)
block|{
comment|/*          * Plenty of space left. Write our 2nd word and worry the next time.          */
name|xmit_cmd_ptr
index|[
literal|1
index|]
operator|=
name|pko_pkt_word
operator|.
name|word64
expr_stmt|;
block|}
else|else
block|{
comment|/*          * 3 words or less are left. We write our 2nd word now and then put in a chain link          * to new PKO cmd buf.          */
name|void
modifier|*
name|pko_cmd_buf
init|=
name|octeon_fpa_alloc
argument_list|(
name|OCTEON_FPA_TX_CMDBUF_POOL
argument_list|)
decl_stmt|;
name|uint64_t
name|phys_cmd_buf
decl_stmt|;
if|if
condition|(
operator|!
name|pko_cmd_buf
condition|)
block|{
comment|/*              * FPA pool for xmit-buffer-commands is empty.              */
name|sc
operator|->
name|outq_ptr
index|[
name|queue
index|]
operator|.
name|xmit_command_state
operator|-=
literal|2
expr_stmt|;
name|octeon_spinlock_unlock
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|outq_ptr
index|[
name|queue
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|phys_cmd_buf
operator|=
name|OCTEON_PTR2PHYS
argument_list|(
name|pko_cmd_buf
argument_list|)
expr_stmt|;
name|xmit_cmd_ptr
index|[
literal|1
index|]
operator|=
name|pko_pkt_word
operator|.
name|word64
expr_stmt|;
name|xmit_cmd_ptr
index|[
literal|2
index|]
operator|=
name|phys_cmd_buf
expr_stmt|;
name|sc
operator|->
name|outq_ptr
index|[
name|queue
index|]
operator|.
name|xmit_command_state
operator|=
operator|(
name|phys_cmd_buf
operator|<<
name|OCTEON_PKO_INDEX_BITS
operator|)
expr_stmt|;
block|}
comment|/*      * Unlock queue structures.      */
name|octeon_spinlock_unlock
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|outq_ptr
index|[
name|queue
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
comment|/*      * 2 words incremented in PKO. Ring the doorbell.      */
ifdef|#
directive|ifdef
name|DEBUG_TX
name|printf
argument_list|(
literal|" Ringing doorbell: Port %u  Queue %u  words 2"
argument_list|,
name|sc
operator|->
name|port
argument_list|,
name|octeon_pko_get_base_queue
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|+
name|queue
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|octeon_pko_ring_doorbell
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|octeon_pko_get_base_queue
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|+
name|queue
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|octeon_rgmx_xmit_mark_buffers_done
parameter_list|(
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
parameter_list|,
name|u_int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|octeon_rgmx_xmit_mark_buffers_done
parameter_list|(
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
parameter_list|,
name|u_int
name|n
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/*                  * Remove packets in queue. Leaving a lag of 3, to allow for PKO in-flight xmission                  */
if|if
condition|(
name|_IF_QLEN
argument_list|(
operator|&
name|sc
operator|->
name|tx_pending_queue
argument_list|)
operator|>
literal|4
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|tx_pending_queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
break|break;
comment|// Queue became empty now. Break out.
block|}
comment|/*                          * Return the mbuf to system.                          */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|i
condition|)
block|{
return|return;
comment|// Nothing removed from queue.
block|}
comment|/*          * The transmitter is no more active.          * Reset output active flag and watchdog timer.          */
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|OCTEON_RGMX_FLUSH_N_XMIT_MBUFS_EACH_LOOP
value|5
end_define

begin_define
define|#
directive|define
name|OCTEON_RGMX_FLUSH_PENDING_MBUFS_MAX
value|1000
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__not_used__
end_ifdef

begin_comment
comment|/*  * octeon_rgmx_output_flush  *  * Drop all packets queued at ifnet layer.  */
end_comment

begin_function
specifier|static
name|void
name|octeon_rgmx_output_flush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|max_flush
init|=
name|OCTEON_RGMX_FLUSH_PENDING_MBUFS_MAX
decl_stmt|;
comment|/* Arbitrarily high number */
while|while
condition|(
name|max_flush
operator|--
operator|&&
name|_IF_QLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
comment|/*                  * Get the next mbuf Packet chain to flush.                  */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* No more packets to flush */
break|break;
block|}
name|_IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * octeon_rgmx_output_start  *  * Start output on interface.  */
end_comment

begin_function
specifier|static
name|void
name|octeon_rgmx_output_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|RGMX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|octeon_rgmx_output_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|RGMX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * octeon_rgmx_output_start_locked  *  * Start output on interface.  Assume Driver locked  */
end_comment

begin_function
specifier|static
name|void
name|octeon_rgmx_output_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|len
decl_stmt|,
name|need_l4_checksum
decl_stmt|;
name|void
modifier|*
name|out_buff
decl_stmt|;
comment|/*          * Take out some of the last queued mbuf's from xmit-pending queue          */
name|octeon_rgmx_xmit_mark_buffers_done
argument_list|(
name|sc
argument_list|,
name|OCTEON_RGMX_FLUSH_N_XMIT_MBUFS_EACH_LOOP
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/*                  * See if there is room to put another packet in the buffer.                  * We *could* do better job by peeking the send queue to                  * know the length of the next packet.  Current version just                  * tests against the worst case (i.e., longest packet).  FIXME.                  *                  * When adding the packet-peek feature, don't forget adding a                  * test on txb_count against QUEUEING_MAX.                  * There is a little chance the packet count exceeds                  * the limit.  Assume transmission buffer is 8KB (2x8KB                  * configuration) and an application sends a bunch of small                  * (i.e., minimum packet sized) packets rapidly.  An 8KB                  * buffer can hold 130 blocks of 62 bytes long...                  */
comment|/*                  * If unable to send more.                  */
if|if
condition|(
name|_IF_QLEN
argument_list|(
operator|&
name|sc
operator|->
name|tx_pending_queue
argument_list|)
operator|>=
name|MAX_TX_BUFS
condition|)
block|{
name|printf
argument_list|(
literal|" Xmit not possible. NO room %u"
argument_list|,
name|_IF_QLEN
argument_list|(
operator|&
name|sc
operator|->
name|tx_pending_queue
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|indicate_active
goto|;
block|}
comment|/*                  * Get the next mbuf chain for a packet to send.                  */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* No more packets to send.  */
goto|goto
name|indicate_inactive
goto|;
block|}
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/*                  * Should never send big packets.  If such a packet is passed,                  * it should be a bug of upper layer.  We just ignore it.                  * ... Partial (too short) packets, neither.                  */
if|if
condition|(
name|len
operator|<
name|ETHER_HDR_LEN
operator|||
name|len
operator|>
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
comment|/*                          * Fail.  Bad packet size.  Return the mbuf to system.                          */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"got an out-of-spec packet (%u bytes) to send\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|indicate_active
goto|;
block|}
comment|/*                  * Copy the mbuf chain into the transmission buffer.                  * txb_* variables are updated as necessary.                  */
name|out_buff
operator|=
name|octeon_rgmx_write_mbufs_to_fpa_buff
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out_buff
condition|)
block|{
comment|/*                          * No FPA physical buf resource.                          * Let's requeue it back.  And slow it down for a while.                          */
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
goto|goto
name|indicate_active
goto|;
block|}
name|need_l4_checksum
operator|=
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/*                  * put the mbuf onto pending queue                  */
comment|//#define DEBUG_TX_PKT_DUMP 1
ifdef|#
directive|ifdef
name|DEBUG_TX_PKT_DUMP
name|int
name|ii
decl_stmt|;
name|u_char
modifier|*
name|dc
init|=
name|out_buff
decl_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Out: "
argument_list|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|len
condition|;
name|ii
operator|++
control|)
name|printf
argument_list|(
literal|" %X"
argument_list|,
name|dc
index|[
name|ii
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|tx_pending_queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/*                  * Pass the mbuf data packet to PKO for xmission.                  */
name|octeon_rgmx_pko_xmit_packet
argument_list|(
name|sc
argument_list|,
name|out_buff
argument_list|,
name|len
argument_list|,
name|need_l4_checksum
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
block|}
name|indicate_inactive
label|:
comment|/*          * We are using the !OACTIVE flag to indicate to          * the outside world that we can accept an          * additional packet rather than that the          * transmitter is _actually_ active.  Indeed, the          * transmitter may be active, but if we haven't          * filled all the buffers with data then we still          * want to accept more.          */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return;
name|indicate_active
label|:
comment|/*          * The transmitter is active, and there are no room for          * more outgoing packets in the transmission buffer.          */
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
comment|//	sc->mibdata.dot3StatsInternalMacTransmitErrors++;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------- *  *                      octeon_config_hw_units()                       *  * ------------------------------------------------------------------- *  *  * Initialize Octeon hardware components. To get the RGMX going.  *  */
end_comment

begin_function
specifier|static
name|void
name|octeon_config_hw_units_pre_ports
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Enable FPA */
name|octeon_enable_fpa
argument_list|()
expr_stmt|;
comment|/* Enable PKO */
name|octeon_pko_enable
argument_list|()
expr_stmt|;
comment|/* Init PKO */
name|octeon_pko_init
argument_list|()
expr_stmt|;
comment|/* Fill FPA */
comment|/*          * Input Buffers Pool          * Pool 0          */
name|octeon_fpa_fill_pool_mem
argument_list|(
name|OCTEON_FPA_RX_PACKET_POOL
argument_list|,
name|OCTEON_FPA_RX_PACKET_POOL_ELEM_SIZE
argument_list|,
name|OCTEON_FPA_RX_PACKET_POOL_ELEMENTS
argument_list|)
expr_stmt|;
comment|/*          * WQE Blocks Pool          * Pool 1          */
name|octeon_fpa_fill_pool_mem
argument_list|(
name|OCTEON_FPA_WQE_RX_POOL
argument_list|,
name|OCTEON_FPA_WQE_RX_POOL_ELEM_SIZE
argument_list|,
name|OCTEON_FPA_WQE_RX_POOL_ELEMENTS
argument_list|)
expr_stmt|;
comment|/*          * PKO Command Pool          * Pool  3          */
name|octeon_fpa_fill_pool_mem
argument_list|(
name|OCTEON_FPA_TX_CMDBUF_POOL
argument_list|,
name|OCTEON_FPA_TX_CMDBUF_POOL_ELEM_SIZE
argument_list|,
name|OCTEON_FPA_TX_CMDBUF_POOL_ELEMENTS
argument_list|)
expr_stmt|;
comment|/*          * Output Buffers Pool          * Pool 2          */
name|octeon_fpa_fill_pool_mem
argument_list|(
name|OCTEON_FPA_TX_PACKET_POOL
argument_list|,
name|OCTEON_FPA_TX_PACKET_POOL_ELEM_SIZE
argument_list|,
name|OCTEON_FPA_TX_PACKET_POOL_ELEMENTS
argument_list|)
expr_stmt|;
name|octeon_rgmx_enable_RED_all
argument_list|(
name|OCTEON_FPA_RX_PACKET_POOL_ELEMENTS
operator|>>
literal|2
argument_list|,
name|OCTEON_FPA_RX_PACKET_POOL_ELEMENTS
operator|>>
literal|3
argument_list|)
expr_stmt|;
comment|/* Configure IPD */
name|octeon_ipd_config
argument_list|(
name|OCTEON_FPA_RX_PACKET_POOL_WORDS
argument_list|,
name|FIRST_PARTICLE_SKIP
operator|/
literal|8
argument_list|,
name|NOT_FIRST_PARTICLE_SKIP
operator|/
literal|8
argument_list|,
name|FIRST_PARTICLE_SKIP
operator|/
literal|128
argument_list|,
name|NOT_FIRST_PARTICLE_SKIP
operator|/
literal|128
argument_list|,
name|OCTEON_FPA_WQE_RX_POOL
argument_list|,
name|OCTEON_IPD_OPC_MODE_STF
argument_list|,
name|ENABLE_BACK_PRESSURE
argument_list|)
expr_stmt|;
comment|/*          * PKO setup Output Command Buffers          */
name|octeon_pko_config_cmdbuf_global_defaults
argument_list|(
name|OCTEON_FPA_TX_CMDBUF_POOL
argument_list|,
name|OCTEON_FPA_TX_CMDBUF_POOL_ELEM_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|octeon_config_hw_units_port
parameter_list|(
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
parameter_list|,
name|u_int
name|port
parameter_list|)
block|{
specifier|const
name|u_int
name|priorities
index|[
literal|8
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|}
decl_stmt|;
name|u_int
name|total_queues
decl_stmt|,
name|base_queue
decl_stmt|;
name|octeon_config_rgmii_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|total_queues
operator|=
name|octeon_pko_get_num_queues
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|base_queue
operator|=
name|octeon_pko_get_base_queue
argument_list|(
name|port
argument_list|)
expr_stmt|;
comment|/* Packet output configures Queue and Ports */
name|octeon_pko_config_port
argument_list|(
name|port
argument_list|,
name|base_queue
argument_list|,
name|total_queues
argument_list|,
name|priorities
argument_list|,
name|OCTEON_FPA_TX_CMDBUF_POOL
argument_list|,
name|sc
operator|->
name|outq_ptr
argument_list|)
expr_stmt|;
name|octeon_rgmx_set_mac
argument_list|(
name|port
argument_list|)
expr_stmt|;
comment|/* Setup Port input tagging */
name|octeon_rgmx_config_pip
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
union|union
block|{
name|uint64_t
name|word64
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|rsvd3
range|:
literal|35
decl_stmt|;
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|time_thr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rsvd2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ds_thr
range|:
literal|11
decl_stmt|;
name|uint64_t
name|rsvd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iq_thr
range|:
literal|11
decl_stmt|;
block|}
name|bits
struct|;
block|}
name|octeon_rgmx_pow_int_threshold_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
union|union
block|{
name|uint64_t
name|word64
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|rsvd
range|:
literal|36
decl_stmt|;
name|uint64_t
name|tc_cnt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ds_cnt
range|:
literal|12
decl_stmt|;
name|uint64_t
name|iq_cnt
range|:
literal|12
decl_stmt|;
block|}
name|bits
struct|;
block|}
name|octeon_rgmx_pow_int_cnt_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
union|union
block|{
name|uint64_t
name|word64
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|rsvd3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|thr_freq
range|:
literal|28
decl_stmt|;
comment|// R/O
name|uint64_t
name|rsvd2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|thr_period
range|:
literal|20
decl_stmt|;
name|uint64_t
name|rsvd
range|:
literal|8
decl_stmt|;
block|}
name|bits
struct|;
block|}
name|octeon_rgmx_pow_int_pc_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
union|union
block|{
name|uint64_t
name|word64
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|rsvd
range|:
literal|52
decl_stmt|;
name|uint64_t
name|nos_cnt
range|:
literal|12
decl_stmt|;
block|}
name|bits
struct|;
block|}
name|octeon_rgmx_pow_nos_cnt
typedef|;
end_typedef

begin_typedef
typedef|typedef
union|union
block|{
name|uint64_t
name|word64
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|rsvd
range|:
literal|32
decl_stmt|;
name|uint64_t
name|inb_pkts
range|:
literal|32
decl_stmt|;
block|}
name|bits
struct|;
block|}
name|octeon_rgmx_pip_inb_pkts
typedef|;
end_typedef

begin_typedef
typedef|typedef
union|union
block|{
name|uint64_t
name|word64
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|rsvd
range|:
literal|48
decl_stmt|;
name|uint64_t
name|inb_errs
range|:
literal|16
decl_stmt|;
block|}
name|bits
struct|;
block|}
name|octeon_rgmx_pip_inb_errs
typedef|;
end_typedef

begin_typedef
typedef|typedef
union|union
block|{
name|uint64_t
name|word64
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|rsvd
range|:
literal|32
decl_stmt|;
name|uint64_t
name|iq_cnt
range|:
literal|32
decl_stmt|;
block|}
name|bits
struct|;
block|}
name|octeon_pow_inpt_q_all_qos
typedef|;
end_typedef

begin_typedef
typedef|typedef
union|union
block|{
name|uint64_t
name|word64
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|rsvd
range|:
literal|32
decl_stmt|;
name|uint64_t
name|iq_cnt
range|:
literal|32
decl_stmt|;
block|}
name|bits
struct|;
block|}
name|octeon_pow_inpt_q_grp_qos
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|octeon_config_hw_units_post_ports
parameter_list|(
name|void
parameter_list|)
block|{
name|octeon_rgmx_pow_int_threshold_t
name|thr
decl_stmt|;
name|octeon_rgmx_pow_int_pc_t
name|intpc
decl_stmt|;
name|thr
operator|.
name|word64
operator|=
literal|0
expr_stmt|;
name|intpc
operator|.
name|word64
operator|=
literal|0
expr_stmt|;
name|intpc
operator|.
name|bits
operator|.
name|thr_freq
operator|=
operator|(
literal|500
operator|*
literal|1000
operator|*
literal|1000
operator|)
operator|/
operator|(
literal|1000
operator|*
literal|16
operator|*
literal|256
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OCTEON_RGMX_POW_TIME_THR_INTS
name|thr
operator|.
name|bits
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|thr
operator|.
name|bits
operator|.
name|time_thr
operator|=
literal|0xf
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_POW_WORKQUEUE_INT_THRESHOLD
argument_list|(
name|OCTEON_POW_RX_GROUP_NUM
argument_list|)
argument_list|,
name|thr
operator|.
name|word64
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_POW_WORKQUEUE_INT_PC
argument_list|,
name|intpc
operator|.
name|word64
argument_list|)
expr_stmt|;
else|#
directive|else
name|thr
operator|.
name|bits
operator|.
name|ds_thr
operator|=
name|thr
operator|.
name|bits
operator|.
name|iq_thr
operator|=
literal|1
expr_stmt|;
comment|// Only if doing absolute queue-cnt interrupts.
name|oct_write64
argument_list|(
name|OCTEON_POW_WORKQUEUE_INT_THRESHOLD
argument_list|(
name|OCTEON_POW_RX_GROUP_NUM
argument_list|)
argument_list|,
name|thr
operator|.
name|word64
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ciu_enable_interrupts
argument_list|(
name|OCTEON_CORE_ID
argument_list|,
name|OCTEON_RGMX_CIU_INTX
argument_list|,
name|OCTEON_RGMX_CIU_ENX
argument_list|,
operator|(
name|OCTEON_POW_RX_GROUP_MASK
operator||
name|CIU_GENTIMER_BITS_ENABLE
argument_list|(
name|CIU_GENTIMER_NUM_1
argument_list|)
operator|)
argument_list|,
name|CIU_MIPS_IP2
argument_list|)
expr_stmt|;
name|ciu_clear_int_summary
argument_list|(
name|CIU_THIS_CORE
argument_list|,
name|OCTEON_RGMX_CIU_INTX
argument_list|,
name|OCTEON_RGMX_CIU_ENX
argument_list|,
name|CIU_GENTIMER_BITS_ENABLE
argument_list|(
name|CIU_GENTIMER_NUM_1
argument_list|)
argument_list|)
expr_stmt|;
name|octeon_ciu_start_gtimer
argument_list|(
name|CIU_GENTIMER_NUM_1
argument_list|,
name|OCTEON_GENTIMER_PERIODIC
argument_list|,
name|OCTEON_GENTIMER_LEN_1SEC
argument_list|)
expr_stmt|;
comment|/*          * Enable IPD          */
name|octeon_ipd_enable
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|octeon_rgmx_config_pip
parameter_list|(
name|u_int
name|port
parameter_list|)
block|{
name|octeon_pip_gbl_cfg_t
name|pip_config
decl_stmt|;
name|octeon_pip_port_cfg_t
name|pip_port_config
decl_stmt|;
name|octeon_pip_port_tag_cfg_t
name|pip_tag_config
decl_stmt|;
comment|/*      * PIP Global config      */
name|pip_config
operator|.
name|word64
operator|=
literal|0
expr_stmt|;
name|pip_config
operator|.
name|bits
operator|.
name|max_l2
operator|=
literal|1
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_PIP_GBL_CFG
argument_list|,
name|pip_config
operator|.
name|word64
argument_list|)
expr_stmt|;
comment|/*      * PIP Port config      */
name|pip_port_config
operator|.
name|word64
operator|=
literal|0
expr_stmt|;
name|pip_port_config
operator|.
name|bits
operator|.
name|mode
operator|=
name|OCTEON_PIP_PORT_CFG_MODE_SKIPL2
expr_stmt|;
name|pip_port_config
operator|.
name|bits
operator|.
name|qos
operator|=
name|port
operator|&
literal|0x7
expr_stmt|;
name|pip_port_config
operator|.
name|bits
operator|.
name|crc_en
operator|=
literal|1
expr_stmt|;
comment|/*      * PIP -> POW tags config      *      * We don't use any pkt input fields for tag hash, except for Port#      */
name|pip_tag_config
operator|.
name|word64
operator|=
literal|0
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|grptag
operator|=
literal|0
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|grptagmask
operator|=
literal|0xf
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|grptagbase
operator|=
literal|1
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|ip6_src_flag
operator|=
literal|0
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|ip6_dst_flag
operator|=
literal|0
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|ip6_sprt_flag
operator|=
literal|0
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|ip6_dprt_flag
operator|=
literal|0
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|ip6_nxth_flag
operator|=
literal|0
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|ip4_src_flag
operator|=
literal|1
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|ip4_dst_flag
operator|=
literal|1
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|ip4_sprt_flag
operator|=
literal|1
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|ip4_dprt_flag
operator|=
literal|1
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|ip4_pctl_flag
operator|=
literal|1
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|tcp6_tag_type
operator|=
literal|0
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|tcp4_tag_type
operator|=
literal|0
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|ip6_tag_type
operator|=
literal|0
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|ip4_tag_type
operator|=
literal|0
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|inc_prt_flag
operator|=
literal|1
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|non_tag_type
operator|=
name|OCTEON_POW_TAG_TYPE_NULL
expr_stmt|;
name|pip_tag_config
operator|.
name|bits
operator|.
name|grp
operator|=
name|OCTEON_POW_RX_GROUP_NUM
expr_stmt|;
name|octeon_pip_config_port
argument_list|(
name|port
argument_list|,
name|pip_port_config
argument_list|,
name|pip_tag_config
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_POW_CORE_GROUP_MASK
argument_list|(
name|OUR_CORE
argument_list|)
argument_list|,
name|OCTEON_POW_ALL_GROUPS_MASK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * octeon_rgmx_stop_port  *  */
end_comment

begin_function
specifier|static
name|u_int
name|octeon_rgmx_stop_port
parameter_list|(
name|u_int
name|port
parameter_list|)
block|{
name|int
name|interface
init|=
name|INTERFACE
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|INDEX
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|octeon_rgmx_prtx_cfg_t
name|gmx_cfg
decl_stmt|;
name|u_int
name|last_enabled
init|=
literal|0
decl_stmt|;
name|gmx_cfg
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_RGMX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|last_enabled
operator|=
operator|(
name|gmx_cfg
operator|.
name|bits
operator|.
name|en
operator|==
literal|1
operator|)
expr_stmt|;
name|gmx_cfg
operator|.
name|bits
operator|.
name|en
operator|=
literal|0
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|word64
argument_list|)
expr_stmt|;
return|return
operator|(
name|last_enabled
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|octeon_rgmx_start_port
parameter_list|(
name|u_int
name|port
parameter_list|)
block|{
name|int
name|interface
init|=
name|INTERFACE
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|INDEX
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|octeon_rgmx_prtx_cfg_t
name|gmx_cfg
decl_stmt|;
name|gmx_cfg
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_RGMX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_cfg
operator|.
name|bits
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|word64
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|octeon_rgmx_stop
parameter_list|(
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
parameter_list|)
block|{
name|octeon_rgmx_stop_port
argument_list|(
name|sc
operator|->
name|port
argument_list|)
expr_stmt|;
comment|/* Reset transmitter variables and interface flags.  */
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_OACTIVE
operator||
name|IFF_DRV_RUNNING
operator|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_sched
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change the media selection.  */
end_comment

begin_function
specifier|static
name|int
name|octeon_rgmx_medchange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* If_media should not pass any request for a media which this            interface doesn't support.  */
name|int
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|bit2media
index|[
name|b
index|]
operator|!=
literal|0
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|bit2media
index|[
name|b
index|]
operator|==
name|sc
operator|->
name|media
operator|.
name|ifm_media
condition|)
break|break;
block|}
if|if
condition|(
operator|(
operator|(
literal|1
operator|<<
name|b
operator|)
operator|&
name|sc
operator|->
name|mbitmap
operator|)
operator|==
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"got an unsupported media request (0x%x)\n"
argument_list|,
name|sc
operator|->
name|media
operator|.
name|ifm_media
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
endif|#
directive|endif
comment|/* We don't actually change media when the interface is down.            fe_init() will do the job, instead.  Should we also wait            until the transmission buffer being empty?  Changing the            media when we are sending a frame will cause two garbages            on wires, one on old media and another on new.  FIXME */
if|if
condition|(
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|printf
argument_list|(
literal|" Media change requested while IF is up\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" Media change requested while IF is Down\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|octeon_rgmx_medstat
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifm
parameter_list|)
block|{
comment|/*      * No support for Media Status callback      */
block|}
end_function

begin_function
specifier|static
name|int
name|octeon_rgmx_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
block|{
name|printf
argument_list|(
literal|" octeon_rgmx_ioctl. No sc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
comment|/*                      * Switch interface state between "running" and                      * "stopped", reflecting the UP flag.                      */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/*                          * New state is IFF_UP                          * Restart or Start now, if driver is not running currently.                          */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" SIOCSTIFFLAGS  UP/Not-running\n"
argument_list|)
expr_stmt|;
break|break;
name|octeon_rgmx_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" SIOCSTIFFLAGS  UP/Running\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/*                          * New state is IFF_DOWN.                          * Stop& shut it down now, if driver is running currently.                          */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" SIOCSTIFFLAGS  Down/Running\n"
argument_list|)
expr_stmt|;
break|break;
name|octeon_rgmx_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" SIOCSTIFFLAGS  Down/Not-Running\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
comment|/* Let if_media to handle these commands and to call                        us back.  */
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|mask
decl_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_HWCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_HWCSUM
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * octeon_rgmx_mark_ready  *  * Initialize the rgmx driver for this instance  * Initialize device.  */
end_comment

begin_function
specifier|static
name|void
name|octeon_rgmx_mark_ready
parameter_list|(
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Enable interrupts.  */
comment|/* For RGMX they are already enabled earlier */
comment|/* Enable transmitter and receiver.  */
comment|/* For RGMX they are already enabled earlier */
comment|/* Flush out all HW receive buffers for this interface. */
comment|/* For RGMX, no means to flush an individual port */
comment|/* Set 'running' flag, because we are now running.   */
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* Set the HW Address filter. aka program Mac-addr& Multicast filters */
comment|/* For RGMX this was taken care of via set_mac_addr() */
comment|/* Kick start the output */
comment|/* Hopefully PKO is running and will pick up packets via the timer  or receive loop */
block|}
end_function

begin_function
specifier|static
name|void
name|octeon_rgmx_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
comment|/*      * Called mostly from ifnet interface  ifp->if_init();      * I think we can anchor most of our iniialization here and      * not do it in different places  from driver_attach().      */
comment|/*      * For now, we only mark the interface ready      */
name|octeon_rgmx_mark_ready
argument_list|(
operator|(
expr|struct
name|rgmx_softc_dev
operator|*
operator|)
name|xsc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|octeon_rgmx_config_speed
parameter_list|(
name|u_int
name|port
parameter_list|,
name|u_int
name|report_link
parameter_list|)
block|{
name|int
name|index
init|=
name|INDEX
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|int
name|iface
init|=
name|INTERFACE
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
decl_stmt|;
name|octeon_rgmx_rxx_rx_inbnd_t
name|link_status
decl_stmt|,
name|old_link_status
decl_stmt|;
name|octeon_rgmx_prtx_cfg_t
name|gmx_cfg
decl_stmt|;
name|uint64_t
name|val64_tx_clk
decl_stmt|,
name|val64_tx_slot
decl_stmt|,
name|val64_tx_burst
decl_stmt|;
name|u_int
name|last_enabled
decl_stmt|;
name|sc
operator|=
name|get_rgmx_softc
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
block|{
name|printf
argument_list|(
literal|" config_speed didn't find sc int:%u port:%u"
argument_list|,
name|iface
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*          * Look up interface-port speed params          */
name|link_status
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_RGMX_RXX_RX_INBND
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|)
expr_stmt|;
comment|/*          * Compre to prev known state. If same then nothing to do.          */
if|if
condition|(
name|link_status
operator|.
name|word64
operator|==
name|sc
operator|->
name|link_status
condition|)
block|{
return|return;
block|}
name|RGMX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|old_link_status
operator|.
name|word64
operator|=
name|sc
operator|->
name|link_status
expr_stmt|;
name|sc
operator|->
name|link_status
operator|=
name|link_status
operator|.
name|word64
expr_stmt|;
name|last_enabled
operator|=
name|octeon_rgmx_stop_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|gmx_cfg
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_RGMX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|)
expr_stmt|;
comment|/*          * Duplex          */
name|gmx_cfg
operator|.
name|bits
operator|.
name|duplex
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|link_status
operator|.
name|bits
operator|.
name|speed
condition|)
block|{
case|case
literal|0
case|:
comment|/* 10Mbps */
name|gmx_cfg
operator|.
name|bits
operator|.
name|speed
operator|=
literal|0
expr_stmt|;
name|gmx_cfg
operator|.
name|bits
operator|.
name|slottime
operator|=
literal|0
expr_stmt|;
name|val64_tx_clk
operator|=
literal|50
expr_stmt|;
name|val64_tx_slot
operator|=
literal|0x40
expr_stmt|;
name|val64_tx_burst
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 100Mbps */
name|gmx_cfg
operator|.
name|bits
operator|.
name|speed
operator|=
literal|0
expr_stmt|;
name|gmx_cfg
operator|.
name|bits
operator|.
name|slottime
operator|=
literal|0
expr_stmt|;
name|val64_tx_clk
operator|=
literal|5
expr_stmt|;
name|val64_tx_slot
operator|=
literal|0x40
expr_stmt|;
name|val64_tx_burst
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 1Gbps */
name|gmx_cfg
operator|.
name|bits
operator|.
name|speed
operator|=
literal|1
expr_stmt|;
name|gmx_cfg
operator|.
name|bits
operator|.
name|slottime
operator|=
literal|1
expr_stmt|;
name|val64_tx_clk
operator|=
literal|1
expr_stmt|;
name|val64_tx_slot
operator|=
literal|0x200
expr_stmt|;
name|val64_tx_burst
operator|=
literal|0x2000
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* ?? */
default|default:
name|gmx_cfg
operator|.
name|bits
operator|.
name|speed
operator|=
literal|1
expr_stmt|;
name|gmx_cfg
operator|.
name|bits
operator|.
name|slottime
operator|=
literal|1
expr_stmt|;
name|val64_tx_clk
operator|=
literal|1
expr_stmt|;
name|val64_tx_slot
operator|=
literal|0x200
expr_stmt|;
name|val64_tx_burst
operator|=
literal|0x2000
expr_stmt|;
break|break;
block|}
name|oct_write64
argument_list|(
name|OCTEON_RGMX_TXX_CLK
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
name|val64_tx_clk
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_TXX_SLOT
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
name|val64_tx_slot
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_TXX_BURST
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
name|val64_tx_burst
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|word64
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_enabled
condition|)
name|octeon_rgmx_start_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_status
operator|.
name|bits
operator|.
name|status
operator|!=
name|old_link_status
operator|.
name|bits
operator|.
name|status
condition|)
block|{
comment|//#define DEBUG_LINESTATUS
if|if
condition|(
name|link_status
operator|.
name|bits
operator|.
name|status
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_LINESTATUS
name|printf
argument_list|(
literal|" %u/%u: Interface is now alive\n"
argument_list|,
name|iface
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|report_link
condition|)
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG_LINESTATUS
name|printf
argument_list|(
literal|" %u/%u: Interface went down\n"
argument_list|,
name|iface
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|report_link
condition|)
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
block|}
name|RGMX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_RGMX_DUMP
end_ifdef

begin_function
specifier|static
name|void
name|octeon_dump_rgmx_stats
parameter_list|(
name|u_int
name|port
parameter_list|)
block|{  }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__not_used__
end_ifdef

begin_function
specifier|static
name|void
name|rgmx_timer_periodic
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|port
decl_stmt|;
name|int
name|index
decl_stmt|;
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|OCTEON_RGMX_NUM_PORTS_MAX
condition|;
name|index
operator|++
control|)
block|{
name|port
operator|=
name|port_array
index|[
name|index
index|]
expr_stmt|;
name|sc
operator|=
name|rgmx_scdev_array
index|[
name|index
index|]
expr_stmt|;
comment|/*                  * Skip over ports/slots not in service.                  */
if|if
condition|(
operator|(
name|port
operator|<
name|OCTEON_RGMX_MIN_PORT
operator|)
operator|||
operator|(
name|port
operator|>
name|OCTEON_RGMX_MAX_PORT
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|NULL
operator|==
name|sc
operator|)
operator|||
operator|(
operator|(
operator|(
expr|struct
name|rgmx_softc_dev
operator|*
operator|)
operator|-
literal|1
operator|)
operator|==
name|sc
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/*                  * Now look for anamolous conditions                  */
if|if
condition|(
name|sc
operator|!=
name|get_rgmx_softc
argument_list|(
name|port
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" port %u  sc %p not in sync with index: %u\n"
argument_list|,
name|port
argument_list|,
name|sc
argument_list|,
name|index
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sc
operator|->
name|port
operator|!=
name|port
condition|)
block|{
name|printf
argument_list|(
literal|" port %u  sc %p port-> %u  not in sync with index: %u\n"
argument_list|,
name|port
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|port
argument_list|,
name|index
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|" port %u  sc %p . Bad ifp %p\n"
argument_list|,
name|port
argument_list|,
name|sc
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*                  * Check if packets queued at ifnet layer. Kick start output if we can.                  */
if|if
condition|(
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|octeon_rgmx_output_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|octeon_rgmx_output_flush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/*                  * Check if line status changed ?  Adjust ourselves.                  */
name|octeon_rgmx_config_speed
argument_list|(
name|port
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_RGMX_DUMP
end_ifdef

begin_function
specifier|static
name|void
name|octeon_dump_pow_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|octeon_rgmx_pow_nos_cnt
name|nos_cnt
decl_stmt|;
name|octeon_rgmx_pow_int_pc_t
name|intpc
decl_stmt|;
name|octeon_rgmx_pow_int_threshold_t
name|thr
decl_stmt|;
name|octeon_rgmx_pow_int_cnt_t
name|int_cnt
decl_stmt|;
name|int
name|core
init|=
name|octeon_get_core_num
argument_list|()
decl_stmt|;
name|octeon_pow_inpt_q_all_qos
name|inpt_q_all
decl_stmt|;
name|octeon_pow_inpt_q_grp_qos
name|inpt_q_grp
decl_stmt|;
name|octeon_rgmx_pip_inb_pkts
name|pkts
decl_stmt|;
name|octeon_rgmx_pip_inb_errs
name|errs
decl_stmt|;
specifier|static
name|u_int
name|pkts0
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|pkts1
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|errs0
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|errs1
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|nos_cnt
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_RGMX_POW_NOS_CNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nos_cnt
operator|.
name|bits
operator|.
name|nos_cnt
condition|)
name|printf
argument_list|(
literal|" *** No sched cnt %u\n"
argument_list|,
name|nos_cnt
operator|.
name|bits
operator|.
name|nos_cnt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" \nGroup mask: 0x%llX     WorkQueue Int :    0x%llX\n"
argument_list|,
name|oct_read64
argument_list|(
name|OCTEON_POW_CORE_GROUP_MASK
argument_list|(
name|OUR_CORE
argument_list|)
argument_list|)
argument_list|,
name|oct_read64
argument_list|(
name|OCTEON_POW_WORKQUEUE_INT
argument_list|)
argument_list|)
expr_stmt|;
name|intpc
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_POW_WORKQUEUE_INT_PC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Intr Periodic Cntr: PC %u  thr:  %u\n"
argument_list|,
name|intpc
operator|.
name|bits
operator|.
name|thr_freq
argument_list|,
name|intpc
operator|.
name|bits
operator|.
name|thr_period
argument_list|)
expr_stmt|;
name|thr
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_POW_WORKQUEUE_INT_THRESHOLD
argument_list|(
name|OCTEON_POW_RX_GROUP_NUM
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Thresholds iq %u  ds %u  time %u  enable %u\n"
argument_list|,
name|thr
operator|.
name|bits
operator|.
name|iq_thr
argument_list|,
name|thr
operator|.
name|bits
operator|.
name|ds_thr
argument_list|,
name|thr
operator|.
name|bits
operator|.
name|time_thr
argument_list|,
name|thr
operator|.
name|bits
operator|.
name|enable
argument_list|)
expr_stmt|;
name|int_cnt
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_POW_INT_CNTR
argument_list|(
name|core
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Int_cnt  iq_cnt %u  ds_cnt %u  tc_cnt %u\n"
argument_list|,
name|int_cnt
operator|.
name|bits
operator|.
name|iq_cnt
argument_list|,
name|int_cnt
operator|.
name|bits
operator|.
name|ds_cnt
argument_list|,
name|int_cnt
operator|.
name|bits
operator|.
name|tc_cnt
argument_list|)
expr_stmt|;
name|pkts
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_PIP_STAT_INB_PKTS
argument_list|(
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|pkts0
operator|+=
name|pkts
operator|.
name|bits
operator|.
name|inb_pkts
expr_stmt|;
name|errs
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_PIP_STAT_INB_ERRS
argument_list|(
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|errs0
operator|+=
name|errs
operator|.
name|bits
operator|.
name|inb_errs
expr_stmt|;
name|pkts
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_PIP_STAT_INB_PKTS
argument_list|(
literal|17
argument_list|)
argument_list|)
expr_stmt|;
name|pkts1
operator|+=
name|pkts
operator|.
name|bits
operator|.
name|inb_pkts
expr_stmt|;
name|errs
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_PIP_STAT_INB_ERRS
argument_list|(
literal|17
argument_list|)
argument_list|)
expr_stmt|;
name|errs1
operator|+=
name|errs
operator|.
name|bits
operator|.
name|inb_errs
expr_stmt|;
name|printf
argument_list|(
literal|" PIP inbound pkts(16): %u   Errors: %u    inbound(17): %u   Errors: %u\n"
argument_list|,
name|pkts0
argument_list|,
name|errs0
argument_list|,
name|pkts1
argument_list|,
name|errs1
argument_list|)
expr_stmt|;
name|inpt_q_all
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_POW_INPT_Q_ALL_QOS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" All queued pkt in qos Levels: %u -- "
argument_list|,
name|inpt_q_all
operator|.
name|bits
operator|.
name|iq_cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|inpt_q_grp
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_POW_INPT_QOS_GRP
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inpt_q_grp
operator|.
name|bits
operator|.
name|iq_cnt
condition|)
name|printf
argument_list|(
literal|" Grp-%u:  %u "
argument_list|,
name|i
argument_list|,
name|inpt_q_grp
operator|.
name|bits
operator|.
name|iq_cnt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------- *  *                      octeon_line_status_loop()                      *  * ------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|octeon_line_status_loop
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|num_devices
condition|;
name|idx
operator|++
control|)
block|{
name|sc
operator|=
name|rgmx_scdev_array
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|&&
name|sc
operator|->
name|ifp
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|octeon_rgmx_config_speed
argument_list|(
name|sc
operator|->
name|port
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|octeon_rgmx_output_start
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//#define DEBUG_RGMX_DUMP
ifdef|#
directive|ifdef
name|DEBUG_RGMX_DUMP
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|++
name|count
operator|>
literal|5
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
comment|//                    octeon_dump_fpa_pool(OCTEON_FPA_RX_PACKET_POOL);
comment|//                    octeon_dump_fpa_pool(OCTEON_FPA_WQE_RX_POOL);
comment|//                    octeon_dump_fpa_pool(OCTEON_FPA_TX_PACKET_POOL);
name|octeon_dump_rgmx_stats
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|octeon_dump_pow_stats
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------- *  *                      octeon_rgmx_set_mac	                       *  * ------------------------------------------------------------------- *  *  * octeon_rgmx_set_mac  *  * Program the ethernet HW address  *  */
end_comment

begin_function
specifier|static
name|void
name|octeon_rgmx_set_mac
parameter_list|(
name|u_int
name|port
parameter_list|)
block|{
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
decl_stmt|;
name|u_int
name|iface
init|=
name|INTERFACE
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|u_int
name|index
init|=
name|INDEX
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|int
name|ii
decl_stmt|;
name|uint64_t
name|mac
init|=
literal|0
decl_stmt|;
name|u_int
name|last_enabled
decl_stmt|;
name|sc
operator|=
name|get_rgmx_softc
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
block|{
name|printf
argument_list|(
literal|" octeon_rgmx_set_mac Missing sc.  port:%u"
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|6
condition|;
name|ii
operator|++
control|)
block|{
name|mac
operator|=
operator|(
name|mac
operator|<<
literal|8
operator|)
operator||
call|(
name|uint64_t
call|)
argument_list|(
name|sc
operator|->
name|ieee
index|[
name|ii
index|]
argument_list|)
expr_stmt|;
block|}
name|last_enabled
operator|=
name|octeon_rgmx_stop_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_SMACX
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_RXX_ADR_CAM0
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
name|sc
operator|->
name|ieee
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_RXX_ADR_CAM1
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
name|sc
operator|->
name|ieee
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_RXX_ADR_CAM2
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
name|sc
operator|->
name|ieee
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_RXX_ADR_CAM3
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
name|sc
operator|->
name|ieee
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_RXX_ADR_CAM4
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
name|sc
operator|->
name|ieee
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_RXX_ADR_CAM5
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
name|sc
operator|->
name|ieee
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_RXX_ADR_CTL
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
name|OCTEON_RGMX_ADRCTL_ACCEPT_BROADCAST
operator||
name|OCTEON_RGMX_ADRCTL_ACCEPT_ALL_MULTICAST
operator||
name|OCTEON_RGMX_ADRCTL_CAM_MODE_ACCEPT_DMAC
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_RXX_ADR_CAM_EN
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_enabled
condition|)
name|octeon_rgmx_start_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------- *  *                      octeon_config_rgmii_port()                     *  * ------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|octeon_config_rgmii_port
parameter_list|(
name|u_int
name|port
parameter_list|)
block|{
name|u_int
name|iface
init|=
name|INTERFACE
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|u_int
name|index
init|=
name|INDEX
argument_list|(
name|port
argument_list|)
decl_stmt|;
comment|/*  	 * Configure an RGMII port 	 */
name|octeon_rgmx_prtx_cfg_t
name|gmx_cfg
decl_stmt|;
comment|/* Enable ASX */
name|oct_write64
argument_list|(
name|OCTEON_ASXX_RX_PRT_EN
argument_list|(
name|iface
argument_list|)
argument_list|,
name|oct_read64
argument_list|(
name|OCTEON_ASXX_RX_PRT_EN
argument_list|(
name|iface
argument_list|)
argument_list|)
operator||
operator|(
literal|1
operator|<<
name|index
operator|)
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_ASXX_TX_PRT_EN
argument_list|(
name|iface
argument_list|)
argument_list|,
name|oct_read64
argument_list|(
name|OCTEON_ASXX_TX_PRT_EN
argument_list|(
name|iface
argument_list|)
argument_list|)
operator||
operator|(
literal|1
operator|<<
name|index
operator|)
argument_list|)
expr_stmt|;
comment|/* Enable RGMX */
name|gmx_cfg
operator|.
name|word64
operator|=
name|oct_read64
argument_list|(
name|OCTEON_RGMX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_cfg
operator|.
name|bits
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|word64
argument_list|)
expr_stmt|;
name|octeon_rgmx_config_speed
argument_list|(
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_RGMX_TXX_THRESH
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/*          * Set hi water mark          */
name|oct_write64
argument_list|(
name|OCTEON_ASXX_TX_HI_WATERX
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|octeon_get_chipid
argument_list|()
operator|==
name|OCTEON_CN5020_CHIP
condition|)
block|{
name|oct_write64
argument_list|(
name|OCTEON_ASXX_TX_CLK_SETX
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_ASXX_RX_CLK_SETX
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oct_write64
argument_list|(
name|OCTEON_ASXX_TX_CLK_SETX
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_ASXX_RX_CLK_SETX
argument_list|(
name|index
argument_list|,
name|iface
argument_list|)
argument_list|,
literal|24
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|octeon_rgmx_enable_RED_queue
parameter_list|(
name|int
name|queue
parameter_list|,
name|int
name|slow_drop
parameter_list|,
name|int
name|all_drop
parameter_list|)
block|{
name|octeon_rgmx_ipd_queue_red_marks_t
name|red_marks
decl_stmt|;
name|octeon_rgmx_ipd_red_q_param_t
name|red_param
decl_stmt|;
if|if
condition|(
name|slow_drop
operator|==
name|all_drop
condition|)
block|{
name|printf
argument_list|(
literal|"Bad val in %s"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return;
block|}
name|red_marks
operator|.
name|word64
operator|=
literal|0
expr_stmt|;
name|red_marks
operator|.
name|bits
operator|.
name|all_drop
operator|=
name|all_drop
expr_stmt|;
name|red_marks
operator|.
name|bits
operator|.
name|slow_drop
operator|=
name|slow_drop
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_IPD_QOSX_RED_MARKS
argument_list|(
name|queue
argument_list|)
argument_list|,
name|red_marks
operator|.
name|word64
argument_list|)
expr_stmt|;
comment|/* Use the actual queue 0 counter, not the average */
name|red_param
operator|.
name|word64
operator|=
literal|0
expr_stmt|;
name|red_param
operator|.
name|bits
operator|.
name|prb_con
operator|=
operator|(
literal|255ul
operator|<<
literal|24
operator|)
operator|/
operator|(
name|slow_drop
operator|-
name|all_drop
operator|)
expr_stmt|;
name|red_param
operator|.
name|bits
operator|.
name|avg_con
operator|=
literal|1
expr_stmt|;
name|red_param
operator|.
name|bits
operator|.
name|new_con
operator|=
literal|255
expr_stmt|;
name|red_param
operator|.
name|bits
operator|.
name|use_pagecount
operator|=
literal|1
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_IPD_RED_Q_PARAM
argument_list|(
name|queue
argument_list|)
argument_list|,
name|red_param
operator|.
name|word64
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|octeon_rgmx_enable_RED_all
parameter_list|(
name|int
name|slow_drop
parameter_list|,
name|int
name|all_drop
parameter_list|)
block|{
name|int
name|port
decl_stmt|,
name|queue
decl_stmt|;
name|octeon_ipd_port_bp_page_count_t
name|ipd_bp_page_count
decl_stmt|;
name|octeon_ipd_red_port_enable_t
name|red_port_enable
decl_stmt|;
comment|/*      * First remove BP settings      */
name|ipd_bp_page_count
operator|.
name|word64
operator|=
literal|0
expr_stmt|;
name|ipd_bp_page_count
operator|.
name|bits
operator|.
name|bp_enable
operator|=
literal|0
expr_stmt|;
name|ipd_bp_page_count
operator|.
name|bits
operator|.
name|page_count
operator|=
literal|100
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|OCTEON_RGMX_MAX_PORT
condition|;
name|port
operator|++
control|)
block|{
name|oct_write64
argument_list|(
name|OCTEON_IPD_PORT_BP_PAGE_COUNT
argument_list|(
name|port
argument_list|)
argument_list|,
name|ipd_bp_page_count
operator|.
name|word64
argument_list|)
expr_stmt|;
block|}
comment|/*      * Enable RED for each individual queue      */
for|for
control|(
name|queue
operator|=
literal|0
init|;
name|queue
operator|<
literal|8
condition|;
name|queue
operator|++
control|)
block|{
name|octeon_rgmx_enable_RED_queue
argument_list|(
name|queue
argument_list|,
name|slow_drop
argument_list|,
name|all_drop
argument_list|)
expr_stmt|;
block|}
name|oct_write64
argument_list|(
name|OCTEON_IPD_BP_PORT_RED_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|red_port_enable
operator|.
name|word64
operator|=
literal|0
expr_stmt|;
name|red_port_enable
operator|.
name|bits
operator|.
name|port_enable
operator|=
literal|0xfffffffffull
expr_stmt|;
name|red_port_enable
operator|.
name|bits
operator|.
name|avg_dly
operator|=
literal|10000
expr_stmt|;
name|red_port_enable
operator|.
name|bits
operator|.
name|prb_dly
operator|=
literal|10000
expr_stmt|;
name|oct_write64
argument_list|(
name|OCTEON_IPD_RED_PORT_ENABLE
argument_list|,
name|red_port_enable
operator|.
name|word64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------- *  *                    octeon_has_4ports()                                 *  * ------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int
name|octeon_has_4ports
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|chipid
decl_stmt|;
name|int
name|retcode
init|=
literal|1
decl_stmt|;
name|chipid
operator|=
name|octeon_get_chipid
argument_list|()
operator|&
literal|0xffffff00
expr_stmt|;
switch|switch
condition|(
name|chipid
condition|)
block|{
case|case
name|OCTEON_CN31XX_CHIP
case|:
case|case
name|OCTEON_CN30XX_CHIP
case|:
case|case
name|OCTEON_CN5020_CHIP
case|:
name|retcode
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__not_used__
end_ifdef

begin_comment
comment|/*  * octeon_rgmx_free_intr  *  * We have 4 child and one parent device.  * It's tricky and unexpected that anyone will detach the device that is built'in on  * the chip.  * We will not support  detachment for now. But keep adding good code that will be used  * someday.  */
end_comment

begin_function
specifier|static
name|void
name|octeon_rgmx_free_intr
parameter_list|(
name|struct
name|rgmx_softc_dev
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|sc
operator|->
name|sc_dev
decl_stmt|;
comment|/*          * Make sure that sc/dev  are the parent Root structs. Not one          * of the rgmxN childs.          */
if|if
condition|(
name|int_handler_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|irq_res
argument_list|,
name|int_handler_tag
argument_list|)
expr_stmt|;
name|int_handler_tag
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OCTEON_RGMX_SCHEDULED_ISRS
if|if
condition|(
name|tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|tq
argument_list|,
operator|&
name|rxtx_isr_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_fast
argument_list|,
operator|&
name|link_isr_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|tq
argument_list|)
expr_stmt|;
name|tq
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|device_method_t
name|rgmii_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|rgmii_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|rgmii_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|rgmii_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|rgmii_driver
init|=
block|{
literal|"rgmii"
block|,
name|rgmii_methods
block|,
expr|sizeof
operator|(
expr|struct
name|rgmx_softc_dev
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|rgmii_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|rgmii
argument_list|,
name|nexus
argument_list|,
name|rgmii_driver
argument_list|,
name|rgmii_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

