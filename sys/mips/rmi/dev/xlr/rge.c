begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2009 RMI Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of RMI Corporation, nor the names of its contributors,  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * RMI_BSD  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_define
define|#
directive|define
name|__RMAN_RESOURCE_VISIBLE
end_define

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/mips_opcode.h>
end_include

begin_include
include|#
directive|include
file|<machine/asm.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/rmi_mips_exts.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpuregs.h>
end_include

begin_include
include|#
directive|include
file|<machine/param.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_include
include|#
directive|include
file|<machine/cpuregs.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* */
end_comment

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/brgphyreg.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/msgring.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/iomap.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/pic.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/rmi_mips_exts.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/rmi_boot_info.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/board.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/dev/xlr/debug.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/dev/xlr/atx_cpld.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/dev/xlr/xgmac_mdio.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/dev/xlr/rge.h>
end_include

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|rge
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|rge
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* #define DEBUG */
end_comment

begin_define
define|#
directive|define
name|RGE_TX_THRESHOLD
value|1024
end_define

begin_define
define|#
directive|define
name|RGE_TX_Q_SIZE
value|1024
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_undef
undef|#
directive|undef
name|dbg_msg
end_undef

begin_decl_stmt
name|int
name|mac_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|dbg_msg
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|do {\             if (mac_debug) {\                 printf("[%s@%d|%s]: cpu_%d: " fmt, \                 __FILE__, __LINE__, __FUNCTION__,  xlr_cpu_id(), ##args);\             }\         } while(0);
end_define

begin_define
define|#
directive|define
name|DUMP_PACKETS
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|dbg_msg
end_undef

begin_define
define|#
directive|define
name|dbg_msg
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_decl_stmt
name|int
name|mac_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAC_B2B_IPG
value|88
end_define

begin_comment
comment|/* frame sizes need to be cacheline aligned */
end_comment

begin_define
define|#
directive|define
name|MAX_FRAME_SIZE
value|1536
end_define

begin_define
define|#
directive|define
name|MAX_FRAME_SIZE_JUMBO
value|9216
end_define

begin_define
define|#
directive|define
name|MAC_SKB_BACK_PTR_SIZE
value|SMP_CACHE_BYTES
end_define

begin_define
define|#
directive|define
name|MAC_PREPAD
value|0
end_define

begin_define
define|#
directive|define
name|BYTE_OFFSET
value|2
end_define

begin_define
define|#
directive|define
name|XLR_RX_BUF_SIZE
value|(MAX_FRAME_SIZE+BYTE_OFFSET+MAC_PREPAD+MAC_SKB_BACK_PTR_SIZE+SMP_CACHE_BYTES)
end_define

begin_define
define|#
directive|define
name|MAC_CRC_LEN
value|4
end_define

begin_define
define|#
directive|define
name|MAX_NUM_MSGRNG_STN_CC
value|128
end_define

begin_define
define|#
directive|define
name|MAX_NUM_DESC
value|1024
end_define

begin_define
define|#
directive|define
name|MAX_SPILL_SIZE
value|(MAX_NUM_DESC + 128)
end_define

begin_define
define|#
directive|define
name|MAC_FRIN_TO_BE_SENT_THRESHOLD
value|16
end_define

begin_define
define|#
directive|define
name|MAX_FRIN_SPILL
value|(MAX_SPILL_SIZE<< 2)
end_define

begin_define
define|#
directive|define
name|MAX_FROUT_SPILL
value|(MAX_SPILL_SIZE<< 2)
end_define

begin_define
define|#
directive|define
name|MAX_CLASS_0_SPILL
value|(MAX_SPILL_SIZE<< 2)
end_define

begin_define
define|#
directive|define
name|MAX_CLASS_1_SPILL
value|(MAX_SPILL_SIZE<< 2)
end_define

begin_define
define|#
directive|define
name|MAX_CLASS_2_SPILL
value|(MAX_SPILL_SIZE<< 2)
end_define

begin_define
define|#
directive|define
name|MAX_CLASS_3_SPILL
value|(MAX_SPILL_SIZE<< 2)
end_define

begin_comment
comment|/*****************************************************************  * Phoenix Generic Mac driver  *****************************************************************/
end_comment

begin_decl_stmt
specifier|extern
name|uint32_t
name|cpu_ltop_map
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLED_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|int
name|port_counters
index|[
literal|4
index|]
index|[
literal|8
index|]
name|__aligned
parameter_list|(
name|XLR_CACHELINE_SIZE
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|port_inc_counter
parameter_list|(
name|port
parameter_list|,
name|counter
parameter_list|)
value|atomic_add_int(&port_counters[port][(counter)], 1)
end_define

begin_define
define|#
directive|define
name|port_set_counter
parameter_list|(
name|port
parameter_list|,
name|counter
parameter_list|,
name|value
parameter_list|)
value|atomic_store_int(&port_counters[port][(counter)], (value))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|port_inc_counter
parameter_list|(
name|port
parameter_list|,
name|counter
parameter_list|)
end_define

begin_comment
comment|/* Nothing */
end_comment

begin_define
define|#
directive|define
name|port_set_counter
parameter_list|(
name|port
parameter_list|,
name|counter
parameter_list|,
name|value
parameter_list|)
end_define

begin_comment
comment|/* Nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|xlr_rge_tx_prepend
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xlr_rge_tx_done
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xlr_rge_get_p2d_failed
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xlr_rge_msg_snd_failed
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xlr_rge_tx_ok_done
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xlr_rge_rx_done
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xlr_rge_repl_done
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #define mac_stats_add(x, val) ({(x) += (val);}) */
end_comment

begin_define
define|#
directive|define
name|mac_stats_add
parameter_list|(
name|x
parameter_list|,
name|val
parameter_list|)
value|xlr_ldaddwu(val,&x)
end_define

begin_define
define|#
directive|define
name|XLR_MAX_CORE
value|8
end_define

begin_define
define|#
directive|define
name|RGE_LOCK_INIT
parameter_list|(
name|_sc
parameter_list|,
name|_name
parameter_list|)
define|\
value|mtx_init(&(_sc)->rge_mtx, _name, MTX_NETWORK_LOCK, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|RGE_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->rge_mtx)
end_define

begin_define
define|#
directive|define
name|RGE_LOCK_ASSERT
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&(_sc)->rge_mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|RGE_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->rge_mtx)
end_define

begin_define
define|#
directive|define
name|RGE_LOCK_DESTROY
parameter_list|(
name|_sc
parameter_list|)
value|mtx_destroy(&(_sc)->rge_mtx)
end_define

begin_define
define|#
directive|define
name|XLR_MAX_MACS
value|8
end_define

begin_define
define|#
directive|define
name|XLR_MAX_TX_FRAGS
value|14
end_define

begin_define
define|#
directive|define
name|MAX_P2D_DESC_PER_PORT
value|512
end_define

begin_struct
struct|struct
name|p2d_tx_desc
block|{
name|uint64_t
name|frag
index|[
name|XLR_MAX_TX_FRAGS
operator|+
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_TX_RING_SIZE
value|(XLR_MAX_MACS * MAX_P2D_DESC_PER_PORT * sizeof(struct p2d_tx_desc))
end_define

begin_decl_stmt
name|struct
name|rge_softc
modifier|*
name|dev_mac
index|[
name|XLR_MAX_MACS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dev_mac_xgs0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dev_mac_gmac0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gmac_common_init_done
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|rge_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rge_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rge_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rge_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rge_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rge_release_resources
parameter_list|(
name|struct
name|rge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rge_rx
parameter_list|(
name|struct
name|rge_softc
modifier|*
parameter_list|,
name|vm_paddr_t
name|paddr
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rge_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rge_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rge_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rge_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rge_stop
parameter_list|(
name|struct
name|rge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rge_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rge_reset
parameter_list|(
name|struct
name|rge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|get_mbuf
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_buf
parameter_list|(
name|vm_paddr_t
name|paddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|get_buf
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xlr_mac_get_hwaddr
parameter_list|(
name|struct
name|rge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xlr_mac_setup_hwaddr
parameter_list|(
name|struct
name|driver_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmi_xlr_mac_set_enable
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmi_xlr_xgmac_init
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmi_xlr_gmac_init
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mac_common_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rge_mii_write
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rge_mii_read
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmi_xlr_mac_mii_statchg
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rmi_xlr_mac_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmi_xlr_mac_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xlr_mac_set_rx_mode
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rmi_xlr_mac_msgring_handler
parameter_list|(
name|int
name|bucket
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|stid
parameter_list|,
name|struct
name|msgrng_msg
modifier|*
name|msg
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mac_frin_replenish
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rmi_xlr_mac_open
parameter_list|(
name|struct
name|rge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rmi_xlr_mac_close
parameter_list|(
name|struct
name|rge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mac_xmit
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|rge_softc
modifier|*
parameter_list|,
name|struct
name|driver_data
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|p2d_tx_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rmi_xlr_mac_xmit
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|rge_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|p2d_tx_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|rge_softc_stats
modifier|*
name|rmi_xlr_mac_get_stats
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmi_xlr_mac_set_multicast_list
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rmi_xlr_mac_change_mtu
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|,
name|int
name|new_mtu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rmi_xlr_mac_fill_rxfr
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmi_xlr_config_spill_area
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rmi_xlr_mac_set_speed
parameter_list|(
name|struct
name|driver_data
modifier|*
name|s
parameter_list|,
name|xlr_mac_speed_t
name|speed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rmi_xlr_mac_set_duplex
parameter_list|(
name|struct
name|driver_data
modifier|*
name|s
parameter_list|,
name|xlr_mac_duplex_t
name|duplex
parameter_list|,
name|xlr_mac_fc_t
name|fc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|serdes_regs_init
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rmi_xlr_gmac_reset
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*Statistics...*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|get_p2d_desc_failed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msg_snd_failed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|get_p2d_failed
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|get_p2d_desc_failed
argument_list|,
literal|0
argument_list|,
literal|"p2d desc failed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|msg_snd_failed
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|msg_snd_failed
argument_list|,
literal|0
argument_list|,
literal|"msg snd failed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|callout
name|xlr_tx_stop_bkp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|rge_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|rge_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|rge_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|rge_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|rge_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|rge_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|rge_resume
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|rge_mii_read
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|rmi_xlr_mac_mii_statchg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|rge_mii_write
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|rge_driver
init|=
block|{
literal|"rge"
block|,
name|rge_methods
block|,
expr|sizeof
operator|(
expr|struct
name|rge_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|rge_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|rge
argument_list|,
name|iodi
argument_list|,
name|rge_driver
argument_list|,
name|rge_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|rge
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__STR
end_ifndef

begin_define
define|#
directive|define
name|__STR
parameter_list|(
name|x
parameter_list|)
value|#x
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STR
end_ifndef

begin_define
define|#
directive|define
name|STR
parameter_list|(
name|x
parameter_list|)
value|__STR(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
modifier|*
name|xlr_tx_ring_mem
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|tx_desc_node
block|{
name|struct
name|p2d_tx_desc
modifier|*
name|ptr
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|tx_desc_node
argument_list|)
name|list
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|XLR_MAX_TX_DESC_NODES
value|(XLR_MAX_MACS * MAX_P2D_DESC_PER_PORT)
end_define

begin_decl_stmt
name|struct
name|tx_desc_node
name|tx_desc_nodes
index|[
name|XLR_MAX_TX_DESC_NODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|xlr_tot_avail_p2d
index|[
name|XLR_MAX_CORE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xlr_total_active_core
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This should contain the list of all free tx frag desc nodes pointing to tx  * p2d arrays  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|tx_desc_node
argument_list|)
name|tx_frag_desc
index|[
name|XLR_MAX_CORE
index|]
operator|=
block|{
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|tx_frag_desc
index|[
literal|0
index|]
argument_list|)
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|tx_frag_desc
index|[
literal|1
index|]
argument_list|)
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|tx_frag_desc
index|[
literal|2
index|]
argument_list|)
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|tx_frag_desc
index|[
literal|3
index|]
argument_list|)
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|tx_frag_desc
index|[
literal|4
index|]
argument_list|)
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|tx_frag_desc
index|[
literal|5
index|]
argument_list|)
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|tx_frag_desc
index|[
literal|6
index|]
argument_list|)
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|tx_frag_desc
index|[
literal|7
index|]
argument_list|)
block|, }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This contains a list of free tx frag node descriptors */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|tx_desc_node
argument_list|)
name|free_tx_frag_desc
index|[
name|XLR_MAX_CORE
index|]
operator|=
block|{
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|free_tx_frag_desc
index|[
literal|0
index|]
argument_list|)
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|free_tx_frag_desc
index|[
literal|1
index|]
argument_list|)
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|free_tx_frag_desc
index|[
literal|2
index|]
argument_list|)
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|free_tx_frag_desc
index|[
literal|3
index|]
argument_list|)
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|free_tx_frag_desc
index|[
literal|4
index|]
argument_list|)
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|free_tx_frag_desc
index|[
literal|5
index|]
argument_list|)
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|free_tx_frag_desc
index|[
literal|6
index|]
argument_list|)
block|,
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|free_tx_frag_desc
index|[
literal|7
index|]
argument_list|)
block|, }
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|tx_desc_lock
index|[
name|XLR_MAX_CORE
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|mac_make_desc_rfr
parameter_list|(
name|struct
name|msgrng_msg
modifier|*
name|msg
parameter_list|,
name|vm_paddr_t
name|addr
parameter_list|)
block|{
name|msg
operator|->
name|msg0
operator|=
operator|(
name|uint64_t
operator|)
name|addr
operator|&
literal|0xffffffffe0ULL
expr_stmt|;
name|msg
operator|->
name|msg1
operator|=
name|msg
operator|->
name|msg2
operator|=
name|msg
operator|->
name|msg3
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAC_TX_DESC_ALIGNMENT
value|(XLR_CACHELINE_SIZE - 1)
end_define

begin_function
specifier|static
name|void
name|init_p2d_allocation
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|active_core
index|[
literal|8
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|uint32_t
name|cpumask
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|cpumask
operator|=
name|xlr_hw_thread_mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cpumask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|cpu
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|active_core
index|[
name|cpu
operator|/
literal|4
index|]
condition|)
block|{
name|active_core
index|[
name|cpu
operator|/
literal|4
index|]
operator|=
literal|1
expr_stmt|;
name|xlr_total_active_core
operator|++
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XLR_MAX_CORE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|active_core
index|[
name|i
index|]
condition|)
name|xlr_tot_avail_p2d
index|[
name|i
index|]
operator|=
name|XLR_MAX_TX_DESC_NODES
operator|/
name|xlr_total_active_core
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Total Active Core %d\n"
argument_list|,
name|xlr_total_active_core
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_tx_ring
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|struct
name|tx_desc_node
modifier|*
name|start
decl_stmt|,
modifier|*
name|node
decl_stmt|;
name|struct
name|p2d_tx_desc
modifier|*
name|tx_desc
decl_stmt|;
name|vm_paddr_t
name|paddr
decl_stmt|;
name|vm_offset_t
name|unmapped_addr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XLR_MAX_CORE
condition|;
name|i
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|tx_desc_lock
index|[
name|i
index|]
argument_list|,
literal|"xlr tx_desc"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|start
operator|=
operator|&
name|tx_desc_nodes
index|[
literal|0
index|]
expr_stmt|;
comment|/* TODO: try to get this from KSEG0 */
name|xlr_tx_ring_mem
operator|=
name|contigmalloc
argument_list|(
operator|(
name|MAX_TX_RING_SIZE
operator|+
name|XLR_CACHELINE_SIZE
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|,
literal|0
argument_list|,
literal|0x10000000
argument_list|,
name|XLR_CACHELINE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlr_tx_ring_mem
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"TX ring memory allocation failed"
argument_list|)
expr_stmt|;
block|}
name|paddr
operator|=
name|vtophys
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|xlr_tx_ring_mem
argument_list|)
expr_stmt|;
name|unmapped_addr
operator|=
name|MIPS_PHYS_TO_KSEG0
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|tx_desc
operator|=
operator|(
expr|struct
name|p2d_tx_desc
operator|*
operator|)
name|unmapped_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XLR_MAX_TX_DESC_NODES
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|start
operator|+
name|i
expr_stmt|;
name|node
operator|->
name|ptr
operator|=
name|tx_desc
expr_stmt|;
name|tx_desc
operator|++
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|tx_frag_desc
index|[
name|j
index|]
argument_list|,
name|node
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|j
operator|=
operator|(
name|i
operator|/
operator|(
name|XLR_MAX_TX_DESC_NODES
operator|/
name|xlr_total_active_core
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|p2d_tx_desc
modifier|*
name|get_p2d_desc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tx_desc_node
modifier|*
name|node
decl_stmt|;
name|struct
name|p2d_tx_desc
modifier|*
name|tx_desc
init|=
name|NULL
decl_stmt|;
name|int
name|cpu
init|=
name|xlr_core_id
argument_list|()
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|tx_desc_lock
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
name|node
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|tx_frag_desc
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|xlr_tot_avail_p2d
index|[
name|cpu
index|]
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|tx_frag_desc
index|[
name|cpu
index|]
argument_list|,
name|node
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|tx_desc
operator|=
name|node
operator|->
name|ptr
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|free_tx_frag_desc
index|[
name|cpu
index|]
argument_list|,
name|node
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Increment p2d desc fail count */
name|get_p2d_desc_failed
operator|++
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|tx_desc_lock
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
return|return
name|tx_desc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_p2d_desc
parameter_list|(
name|struct
name|p2d_tx_desc
modifier|*
name|tx_desc
parameter_list|)
block|{
name|struct
name|tx_desc_node
modifier|*
name|node
decl_stmt|;
name|int
name|cpu
init|=
name|xlr_core_id
argument_list|()
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|tx_desc_lock
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
name|node
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_tx_frag_desc
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|node
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"Free TX frag node list is empty\n"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_tx_frag_desc
index|[
name|cpu
index|]
argument_list|,
name|node
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|node
operator|->
name|ptr
operator|=
name|tx_desc
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|tx_frag_desc
index|[
name|cpu
index|]
argument_list|,
name|node
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|xlr_tot_avail_p2d
index|[
name|cpu
index|]
operator|++
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|tx_desc_lock
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|build_frag_list
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|,
name|struct
name|msgrng_msg
modifier|*
name|p2p_msg
parameter_list|,
name|struct
name|p2d_tx_desc
modifier|*
name|tx_desc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|vm_paddr_t
name|paddr
decl_stmt|;
name|uint64_t
name|p2d_len
decl_stmt|;
name|int
name|nfrag
decl_stmt|;
name|vm_paddr_t
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|uint32_t
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|vm_offset_t
name|taddr
decl_stmt|;
name|uint64_t
name|fr_stid
decl_stmt|;
name|fr_stid
operator|=
operator|(
name|xlr_core_id
argument_list|()
operator|<<
literal|3
operator|)
operator|+
name|xlr_thr_id
argument_list|()
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|tx_desc
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|nfrag
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m_head
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
operator|(
name|nfrag
operator|+
literal|1
operator|)
operator|>=
name|XLR_MAX_TX_FRAGS
condition|)
block|{
name|free_p2d_desc
argument_list|(
name|tx_desc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
literal|0
condition|)
block|{
name|paddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
expr_stmt|;
name|p1
operator|=
name|paddr
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
name|p2
operator|=
name|vtophys
argument_list|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|m
operator|->
name|m_data
operator|+
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|p2
condition|)
block|{
name|len1
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|PAGE_SIZE
operator|-
operator|(
name|paddr
operator|&
name|PAGE_MASK
operator|)
argument_list|)
expr_stmt|;
name|tx_desc
operator|->
name|frag
index|[
name|nfrag
index|]
operator|=
operator|(
literal|127ULL
operator|<<
literal|54
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|len1
operator|<<
literal|40
operator|)
operator||
name|paddr
expr_stmt|;
name|nfrag
operator|++
expr_stmt|;
name|taddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|m
operator|->
name|m_data
operator|+
name|len1
expr_stmt|;
name|p2
operator|=
name|vtophys
argument_list|(
name|taddr
argument_list|)
expr_stmt|;
name|len2
operator|=
name|m
operator|->
name|m_len
operator|-
name|len1
expr_stmt|;
if|if
condition|(
name|len2
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|nfrag
operator|>=
name|XLR_MAX_TX_FRAGS
condition|)
name|panic
argument_list|(
literal|"TX frags exceeded"
argument_list|)
expr_stmt|;
name|tx_desc
operator|->
name|frag
index|[
name|nfrag
index|]
operator|=
operator|(
literal|127ULL
operator|<<
literal|54
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|len2
operator|<<
literal|40
operator|)
operator||
name|p2
expr_stmt|;
name|taddr
operator|+=
name|len2
expr_stmt|;
name|p1
operator|=
name|vtophys
argument_list|(
name|taddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p2
operator|+
name|len2
operator|)
operator|!=
name|p1
condition|)
block|{
name|printf
argument_list|(
literal|"p1 = %p p2 = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"len1 = %x len2 = %x\n"
argument_list|,
name|len1
argument_list|,
name|len2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"m_data %p\n"
argument_list|,
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Multiple Mbuf segment discontiguous\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tx_desc
operator|->
name|frag
index|[
name|nfrag
index|]
operator|=
operator|(
literal|127ULL
operator|<<
literal|54
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|m
operator|->
name|m_len
operator|<<
literal|40
operator|)
operator||
name|paddr
expr_stmt|;
block|}
name|nfrag
operator|++
expr_stmt|;
block|}
block|}
comment|/* set eop in the last tx p2d desc */
name|tx_desc
operator|->
name|frag
index|[
name|nfrag
operator|-
literal|1
index|]
operator||=
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
expr_stmt|;
name|paddr
operator|=
name|vtophys
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|tx_desc
argument_list|)
expr_stmt|;
name|tx_desc
operator|->
name|frag
index|[
name|nfrag
index|]
operator|=
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
operator||
operator|(
name|fr_stid
operator|<<
literal|54
operator|)
operator||
name|paddr
expr_stmt|;
name|nfrag
operator|++
expr_stmt|;
name|tx_desc
operator|->
name|frag
index|[
name|XLR_MAX_TX_FRAGS
index|]
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|intptr_t
operator|)
name|tx_desc
expr_stmt|;
name|tx_desc
operator|->
name|frag
index|[
name|XLR_MAX_TX_FRAGS
operator|+
literal|1
index|]
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|intptr_t
operator|)
name|m_head
expr_stmt|;
name|p2d_len
operator|=
operator|(
name|nfrag
operator|*
literal|8
operator|)
expr_stmt|;
name|p2p_msg
operator|->
name|msg0
operator|=
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
operator||
operator|(
literal|1ULL
operator|<<
literal|62
operator|)
operator||
operator|(
literal|127ULL
operator|<<
literal|54
operator|)
operator||
operator|(
name|p2d_len
operator|<<
literal|40
operator|)
operator||
name|paddr
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_tx_desc
parameter_list|(
name|struct
name|msgrng_msg
modifier|*
name|msg
parameter_list|,
name|int
name|rel_buf
parameter_list|)
block|{
name|struct
name|p2d_tx_desc
modifier|*
name|tx_desc
decl_stmt|,
modifier|*
name|chk_addr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|tx_desc
operator|=
operator|(
expr|struct
name|p2d_tx_desc
operator|*
operator|)
name|MIPS_PHYS_TO_KSEG0
argument_list|(
name|msg
operator|->
name|msg0
argument_list|)
expr_stmt|;
name|chk_addr
operator|=
operator|(
expr|struct
name|p2d_tx_desc
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|tx_desc
operator|->
name|frag
index|[
name|XLR_MAX_TX_FRAGS
index|]
expr_stmt|;
if|if
condition|(
name|tx_desc
operator|!=
name|chk_addr
condition|)
block|{
name|printf
argument_list|(
literal|"Address %p does not match with stored addr %p - we leaked a descriptor\n"
argument_list|,
name|tx_desc
argument_list|,
name|chk_addr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rel_buf
condition|)
block|{
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|tx_desc
operator|->
name|frag
index|[
name|XLR_MAX_TX_FRAGS
operator|+
literal|1
index|]
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|free_p2d_desc
argument_list|(
name|tx_desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|get_mbuf
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_new
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|m_new
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|m_new
operator|->
name|m_len
operator|=
name|MCLBYTES
expr_stmt|;
name|m_new
operator|->
name|m_len
operator|=
name|m_new
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
return|return
name|m_new
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_buf
parameter_list|(
name|vm_paddr_t
name|paddr
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint64_t
name|mag
decl_stmt|;
name|uint32_t
name|sr
decl_stmt|;
name|sr
operator|=
name|xlr_enable_kx
argument_list|()
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|xlr_paddr_ld
argument_list|(
name|paddr
operator|-
name|XLR_CACHELINE_SIZE
argument_list|)
expr_stmt|;
name|mag
operator|=
name|xlr_paddr_ld
argument_list|(
name|paddr
operator|-
name|XLR_CACHELINE_SIZE
operator|+
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|xlr_restore_kx
argument_list|(
name|sr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mag
operator|!=
literal|0xf00bad
condition|)
block|{
name|printf
argument_list|(
literal|"Something is wrong kseg:%lx found mag:%lx not 0xf00bad\n"
argument_list|,
operator|(
name|u_long
operator|)
name|paddr
argument_list|,
operator|(
name|u_long
operator|)
name|mag
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_buf
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_new
init|=
name|NULL
decl_stmt|;
name|uint64_t
modifier|*
name|md
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|vm_paddr_t
name|temp1
decl_stmt|,
name|temp2
decl_stmt|;
endif|#
directive|endif
name|m_new
operator|=
name|get_mbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|m_adj
argument_list|(
name|m_new
argument_list|,
name|XLR_CACHELINE_SIZE
operator|-
operator|(
operator|(
name|uintptr_t
operator|)
name|m_new
operator|->
name|m_data
operator|&
literal|0x1f
operator|)
argument_list|)
expr_stmt|;
name|md
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|m_new
operator|->
name|m_data
expr_stmt|;
name|md
index|[
literal|0
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|m_new
expr_stmt|;
comment|/* Back Ptr */
name|md
index|[
literal|1
index|]
operator|=
literal|0xf00bad
expr_stmt|;
name|m_adj
argument_list|(
name|m_new
argument_list|,
name|XLR_CACHELINE_SIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|temp1
operator|=
name|vtophys
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|m_new
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|vtophys
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|m_new
operator|->
name|m_data
operator|+
literal|1536
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp1
operator|+
literal|1536
operator|)
operator|!=
name|temp2
condition|)
name|panic
argument_list|(
literal|"ALLOCED BUFFER IS NOT CONTIGUOUS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|void
operator|*
operator|)
name|m_new
operator|->
name|m_data
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|rmi_xlr_mac_set_enable
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|uint32_t
name|regval
decl_stmt|;
name|int
name|tx_threshold
init|=
literal|1518
decl_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|regval
operator|=
name|xlr_read_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_TX_CONTROL
argument_list|)
expr_stmt|;
name|regval
operator||=
operator|(
literal|1
operator|<<
name|O_TX_CONTROL__TxEnable
operator|)
operator||
operator|(
name|tx_threshold
operator|<<
name|O_TX_CONTROL__TxThreshold
operator|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_TX_CONTROL
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|regval
operator|=
name|xlr_read_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_RX_CONTROL
argument_list|)
expr_stmt|;
name|regval
operator||=
literal|1
operator|<<
name|O_RX_CONTROL__RxEnable
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|mode
operator|==
name|XLR_PORT0_RGMII
condition|)
name|regval
operator||=
literal|1
operator|<<
name|O_RX_CONTROL__RGMII
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_RX_CONTROL
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|regval
operator|=
name|xlr_read_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_MAC_CONFIG_1
argument_list|)
expr_stmt|;
name|regval
operator||=
operator|(
name|O_MAC_CONFIG_1__txen
operator||
name|O_MAC_CONFIG_1__rxen
operator|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_MAC_CONFIG_1
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regval
operator|=
name|xlr_read_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_TX_CONTROL
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
name|O_TX_CONTROL__TxEnable
operator|)
operator||
operator|(
name|tx_threshold
operator|<<
name|O_TX_CONTROL__TxThreshold
operator|)
operator|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_TX_CONTROL
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|regval
operator|=
name|xlr_read_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_RX_CONTROL
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|O_RX_CONTROL__RxEnable
operator|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_RX_CONTROL
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|regval
operator|=
name|xlr_read_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_MAC_CONFIG_1
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|~
operator|(
name|O_MAC_CONFIG_1__txen
operator||
name|O_MAC_CONFIG_1__rxen
operator|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_MAC_CONFIG_1
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|__inline__
name|int
name|xlr_mac_send_fr
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|,
name|vm_paddr_t
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|msgrng_msg
name|msg
decl_stmt|;
name|int
name|stid
init|=
name|priv
operator|->
name|rfrbucket
decl_stmt|;
name|int
name|code
decl_stmt|,
name|ret
decl_stmt|;
name|uint32_t
name|msgrng_flags
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|int
name|i
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|mac_make_desc_rfr
argument_list|(
operator|&
name|msg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Send the packet to MAC */
name|dbg_msg
argument_list|(
literal|"mac_%d: Sending free packet %lx to stid %d\n"
argument_list|,
name|priv
operator|->
name|instance
argument_list|,
operator|(
name|u_long
operator|)
name|addr
argument_list|,
name|stid
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|type
operator|==
name|XLR_XGMAC
condition|)
name|code
operator|=
name|MSGRNG_CODE_XGMAC
expr_stmt|;
comment|/* WHY? */
else|else
name|code
operator|=
name|MSGRNG_CODE_MAC
expr_stmt|;
do|do
block|{
name|msgrng_flags
operator|=
name|msgrng_access_enable
argument_list|()
expr_stmt|;
name|ret
operator|=
name|message_send
argument_list|(
literal|1
argument_list|,
name|code
argument_list|,
name|stid
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
name|msgrng_restore
argument_list|(
name|msgrng_flags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|i
operator|++
operator|<
literal|100000
argument_list|,
operator|(
literal|"Too many credit fails\n"
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|!=
literal|0
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_function
specifier|static
name|void
name|xgmac_mdio_setup
parameter_list|(
specifier|volatile
name|unsigned
name|int
modifier|*
name|_mmio
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|rd_data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|rd_data
operator|=
name|xmdio_read
argument_list|(
name|_mmio
argument_list|,
literal|1
argument_list|,
literal|0x8000
operator|+
name|i
argument_list|)
expr_stmt|;
name|rd_data
operator|=
name|rd_data
operator|&
literal|0xffffdfff
expr_stmt|;
comment|/* clear isolate bit */
name|xmdio_write
argument_list|(
name|_mmio
argument_list|,
literal|1
argument_list|,
literal|0x8000
operator|+
name|i
argument_list|,
name|rd_data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  *  Init MII interface  *  *  Input parameters:  *  	   s - priv structure  ********************************************************************* */
end_comment

begin_define
define|#
directive|define
name|PHY_STATUS_RETRIES
value|25000
end_define

begin_function
specifier|static
name|void
name|rmi_xlr_mac_mii_init
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
block|{
name|xlr_reg_t
modifier|*
name|mii_mmio
init|=
name|priv
operator|->
name|mii_mmio
decl_stmt|;
comment|/* use the lowest clock divisor - divisor 28 */
name|xlr_write_reg
argument_list|(
name|mii_mmio
argument_list|,
name|R_MII_MGMT_CONFIG
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  Read a PHY register.  *  *  Input parameters:  *  	   s - priv structure  *  	   phyaddr - PHY's address  *  	   regidx = index of register to read  *  *  Return value:  *  	   value read, or 0 if an error occurred.  ********************************************************************* */
end_comment

begin_function
specifier|static
name|int
name|rge_mii_read_internal
parameter_list|(
name|xlr_reg_t
modifier|*
name|mii_mmio
parameter_list|,
name|int
name|phyaddr
parameter_list|,
name|int
name|regidx
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* setup the phy reg to be used */
name|xlr_write_reg
argument_list|(
name|mii_mmio
argument_list|,
name|R_MII_MGMT_ADDRESS
argument_list|,
operator|(
name|phyaddr
operator|<<
literal|8
operator|)
operator||
operator|(
name|regidx
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Issue the read command */
name|xlr_write_reg
argument_list|(
name|mii_mmio
argument_list|,
name|R_MII_MGMT_COMMAND
argument_list|,
operator|(
literal|1
operator|<<
name|O_MII_MGMT_COMMAND__rstat
operator|)
argument_list|)
expr_stmt|;
comment|/* poll for the read cycle to complete */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHY_STATUS_RETRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xlr_read_reg
argument_list|(
name|mii_mmio
argument_list|,
name|R_MII_MGMT_INDICATORS
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* clear the read cycle */
name|xlr_write_reg
argument_list|(
name|mii_mmio
argument_list|,
name|R_MII_MGMT_COMMAND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|PHY_STATUS_RETRIES
condition|)
block|{
return|return
literal|0xffffffff
return|;
block|}
comment|/* Read the data back */
return|return
name|xlr_read_reg
argument_list|(
name|mii_mmio
argument_list|,
name|R_MII_MGMT_STATUS
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rge_mii_read
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phyaddr
parameter_list|,
name|int
name|regidx
parameter_list|)
block|{
name|struct
name|rge_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
name|rge_mii_read_internal
argument_list|(
name|sc
operator|->
name|priv
operator|.
name|mii_mmio
argument_list|,
name|phyaddr
argument_list|,
name|regidx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  Set MII hooks to newly selected media  *  *  Input parameters:  *  	   ifp - Interface Pointer  *  *  Return value:  *  	   nothing  ********************************************************************* */
end_comment

begin_function
specifier|static
name|int
name|rmi_xlr_mac_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|rge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|mii_mediachg
argument_list|(
operator|&
name|sc
operator|->
name|rge_mii
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  Get the current interface media status  *  *  Input parameters:  *  	   ifp  - Interface Pointer  *  	   ifmr - Interface media request ptr  *  *  Return value:  *  	   nothing  ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|rmi_xlr_mac_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|rge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* Check whether this is interface is active or not. */
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_up
condition|)
block|{
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
block|}
else|else
block|{
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  *  Write a value to a PHY register.  *  *  Input parameters:  *  	   s - priv structure  *  	   phyaddr - PHY to use  *  	   regidx - register within the PHY  *  	   regval - data to write to register  *  *  Return value:  *  	   nothing  ********************************************************************* */
end_comment

begin_function
specifier|static
name|void
name|rge_mii_write_internal
parameter_list|(
name|xlr_reg_t
modifier|*
name|mii_mmio
parameter_list|,
name|int
name|phyaddr
parameter_list|,
name|int
name|regidx
parameter_list|,
name|int
name|regval
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|xlr_write_reg
argument_list|(
name|mii_mmio
argument_list|,
name|R_MII_MGMT_ADDRESS
argument_list|,
operator|(
name|phyaddr
operator|<<
literal|8
operator|)
operator||
operator|(
name|regidx
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Write the data which starts the write cycle */
name|xlr_write_reg
argument_list|(
name|mii_mmio
argument_list|,
name|R_MII_MGMT_WRITE_DATA
argument_list|,
name|regval
argument_list|)
expr_stmt|;
comment|/* poll for the write cycle to complete */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHY_STATUS_RETRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xlr_read_reg
argument_list|(
name|mii_mmio
argument_list|,
name|R_MII_MGMT_INDICATORS
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|rge_mii_write
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phyaddr
parameter_list|,
name|int
name|regidx
parameter_list|,
name|int
name|regval
parameter_list|)
block|{
name|struct
name|rge_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|rge_mii_write_internal
argument_list|(
name|sc
operator|->
name|priv
operator|.
name|mii_mmio
argument_list|,
name|phyaddr
argument_list|,
name|regidx
argument_list|,
name|regval
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rmi_xlr_mac_mii_statchg
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|serdes_regs_init
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
block|{
name|xlr_reg_t
modifier|*
name|mmio_gpio
init|=
operator|(
name|xlr_reg_t
operator|*
operator|)
operator|(
name|xlr_io_base
operator|+
name|XLR_IO_GPIO_OFFSET
operator|)
decl_stmt|;
comment|/* Initialize SERDES CONTROL Registers */
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|serdes_mmio
argument_list|,
literal|26
argument_list|,
literal|0
argument_list|,
literal|0x6DB0
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|serdes_mmio
argument_list|,
literal|26
argument_list|,
literal|1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|serdes_mmio
argument_list|,
literal|26
argument_list|,
literal|2
argument_list|,
literal|0xB6D0
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|serdes_mmio
argument_list|,
literal|26
argument_list|,
literal|3
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|serdes_mmio
argument_list|,
literal|26
argument_list|,
literal|4
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|serdes_mmio
argument_list|,
literal|26
argument_list|,
literal|5
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|serdes_mmio
argument_list|,
literal|26
argument_list|,
literal|6
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|serdes_mmio
argument_list|,
literal|26
argument_list|,
literal|7
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|serdes_mmio
argument_list|,
literal|26
argument_list|,
literal|8
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|serdes_mmio
argument_list|,
literal|26
argument_list|,
literal|9
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|serdes_mmio
argument_list|,
literal|26
argument_list|,
literal|10
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* 	 * GPIO setting which affect the serdes - needs figuring out 	 */
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio_gpio
argument_list|,
literal|0x20
argument_list|,
literal|0x7e6802
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio_gpio
argument_list|,
literal|0x10
argument_list|,
literal|0x7104
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/*  	 * This kludge is needed to setup serdes (?) clock correctly on some 	 * XLS boards 	 */
if|if
condition|(
operator|(
name|xlr_boot1_info
operator|.
name|board_major_version
operator|==
name|RMI_XLR_BOARD_ARIZONA_XI
operator|||
name|xlr_boot1_info
operator|.
name|board_major_version
operator|==
name|RMI_XLR_BOARD_ARIZONA_XII
operator|)
operator|&&
name|xlr_boot1_info
operator|.
name|board_minor_version
operator|==
literal|4
condition|)
block|{
comment|/* use 125 Mhz instead of 156.25Mhz ref clock */
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio_gpio
argument_list|,
literal|0x10
argument_list|,
literal|0x7103
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio_gpio
argument_list|,
literal|0x21
argument_list|,
literal|0x7103
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|serdes_autoconfig
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
block|{
name|int
name|delay
init|=
literal|100000
decl_stmt|;
comment|/* Enable Auto negotiation in the PCS Layer */
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|pcs_mmio
argument_list|,
literal|27
argument_list|,
literal|0
argument_list|,
literal|0x1000
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|pcs_mmio
argument_list|,
literal|27
argument_list|,
literal|0
argument_list|,
literal|0x0200
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|pcs_mmio
argument_list|,
literal|28
argument_list|,
literal|0
argument_list|,
literal|0x1000
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|pcs_mmio
argument_list|,
literal|28
argument_list|,
literal|0
argument_list|,
literal|0x0200
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|pcs_mmio
argument_list|,
literal|29
argument_list|,
literal|0
argument_list|,
literal|0x1000
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|pcs_mmio
argument_list|,
literal|29
argument_list|,
literal|0
argument_list|,
literal|0x0200
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|pcs_mmio
argument_list|,
literal|30
argument_list|,
literal|0
argument_list|,
literal|0x1000
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|pcs_mmio
argument_list|,
literal|30
argument_list|,
literal|0
argument_list|,
literal|0x0200
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************  * Initialize GMAC  *****************************************************************/
end_comment

begin_function
specifier|static
name|void
name|rmi_xlr_config_pde
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|cpu
init|=
literal|0
decl_stmt|,
name|bucket
init|=
literal|0
decl_stmt|;
name|uint64_t
name|bucket_map
init|=
literal|0
decl_stmt|;
comment|/* uint32_t desc_pack_ctrl = 0; */
name|uint32_t
name|cpumask
decl_stmt|;
name|cpumask
operator|=
literal|0x1
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/*          * rge may be called before SMP start in a BOOTP/NFSROOT          * setup. we will distribute packets to other cpus only when          * the SMP is started. 	 */
if|if
condition|(
name|smp_started
condition|)
name|cpumask
operator|=
name|xlr_hw_thread_mask
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cpumask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|cpu
operator|=
name|i
expr_stmt|;
name|bucket
operator|=
operator|(
operator|(
name|cpu
operator|>>
literal|2
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|bucket_map
operator||=
operator|(
literal|3ULL
operator|<<
name|bucket
operator|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"rmi_xlr_config_pde: bucket_map=%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|bucket_map
argument_list|)
expr_stmt|;
comment|/* bucket_map = 0x1; */
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_PDE_CLASS_0
argument_list|,
operator|(
name|bucket_map
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_PDE_CLASS_0
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|bucket_map
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_PDE_CLASS_1
argument_list|,
operator|(
name|bucket_map
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_PDE_CLASS_1
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|bucket_map
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_PDE_CLASS_2
argument_list|,
operator|(
name|bucket_map
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_PDE_CLASS_2
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|bucket_map
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_PDE_CLASS_3
argument_list|,
operator|(
name|bucket_map
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_PDE_CLASS_3
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|bucket_map
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rge_smp_update_pde
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|driver_data
modifier|*
name|priv
decl_stmt|;
name|struct
name|rge_softc
modifier|*
name|sc
decl_stmt|;
name|printf
argument_list|(
literal|"Updating packet distribution for SMP\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XLR_MAX_MACS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|=
name|dev_mac
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
continue|continue;
name|priv
operator|=
operator|&
operator|(
name|sc
operator|->
name|priv
operator|)
expr_stmt|;
name|rmi_xlr_mac_set_enable
argument_list|(
name|priv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rmi_xlr_config_pde
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|rmi_xlr_mac_set_enable
argument_list|(
name|priv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|rge_smp_update_pde
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|rge_smp_update_pde
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|rmi_xlr_config_parser
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
block|{
comment|/* 	 * Mark it as no classification The parser extract is gauranteed to 	 * be zero with no classfication 	 */
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_L2TYPE_0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_L2TYPE_0
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* configure the parser : L2 Type is configured in the bootloader */
comment|/* extract IP: src, dest protocol */
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_L3CTABLE
argument_list|,
operator|(
literal|9
operator|<<
literal|20
operator|)
operator||
operator|(
literal|1
operator|<<
literal|19
operator|)
operator||
operator|(
literal|1
operator|<<
literal|18
operator|)
operator||
operator|(
literal|0x01
operator|<<
literal|16
operator|)
operator||
operator|(
literal|0x0800
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_L3CTABLE
operator|+
literal|1
argument_list|,
operator|(
literal|12
operator|<<
literal|25
operator|)
operator||
operator|(
literal|4
operator|<<
literal|21
operator|)
operator||
operator|(
literal|16
operator|<<
literal|14
operator|)
operator||
operator|(
literal|4
operator|<<
literal|10
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rmi_xlr_config_classifier
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|type
operator|==
name|XLR_XGMAC
condition|)
block|{
comment|/* xgmac translation table doesn't have sane values on reset */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_TRANSLATETABLE
operator|+
name|i
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* 		 * use upper 7 bits of the parser extract to index the 		 * translate table 		 */
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_PARSERCONFIGREG
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_enum
enum|enum
block|{
name|SGMII_SPEED_10
init|=
literal|0x00000000
block|,
name|SGMII_SPEED_100
init|=
literal|0x02000000
block|,
name|SGMII_SPEED_1000
init|=
literal|0x04000000
block|, }
enum|;
end_enum

begin_function
specifier|static
name|void
name|rmi_xlr_gmac_config_speed
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
block|{
name|int
name|phy_addr
init|=
name|priv
operator|->
name|phy_addr
decl_stmt|;
name|xlr_reg_t
modifier|*
name|mmio
init|=
name|priv
operator|->
name|mmio
decl_stmt|;
name|struct
name|rge_softc
modifier|*
name|sc
init|=
name|priv
operator|->
name|sc
decl_stmt|;
name|priv
operator|->
name|speed
operator|=
name|rge_mii_read_internal
argument_list|(
name|priv
operator|->
name|mii_mmio
argument_list|,
name|phy_addr
argument_list|,
literal|28
argument_list|)
expr_stmt|;
name|priv
operator|->
name|link
operator|=
name|rge_mii_read_internal
argument_list|(
name|priv
operator|->
name|mii_mmio
argument_list|,
name|phy_addr
argument_list|,
literal|1
argument_list|)
operator|&
literal|0x4
expr_stmt|;
name|priv
operator|->
name|speed
operator|=
operator|(
name|priv
operator|->
name|speed
operator|>>
literal|3
operator|)
operator|&
literal|0x03
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|speed
operator|==
name|xlr_mac_speed_10
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|mode
operator|!=
name|XLR_RGMII
condition|)
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_INTERFACE_CONTROL
argument_list|,
name|SGMII_SPEED_10
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_MAC_CONFIG_2
argument_list|,
literal|0x7117
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_CORECONTROL
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: [10Mbps]\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|rge_dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
operator|.
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_10_T
operator||
name|IFM_FDX
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_10_T
operator||
name|IFM_FDX
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media_active
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_10_T
operator||
name|IFM_FDX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|priv
operator|->
name|speed
operator|==
name|xlr_mac_speed_100
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|mode
operator|!=
name|XLR_RGMII
condition|)
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_INTERFACE_CONTROL
argument_list|,
name|SGMII_SPEED_100
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_MAC_CONFIG_2
argument_list|,
literal|0x7117
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_CORECONTROL
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: [100Mbps]\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|rge_dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
operator|.
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media_active
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|priv
operator|->
name|speed
operator|!=
name|xlr_mac_speed_1000
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|mode
operator|!=
name|XLR_RGMII
condition|)
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_INTERFACE_CONTROL
argument_list|,
name|SGMII_SPEED_100
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PHY reported unknown MAC speed, defaulting to 100Mbps\n"
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_MAC_CONFIG_2
argument_list|,
literal|0x7117
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_CORECONTROL
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
operator|.
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media_active
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|priv
operator|->
name|mode
operator|!=
name|XLR_RGMII
condition|)
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_INTERFACE_CONTROL
argument_list|,
name|SGMII_SPEED_1000
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_MAC_CONFIG_2
argument_list|,
literal|0x7217
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_CORECONTROL
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: [1000Mbps]\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|rge_dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
operator|.
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_1000_T
operator||
name|IFM_FDX
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_1000_T
operator||
name|IFM_FDX
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media_active
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_1000_T
operator||
name|IFM_FDX
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|priv
operator|->
name|link
condition|)
block|{
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
expr_stmt|;
name|sc
operator|->
name|link_up
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|link_up
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************  * Initialize XGMAC  *****************************************************************/
end_comment

begin_function
specifier|static
name|void
name|rmi_xlr_xgmac_init
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|xlr_reg_t
modifier|*
name|mmio
init|=
name|priv
operator|->
name|mmio
decl_stmt|;
name|int
name|id
init|=
name|priv
operator|->
name|instance
decl_stmt|;
name|struct
name|rge_softc
modifier|*
name|sc
init|=
name|priv
operator|->
name|sc
decl_stmt|;
specifier|volatile
name|unsigned
name|short
modifier|*
name|cpld
decl_stmt|;
name|cpld
operator|=
operator|(
specifier|volatile
name|unsigned
name|short
operator|*
operator|)
literal|0xBD840000
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_DESC_PACK_CTRL
argument_list|,
operator|(
name|MAX_FRAME_SIZE
operator|<<
name|O_DESC_PACK_CTRL__RegularSize
operator|)
operator||
operator|(
literal|4
operator|<<
literal|20
operator|)
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_BYTEOFFSET0
argument_list|,
name|BYTE_OFFSET
argument_list|)
expr_stmt|;
name|rmi_xlr_config_pde
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|rmi_xlr_config_parser
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|rmi_xlr_config_classifier
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_MSG_TX_THRESHOLD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* configure the XGMAC Registers */
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_XGMAC_CONFIG_1
argument_list|,
literal|0x50000026
argument_list|)
expr_stmt|;
comment|/* configure the XGMAC_GLUE Registers */
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_DMACR0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_DMACR1
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_DMACR2
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_DMACR3
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_STATCTRL
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_L2ALLOCCTRL
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_XGMACPADCALIBRATION
argument_list|,
literal|0x030
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_EGRESSFIFOCARVINGSLOTS
argument_list|,
literal|0x0f
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_L2ALLOCCTRL
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_XGMAC_MIIM_CONFIG
argument_list|,
literal|0x3e
argument_list|)
expr_stmt|;
comment|/* 	 * take XGMII phy out of reset 	 */
comment|/* 	 * we are pulling everything out of reset because writing a 0 would 	 * reset other devices on the chip 	 */
name|cpld
index|[
name|ATX_CPLD_RESET_1
index|]
operator|=
literal|0xffff
expr_stmt|;
name|cpld
index|[
name|ATX_CPLD_MISC_CTRL
index|]
operator|=
literal|0xffff
expr_stmt|;
name|cpld
index|[
name|ATX_CPLD_RESET_2
index|]
operator|=
literal|0xffff
expr_stmt|;
name|xgmac_mdio_setup
argument_list|(
name|mmio
argument_list|)
expr_stmt|;
name|rmi_xlr_config_spill_area
argument_list|(
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_XGS_TX0_BUCKET_SIZE
operator|+
name|i
argument_list|,
name|bucket_sizes
operator|.
name|bucket
index|[
name|MSGRNG_STNID_XGS0_TX
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_XGS_JFR_BUCKET_SIZE
argument_list|,
name|bucket_sizes
operator|.
name|bucket
index|[
name|MSGRNG_STNID_XMAC0JFR
index|]
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_XGS_RFR_BUCKET_SIZE
argument_list|,
name|bucket_sizes
operator|.
name|bucket
index|[
name|MSGRNG_STNID_XMAC0RFR
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NUM_MSGRNG_STN_CC
condition|;
name|i
operator|++
control|)
block|{
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_CC_CPU0_0
operator|+
name|i
argument_list|,
name|cc_table_xgs_0
operator|.
name|counters
index|[
name|i
operator|>>
literal|3
index|]
index|[
name|i
operator|&
literal|0x07
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|id
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_XGS_TX0_BUCKET_SIZE
operator|+
name|i
argument_list|,
name|bucket_sizes
operator|.
name|bucket
index|[
name|MSGRNG_STNID_XGS1_TX
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_XGS_JFR_BUCKET_SIZE
argument_list|,
name|bucket_sizes
operator|.
name|bucket
index|[
name|MSGRNG_STNID_XMAC1JFR
index|]
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_XGS_RFR_BUCKET_SIZE
argument_list|,
name|bucket_sizes
operator|.
name|bucket
index|[
name|MSGRNG_STNID_XMAC1RFR
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NUM_MSGRNG_STN_CC
condition|;
name|i
operator|++
control|)
block|{
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_CC_CPU0_0
operator|+
name|i
argument_list|,
name|cc_table_xgs_1
operator|.
name|counters
index|[
name|i
operator|>>
literal|3
index|]
index|[
name|i
operator|&
literal|0x07
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
operator|.
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_10G_SR
operator||
name|IFM_FDX
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
operator|.
name|ifm_media
operator||=
operator|(
name|IFM_AVALID
operator||
name|IFM_ACTIVE
operator|)
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_10G_SR
operator||
name|IFM_FDX
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media_active
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_10G_SR
operator||
name|IFM_FDX
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
operator||=
operator|(
name|IFM_AVALID
operator||
name|IFM_ACTIVE
operator|)
expr_stmt|;
name|priv
operator|->
name|init_frin_desc
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************  * Initialization gmac  *******************************************************/
end_comment

begin_function
specifier|static
name|int
name|rmi_xlr_gmac_reset
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
block|{
specifier|volatile
name|uint32_t
name|val
decl_stmt|;
name|xlr_reg_t
modifier|*
name|mmio
init|=
name|priv
operator|->
name|mmio
decl_stmt|;
name|int
name|i
decl_stmt|,
name|maxloops
init|=
literal|100
decl_stmt|;
comment|/* Disable MAC RX */
name|val
operator|=
name|xlr_read_reg
argument_list|(
name|mmio
argument_list|,
name|R_MAC_CONFIG_1
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
literal|0x4
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_MAC_CONFIG_1
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Disable Core RX */
name|val
operator|=
name|xlr_read_reg
argument_list|(
name|mmio
argument_list|,
name|R_RX_CONTROL
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
literal|0x1
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_RX_CONTROL
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* wait for rx to halt */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxloops
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|xlr_read_reg
argument_list|(
name|mmio
argument_list|,
name|R_RX_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x2
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|maxloops
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Issue a soft reset */
name|val
operator|=
name|xlr_read_reg
argument_list|(
name|mmio
argument_list|,
name|R_RX_CONTROL
argument_list|)
expr_stmt|;
name|val
operator||=
literal|0x4
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_RX_CONTROL
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* wait for reset to complete */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxloops
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|xlr_read_reg
argument_list|(
name|mmio
argument_list|,
name|R_RX_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x8
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|maxloops
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Clear the soft reset bit */
name|val
operator|=
name|xlr_read_reg
argument_list|(
name|mmio
argument_list|,
name|R_RX_CONTROL
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
literal|0x4
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_RX_CONTROL
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rmi_xlr_gmac_init
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|xlr_reg_t
modifier|*
name|mmio
init|=
name|priv
operator|->
name|mmio
decl_stmt|;
name|int
name|id
init|=
name|priv
operator|->
name|instance
decl_stmt|;
name|struct
name|stn_cc
modifier|*
name|gmac_cc_config
decl_stmt|;
name|uint32_t
name|value
init|=
literal|0
decl_stmt|;
name|int
name|blk
init|=
name|id
operator|/
literal|4
decl_stmt|,
name|port
init|=
name|id
operator|%
literal|4
decl_stmt|;
name|rmi_xlr_mac_set_enable
argument_list|(
name|priv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rmi_xlr_config_spill_area
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_DESC_PACK_CTRL
argument_list|,
operator|(
name|BYTE_OFFSET
operator|<<
name|O_DESC_PACK_CTRL__ByteOffset
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_DESC_PACK_CTRL__MaxEntry
operator|)
operator||
operator|(
name|MAX_FRAME_SIZE
operator|<<
name|O_DESC_PACK_CTRL__RegularSize
operator|)
argument_list|)
expr_stmt|;
name|rmi_xlr_config_pde
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|rmi_xlr_config_parser
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|rmi_xlr_config_classifier
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_MSG_TX_THRESHOLD
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_MAC_CONFIG_1
argument_list|,
literal|0x35
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_RX_CONTROL
argument_list|,
operator|(
literal|0x7
operator|<<
literal|6
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|mode
operator|==
name|XLR_PORT0_RGMII
condition|)
block|{
name|printf
argument_list|(
literal|"Port 0 set in RGMII mode\n"
argument_list|)
expr_stmt|;
name|value
operator|=
name|xlr_read_reg
argument_list|(
name|mmio
argument_list|,
name|R_RX_CONTROL
argument_list|)
expr_stmt|;
name|value
operator||=
literal|1
operator|<<
name|O_RX_CONTROL__RGMII
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_RX_CONTROL
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|rmi_xlr_mac_mii_init
argument_list|(
name|priv
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|priv->advertising = ADVERTISED_10baseT_Full | ADVERTISED_10baseT_Half | 	    ADVERTISED_100baseT_Full | ADVERTISED_100baseT_Half | 	    ADVERTISED_1000baseT_Full | ADVERTISED_Autoneg | 	    ADVERTISED_MII;
endif|#
directive|endif
comment|/* 	 * Enable all MDIO interrupts in the phy RX_ER bit seems to be get 	 * set about every 1 sec in GigE mode, ignore it for now... 	 */
name|rge_mii_write_internal
argument_list|(
name|priv
operator|->
name|mii_mmio
argument_list|,
name|priv
operator|->
name|phy_addr
argument_list|,
literal|25
argument_list|,
literal|0xfffffffe
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|mode
operator|!=
name|XLR_RGMII
condition|)
block|{
name|serdes_regs_init
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|serdes_autoconfig
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
name|rmi_xlr_gmac_config_speed
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|value
operator|=
name|xlr_read_reg
argument_list|(
name|mmio
argument_list|,
name|R_IPG_IFG
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_IPG_IFG
argument_list|,
operator|(
operator|(
name|value
operator|&
operator|~
literal|0x7f
operator|)
operator||
name|MAC_B2B_IPG
operator|)
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_DMACR0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_DMACR1
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_DMACR2
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_DMACR3
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_STATCTRL
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_L2ALLOCCTRL
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_INTMASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_FREEQCARVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_GMAC_TX0_BUCKET_SIZE
operator|+
name|port
argument_list|,
name|xlr_board_info
operator|.
name|bucket_sizes
operator|->
name|bucket
index|[
name|priv
operator|->
name|txbucket
index|]
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_GMAC_JFR0_BUCKET_SIZE
argument_list|,
name|xlr_board_info
operator|.
name|bucket_sizes
operator|->
name|bucket
index|[
name|MSGRNG_STNID_GMACJFR_0
index|]
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_GMAC_RFR0_BUCKET_SIZE
argument_list|,
name|xlr_board_info
operator|.
name|bucket_sizes
operator|->
name|bucket
index|[
name|MSGRNG_STNID_GMACRFR_0
index|]
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_GMAC_JFR1_BUCKET_SIZE
argument_list|,
name|xlr_board_info
operator|.
name|bucket_sizes
operator|->
name|bucket
index|[
name|MSGRNG_STNID_GMACJFR_1
index|]
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_GMAC_RFR1_BUCKET_SIZE
argument_list|,
name|xlr_board_info
operator|.
name|bucket_sizes
operator|->
name|bucket
index|[
name|MSGRNG_STNID_GMACRFR_1
index|]
argument_list|)
expr_stmt|;
name|dbg_msg
argument_list|(
literal|"Programming credit counter %d : %d -> %d\n"
argument_list|,
name|blk
argument_list|,
name|R_GMAC_TX0_BUCKET_SIZE
operator|+
name|port
argument_list|,
name|xlr_board_info
operator|.
name|bucket_sizes
operator|->
name|bucket
index|[
name|priv
operator|->
name|txbucket
index|]
argument_list|)
expr_stmt|;
name|gmac_cc_config
operator|=
name|xlr_board_info
operator|.
name|gmac_block
index|[
name|blk
index|]
operator|.
name|credit_config
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NUM_MSGRNG_STN_CC
condition|;
name|i
operator|++
control|)
block|{
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_CC_CPU0_0
operator|+
name|i
argument_list|,
name|gmac_cc_config
operator|->
name|counters
index|[
name|i
operator|>>
literal|3
index|]
index|[
name|i
operator|&
literal|0x07
index|]
argument_list|)
expr_stmt|;
name|dbg_msg
argument_list|(
literal|"%d: %d -> %d\n"
argument_list|,
name|priv
operator|->
name|instance
argument_list|,
name|R_CC_CPU0_0
operator|+
name|i
argument_list|,
name|gmac_cc_config
operator|->
name|counters
index|[
name|i
operator|>>
literal|3
index|]
index|[
name|i
operator|&
literal|0x07
index|]
argument_list|)
expr_stmt|;
block|}
name|priv
operator|->
name|init_frin_desc
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Set promiscuous mode  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|xlr_mac_set_rx_mode
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|driver_data
modifier|*
name|priv
init|=
operator|&
operator|(
name|sc
operator|->
name|priv
operator|)
decl_stmt|;
name|uint32_t
name|regval
decl_stmt|;
name|regval
operator|=
name|xlr_read_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_MAC_FILTER_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|regval
operator||=
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__BROADCAST_EN
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__PAUSE_FRAME_EN
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__ALL_MCAST_EN
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__ALL_UCAST_EN
operator|)
expr_stmt|;
block|}
else|else
block|{
name|regval
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__PAUSE_FRAME_EN
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__ALL_UCAST_EN
operator|)
operator|)
expr_stmt|;
block|}
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_MAC_FILTER_CONFIG
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  Configure LAN speed for the specified MAC.  ********************************************************************* */
end_comment

begin_function
specifier|static
name|int
name|rmi_xlr_mac_set_speed
parameter_list|(
name|struct
name|driver_data
modifier|*
name|s
parameter_list|,
name|xlr_mac_speed_t
name|speed
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  Set Ethernet duplex and flow control options for this MAC  ********************************************************************* */
end_comment

begin_function
specifier|static
name|int
name|rmi_xlr_mac_set_duplex
parameter_list|(
name|struct
name|driver_data
modifier|*
name|s
parameter_list|,
name|xlr_mac_duplex_t
name|duplex
parameter_list|,
name|xlr_mac_fc_t
name|fc
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************  * Kernel Net Stack<-> MAC Driver Interface  *****************************************************************/
end_comment

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_define
define|#
directive|define
name|MAC_TX_FAIL
value|2
end_define

begin_define
define|#
directive|define
name|MAC_TX_PASS
value|0
end_define

begin_define
define|#
directive|define
name|MAC_TX_RETRY
value|1
end_define

begin_decl_stmt
name|int
name|xlr_dev_queue_xmit_hack
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mac_xmit
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|p2d_tx_desc
modifier|*
name|tx_desc
parameter_list|)
block|{
name|struct
name|msgrng_msg
name|msg
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|stid
init|=
name|priv
operator|->
name|txbucket
decl_stmt|;
name|uint32_t
name|tx_cycles
init|=
literal|0
decl_stmt|;
name|uint32_t
name|mflags
decl_stmt|;
name|int
name|vcpu
init|=
name|xlr_cpu_id
argument_list|()
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|tx_cycles
operator|=
name|mips_rd_count
argument_list|()
expr_stmt|;
if|if
condition|(
name|build_frag_list
argument_list|(
name|m
argument_list|,
operator|&
name|msg
argument_list|,
name|tx_desc
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|MAC_TX_FAIL
return|;
else|else
block|{
name|mflags
operator|=
name|msgrng_access_enable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|message_send
argument_list|(
literal|1
argument_list|,
name|MSGRNG_CODE_MAC
argument_list|,
name|stid
argument_list|,
operator|&
name|msg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|msg_snd_failed
operator|++
expr_stmt|;
name|msgrng_restore
argument_list|(
name|mflags
argument_list|)
expr_stmt|;
name|release_tx_desc
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xlr_rge_msg_snd_failed
index|[
name|vcpu
index|]
operator|++
expr_stmt|;
name|dbg_msg
argument_list|(
literal|"Failed packet to cpu %d, rv = %d, stid %d, msg0=%jx\n"
argument_list|,
name|vcpu
argument_list|,
name|rv
argument_list|,
name|stid
argument_list|,
operator|(
name|uintmax_t
operator|)
name|msg
operator|.
name|msg0
argument_list|)
expr_stmt|;
return|return
name|MAC_TX_FAIL
return|;
block|}
name|msgrng_restore
argument_list|(
name|mflags
argument_list|)
expr_stmt|;
name|port_inc_counter
argument_list|(
name|priv
operator|->
name|instance
argument_list|,
name|PORT_TX
argument_list|)
expr_stmt|;
block|}
comment|/* Send the packet to MAC */
name|dbg_msg
argument_list|(
literal|"Sent tx packet to stid %d, msg0=%jx, msg1=%jx \n"
argument_list|,
name|stid
argument_list|,
operator|(
name|uintmax_t
operator|)
name|msg
operator|.
name|msg0
argument_list|,
operator|(
name|uintmax_t
operator|)
name|msg
operator|.
name|msg1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMP_PACKETS
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|printf
argument_list|(
literal|"Tx Packet: length=%d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|&&
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02x "
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|xlr_inc_counter
argument_list|(
name|NETIF_TX
argument_list|)
expr_stmt|;
return|return
name|MAC_TX_PASS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rmi_xlr_mac_xmit
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|p2d_tx_desc
modifier|*
name|tx_desc
parameter_list|)
block|{
name|struct
name|driver_data
modifier|*
name|priv
init|=
operator|&
operator|(
name|sc
operator|->
name|priv
operator|)
decl_stmt|;
name|int
name|ret
init|=
operator|-
name|ENOSPC
decl_stmt|;
name|dbg_msg
argument_list|(
literal|"IN\n"
argument_list|)
expr_stmt|;
name|xlr_inc_counter
argument_list|(
name|NETIF_STACK_TX
argument_list|)
expr_stmt|;
name|retry
label|:
name|ret
operator|=
name|mac_xmit
argument_list|(
name|m
argument_list|,
name|sc
argument_list|,
name|priv
argument_list|,
name|len
argument_list|,
name|tx_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|MAC_TX_RETRY
condition|)
goto|goto
name|retry
goto|;
name|dbg_msg
argument_list|(
literal|"OUT, ret = %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|MAC_TX_FAIL
condition|)
block|{
comment|/* FULL */
name|dbg_msg
argument_list|(
literal|"Msg Ring Full. Stopping upper layer Q\n"
argument_list|)
expr_stmt|;
name|port_inc_counter
argument_list|(
name|priv
operator|->
name|instance
argument_list|,
name|PORT_STOPQ
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mac_frin_replenish
parameter_list|(
name|void
modifier|*
name|args
comment|/* ignored */
parameter_list|)
block|{
name|int
name|cpu
init|=
name|xlr_core_id
argument_list|()
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|xlr_inc_counter
argument_list|(
name|REPLENISH_ENTER
argument_list|)
expr_stmt|;
comment|/* 	 * xlr_set_counter(REPLENISH_ENTER_COUNT, 	 * atomic_read(frin_to_be_sent)); 	 */
name|xlr_set_counter
argument_list|(
name|REPLENISH_CPU
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|done
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XLR_MAX_MACS
condition|;
name|i
operator|++
control|)
block|{
comment|/* int offset = 0; */
name|void
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|cycles
decl_stmt|;
name|struct
name|rge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|driver_data
modifier|*
name|priv
decl_stmt|;
name|int
name|frin_to_be_sent
decl_stmt|;
name|sc
operator|=
name|dev_mac
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
goto|goto
name|skip
goto|;
name|priv
operator|=
operator|&
operator|(
name|sc
operator|->
name|priv
operator|)
expr_stmt|;
name|frin_to_be_sent
operator|=
name|priv
operator|->
name|frin_to_be_sent
index|[
name|cpu
index|]
expr_stmt|;
comment|/* if (atomic_read(frin_to_be_sent)< 0) */
if|if
condition|(
name|frin_to_be_sent
operator|<
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"BUG?: [%s]: gmac_%d illegal value for frin_to_be_sent=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
argument_list|,
name|frin_to_be_sent
argument_list|)
expr_stmt|;
block|}
comment|/* if (!atomic_read(frin_to_be_sent)) */
if|if
condition|(
operator|!
name|frin_to_be_sent
condition|)
goto|goto
name|skip
goto|;
name|cycles
operator|=
name|mips_rd_count
argument_list|()
expr_stmt|;
block|{
name|m
operator|=
name|get_buf
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|rge_dev
argument_list|,
literal|"No buffer\n"
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
block|}
name|xlr_inc_counter
argument_list|(
name|REPLENISH_FRIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlr_mac_send_fr
argument_list|(
name|priv
argument_list|,
name|vtophys
argument_list|(
name|m
argument_list|)
argument_list|,
name|MAX_FRAME_SIZE
argument_list|)
condition|)
block|{
name|free_buf
argument_list|(
name|vtophys
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[%s]: rx free message_send failed!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
break|break;
block|}
name|xlr_set_counter
argument_list|(
name|REPLENISH_CYCLES
argument_list|,
operator|(
name|read_c0_count
argument_list|()
operator|-
name|cycles
operator|)
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|(
operator|&
name|priv
operator|->
name|frin_to_be_sent
index|[
name|cpu
index|]
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
name|skip
label|:
name|done
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|==
name|XLR_MAX_MACS
condition|)
break|break;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|volatile
name|uint32_t
name|g_tx_frm_tx_ok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|rge_tx_bkp_func
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xlr_board_info
operator|.
name|gmacports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dev_mac
index|[
name|i
index|]
operator|||
operator|!
name|dev_mac
index|[
name|i
index|]
operator|->
name|active
condition|)
continue|continue;
name|rge_start_locked
argument_list|(
name|dev_mac
index|[
name|i
index|]
operator|->
name|rge_ifp
argument_list|,
name|RGE_TX_THRESHOLD
argument_list|)
expr_stmt|;
block|}
name|atomic_subtract_int
argument_list|(
operator|&
name|g_tx_frm_tx_ok
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called from an interrupt handler */
end_comment

begin_function
name|void
name|rmi_xlr_mac_msgring_handler
parameter_list|(
name|int
name|bucket
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|stid
parameter_list|,
name|struct
name|msgrng_msg
modifier|*
name|msg
parameter_list|,
name|void
modifier|*
name|data
comment|/* ignored */
parameter_list|)
block|{
name|uint64_t
name|phys_addr
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|addr
init|=
literal|0
decl_stmt|;
name|uint32_t
name|length
init|=
literal|0
decl_stmt|;
name|int
name|ctrl
init|=
literal|0
decl_stmt|,
name|port
init|=
literal|0
decl_stmt|;
name|struct
name|rge_softc
modifier|*
name|sc
init|=
name|NULL
decl_stmt|;
name|struct
name|driver_data
modifier|*
name|priv
init|=
literal|0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|vcpu
init|=
name|xlr_cpu_id
argument_list|()
decl_stmt|;
name|int
name|cpu
init|=
name|xlr_core_id
argument_list|()
decl_stmt|;
name|dbg_msg
argument_list|(
literal|"mac: bucket=%d, size=%d, code=%d, stid=%d, msg0=%jx msg1=%jx\n"
argument_list|,
name|bucket
argument_list|,
name|size
argument_list|,
name|code
argument_list|,
name|stid
argument_list|,
operator|(
name|uintmax_t
operator|)
name|msg
operator|->
name|msg0
argument_list|,
operator|(
name|uintmax_t
operator|)
name|msg
operator|->
name|msg1
argument_list|)
expr_stmt|;
name|phys_addr
operator|=
call|(
name|uint64_t
call|)
argument_list|(
name|msg
operator|->
name|msg0
operator|&
literal|0xffffffffe0ULL
argument_list|)
expr_stmt|;
name|length
operator|=
operator|(
name|msg
operator|->
name|msg0
operator|>>
literal|40
operator|)
operator|&
literal|0x3fff
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|ctrl
operator|=
name|CTRL_REG_FREE
expr_stmt|;
name|port
operator|=
operator|(
name|msg
operator|->
name|msg0
operator|>>
literal|54
operator|)
operator|&
literal|0x0f
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ctrl
operator|=
name|CTRL_SNGL
expr_stmt|;
name|length
operator|=
name|length
operator|-
name|BYTE_OFFSET
operator|-
name|MAC_CRC_LEN
expr_stmt|;
name|port
operator|=
name|msg
operator|->
name|msg0
operator|&
literal|0x0f
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xlr_board_info
operator|.
name|is_xls
condition|)
block|{
if|if
condition|(
name|stid
operator|==
name|MSGRNG_STNID_GMAC1
condition|)
name|port
operator|+=
literal|4
expr_stmt|;
name|sc
operator|=
name|dev_mac
index|[
name|dev_mac_gmac0
operator|+
name|port
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stid
operator|==
name|MSGRNG_STNID_XGS0FR
condition|)
name|sc
operator|=
name|dev_mac
index|[
name|dev_mac_xgs0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|stid
operator|==
name|MSGRNG_STNID_XGS1FR
condition|)
name|sc
operator|=
name|dev_mac
index|[
name|dev_mac_xgs0
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|sc
operator|=
name|dev_mac
index|[
name|dev_mac_gmac0
operator|+
name|port
index|]
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|priv
operator|=
operator|&
operator|(
name|sc
operator|->
name|priv
operator|)
expr_stmt|;
name|dbg_msg
argument_list|(
literal|"msg0 = %jx, stid = %d, port = %d, addr=%lx, length=%d, ctrl=%d\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|msg
operator|->
name|msg0
argument_list|,
name|stid
argument_list|,
name|port
argument_list|,
name|addr
argument_list|,
name|length
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctrl
operator|==
name|CTRL_REG_FREE
operator|||
name|ctrl
operator|==
name|CTRL_JUMBO_FREE
condition|)
block|{
name|xlr_rge_tx_ok_done
index|[
name|vcpu
index|]
operator|++
expr_stmt|;
name|release_tx_desc
argument_list|(
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|rge_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|g_tx_frm_tx_ok
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
name|rge_tx_bkp_func
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xlr_set_counter
argument_list|(
name|NETIF_TX_COMPLETE_CYCLES
argument_list|,
operator|(
name|read_c0_count
argument_list|()
operator|-
name|msgrng_msg_cycles
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctrl
operator|==
name|CTRL_SNGL
operator|||
name|ctrl
operator|==
name|CTRL_START
condition|)
block|{
comment|/* Rx Packet */
comment|/* struct mbuf *m = 0; */
comment|/* int logical_cpu = 0; */
name|dbg_msg
argument_list|(
literal|"Received packet, port = %d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* 		 * if num frins to be sent exceeds threshold, wake up the 		 * helper thread 		 */
name|atomic_add_int
argument_list|(
operator|&
operator|(
name|priv
operator|->
name|frin_to_be_sent
index|[
name|cpu
index|]
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|priv
operator|->
name|frin_to_be_sent
index|[
name|cpu
index|]
operator|)
operator|>
name|MAC_FRIN_TO_BE_SENT_THRESHOLD
condition|)
block|{
name|mac_frin_replenish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|dbg_msg
argument_list|(
literal|"gmac_%d: rx packet: phys_addr = %jx, length = %x\n"
argument_list|,
name|priv
operator|->
name|instance
argument_list|,
operator|(
name|uintmax_t
operator|)
name|phys_addr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|mac_stats_add
argument_list|(
name|priv
operator|->
name|stats
operator|.
name|rx_packets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mac_stats_add
argument_list|(
name|priv
operator|->
name|stats
operator|.
name|rx_bytes
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|xlr_inc_counter
argument_list|(
name|NETIF_RX
argument_list|)
expr_stmt|;
name|xlr_set_counter
argument_list|(
name|NETIF_RX_CYCLES
argument_list|,
operator|(
name|read_c0_count
argument_list|()
operator|-
name|msgrng_msg_cycles
operator|)
argument_list|)
expr_stmt|;
name|rge_rx
argument_list|(
name|sc
argument_list|,
name|phys_addr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|xlr_rge_rx_done
index|[
name|vcpu
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"[%s]: unrecognized ctrl=%d!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|rge_probe
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"RMI Gigabit Ethernet"
argument_list|)
expr_stmt|;
comment|/* Always return 0 */
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|volatile
name|unsigned
name|long
name|xlr_debug_enabled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|callout
name|rge_dbg_count
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|xlr_debug_count
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|driver_data
modifier|*
name|priv
init|=
operator|&
name|dev_mac
index|[
literal|0
index|]
operator|->
name|priv
decl_stmt|;
comment|/* uint32_t crdt; */
if|if
condition|(
name|xlr_debug_enabled
condition|)
block|{
name|printf
argument_list|(
literal|"\nAvailRxIn %#x\n"
argument_list|,
name|xlr_read_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
literal|0x23e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|rge_dbg_count
argument_list|,
name|hz
argument_list|,
name|xlr_debug_count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xlr_tx_q_wakeup
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xlr_board_info
operator|.
name|gmacports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dev_mac
index|[
name|i
index|]
operator|||
operator|!
name|dev_mac
index|[
name|i
index|]
operator|->
name|active
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dev_mac
index|[
name|i
index|]
operator|->
name|rge_ifp
operator|->
name|if_drv_flags
operator|)
operator|&
name|IFF_DRV_OACTIVE
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XLR_MAX_CORE
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|xlr_tot_avail_p2d
index|[
name|j
index|]
condition|)
block|{
name|dev_mac
index|[
name|i
index|]
operator|->
name|rge_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|g_tx_frm_tx_ok
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
name|rge_tx_bkp_func
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|xlr_tx_stop_bkp
argument_list|,
literal|5
operator|*
name|hz
argument_list|,
name|xlr_tx_q_wakeup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rge_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|rge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|driver_data
modifier|*
name|priv
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|xlr_gmac_block_t
modifier|*
name|gmac_conf
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rge_dev
operator|=
name|dev
expr_stmt|;
comment|/* Initialize mac's */
name|sc
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|unit
operator|>
name|XLR_MAX_MACS
condition|)
block|{
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|RGE_LOCK_INIT
argument_list|(
name|sc
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|=
operator|&
operator|(
name|sc
operator|->
name|priv
operator|)
expr_stmt|;
name|priv
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* TODO : fix me up later */
name|priv
operator|->
name|id
operator|=
name|sc
operator|->
name|unit
expr_stmt|;
if|if
condition|(
name|gmac_conf
operator|->
name|type
operator|==
name|XLR_GMAC
condition|)
block|{
name|priv
operator|->
name|instance
operator|=
name|priv
operator|->
name|id
expr_stmt|;
name|priv
operator|->
name|mmio
operator|=
operator|(
name|xlr_reg_t
operator|*
operator|)
operator|(
name|xlr_io_base
operator|+
name|gmac_conf
operator|->
name|baseaddr
operator|+
literal|0x1000
operator|*
operator|(
name|sc
operator|->
name|unit
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|rmi_xlr_gmac_reset
argument_list|(
name|priv
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|gmac_conf
operator|->
name|type
operator|==
name|XLR_XGMAC
condition|)
block|{
name|priv
operator|->
name|instance
operator|=
name|priv
operator|->
name|id
operator|-
name|xlr_board_info
operator|.
name|gmacports
expr_stmt|;
name|priv
operator|->
name|mmio
operator|=
operator|(
name|xlr_reg_t
operator|*
operator|)
operator|(
name|xlr_io_base
operator|+
name|gmac_conf
operator|->
name|baseaddr
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|xlr_boot1_info
operator|.
name|board_major_version
operator|==
name|RMI_XLR_BOARD_ARIZONA_VI
operator|||
operator|(
name|xlr_boot1_info
operator|.
name|board_major_version
operator|==
name|RMI_XLR_BOARD_ARIZONA_XI
operator|&&
name|priv
operator|->
name|instance
operator|>=
literal|4
operator|)
condition|)
block|{
name|dbg_msg
argument_list|(
literal|"Arizona board - offset 4 \n"
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mii_mmio
operator|=
operator|(
name|xlr_reg_t
operator|*
operator|)
operator|(
name|xlr_io_base
operator|+
name|XLR_IO_GMAC_4_OFFSET
operator|)
expr_stmt|;
block|}
else|else
name|priv
operator|->
name|mii_mmio
operator|=
operator|(
name|xlr_reg_t
operator|*
operator|)
operator|(
name|xlr_io_base
operator|+
name|XLR_IO_GMAC_0_OFFSET
operator|)
expr_stmt|;
name|priv
operator|->
name|pcs_mmio
operator|=
operator|(
name|xlr_reg_t
operator|*
operator|)
operator|(
name|xlr_io_base
operator|+
name|gmac_conf
operator|->
name|baseaddr
operator|)
expr_stmt|;
name|priv
operator|->
name|serdes_mmio
operator|=
operator|(
name|xlr_reg_t
operator|*
operator|)
operator|(
name|xlr_io_base
operator|+
name|XLR_IO_GMAC_0_OFFSET
operator|)
expr_stmt|;
name|sc
operator|->
name|base_addr
operator|=
operator|(
name|unsigned
name|long
operator|)
name|priv
operator|->
name|mmio
expr_stmt|;
name|sc
operator|->
name|mem_end
operator|=
operator|(
name|unsigned
name|long
operator|)
name|priv
operator|->
name|mmio
operator|+
name|XLR_IO_SIZE
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|xmit
operator|=
name|rge_start
expr_stmt|;
name|sc
operator|->
name|stop
operator|=
name|rge_stop
expr_stmt|;
name|sc
operator|->
name|get_stats
operator|=
name|rmi_xlr_mac_get_stats
expr_stmt|;
name|sc
operator|->
name|ioctl
operator|=
name|rge_ioctl
expr_stmt|;
comment|/* Initialize the device specific driver data */
name|mtx_init
argument_list|(
operator|&
name|priv
operator|->
name|lock
argument_list|,
literal|"rge"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|priv
operator|->
name|type
operator|=
name|gmac_conf
operator|->
name|type
expr_stmt|;
name|priv
operator|->
name|mode
operator|=
name|gmac_conf
operator|->
name|mode
expr_stmt|;
if|if
condition|(
name|xlr_board_info
operator|.
name|is_xls
operator|==
literal|0
condition|)
block|{
comment|/* TODO - check II and IIB boards */
if|if
condition|(
name|xlr_boot1_info
operator|.
name|board_major_version
operator|==
name|RMI_XLR_BOARD_ARIZONA_II
operator|&&
name|xlr_boot1_info
operator|.
name|board_minor_version
operator|!=
literal|1
condition|)
name|priv
operator|->
name|phy_addr
operator|=
name|priv
operator|->
name|instance
operator|-
literal|2
expr_stmt|;
else|else
name|priv
operator|->
name|phy_addr
operator|=
name|priv
operator|->
name|instance
expr_stmt|;
name|priv
operator|->
name|mode
operator|=
name|XLR_RGMII
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gmac_conf
operator|->
name|mode
operator|==
name|XLR_PORT0_RGMII
operator|&&
name|priv
operator|->
name|instance
operator|==
literal|0
condition|)
block|{
name|priv
operator|->
name|mode
operator|=
name|XLR_PORT0_RGMII
expr_stmt|;
name|priv
operator|->
name|phy_addr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|priv
operator|->
name|mode
operator|=
name|XLR_SGMII
expr_stmt|;
comment|/* Board 11 has SGMII daughter cards with the XLS chips, in this case 			   the phy number is 0-3 for both GMAC blocks */
if|if
condition|(
name|xlr_boot1_info
operator|.
name|board_major_version
operator|==
name|RMI_XLR_BOARD_ARIZONA_XI
condition|)
name|priv
operator|->
name|phy_addr
operator|=
name|priv
operator|->
name|instance
operator|%
literal|4
operator|+
literal|16
expr_stmt|;
else|else
name|priv
operator|->
name|phy_addr
operator|=
name|priv
operator|->
name|instance
operator|+
literal|16
expr_stmt|;
block|}
block|}
name|priv
operator|->
name|txbucket
operator|=
name|gmac_conf
operator|->
name|station_txbase
operator|+
name|priv
operator|->
name|instance
operator|%
literal|4
expr_stmt|;
name|priv
operator|->
name|rfrbucket
operator|=
name|gmac_conf
operator|->
name|station_rfr
expr_stmt|;
name|priv
operator|->
name|spill_configured
operator|=
literal|0
expr_stmt|;
name|dbg_msg
argument_list|(
literal|"priv->mmio=%p\n"
argument_list|,
name|priv
operator|->
name|mmio
argument_list|)
expr_stmt|;
comment|/* Set up ifnet structure */
name|ifp
operator|=
name|sc
operator|->
name|rge_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|rge_dev
argument_list|,
literal|"failed to if_alloc()\n"
argument_list|)
expr_stmt|;
name|rge_release_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
name|RGE_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|rge_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|rge_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|rge_init
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|RGE_TX_Q_SIZE
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|active
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_TXCSUM
operator||
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* Initialize the rge_softc */
name|sc
operator|->
name|irq
operator|=
name|gmac_conf
operator|->
name|baseirq
operator|+
name|priv
operator|->
name|instance
operator|%
literal|4
expr_stmt|;
comment|/* Set the IRQ into the rid field */
comment|/* 	 * note this is a hack to pass the irq to the iodi interrupt setup 	 * routines 	 */
name|sc
operator|->
name|rge_irq
operator|.
name|__r_i
operator|=
operator|(
expr|struct
name|resource_i
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|sc
operator|->
name|irq
expr_stmt|;
name|ret
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|rge_irq
argument_list|,
name|INTR_FAST
operator||
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|rge_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rge_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|rge_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|rge_dev
argument_list|,
literal|"couldn't set up irq\n"
argument_list|)
expr_stmt|;
name|RGE_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|xlr_mac_get_hwaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xlr_mac_setup_hwaddr
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|dbg_msg
argument_list|(
literal|"MMIO %08lx, MII %08lx, PCS %08lx, base %08lx PHY %d IRQ %d\n"
argument_list|,
operator|(
name|u_long
operator|)
name|priv
operator|->
name|mmio
argument_list|,
operator|(
name|u_long
operator|)
name|priv
operator|->
name|mii_mmio
argument_list|,
operator|(
name|u_long
operator|)
name|priv
operator|->
name|pcs_mmio
argument_list|,
operator|(
name|u_long
operator|)
name|sc
operator|->
name|base_addr
argument_list|,
name|priv
operator|->
name|phy_addr
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|dbg_msg
argument_list|(
literal|"HWADDR %02x:%02x tx %d rfr %d\n"
argument_list|,
operator|(
name|u_int
operator|)
name|sc
operator|->
name|dev_addr
index|[
literal|4
index|]
argument_list|,
operator|(
name|u_int
operator|)
name|sc
operator|->
name|dev_addr
index|[
literal|5
index|]
argument_list|,
name|priv
operator|->
name|txbucket
argument_list|,
name|priv
operator|->
name|rfrbucket
argument_list|)
expr_stmt|;
comment|/* 	 * Set up ifmedia support. 	 */
comment|/* 	 * Initialize MII/media info. 	 */
name|sc
operator|->
name|rge_mii
operator|.
name|mii_ifp
operator|=
name|ifp
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_readreg
operator|=
name|rge_mii_read
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_writereg
operator|=
operator|(
name|mii_writereg_t
operator|)
name|rge_mii_write
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_statchg
operator|=
name|rmi_xlr_mac_mii_statchg
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
argument_list|,
literal|0
argument_list|,
name|rmi_xlr_mac_mediachange
argument_list|,
name|rmi_xlr_mac_mediastatus
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
operator|.
name|ifm_media
operator|=
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
comment|/* 	 * Call MI attach routine. 	 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|dev_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|type
operator|==
name|XLR_GMAC
condition|)
block|{
name|rmi_xlr_gmac_init
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|priv
operator|->
name|type
operator|==
name|XLR_XGMAC
condition|)
block|{
name|rmi_xlr_xgmac_init
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
name|dbg_msg
argument_list|(
literal|"rge_%d: Phoenix Mac at 0x%p (mtu=%d)\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|priv
operator|->
name|mmio
argument_list|,
name|sc
operator|->
name|mtu
argument_list|)
expr_stmt|;
name|dev_mac
index|[
name|sc
operator|->
name|unit
index|]
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|type
operator|==
name|XLR_XGMAC
operator|&&
name|priv
operator|->
name|instance
operator|==
literal|0
condition|)
name|dev_mac_xgs0
operator|=
name|sc
operator|->
name|unit
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|type
operator|==
name|XLR_GMAC
operator|&&
name|priv
operator|->
name|instance
operator|==
literal|0
condition|)
name|dev_mac_gmac0
operator|=
name|sc
operator|->
name|unit
expr_stmt|;
if|if
condition|(
operator|!
name|gmac_common_init_done
condition|)
block|{
name|mac_common_init
argument_list|()
expr_stmt|;
name|gmac_common_init_done
operator|=
literal|1
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|xlr_tx_stop_bkp
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|xlr_tx_stop_bkp
argument_list|,
name|hz
argument_list|,
name|xlr_tx_q_wakeup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|rge_dbg_count
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
comment|//callout_reset(&rge_dbg_count, hz, xlr_debug_count, NULL);
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|rmi_xlr_mac_open
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|RGE_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"error - skipping\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rge_reset
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|rge_detach
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|FREEBSD_MAC_NOT_YET
name|struct
name|rge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|rge_ifp
expr_stmt|;
name|RGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rge_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rge_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rge_tbi
condition|)
block|{
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|rge_ifmedia
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|rge_miibus
argument_list|)
expr_stmt|;
block|}
name|rge_release_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_MAC_NOT_YET */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rge_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|rge_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|RGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rge_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rge_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|panic
argument_list|(
literal|"rge_resume(): unimplemented\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rge_release_resources
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|rge_ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|sc
operator|->
name|rge_ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|rge_mtx
argument_list|)
condition|)
comment|/* XXX */
name|RGE_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|uint32_t
name|gmac_rx_fail
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|gmac_rx_pass
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|rge_rx
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|,
name|vm_paddr_t
name|paddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|rge_ifp
decl_stmt|;
name|uint64_t
name|mag
decl_stmt|;
name|uint32_t
name|sr
decl_stmt|;
comment|/* 	 * On 32 bit machines we use XKPHYS to get the values stores with 	 * the mbuf, need to explicitly enable KX. Disable interrupts while 	 * KX is enabled to prevent this setting leaking to other code. 	 */
name|sr
operator|=
name|xlr_enable_kx
argument_list|()
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|xlr_paddr_ld
argument_list|(
name|paddr
operator|-
name|XLR_CACHELINE_SIZE
argument_list|)
expr_stmt|;
name|mag
operator|=
name|xlr_paddr_ld
argument_list|(
name|paddr
operator|-
name|XLR_CACHELINE_SIZE
operator|+
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|xlr_restore_kx
argument_list|(
name|sr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mag
operator|!=
literal|0xf00bad
condition|)
block|{
comment|/* somebody else packet Error - FIXME in intialization */
name|printf
argument_list|(
literal|"cpu %d: *ERROR* Not my packet paddr %p\n"
argument_list|,
name|xlr_cpu_id
argument_list|()
argument_list|,
operator|(
name|void
operator|*
operator|)
name|paddr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* align the data */
name|m
operator|->
name|m_data
operator|+=
name|BYTE_OFFSET
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMP_PACKETS
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|printf
argument_list|(
literal|"Rx Packet: length=%d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|&&
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02x "
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rge_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|rge_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|rge_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|driver_data
modifier|*
name|priv
init|=
operator|&
operator|(
name|sc
operator|->
name|priv
operator|)
decl_stmt|;
name|xlr_reg_t
modifier|*
name|mmio
init|=
name|priv
operator|->
name|mmio
decl_stmt|;
name|uint32_t
name|intreg
init|=
name|xlr_read_reg
argument_list|(
name|mmio
argument_list|,
name|R_INTREG
argument_list|)
decl_stmt|;
if|if
condition|(
name|intreg
operator|&
operator|(
literal|1
operator|<<
name|O_INTREG__MDInt
operator|)
condition|)
block|{
name|uint32_t
name|phy_int_status
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XLR_MAX_MACS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|rge_softc
modifier|*
name|phy_dev
init|=
literal|0
decl_stmt|;
name|struct
name|driver_data
modifier|*
name|phy_priv
init|=
literal|0
decl_stmt|;
name|phy_dev
operator|=
name|dev_mac
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|phy_dev
operator|==
name|NULL
condition|)
continue|continue;
name|phy_priv
operator|=
operator|&
name|phy_dev
operator|->
name|priv
expr_stmt|;
if|if
condition|(
name|phy_priv
operator|->
name|type
operator|==
name|XLR_XGMAC
condition|)
continue|continue;
name|phy_int_status
operator|=
name|rge_mii_read_internal
argument_list|(
name|phy_priv
operator|->
name|mii_mmio
argument_list|,
name|phy_priv
operator|->
name|phy_addr
argument_list|,
literal|26
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rge%d: Phy addr %d, MII MMIO %lx status %x\n"
argument_list|,
name|phy_priv
operator|->
name|instance
argument_list|,
operator|(
name|int
operator|)
name|phy_priv
operator|->
name|phy_addr
argument_list|,
operator|(
name|u_long
operator|)
name|phy_priv
operator|->
name|mii_mmio
argument_list|,
name|phy_int_status
argument_list|)
expr_stmt|;
name|rmi_xlr_gmac_config_speed
argument_list|(
name|phy_priv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"[%s]: mac type = %d, instance %d error "
literal|"interrupt: INTREG = 0x%08x\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|priv
operator|->
name|type
argument_list|,
name|priv
operator|->
name|instance
argument_list|,
name|intreg
argument_list|)
expr_stmt|;
block|}
comment|/* clear all interrupts and hope to make progress */
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|R_INTREG
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* (not yet) on A0 and B0, xgmac interrupts are routed only to xgs_1 irq */
if|if
condition|(
operator|(
name|xlr_revision
argument_list|()
operator|<
literal|2
operator|)
operator|&&
operator|(
name|priv
operator|->
name|type
operator|==
name|XLR_XGMAC
operator|)
condition|)
block|{
name|struct
name|rge_softc
modifier|*
name|xgs0_dev
init|=
name|dev_mac
index|[
name|dev_mac_xgs0
index|]
decl_stmt|;
name|struct
name|driver_data
modifier|*
name|xgs0_priv
init|=
operator|&
name|xgs0_dev
operator|->
name|priv
decl_stmt|;
name|xlr_reg_t
modifier|*
name|xgs0_mmio
init|=
name|xgs0_priv
operator|->
name|mmio
decl_stmt|;
name|uint32_t
name|xgs0_intreg
init|=
name|xlr_read_reg
argument_list|(
name|xgs0_mmio
argument_list|,
name|R_INTREG
argument_list|)
decl_stmt|;
if|if
condition|(
name|xgs0_intreg
condition|)
block|{
name|printf
argument_list|(
literal|"[%s]: mac type = %d, instance %d error "
literal|"interrupt: INTREG = 0x%08x\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|xgs0_priv
operator|->
name|type
argument_list|,
name|xgs0_priv
operator|->
name|instance
argument_list|,
name|xgs0_intreg
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|xgs0_mmio
argument_list|,
name|R_INTREG
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rge_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|threshold
parameter_list|)
block|{
name|struct
name|rge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
name|prepend_pkt
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|p2d_tx_desc
modifier|*
name|tx_desc
init|=
name|NULL
decl_stmt|;
name|int
name|cpu
init|=
name|xlr_core_id
argument_list|()
decl_stmt|;
name|uint32_t
name|vcpu
init|=
name|xlr_cpu_id
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xlr_tot_avail_p2d
index|[
name|cpu
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
return|return;
name|tx_desc
operator|=
name|get_p2d_desc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|tx_desc
condition|)
block|{
name|xlr_rge_get_p2d_failed
index|[
name|vcpu
index|]
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Grab a packet off the queue. */
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|free_p2d_desc
argument_list|(
name|tx_desc
argument_list|)
expr_stmt|;
return|return;
block|}
name|prepend_pkt
operator|=
name|rmi_xlr_mac_xmit
argument_list|(
name|m
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|tx_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|prepend_pkt
condition|)
block|{
name|xlr_rge_tx_prepend
index|[
name|vcpu
index|]
operator|++
expr_stmt|;
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return;
block|}
else|else
block|{
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|xlr_rge_tx_done
index|[
name|vcpu
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rge_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|rge_start_locked
argument_list|(
name|ifp
argument_list|,
name|RGE_TX_Q_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|rge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
comment|/* struct mii_data *mii; */
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|error
operator|=
name|rmi_xlr_mac_change_mtu
argument_list|(
name|sc
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|RGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* 			 * If only the state of the PROMISC flag changed, 			 * then just use the 'set promisc mode' command 			 * instead of reinitializing the entire NIC. Doing a 			 * full re-init means reloading the firmware and 			 * waiting for it to start up, which may take a 			 * second or two.  Similarly for ALLMULTI. 			 */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
name|sc
operator|->
name|flags
operator||=
name|IFF_PROMISC
expr_stmt|;
name|xlr_mac_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|sc
operator|->
name|flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|sc
operator|->
name|flags
operator|&=
name|IFF_PROMISC
expr_stmt|;
name|xlr_mac_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc
operator|->
name|flags
operator|)
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|rmi_xlr_mac_set_multicast_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|xlr_mac_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|xlr_mac_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|RGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|RGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rmi_xlr_mac_set_multicast_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|rge_mii
operator|.
name|mii_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rge_init
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|rge_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|rge_softc
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|driver_data
modifier|*
name|priv
init|=
operator|&
operator|(
name|sc
operator|->
name|priv
operator|)
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|rge_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|rmi_xlr_mac_set_enable
argument_list|(
name|priv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rge_stop
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|rmi_xlr_mac_close
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rge_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|rge_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|RGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rge_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rge_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rmi_xlr_mac_open
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|driver_data
modifier|*
name|priv
init|=
operator|&
operator|(
name|sc
operator|->
name|priv
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dbg_msg
argument_list|(
literal|"IN\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmi_xlr_mac_fill_rxfr
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|xlr_mac_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|unit
operator|==
name|xlr_board_info
operator|.
name|gmacports
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Enabling MDIO interrupts\n"
argument_list|)
expr_stmt|;
name|struct
name|rge_softc
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xlr_board_info
operator|.
name|gmacports
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|dev_mac
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|xlr_write_reg
argument_list|(
name|tmp
operator|->
name|priv
operator|.
name|mmio
argument_list|,
name|R_INTMASK
argument_list|,
operator|(
operator|(
name|tmp
operator|->
name|priv
operator|.
name|instance
operator|==
literal|0
operator|)
operator|<<
name|O_INTMASK__MDInt
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Configure the speed, duplex, and flow control 	 */
name|rmi_xlr_mac_set_speed
argument_list|(
name|priv
argument_list|,
name|priv
operator|->
name|speed
argument_list|)
expr_stmt|;
name|rmi_xlr_mac_set_duplex
argument_list|(
name|priv
argument_list|,
name|priv
operator|->
name|duplex
argument_list|,
name|priv
operator|->
name|flow_ctrl
argument_list|)
expr_stmt|;
name|rmi_xlr_mac_set_enable
argument_list|(
name|priv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|priv
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|atomic_store_int
argument_list|(
operator|&
operator|(
name|priv
operator|->
name|frin_to_be_sent
index|[
name|i
index|]
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|rmi_xlr_mac_close
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|driver_data
modifier|*
name|priv
init|=
operator|&
operator|(
name|sc
operator|->
name|priv
operator|)
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|priv
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * There may have left over mbufs in the ring as well as in free in 	 * they will be reused next time open is called 	 */
name|rmi_xlr_mac_set_enable
argument_list|(
name|priv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xlr_inc_counter
argument_list|(
name|NETIF_STOP_Q
argument_list|)
expr_stmt|;
name|port_inc_counter
argument_list|(
name|priv
operator|->
name|instance
argument_list|,
name|PORT_STOPQ
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|struct
name|rge_softc_stats
modifier|*
name|rmi_xlr_mac_get_stats
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|driver_data
modifier|*
name|priv
init|=
operator|&
operator|(
name|sc
operator|->
name|priv
operator|)
decl_stmt|;
comment|/* unsigned long flags; */
name|mtx_lock_spin
argument_list|(
operator|&
name|priv
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* XXX update other stats here */
name|mtx_unlock_spin
argument_list|(
operator|&
name|priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|&
name|priv
operator|->
name|stats
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|rmi_xlr_mac_set_multicast_list
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|)
block|{ }
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|rmi_xlr_mac_change_mtu
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|,
name|int
name|new_mtu
parameter_list|)
block|{
name|struct
name|driver_data
modifier|*
name|priv
init|=
operator|&
operator|(
name|sc
operator|->
name|priv
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|new_mtu
operator|>
literal|9500
operator|)
operator|||
operator|(
name|new_mtu
operator|<
literal|64
operator|)
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mtu
operator|=
name|new_mtu
expr_stmt|;
comment|/* Disable MAC TX/RX */
name|rmi_xlr_mac_set_enable
argument_list|(
name|priv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Flush RX FR IN */
comment|/* Flush TX IN */
name|rmi_xlr_mac_set_enable
argument_list|(
name|priv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|rmi_xlr_mac_fill_rxfr
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|driver_data
modifier|*
name|priv
init|=
operator|&
operator|(
name|sc
operator|->
name|priv
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|dbg_msg
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|init_frin_desc
condition|)
return|return
name|ret
return|;
name|priv
operator|->
name|init_frin_desc
operator|=
literal|0
expr_stmt|;
name|dbg_msg
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NUM_DESC
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|=
name|get_buf
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
break|break;
block|}
comment|/* Send the free Rx desc to the MAC */
name|xlr_mac_send_fr
argument_list|(
name|priv
argument_list|,
name|vtophys
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|MAX_FRAME_SIZE
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|__inline__
name|void
modifier|*
name|rmi_xlr_config_spill
parameter_list|(
name|xlr_reg_t
modifier|*
name|mmio
parameter_list|,
name|int
name|reg_start_0
parameter_list|,
name|int
name|reg_start_1
parameter_list|,
name|int
name|reg_size
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|uint32_t
name|spill_size
init|=
name|size
decl_stmt|;
name|void
modifier|*
name|spill
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|phys_addr
init|=
literal|0
decl_stmt|;
name|spill
operator|=
name|contigmalloc
argument_list|(
operator|(
name|spill_size
operator|+
name|XLR_CACHELINE_SIZE
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|XLR_CACHELINE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spill
operator|||
operator|(
operator|(
name|vm_offset_t
operator|)
name|spill
operator|&
operator|(
name|XLR_CACHELINE_SIZE
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"Unable to allocate memory for spill area!\n"
argument_list|)
expr_stmt|;
block|}
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|spill
argument_list|)
expr_stmt|;
name|dbg_msg
argument_list|(
literal|"Allocate spill %d bytes at %jx\n"
argument_list|,
name|size
argument_list|,
operator|(
name|uintmax_t
operator|)
name|phys_addr
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|reg_start_0
argument_list|,
operator|(
name|phys_addr
operator|>>
literal|5
operator|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|reg_start_1
argument_list|,
operator|(
name|phys_addr
operator|>>
literal|37
operator|)
operator|&
literal|0x07
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
name|reg_size
argument_list|,
name|spill_size
argument_list|)
expr_stmt|;
return|return
name|spill
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rmi_xlr_config_spill_area
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
block|{
comment|/* 	 * if driver initialization is done parallely on multiple cpus 	 * spill_configured needs synchronization 	 */
if|if
condition|(
name|priv
operator|->
name|spill_configured
condition|)
return|return;
if|if
condition|(
name|priv
operator|->
name|type
operator|==
name|XLR_GMAC
operator|&&
name|priv
operator|->
name|instance
operator|%
literal|4
operator|!=
literal|0
condition|)
block|{
name|priv
operator|->
name|spill_configured
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|priv
operator|->
name|spill_configured
operator|=
literal|1
expr_stmt|;
name|priv
operator|->
name|frin_spill
operator|=
name|rmi_xlr_config_spill
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_REG_FRIN_SPILL_MEM_START_0
argument_list|,
name|R_REG_FRIN_SPILL_MEM_START_1
argument_list|,
name|R_REG_FRIN_SPILL_MEM_SIZE
argument_list|,
name|MAX_FRIN_SPILL
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fr_desc
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|class_0_spill
operator|=
name|rmi_xlr_config_spill
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_CLASS0_SPILL_MEM_START_0
argument_list|,
name|R_CLASS0_SPILL_MEM_START_1
argument_list|,
name|R_CLASS0_SPILL_MEM_SIZE
argument_list|,
name|MAX_CLASS_0_SPILL
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|rx_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|class_1_spill
operator|=
name|rmi_xlr_config_spill
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_CLASS1_SPILL_MEM_START_0
argument_list|,
name|R_CLASS1_SPILL_MEM_START_1
argument_list|,
name|R_CLASS1_SPILL_MEM_SIZE
argument_list|,
name|MAX_CLASS_1_SPILL
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|rx_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|frout_spill
operator|=
name|rmi_xlr_config_spill
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_FROUT_SPILL_MEM_START_0
argument_list|,
name|R_FROUT_SPILL_MEM_START_1
argument_list|,
name|R_FROUT_SPILL_MEM_SIZE
argument_list|,
name|MAX_FROUT_SPILL
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fr_desc
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|class_2_spill
operator|=
name|rmi_xlr_config_spill
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_CLASS2_SPILL_MEM_START_0
argument_list|,
name|R_CLASS2_SPILL_MEM_START_1
argument_list|,
name|R_CLASS2_SPILL_MEM_SIZE
argument_list|,
name|MAX_CLASS_2_SPILL
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|rx_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|class_3_spill
operator|=
name|rmi_xlr_config_spill
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_CLASS3_SPILL_MEM_START_0
argument_list|,
name|R_CLASS3_SPILL_MEM_START_1
argument_list|,
name|R_CLASS3_SPILL_MEM_SIZE
argument_list|,
name|MAX_CLASS_3_SPILL
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|rx_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|spill_configured
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************  * Write the MAC address to the XLR registers  * All 4 addresses are the same for now  *****************************************************************/
end_comment

begin_function
specifier|static
name|void
name|xlr_mac_setup_hwaddr
parameter_list|(
name|struct
name|driver_data
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|rge_softc
modifier|*
name|sc
init|=
name|priv
operator|->
name|sc
decl_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_MAC_ADDR0
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|dev_addr
index|[
literal|5
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sc
operator|->
name|dev_addr
index|[
literal|4
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sc
operator|->
name|dev_addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|sc
operator|->
name|dev_addr
index|[
literal|2
index|]
operator|)
operator|)
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_MAC_ADDR0
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|dev_addr
index|[
literal|1
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sc
operator|->
name|dev_addr
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator|)
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_MAC_ADDR_MASK2
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_MAC_ADDR_MASK2
operator|+
literal|1
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_MAC_ADDR_MASK3
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_MAC_ADDR_MASK3
operator|+
literal|1
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|priv
operator|->
name|mmio
argument_list|,
name|R_MAC_FILTER_CONFIG
argument_list|,
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__BROADCAST_EN
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__ALL_MCAST_EN
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__MAC_ADDR0_VALID
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************  * Read the MAC address from the XLR registers  * All 4 addresses are the same for now  *****************************************************************/
end_comment

begin_function
specifier|static
name|void
name|xlr_mac_get_hwaddr
parameter_list|(
name|struct
name|rge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|driver_data
modifier|*
name|priv
init|=
operator|&
operator|(
name|sc
operator|->
name|priv
operator|)
decl_stmt|;
name|sc
operator|->
name|dev_addr
index|[
literal|0
index|]
operator|=
operator|(
name|xlr_boot1_info
operator|.
name|mac_addr
operator|>>
literal|40
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|dev_addr
index|[
literal|1
index|]
operator|=
operator|(
name|xlr_boot1_info
operator|.
name|mac_addr
operator|>>
literal|32
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|dev_addr
index|[
literal|2
index|]
operator|=
operator|(
name|xlr_boot1_info
operator|.
name|mac_addr
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|dev_addr
index|[
literal|3
index|]
operator|=
operator|(
name|xlr_boot1_info
operator|.
name|mac_addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|dev_addr
index|[
literal|4
index|]
operator|=
operator|(
name|xlr_boot1_info
operator|.
name|mac_addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|dev_addr
index|[
literal|5
index|]
operator|=
operator|(
operator|(
name|xlr_boot1_info
operator|.
name|mac_addr
operator|>>
literal|0
operator|)
operator|&
literal|0xff
operator|)
operator|+
name|priv
operator|->
name|instance
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************  * Mac Module Initialization  *****************************************************************/
end_comment

begin_function
specifier|static
name|void
name|mac_common_init
parameter_list|(
name|void
parameter_list|)
block|{
name|init_p2d_allocation
argument_list|()
expr_stmt|;
name|init_tx_ring
argument_list|()
expr_stmt|;
if|if
condition|(
name|xlr_board_info
operator|.
name|is_xls
condition|)
block|{
if|if
condition|(
name|register_msgring_handler
argument_list|(
name|MSGRNG_STNID_GMAC
argument_list|,
name|MSGRNG_STNID_GMAC
operator|+
literal|1
argument_list|,
name|rmi_xlr_mac_msgring_handler
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Couldn't register msgring handler\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|register_msgring_handler
argument_list|(
name|MSGRNG_STNID_GMAC1
argument_list|,
name|MSGRNG_STNID_GMAC1
operator|+
literal|1
argument_list|,
name|rmi_xlr_mac_msgring_handler
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Couldn't register msgring handler\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|register_msgring_handler
argument_list|(
name|MSGRNG_STNID_GMAC
argument_list|,
name|MSGRNG_STNID_GMAC
operator|+
literal|1
argument_list|,
name|rmi_xlr_mac_msgring_handler
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Couldn't register msgring handler\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Not yet if (xlr_board_atx_ii()) { if (register_msgring_handler 	 * (TX_STN_XGS_0, rmi_xlr_mac_msgring_handler, NULL)) { 	 * panic("Couldn't register msgring handler for TX_STN_XGS_0\n"); } 	 * if (register_msgring_handler (TX_STN_XGS_1, 	 * rmi_xlr_mac_msgring_handler, NULL)) { panic("Couldn't register 	 * msgring handler for TX_STN_XGS_1\n"); } } 	 */
block|}
end_function

end_unit

