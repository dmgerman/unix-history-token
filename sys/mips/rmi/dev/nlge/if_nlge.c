begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2009 RMI Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of RMI Corporation, nor the names of its contributors,  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * RMI_BSD */
end_comment

begin_comment
comment|/*  * The XLR device supports upto four 10/100/1000 Ethernet MACs and upto  * two 10G Ethernet MACs (of XGMII). Alternatively, each 10G port can used  * as a SPI-4 interface, with 8 ports per such interface. The MACs are  * encapsulated in another hardware block referred to as network accelerator,  * such that there are three instances of these in a XLR. One of them controls  * the four 1G RGMII ports while one each of the others controls an XGMII port.  * Enabling MACs requires configuring the corresponding network accelerator  * and the individual port.  * The XLS device supports upto 8 10/100/1000 Ethernet MACs or max 2 10G  * Ethernet MACs. The 1G MACs are of SGMII and 10G MACs are of XAUI  * interface. These ports are part of two network accelerators.  * The nlge driver configures and initializes non-SPI4 Ethernet ports in the  * XLR/XLS devices and enables data transfer on them.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_define
define|#
directive|define
name|__RMAN_RESOURCE_VISIBLE
end_define

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/mips_opcode.h>
end_include

begin_include
include|#
directive|include
file|<machine/asm.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpuregs.h>
end_include

begin_include
include|#
directive|include
file|<machine/param.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/msgring.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/iomap.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/pic.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/board.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/rmi_mips_exts.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/rmi_boot_info.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/dev/xlr/atx_cpld.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/dev/xlr/xgmac_mdio.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|"miidevs.h"
end_include

begin_include
include|#
directive|include
file|<dev/mii/brgphyreg.h>
end_include

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_include
include|#
directive|include
file|<mips/rmi/dev/nlge/if_nlge.h>
end_include

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nlna
argument_list|,
name|nlge
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nlge
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nlge
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Network accelarator entry points */
end_comment

begin_function_decl
specifier|static
name|int
name|nlna_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlna_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlna_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlna_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlna_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlna_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* GMAC port entry points */
end_comment

begin_function_decl
specifier|static
name|int
name|nlge_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlge_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlge_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlge_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlge_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_rx
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|,
name|vm_paddr_t
name|paddr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlge_mii_write
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlge_mii_read
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_mac_mii_statchg
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlge_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Other internal/helper functions */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|get_buf
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_add_to_port_set
parameter_list|(
name|struct
name|nlge_port_set
modifier|*
name|pset
parameter_list|,
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_config_pde
parameter_list|(
name|struct
name|nlna_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_config_parser
parameter_list|(
name|struct
name|nlna_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_config_classifier
parameter_list|(
name|struct
name|nlna_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_config_fifo_spill_area
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_config_translate_table
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_config_common
parameter_list|(
name|struct
name|nlna_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_disable_ports
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_enable_intr
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_disable_intr
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_enable_ports
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_get_all_softc
parameter_list|(
name|device_t
name|iodi_dev
parameter_list|,
name|struct
name|nlna_softc
modifier|*
modifier|*
name|sc_vec
parameter_list|,
name|uint32_t
name|vec_sz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_hw_init
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlna_is_last_active_na
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_media_specific_config
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_reset_ports
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|xlr_gmac_block_t
modifier|*
name|blk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|nlna_softc
modifier|*
name|nlna_sc_init
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|xlr_gmac_block_t
modifier|*
name|blk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_setup_intr
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_smp_update_pde
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlna_submit_rx_free_desc
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|n_desc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlge_gmac_config_speed
parameter_list|(
name|struct
name|nlge_softc
modifier|*
parameter_list|,
name|int
name|quick
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_hw_init
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlge_if_init
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlge_irq_init
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_irq_fini
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_media_specific_init
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_mii_init
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlge_mii_read_internal
parameter_list|(
name|xlr_reg_t
modifier|*
name|mii_base
parameter_list|,
name|int
name|phyaddr
parameter_list|,
name|int
name|regidx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_mii_write_internal
parameter_list|(
name|xlr_reg_t
modifier|*
name|mii_base
parameter_list|,
name|int
name|phyaddr
parameter_list|,
name|int
name|regidx
parameter_list|,
name|int
name|regval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|nlge_msgring_handler
parameter_list|(
name|int
name|bucket
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|stid
parameter_list|,
name|struct
name|msgrng_msg
modifier|*
name|msg
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_port_disable
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_port_enable
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_read_mac_addr
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_sc_init
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|struct
name|xlr_gmac_port
modifier|*
name|port_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_set_mac_addr
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_set_port_attribs
parameter_list|(
name|struct
name|nlge_softc
modifier|*
parameter_list|,
name|struct
name|xlr_gmac_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_mac_set_rx_mode
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_sgmii_init
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlge_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|prepare_fmn_message
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|msgrng_msg
modifier|*
name|msg
parameter_list|,
name|uint32_t
modifier|*
name|n_entries
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|,
name|uint64_t
name|fr_stid
parameter_list|,
name|struct
name|nlge_tx_desc
modifier|*
modifier|*
name|tx_desc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_tx_desc
parameter_list|(
name|vm_paddr_t
name|phy_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|send_fmn_msg_tx
parameter_list|(
name|struct
name|nlge_softc
modifier|*
parameter_list|,
name|struct
name|msgrng_msg
modifier|*
parameter_list|,
name|uint32_t
name|n_entries
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nl_tx_q_wakeup
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//#define DEBUG
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|mac_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|PDEBUG
end_undef

begin_define
define|#
directive|define
name|PDEBUG
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|do {\             if (mac_debug) {\                 printf("[%s@%d|%s]: cpu_%d: " fmt, \                 __FILE__, __LINE__, __FUNCTION__,  PCPU_GET(cpuid), ##args);\             }\         } while(0);
end_define

begin_comment
comment|/* Debug/dump functions */
end_comment

begin_function_decl
specifier|static
name|void
name|dump_reg
parameter_list|(
name|xlr_reg_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_gmac_registers
parameter_list|(
name|struct
name|nlge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_na_registers
parameter_list|(
name|xlr_reg_t
modifier|*
name|base
parameter_list|,
name|int
name|port_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_mac_stats
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_mii_regs
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(used
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|dump_mii_data
parameter_list|(
name|struct
name|mii_data
modifier|*
name|mii
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(used
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|dump_board_info
parameter_list|(
name|struct
name|xlr_board_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_pcs_regs
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|,
name|int
name|phy
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|PDEBUG
end_undef

begin_define
define|#
directive|define
name|PDEBUG
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|dump_reg
parameter_list|(
name|a
parameter_list|,
name|o
parameter_list|,
name|n
parameter_list|)
end_define

begin_comment
comment|/* nop */
end_comment

begin_define
define|#
directive|define
name|dump_gmac_registers
parameter_list|(
name|a
parameter_list|)
end_define

begin_comment
comment|/* nop */
end_comment

begin_define
define|#
directive|define
name|dump_na_registers
parameter_list|(
name|a
parameter_list|,
name|p
parameter_list|)
end_define

begin_comment
comment|/* nop */
end_comment

begin_define
define|#
directive|define
name|dump_board_info
parameter_list|(
name|b
parameter_list|)
end_define

begin_comment
comment|/* nop */
end_comment

begin_define
define|#
directive|define
name|dump_mac_stats
parameter_list|(
name|sc
parameter_list|)
end_define

begin_comment
comment|/* nop */
end_comment

begin_define
define|#
directive|define
name|dump_mii_regs
parameter_list|(
name|sc
parameter_list|)
end_define

begin_comment
comment|/* nop */
end_comment

begin_define
define|#
directive|define
name|dump_mii_data
parameter_list|(
name|mii
parameter_list|)
end_define

begin_comment
comment|/* nop */
end_comment

begin_define
define|#
directive|define
name|dump_pcs_regs
parameter_list|(
name|sc
parameter_list|,
name|phy
parameter_list|)
end_define

begin_comment
comment|/* nop */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Wrappers etc. to export the driver entry points. */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|nlna_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|nlna_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|nlna_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|nlna_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|nlna_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|nlna_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|nlna_resume
argument_list|)
block|,
comment|/* bus interface : TBD : what are these for ? */
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bus_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|nlna_driver
init|=
block|{
literal|"nlna"
block|,
name|nlna_methods
block|,
expr|sizeof
operator|(
expr|struct
name|nlna_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|nlna_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|nlge_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|nlge_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|nlge_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|nlge_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|nlge_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|nlge_resume
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|nlge_mii_read
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|nlge_mii_write
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|nlge_mac_mii_statchg
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|nlge_driver
init|=
block|{
literal|"nlge"
block|,
name|nlge_methods
block|,
expr|sizeof
operator|(
expr|struct
name|nlge_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|nlge_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|nlna
argument_list|,
name|iodi
argument_list|,
name|nlna_driver
argument_list|,
name|nlna_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|nlge
argument_list|,
name|nlna
argument_list|,
name|nlge_driver
argument_list|,
name|nlge_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|nlge
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|nl_tx_desc_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tunables. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flow_classification
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.nlge.flow_classification"
argument_list|,
operator|&
name|flow_classification
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|__inline
name|void
name|atomic_incr_long
parameter_list|(
name|unsigned
name|long
modifier|*
name|addr
parameter_list|)
block|{
comment|/* XXX: fix for 64 bit */
name|unsigned
name|int
modifier|*
name|iaddr
init|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|addr
decl_stmt|;
name|xlr_ldaddwu
argument_list|(
literal|1
argument_list|,
name|iaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nlna_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add all attached GMAC/XGMAC ports to the device tree. Port  * configuration is spread in two regions - common configuration  * for all ports in the NA and per-port configuration in MAC-specific  * region. This function does the following:  *  - adds the ports to the device tree  *  - reset the ports  *  - do all the common initialization  *  - invoke bus_generic_attach for per-port configuration  *  - supply initial free rx descriptors to ports  *  - initialize s/w data structures  *  - finally, enable interrupts (only in the last NA).  *  * For reference, sample address space for common and per-port  * registers is given below.  *  * The address map for RNA0 is:                           (typical value)  *  * XLR_IO_BASE +--------------------------------------+   0xbef0_0000  *             |                                      |  *             |                                      |  *             |                                      |  *             |                                      |  *             |                                      |  *             |                                      |  * GMAC0  ---> +--------------------------------------+   0xbef0_c000  *             |                                      |  *             |                                      |  * (common) -> |......................................|   0xbef0_c400  *             |                                      |  *             |   (RGMII/SGMII: common registers)    |  *             |                                      |  * GMAC1  ---> |--------------------------------------|   0xbef0_d000  *             |                                      |  *             |                                      |  * (common) -> |......................................|   0xbef0_d400  *             |                                      |  *             |   (RGMII/SGMII: common registers)    |  *             |                                      |  *             |......................................|  *       and so on ....  *  * Ref: Figure 14-3 and Table 14-1 of XLR PRM  */
end_comment

begin_function
specifier|static
name|int
name|nlna_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xlr_gmac_block_t
modifier|*
name|block_info
decl_stmt|;
name|device_t
name|gmac_dev
decl_stmt|;
name|struct
name|nlna_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|id
decl_stmt|;
name|id
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|block_info
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|block_info
operator|->
name|enabled
condition|)
block|{
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|dump_board_info
argument_list|(
operator|&
name|xlr_board_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize nlna state in softc structure */
name|sc
operator|=
name|nlna_sc_init
argument_list|(
name|dev
argument_list|,
name|block_info
argument_list|)
expr_stmt|;
comment|/* Add device's for the ports controlled by this NA. */
if|if
condition|(
name|block_info
operator|->
name|type
operator|==
name|XLR_GMAC
condition|)
block|{
name|KASSERT
argument_list|(
name|id
operator|<
literal|2
argument_list|,
operator|(
literal|"No GMACs supported with this network"
literal|"accelerator: %d"
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|gmac_dev
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"nlge"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|gmac_dev
argument_list|,
operator|&
name|block_info
operator|->
name|gmac_port
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|block_info
operator|->
name|type
operator|==
name|XLR_XGMAC
condition|)
block|{
name|KASSERT
argument_list|(
name|id
operator|>
literal|0
operator|&&
name|id
operator|<=
literal|2
argument_list|,
operator|(
literal|"No XGMACs supported with this"
literal|"network accelerator: %d"
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
name|gmac_dev
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"nlge"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|gmac_dev
argument_list|,
operator|&
name|block_info
operator|->
name|gmac_port
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|block_info
operator|->
name|type
operator|==
name|XLR_SPI4
condition|)
block|{
comment|/* SPI4 is not supported here */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unsupported: NA with SPI4 type"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|nlna_reset_ports
argument_list|(
name|sc
argument_list|,
name|block_info
argument_list|)
expr_stmt|;
comment|/* Initialize Network Accelarator registers. */
name|nlna_hw_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to attach port(s)\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Send out the initial pool of free-descriptors for the rx path */
name|nlna_submit_rx_free_desc
argument_list|(
name|sc
argument_list|,
name|MAX_FRIN_SPILL
argument_list|)
expr_stmt|;
comment|/* S/w data structure initializations shared by all NA's. */
if|if
condition|(
name|nl_tx_desc_zone
operator|==
name|NULL
condition|)
block|{
comment|/* Create a zone for allocating tx descriptors */
name|nl_tx_desc_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"NL Tx Desc"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlge_tx_desc
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|XLR_CACHELINE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Other per NA s/w initialization */
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|tx_thr
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|tx_thr
argument_list|,
name|hz
argument_list|,
name|nl_tx_q_wakeup
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable NA interrupts */
name|nlna_setup_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nlna_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|nlna_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_is_alive
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|nlna_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* This will make sure that per-port detach is complete 		 * and all traffic on the ports has been stopped. */
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|nl_tx_desc_zone
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nlna_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nlna_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nlna_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* GMAC port entry points */
end_comment

begin_function
specifier|static
name|int
name|nlge_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|nlge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|xlr_gmac_port
modifier|*
name|port_info
decl_stmt|;
name|int
name|index
decl_stmt|;
name|char
modifier|*
name|desc
index|[]
init|=
block|{
literal|"RGMII"
block|,
literal|"SGMII"
block|,
literal|"RGMII/SGMII"
block|,
literal|"XGMAC"
block|,
literal|"XAUI"
block|,
literal|"Unknown"
block|}
decl_stmt|;
name|port_info
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|port_info
operator|->
name|type
operator|<
name|XLR_RGMII
operator|||
name|port_info
operator|->
name|type
operator|>
name|XLR_XAUI
operator|)
condition|?
literal|5
else|:
name|port_info
operator|->
name|type
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|desc
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|nlge_sc_init
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|,
name|port_info
argument_list|)
expr_stmt|;
name|nlge_port_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nlge_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|nlge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|nlna_softc
modifier|*
name|nsc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|nlge_if_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nlge_mii_init
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|nlge_irq_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|nlge_hw_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nsc
operator|=
operator|(
expr|struct
name|nlna_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|nsc
operator|->
name|child_sc
index|[
name|sc
operator|->
name|instance
index|]
operator|=
name|sc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nlge_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|nlge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|nlge_if
expr_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|nlge_port_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nlge_irq_fini
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
condition|)
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nlge_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nlge_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlge_init
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|nlge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|nlge_softc
operator|*
operator|)
name|addr
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|nlge_if
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
name|nlge_gmac_config_speed
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|nlge_port_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_type
operator|==
name|XLR_SGMII
condition|)
block|{
name|dump_pcs_regs
argument_list|(
name|sc
argument_list|,
literal|27
argument_list|)
expr_stmt|;
block|}
name|dump_gmac_registers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dump_mac_stats
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nlge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|nlge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|NLGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|nlge_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|&&
operator|!
operator|(
name|sc
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
name|sc
operator|->
name|if_flags
operator||=
name|IFF_PROMISC
expr_stmt|;
name|nlge_mac_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|sc
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|sc
operator|->
name|if_flags
operator|&=
name|IFF_PROMISC
expr_stmt|;
name|nlge_mac_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|nlge_port_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|NLGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
if|if
condition|(
name|sc
operator|->
name|mii_bus
operator|!=
name|NULL
condition|)
block|{
name|mii
operator|=
operator|(
expr|struct
name|mii_data
operator|*
operator|)
name|device_get_softc
argument_list|(
name|sc
operator|->
name|mii_bus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This function is called from an interrupt handler */
end_comment

begin_function
name|void
name|nlge_msgring_handler
parameter_list|(
name|int
name|bucket
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|stid
parameter_list|,
name|struct
name|msgrng_msg
modifier|*
name|msg
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|nlna_softc
modifier|*
name|na_sc
decl_stmt|;
name|struct
name|nlge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|vm_paddr_t
name|phys_addr
decl_stmt|;
name|uint32_t
name|length
decl_stmt|;
name|int
name|ctrl
decl_stmt|;
name|int
name|tx_error
decl_stmt|;
name|int
name|port
decl_stmt|;
name|int
name|is_p2p
decl_stmt|;
name|is_p2p
operator|=
literal|0
expr_stmt|;
name|tx_error
operator|=
literal|0
expr_stmt|;
name|length
operator|=
operator|(
name|msg
operator|->
name|msg0
operator|>>
literal|40
operator|)
operator|&
literal|0x3fff
expr_stmt|;
name|na_sc
operator|=
operator|(
expr|struct
name|nlna_softc
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|ctrl
operator|=
name|CTRL_REG_FREE
expr_stmt|;
name|phys_addr
operator|=
name|msg
operator|->
name|msg0
operator|&
literal|0xffffffffffULL
expr_stmt|;
name|port
operator|=
operator|(
name|msg
operator|->
name|msg0
operator|>>
literal|54
operator|)
operator|&
literal|0x0f
expr_stmt|;
name|is_p2p
operator|=
operator|(
name|msg
operator|->
name|msg0
operator|>>
literal|62
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tx_error
operator|=
operator|(
name|msg
operator|->
name|msg0
operator|>>
literal|58
operator|)
operator|&
literal|0xf
expr_stmt|;
block|}
else|else
block|{
name|ctrl
operator|=
name|CTRL_SNGL
expr_stmt|;
name|phys_addr
operator|=
name|msg
operator|->
name|msg0
operator|&
literal|0xffffffffe0ULL
expr_stmt|;
name|length
operator|=
name|length
operator|-
name|BYTE_OFFSET
operator|-
name|MAC_CRC_LEN
expr_stmt|;
name|port
operator|=
name|msg
operator|->
name|msg0
operator|&
literal|0x0f
expr_stmt|;
block|}
name|sc
operator|=
name|na_sc
operator|->
name|child_sc
index|[
name|port
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Message (of %d len) with softc=NULL on %d port (type=%s)\n"
argument_list|,
name|length
argument_list|,
name|port
argument_list|,
operator|(
name|ctrl
operator|==
name|CTRL_SNGL
condition|?
literal|"Pkt rx"
else|:
literal|"Freeback for tx packet"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ctrl
operator|==
name|CTRL_REG_FREE
operator|||
name|ctrl
operator|==
name|CTRL_JUMBO_FREE
condition|)
block|{
name|ifp
operator|=
name|sc
operator|->
name|nlge_if
expr_stmt|;
if|if
condition|(
operator|!
name|tx_error
condition|)
block|{
if|if
condition|(
name|is_p2p
condition|)
block|{
name|release_tx_desc
argument_list|(
name|phys_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|__mips_n64
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|xlr_paddr_ld
argument_list|(
name|phys_addr
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|phys_addr
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|NLGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|na_sc
operator|->
name|tx_thr
argument_list|,
name|hz
argument_list|,
name|nl_tx_q_wakeup
argument_list|,
name|na_sc
argument_list|)
expr_stmt|;
block|}
name|NLGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ERROR: Tx fb error (%d) on port %d\n"
argument_list|,
name|tx_error
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|atomic_incr_long
argument_list|(
operator|(
name|tx_error
operator|)
condition|?
operator|&
name|ifp
operator|->
name|if_oerrors
else|:
operator|&
name|ifp
operator|->
name|if_opackets
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctrl
operator|==
name|CTRL_SNGL
operator|||
name|ctrl
operator|==
name|CTRL_START
condition|)
block|{
comment|/* Rx Packet */
name|nlge_rx
argument_list|(
name|sc
argument_list|,
name|phys_addr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|nlna_submit_rx_free_desc
argument_list|(
name|na_sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* return free descr to NA */
block|}
else|else
block|{
name|printf
argument_list|(
literal|"[%s]: unrecognized ctrl=%d!\n"
argument_list|,
name|__func__
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nlge_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|nlge_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
comment|//NLGE_LOCK(sc);
name|nlge_start_locked
argument_list|(
name|ifp
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|//NLGE_UNLOCK(sc);
block|}
end_function

begin_function
specifier|static
name|void
name|nl_tx_q_wakeup
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|nlna_softc
modifier|*
name|na_sc
decl_stmt|;
name|struct
name|nlge_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|na_sc
operator|=
operator|(
expr|struct
name|nlna_softc
operator|*
operator|)
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XLR_MAX_MACS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|=
name|na_sc
operator|->
name|child_sc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
name|nlge_start_locked
argument_list|(
name|sc
operator|->
name|nlge_if
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|na_sc
operator|->
name|tx_thr
argument_list|,
literal|5
operator|*
name|hz
argument_list|,
name|nl_tx_q_wakeup
argument_list|,
name|na_sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlge_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|msgrng_msg
name|msg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|nlge_tx_desc
modifier|*
name|tx_desc
decl_stmt|;
name|uint64_t
name|fr_stid
decl_stmt|;
name|uint32_t
name|cpu
decl_stmt|;
name|uint32_t
name|n_entries
decl_stmt|;
name|uint32_t
name|tid
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|cpu
operator|=
name|xlr_core_id
argument_list|()
expr_stmt|;
name|tid
operator|=
name|xlr_thr_id
argument_list|()
expr_stmt|;
comment|/* H/w threads [0, 2] --> bucket 6 and [1, 3] --> bucket 7 */
name|fr_stid
operator|=
name|cpu
operator|*
literal|8
operator|+
literal|6
operator|+
operator|(
name|tid
operator|%
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
return|return;
block|}
do|do
block|{
comment|/* 		 * First, remove some freeback messages before transmitting 		 * any new packets. However, cap the number of messages 		 * drained to permit this thread to continue with its 		 * transmission. 		 * 		 * Mask for buckets {6, 7} is 0xc0 		 */
name|xlr_msgring_handler
argument_list|(
literal|0xc0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Grab a packet off the queue. */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tx_desc
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|prepare_fmn_message
argument_list|(
name|sc
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|n_entries
argument_list|,
name|m
argument_list|,
name|fr_stid
argument_list|,
operator|&
name|tx_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
name|ret
operator|=
name|send_fmn_msg_tx
argument_list|(
name|sc
argument_list|,
operator|&
name|msg
argument_list|,
name|n_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
return|return;
name|fail
label|:
if|if
condition|(
name|tx_desc
operator|!=
name|NULL
condition|)
block|{
name|uma_zfree
argument_list|(
name|nl_tx_desc_zone
argument_list|,
name|tx_desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|NLGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|NLGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|atomic_incr_long
argument_list|(
operator|&
name|ifp
operator|->
name|if_iqdrops
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|nlge_rx
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|,
name|vm_paddr_t
name|paddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint64_t
name|tm
decl_stmt|,
name|mag
decl_stmt|;
name|uint32_t
name|sr
decl_stmt|;
name|sr
operator|=
name|xlr_enable_kx
argument_list|()
expr_stmt|;
name|tm
operator|=
name|xlr_paddr_ld
argument_list|(
name|paddr
operator|-
name|XLR_CACHELINE_SIZE
argument_list|)
expr_stmt|;
name|mag
operator|=
name|xlr_paddr_ld
argument_list|(
name|paddr
operator|-
name|XLR_CACHELINE_SIZE
operator|+
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|xlr_restore_kx
argument_list|(
name|sr
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|tm
expr_stmt|;
if|if
condition|(
name|mag
operator|!=
literal|0xf00bad
condition|)
block|{
comment|/* somebody else's packet. Error - FIXME in intialization */
name|printf
argument_list|(
literal|"cpu %d: *ERROR* Not my packet paddr %jx\n"
argument_list|,
name|xlr_core_id
argument_list|()
argument_list|,
operator|(
name|uintmax_t
operator|)
name|paddr
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
name|sc
operator|->
name|nlge_if
expr_stmt|;
comment|/* align the data */
name|m
operator|->
name|m_data
operator|+=
name|BYTE_OFFSET
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|atomic_incr_long
argument_list|(
operator|&
name|ifp
operator|->
name|if_ipackets
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nlge_mii_write
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|int
name|phyaddr
parameter_list|,
name|int
name|regidx
parameter_list|,
name|int
name|regval
parameter_list|)
block|{
name|struct
name|nlge_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|phy_addr
operator|==
name|phyaddr
operator|&&
name|sc
operator|->
name|port_type
operator|!=
name|XLR_XGMII
condition|)
name|nlge_mii_write_internal
argument_list|(
name|sc
operator|->
name|mii_base
argument_list|,
name|phyaddr
argument_list|,
name|regidx
argument_list|,
name|regval
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nlge_mii_read
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|int
name|phyaddr
parameter_list|,
name|int
name|regidx
parameter_list|)
block|{
name|struct
name|nlge_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|val
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|sc
operator|->
name|phy_addr
operator|!=
name|phyaddr
operator|&&
name|sc
operator|->
name|port_type
operator|!=
name|XLR_XGMII
operator|)
condition|?
operator|(
literal|0xffff
operator|)
else|:
name|nlge_mii_read_internal
argument_list|(
name|sc
operator|->
name|mii_base
argument_list|,
name|phyaddr
argument_list|,
name|regidx
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlge_mac_mii_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|nlge_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlge_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|nlge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|md
decl_stmt|;
name|md
operator|=
name|NULL
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mii_bus
condition|)
name|md
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|mii_bus
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link
operator|==
name|xlr_mac_link_down
condition|)
return|return;
if|if
condition|(
name|md
operator|!=
name|NULL
condition|)
name|ifmr
operator|->
name|ifm_active
operator|=
name|md
operator|->
name|mii_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|nlna_softc
modifier|*
name|nlna_sc_init
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|xlr_gmac_block_t
modifier|*
name|blk
parameter_list|)
block|{
name|struct
name|nlna_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nlna_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|base
operator|=
name|xlr_io_mmio
argument_list|(
name|blk
operator|->
name|baseaddr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rfrbucket
operator|=
name|blk
operator|->
name|station_rfr
expr_stmt|;
name|sc
operator|->
name|station_id
operator|=
name|blk
operator|->
name|station_id
expr_stmt|;
name|sc
operator|->
name|na_type
operator|=
name|blk
operator|->
name|type
expr_stmt|;
name|sc
operator|->
name|mac_type
operator|=
name|blk
operator|->
name|mode
expr_stmt|;
name|sc
operator|->
name|num_ports
operator|=
name|blk
operator|->
name|num_ports
expr_stmt|;
name|sc
operator|->
name|mdio_set
operator|.
name|port_vec
operator|=
name|sc
operator|->
name|mdio_sc
expr_stmt|;
name|sc
operator|->
name|mdio_set
operator|.
name|vec_sz
operator|=
name|XLR_MAX_MACS
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do:  *     - Initialize common GMAC registers (index range 0x100-0x3ff).  */
end_comment

begin_function
specifier|static
name|void
name|nlna_hw_init
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Register message ring handler for the NA block, messages from 	 * the GMAC will have source station id to the first bucket of the  	 * NA FMN station, so register just that station id. 	 */
if|if
condition|(
name|register_msgring_handler
argument_list|(
name|sc
operator|->
name|station_id
argument_list|,
name|sc
operator|->
name|station_id
operator|+
literal|1
argument_list|,
name|nlge_msgring_handler
argument_list|,
name|sc
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Couldn't register msgring handler\n"
argument_list|)
expr_stmt|;
block|}
name|nlna_config_fifo_spill_area
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nlna_config_pde
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nlna_config_common
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nlna_config_parser
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nlna_config_classifier
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enable interrupts on all the ports controlled by this NA. For now, we  * only care about the MII interrupt and this has to be enabled only  * on the port id0.  *  * This function is not in-sync with the regular way of doing things - it  * executes only in the context of the last active network accelerator (and  * thereby has some ugly accesses in the device tree). Though inelegant, it  * is necessary to do it this way as the per-port interrupts can be  * setup/enabled only after all the network accelerators have been  * initialized.  */
end_comment

begin_function
specifier|static
name|void
name|nlna_setup_intr
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|nlna_softc
modifier|*
name|na_sc
index|[
name|XLR_MAX_NLNA
index|]
decl_stmt|;
name|struct
name|nlge_port_set
modifier|*
name|pset
decl_stmt|;
name|struct
name|xlr_gmac_port
modifier|*
name|port_info
decl_stmt|;
name|device_t
name|iodi_dev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|nlna_is_last_active_na
argument_list|(
name|sc
argument_list|)
condition|)
return|return ;
comment|/* Collect all nlna softc pointers */
name|memset
argument_list|(
name|na_sc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|na_sc
argument_list|)
operator|*
name|XLR_MAX_NLNA
argument_list|)
expr_stmt|;
name|iodi_dev
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|nlna_dev
argument_list|)
expr_stmt|;
name|nlna_get_all_softc
argument_list|(
name|iodi_dev
argument_list|,
name|na_sc
argument_list|,
name|XLR_MAX_NLNA
argument_list|)
expr_stmt|;
comment|/* Setup the MDIO interrupt lists. */
comment|/* 	 * MDIO interrupts are coarse - a single interrupt line provides 	 * information about one of many possible ports. To figure out the 	 * exact port on which action is to be taken, all of the ports 	 * linked to an MDIO interrupt should be read. To enable this, 	 * ports need to add themselves to port sets. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XLR_MAX_NLNA
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|na_sc
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|na_sc
index|[
name|i
index|]
operator|->
name|num_ports
condition|;
name|j
operator|++
control|)
block|{
comment|/* processing j-th port on i-th NA */
name|port_info
operator|=
name|device_get_ivars
argument_list|(
name|na_sc
index|[
name|i
index|]
operator|->
name|child_sc
index|[
name|j
index|]
operator|->
name|nlge_dev
argument_list|)
expr_stmt|;
name|pset
operator|=
operator|&
name|na_sc
index|[
name|port_info
operator|->
name|mdint_id
index|]
operator|->
name|mdio_set
expr_stmt|;
name|nlna_add_to_port_set
argument_list|(
name|pset
argument_list|,
name|na_sc
index|[
name|i
index|]
operator|->
name|child_sc
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Enable interrupts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XLR_MAX_NLNA
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|na_sc
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|na_sc
index|[
name|i
index|]
operator|->
name|na_type
operator|!=
name|XLR_XGMAC
condition|)
block|{
name|nlna_enable_intr
argument_list|(
name|na_sc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nlna_add_to_port_set
parameter_list|(
name|struct
name|nlge_port_set
modifier|*
name|pset
parameter_list|,
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* step past the non-NULL elements */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pset
operator|->
name|vec_sz
operator|&&
name|pset
operator|->
name|port_vec
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
name|pset
operator|->
name|vec_sz
condition|)
name|pset
operator|->
name|port_vec
index|[
name|i
index|]
operator|=
name|sc
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"warning: internal error: out-of-bounds for MDIO array"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlna_enable_intr
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|child_sc
index|[
name|i
index|]
operator|->
name|instance
operator|==
literal|0
condition|)
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|child_sc
index|[
name|i
index|]
operator|->
name|base
argument_list|,
name|R_INTMASK
argument_list|,
operator|(
literal|1
operator|<<
name|O_INTMASK__MDInt
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nlna_disable_intr
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|child_sc
index|[
name|i
index|]
operator|->
name|instance
operator|==
literal|0
condition|)
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|child_sc
index|[
name|i
index|]
operator|->
name|base
argument_list|,
name|R_INTMASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nlna_is_last_active_na
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|id
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|nlna_dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|id
operator|==
literal|2
operator|||
name|xlr_board_info
operator|.
name|gmac_block
index|[
name|id
operator|+
literal|1
index|]
operator|.
name|enabled
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlna_submit_rx_free_desc
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|n_desc
parameter_list|)
block|{
name|struct
name|msgrng_msg
name|msg
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|uint32_t
name|msgrng_flags
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|stid
decl_stmt|,
name|ret
decl_stmt|,
name|code
decl_stmt|;
if|if
condition|(
name|n_desc
operator|>
literal|1
condition|)
block|{
name|PDEBUG
argument_list|(
literal|"Sending %d free-in descriptors to station=%d\n"
argument_list|,
name|n_desc
argument_list|,
name|sc
operator|->
name|rfrbucket
argument_list|)
expr_stmt|;
block|}
name|stid
operator|=
name|sc
operator|->
name|rfrbucket
expr_stmt|;
name|code
operator|=
operator|(
name|sc
operator|->
name|na_type
operator|==
name|XLR_XGMAC
operator|)
condition|?
name|MSGRNG_CODE_XGMAC
else|:
name|MSGRNG_CODE_MAC
expr_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_desc
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|=
name|get_buf
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|nlna_dev
argument_list|,
literal|"Cannot allocate mbuf\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Send the free Rx desc to the MAC */
name|msg
operator|.
name|msg0
operator|=
name|vtophys
argument_list|(
name|ptr
argument_list|)
operator|&
literal|0xffffffffe0ULL
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|msgrng_flags
operator|=
name|msgrng_access_enable
argument_list|()
expr_stmt|;
name|ret
operator|=
name|message_send
argument_list|(
literal|1
argument_list|,
name|code
argument_list|,
name|stid
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
name|msgrng_restore
argument_list|(
name|msgrng_flags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|n
operator|++
operator|<
literal|100000
argument_list|,
operator|(
literal|"Too many credit fails in rx path\n"
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|!=
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline__
name|void
modifier|*
name|nlna_config_spill
parameter_list|(
name|xlr_reg_t
modifier|*
name|base
parameter_list|,
name|int
name|reg_start_0
parameter_list|,
name|int
name|reg_start_1
parameter_list|,
name|int
name|reg_size
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|void
modifier|*
name|spill
decl_stmt|;
name|uint64_t
name|phys_addr
decl_stmt|;
name|uint32_t
name|spill_size
decl_stmt|;
name|spill_size
operator|=
name|size
expr_stmt|;
name|spill
operator|=
name|contigmalloc
argument_list|(
operator|(
name|spill_size
operator|+
name|XLR_CACHELINE_SIZE
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|XLR_CACHELINE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|spill
operator|==
name|NULL
operator|||
operator|(
operator|(
name|vm_offset_t
operator|)
name|spill
operator|&
operator|(
name|XLR_CACHELINE_SIZE
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"Unable to allocate memory for spill area!\n"
argument_list|)
expr_stmt|;
block|}
name|phys_addr
operator|=
name|vtophys
argument_list|(
name|spill
argument_list|)
expr_stmt|;
name|PDEBUG
argument_list|(
literal|"Allocated spill %d bytes at %llx\n"
argument_list|,
name|size
argument_list|,
name|phys_addr
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|base
argument_list|,
name|reg_start_0
argument_list|,
operator|(
name|phys_addr
operator|>>
literal|5
operator|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|base
argument_list|,
name|reg_start_1
argument_list|,
operator|(
name|phys_addr
operator|>>
literal|37
operator|)
operator|&
literal|0x07
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|base
argument_list|,
name|reg_size
argument_list|,
name|spill_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|spill
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Configure the 6 FIFO's that are used by the network accelarator to  * communicate with the rest of the XLx device. 4 of the FIFO's are for  * packets from NA --> cpu (called Class FIFO's) and 2 are for feeding  * the NA with free descriptors.  */
end_comment

begin_function
specifier|static
name|void
name|nlna_config_fifo_spill_area
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|frin_spill
operator|=
name|nlna_config_spill
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_REG_FRIN_SPILL_MEM_START_0
argument_list|,
name|R_REG_FRIN_SPILL_MEM_START_1
argument_list|,
name|R_REG_FRIN_SPILL_MEM_SIZE
argument_list|,
name|MAX_FRIN_SPILL
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fr_desc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|frout_spill
operator|=
name|nlna_config_spill
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_FROUT_SPILL_MEM_START_0
argument_list|,
name|R_FROUT_SPILL_MEM_START_1
argument_list|,
name|R_FROUT_SPILL_MEM_SIZE
argument_list|,
name|MAX_FROUT_SPILL
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fr_desc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|class_0_spill
operator|=
name|nlna_config_spill
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_CLASS0_SPILL_MEM_START_0
argument_list|,
name|R_CLASS0_SPILL_MEM_START_1
argument_list|,
name|R_CLASS0_SPILL_MEM_SIZE
argument_list|,
name|MAX_CLASS_0_SPILL
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|rx_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|class_1_spill
operator|=
name|nlna_config_spill
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_CLASS1_SPILL_MEM_START_0
argument_list|,
name|R_CLASS1_SPILL_MEM_START_1
argument_list|,
name|R_CLASS1_SPILL_MEM_SIZE
argument_list|,
name|MAX_CLASS_1_SPILL
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|rx_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|class_2_spill
operator|=
name|nlna_config_spill
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_CLASS2_SPILL_MEM_START_0
argument_list|,
name|R_CLASS2_SPILL_MEM_START_1
argument_list|,
name|R_CLASS2_SPILL_MEM_SIZE
argument_list|,
name|MAX_CLASS_2_SPILL
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|rx_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|class_3_spill
operator|=
name|nlna_config_spill
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_CLASS3_SPILL_MEM_START_0
argument_list|,
name|R_CLASS3_SPILL_MEM_START_1
argument_list|,
name|R_CLASS3_SPILL_MEM_SIZE
argument_list|,
name|MAX_CLASS_3_SPILL
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|rx_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the CPU buckets that receive packets from the NA class FIFOs. */
end_comment

begin_function
specifier|static
name|void
name|nlna_config_pde
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint64_t
name|bucket_map
decl_stmt|;
name|uint32_t
name|cpumask
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cpu
decl_stmt|,
name|bucket
decl_stmt|;
name|cpumask
operator|=
literal|0x1
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/*          * rge may be called before SMP start in a BOOTP/NFSROOT          * setup. we will distribute packets to other cpus only when          * the SMP is started. 	 */
if|if
condition|(
name|smp_started
condition|)
name|cpumask
operator|=
name|xlr_hw_thread_mask
expr_stmt|;
endif|#
directive|endif
name|bucket_map
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cpumask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|cpu
operator|=
name|i
expr_stmt|;
comment|/* use bucket 0 and 1 on every core for NA msgs */
name|bucket
operator|=
name|cpu
operator|/
literal|4
operator|*
literal|8
expr_stmt|;
name|bucket_map
operator||=
operator|(
literal|3ULL
operator|<<
name|bucket
operator|)
expr_stmt|;
block|}
block|}
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_PDE_CLASS_0
argument_list|,
operator|(
name|bucket_map
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_PDE_CLASS_0
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|bucket_map
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_PDE_CLASS_1
argument_list|,
operator|(
name|bucket_map
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_PDE_CLASS_1
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|bucket_map
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_PDE_CLASS_2
argument_list|,
operator|(
name|bucket_map
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_PDE_CLASS_2
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|bucket_map
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_PDE_CLASS_3
argument_list|,
operator|(
name|bucket_map
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_PDE_CLASS_3
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|bucket_map
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the network accelerator packet distribution engine for SMP.  * On bootup, we have just the boot hw thread handling all packets, on SMP  * start, we can start distributing packets across all the cores which are up.  */
end_comment

begin_function
specifier|static
name|void
name|nlna_smp_update_pde
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|device_t
name|iodi_dev
decl_stmt|;
name|struct
name|nlna_softc
modifier|*
name|na_sc
index|[
name|XLR_MAX_NLNA
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"Updating packet distribution for SMP\n"
argument_list|)
expr_stmt|;
name|iodi_dev
operator|=
name|devclass_get_device
argument_list|(
name|devclass_find
argument_list|(
literal|"iodi"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nlna_get_all_softc
argument_list|(
name|iodi_dev
argument_list|,
name|na_sc
argument_list|,
name|XLR_MAX_NLNA
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XLR_MAX_NLNA
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|na_sc
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|nlna_disable_ports
argument_list|(
name|na_sc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nlna_config_pde
argument_list|(
name|na_sc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nlna_config_translate_table
argument_list|(
name|na_sc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nlna_enable_ports
argument_list|(
name|na_sc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|nlna_smp_update_pde
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|nlna_smp_update_pde
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|nlna_config_translate_table
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|cpu_mask
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|bkts
index|[
literal|32
index|]
decl_stmt|;
comment|/* one bucket is assumed for each cpu */
name|int
name|b1
decl_stmt|,
name|b2
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|use_bkt
decl_stmt|;
if|if
condition|(
operator|!
name|flow_classification
condition|)
return|return;
name|use_bkt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|smp_started
condition|)
name|cpu_mask
operator|=
name|xlr_hw_thread_mask
expr_stmt|;
else|else
return|return;
name|printf
argument_list|(
literal|"Using %s-based distribution\n"
argument_list|,
operator|(
name|use_bkt
operator|)
condition|?
literal|"bucket"
else|:
literal|"class"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&
name|cpu_mask
condition|)
block|{
comment|/* for each cpu, mark the 4+threadid bucket */
name|bkts
index|[
name|j
index|]
operator|=
operator|(
operator|(
name|i
operator|/
literal|4
operator|)
operator|*
literal|8
operator|)
operator|+
operator|(
name|i
operator|%
literal|4
operator|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
comment|/*configure the 128 * 9 Translation table to send to available buckets*/
name|k
operator|=
literal|0
expr_stmt|;
name|c1
operator|=
literal|3
expr_stmt|;
name|c2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get the next 2 pairs of (class, bucket): 		   (c1, b1), (c2, b2).   		   c1, c2 limited to {0, 1, 2, 3}  		       i.e, the 4 classes defined by h/w 		   b1, b2 limited to { bkts[i], where 0<= i< j} 		       i.e, the set of buckets computed in the 		       above loop. 		*/
name|c1
operator|=
operator|(
name|c1
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
name|c2
operator|=
operator|(
name|c1
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
name|b1
operator|=
name|bkts
index|[
name|k
index|]
expr_stmt|;
name|k
operator|=
operator|(
name|k
operator|+
literal|1
operator|)
operator|%
name|j
expr_stmt|;
name|b2
operator|=
name|bkts
index|[
name|k
index|]
expr_stmt|;
name|k
operator|=
operator|(
name|k
operator|+
literal|1
operator|)
operator|%
name|j
expr_stmt|;
name|PDEBUG
argument_list|(
literal|"Translation table[%d] b1=%d b2=%d c1=%d c2=%d\n"
argument_list|,
name|i
argument_list|,
name|b1
argument_list|,
name|b2
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|c1
operator|<<
literal|23
operator|)
operator||
operator|(
name|b1
operator|<<
literal|17
operator|)
operator||
operator|(
name|use_bkt
operator|<<
literal|16
operator|)
operator||
operator|(
name|c2
operator|<<
literal|7
operator|)
operator||
operator|(
name|b2
operator|<<
literal|1
operator|)
operator||
operator|(
name|use_bkt
operator|<<
literal|0
operator|)
operator|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_TRANSLATETABLE
operator|+
name|i
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|c1
operator|=
name|c2
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nlna_config_parser
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
comment|/* 	 * Mark it as ETHERNET type. 	 */
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_L2TYPE_0
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flow_classification
condition|)
return|return;
comment|/* Use 7bit CRChash for flow classification with 127 as CRC polynomial*/
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_PARSERCONFIGREG
argument_list|,
operator|(
operator|(
literal|0x7f
operator|<<
literal|8
operator|)
operator||
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* configure the parser : L2 Type is configured in the bootloader */
comment|/* extract IP: src, dest protocol */
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_L3CTABLE
argument_list|,
operator|(
literal|9
operator|<<
literal|20
operator|)
operator||
operator|(
literal|1
operator|<<
literal|19
operator|)
operator||
operator|(
literal|1
operator|<<
literal|18
operator|)
operator||
operator|(
literal|0x01
operator|<<
literal|16
operator|)
operator||
operator|(
literal|0x0800
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_L3CTABLE
operator|+
literal|1
argument_list|,
operator|(
literal|9
operator|<<
literal|25
operator|)
operator||
operator|(
literal|1
operator|<<
literal|21
operator|)
operator||
operator|(
literal|12
operator|<<
literal|14
operator|)
operator||
operator|(
literal|4
operator|<<
literal|10
operator|)
operator||
operator|(
literal|16
operator|<<
literal|4
operator|)
operator||
literal|4
argument_list|)
expr_stmt|;
comment|/* Configure to extract SRC port and Dest port for TCP and UDP pkts */
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_L4CTABLE
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_L4CTABLE
operator|+
literal|2
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
literal|0
operator|<<
literal|21
operator|)
operator||
operator|(
literal|2
operator|<<
literal|17
operator|)
operator||
operator|(
literal|2
operator|<<
literal|11
operator|)
operator||
operator|(
literal|2
operator|<<
literal|7
operator|)
operator|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_L4CTABLE
operator|+
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_L4CTABLE
operator|+
literal|3
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlna_config_classifier
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mac_type
operator|==
name|XLR_XGMII
condition|)
block|{
comment|/* TBD: XGMII init sequence */
comment|/* xgmac translation table doesn't have sane values on reset */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_TRANSLATETABLE
operator|+
name|i
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* 		 * use upper 7 bits of the parser extract to index the 		 * translate table 		 */
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_PARSERCONFIGREG
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Complete a bunch of h/w register initializations that are common for all the  * ports controlled by a NA.  */
end_comment

begin_function
specifier|static
name|void
name|nlna_config_common
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|xlr_gmac_block_t
modifier|*
name|block_info
decl_stmt|;
name|struct
name|stn_cc
modifier|*
name|gmac_cc_config
decl_stmt|;
name|int
name|i
decl_stmt|;
name|block_info
operator|=
name|device_get_ivars
argument_list|(
name|sc
operator|->
name|nlna_dev
argument_list|)
expr_stmt|;
name|gmac_cc_config
operator|=
name|block_info
operator|->
name|credit_config
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NUM_MSGRNG_STN_CC
condition|;
name|i
operator|++
control|)
block|{
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_CC_CPU0_0
operator|+
name|i
argument_list|,
name|gmac_cc_config
operator|->
name|counters
index|[
name|i
operator|>>
literal|3
index|]
index|[
name|i
operator|&
literal|0x07
index|]
argument_list|)
expr_stmt|;
block|}
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_MSG_TX_THRESHOLD
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_DMACR0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_DMACR1
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_DMACR2
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_DMACR3
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_FREEQCARVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nlna_media_specific_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlna_media_specific_config
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bucket_size
modifier|*
name|bucket_sizes
decl_stmt|;
name|bucket_sizes
operator|=
name|xlr_board_info
operator|.
name|bucket_sizes
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|mac_type
condition|)
block|{
case|case
name|XLR_RGMII
case|:
case|case
name|XLR_SGMII
case|:
case|case
name|XLR_XAUI
case|:
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_GMAC_JFR0_BUCKET_SIZE
argument_list|,
name|bucket_sizes
operator|->
name|bucket
index|[
name|MSGRNG_STNID_GMACJFR_0
index|]
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_GMAC_RFR0_BUCKET_SIZE
argument_list|,
name|bucket_sizes
operator|->
name|bucket
index|[
name|MSGRNG_STNID_GMACRFR_0
index|]
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_GMAC_JFR1_BUCKET_SIZE
argument_list|,
name|bucket_sizes
operator|->
name|bucket
index|[
name|MSGRNG_STNID_GMACJFR_1
index|]
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_GMAC_RFR1_BUCKET_SIZE
argument_list|,
name|bucket_sizes
operator|->
name|bucket
index|[
name|MSGRNG_STNID_GMACRFR_1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mac_type
operator|==
name|XLR_XAUI
condition|)
block|{
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_TXDATAFIFO0
argument_list|,
operator|(
literal|224
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XLR_XGMII
case|:
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_XGS_RFR_BUCKET_SIZE
argument_list|,
name|bucket_sizes
operator|->
name|bucket
index|[
name|sc
operator|->
name|rfrbucket
index|]
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nlna_reset_ports
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|xlr_gmac_block_t
modifier|*
name|blk
parameter_list|)
block|{
name|xlr_reg_t
modifier|*
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|rx_ctrl
decl_stmt|;
comment|/* Refer Section 13.9.3 in the PRM for the reset sequence */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|xlr_io_mmio
argument_list|(
name|blk
operator|->
name|gmac_port
index|[
name|i
index|]
operator|.
name|base_addr
argument_list|)
expr_stmt|;
comment|/* 1. Reset RxEnable in MAC_CONFIG */
switch|switch
condition|(
name|sc
operator|->
name|mac_type
condition|)
block|{
case|case
name|XLR_RGMII
case|:
case|case
name|XLR_SGMII
case|:
name|NLGE_UPDATE
argument_list|(
name|addr
argument_list|,
name|R_MAC_CONFIG_1
argument_list|,
literal|0
argument_list|,
operator|(
literal|1
operator|<<
name|O_MAC_CONFIG_1__rxen
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XLR_XAUI
case|:
case|case
name|XLR_XGMII
case|:
name|NLGE_UPDATE
argument_list|(
name|addr
argument_list|,
name|R_RX_CONTROL
argument_list|,
literal|0
argument_list|,
operator|(
literal|1
operator|<<
name|O_RX_CONTROL__RxEnable
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Error: Unsupported port_type=%d\n"
argument_list|,
name|sc
operator|->
name|mac_type
argument_list|)
expr_stmt|;
block|}
comment|/* 1.1 Wait for RxControl.RxHalt to be set */
do|do
block|{
name|rx_ctrl
operator|=
name|NLGE_READ
argument_list|(
name|addr
argument_list|,
name|R_RX_CONTROL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|rx_ctrl
operator|&
literal|0x2
operator|)
condition|)
do|;
comment|/* 2. Set the soft reset bit in RxControl */
name|NLGE_UPDATE
argument_list|(
name|addr
argument_list|,
name|R_RX_CONTROL
argument_list|,
operator|(
literal|1
operator|<<
name|O_RX_CONTROL__SoftReset
operator|)
argument_list|,
operator|(
literal|1
operator|<<
name|O_RX_CONTROL__SoftReset
operator|)
argument_list|)
expr_stmt|;
comment|/* 2.1 Wait for RxControl.SoftResetDone to be set */
do|do
block|{
name|rx_ctrl
operator|=
name|NLGE_READ
argument_list|(
name|addr
argument_list|,
name|R_RX_CONTROL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|rx_ctrl
operator|&
literal|0x8
operator|)
condition|)
do|;
comment|/* 3. Clear the soft reset bit in RxControl */
name|NLGE_UPDATE
argument_list|(
name|addr
argument_list|,
name|R_RX_CONTROL
argument_list|,
literal|0
argument_list|,
operator|(
literal|1
operator|<<
name|O_RX_CONTROL__SoftReset
operator|)
argument_list|)
expr_stmt|;
comment|/* Turn off tx/rx on the port. */
name|NLGE_UPDATE
argument_list|(
name|addr
argument_list|,
name|R_RX_CONTROL
argument_list|,
literal|0
argument_list|,
operator|(
literal|1
operator|<<
name|O_RX_CONTROL__RxEnable
operator|)
argument_list|)
expr_stmt|;
name|NLGE_UPDATE
argument_list|(
name|addr
argument_list|,
name|R_TX_CONTROL
argument_list|,
literal|0
argument_list|,
operator|(
literal|1
operator|<<
name|O_TX_CONTROL__TxEnable
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nlna_disable_ports
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|child_sc
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|nlge_port_disable
argument_list|(
name|sc
operator|->
name|child_sc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nlna_enable_ports
parameter_list|(
name|struct
name|nlna_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|nlge_dev
decl_stmt|,
modifier|*
name|devlist
decl_stmt|;
name|struct
name|nlge_softc
modifier|*
name|port_sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numdevs
decl_stmt|;
name|device_get_children
argument_list|(
name|sc
operator|->
name|nlna_dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|nlge_dev
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nlge_dev
operator|==
name|NULL
condition|)
continue|continue;
name|port_sc
operator|=
name|device_get_softc
argument_list|(
name|nlge_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_sc
operator|->
name|nlge_if
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|nlge_port_enable
argument_list|(
name|port_sc
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlna_get_all_softc
parameter_list|(
name|device_t
name|iodi_dev
parameter_list|,
name|struct
name|nlna_softc
modifier|*
modifier|*
name|sc_vec
parameter_list|,
name|uint32_t
name|vec_sz
parameter_list|)
block|{
name|device_t
name|na_dev
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vec_sz
condition|;
name|i
operator|++
control|)
block|{
name|sc_vec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|na_dev
operator|=
name|device_find_child
argument_list|(
name|iodi_dev
argument_list|,
literal|"nlna"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|na_dev
operator|!=
name|NULL
condition|)
name|sc_vec
index|[
name|i
index|]
operator|=
name|device_get_softc
argument_list|(
name|na_dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nlge_port_disable
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|xlr_reg_t
modifier|*
name|base
decl_stmt|;
name|uint32_t
name|rd
decl_stmt|;
name|int
name|id
decl_stmt|,
name|port_type
decl_stmt|;
name|id
operator|=
name|sc
operator|->
name|id
expr_stmt|;
name|port_type
operator|=
name|sc
operator|->
name|port_type
expr_stmt|;
name|base
operator|=
name|sc
operator|->
name|base
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|nlge_if
expr_stmt|;
name|NLGE_UPDATE
argument_list|(
name|base
argument_list|,
name|R_RX_CONTROL
argument_list|,
literal|0x0
argument_list|,
literal|1
operator|<<
name|O_RX_CONTROL__RxEnable
argument_list|)
expr_stmt|;
do|do
block|{
name|rd
operator|=
name|NLGE_READ
argument_list|(
name|base
argument_list|,
name|R_RX_CONTROL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|rd
operator|&
operator|(
literal|1
operator|<<
name|O_RX_CONTROL__RxHalt
operator|)
operator|)
condition|)
do|;
name|NLGE_UPDATE
argument_list|(
name|base
argument_list|,
name|R_TX_CONTROL
argument_list|,
literal|0
argument_list|,
literal|1
operator|<<
name|O_TX_CONTROL__TxEnable
argument_list|)
expr_stmt|;
do|do
block|{
name|rd
operator|=
name|NLGE_READ
argument_list|(
name|base
argument_list|,
name|R_TX_CONTROL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|rd
operator|&
operator|(
literal|1
operator|<<
name|O_TX_CONTROL__TxIdle
operator|)
operator|)
condition|)
do|;
switch|switch
condition|(
name|port_type
condition|)
block|{
case|case
name|XLR_RGMII
case|:
case|case
name|XLR_SGMII
case|:
name|NLGE_UPDATE
argument_list|(
name|base
argument_list|,
name|R_MAC_CONFIG_1
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|O_MAC_CONFIG_1__rxen
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_MAC_CONFIG_1__txen
operator|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XLR_XGMII
case|:
case|case
name|XLR_XAUI
case|:
name|NLGE_UPDATE
argument_list|(
name|base
argument_list|,
name|R_XGMAC_CONFIG_1
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|O_XGMAC_CONFIG_1__hsttfen
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_XGMAC_CONFIG_1__hstrfen
operator|)
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown MAC type on port %d\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nlge_port_enable
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|xlr_gmac_port
modifier|*
name|self
decl_stmt|;
name|xlr_reg_t
modifier|*
name|base
decl_stmt|;
name|base
operator|=
name|sc
operator|->
name|base
expr_stmt|;
name|self
operator|=
name|device_get_ivars
argument_list|(
name|sc
operator|->
name|nlge_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlr_board_info
operator|.
name|is_xls
operator|&&
name|sc
operator|->
name|port_type
operator|==
name|XLR_RGMII
condition|)
name|NLGE_UPDATE
argument_list|(
name|base
argument_list|,
name|R_RX_CONTROL
argument_list|,
operator|(
literal|1
operator|<<
name|O_RX_CONTROL__RGMII
operator|)
argument_list|,
operator|(
literal|1
operator|<<
name|O_RX_CONTROL__RGMII
operator|)
argument_list|)
expr_stmt|;
name|NLGE_UPDATE
argument_list|(
name|base
argument_list|,
name|R_RX_CONTROL
argument_list|,
operator|(
literal|1
operator|<<
name|O_RX_CONTROL__RxEnable
operator|)
argument_list|,
operator|(
literal|1
operator|<<
name|O_RX_CONTROL__RxEnable
operator|)
argument_list|)
expr_stmt|;
name|NLGE_UPDATE
argument_list|(
name|base
argument_list|,
name|R_TX_CONTROL
argument_list|,
operator|(
literal|1
operator|<<
name|O_TX_CONTROL__TxEnable
operator||
name|RGE_TX_THRESHOLD_BYTES
operator|)
argument_list|,
operator|(
literal|1
operator|<<
name|O_TX_CONTROL__TxEnable
operator||
literal|0x3fff
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|port_type
condition|)
block|{
case|case
name|XLR_RGMII
case|:
case|case
name|XLR_SGMII
case|:
name|NLGE_UPDATE
argument_list|(
name|base
argument_list|,
name|R_MAC_CONFIG_1
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|O_MAC_CONFIG_1__rxen
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_MAC_CONFIG_1__txen
operator|)
operator|)
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|O_MAC_CONFIG_1__rxen
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_MAC_CONFIG_1__txen
operator|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XLR_XGMII
case|:
case|case
name|XLR_XAUI
case|:
name|NLGE_UPDATE
argument_list|(
name|base
argument_list|,
name|R_XGMAC_CONFIG_1
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|O_XGMAC_CONFIG_1__hsttfen
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_XGMAC_CONFIG_1__hstrfen
operator|)
operator|)
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|O_XGMAC_CONFIG_1__hsttfen
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_XGMAC_CONFIG_1__hstrfen
operator|)
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown MAC type on port %d\n"
argument_list|,
name|sc
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nlge_mac_set_rx_mode
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|regval
decl_stmt|;
name|regval
operator|=
name|NLGE_READ
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_MAC_FILTER_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|regval
operator||=
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__BROADCAST_EN
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__PAUSE_FRAME_EN
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__ALL_MCAST_EN
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__ALL_UCAST_EN
operator|)
expr_stmt|;
block|}
else|else
block|{
name|regval
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__PAUSE_FRAME_EN
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__ALL_UCAST_EN
operator|)
operator|)
expr_stmt|;
block|}
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_MAC_FILTER_CONFIG
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlge_sgmii_init
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|xlr_reg_t
modifier|*
name|mmio_gpio
decl_stmt|;
name|int
name|phy
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_type
operator|!=
name|XLR_SGMII
condition|)
return|return;
name|nlge_mii_write_internal
argument_list|(
name|sc
operator|->
name|serdes_addr
argument_list|,
literal|26
argument_list|,
literal|0
argument_list|,
literal|0x6DB0
argument_list|)
expr_stmt|;
name|nlge_mii_write_internal
argument_list|(
name|sc
operator|->
name|serdes_addr
argument_list|,
literal|26
argument_list|,
literal|1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|nlge_mii_write_internal
argument_list|(
name|sc
operator|->
name|serdes_addr
argument_list|,
literal|26
argument_list|,
literal|2
argument_list|,
literal|0xB6D0
argument_list|)
expr_stmt|;
name|nlge_mii_write_internal
argument_list|(
name|sc
operator|->
name|serdes_addr
argument_list|,
literal|26
argument_list|,
literal|3
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
name|nlge_mii_write_internal
argument_list|(
name|sc
operator|->
name|serdes_addr
argument_list|,
literal|26
argument_list|,
literal|4
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|nlge_mii_write_internal
argument_list|(
name|sc
operator|->
name|serdes_addr
argument_list|,
literal|26
argument_list|,
literal|5
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|nlge_mii_write_internal
argument_list|(
name|sc
operator|->
name|serdes_addr
argument_list|,
literal|26
argument_list|,
literal|6
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
name|nlge_mii_write_internal
argument_list|(
name|sc
operator|->
name|serdes_addr
argument_list|,
literal|26
argument_list|,
literal|7
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|nlge_mii_write_internal
argument_list|(
name|sc
operator|->
name|serdes_addr
argument_list|,
literal|26
argument_list|,
literal|8
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|nlge_mii_write_internal
argument_list|(
name|sc
operator|->
name|serdes_addr
argument_list|,
literal|26
argument_list|,
literal|9
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|nlge_mii_write_internal
argument_list|(
name|sc
operator|->
name|serdes_addr
argument_list|,
literal|26
argument_list|,
literal|10
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* program  GPIO values for serdes init parameters */
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|mmio_gpio
operator|=
name|xlr_io_mmio
argument_list|(
name|XLR_IO_GPIO_OFFSET
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio_gpio
argument_list|,
literal|0x20
argument_list|,
literal|0x7e6802
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio_gpio
argument_list|,
literal|0x10
argument_list|,
literal|0x7104
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/*  	 * This kludge is needed to setup serdes (?) clock correctly on some 	 * XLS boards 	 */
if|if
condition|(
operator|(
name|xlr_boot1_info
operator|.
name|board_major_version
operator|==
name|RMI_XLR_BOARD_ARIZONA_XI
operator|||
name|xlr_boot1_info
operator|.
name|board_major_version
operator|==
name|RMI_XLR_BOARD_ARIZONA_XII
operator|)
operator|&&
name|xlr_boot1_info
operator|.
name|board_minor_version
operator|==
literal|4
condition|)
block|{
comment|/* use 125 Mhz instead of 156.25Mhz ref clock */
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio_gpio
argument_list|,
literal|0x10
argument_list|,
literal|0x7103
argument_list|)
expr_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio_gpio
argument_list|,
literal|0x21
argument_list|,
literal|0x7103
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* enable autoneg - more magic */
name|phy
operator|=
name|sc
operator|->
name|phy_addr
operator|%
literal|4
operator|+
literal|27
expr_stmt|;
name|nlge_mii_write_internal
argument_list|(
name|sc
operator|->
name|pcs_addr
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|,
literal|0x1000
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
name|nlge_mii_write_internal
argument_list|(
name|sc
operator|->
name|pcs_addr
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|,
literal|0x0200
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlge_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nlge_port_set
modifier|*
name|pset
decl_stmt|;
name|struct
name|nlge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|nlge_softc
modifier|*
name|port_sc
decl_stmt|;
name|xlr_reg_t
modifier|*
name|base
decl_stmt|;
name|uint32_t
name|intreg
decl_stmt|;
name|uint32_t
name|intr_status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"warning: No port registered for interrupt\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|base
operator|=
name|sc
operator|->
name|base
expr_stmt|;
name|intreg
operator|=
name|NLGE_READ
argument_list|(
name|base
argument_list|,
name|R_INTREG
argument_list|)
expr_stmt|;
if|if
condition|(
name|intreg
operator|&
operator|(
literal|1
operator|<<
name|O_INTREG__MDInt
operator|)
condition|)
block|{
name|pset
operator|=
name|sc
operator|->
name|mdio_pset
expr_stmt|;
if|if
condition|(
name|pset
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"warning: No ports for MDIO interrupt\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pset
operator|->
name|vec_sz
condition|;
name|i
operator|++
control|)
block|{
name|port_sc
operator|=
name|pset
operator|->
name|port_vec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|port_sc
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Ack phy interrupt - clear on read*/
name|intr_status
operator|=
name|nlge_mii_read_internal
argument_list|(
name|port_sc
operator|->
name|mii_base
argument_list|,
name|port_sc
operator|->
name|phy_addr
argument_list|,
literal|26
argument_list|)
expr_stmt|;
name|PDEBUG
argument_list|(
literal|"Phy_%d: int_status=0x%08x\n"
argument_list|,
name|port_sc
operator|->
name|phy_addr
argument_list|,
name|intr_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|intr_status
operator|&
literal|0x8000
operator|)
condition|)
block|{
comment|/* no interrupt for this port */
continue|continue;
block|}
if|if
condition|(
name|intr_status
operator|&
literal|0x2410
condition|)
block|{
comment|/* update link status for port */
name|nlge_gmac_config_speed
argument_list|(
name|port_sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: Unsupported phy interrupt"
literal|" (0x%08x)\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|port_sc
operator|->
name|nlge_dev
argument_list|)
argument_list|,
name|intr_status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Clear the NA interrupt */
name|xlr_write_reg
argument_list|(
name|base
argument_list|,
name|R_INTREG
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|nlge_irq_init
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|resource
name|irq_res
decl_stmt|;
name|struct
name|nlna_softc
modifier|*
name|na_sc
decl_stmt|;
name|struct
name|xlr_gmac_block_t
modifier|*
name|block_info
decl_stmt|;
name|device_t
name|na_dev
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|irq_num
decl_stmt|;
name|na_dev
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|nlge_dev
argument_list|)
expr_stmt|;
name|block_info
operator|=
name|device_get_ivars
argument_list|(
name|na_dev
argument_list|)
expr_stmt|;
name|irq_num
operator|=
name|block_info
operator|->
name|baseirq
operator|+
name|sc
operator|->
name|instance
expr_stmt|;
name|irq_res
operator|.
name|__r_i
operator|=
operator|(
expr|struct
name|resource_i
operator|*
operator|)
call|(
name|intptr_t
call|)
argument_list|(
name|irq_num
argument_list|)
expr_stmt|;
name|ret
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|nlge_dev
argument_list|,
operator|&
name|irq_res
argument_list|,
operator|(
name|INTR_FAST
operator||
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
operator|)
argument_list|,
name|NULL
argument_list|,
name|nlge_intr
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|nlge_detach
argument_list|(
name|sc
operator|->
name|nlge_dev
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|nlge_dev
argument_list|,
literal|"couldn't set up irq: error=%d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|PDEBUG
argument_list|(
literal|"Setup intr for dev=%s, irq=%d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|nlge_dev
argument_list|)
argument_list|,
name|irq_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|instance
operator|==
literal|0
condition|)
block|{
name|na_sc
operator|=
name|device_get_softc
argument_list|(
name|na_dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mdio_pset
operator|=
operator|&
name|na_sc
operator|->
name|mdio_set
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlge_irq_fini
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|nlge_hw_init
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|xlr_gmac_port
modifier|*
name|port_info
decl_stmt|;
name|xlr_reg_t
modifier|*
name|base
decl_stmt|;
name|base
operator|=
name|sc
operator|->
name|base
expr_stmt|;
name|port_info
operator|=
name|device_get_ivars
argument_list|(
name|sc
operator|->
name|nlge_dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_bucket_id
operator|=
name|port_info
operator|->
name|tx_bucket_id
expr_stmt|;
comment|/* each packet buffer is 1536 bytes */
name|NLGE_WRITE
argument_list|(
name|base
argument_list|,
name|R_DESC_PACK_CTRL
argument_list|,
operator|(
literal|1
operator|<<
name|O_DESC_PACK_CTRL__MaxEntry
operator|)
operator||
operator|(
name|MAX_FRAME_SIZE
operator|<<
name|O_DESC_PACK_CTRL__RegularSize
operator|)
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|base
argument_list|,
name|R_STATCTRL
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|O_STATCTRL__Sten
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_STATCTRL__ClrCnt
operator|)
operator|)
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|base
argument_list|,
name|R_L2ALLOCCTRL
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|base
argument_list|,
name|R_INTMASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nlge_set_mac_addr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nlge_media_specific_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlge_sc_init
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|struct
name|xlr_gmac_port
modifier|*
name|port_info
parameter_list|)
block|{
name|memset
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nlge_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|id
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|nlge_set_port_attribs
argument_list|(
name|sc
argument_list|,
name|port_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlge_media_specific_init
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mii_data
modifier|*
name|media
decl_stmt|;
name|struct
name|bucket_size
modifier|*
name|bucket_sizes
decl_stmt|;
name|bucket_sizes
operator|=
name|xlr_board_info
operator|.
name|bucket_sizes
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|port_type
condition|)
block|{
case|case
name|XLR_RGMII
case|:
case|case
name|XLR_SGMII
case|:
case|case
name|XLR_XAUI
case|:
name|NLGE_UPDATE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_DESC_PACK_CTRL
argument_list|,
operator|(
name|BYTE_OFFSET
operator|<<
name|O_DESC_PACK_CTRL__ByteOffset
operator|)
argument_list|,
operator|(
name|W_DESC_PACK_CTRL__ByteOffset
operator|<<
name|O_DESC_PACK_CTRL__ByteOffset
operator|)
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_GMAC_TX0_BUCKET_SIZE
operator|+
name|sc
operator|->
name|instance
argument_list|,
name|bucket_sizes
operator|->
name|bucket
index|[
name|sc
operator|->
name|tx_bucket_id
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_type
operator|!=
name|XLR_XAUI
condition|)
block|{
name|nlge_gmac_config_speed
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mii_bus
condition|)
block|{
name|media
operator|=
operator|(
expr|struct
name|mii_data
operator|*
operator|)
name|device_get_softc
argument_list|(
name|sc
operator|->
name|mii_bus
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XLR_XGMII
case|:
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_BYTEOFFSET0
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_XGMACPADCALIBRATION
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_XGS_TX0_BUCKET_SIZE
argument_list|,
name|bucket_sizes
operator|->
name|bucket
index|[
name|sc
operator|->
name|tx_bucket_id
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Read the MAC address from the XLR boot registers. All port addresses  * are identical except for the lowest octet.  */
end_comment

begin_function
specifier|static
name|void
name|nlge_read_mac_addr
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|40
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
operator|&&
name|j
operator|>=
literal|0
condition|;
name|i
operator|++
operator|,
name|j
operator|-=
literal|8
control|)
name|sc
operator|->
name|dev_addr
index|[
name|i
index|]
operator|=
operator|(
name|xlr_boot1_info
operator|.
name|mac_addr
operator|>>
name|j
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|dev_addr
index|[
name|i
operator|-
literal|1
index|]
operator|+=
name|sc
operator|->
name|id
expr_stmt|;
comment|/* last octet is port-specific */
block|}
end_function

begin_comment
comment|/*  * Write the MAC address to the XLR MAC port. Also, set the address  * masks and MAC filter configuration.  */
end_comment

begin_function
specifier|static
name|void
name|nlge_set_mac_addr
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_MAC_ADDR0
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|dev_addr
index|[
literal|5
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sc
operator|->
name|dev_addr
index|[
literal|4
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sc
operator|->
name|dev_addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|sc
operator|->
name|dev_addr
index|[
literal|2
index|]
operator|)
operator|)
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_MAC_ADDR0
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|dev_addr
index|[
literal|1
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sc
operator|->
name|dev_addr
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator|)
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_MAC_ADDR_MASK2
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_MAC_ADDR_MASK2
operator|+
literal|1
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_MAC_ADDR_MASK3
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_MAC_ADDR_MASK3
operator|+
literal|1
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_MAC_FILTER_CONFIG
argument_list|,
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__BROADCAST_EN
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__ALL_MCAST_EN
operator|)
operator||
operator|(
literal|1
operator|<<
name|O_MAC_FILTER_CONFIG__MAC_ADDR0_VALID
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_type
operator|==
name|XLR_RGMII
operator|||
name|sc
operator|->
name|port_type
operator|==
name|XLR_SGMII
condition|)
block|{
name|NLGE_UPDATE
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_IPG_IFG
argument_list|,
name|MAC_B2B_IPG
argument_list|,
literal|0x7f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nlge_if_init
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|nlge_dev
expr_stmt|;
name|NLGE_LOCK_INIT
argument_list|(
name|sc
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|nlge_if
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|nlge_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|nlge_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|nlge_init
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|RGE_TX_Q_SIZE
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|nlge_mii
operator|.
name|mii_media
argument_list|,
literal|0
argument_list|,
name|nlge_mediachange
argument_list|,
name|nlge_mediastatus
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|nlge_mii
operator|.
name|mii_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|nlge_mii
operator|.
name|mii_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nlge_mii
operator|.
name|mii_media
operator|.
name|ifm_media
operator|=
name|sc
operator|->
name|nlge_mii
operator|.
name|mii_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
name|nlge_read_mac_addr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|dev_addr
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlge_mii_init
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_type
operator|!=
name|XLR_XAUI
operator|&&
name|sc
operator|->
name|port_type
operator|!=
name|XLR_XGMII
condition|)
block|{
name|NLGE_WRITE
argument_list|(
name|sc
operator|->
name|mii_base
argument_list|,
name|R_MII_MGMT_CONFIG
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|mii_phy_probe
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|mii_bus
argument_list|,
name|nlge_mediachange
argument_list|,
name|nlge_mediastatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"no PHY device found\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mii_bus
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mii_bus
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Enable all MDIO interrupts in the phy. RX_ER bit seems to get 		 * set about every 1 sec in GigE mode, ignore it for now... 		 */
name|nlge_mii_write_internal
argument_list|(
name|sc
operator|->
name|mii_base
argument_list|,
name|sc
operator|->
name|phy_addr
argument_list|,
literal|25
argument_list|,
literal|0xfffffffe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  Read a PHY register.  *  *  Input parameters:  *  	   mii_base - Base address of MII  *  	   phyaddr - PHY's address  *  	   regidx = index of register to read  *  *  Return value:  *  	   value read, or 0 if an error occurred.  */
end_comment

begin_function
specifier|static
name|int
name|nlge_mii_read_internal
parameter_list|(
name|xlr_reg_t
modifier|*
name|mii_base
parameter_list|,
name|int
name|phyaddr
parameter_list|,
name|int
name|regidx
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|val
decl_stmt|;
comment|/* setup the phy reg to be used */
name|NLGE_WRITE
argument_list|(
name|mii_base
argument_list|,
name|R_MII_MGMT_ADDRESS
argument_list|,
operator|(
name|phyaddr
operator|<<
literal|8
operator|)
operator||
operator|(
name|regidx
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Issue the read command */
name|NLGE_WRITE
argument_list|(
name|mii_base
argument_list|,
name|R_MII_MGMT_COMMAND
argument_list|,
operator|(
literal|1
operator|<<
name|O_MII_MGMT_COMMAND__rstat
operator|)
argument_list|)
expr_stmt|;
comment|/* poll for the read cycle to complete */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHY_STATUS_RETRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|NLGE_READ
argument_list|(
name|mii_base
argument_list|,
name|R_MII_MGMT_INDICATORS
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* clear the read cycle */
name|NLGE_WRITE
argument_list|(
name|mii_base
argument_list|,
name|R_MII_MGMT_COMMAND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|PHY_STATUS_RETRIES
condition|)
block|{
return|return
operator|(
literal|0xffffffff
operator|)
return|;
block|}
name|val
operator|=
name|NLGE_READ
argument_list|(
name|mii_base
argument_list|,
name|R_MII_MGMT_STATUS
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Write a value to a PHY register.  *  *  Input parameters:  *  	   mii_base - Base address of MII  *  	   phyaddr - PHY to use  *  	   regidx - register within the PHY  *  	   regval - data to write to register  *  *  Return value:  *  	   nothing  */
end_comment

begin_function
specifier|static
name|void
name|nlge_mii_write_internal
parameter_list|(
name|xlr_reg_t
modifier|*
name|mii_base
parameter_list|,
name|int
name|phyaddr
parameter_list|,
name|int
name|regidx
parameter_list|,
name|int
name|regval
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|NLGE_WRITE
argument_list|(
name|mii_base
argument_list|,
name|R_MII_MGMT_ADDRESS
argument_list|,
operator|(
name|phyaddr
operator|<<
literal|8
operator|)
operator||
operator|(
name|regidx
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Write the data which starts the write cycle */
name|NLGE_WRITE
argument_list|(
name|mii_base
argument_list|,
name|R_MII_MGMT_WRITE_DATA
argument_list|,
name|regval
argument_list|)
expr_stmt|;
comment|/* poll for the write cycle to complete */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHY_STATUS_RETRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|NLGE_READ
argument_list|(
name|mii_base
argument_list|,
name|R_MII_MGMT_INDICATORS
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Function to optimize the use of p2d descriptors for the given PDU.  * As it is on the fast-path (called during packet transmission), it  * described in more detail than the initialization functions.  *  * Input: mbuf chain (MC), pointer to fmn message  * Input constraints: None  * Output: FMN message to transmit the data in MC  * Return values: 0 - success  *                1 - MC cannot be handled (see Limitations below)  *                2 - MC cannot be handled presently (maybe worth re-trying)  * Other output: Number of entries filled in the FMN message  *  * Output structure/constraints:  *     1. Max 3 p2d's + 1 zero-len (ZL) p2d with virtual address of MC.  *     2. 3 p2d's + 1 p2p with max 14 p2d's (ZL p2d not required in this case).  *     3. Each p2d points to physically contiguous chunk of data (subject to  *        entire MC requiring max 17 p2d's).  * Limitations:  *     1. MC's that require more than 17 p2d's are not handled.  * Benefits: MC's that require<= 3 p2d's avoid the overhead of allocating  *           the p2p structure. Small packets (which typically give low  *           performance) are expected to have a small MC that takes  *           advantage of this.  */
end_comment

begin_function
specifier|static
name|int
name|prepare_fmn_message
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|msgrng_msg
modifier|*
name|fmn_msg
parameter_list|,
name|uint32_t
modifier|*
name|n_entries
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf_chain
parameter_list|,
name|uint64_t
name|fb_stn_id
parameter_list|,
name|struct
name|nlge_tx_desc
modifier|*
modifier|*
name|tx_desc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|nlge_tx_desc
modifier|*
name|p2p
decl_stmt|;
name|uint64_t
modifier|*
name|cur_p2d
decl_stmt|;
name|uint64_t
name|fbpaddr
decl_stmt|;
name|vm_offset_t
name|buf
decl_stmt|;
name|vm_paddr_t
name|paddr
decl_stmt|;
name|int
name|msg_sz
decl_stmt|,
name|p2p_sz
decl_stmt|,
name|len
decl_stmt|,
name|frag_sz
decl_stmt|;
comment|/* Num entries per FMN msg is 4 for XLR/XLS */
specifier|const
name|int
name|FMN_SZ
init|=
sizeof|sizeof
argument_list|(
operator|*
name|fmn_msg
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
decl_stmt|;
name|msg_sz
operator|=
name|p2p_sz
operator|=
literal|0
expr_stmt|;
name|p2p
operator|=
name|NULL
expr_stmt|;
name|cur_p2d
operator|=
operator|&
name|fmn_msg
operator|->
name|msg0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|mbuf_chain
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|buf
operator|=
operator|(
name|vm_offset_t
operator|)
name|m
operator|->
name|m_data
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|msg_sz
operator|==
operator|(
name|FMN_SZ
operator|-
literal|1
operator|)
condition|)
block|{
name|p2p
operator|=
name|uma_zalloc
argument_list|(
name|nl_tx_desc_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|2
operator|)
return|;
block|}
comment|/* 				 * Save the virtual address in the descriptor, 				 * it makes freeing easy. 				 */
name|p2p
operator|->
name|frag
index|[
name|XLR_MAX_TX_FRAGS
index|]
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|vm_offset_t
operator|)
name|p2p
expr_stmt|;
name|cur_p2d
operator|=
operator|&
name|p2p
operator|->
name|frag
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msg_sz
operator|==
operator|(
name|FMN_SZ
operator|-
literal|2
operator|+
name|XLR_MAX_TX_FRAGS
operator|)
condition|)
block|{
name|uma_zfree
argument_list|(
name|nl_tx_desc_zone
argument_list|,
name|p2p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|paddr
operator|=
name|vtophys
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|frag_sz
operator|=
name|PAGE_SIZE
operator|-
operator|(
name|buf
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|frag_sz
condition|)
name|frag_sz
operator|=
name|len
expr_stmt|;
operator|*
name|cur_p2d
operator|++
operator|=
operator|(
literal|127ULL
operator|<<
literal|54
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|frag_sz
operator|<<
literal|40
operator|)
operator||
name|paddr
expr_stmt|;
name|msg_sz
operator|++
expr_stmt|;
if|if
condition|(
name|p2p
operator|!=
name|NULL
condition|)
name|p2p_sz
operator|++
expr_stmt|;
name|len
operator|-=
name|frag_sz
expr_stmt|;
name|buf
operator|+=
name|frag_sz
expr_stmt|;
block|}
block|}
if|if
condition|(
name|msg_sz
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Zero-length mbuf chain ??\n"
argument_list|)
expr_stmt|;
operator|*
name|n_entries
operator|=
name|msg_sz
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* set eop in most-recent p2d */
name|cur_p2d
index|[
operator|-
literal|1
index|]
operator||=
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__mips_n64
comment|/*  	 * On n64, we cannot store our mbuf pointer(64 bit) in the freeback 	 * message (40bit available), so we put the mbuf in m_nextpkt and  	 * use the physical addr of that in freeback message. 	 */
name|mbuf_chain
operator|->
name|m_nextpkt
operator|=
name|mbuf_chain
expr_stmt|;
name|fbpaddr
operator|=
name|vtophys
argument_list|(
operator|&
name|mbuf_chain
operator|->
name|m_nextpkt
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Careful, don't sign extend when going to 64bit */
name|fbpaddr
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|mbuf_chain
expr_stmt|;
endif|#
directive|endif
operator|*
name|cur_p2d
operator|=
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|fb_stn_id
operator|<<
literal|54
operator|)
operator||
name|fbpaddr
expr_stmt|;
operator|*
name|tx_desc
operator|=
name|p2p
expr_stmt|;
if|if
condition|(
name|p2p
operator|!=
name|NULL
condition|)
block|{
name|paddr
operator|=
name|vtophys
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
name|p2p_sz
operator|++
expr_stmt|;
name|fmn_msg
operator|->
name|msg3
operator|=
operator|(
literal|1ULL
operator|<<
literal|62
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|fb_stn_id
operator|<<
literal|54
operator|)
operator||
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|p2p_sz
operator|*
literal|8
argument_list|)
operator|<<
literal|40
operator|)
operator||
name|paddr
expr_stmt|;
operator|*
name|n_entries
operator|=
name|FMN_SZ
expr_stmt|;
block|}
else|else
block|{
operator|*
name|n_entries
operator|=
name|msg_sz
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_fmn_msg_tx
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|msgrng_msg
modifier|*
name|msg
parameter_list|,
name|uint32_t
name|n_entries
parameter_list|)
block|{
name|uint32_t
name|msgrng_flags
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
do|do
block|{
name|msgrng_flags
operator|=
name|msgrng_access_enable
argument_list|()
expr_stmt|;
name|ret
operator|=
name|message_send
argument_list|(
name|n_entries
argument_list|,
name|MSGRNG_CODE_MAC
argument_list|,
name|sc
operator|->
name|tx_bucket_id
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|msgrng_restore
argument_list|(
name|msgrng_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
literal|100000
condition|)
do|;
name|device_printf
argument_list|(
name|sc
operator|->
name|nlge_dev
argument_list|,
literal|"Too many credit fails in tx path\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_tx_desc
parameter_list|(
name|vm_paddr_t
name|paddr
parameter_list|)
block|{
name|struct
name|nlge_tx_desc
modifier|*
name|tx_desc
decl_stmt|;
name|uint32_t
name|sr
decl_stmt|;
name|uint64_t
name|vaddr
decl_stmt|;
name|paddr
operator|+=
operator|(
name|XLR_MAX_TX_FRAGS
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
expr_stmt|;
name|sr
operator|=
name|xlr_enable_kx
argument_list|()
expr_stmt|;
name|vaddr
operator|=
name|xlr_paddr_ld
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|xlr_restore_kx
argument_list|(
name|sr
argument_list|)
expr_stmt|;
name|tx_desc
operator|=
operator|(
expr|struct
name|nlge_tx_desc
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|vaddr
expr_stmt|;
name|uma_zfree
argument_list|(
name|nl_tx_desc_zone
argument_list|,
name|tx_desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_buf
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|;
name|uint64_t
modifier|*
name|md
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|vm_paddr_t
name|temp1
decl_stmt|,
name|temp2
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|m_new
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m_new
operator|->
name|m_len
operator|=
name|m_new
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
name|m_adj
argument_list|(
name|m_new
argument_list|,
name|XLR_CACHELINE_SIZE
operator|-
operator|(
operator|(
name|uintptr_t
operator|)
name|m_new
operator|->
name|m_data
operator|&
literal|0x1f
operator|)
argument_list|)
expr_stmt|;
name|md
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|m_new
operator|->
name|m_data
expr_stmt|;
name|md
index|[
literal|0
index|]
operator|=
operator|(
name|intptr_t
operator|)
name|m_new
expr_stmt|;
comment|/* Back Ptr */
name|md
index|[
literal|1
index|]
operator|=
literal|0xf00bad
expr_stmt|;
name|m_adj
argument_list|(
name|m_new
argument_list|,
name|XLR_CACHELINE_SIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|temp1
operator|=
name|vtophys
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|m_new
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|vtophys
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|m_new
operator|->
name|m_data
operator|+
literal|1536
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp1
operator|+
literal|1536
operator|)
operator|!=
name|temp2
condition|)
name|panic
argument_list|(
literal|"ALLOCED BUFFER IS NOT CONTIGUOUS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|m_new
operator|->
name|m_data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nlge_gmac_config_speed
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|,
name|int
name|quick
parameter_list|)
block|{
name|struct
name|mii_data
modifier|*
name|md
decl_stmt|;
name|xlr_reg_t
modifier|*
name|mmio
decl_stmt|;
name|int
name|bmsr
decl_stmt|,
name|n_tries
decl_stmt|,
name|max_tries
decl_stmt|;
name|int
name|core_ctl
index|[]
init|=
block|{
literal|0x2
block|,
literal|0x1
block|,
literal|0x0
block|,
literal|0x1
block|}
decl_stmt|;
name|int
name|sgmii_speed
index|[]
init|=
block|{
name|SGMII_SPEED_10
block|,
name|SGMII_SPEED_100
block|,
name|SGMII_SPEED_1000
block|,
name|SGMII_SPEED_100
block|}
decl_stmt|;
comment|/* default to 100Mbps */
name|char
modifier|*
name|speed_str
index|[]
init|=
block|{
literal|"10"
block|,
literal|"100"
block|,
literal|"1000"
block|,
literal|"unknown, defaulting to 100"
block|}
decl_stmt|;
name|int
name|link_state
init|=
name|LINK_STATE_DOWN
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_type
operator|==
name|XLR_XAUI
operator|||
name|sc
operator|->
name|port_type
operator|==
name|XLR_XGMII
condition|)
return|return
literal|0
return|;
name|md
operator|=
name|NULL
expr_stmt|;
name|mmio
operator|=
name|sc
operator|->
name|base
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mii_base
operator|!=
name|NULL
condition|)
block|{
name|max_tries
operator|=
operator|(
name|quick
operator|==
literal|1
operator|)
condition|?
literal|100
else|:
literal|4000
expr_stmt|;
name|bmsr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n_tries
operator|=
literal|0
init|;
name|n_tries
operator|<
name|max_tries
condition|;
name|n_tries
operator|++
control|)
block|{
name|bmsr
operator|=
name|nlge_mii_read_internal
argument_list|(
name|sc
operator|->
name|mii_base
argument_list|,
name|sc
operator|->
name|phy_addr
argument_list|,
name|MII_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bmsr
operator|&
name|BMSR_ACOMP
operator|)
operator|&&
operator|(
name|bmsr
operator|&
name|BMSR_LINK
operator|)
condition|)
break|break;
comment|/* Auto-negotiation is complete 					  and link is up */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|bmsr
operator|&=
name|BMSR_LINK
expr_stmt|;
name|sc
operator|->
name|link
operator|=
operator|(
name|bmsr
operator|==
literal|0
operator|)
condition|?
name|xlr_mac_link_down
else|:
name|xlr_mac_link_up
expr_stmt|;
name|sc
operator|->
name|speed
operator|=
name|nlge_mii_read_internal
argument_list|(
name|sc
operator|->
name|mii_base
argument_list|,
name|sc
operator|->
name|phy_addr
argument_list|,
literal|28
argument_list|)
expr_stmt|;
name|sc
operator|->
name|speed
operator|=
operator|(
name|sc
operator|->
name|speed
operator|>>
literal|3
operator|)
operator|&
literal|0x03
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link
operator|==
name|xlr_mac_link_up
condition|)
block|{
name|link_state
operator|=
name|LINK_STATE_UP
expr_stmt|;
name|nlge_sgmii_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mii_bus
condition|)
name|md
operator|=
operator|(
expr|struct
name|mii_data
operator|*
operator|)
name|device_get_softc
argument_list|(
name|sc
operator|->
name|mii_bus
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|port_type
operator|!=
name|XLR_RGMII
condition|)
name|NLGE_WRITE
argument_list|(
name|mmio
argument_list|,
name|R_INTERFACE_CONTROL
argument_list|,
name|sgmii_speed
index|[
name|sc
operator|->
name|speed
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|speed
operator|==
name|xlr_mac_speed_10
operator|||
name|sc
operator|->
name|speed
operator|==
name|xlr_mac_speed_100
operator|||
name|sc
operator|->
name|speed
operator|==
name|xlr_mac_speed_rsvd
condition|)
block|{
name|NLGE_WRITE
argument_list|(
name|mmio
argument_list|,
name|R_MAC_CONFIG_2
argument_list|,
literal|0x7117
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|speed
operator|==
name|xlr_mac_speed_1000
condition|)
block|{
name|NLGE_WRITE
argument_list|(
name|mmio
argument_list|,
name|R_MAC_CONFIG_2
argument_list|,
literal|0x7217
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|!=
name|NULL
condition|)
block|{
name|ifmedia_set
argument_list|(
operator|&
name|md
operator|->
name|mii_media
argument_list|,
name|IFM_MAKEWORD
argument_list|(
name|IFM_ETHER
argument_list|,
name|IFM_1000_T
argument_list|,
name|IFM_FDX
argument_list|,
name|md
operator|->
name|mii_instance
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|NLGE_WRITE
argument_list|(
name|mmio
argument_list|,
name|R_CORECONTROL
argument_list|,
name|core_ctl
index|[
name|sc
operator|->
name|speed
index|]
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|nlge_if
argument_list|,
name|link_state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: [%sMbps]\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|nlge_dev
argument_list|)
argument_list|,
name|speed_str
index|[
name|sc
operator|->
name|speed
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called for each port that was added to the device tree  * and it initializes the following port attributes:  * 	- type  *      - base (base address to access port-specific registers)  *      - mii_base  * 	- phy_addr  */
end_comment

begin_function
specifier|static
name|void
name|nlge_set_port_attribs
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|xlr_gmac_port
modifier|*
name|port_info
parameter_list|)
block|{
name|sc
operator|->
name|instance
operator|=
name|port_info
operator|->
name|instance
operator|%
literal|4
expr_stmt|;
comment|/* TBD: will not work for SPI-4 */
name|sc
operator|->
name|port_type
operator|=
name|port_info
operator|->
name|type
expr_stmt|;
name|sc
operator|->
name|base
operator|=
name|xlr_io_mmio
argument_list|(
name|port_info
operator|->
name|base_addr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mii_base
operator|=
name|xlr_io_mmio
argument_list|(
name|port_info
operator|->
name|mii_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_info
operator|->
name|pcs_addr
operator|!=
literal|0
condition|)
name|sc
operator|->
name|pcs_addr
operator|=
name|xlr_io_mmio
argument_list|(
name|port_info
operator|->
name|pcs_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_info
operator|->
name|serdes_addr
operator|!=
literal|0
condition|)
name|sc
operator|->
name|serdes_addr
operator|=
name|xlr_io_mmio
argument_list|(
name|port_info
operator|->
name|serdes_addr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|phy_addr
operator|=
name|port_info
operator|->
name|phy_addr
expr_stmt|;
name|PDEBUG
argument_list|(
literal|"Port%d: base=%p, mii_base=%p, phy_addr=%d\n"
argument_list|,
name|sc
operator|->
name|id
argument_list|,
name|sc
operator|->
name|base
argument_list|,
name|sc
operator|->
name|mii_base
argument_list|,
name|sc
operator|->
name|phy_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Debug dump functions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|dump_reg
parameter_list|(
name|xlr_reg_t
modifier|*
name|base
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|NLGE_READ
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-30s: 0x%8x 0x%8x\n"
argument_list|,
name|name
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|STRINGIFY
parameter_list|(
name|x
parameter_list|)
value|#x
end_define

begin_function
specifier|static
name|void
name|dump_na_registers
parameter_list|(
name|xlr_reg_t
modifier|*
name|base_addr
parameter_list|,
name|int
name|port_id
parameter_list|)
block|{
name|PDEBUG
argument_list|(
literal|"Register dump for NA (of port=%d)\n"
argument_list|,
name|port_id
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_PARSERCONFIGREG
argument_list|,
name|STRINGIFY
argument_list|(
name|R_PARSERCONFIGREG
argument_list|)
argument_list|)
expr_stmt|;
name|PDEBUG
argument_list|(
literal|"Tx bucket sizes\n"
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_GMAC_JFR0_BUCKET_SIZE
argument_list|,
name|STRINGIFY
argument_list|(
name|R_GMAC_JFR0_BUCKET_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_GMAC_RFR0_BUCKET_SIZE
argument_list|,
name|STRINGIFY
argument_list|(
name|R_GMAC_RFR0_BUCKET_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_GMAC_TX0_BUCKET_SIZE
argument_list|,
name|STRINGIFY
argument_list|(
name|R_GMAC_TX0_BUCKET_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_GMAC_TX1_BUCKET_SIZE
argument_list|,
name|STRINGIFY
argument_list|(
name|R_GMAC_TX1_BUCKET_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_GMAC_TX2_BUCKET_SIZE
argument_list|,
name|STRINGIFY
argument_list|(
name|R_GMAC_TX2_BUCKET_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_GMAC_TX3_BUCKET_SIZE
argument_list|,
name|STRINGIFY
argument_list|(
name|R_GMAC_TX3_BUCKET_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_GMAC_JFR1_BUCKET_SIZE
argument_list|,
name|STRINGIFY
argument_list|(
name|R_GMAC_JFR1_BUCKET_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_GMAC_RFR1_BUCKET_SIZE
argument_list|,
name|STRINGIFY
argument_list|(
name|R_GMAC_RFR1_BUCKET_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_TXDATAFIFO0
argument_list|,
name|STRINGIFY
argument_list|(
name|R_TXDATAFIFO0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_TXDATAFIFO1
argument_list|,
name|STRINGIFY
argument_list|(
name|R_TXDATAFIFO1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_gmac_registers
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|xlr_reg_t
modifier|*
name|base_addr
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|int
name|port_id
init|=
name|sc
operator|->
name|instance
decl_stmt|;
name|PDEBUG
argument_list|(
literal|"Register dump for port=%d\n"
argument_list|,
name|port_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_type
operator|==
name|XLR_RGMII
operator|||
name|sc
operator|->
name|port_type
operator|==
name|XLR_SGMII
condition|)
block|{
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MAC_CONFIG_1
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MAC_CONFIG_1
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MAC_CONFIG_2
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MAC_CONFIG_2
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_IPG_IFG
argument_list|,
name|STRINGIFY
argument_list|(
name|R_IPG_IFG
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_HALF_DUPLEX
argument_list|,
name|STRINGIFY
argument_list|(
name|R_HALF_DUPLEX
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MAXIMUM_FRAME_LENGTH
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MAXIMUM_FRAME_LENGTH
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_TEST
argument_list|,
name|STRINGIFY
argument_list|(
name|R_TEST
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MII_MGMT_CONFIG
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MII_MGMT_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MII_MGMT_COMMAND
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MII_MGMT_COMMAND
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MII_MGMT_ADDRESS
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MII_MGMT_ADDRESS
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MII_MGMT_WRITE_DATA
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MII_MGMT_WRITE_DATA
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MII_MGMT_STATUS
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MII_MGMT_STATUS
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MII_MGMT_INDICATORS
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MII_MGMT_INDICATORS
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_INTERFACE_CONTROL
argument_list|,
name|STRINGIFY
argument_list|(
name|R_INTERFACE_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_INTERFACE_STATUS
argument_list|,
name|STRINGIFY
argument_list|(
name|R_INTERFACE_STATUS
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|port_type
operator|==
name|XLR_XAUI
operator|||
name|sc
operator|->
name|port_type
operator|==
name|XLR_XGMII
condition|)
block|{
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_XGMAC_CONFIG_0
argument_list|,
name|STRINGIFY
argument_list|(
name|R_XGMAC_CONFIG_0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_XGMAC_CONFIG_1
argument_list|,
name|STRINGIFY
argument_list|(
name|R_XGMAC_CONFIG_1
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_XGMAC_CONFIG_2
argument_list|,
name|STRINGIFY
argument_list|(
name|R_XGMAC_CONFIG_2
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_XGMAC_CONFIG_3
argument_list|,
name|STRINGIFY
argument_list|(
name|R_XGMAC_CONFIG_3
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_XGMAC_STATION_ADDRESS_LS
argument_list|,
name|STRINGIFY
argument_list|(
name|R_XGMAC_STATION_ADDRESS_LS
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_XGMAC_STATION_ADDRESS_MS
argument_list|,
name|STRINGIFY
argument_list|(
name|R_XGMAC_STATION_ADDRESS_MS
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_XGMAC_MAX_FRAME_LEN
argument_list|,
name|STRINGIFY
argument_list|(
name|R_XGMAC_MAX_FRAME_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_XGMAC_REV_LEVEL
argument_list|,
name|STRINGIFY
argument_list|(
name|R_XGMAC_REV_LEVEL
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_XGMAC_MIIM_COMMAND
argument_list|,
name|STRINGIFY
argument_list|(
name|R_XGMAC_MIIM_COMMAND
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_XGMAC_MIIM_FILED
argument_list|,
name|STRINGIFY
argument_list|(
name|R_XGMAC_MIIM_FILED
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_XGMAC_MIIM_CONFIG
argument_list|,
name|STRINGIFY
argument_list|(
name|R_XGMAC_MIIM_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_XGMAC_MIIM_LINK_FAIL_VECTOR
argument_list|,
name|STRINGIFY
argument_list|(
name|R_XGMAC_MIIM_LINK_FAIL_VECTOR
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_XGMAC_MIIM_INDICATOR
argument_list|,
name|STRINGIFY
argument_list|(
name|R_XGMAC_MIIM_INDICATOR
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MAC_ADDR0
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MAC_ADDR0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MAC_ADDR0
operator|+
literal|1
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MAC_ADDR0
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MAC_ADDR1
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MAC_ADDR1
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MAC_ADDR2
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MAC_ADDR2
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MAC_ADDR3
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MAC_ADDR3
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MAC_ADDR_MASK2
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MAC_ADDR_MASK2
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MAC_ADDR_MASK3
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MAC_ADDR_MASK3
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_MAC_FILTER_CONFIG
argument_list|,
name|STRINGIFY
argument_list|(
name|R_MAC_FILTER_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_TX_CONTROL
argument_list|,
name|STRINGIFY
argument_list|(
name|R_TX_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_RX_CONTROL
argument_list|,
name|STRINGIFY
argument_list|(
name|R_RX_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_DESC_PACK_CTRL
argument_list|,
name|STRINGIFY
argument_list|(
name|R_DESC_PACK_CTRL
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_STATCTRL
argument_list|,
name|STRINGIFY
argument_list|(
name|R_STATCTRL
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_L2ALLOCCTRL
argument_list|,
name|STRINGIFY
argument_list|(
name|R_L2ALLOCCTRL
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_INTMASK
argument_list|,
name|STRINGIFY
argument_list|(
name|R_INTMASK
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_INTREG
argument_list|,
name|STRINGIFY
argument_list|(
name|R_INTREG
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_TXRETRY
argument_list|,
name|STRINGIFY
argument_list|(
name|R_TXRETRY
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_CORECONTROL
argument_list|,
name|STRINGIFY
argument_list|(
name|R_CORECONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_BYTEOFFSET0
argument_list|,
name|STRINGIFY
argument_list|(
name|R_BYTEOFFSET0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_BYTEOFFSET1
argument_list|,
name|STRINGIFY
argument_list|(
name|R_BYTEOFFSET1
argument_list|)
argument_list|)
expr_stmt|;
name|dump_reg
argument_list|(
name|base_addr
argument_list|,
name|R_L2TYPE_0
argument_list|,
name|STRINGIFY
argument_list|(
name|R_L2TYPE_0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_na_registers
argument_list|(
name|base_addr
argument_list|,
name|port_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_fmn_cpu_credits_for_gmac
parameter_list|(
name|struct
name|xlr_board_info
modifier|*
name|board
parameter_list|,
name|int
name|gmac_id
parameter_list|)
block|{
name|struct
name|stn_cc
modifier|*
name|cc
decl_stmt|;
name|int
name|gmac_bucket_ids
index|[]
init|=
block|{
literal|97
block|,
literal|98
block|,
literal|99
block|,
literal|100
block|,
literal|101
block|,
literal|103
block|}
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|r
decl_stmt|,
name|c
decl_stmt|;
name|int
name|n_gmac_buckets
decl_stmt|;
name|n_gmac_buckets
operator|=
sizeof|sizeof
argument_list|(
name|gmac_bucket_ids
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|gmac_bucket_ids
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
comment|// for each cpu
name|cc
operator|=
name|board
operator|->
name|credit_configs
index|[
name|j
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"Credits for Station CPU_%d ---> GMAC buckets (tx path)\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n_gmac_buckets
condition|;
name|k
operator|++
control|)
block|{
name|r
operator|=
name|gmac_bucket_ids
index|[
name|k
index|]
operator|/
literal|8
expr_stmt|;
name|c
operator|=
name|gmac_bucket_ids
index|[
name|k
index|]
operator|%
literal|8
expr_stmt|;
name|printf
argument_list|(
literal|"    --> gmac%d_bucket_%-3d: credits=%d\n"
argument_list|,
name|gmac_id
argument_list|,
name|gmac_bucket_ids
index|[
name|k
index|]
argument_list|,
name|cc
operator|->
name|counters
index|[
name|r
index|]
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_fmn_gmac_credits
parameter_list|(
name|struct
name|xlr_board_info
modifier|*
name|board
parameter_list|,
name|int
name|gmac_id
parameter_list|)
block|{
name|struct
name|stn_cc
modifier|*
name|cc
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|cc
operator|=
name|board
operator|->
name|gmac_block
index|[
name|gmac_id
index|]
operator|.
name|credit_config
expr_stmt|;
name|printf
argument_list|(
literal|"Credits for Station: GMAC_%d ---> CPU buckets (rx path)\n"
argument_list|,
name|gmac_id
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
comment|// for each cpu
name|printf
argument_list|(
literal|"    ---> cpu_%d\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
block|{
comment|// for each bucket in cpu
name|printf
argument_list|(
literal|"        ---> bucket_%d: credits=%d\n"
argument_list|,
name|j
operator|*
literal|8
operator|+
name|k
argument_list|,
name|cc
operator|->
name|counters
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_board_info
parameter_list|(
name|struct
name|xlr_board_info
modifier|*
name|board
parameter_list|)
block|{
name|struct
name|xlr_gmac_block_t
modifier|*
name|gm
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|printf
argument_list|(
literal|"cpu=%x "
argument_list|,
name|xlr_revision
argument_list|()
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"board_version: major=%llx, minor=%llx\n"
argument_list|,
name|xlr_boot1_info
operator|.
name|board_major_version
argument_list|,
name|xlr_boot1_info
operator|.
name|board_minor_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"is_xls=%d, nr_cpus=%d, usb=%s, cfi=%s, ata=%s\npci_irq=%d,"
literal|"gmac_ports=%d\n"
argument_list|,
name|board
operator|->
name|is_xls
argument_list|,
name|board
operator|->
name|nr_cpus
argument_list|,
name|board
operator|->
name|usb
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|,
name|board
operator|->
name|cfi
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|,
name|board
operator|->
name|ata
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|,
name|board
operator|->
name|pci_irq
argument_list|,
name|board
operator|->
name|gmacports
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"FMN: Core-station bucket sizes\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|&&
operator|(
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"b[%d] = %d "
argument_list|,
name|i
argument_list|,
name|board
operator|->
name|bucket_sizes
operator|->
name|bucket
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|gm
operator|=
operator|&
name|board
operator|->
name|gmac_block
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"RNA_%d: type=%d, enabled=%s, mode=%d, station_id=%d,"
literal|"station_txbase=%d, station_rfr=%d "
argument_list|,
name|i
argument_list|,
name|gm
operator|->
name|type
argument_list|,
name|gm
operator|->
name|enabled
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|,
name|gm
operator|->
name|mode
argument_list|,
name|gm
operator|->
name|station_id
argument_list|,
name|gm
operator|->
name|station_txbase
argument_list|,
name|gm
operator|->
name|station_rfr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"n_ports=%d, baseaddr=%p, baseirq=%d, baseinst=%d\n"
argument_list|,
name|gm
operator|->
name|num_ports
argument_list|,
operator|(
name|xlr_reg_t
operator|*
operator|)
name|gm
operator|->
name|baseaddr
argument_list|,
name|gm
operator|->
name|baseirq
argument_list|,
name|gm
operator|->
name|baseinst
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|3
condition|;
name|k
operator|++
control|)
block|{
comment|// for each NA
name|dump_fmn_cpu_credits_for_gmac
argument_list|(
name|board
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|dump_fmn_gmac_credits
argument_list|(
name|board
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_mac_stats
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|xlr_reg_t
modifier|*
name|addr
decl_stmt|;
name|uint32_t
name|pkts_tx
decl_stmt|,
name|pkts_rx
decl_stmt|;
name|addr
operator|=
name|sc
operator|->
name|base
expr_stmt|;
name|pkts_rx
operator|=
name|NLGE_READ
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_RPKT
argument_list|)
expr_stmt|;
name|pkts_tx
operator|=
name|NLGE_READ
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|R_TPKT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[nlge_%d mac stats]: pkts_tx=%u, pkts_rx=%u\n"
argument_list|,
name|sc
operator|->
name|id
argument_list|,
name|pkts_tx
argument_list|,
name|pkts_rx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkts_rx
operator|>
literal|0
condition|)
block|{
name|uint32_t
name|r
decl_stmt|;
comment|/* dump all rx counters. we need this because pkts_rx includes 		   bad packets. */
for|for
control|(
name|r
operator|=
name|R_RFCS
init|;
name|r
operator|<=
name|R_ROVR
condition|;
name|r
operator|++
control|)
name|printf
argument_list|(
literal|"[nlge_%d mac stats]: [0x%x]=%u\n"
argument_list|,
name|sc
operator|->
name|id
argument_list|,
name|r
argument_list|,
name|NLGE_READ
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pkts_tx
operator|>
literal|0
condition|)
block|{
name|uint32_t
name|r
decl_stmt|;
comment|/* dump all tx counters. might be useful for debugging. */
for|for
control|(
name|r
operator|=
name|R_TMCA
init|;
name|r
operator|<=
name|R_TFRG
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|r
operator|==
operator|(
name|R_TNCL
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
name|r
operator|==
operator|(
name|R_TNCL
operator|+
literal|2
operator|)
operator|)
condition|)
continue|continue;
name|printf
argument_list|(
literal|"[nlge_%d mac stats]: [0x%x]=%u\n"
argument_list|,
name|sc
operator|->
name|id
argument_list|,
name|r
argument_list|,
name|NLGE_READ
argument_list|(
name|sc
operator|->
name|base
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_mii_regs
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|mii_regs
index|[]
init|=
block|{
literal|0x0
block|,
literal|0x1
block|,
literal|0x2
block|,
literal|0x3
block|,
literal|0x4
block|,
literal|0x5
block|,
literal|0x6
block|,
literal|0x7
block|,
literal|0x8
block|,
literal|0x9
block|,
literal|0xa
block|,
literal|0xf
block|,
literal|0x10
block|,
literal|0x11
block|,
literal|0x12
block|,
literal|0x13
block|,
literal|0x14
block|,
literal|0x15
block|,
literal|0x16
block|,
literal|0x17
block|,
literal|0x18
block|,
literal|0x19
block|,
literal|0x1a
block|,
literal|0x1b
block|,
literal|0x1c
block|,
literal|0x1d
block|,
literal|0x1e
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_regs
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mii_base
operator|==
name|NULL
operator|||
name|sc
operator|->
name|mii_bus
operator|==
name|NULL
condition|)
return|return;
name|n_regs
operator|=
sizeof|sizeof
argument_list|(
name|mii_regs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mii_regs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_regs
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"[mii_0x%x] = %x\n"
argument_list|,
name|mii_regs
index|[
name|i
index|]
argument_list|,
name|nlge_mii_read_internal
argument_list|(
name|sc
operator|->
name|mii_base
argument_list|,
name|sc
operator|->
name|phy_addr
argument_list|,
name|mii_regs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_ifmedia
parameter_list|(
name|struct
name|ifmedia
modifier|*
name|ifm
parameter_list|)
block|{
name|printf
argument_list|(
literal|"ifm_mask=%08x, ifm_media=%08x, cur=%p\n"
argument_list|,
name|ifm
operator|->
name|ifm_mask
argument_list|,
name|ifm
operator|->
name|ifm_media
argument_list|,
name|ifm
operator|->
name|ifm_cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifm
operator|->
name|ifm_cur
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Cur attribs: ifmedia_entry.ifm_media=%08x,"
literal|" ifmedia_entry.ifm_data=%08x\n"
argument_list|,
name|ifm
operator|->
name|ifm_cur
operator|->
name|ifm_media
argument_list|,
name|ifm
operator|->
name|ifm_cur
operator|->
name|ifm_data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_mii_data
parameter_list|(
name|struct
name|mii_data
modifier|*
name|mii
parameter_list|)
block|{
name|dump_ifmedia
argument_list|(
operator|&
name|mii
operator|->
name|mii_media
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ifp=%p, mii_instance=%d, mii_media_status=%08x,"
literal|" mii_media_active=%08x\n"
argument_list|,
name|mii
operator|->
name|mii_ifp
argument_list|,
name|mii
operator|->
name|mii_instance
argument_list|,
name|mii
operator|->
name|mii_media_status
argument_list|,
name|mii
operator|->
name|mii_media_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_pcs_regs
parameter_list|(
name|struct
name|nlge_softc
modifier|*
name|sc
parameter_list|,
name|int
name|phy
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|val
decl_stmt|;
name|printf
argument_list|(
literal|"PCS regs from %p for phy=%d\n"
argument_list|,
name|sc
operator|->
name|pcs_addr
argument_list|,
name|phy
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|2
operator|||
name|i
operator|==
literal|3
operator|||
operator|(
name|i
operator|>=
literal|9
operator|&&
name|i
operator|<=
literal|14
operator|)
condition|)
continue|continue;
name|val
operator|=
name|nlge_mii_read_internal
argument_list|(
name|sc
operator|->
name|pcs_addr
argument_list|,
name|phy
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PHY:%d pcs[0x%x] is 0x%x\n"
argument_list|,
name|phy
argument_list|,
name|i
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

