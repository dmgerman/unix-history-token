begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2009 RMI Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of RMI Corporation, nor the names of its contributors,  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * RMI_BSD  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|__RMAN_RESOURCE_VISIBLE
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/param.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/board.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/pic.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/msgring.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/iomap.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/rmi_mips_exts.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/dev/xlr/atx_cpld.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/dev/xlr/xgmac_mdio.h>
end_include

begin_decl_stmt
specifier|extern
name|bus_space_tag_t
name|uart_bus_space_mem
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|resource
modifier|*
name|iodi_alloc_resource
parameter_list|(
name|device_t
parameter_list|,
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|u_long
parameter_list|,
name|u_long
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iodi_activate_resource
parameter_list|(
name|device_t
parameter_list|,
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|resource
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iodi_setup_intr
parameter_list|(
name|device_t
parameter_list|,
name|device_t
parameter_list|,
name|struct
name|resource
modifier|*
parameter_list|,
name|int
parameter_list|,
name|driver_filter_t
modifier|*
parameter_list|,
name|driver_intr_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|iodi_softc
modifier|*
name|iodi_softc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* There can be only one. */
end_comment

begin_comment
comment|/*  * We will manage the Flash/PCMCIA devices in IODI for now.  * The NOR flash, Compact flash etc. which can be connected on   * various chip selects on the peripheral IO, should have a   * separate bus later.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_pcmcia_ack
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|xlr_reg_t
modifier|*
name|mmio
init|=
name|xlr_io_mmio
argument_list|(
name|XLR_IO_FLASH_OFFSET
argument_list|)
decl_stmt|;
name|xlr_write_reg
argument_list|(
name|mmio
argument_list|,
literal|0x60
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iodi_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|ires
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_filter_t
modifier|*
name|filt
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|device_get_name
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"uart"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* FIXME uart 1? */
name|cpu_establish_hardintr
argument_list|(
literal|"uart"
argument_list|,
name|filt
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|PIC_UART_0_IRQ
argument_list|,
name|flags
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
name|pic_setup_intr
argument_list|(
name|PIC_IRT_UART_0_INDEX
argument_list|,
name|PIC_UART_0_IRQ
argument_list|,
literal|0x1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"rge"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nlge"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|irq
decl_stmt|;
comment|/* This is a hack to pass in the irq */
name|irq
operator|=
operator|(
name|intptr_t
operator|)
name|ires
operator|->
name|__r_i
expr_stmt|;
name|cpu_establish_hardintr
argument_list|(
literal|"rge"
argument_list|,
name|filt
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|irq
argument_list|,
name|flags
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
name|pic_setup_intr
argument_list|(
name|irq
operator|-
name|PIC_IRQ_BASE
argument_list|,
name|irq
argument_list|,
literal|0x1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ehci"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cpu_establish_hardintr
argument_list|(
literal|"ehci"
argument_list|,
name|filt
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|PIC_USB_IRQ
argument_list|,
name|flags
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
name|pic_setup_intr
argument_list|(
name|PIC_USB_IRQ
operator|-
name|PIC_IRQ_BASE
argument_list|,
name|PIC_USB_IRQ
argument_list|,
literal|0x1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ata"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xlr_establish_intr
argument_list|(
literal|"ata"
argument_list|,
name|filt
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|PIC_PCMCIA_IRQ
argument_list|,
name|flags
argument_list|,
name|cookiep
argument_list|,
name|bridge_pcmcia_ack
argument_list|)
expr_stmt|;
name|pic_setup_intr
argument_list|(
name|PIC_PCMCIA_IRQ
operator|-
name|PIC_IRQ_BASE
argument_list|,
name|PIC_PCMCIA_IRQ
argument_list|,
literal|0x1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|iodi_alloc_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|device_get_name
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|int
name|unit
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IRQ
case|:
name|device_printf
argument_list|(
name|bus
argument_list|,
literal|"IRQ resource - for %s %lx-%lx\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_RES_IOPORT
case|:
name|device_printf
argument_list|(
name|bus
argument_list|,
literal|"IOPORT resource - for %s %lx-%lx\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|device_printf
argument_list|(
name|bus
argument_list|,
literal|"MEMORY resource - for %s %lx-%lx\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"uart"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|unit
operator|=
name|device_get_unit
argument_list|(
name|child
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* uart 0 */
name|res
operator|->
name|r_bushandle
operator|=
operator|(
name|xlr_io_base
operator|+
name|XLR_IO_UART_0_OFFSET
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unit
operator|==
literal|1
condition|)
block|{
name|res
operator|->
name|r_bushandle
operator|=
operator|(
name|xlr_io_base
operator|+
name|XLR_IO_UART_1_OFFSET
operator|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s: Unknown uart unit\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|res
operator|->
name|r_bustag
operator|=
name|uart_bus_space_mem
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ehci"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|->
name|r_bushandle
operator|=
name|MIPS_PHYS_TO_KSEG1
argument_list|(
literal|0x1ef24000
argument_list|)
expr_stmt|;
name|res
operator|->
name|r_bustag
operator|=
name|rmi_pci_bus_space
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"cfi"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|->
name|r_bushandle
operator|=
name|MIPS_PHYS_TO_KSEG1
argument_list|(
literal|0x1c000000
argument_list|)
expr_stmt|;
name|res
operator|->
name|r_bustag
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ata"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|->
name|r_bushandle
operator|=
name|MIPS_PHYS_TO_KSEG1
argument_list|(
literal|0x1d000000
argument_list|)
expr_stmt|;
name|res
operator|->
name|r_bustag
operator|=
name|rmi_pci_bus_space
expr_stmt|;
comment|/* byte swapping (not really PCI) */
block|}
comment|/* res->r_start = *rid; */
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iodi_activate_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|iodi_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iodi_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iodi_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iodi_identify
parameter_list|(
name|driver_t
modifier|*
parameter_list|,
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|iodi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|iodi_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"iodi"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iodi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|tmpd
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Attach each devices 	 */
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"uart"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"xlr_i2c"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pcib"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlr_board_info
operator|.
name|usb
condition|)
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"ehci"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlr_board_info
operator|.
name|cfi
condition|)
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"cfi"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlr_board_info
operator|.
name|ata
condition|)
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"ata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlr_board_info
operator|.
name|gmac_block
index|[
literal|0
index|]
operator|.
name|enabled
condition|)
block|{
name|tmpd
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"rge"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|tmpd
argument_list|,
operator|&
name|xlr_board_info
operator|.
name|gmac_block
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tmpd
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"rge"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|tmpd
argument_list|,
operator|&
name|xlr_board_info
operator|.
name|gmac_block
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tmpd
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"rge"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|tmpd
argument_list|,
operator|&
name|xlr_board_info
operator|.
name|gmac_block
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tmpd
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"rge"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|tmpd
argument_list|,
operator|&
name|xlr_board_info
operator|.
name|gmac_block
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xlr_board_info
operator|.
name|gmac_block
index|[
literal|1
index|]
operator|.
name|enabled
condition|)
block|{
if|if
condition|(
name|xlr_board_info
operator|.
name|gmac_block
index|[
literal|1
index|]
operator|.
name|type
operator|==
name|XLR_GMAC
condition|)
block|{
name|tmpd
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"rge"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|tmpd
argument_list|,
operator|&
name|xlr_board_info
operator|.
name|gmac_block
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tmpd
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"rge"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|tmpd
argument_list|,
operator|&
name|xlr_board_info
operator|.
name|gmac_block
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlr_board_info
operator|.
name|gmac_block
index|[
literal|1
index|]
operator|.
name|enabled
operator|&
literal|0x4
condition|)
block|{
name|tmpd
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"rge"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|tmpd
argument_list|,
operator|&
name|xlr_board_info
operator|.
name|gmac_block
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xlr_board_info
operator|.
name|gmac_block
index|[
literal|1
index|]
operator|.
name|enabled
operator|&
literal|0x8
condition|)
block|{
name|tmpd
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"rge"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|tmpd
argument_list|,
operator|&
name|xlr_board_info
operator|.
name|gmac_block
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|xlr_board_info
operator|.
name|gmac_block
index|[
literal|1
index|]
operator|.
name|type
operator|==
name|XLR_XGMAC
condition|)
block|{
if|#
directive|if
literal|0
comment|/* XGMAC not yet */
block|tmpd = device_add_child(dev, "rge", 4); 			device_set_ivars(tmpd,&xlr_board_info.gmac_block[1]);  			tmpd = device_add_child(dev, "rge", 5); 			device_set_ivars(tmpd,&xlr_board_info.gmac_block[1]);
endif|#
directive|endif
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unknown type of gmac 1\n"
argument_list|)
expr_stmt|;
block|}
comment|/* This is to add the new GMAC driver. The above adds the old driver, 	   which has been retained for now as the new driver is stabilized. 	   The new driver is enabled with "option nlge". Make sure that only 	   one of rge or nlge is enabled in the conf file. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xlr_board_info
operator|.
name|gmac_block
index|[
name|i
index|]
operator|.
name|enabled
operator|==
literal|0
condition|)
continue|continue;
name|tmpd
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"nlna"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|tmpd
argument_list|,
operator|&
name|xlr_board_info
operator|.
name|gmac_block
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bus_generic_probe
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iodi_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|nlna_dev
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|nlna_dev
operator|=
name|device_find_child
argument_list|(
name|dev
argument_list|,
literal|"nlna"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlna_dev
operator|!=
name|NULL
condition|)
name|error
operator|=
name|bus_generic_detach
argument_list|(
name|nlna_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|ret
operator|=
name|error
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|iodi_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|iodi_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|iodi_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|iodi_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|iodi_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|iodi_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|iodi_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|iodi_setup_intr
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|iodi_driver
init|=
block|{
literal|"iodi"
block|,
name|iodi_methods
block|,
literal|1
comment|/* no softc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|iodi_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|iodi
argument_list|,
name|nexus
argument_list|,
name|iodi_driver
argument_list|,
name|iodi_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

