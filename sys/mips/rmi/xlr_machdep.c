begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006-2009 RMI Corporation  * Copyright (c) 2002-2004 Juli Mallett<jmallett@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/rtprio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_comment
comment|/* cinit() */
end_comment

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/timetc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpuinfo.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpuregs.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/hwfunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/asm.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/trap.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/fls64.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/rmi_mips_exts.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/iomap.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/clock.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/msgring.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/xlrconfig.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/pic.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XLR_PERFMON
end_ifdef

begin_include
include|#
directive|include
file|<mips/rmi/perfmon.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|mpwait
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|enable_msgring_int
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|unsigned
name|long
name|xlr_io_base
init|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|DEFAULT_XLR_IO_BASE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 4KB static data aread to keep a copy of the bootload env until    the dynamic kenv is setup */
end_comment

begin_decl_stmt
name|char
name|boot1_env
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rmi_spin_mutex_safe
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Parameters from boot loader  */
end_comment

begin_decl_stmt
name|struct
name|boot1_info
name|xlr_boot1_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|xlr_loader_info
name|xlr_loader_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME : Unused */
end_comment

begin_decl_stmt
name|int
name|xlr_run_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xlr_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|xlr_argv
decl_stmt|,
modifier|*
modifier|*
name|xlr_envp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|cpu_mask_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|xlr_online_cpumask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|xlr_core_cpu_mask
init|=
literal|0x1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Core 0 thread 0 is always there */
end_comment

begin_function
name|void
name|platform_reset
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* FIXME : use proper define */
name|u_int32_t
modifier|*
name|mmio
init|=
operator|(
name|u_int32_t
operator|*
operator|)
literal|0xbef18000
decl_stmt|;
name|printf
argument_list|(
literal|"Rebooting the system now\n"
argument_list|)
expr_stmt|;
name|mmio
index|[
literal|8
index|]
operator|=
literal|0x1
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|xlr_asid_pcpu
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This the default */
end_comment

begin_decl_stmt
name|int
name|xlr_shtlb_enabled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function sets up the number of tlb entries available    to the kernel based on the number of threads brought up.    The ASID range also gets divided similarly.    THE NUMBER OF THREADS BROUGHT UP IN EACH CORE MUST BE THE SAME NOTE: This function will mark all 64TLB entries as available to the threads brought up in the core. If kernel is brought with say mask 0x33333333, no TLBs will be available to the threads in each core. */
end_comment

begin_function
specifier|static
name|void
name|setup_tlb_resource
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|mmu_setup
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|uint32_t
name|cpu_map
init|=
name|xlr_boot1_info
operator|.
name|cpu_online_map
decl_stmt|;
name|uint32_t
name|thr_mask
init|=
name|cpu_map
operator|>>
operator|(
name|xlr_core_id
argument_list|()
operator|<<
literal|2
operator|)
decl_stmt|;
name|uint8_t
name|core0
init|=
name|xlr_boot1_info
operator|.
name|cpu_online_map
operator|&
literal|0xf
decl_stmt|;
name|uint8_t
name|core_thr_mask
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
comment|/* If CPU0 did not enable shared TLB, other cores need to follow */
if|if
condition|(
operator|(
name|xlr_core_id
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|xlr_shtlb_enabled
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* First check if each core is brought up with the same mask */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|core_thr_mask
operator|=
name|cpu_map
operator|>>
operator|(
name|i
operator|<<
literal|2
operator|)
expr_stmt|;
name|core_thr_mask
operator|&=
literal|0xf
expr_stmt|;
if|if
condition|(
name|core_thr_mask
operator|&&
name|core_thr_mask
operator|!=
name|core0
condition|)
block|{
name|printf
argument_list|(
literal|"Each core must be brought with same cpu mask\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Cannot enabled shared TLB. "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Falling back to split TLB mode\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|xlr_shtlb_enabled
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|thr_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|count
operator|++
expr_stmt|;
switch|switch
condition|(
name|count
condition|)
block|{
case|case
literal|1
case|:
name|xlr_asid_pcpu
operator|=
literal|256
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|xlr_asid_pcpu
operator|=
literal|128
expr_stmt|;
name|value
operator|=
literal|0x2
expr_stmt|;
break|break;
default|default:
name|xlr_asid_pcpu
operator|=
literal|64
expr_stmt|;
name|value
operator|=
literal|0x3
expr_stmt|;
break|break;
block|}
name|mmu_setup
operator|=
name|read_32bit_phnx_ctrl_reg
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mmu_setup
operator|=
name|mmu_setup
operator|&
operator|~
literal|0x06
expr_stmt|;
name|mmu_setup
operator||=
operator|(
name|value
operator|<<
literal|1
operator|)
expr_stmt|;
comment|/* turn on global mode */
ifndef|#
directive|ifndef
name|SMP
name|mmu_setup
operator||=
literal|0x01
expr_stmt|;
endif|#
directive|endif
name|write_32bit_phnx_ctrl_reg
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
name|mmu_setup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Platform specific register setup for CPUs  * XLR has control registers accessible with MFCR/MTCR instructions, this  * code initialized them from the environment variable xlr.cr of form:  *  xlr.cr=reg:val[,reg:val]*, all values in hex.  * To enable shared TLB option use xlr.shtlb=1  */
end_comment

begin_function
name|void
name|platform_cpu_init
parameter_list|()
block|{
name|char
modifier|*
name|hw_env
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|val
decl_stmt|;
name|int
name|thr_id
init|=
name|xlr_thr_id
argument_list|()
decl_stmt|;
comment|/*  * XXX: SMP now need different wired mappings for threads   * we cannot share TLBs.  */
if|if
condition|(
name|thr_id
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|hw_env
operator|=
name|getenv
argument_list|(
literal|"xlr.shtlb"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|start
operator|=
name|hw_env
expr_stmt|;
name|reg
operator|=
name|strtoul
argument_list|(
name|start
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|!=
name|end
operator|&&
name|reg
operator|!=
literal|0
condition|)
name|setup_tlb_resource
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* By default TLB entries are shared in a core */
name|setup_tlb_resource
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|hw_env
operator|=
name|getenv
argument_list|(
literal|"xlr.cr"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|start
operator|=
name|hw_env
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|!=
literal|'\0'
condition|)
block|{
name|reg
operator|=
name|strtoul
argument_list|(
name|start
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid value in xlr.cr %s, cannot read a hex value at %d\n"
argument_list|,
name|hw_env
argument_list|,
name|start
operator|-
name|hw_env
argument_list|)
expr_stmt|;
goto|goto
name|err_return
goto|;
block|}
if|if
condition|(
operator|*
name|end
operator|!=
literal|':'
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid format in xlr.cr %s, ':' expected at pos %d\n"
argument_list|,
name|hw_env
argument_list|,
name|end
operator|-
name|hw_env
argument_list|)
expr_stmt|;
goto|goto
name|err_return
goto|;
block|}
name|start
operator|=
name|end
operator|+
literal|1
expr_stmt|;
comment|/* step over ':' */
name|val
operator|=
name|strtoul
argument_list|(
name|start
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid value in xlr.cr %s, cannot read a hex value at pos %d\n"
argument_list|,
name|hw_env
argument_list|,
name|start
operator|-
name|hw_env
argument_list|)
expr_stmt|;
goto|goto
name|err_return
goto|;
block|}
if|if
condition|(
operator|*
name|end
operator|!=
literal|','
operator|&&
operator|*
name|end
operator|!=
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid format in xlr.cr %s, ',' expected at pos %d\n"
argument_list|,
name|hw_env
argument_list|,
name|end
operator|-
name|hw_env
argument_list|)
expr_stmt|;
goto|goto
name|err_return
goto|;
block|}
name|xlr_mtcr
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|','
condition|)
name|start
operator|=
name|end
operator|+
literal|1
expr_stmt|;
comment|/* skip over ',' */
else|else
name|start
operator|=
name|end
expr_stmt|;
block|}
name|freeenv
argument_list|(
name|hw_env
argument_list|)
expr_stmt|;
return|return;
name|err_return
label|:
name|panic
argument_list|(
literal|"Invalid xlr.cr setting!"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|xlr_set_boot_flags
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|getenv
argument_list|(
literal|"boot_flags"
argument_list|)
init|;
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|boothowto
operator||=
name|RB_KDB
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|boothowto
operator||=
name|RB_GDB
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|boothowto
operator||=
name|RB_VERBOSE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* single-user (default, supported for sanity) */
case|case
literal|'S'
case|:
name|boothowto
operator||=
name|RB_SINGLE
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unrecognized boot flag '%c'.\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p
condition|)
name|freeenv
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
specifier|extern
name|uint32_t
name|_end
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mips_init
parameter_list|(
name|void
parameter_list|)
block|{
name|init_param1
argument_list|()
expr_stmt|;
name|init_param2
argument_list|(
name|physmem
argument_list|)
expr_stmt|;
comment|/* XXX: Catch 22. Something touches the tlb. */
name|mips_cpu_init
argument_list|()
expr_stmt|;
name|pmap_bootstrap
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DDB
name|kdb_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|boothowto
operator|&
name|RB_KDB
condition|)
block|{
name|kdb_enter
argument_list|(
literal|"Boot flags requested debugger"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mips_proc0_init
argument_list|()
expr_stmt|;
name|write_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|7
argument_list|,
name|pcpup
operator|->
name|pc_curthread
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|platform_start
parameter_list|(
name|__register_t
name|a0
name|__unused
parameter_list|,
name|__register_t
name|a1
name|__unused
parameter_list|,
name|__register_t
name|a2
name|__unused
parameter_list|,
name|__register_t
name|a3
name|__unused
parameter_list|)
block|{
name|vm_size_t
name|physsz
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|xlr_boot1_mem_map
modifier|*
name|boot_map
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|uint32_t
name|tmp
decl_stmt|;
name|void
function_decl|(
modifier|*
name|wakeup
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* XXX no zeroing of BSS? */
comment|/* Initialize pcpu stuff */
name|mips_pcpu0_init
argument_list|()
expr_stmt|;
comment|/* XXX FIXME the code below is not 64 bit clean */
comment|/* Save boot loader and other stuff from scratch regs */
name|xlr_boot1_info
operator|=
operator|*
operator|(
expr|struct
name|boot1_info
operator|*
operator|)
name|read_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpu_mask_info
operator|=
name|read_c0_register64
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xlr_online_cpumask
operator|=
name|read_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xlr_run_mode
operator|=
name|read_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|xlr_argc
operator|=
name|read_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|xlr_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|read_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xlr_envp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|read_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* TODO: Verify the magic number here */
comment|/* FIXMELATER: xlr_boot1_info.magic_number */
comment|/* initialize console so that we have printf */
name|boothowto
operator||=
operator|(
name|RB_SERIAL
operator||
name|RB_MULTIPLE
operator|)
expr_stmt|;
comment|/* Use multiple consoles */
comment|/* clockrate used by delay, so initialize it here */
name|cpu_clock
operator|=
name|xlr_boot1_info
operator|.
name|cpu_frequency
operator|/
literal|1000000
expr_stmt|;
comment|/* 	 * Note the time counter on CPU0 runs not at system clock speed, but 	 * at PIC time counter speed (which is returned by 	 * platform_get_frequency(). Thus we do not use 	 * xlr_boot1_info.cpu_frequency here. 	 */
name|mips_timer_early_init
argument_list|(
name|platform_get_frequency
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Init the time counter in the PIC and local putc routine*/
name|rmi_early_counter_init
argument_list|()
expr_stmt|;
comment|/* Init console please */
name|cninit
argument_list|()
expr_stmt|;
name|init_static_kenv
argument_list|(
name|boot1_env
argument_list|,
sizeof|sizeof
argument_list|(
name|boot1_env
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Environment (from %d args):\n"
argument_list|,
name|xlr_argc
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlr_argc
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"\tNone\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|xlr_argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|xlr_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|n
operator|=
name|strsep
argument_list|(
operator|&
name|xlr_argv
index|[
name|i
index|]
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlr_argv
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|setenv
argument_list|(
name|n
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
else|else
name|setenv
argument_list|(
name|n
argument_list|,
name|xlr_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|xlr_set_boot_flags
argument_list|()
expr_stmt|;
comment|/* get physical memory info from boot loader */
name|boot_map
operator|=
operator|(
expr|struct
name|xlr_boot1_mem_map
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|xlr_boot1_info
operator|.
name|psb_mem_map
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|boot_map
operator|->
name|num_entries
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|boot_map
operator|->
name|physmem_map
index|[
name|i
index|]
operator|.
name|type
operator|==
name|BOOT1_MEM_RAM
condition|)
block|{
if|if
condition|(
name|j
operator|==
literal|14
condition|)
block|{
name|printf
argument_list|(
literal|"*** ERROR *** memory map too large ***\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
comment|/* TODO FIXME  */
comment|/* start after kernel end */
name|phys_avail
index|[
literal|0
index|]
operator|=
operator|(
name|vm_paddr_t
operator|)
name|MIPS_KSEG0_TO_PHYS
argument_list|(
operator|&
name|_end
argument_list|)
operator|+
literal|0x20000
expr_stmt|;
comment|/* boot loader start */
comment|/* HACK to Use bootloaders memory region */
comment|/* TODO FIXME  */
if|if
condition|(
name|boot_map
operator|->
name|physmem_map
index|[
literal|0
index|]
operator|.
name|size
operator|==
literal|0x0c000000
condition|)
block|{
name|boot_map
operator|->
name|physmem_map
index|[
literal|0
index|]
operator|.
name|size
operator|=
literal|0x0ff00000
expr_stmt|;
block|}
name|phys_avail
index|[
literal|1
index|]
operator|=
name|boot_map
operator|->
name|physmem_map
index|[
literal|0
index|]
operator|.
name|addr
operator|+
name|boot_map
operator|->
name|physmem_map
index|[
literal|0
index|]
operator|.
name|size
expr_stmt|;
name|printf
argument_list|(
literal|"First segment: addr:%p -> %p \n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|phys_avail
index|[
literal|0
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|phys_avail
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  * Can't use this code yet, because most of the fixed allocations happen from  * the biggest physical area. If we have more than 512M memory the kernel will try  * to map from the second are which is not in KSEG0 and not mapped  */
name|phys_avail
index|[
name|j
index|]
operator|=
operator|(
name|vm_paddr_t
operator|)
name|boot_map
operator|->
name|physmem_map
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|phys_avail
index|[
name|j
index|]
operator|+
name|boot_map
operator|->
name|physmem_map
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|<
name|phys_avail
index|[
name|j
index|]
condition|)
block|{
comment|/* Houston we have an issue. Memory is 					 * larger than possible. Its probably in 					 * 64 bit> 4Gig and we are in 32 bit mode. 					 */
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
literal|0xfffff000
expr_stmt|;
name|printf
argument_list|(
literal|"boot map size was %llx\n"
argument_list|,
name|boot_map
operator|->
name|physmem_map
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|boot_map
operator|->
name|physmem_map
index|[
name|i
index|]
operator|.
name|size
operator|=
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|phys_avail
index|[
name|j
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"reduced to %llx\n"
argument_list|,
name|boot_map
operator|->
name|physmem_map
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Next segment : addr:%p -> %p \n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|phys_avail
index|[
name|j
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|physsz
operator|+=
name|boot_map
operator|->
name|physmem_map
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
block|}
block|}
comment|/* FIXME XLR TODO */
name|phys_avail
index|[
name|j
index|]
operator|=
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|realmem
operator|=
name|physmem
operator|=
name|btoc
argument_list|(
name|physsz
argument_list|)
expr_stmt|;
comment|/* Store pcpu in scratch 5 */
name|write_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|5
argument_list|,
name|pcpup
argument_list|)
expr_stmt|;
comment|/* Set up hz, among others. */
name|mips_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* 	 * If thread 0 of any core is not available then mark whole core as 	 * not available 	 */
name|tmp
operator|=
name|xlr_boot1_info
operator|.
name|cpu_online_map
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|+=
literal|4
control|)
block|{
if|if
condition|(
operator|(
name|tmp
operator|&
operator|(
literal|0xf
operator|<<
name|i
operator|)
operator|)
operator|&&
operator|!
operator|(
name|tmp
operator|&
operator|(
literal|0x1
operator|<<
name|i
operator|)
operator|)
condition|)
block|{
comment|/* 			 * Oopps.. thread 0 is not available. Disable whole 			 * core 			 */
name|tmp
operator|=
name|tmp
operator|&
operator|~
operator|(
literal|0xf
operator|<<
name|i
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"WARNING: Core %d is disabled because thread 0"
literal|" of this core is not enabled.\n"
argument_list|,
name|i
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
name|xlr_boot1_info
operator|.
name|cpu_online_map
operator|=
name|tmp
expr_stmt|;
comment|/* Wakeup Other cpus, and put them in bsd park code. */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
comment|/* Allocate stack for all other cpus from fbsd kseg0 memory. */
if|if
condition|(
operator|(
literal|1U
operator|<<
name|i
operator|)
operator|&
name|xlr_boot1_info
operator|.
name|cpu_online_map
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|&
literal|0x3
operator|)
operator|==
literal|0
condition|)
comment|/* store thread0 of each core */
name|xlr_core_cpu_mask
operator||=
operator|(
literal|1
operator|<<
name|j
operator|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
name|wakeup
operator|=
operator|(
operator|(
name|void
argument_list|(
argument|*
argument_list|)
operator|(
name|void
operator|*
operator|,
name|void
operator|*
operator|,
name|unsigned
name|int
operator|)
operator|)
call|(
name|unsigned
name|long
call|)
argument_list|(
name|xlr_boot1_info
operator|.
name|wakeup
argument_list|)
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"Waking up CPUs 0x%llx.\n"
argument_list|,
name|xlr_boot1_info
operator|.
name|cpu_online_map
operator|&
operator|~
operator|(
literal|0x1U
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlr_boot1_info
operator|.
name|cpu_online_map
operator|&
operator|~
operator|(
literal|0x1U
operator|)
condition|)
name|wakeup
argument_list|(
name|mpwait
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|xlr_boot1_info
operator|.
name|cpu_online_map
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* xlr specific post initialization */
comment|/* 	 * The expectation is that mutex_init() is already done in 	 * mips_init() XXX NOTE: We may need to move this to SMP based init 	 * code for each CPU, later. 	 */
name|rmi_spin_mutex_safe
operator|=
literal|1
expr_stmt|;
name|on_chip_init
argument_list|()
expr_stmt|;
name|mips_timer_init_params
argument_list|(
name|platform_get_frequency
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Platform specific startup now completes\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|platform_identify
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Board [%d:%d], processor 0x%08x\n"
argument_list|,
operator|(
name|int
operator|)
name|xlr_boot1_info
operator|.
name|board_major_version
argument_list|,
operator|(
name|int
operator|)
name|xlr_boot1_info
operator|.
name|board_minor_version
argument_list|,
name|mips_rd_prid
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX Maybe return the state of the watchdog in enter, and pass it to  * exit?  Like spl().  */
end_comment

begin_function
name|void
name|platform_trap_enter
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|platform_trap_exit
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_decl_stmt
name|int
name|xlr_ap_release
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|platform_start_ap
parameter_list|(
name|int
name|cpuid
parameter_list|)
block|{
comment|/* 	 * other cpus are enabled by the boot loader and they will be  	 * already looping in mpwait, release them 	 */
name|atomic_store_rel_int
argument_list|(
operator|&
name|xlr_ap_release
index|[
name|cpuid
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|platform_init_ap
parameter_list|(
name|int
name|processor_id
parameter_list|)
block|{
name|uint32_t
name|stat
decl_stmt|;
comment|/* Setup interrupts for secondary CPUs here */
name|stat
operator|=
name|mips_rd_status
argument_list|()
expr_stmt|;
name|stat
operator||=
name|MIPS_SR_COP_2_BIT
operator||
name|MIPS_SR_COP_0_BIT
expr_stmt|;
name|mips_wr_status
argument_list|(
name|stat
argument_list|)
expr_stmt|;
name|xlr_unmask_hard_irq
argument_list|(
operator|(
name|void
operator|*
operator|)
name|platform_ipi_intrnum
argument_list|()
argument_list|)
expr_stmt|;
name|xlr_unmask_hard_irq
argument_list|(
operator|(
name|void
operator|*
operator|)
name|IRQ_TIMER
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlr_thr_id
argument_list|()
operator|==
literal|0
condition|)
block|{
name|xlr_msgring_cpu_init
argument_list|()
expr_stmt|;
name|xlr_unmask_hard_irq
argument_list|(
operator|(
name|void
operator|*
operator|)
name|IRQ_MSGRING
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|int
name|platform_ipi_intrnum
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|IRQ_IPI
return|;
block|}
end_function

begin_function
name|void
name|platform_ipi_send
parameter_list|(
name|int
name|cpuid
parameter_list|)
block|{
name|pic_send_ipi
argument_list|(
name|cpuid
argument_list|,
name|platform_ipi_intrnum
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|platform_ipi_clear
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|int
name|platform_processor_id
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|xlr_cpu_id
argument_list|()
return|;
block|}
end_function

begin_function
name|int
name|platform_num_processors
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|fls
argument_list|(
name|xlr_boot1_info
operator|.
name|cpu_online_map
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

