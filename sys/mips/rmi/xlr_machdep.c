begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006-2009 RMI Corporation  * Copyright (c) 2002-2004 Juli Mallett<jmallett@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/rtprio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_comment
comment|/* cinit() */
end_comment

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/timetc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpuinfo.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpuregs.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/hwfunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/asm.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/trap.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/fls64.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/rmi_mips_exts.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/iomap.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/clock.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/msgring.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/xlrconfig.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<mips/rmi/pic.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XLR_PERFMON
end_ifdef

begin_include
include|#
directive|include
file|<mips/rmi/perfmon.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|platform_prep_smp_launch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|unsigned
name|long
name|xlr_io_base
init|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|DEFAULT_XLR_IO_BASE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 4KB static data aread to keep a copy of the bootload env until    the dynamic kenv is setup */
end_comment

begin_decl_stmt
name|char
name|boot1_env
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|_gp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rmi_spin_mutex_safe
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Parameters from boot loader  */
end_comment

begin_decl_stmt
name|struct
name|boot1_info
name|xlr_boot1_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|xlr_loader_info
name|xlr_loader_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME : Unused */
end_comment

begin_decl_stmt
name|int
name|xlr_run_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xlr_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|xlr_argv
decl_stmt|,
modifier|*
modifier|*
name|xlr_envp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|cpu_mask_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|xlr_online_cpumask
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|xlr_secondary_gp
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|xlr_secondary_sp
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|mips_cpu_online_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|mips_cpu_logical_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|cpu_ltop_map
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|cpu_ptol_map
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|xlr_core_cpu_mask
init|=
literal|0x1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Core 0 thread 0 is always there */
end_comment

begin_function
name|void
name|platform_reset
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* FIXME : use proper define */
name|u_int32_t
modifier|*
name|mmio
init|=
operator|(
name|u_int32_t
operator|*
operator|)
literal|0xbef18000
decl_stmt|;
name|printf
argument_list|(
literal|"Rebooting the system now\n"
argument_list|)
expr_stmt|;
name|mmio
index|[
literal|8
index|]
operator|=
literal|0x1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|platform_secondary_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|xlr_msgring_cpu_init
argument_list|()
expr_stmt|;
comment|/* Setup interrupts for secondary CPUs here */
name|mips_mask_hard_irq
argument_list|(
name|IPI_SMP_CALL_FUNCTION
argument_list|)
expr_stmt|;
name|mips_mask_hard_irq
argument_list|(
name|IPI_STOP
argument_list|)
expr_stmt|;
name|mips_mask_hard_irq
argument_list|(
name|IPI_RENDEZVOUS
argument_list|)
expr_stmt|;
name|mips_mask_hard_irq
argument_list|(
name|IPI_AST
argument_list|)
expr_stmt|;
name|mips_mask_hard_irq
argument_list|(
name|IRQ_TIMER
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XLR_PERFMON
name|mips_mask_hard_irq
argument_list|(
name|IPI_PERFMON
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|int
name|xlr_asid_pcpu
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This the default */
end_comment

begin_decl_stmt
name|int
name|xlr_shtlb_enabled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function sets up the number of tlb entries available    to the kernel based on the number of threads brought up.    The ASID range also gets divided similarly.    THE NUMBER OF THREADS BROUGHT UP IN EACH CORE MUST BE THE SAME NOTE: This function will mark all 64TLB entries as available to the threads brought up in the core. If kernel is brought with say mask 0x33333333, no TLBs will be available to the threads in each core. */
end_comment

begin_function
specifier|static
name|void
name|setup_tlb_resource
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|mmu_setup
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|uint32_t
name|cpu_map
init|=
name|xlr_boot1_info
operator|.
name|cpu_online_map
decl_stmt|;
name|uint32_t
name|thr_mask
init|=
name|cpu_map
operator|>>
operator|(
name|xlr_cpu_id
argument_list|()
operator|<<
literal|2
operator|)
decl_stmt|;
name|uint8_t
name|core0
init|=
name|xlr_boot1_info
operator|.
name|cpu_online_map
operator|&
literal|0xf
decl_stmt|;
name|uint8_t
name|core_thr_mask
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
comment|/* If CPU0 did not enable shared TLB, other cores need to follow */
if|if
condition|(
operator|(
name|xlr_cpu_id
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|xlr_shtlb_enabled
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* First check if each core is brought up with the same mask */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|core_thr_mask
operator|=
name|cpu_map
operator|>>
operator|(
name|i
operator|<<
literal|2
operator|)
expr_stmt|;
name|core_thr_mask
operator|&=
literal|0xf
expr_stmt|;
if|if
condition|(
name|core_thr_mask
operator|&&
name|core_thr_mask
operator|!=
name|core0
condition|)
block|{
name|printf
argument_list|(
literal|"Each core must be brought with same cpu mask\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Cannot enabled shared TLB. "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Falling back to split TLB mode\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|xlr_shtlb_enabled
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|thr_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|count
operator|++
expr_stmt|;
switch|switch
condition|(
name|count
condition|)
block|{
case|case
literal|1
case|:
name|xlr_asid_pcpu
operator|=
literal|256
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|xlr_asid_pcpu
operator|=
literal|128
expr_stmt|;
name|value
operator|=
literal|0x2
expr_stmt|;
break|break;
default|default:
name|xlr_asid_pcpu
operator|=
literal|64
expr_stmt|;
name|value
operator|=
literal|0x3
expr_stmt|;
break|break;
block|}
name|mmu_setup
operator|=
name|read_32bit_phnx_ctrl_reg
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mmu_setup
operator|=
name|mmu_setup
operator|&
operator|~
literal|0x06
expr_stmt|;
name|mmu_setup
operator||=
operator|(
name|value
operator|<<
literal|1
operator|)
expr_stmt|;
comment|/* turn on global mode */
name|mmu_setup
operator||=
literal|0x01
expr_stmt|;
name|write_32bit_phnx_ctrl_reg
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
name|mmu_setup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Platform specific register setup for CPUs  * XLR has control registers accessible with MFCR/MTCR instructions, this  * code initialized them from the environment variable xlr.cr of form:  *  xlr.cr=reg:val[,reg:val]*, all values in hex.  * To enable shared TLB option use xlr.shtlb=1  */
end_comment

begin_function
name|void
name|platform_cpu_init
parameter_list|()
block|{
name|char
modifier|*
name|hw_env
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|val
decl_stmt|;
name|int
name|thr_id
init|=
name|xlr_thr_id
argument_list|()
decl_stmt|;
if|if
condition|(
name|thr_id
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|hw_env
operator|=
name|getenv
argument_list|(
literal|"xlr.shtlb"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|start
operator|=
name|hw_env
expr_stmt|;
name|reg
operator|=
name|strtoul
argument_list|(
name|start
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|!=
name|end
operator|&&
name|reg
operator|!=
literal|0
condition|)
name|setup_tlb_resource
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* By default TLB entries are shared in a core */
name|setup_tlb_resource
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|hw_env
operator|=
name|getenv
argument_list|(
literal|"xlr.cr"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|start
operator|=
name|hw_env
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|!=
literal|'\0'
condition|)
block|{
name|reg
operator|=
name|strtoul
argument_list|(
name|start
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid value in xlr.cr %s, cannot read a hex value at %d\n"
argument_list|,
name|hw_env
argument_list|,
name|start
operator|-
name|hw_env
argument_list|)
expr_stmt|;
goto|goto
name|err_return
goto|;
block|}
if|if
condition|(
operator|*
name|end
operator|!=
literal|':'
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid format in xlr.cr %s, ':' expected at pos %d\n"
argument_list|,
name|hw_env
argument_list|,
name|end
operator|-
name|hw_env
argument_list|)
expr_stmt|;
goto|goto
name|err_return
goto|;
block|}
name|start
operator|=
name|end
operator|+
literal|1
expr_stmt|;
comment|/* step over ':' */
name|val
operator|=
name|strtoul
argument_list|(
name|start
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid value in xlr.cr %s, cannot read a hex value at pos %d\n"
argument_list|,
name|hw_env
argument_list|,
name|start
operator|-
name|hw_env
argument_list|)
expr_stmt|;
goto|goto
name|err_return
goto|;
block|}
if|if
condition|(
operator|*
name|end
operator|!=
literal|','
operator|&&
operator|*
name|end
operator|!=
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid format in xlr.cr %s, ',' expected at pos %d\n"
argument_list|,
name|hw_env
argument_list|,
name|end
operator|-
name|hw_env
argument_list|)
expr_stmt|;
goto|goto
name|err_return
goto|;
block|}
name|xlr_mtcr
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|','
condition|)
name|start
operator|=
name|end
operator|+
literal|1
expr_stmt|;
comment|/* skip over ',' */
else|else
name|start
operator|=
name|end
expr_stmt|;
block|}
name|freeenv
argument_list|(
name|hw_env
argument_list|)
expr_stmt|;
return|return;
name|err_return
label|:
name|panic
argument_list|(
literal|"Invalid xlr.cr setting!"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function_decl
specifier|extern
name|void
name|xlr_secondary_start
parameter_list|(
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|xlr_secondary_entry
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|long
name|sp
decl_stmt|,
name|gp
decl_stmt|;
name|unsigned
name|int
name|cpu
init|=
operator|(
name|xlr_cpu_id
argument_list|()
operator|<<
literal|2
operator|)
operator|+
name|xlr_thr_id
argument_list|()
decl_stmt|;
name|sp
operator|=
name|xlr_secondary_sp
index|[
name|cpu
index|]
expr_stmt|;
name|gp
operator|=
name|xlr_secondary_gp
index|[
name|cpu
index|]
expr_stmt|;
name|xlr_secondary_start
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|mips_secondary_wait
argument_list|,
name|sp
argument_list|,
name|gp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|xlr_set_boot_flags
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|getenv
argument_list|(
literal|"boot_flags"
argument_list|)
init|;
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|boothowto
operator||=
name|RB_KDB
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|boothowto
operator||=
name|RB_GDB
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|boothowto
operator||=
name|RB_VERBOSE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* single-user (default, supported for sanity) */
case|case
literal|'S'
case|:
name|boothowto
operator||=
name|RB_SINGLE
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unrecognized boot flag '%c'.\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p
condition|)
name|freeenv
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
specifier|extern
name|uint32_t
name|_end
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mips_init
parameter_list|(
name|void
parameter_list|)
block|{
name|init_param1
argument_list|()
expr_stmt|;
name|init_param2
argument_list|(
name|physmem
argument_list|)
expr_stmt|;
comment|/* XXX: Catch 22. Something touches the tlb. */
name|mips_cpu_init
argument_list|()
expr_stmt|;
name|pmap_bootstrap
argument_list|()
expr_stmt|;
name|mips_proc0_init
argument_list|()
expr_stmt|;
name|write_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|7
argument_list|,
name|pcpup
operator|->
name|pc_curthread
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|()
expr_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DDB
ifdef|#
directive|ifdef
name|SMP
name|setup_nmi
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SMP */
name|kdb_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|boothowto
operator|&
name|RB_KDB
condition|)
block|{
name|kdb_enter
argument_list|(
literal|"Boot flags requested debugger"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|platform_start
parameter_list|(
name|__register_t
name|a0
name|__unused
parameter_list|,
name|__register_t
name|a1
name|__unused
parameter_list|,
name|__register_t
name|a2
name|__unused
parameter_list|,
name|__register_t
name|a3
name|__unused
parameter_list|)
block|{
name|vm_size_t
name|physsz
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|xlr_boot1_mem_map
modifier|*
name|boot_map
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|uint32_t
name|tmp
decl_stmt|;
name|void
function_decl|(
modifier|*
name|wakeup
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* XXX no zeroing of BSS? */
comment|/* Initialize pcpu stuff */
name|mips_pcpu0_init
argument_list|()
expr_stmt|;
comment|/* XXX FIXME the code below is not 64 bit clean */
comment|/* Save boot loader and other stuff from scratch regs */
name|xlr_boot1_info
operator|=
operator|*
operator|(
expr|struct
name|boot1_info
operator|*
operator|)
name|read_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpu_mask_info
operator|=
name|read_c0_register64
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xlr_online_cpumask
operator|=
name|read_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xlr_run_mode
operator|=
name|read_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|xlr_argc
operator|=
name|read_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|xlr_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|read_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xlr_envp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|read_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* TODO: Verify the magic number here */
comment|/* FIXMELATER: xlr_boot1_info.magic_number */
comment|/* initialize console so that we have printf */
name|boothowto
operator||=
operator|(
name|RB_SERIAL
operator||
name|RB_MULTIPLE
operator|)
expr_stmt|;
comment|/* Use multiple consoles */
comment|/* clockrate used by delay, so initialize it here */
name|cpu_clock
operator|=
name|xlr_boot1_info
operator|.
name|cpu_frequency
operator|/
literal|1000000
expr_stmt|;
comment|/* 	 * Note the time counter on CPU0 runs not at system clock speed, but 	 * at PIC time counter speed (which is returned by 	 * platform_get_frequency(). Thus we do not use 	 * xlr_boot1_info.cpu_frequency here. 	 */
name|mips_timer_early_init
argument_list|(
name|platform_get_frequency
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Init the time counter in the PIC and local putc routine*/
name|rmi_early_counter_init
argument_list|()
expr_stmt|;
comment|/* Init console please */
name|cninit
argument_list|()
expr_stmt|;
name|init_static_kenv
argument_list|(
name|boot1_env
argument_list|,
sizeof|sizeof
argument_list|(
name|boot1_env
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Environment (from %d args):\n"
argument_list|,
name|xlr_argc
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlr_argc
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"\tNone\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|xlr_argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|xlr_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|n
operator|=
name|strsep
argument_list|(
operator|&
name|xlr_argv
index|[
name|i
index|]
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlr_argv
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|setenv
argument_list|(
name|n
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
else|else
name|setenv
argument_list|(
name|n
argument_list|,
name|xlr_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|xlr_set_boot_flags
argument_list|()
expr_stmt|;
comment|/* get physical memory info from boot loader */
name|boot_map
operator|=
operator|(
expr|struct
name|xlr_boot1_mem_map
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|xlr_boot1_info
operator|.
name|psb_mem_map
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|boot_map
operator|->
name|num_entries
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|boot_map
operator|->
name|physmem_map
index|[
name|i
index|]
operator|.
name|type
operator|==
name|BOOT1_MEM_RAM
condition|)
block|{
if|if
condition|(
name|j
operator|==
literal|14
condition|)
block|{
name|printf
argument_list|(
literal|"*** ERROR *** memory map too large ***\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
comment|/* TODO FIXME  */
comment|/* start after kernel end */
name|phys_avail
index|[
literal|0
index|]
operator|=
operator|(
name|vm_paddr_t
operator|)
name|MIPS_KSEG0_TO_PHYS
argument_list|(
operator|&
name|_end
argument_list|)
operator|+
literal|0x20000
expr_stmt|;
comment|/* boot loader start */
comment|/* HACK to Use bootloaders memory region */
comment|/* TODO FIXME  */
if|if
condition|(
name|boot_map
operator|->
name|physmem_map
index|[
literal|0
index|]
operator|.
name|size
operator|==
literal|0x0c000000
condition|)
block|{
name|boot_map
operator|->
name|physmem_map
index|[
literal|0
index|]
operator|.
name|size
operator|=
literal|0x0ff00000
expr_stmt|;
block|}
name|phys_avail
index|[
literal|1
index|]
operator|=
name|boot_map
operator|->
name|physmem_map
index|[
literal|0
index|]
operator|.
name|addr
operator|+
name|boot_map
operator|->
name|physmem_map
index|[
literal|0
index|]
operator|.
name|size
expr_stmt|;
block|}
else|else
block|{
comment|/*  * Can't use this code yet, because most of the fixed allocations happen from  * the biggest physical area. If we have more than 512M memory the kernel will try  * to map from the second are which is not in KSEG0 and not mapped  */
name|phys_avail
index|[
name|j
index|]
operator|=
operator|(
name|vm_paddr_t
operator|)
name|boot_map
operator|->
name|physmem_map
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|phys_avail
index|[
name|j
index|]
operator|+
name|boot_map
operator|->
name|physmem_map
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME TOD0 */
block|phys_avail[j] = phys_avail[j + 1] = 0;
endif|#
directive|endif
block|}
name|physsz
operator|+=
name|boot_map
operator|->
name|physmem_map
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
block|}
block|}
comment|/* FIXME XLR TODO */
name|phys_avail
index|[
name|j
index|]
operator|=
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|realmem
operator|=
name|physmem
operator|=
name|btoc
argument_list|(
name|physsz
argument_list|)
expr_stmt|;
comment|/* Store pcpu in scratch 5 */
name|write_c0_register32
argument_list|(
name|MIPS_COP_0_OSSCRATCH
argument_list|,
literal|5
argument_list|,
name|pcpup
argument_list|)
expr_stmt|;
comment|/* Set up hz, among others. */
name|mips_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* 	 * If thread 0 of any core is not available then mark whole core as 	 * not available 	 */
name|tmp
operator|=
name|xlr_boot1_info
operator|.
name|cpu_online_map
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|+=
literal|4
control|)
block|{
if|if
condition|(
operator|(
name|tmp
operator|&
operator|(
literal|0xf
operator|<<
name|i
operator|)
operator|)
operator|&&
operator|!
operator|(
name|tmp
operator|&
operator|(
literal|0x1
operator|<<
name|i
operator|)
operator|)
condition|)
block|{
comment|/* 			 * Oopps.. thread 0 is not available. Disable whole 			 * core 			 */
name|tmp
operator|=
name|tmp
operator|&
operator|~
operator|(
literal|0xf
operator|<<
name|i
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"WARNING: Core %d is disabled because thread 0"
literal|" of this core is not enabled.\n"
argument_list|,
name|i
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
name|xlr_boot1_info
operator|.
name|cpu_online_map
operator|=
name|tmp
expr_stmt|;
comment|/* Wakeup Other cpus, and put them in bsd park code. */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
comment|/* Allocate stack for all other cpus from fbsd kseg0 memory. */
if|if
condition|(
operator|(
literal|1U
operator|<<
name|i
operator|)
operator|&
name|xlr_boot1_info
operator|.
name|cpu_online_map
condition|)
block|{
name|xlr_secondary_gp
index|[
name|i
index|]
operator|=
name|pmap_steal_memory
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xlr_secondary_gp
index|[
name|i
index|]
condition|)
name|panic
argument_list|(
literal|"Allocation failed for secondary cpu stacks"
argument_list|)
expr_stmt|;
name|xlr_secondary_sp
index|[
name|i
index|]
operator|=
name|xlr_secondary_gp
index|[
name|i
index|]
operator|+
name|PAGE_SIZE
operator|-
name|CALLFRAME_SIZ
expr_stmt|;
name|xlr_secondary_gp
index|[
name|i
index|]
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|&
name|_gp
expr_stmt|;
comment|/* Build ltop and ptol cpu map. */
name|cpu_ltop_map
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
name|cpu_ptol_map
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|0x3
operator|)
operator|==
literal|0
condition|)
comment|/* store thread0 of each core */
name|xlr_core_cpu_mask
operator||=
operator|(
literal|1
operator|<<
name|j
operator|)
expr_stmt|;
name|mips_cpu_logical_mask
operator||=
operator|(
literal|1
operator|<<
name|j
operator|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
name|mips_cpu_online_mask
operator||=
name|xlr_boot1_info
operator|.
name|cpu_online_map
expr_stmt|;
name|wakeup
operator|=
operator|(
operator|(
name|void
argument_list|(
argument|*
argument_list|)
operator|(
name|void
operator|*
operator|,
name|void
operator|*
operator|,
name|unsigned
name|int
operator|)
operator|)
call|(
name|unsigned
name|long
call|)
argument_list|(
name|xlr_boot1_info
operator|.
name|wakeup
argument_list|)
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"Waking up CPUs 0x%llx.\n"
argument_list|,
name|xlr_boot1_info
operator|.
name|cpu_online_map
operator|&
operator|~
operator|(
literal|0x1U
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlr_boot1_info
operator|.
name|cpu_online_map
operator|&
operator|~
operator|(
literal|0x1U
operator|)
condition|)
name|wakeup
argument_list|(
name|xlr_secondary_entry
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|xlr_boot1_info
operator|.
name|cpu_online_map
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* xlr specific post initialization */
comment|/* 	 * The expectation is that mutex_init() is already done in 	 * mips_init() XXX NOTE: We may need to move this to SMP based init 	 * code for each CPU, later. 	 */
name|rmi_spin_mutex_safe
operator|=
literal|1
expr_stmt|;
name|on_chip_init
argument_list|()
expr_stmt|;
name|mips_timer_init_params
argument_list|(
name|platform_get_frequency
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Platform specific startup now completes\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|platform_identify
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Board [%d:%d], processor 0x%08x\n"
argument_list|,
operator|(
name|int
operator|)
name|xlr_boot1_info
operator|.
name|board_major_version
argument_list|,
operator|(
name|int
operator|)
name|xlr_boot1_info
operator|.
name|board_minor_version
argument_list|,
name|mips_rd_prid
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX Maybe return the state of the watchdog in enter, and pass it to  * exit?  Like spl().  */
end_comment

begin_function
name|void
name|platform_trap_enter
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|platform_trap_exit
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  void  platform_update_intrmask(int intr)  {    write_c0_eimr64(read_c0_eimr64() | (1ULL<<intr));  } */
end_comment

begin_function_decl
name|void
name|disable_msgring_int
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|enable_msgring_int
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|xlr_msgring_handler
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|msgring_process_fast_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|msgring_ithread
block|{
name|struct
name|thread
modifier|*
name|i_thread
decl_stmt|;
name|u_int
name|i_pending
decl_stmt|;
name|u_int
name|i_flags
decl_stmt|;
name|int
name|i_cpu
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|msgring_ithread
name|msgring_ithreads
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ithd_name
index|[
name|MAXCPU
index|]
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|msgring_process_fast_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|cpu
init|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
decl_stmt|;
specifier|volatile
name|struct
name|msgring_ithread
modifier|*
name|it
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
comment|/* wakeup an appropriate intr_thread for processing this interrupt */
name|it
operator|=
operator|(
specifier|volatile
expr|struct
name|msgring_ithread
operator|*
operator|)
operator|&
name|msgring_ithreads
index|[
name|cpu
index|]
expr_stmt|;
name|td
operator|=
name|it
operator|->
name|i_thread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* 	 * Interrupt thread will enable the interrupts after processing all 	 * messages 	 */
name|disable_msgring_int
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|it
operator|->
name|i_pending
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TD_AWAITING_INTR
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: schedule pid %d (%s)"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|TD_CLR_IWAIT
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_add
argument_list|(
name|td
argument_list|,
name|SRQ_INTR
argument_list|)
expr_stmt|;
block|}
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MIT_DEAD
value|4
end_define

begin_function
specifier|static
name|void
name|msgring_process
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|volatile
name|struct
name|msgring_ithread
modifier|*
name|ithd
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|ithd
operator|=
operator|(
specifier|volatile
expr|struct
name|msgring_ithread
operator|*
operator|)
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|ithd
operator|->
name|i_thread
operator|==
name|td
argument_list|,
operator|(
literal|"%s:msg_ithread and proc linkage out of sync"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* First bind this thread to the right CPU */
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|td
argument_list|,
name|ithd
operator|->
name|i_cpu
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|//printf("Started %s on CPU %d\n", __FUNCTION__, ithd->i_cpu);
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ithd
operator|->
name|i_flags
operator|&
name|MIT_DEAD
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: pid %d (%s) exiting"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|ithd
operator|->
name|i_pending
condition|)
block|{
comment|/* 			 * This might need a full read and write barrier to 			 * make sure that this write posts before any of the 			 * memory or device accesses in the handlers. 			 */
name|atomic_store_rel_int
argument_list|(
operator|&
name|ithd
operator|->
name|i_pending
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xlr_msgring_handler
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|enable_msgring_int
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ithd
operator|->
name|i_pending
operator|&&
operator|!
operator|(
name|ithd
operator|->
name|i_flags
operator|&
name|MIT_DEAD
operator|)
condition|)
block|{
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|ithd
operator|->
name|i_pending
condition|)
block|{
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sched_class
argument_list|(
name|td
argument_list|,
name|PRI_ITHD
argument_list|)
expr_stmt|;
name|TD_SET_IWAIT
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_VOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|platform_prep_smp_launch
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
name|uint32_t
name|cpu_mask
decl_stmt|;
name|struct
name|msgring_ithread
modifier|*
name|ithd
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cpu_mask
operator|=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
operator||
name|PCPU_GET
argument_list|(
name|other_cpus
argument_list|)
expr_stmt|;
comment|/* Create kernel threads for message ring interrupt processing */
comment|/* Currently create one task for thread 0 of each core */
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|MAXCPU
condition|;
name|cpu
operator|+=
literal|1
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
literal|1
operator|<<
name|cpu
operator|)
operator|&
name|cpu_mask
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cpu_ltop_map
index|[
name|cpu
index|]
operator|%
literal|4
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|ithd
operator|=
operator|&
name|msgring_ithreads
index|[
name|cpu
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|ithd_name
index|[
name|cpu
index|]
argument_list|,
literal|"msg_intr%d"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|error
operator|=
name|kproc_create
argument_list|(
name|msgring_process
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ithd
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|RFSTOPPED
operator||
name|RFHIGHPID
operator|)
argument_list|,
literal|2
argument_list|,
name|ithd_name
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"kproc_create() failed with %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|td
operator|=
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* XXXKSE */
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_class
argument_list|(
name|td
argument_list|,
name|PRI_ITHD
argument_list|)
expr_stmt|;
name|TD_SET_IWAIT
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|ithd
operator|->
name|i_thread
operator|=
name|td
expr_stmt|;
name|ithd
operator|->
name|i_pending
operator|=
literal|0
expr_stmt|;
name|ithd
operator|->
name|i_cpu
operator|=
name|cpu
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: created %s"
argument_list|,
name|__func__
argument_list|,
name|ithd_name
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

