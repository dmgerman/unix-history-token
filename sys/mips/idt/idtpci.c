begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: idtpci.c,v 1.1 2007/03/20 08:52:02 dyoung Exp $ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2007 David Young.  * Copyright (c) 2007 Oleskandr Tymoshenko.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or  * without modification, are permitted provided that the following  * conditions are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above  *    copyright notice, this list of conditions and the following  *    disclaimer in the documentation and/or other materials provided  *    with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,  * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2006 Itronix Inc.  * All rights reserved.  *  * Written by Garrett D'Amore for Itronix Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of Itronix Inc. may not be used to endorse  *    or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY ITRONIX INC. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ITRONIX INC. BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcib_private.h>
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_include
include|#
directive|include
file|<mips/idt/idtreg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IDTPCI_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|idtpci_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IDTPCI_DPRINTF
parameter_list|(
name|__fmt
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {						\ 	if (idtpci_debug)			\ 		printf((__fmt), __VA_ARGS__);	\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !IDTPCI_DEBUG */
end_comment

begin_define
define|#
directive|define
name|IDTPCI_DPRINTF
parameter_list|(
name|__fmt
parameter_list|,
modifier|...
parameter_list|)
value|do { } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IDTPCI_DEBUG */
end_comment

begin_define
define|#
directive|define
name|IDTPCI_TAG_BUS_MASK
value|0x007f0000
end_define

begin_define
define|#
directive|define
name|IDTPCI_TAG_DEVICE_MASK
value|0x00007800
end_define

begin_define
define|#
directive|define
name|IDTPCI_TAG_FUNCTION_MASK
value|0x00000300
end_define

begin_define
define|#
directive|define
name|IDTPCI_TAG_REGISTER_MASK
value|0x0000007c
end_define

begin_define
define|#
directive|define
name|IDTPCI_MAX_DEVICE
end_define

begin_define
define|#
directive|define
name|REG_READ
parameter_list|(
name|o
parameter_list|)
value|*((volatile uint32_t *)MIPS_PHYS_TO_KSEG1(IDT_BASE_PCI + (o)))
end_define

begin_define
define|#
directive|define
name|REG_WRITE
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
value|(REG_READ(o)) = (v)
end_define

begin_decl_stmt
name|unsigned
name|int
name|korina_fixup
index|[
literal|24
index|]
init|=
block|{
literal|0x00000157
block|,
literal|0x00000000
block|,
literal|0x00003c04
block|,
literal|0x00000008
block|,
literal|0x18800001
block|,
literal|0x18000001
block|,
literal|0x48000008
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x011d0214
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x38080101
block|,
literal|0x00008080
block|,
literal|0x00000d6e
block|,
literal|0x00000000
block|,
literal|0x00000051
block|,
literal|0x00000000
block|,
literal|0x00000055
block|,
literal|0x18000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|idtpci_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|int
name|sc_busno
decl_stmt|;
name|struct
name|rman
name|sc_mem_rman
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|rman
name|sc_io_rman
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|rman
name|sc_irq_rman
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|uint32_t
name|idtpci_make_addr
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
return|return
literal|0x80000000
operator||
operator|(
name|bus
operator|<<
literal|16
operator|)
operator||
operator|(
name|slot
operator|<<
literal|11
operator|)
operator||
operator|(
name|func
operator|<<
literal|8
operator|)
operator||
name|reg
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|idtpci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|idtpci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|busno
init|=
literal|0
decl_stmt|;
name|struct
name|idtpci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|pci_data
decl_stmt|,
name|force_endianess
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bus_addr_t
name|addr
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_busno
operator|=
name|busno
expr_stmt|;
comment|/* TODO: Check for host mode */
comment|/* Enabled PCI, IG mode, EAP mode */
name|REG_WRITE
argument_list|(
name|IDT_PCI_CNTL
argument_list|,
name|IDT_PCI_CNTL_IGM
operator||
name|IDT_PCI_CNTL_EAP
operator||
name|IDT_PCI_CNTL_EN
argument_list|)
expr_stmt|;
comment|/* Wait while "Reset in progress bit" set */
while|while
condition|(
literal|1
condition|)
block|{
name|pci_data
operator|=
name|REG_READ
argument_list|(
name|IDT_PCI_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pci_data
operator|&
name|IDT_PCI_STATUS_RIP
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Reset status register */
name|REG_WRITE
argument_list|(
name|IDT_PCI_STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Mask interrupts related to status register */
name|REG_WRITE
argument_list|(
name|IDT_PCI_STATUS_MASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Disable PCI decoupled access */
name|REG_WRITE
argument_list|(
name|IDT_PCI_DAC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Zero status and mask DA interrupts */
name|REG_WRITE
argument_list|(
name|IDT_PCI_DAS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_DASM
argument_list|,
literal|0x7f
argument_list|)
expr_stmt|;
comment|/* Init PCI messaging unit */
comment|/* Disable messaging interrupts */
name|REG_WRITE
argument_list|(
name|IDT_PCI_IIC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_IIM
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_OIC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_OIM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__MIPSEB__
name|force_endianess
operator|=
name|IDT_PCI_LBA_FE
expr_stmt|;
endif|#
directive|endif
comment|/* LBA0 -- memory window */
name|REG_WRITE
argument_list|(
name|IDT_PCI_LBA0
argument_list|,
name|IDT_PCIMEM0_BASE
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_LBA0_MAP
argument_list|,
name|IDT_PCIMEM0_BASE
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_LBA0_CNTL
argument_list|,
name|IDT_PCI_LBA_SIZE_16MB
operator||
name|force_endianess
argument_list|)
expr_stmt|;
name|pci_data
operator|=
name|REG_READ
argument_list|(
name|IDT_PCI_LBA0_CNTL
argument_list|)
expr_stmt|;
comment|/* LBA1 -- memory window */
name|REG_WRITE
argument_list|(
name|IDT_PCI_LBA1
argument_list|,
name|IDT_PCIMEM1_BASE
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_LBA1_MAP
argument_list|,
name|IDT_PCIMEM1_BASE
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_LBA1_CNTL
argument_list|,
name|IDT_PCI_LBA_SIZE_256MB
operator||
name|force_endianess
argument_list|)
expr_stmt|;
name|pci_data
operator|=
name|REG_READ
argument_list|(
name|IDT_PCI_LBA1_CNTL
argument_list|)
expr_stmt|;
comment|/* LBA2 -- IO window */
name|REG_WRITE
argument_list|(
name|IDT_PCI_LBA2
argument_list|,
name|IDT_PCIMEM2_BASE
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_LBA2_MAP
argument_list|,
name|IDT_PCIMEM2_BASE
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_LBA2_CNTL
argument_list|,
name|IDT_PCI_LBA_SIZE_4MB
operator||
name|IDT_PCI_LBA_MSI
operator||
name|force_endianess
argument_list|)
expr_stmt|;
name|pci_data
operator|=
name|REG_READ
argument_list|(
name|IDT_PCI_LBA2_CNTL
argument_list|)
expr_stmt|;
comment|/* LBA3 -- IO window */
name|REG_WRITE
argument_list|(
name|IDT_PCI_LBA3
argument_list|,
name|IDT_PCIMEM3_BASE
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_LBA3_MAP
argument_list|,
name|IDT_PCIMEM3_BASE
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_LBA3_CNTL
argument_list|,
name|IDT_PCI_LBA_SIZE_1MB
operator||
name|IDT_PCI_LBA_MSI
operator||
name|force_endianess
argument_list|)
expr_stmt|;
name|pci_data
operator|=
name|REG_READ
argument_list|(
name|IDT_PCI_LBA3_CNTL
argument_list|)
expr_stmt|;
name|pci_data
operator|=
name|REG_READ
argument_list|(
name|IDT_PCI_CNTL
argument_list|)
operator|&
operator|~
name|IDT_PCI_CNTL_TNR
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_CNTL
argument_list|,
name|pci_data
argument_list|)
expr_stmt|;
name|pci_data
operator|=
name|REG_READ
argument_list|(
name|IDT_PCI_CNTL
argument_list|)
expr_stmt|;
comment|/* Rewrite Target Control register with default values */
name|REG_WRITE
argument_list|(
name|IDT_PCI_TC
argument_list|,
operator|(
name|IDT_PCI_TC_DTIMER
operator|<<
literal|8
operator|)
operator||
name|IDT_PCI_TC_RTIMER
argument_list|)
expr_stmt|;
comment|/* Perform Korina fixup */
name|addr
operator|=
name|idtpci_make_addr
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
block|{
name|REG_WRITE
argument_list|(
name|IDT_PCI_CFG_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_CFG_DATA
argument_list|,
name|korina_fixup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
asm|__asm__
specifier|volatile
asm|("sync");
name|REG_WRITE
argument_list|(
name|IDT_PCI_CFG_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_CFG_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Use KSEG1 to access IO ports for it is uncached */
name|sc
operator|->
name|sc_io_rman
index|[
literal|0
index|]
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|sc
operator|->
name|sc_io_rman
index|[
literal|0
index|]
operator|.
name|rm_descr
operator|=
literal|"IDTPCI I/O Ports window 1"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_io_rman
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
operator|||
name|rman_manage_region
argument_list|(
operator|&
name|sc
operator|->
name|sc_io_rman
index|[
literal|0
index|]
argument_list|,
name|IDT_PCIMEM2_BASE
argument_list|,
name|IDT_PCIMEM2_BASE
operator|+
name|IDT_PCIMEM2_SIZE
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"idtpci_attach: failed to set up I/O rman"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_io_rman
index|[
literal|1
index|]
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|sc
operator|->
name|sc_io_rman
index|[
literal|1
index|]
operator|.
name|rm_descr
operator|=
literal|"IDTPCI I/O Ports window 2"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_io_rman
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
operator|||
name|rman_manage_region
argument_list|(
operator|&
name|sc
operator|->
name|sc_io_rman
index|[
literal|1
index|]
argument_list|,
name|IDT_PCIMEM3_BASE
argument_list|,
name|IDT_PCIMEM3_BASE
operator|+
name|IDT_PCIMEM3_SIZE
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"idtpci_attach: failed to set up I/O rman"
argument_list|)
expr_stmt|;
block|}
comment|/* Use KSEG1 to access PCI memory for it is uncached */
name|sc
operator|->
name|sc_mem_rman
index|[
literal|0
index|]
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|sc
operator|->
name|sc_mem_rman
index|[
literal|0
index|]
operator|.
name|rm_descr
operator|=
literal|"IDTPCI PCI Memory window 1"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mem_rman
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
operator|||
name|rman_manage_region
argument_list|(
operator|&
name|sc
operator|->
name|sc_mem_rman
index|[
literal|0
index|]
argument_list|,
name|IDT_PCIMEM0_BASE
argument_list|,
name|IDT_PCIMEM0_BASE
operator|+
name|IDT_PCIMEM0_SIZE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"idtpci_attach: failed to set up memory rman"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_mem_rman
index|[
literal|1
index|]
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|sc
operator|->
name|sc_mem_rman
index|[
literal|1
index|]
operator|.
name|rm_descr
operator|=
literal|"IDTPCI PCI Memory window 2"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mem_rman
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
operator|||
name|rman_manage_region
argument_list|(
operator|&
name|sc
operator|->
name|sc_mem_rman
index|[
literal|1
index|]
argument_list|,
name|IDT_PCIMEM1_BASE
argument_list|,
name|IDT_PCIMEM1_BASE
operator|+
name|IDT_PCIMEM1_SIZE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"idtpci_attach: failed to set up memory rman"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_irq_rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|sc
operator|->
name|sc_irq_rman
operator|.
name|rm_descr
operator|=
literal|"IDTPCI PCI IRQs"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_irq_rman
argument_list|)
operator|!=
literal|0
operator|||
name|rman_manage_region
argument_list|(
operator|&
name|sc
operator|->
name|sc_irq_rman
argument_list|,
name|PCI_IRQ_BASE
argument_list|,
name|PCI_IRQ_END
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"idtpci_attach: failed to set up IRQ rman"
argument_list|)
expr_stmt|;
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pci"
argument_list|,
name|busno
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|idtpci_maxslots
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|PCI_SLOTMAX
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|idtpci_read_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|uint32_t
name|data
decl_stmt|;
name|uint32_t
name|shift
decl_stmt|,
name|mask
decl_stmt|;
name|bus_addr_t
name|addr
decl_stmt|;
name|IDTPCI_DPRINTF
argument_list|(
literal|"%s: tag (%x, %x, %x) reg %d(%d)\n"
argument_list|,
name|__func__
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
name|reg
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|addr
operator|=
name|idtpci_make_addr
argument_list|(
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_CFG_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|data
operator|=
name|REG_READ
argument_list|(
name|IDT_PCI_CFG_DATA
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reg
operator|%
literal|4
condition|)
block|{
case|case
literal|3
case|:
name|shift
operator|=
literal|24
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|shift
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|shift
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|shift
operator|=
literal|0
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|bytes
condition|)
block|{
case|case
literal|1
case|:
name|mask
operator|=
literal|0xff
expr_stmt|;
name|data
operator|=
operator|(
name|data
operator|>>
name|shift
operator|)
operator|&
name|mask
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mask
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|reg
operator|%
literal|4
operator|==
literal|0
condition|)
name|data
operator|=
name|data
operator|&
name|mask
expr_stmt|;
else|else
name|data
operator|=
operator|(
name|data
operator|>>
literal|16
operator|)
operator|&
name|mask
expr_stmt|;
break|break;
case|case
literal|4
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: wrong bytes count"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
asm|__asm__
specifier|volatile
asm|("sync");
name|IDTPCI_DPRINTF
argument_list|(
literal|"%s: read 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|idtpci_write_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|bus_addr_t
name|addr
decl_stmt|;
name|uint32_t
name|reg_data
decl_stmt|;
name|uint32_t
name|shift
decl_stmt|,
name|mask
decl_stmt|;
name|IDTPCI_DPRINTF
argument_list|(
literal|"%s: tag (%x, %x, %x) reg %d(%d) data %08x\n"
argument_list|,
name|__func__
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
name|reg
argument_list|,
name|bytes
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
literal|4
condition|)
block|{
name|reg_data
operator|=
name|idtpci_read_config
argument_list|(
name|dev
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reg
operator|%
literal|4
condition|)
block|{
case|case
literal|3
case|:
name|shift
operator|=
literal|24
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|shift
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|shift
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|shift
operator|=
literal|0
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|bytes
condition|)
block|{
case|case
literal|1
case|:
name|mask
operator|=
literal|0xff
expr_stmt|;
name|data
operator|=
operator|(
name|reg_data
operator|&
operator|~
operator|(
name|mask
operator|<<
name|shift
operator|)
operator|)
operator||
operator|(
name|data
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mask
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|reg
operator|%
literal|4
operator|==
literal|0
condition|)
name|data
operator|=
operator|(
name|reg_data
operator|&
operator|~
name|mask
operator|)
operator||
name|data
expr_stmt|;
else|else
name|data
operator|=
operator|(
name|reg_data
operator|&
operator|~
operator|(
name|mask
operator|<<
name|shift
operator|)
operator|)
operator||
operator|(
name|data
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: wrong bytes count"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|addr
operator|=
name|idtpci_make_addr
argument_list|(
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_CFG_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_CFG_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
asm|__asm__
specifier|volatile
asm|("sync");
name|REG_WRITE
argument_list|(
name|IDT_PCI_CFG_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|IDT_PCI_CFG_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|idtpci_route_interrupt
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|device
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
specifier|static
name|int
name|idt_pci_table
index|[
literal|2
index|]
index|[
literal|12
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|}
block|}
decl_stmt|;
name|int
name|dev
decl_stmt|,
name|bus
decl_stmt|,
name|irq
decl_stmt|;
name|dev
operator|=
name|pci_get_slot
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|pcib
argument_list|,
literal|"routing pin %d for %s\n"
argument_list|,
name|pin
argument_list|,
name|device_get_nameunit
argument_list|(
name|device
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|>=
literal|0
operator|&&
name|bus
operator|<=
literal|1
operator|&&
name|dev
operator|>=
literal|0
operator|&&
name|dev
operator|<=
literal|11
condition|)
block|{
name|irq
operator|=
name|IP_IRQ
argument_list|(
literal|6
argument_list|,
name|idt_pci_table
index|[
name|bus
index|]
index|[
name|dev
index|]
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"idtpci: %d/%d/%d -> IRQ%d\n"
argument_list|,
name|pci_get_bus
argument_list|(
name|device
argument_list|)
argument_list|,
name|dev
argument_list|,
name|pci_get_function
argument_list|(
name|device
argument_list|)
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
name|irq
operator|)
return|;
block|}
else|else
name|printf
argument_list|(
literal|"idtpci: no mapping for %d/%d/%d\n"
argument_list|,
name|pci_get_bus
argument_list|(
name|device
argument_list|)
argument_list|,
name|dev
argument_list|,
name|pci_get_function
argument_list|(
name|device
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|idtpci_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|idtpci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCIB_IVAR_DOMAIN
case|:
operator|*
name|result
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PCIB_IVAR_BUS
case|:
operator|*
name|result
operator|=
name|sc
operator|->
name|sc_busno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|idtpci_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
name|result
parameter_list|)
block|{
name|struct
name|idtpci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCIB_IVAR_BUS
case|:
name|sc
operator|->
name|sc_busno
operator|=
name|result
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|idtpci_alloc_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|idtpci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|rv
init|=
name|NULL
decl_stmt|;
name|struct
name|rman
modifier|*
name|rm1
decl_stmt|,
modifier|*
name|rm2
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IRQ
case|:
name|rm1
operator|=
operator|&
name|sc
operator|->
name|sc_irq_rman
expr_stmt|;
name|rm2
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|rm1
operator|=
operator|&
name|sc
operator|->
name|sc_mem_rman
index|[
literal|0
index|]
expr_stmt|;
name|rm2
operator|=
operator|&
name|sc
operator|->
name|sc_mem_rman
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|SYS_RES_IOPORT
case|:
name|rm1
operator|=
operator|&
name|sc
operator|->
name|sc_io_rman
index|[
literal|0
index|]
expr_stmt|;
name|rm2
operator|=
operator|&
name|sc
operator|->
name|sc_io_rman
index|[
literal|1
index|]
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rv
operator|=
name|rman_reserve_resource
argument_list|(
name|rm1
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|,
name|child
argument_list|)
expr_stmt|;
comment|/* Try second window if it exists */
if|if
condition|(
operator|(
name|rv
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|rm2
operator|!=
name|NULL
operator|)
condition|)
name|rv
operator|=
name|rman_reserve_resource
argument_list|(
name|rm2
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rman_set_rid
argument_list|(
name|rv
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RF_ACTIVE
condition|)
block|{
if|if
condition|(
name|bus_activate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|rv
argument_list|)
condition|)
block|{
name|rman_release_resource
argument_list|(
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|idtpci_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
return|return
operator|(
name|intr_event_remove_handler
argument_list|(
name|cookie
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|idtpci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|idtpci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|idtpci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|idtpci_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|idtpci_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|idtpci_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|bus_generic_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bus_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|idtpci_teardown_intr
argument_list|)
block|,
comment|/* pcib interface */
name|DEVMETHOD
argument_list|(
name|pcib_maxslots
argument_list|,
name|idtpci_maxslots
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_read_config
argument_list|,
name|idtpci_read_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_write_config
argument_list|,
name|idtpci_write_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_route_interrupt
argument_list|,
name|idtpci_route_interrupt
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|idtpci_driver
init|=
block|{
literal|"pcib"
block|,
name|idtpci_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|idtpci_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|idtpci_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|idtpci
argument_list|,
name|obio
argument_list|,
name|idtpci_driver
argument_list|,
name|idtpci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

