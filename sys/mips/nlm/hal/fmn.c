begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2003-2011 Netlogic Microsystems (Netlogic). All rights  * reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  *  * NETLOGIC_BSD */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<mips/nlm/hal/mips-extns.h>
end_include

begin_include
include|#
directive|include
file|<mips/nlm/hal/haldefs.h>
end_include

begin_include
include|#
directive|include
file|<mips/nlm/hal/iomap.h>
end_include

begin_include
include|#
directive|include
file|<mips/nlm/hal/fmn.h>
end_include

begin_comment
comment|/* XLP can take upto 16K of FMN messages per hardware queue, as spill. * But, configuring all 16K causes the total spill memory to required * to blow upto 192MB for single chip configuration, and 768MB in four * chip configuration. Hence for now, we will setup the per queue spill * as 1K FMN messages. With this, the total spill memory needed for 1024 * hardware queues (with 12bytes per single entry FMN message) becomes * (1*1024)*12*1024queues = 12MB. For the four chip config, the memory * needed = 12 * 4 = 48MB. */
end_comment

begin_decl_stmt
name|uint64_t
name|nlm_cms_spill_total_messages
init|=
literal|1
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On a XLP832, we have the following FMN stations: * CPU    stations: 8 * PCIE0  stations: 1 * PCIE1  stations: 1 * PCIE2  stations: 1 * PCIE3  stations: 1 * GDX    stations: 1 * CRYPTO stations: 1 * RSA    stations: 1 * CMP    stations: 1 * POE    stations: 1 * NAE    stations: 1 * ================== * Total          : 18 stations per chip * * For all 4 nodes, there are 18*4 = 72 FMN stations */
end_comment

begin_decl_stmt
name|uint32_t
name|nlm_cms_total_stations
init|=
literal|18
operator|*
literal|4
comment|/*xlp_num_nodes*/
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Takes inputs as node, queue_size and maximum number of queues.  * Calculates the base, start& end and returns the same for a  * defined qid.  *  * The output queues are maintained in the internal output buffer  * which is a on-chip SRAM structure. For the actial hardware  * internal implementation, It is a structure which consists  * of eight banks of 4096-entry x message-width SRAMs. The SRAM  * implementation is designed to run at 1GHz with a 1-cycle read/write  * access. A read/write transaction can be initiated for each bank  * every cycle for a total of eight accesses per cycle. Successive  * entries of the same output queue are placed in successive banks.  * This is done to spread different read& write accesses to same/different  * output queue over as many different banks as possible so that they  * can be scheduled concurrently. Spreading the accesses to as many banks  * as possible to maximize the concurrency internally is important for  * achieving the desired peak throughput. This is done by h/w implementation  * itself.  *  * Output queues are allocated from this internal output buffer by  * software. The total capacity of the output buffer is 32K-entry.  * Each output queue can be sized from 32-entry to 1024-entry in  * increments of 32-entry. This is done by specifying a Start& a  * End pointer: pointers to the first& last 32-entry chunks allocated  * to the output queue.  *  * To optimize the storage required for 1024 OQ pointers, the upper 5-bits  * are shared by the Start& the End pointer. The side-effect of this  * optimization is that an OQ can't cross a 1024-entry boundary. Also, the  * lower 5-bits don't need to be specified in the Start& the End pointer  * as the allocation is in increments of 32-entries.  *  * Queue occupancy is tracked by a Head& a Tail pointer. Tail pointer  * indicates the location to which next entry will be written& Head  * pointer indicates the location from which next entry will be read. When  * these pointers reach the top of the allocated space (indicated by the  * End pointer), they are reset to the bottom of the allocated space  * (indicated by the Start pointer).  *  * Output queue pointer information:  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  *  *   14               10 9              5 4                 0  *   ------------------  *   | base ptr       |  *   ------------------  *                       ----------------  *                       | start ptr    |  *                       ----------------  *                       ----------------  *                       | end   ptr    |  *                       ----------------  *                       ------------------------------------  *                       |           head ptr               |  *                       ------------------------------------  *                       ------------------------------------  *                       |           tail ptr               |  *                       ------------------------------------  * Note:  * A total of 1024 segments can sit on one software-visible "bank"  * of internal SRAM. Each segment contains 32 entries. Also note  * that sw-visible "banks" are not the same as the actual internal  * 8-bank implementation of hardware. It is an optimization of  * internal access.  *  */
end_comment

begin_function
name|void
name|nlm_cms_setup_credits
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|destid
parameter_list|,
name|int
name|srcid
parameter_list|,
name|int
name|credit
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|credit
operator|<<
literal|24
operator|)
operator||
operator|(
name|destid
operator|<<
literal|12
operator|)
operator||
operator|(
name|srcid
operator|<<
literal|0
operator|)
operator|)
expr_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_OUTPUTQ_CREDIT_CFG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * base		- CMS module base address for this node.  * qid		- is the output queue id otherwise called as vc id  * spill_base   - is the 40-bit physical address of spill memory. Must be 		  4KB aligned.  * nsegs	- No of segments where a "1" indicates 4KB. Spill size must be  *                a multiple of 4KB.  */
end_comment

begin_function
name|int
name|nlm_cms_alloc_spill_q
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|qid
parameter_list|,
name|uint64_t
name|spill_base
parameter_list|,
name|int
name|nsegs
parameter_list|)
block|{
name|uint64_t
name|queue_config
decl_stmt|;
name|uint32_t
name|spill_start
decl_stmt|;
if|if
condition|(
name|nsegs
operator|>
name|CMS_MAX_SPILL_SEGMENTS_PER_QUEUE
condition|)
block|{
return|return
literal|1
return|;
block|}
name|queue_config
operator|=
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
operator|(
name|CMS_OUTPUTQ_CONFIG
argument_list|(
name|qid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|spill_start
operator|=
operator|(
operator|(
name|spill_base
operator|>>
literal|12
operator|)
operator|&
literal|0x3F
operator|)
expr_stmt|;
comment|/* Spill configuration */
name|queue_config
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|CMS_SPILL_ENA
operator|<<
literal|62
operator|)
operator||
operator|(
operator|(
operator|(
name|spill_base
operator|>>
literal|18
operator|)
operator|&
literal|0x3FFFFF
operator|)
operator|<<
literal|27
operator|)
operator||
operator|(
name|spill_start
operator|+
name|nsegs
operator|-
literal|1
operator|)
operator|<<
literal|21
operator||
operator|(
name|spill_start
operator|<<
literal|15
operator|)
operator|)
expr_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
operator|(
name|CMS_OUTPUTQ_CONFIG
argument_list|(
name|qid
argument_list|)
operator|)
argument_list|,
name|queue_config
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|uint64_t
name|nlm_cms_get_onchip_queue
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
return|return
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_OUTPUTQ_CONFIG
argument_list|(
name|qid
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|nlm_cms_set_onchip_queue
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|qid
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|uint64_t
name|rdval
decl_stmt|;
name|rdval
operator|=
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_OUTPUTQ_CONFIG
argument_list|(
name|qid
argument_list|)
argument_list|)
expr_stmt|;
name|rdval
operator||=
name|val
expr_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_OUTPUTQ_CONFIG
argument_list|(
name|qid
argument_list|)
argument_list|,
name|rdval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nlm_cms_per_queue_level_intr
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|qid
parameter_list|,
name|int
name|sub_type
parameter_list|,
name|int
name|intr_val
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_OUTPUTQ_CONFIG
argument_list|(
name|qid
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
operator|(
literal|0x7ULL
operator|<<
literal|56
operator|)
operator||
operator|(
literal|0x3ULL
operator|<<
literal|54
operator|)
operator|)
expr_stmt|;
name|val
operator||=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|sub_type
operator|<<
literal|54
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|intr_val
operator|<<
literal|56
operator|)
operator|)
expr_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_OUTPUTQ_CONFIG
argument_list|(
name|qid
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nlm_cms_per_queue_timer_intr
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|qid
parameter_list|,
name|int
name|sub_type
parameter_list|,
name|int
name|intr_val
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_OUTPUTQ_CONFIG
argument_list|(
name|qid
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
operator|(
literal|0x7ULL
operator|<<
literal|51
operator|)
operator||
operator|(
literal|0x3ULL
operator|<<
literal|49
operator|)
operator|)
expr_stmt|;
name|val
operator||=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|sub_type
operator|<<
literal|49
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|intr_val
operator|<<
literal|51
operator|)
operator|)
expr_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_OUTPUTQ_CONFIG
argument_list|(
name|qid
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* returns 1 if interrupt has been generated for this output queue */
end_comment

begin_function
name|int
name|nlm_cms_outputq_intr_check
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_OUTPUTQ_CONFIG
argument_list|(
name|qid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|val
operator|>>
literal|59
operator|)
operator|&
literal|0x1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nlm_cms_outputq_clr_intr
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_OUTPUTQ_CONFIG
argument_list|(
name|qid
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
literal|1ULL
operator|<<
literal|59
operator|)
expr_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_OUTPUTQ_CONFIG
argument_list|(
name|qid
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nlm_cms_illegal_dst_error_intr
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|en
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_CONFIG
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|en
operator|<<
literal|8
operator|)
expr_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nlm_cms_timeout_error_intr
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|en
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_CONFIG
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|en
operator|<<
literal|7
operator|)
expr_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nlm_cms_biu_error_resp_intr
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|en
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_CONFIG
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|en
operator|<<
literal|6
operator|)
expr_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nlm_cms_spill_uncorrectable_ecc_error_intr
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|en
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_CONFIG
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|en
operator|<<
literal|5
operator|)
operator||
operator|(
name|en
operator|<<
literal|3
operator|)
expr_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nlm_cms_spill_correctable_ecc_error_intr
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|en
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_CONFIG
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|en
operator|<<
literal|4
operator|)
operator||
operator|(
name|en
operator|<<
literal|2
operator|)
expr_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nlm_cms_outputq_uncorrectable_ecc_error_intr
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|en
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_CONFIG
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|en
operator|<<
literal|1
operator|)
expr_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nlm_cms_outputq_correctable_ecc_error_intr
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|en
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_CONFIG
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|en
operator|<<
literal|0
operator|)
expr_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|nlm_cms_network_error_status
parameter_list|(
name|uint64_t
name|base
parameter_list|)
block|{
return|return
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_ERR
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|nlm_cms_get_net_error_code
parameter_list|(
name|uint64_t
name|err
parameter_list|)
block|{
return|return
operator|(
operator|(
name|err
operator|>>
literal|12
operator|)
operator|&
literal|0xf
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nlm_cms_get_net_error_syndrome
parameter_list|(
name|uint64_t
name|err
parameter_list|)
block|{
return|return
operator|(
operator|(
name|err
operator|>>
literal|32
operator|)
operator|&
literal|0x1ff
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nlm_cms_get_net_error_ramindex
parameter_list|(
name|uint64_t
name|err
parameter_list|)
block|{
return|return
operator|(
operator|(
name|err
operator|>>
literal|44
operator|)
operator|&
literal|0x7fff
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nlm_cms_get_net_error_outputq
parameter_list|(
name|uint64_t
name|err
parameter_list|)
block|{
return|return
operator|(
operator|(
name|err
operator|>>
literal|16
operator|)
operator|&
literal|0xfff
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================= FMN Tracing related APIs ================*/
end_comment

begin_function
name|void
name|nlm_cms_trace_setup
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|en
parameter_list|,
name|uint64_t
name|trace_base
parameter_list|,
name|uint64_t
name|trace_limit
parameter_list|,
name|int
name|match_dstid_en
parameter_list|,
name|int
name|dst_id
parameter_list|,
name|int
name|match_srcid_en
parameter_list|,
name|int
name|src_id
parameter_list|,
name|int
name|wrap
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_TRACE_BASE_ADDR
argument_list|,
name|trace_base
argument_list|)
expr_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_TRACE_LIMIT_ADDR
argument_list|,
name|trace_limit
argument_list|)
expr_stmt|;
name|val
operator|=
name|nlm_read_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_TRACE_CONFIG
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|match_dstid_en
operator|<<
literal|39
operator|)
operator||
operator|(
operator|(
name|dst_id
operator|&
literal|0xfff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|match_srcid_en
operator|<<
literal|23
operator|)
operator||
operator|(
operator|(
name|src_id
operator|&
literal|0xfff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|wrap
operator|<<
literal|1
operator|)
operator||
operator|(
name|en
operator|<<
literal|0
operator|)
operator|)
expr_stmt|;
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nlm_cms_endian_byte_swap
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|en
parameter_list|)
block|{
name|nlm_write_cms_reg
argument_list|(
name|base
argument_list|,
name|CMS_MSG_ENDIAN_SWAP
argument_list|,
name|en
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

