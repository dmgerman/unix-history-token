begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: if_admsw.c,v 1.3 2007/04/22 19:26:25 dyoung Exp $ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2007 Ruslan Ermilov and Vsevolod Lobko.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or  * without modification, are permitted provided that the following  * conditions are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above  *    copyright notice, this list of conditions and the following  *    disclaimer in the documentation and/or other materials provided  *    with the distribution.  * 3. The names of the authors may not be used to endorse or promote  *    products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,  * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2001 Wasabi Systems, Inc.  * All rights reserved.  *  * Written by Jason R. Thorpe for Wasabi Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed for the NetBSD Project by  *	Wasabi Systems, Inc.  * 4. The name of Wasabi Systems, Inc. may not be used to endorse  *    or promote products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Device driver for Alchemy Semiconductor Au1x00 Ethernet Media  * Access Controller.  *  * TODO:  *  *	Better Rx buffer management; we want to get new Rx buffers  *	to the chip more quickly than we currently do.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_include
include|#
directive|include
file|<mips/adm5120/adm5120reg.h>
end_include

begin_include
include|#
directive|include
file|<mips/adm5120/if_admswreg.h>
end_include

begin_include
include|#
directive|include
file|<mips/adm5120/if_admswvar.h>
end_include

begin_comment
comment|/* TODO: add locking */
end_comment

begin_define
define|#
directive|define
name|ADMSW_LOCK
parameter_list|(
name|sc
parameter_list|)
value|do {} while(0);
end_define

begin_define
define|#
directive|define
name|ADMSW_UNLOCK
parameter_list|(
name|sc
parameter_list|)
value|do {} while(0);
end_define

begin_decl_stmt
specifier|static
name|uint8_t
name|vlan_matrix
index|[
name|SW_DEVS
index|]
init|=
block|{
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
comment|/* CPU + port0 */
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
comment|/* CPU + port1 */
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
comment|/* CPU + port2 */
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
comment|/* CPU + port3 */
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
comment|/* CPU + port4 */
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
comment|/* CPU + port5 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ifnet entry points */
end_comment

begin_function_decl
specifier|static
name|void
name|admsw_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|admsw_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|admsw_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|admsw_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|admsw_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|admsw_reset
parameter_list|(
name|struct
name|admsw_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|admsw_set_filter
parameter_list|(
name|struct
name|admsw_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|admsw_txintr
parameter_list|(
name|struct
name|admsw_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|admsw_rxintr
parameter_list|(
name|struct
name|admsw_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|admsw_add_rxbuf
parameter_list|(
name|struct
name|admsw_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|admsw_add_rxhbuf
parameter_list|(
name|sc
parameter_list|,
name|idx
parameter_list|)
value|admsw_add_rxbuf(sc, idx, 1)
end_define

begin_define
define|#
directive|define
name|admsw_add_rxlbuf
parameter_list|(
name|sc
parameter_list|,
name|idx
parameter_list|)
value|admsw_add_rxbuf(sc, idx, 0)
end_define

begin_function_decl
specifier|static
name|int
name|admsw_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|admsw_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|admsw_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* bus entry points */
end_comment

begin_function_decl
specifier|static
name|int
name|admsw_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|admsw_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|admsw_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|admsw_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|admsw_dma_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|uint32_t
modifier|*
name|addr
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|KASSERT
argument_list|(
name|nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"too many DMA segments, %d should be 1"
operator|,
name|nseg
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|admsw_rxbuf_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|admsw_descsoft
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|KASSERT
argument_list|(
name|nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"too many DMA segments, %d should be 1"
operator|,
name|nseg
operator|)
argument_list|)
expr_stmt|;
name|ds
operator|=
name|arg
expr_stmt|;
name|ds
operator|->
name|ds_nsegs
operator|=
name|nseg
expr_stmt|;
name|ds
operator|->
name|ds_addr
index|[
literal|0
index|]
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|ds
operator|->
name|ds_len
index|[
literal|0
index|]
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|admsw_mbuf_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|admsw_descsoft
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|ds
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|nseg
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|nseg
operator|!=
literal|2
operator|)
condition|)
name|panic
argument_list|(
literal|"%s: nseg == %d\n"
argument_list|,
name|__func__
argument_list|,
name|nseg
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_nsegs
operator|=
name|nseg
expr_stmt|;
name|ds
operator|->
name|ds_addr
index|[
literal|0
index|]
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|ds
operator|->
name|ds_len
index|[
literal|0
index|]
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
expr_stmt|;
if|if
condition|(
name|nseg
operator|>
literal|1
condition|)
block|{
name|ds
operator|->
name|ds_addr
index|[
literal|1
index|]
operator|=
name|segs
index|[
literal|1
index|]
operator|.
name|ds_addr
expr_stmt|;
name|ds
operator|->
name|ds_len
index|[
literal|1
index|]
operator|=
name|segs
index|[
literal|1
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|admsw_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ADM5120 Switch Engine"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|REG_READ
parameter_list|(
name|o
parameter_list|)
value|bus_read_4((sc)->mem_res, (o))
end_define

begin_define
define|#
directive|define
name|REG_WRITE
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
value|bus_write_4((sc)->mem_res, (o),(v))
end_define

begin_function
specifier|static
name|void
name|admsw_init_bufs
parameter_list|(
name|struct
name|admsw_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|admsw_desc
modifier|*
name|desc
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ADMSW_NTXHDESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_txhsoft
index|[
name|i
index|]
operator|.
name|ds_mbuf
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_txhsoft
index|[
name|i
index|]
operator|.
name|ds_mbuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txhsoft
index|[
name|i
index|]
operator|.
name|ds_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|desc
operator|=
operator|&
name|sc
operator|->
name|sc_txhdescs
index|[
name|i
index|]
expr_stmt|;
name|desc
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|cntl
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|len
operator|=
name|MAC_BUFLEN
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|ADMSW_CDTXHSYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_txhdescs
index|[
name|ADMSW_NTXHDESC
operator|-
literal|1
index|]
operator|.
name|data
operator||=
name|ADM5120_DMA_RINGEND
expr_stmt|;
name|ADMSW_CDTXHSYNC
argument_list|(
name|sc
argument_list|,
name|ADMSW_NTXHDESC
operator|-
literal|1
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ADMSW_NRXHDESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rxhsoft
index|[
name|i
index|]
operator|.
name|ds_mbuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|admsw_add_rxhbuf
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"admsw_init_bufs\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|ADMSW_INIT_RXHDESC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ADMSW_NTXLDESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_txlsoft
index|[
name|i
index|]
operator|.
name|ds_mbuf
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_txlsoft
index|[
name|i
index|]
operator|.
name|ds_mbuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txlsoft
index|[
name|i
index|]
operator|.
name|ds_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|desc
operator|=
operator|&
name|sc
operator|->
name|sc_txldescs
index|[
name|i
index|]
expr_stmt|;
name|desc
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|cntl
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|len
operator|=
name|MAC_BUFLEN
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|ADMSW_CDTXLSYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_txldescs
index|[
name|ADMSW_NTXLDESC
operator|-
literal|1
index|]
operator|.
name|data
operator||=
name|ADM5120_DMA_RINGEND
expr_stmt|;
name|ADMSW_CDTXLSYNC
argument_list|(
name|sc
argument_list|,
name|ADMSW_NTXLDESC
operator|-
literal|1
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ADMSW_NRXLDESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rxlsoft
index|[
name|i
index|]
operator|.
name|ds_mbuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|admsw_add_rxlbuf
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"admsw_init_bufs\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|ADMSW_INIT_RXLDESC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|REG_WRITE
argument_list|(
name|SEND_HBADDR_REG
argument_list|,
name|ADMSW_CDTXHADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|SEND_LBADDR_REG
argument_list|,
name|ADMSW_CDTXLADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|RECV_HBADDR_REG
argument_list|,
name|ADMSW_CDRXHADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|RECV_LBADDR_REG
argument_list|,
name|ADMSW_CDRXLADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txfree
operator|=
name|ADMSW_NTXLDESC
expr_stmt|;
name|sc
operator|->
name|sc_txnext
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_txdirty
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rxptr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|admsw_setvlan
parameter_list|(
name|struct
name|admsw_softc
modifier|*
name|sc
parameter_list|,
name|char
name|matrix
index|[
literal|6
index|]
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|i
operator|=
name|matrix
index|[
literal|0
index|]
operator|+
operator|(
name|matrix
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|matrix
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|matrix
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|VLAN_G1_REG
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|matrix
index|[
literal|4
index|]
operator|+
operator|(
name|matrix
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|VLAN_G2_REG
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|admsw_reset
parameter_list|(
name|struct
name|admsw_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|wdog1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|REG_WRITE
argument_list|(
name|PORT_CONF0_REG
argument_list|,
name|REG_READ
argument_list|(
name|PORT_CONF0_REG
argument_list|)
operator||
name|PORT_CONF0_DP_MASK
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|CPUP_CONF_REG
argument_list|,
name|REG_READ
argument_list|(
name|CPUP_CONF_REG
argument_list|)
operator||
name|CPUP_CONF_DCPUP
argument_list|)
expr_stmt|;
comment|/* Wait for DMA to complete.  Overkill.  In 3ms, we can 	 * send at least two entire 1500-byte packets at 10 Mb/s. 	 */
name|DELAY
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
comment|/* The datasheet recommends that we move all PHYs to reset 	 * state prior to software reset. 	 */
name|REG_WRITE
argument_list|(
name|PHY_CNTL2_REG
argument_list|,
name|REG_READ
argument_list|(
name|PHY_CNTL2_REG
argument_list|)
operator|&
operator|~
name|PHY_CNTL2_PHYR_MASK
argument_list|)
expr_stmt|;
comment|/* Reset the switch. */
name|REG_WRITE
argument_list|(
name|ADMSW_SW_RES
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|ADMSW_BOOT_DONE
argument_list|,
name|ADMSW_BOOT_DONE_BO
argument_list|)
expr_stmt|;
comment|/* begin old code */
name|REG_WRITE
argument_list|(
name|CPUP_CONF_REG
argument_list|,
name|CPUP_CONF_DCPUP
operator||
name|CPUP_CONF_CRCP
operator||
name|CPUP_CONF_DUNP_MASK
operator||
name|CPUP_CONF_DMCP_MASK
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|PORT_CONF0_REG
argument_list|,
name|PORT_CONF0_EMCP_MASK
operator||
name|PORT_CONF0_EMBP_MASK
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|PHY_CNTL2_REG
argument_list|,
name|REG_READ
argument_list|(
name|PHY_CNTL2_REG
argument_list|)
operator||
name|PHY_CNTL2_ANE_MASK
operator||
name|PHY_CNTL2_PHYR_MASK
operator||
name|PHY_CNTL2_AMDIX_MASK
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|PHY_CNTL3_REG
argument_list|,
name|REG_READ
argument_list|(
name|PHY_CNTL3_REG
argument_list|)
operator||
name|PHY_CNTL3_RNT
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|ADMSW_INT_MASK
argument_list|,
name|INT_MASK
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|ADMSW_INT_ST
argument_list|,
name|INT_MASK
argument_list|)
expr_stmt|;
comment|/* 	 * While in DDB, we stop servicing interrupts, RX ring 	 * fills up and when free block counter falls behind FC 	 * threshold, the switch starts to emit 802.3x PAUSE 	 * frames.  This can upset peer switches. 	 * 	 * Stop this from happening by disabling FC and D2 	 * thresholds. 	 */
name|REG_WRITE
argument_list|(
name|FC_TH_REG
argument_list|,
name|REG_READ
argument_list|(
name|FC_TH_REG
argument_list|)
operator|&
operator|~
operator|(
name|FC_TH_FCS_MASK
operator||
name|FC_TH_D2S_MASK
operator|)
argument_list|)
expr_stmt|;
name|admsw_setvlan
argument_list|(
name|sc
argument_list|,
name|vlan_matrix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SW_DEVS
condition|;
name|i
operator|++
control|)
block|{
name|REG_WRITE
argument_list|(
name|MAC_WT1_REG
argument_list|,
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator||
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|4
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|5
index|]
operator|+
name|i
operator|)
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|MAC_WT0_REG
argument_list|,
operator|(
name|i
operator|<<
name|MAC_WT0_VLANID_SHIFT
operator|)
operator||
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator|<<
literal|24
operator|)
operator||
name|MAC_WT0_WRITE
operator||
name|MAC_WT0_VLANID_EN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|REG_READ
argument_list|(
name|MAC_WT0_REG
argument_list|)
operator|&
name|MAC_WT0_WRITE_DONE
operator|)
condition|)
empty_stmt|;
block|}
name|wdog1
operator|=
name|REG_READ
argument_list|(
name|ADM5120_WDOG1
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|ADM5120_WDOG1
argument_list|,
name|wdog1
operator|&
operator|~
name|ADM5120_WDOG1_WDE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|admsw_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uint8_t
name|enaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|struct
name|admsw_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|admsw_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|rid
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ADM5120 Switch Engine, %d ports\n"
argument_list|,
name|SW_DEVS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ndevs
operator|=
literal|0
expr_stmt|;
comment|/* XXXMIPS: fix it */
name|enaddr
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|enaddr
index|[
literal|1
index|]
operator|=
literal|0x0C
expr_stmt|;
name|enaddr
index|[
literal|2
index|]
operator|=
literal|0x42
expr_stmt|;
name|enaddr
index|[
literal|3
index|]
operator|=
literal|0x07
expr_stmt|;
name|enaddr
index|[
literal|4
index|]
operator|=
literal|0xB2
expr_stmt|;
name|enaddr
index|[
literal|5
index|]
operator|=
literal|0x4E
expr_stmt|;
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"base Ethernet address %s\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|enaddr
argument_list|)
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate memory resource\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Hook up the interrupt handler. */
name|rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate IRQ resource\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|admsw_intr
argument_list|,
name|NULL
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"WARNING: unable to register interrupt handler\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Allocate the control data structures, and create and load the 	 * DMA map for it. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|admsw_control_data
argument_list|)
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|admsw_control_data
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_control_dmat
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to create control data DMA map, error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sc_control_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_control_data
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|sc_cddmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to allocate control data, error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_control_dmat
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|,
name|sc
operator|->
name|sc_control_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|admsw_control_data
argument_list|)
argument_list|,
name|admsw_dma_map_addr
argument_list|,
operator|&
name|sc
operator|->
name|sc_cddma
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to load control data DMA map, error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Create the transmit buffer DMA maps. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
literal|1
argument_list|,
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_bufs_dmat
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to create control data DMA map, error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ADMSW_NTXHDESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_bufs_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_txhsoft
index|[
name|i
index|]
operator|.
name|ds_dmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to create txh DMA map %d, error = %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|sc_txhsoft
index|[
name|i
index|]
operator|.
name|ds_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ADMSW_NTXLDESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_bufs_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_txlsoft
index|[
name|i
index|]
operator|.
name|ds_dmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to create txl DMA map %d, error = %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|sc_txlsoft
index|[
name|i
index|]
operator|.
name|ds_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Create the receive buffer DMA maps. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ADMSW_NRXHDESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_bufs_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxhsoft
index|[
name|i
index|]
operator|.
name|ds_dmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to create rxh DMA map %d, error = %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|sc_rxhsoft
index|[
name|i
index|]
operator|.
name|ds_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ADMSW_NRXLDESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_bufs_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxlsoft
index|[
name|i
index|]
operator|.
name|ds_dmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to create rxl DMA map %d, error = %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|sc_rxlsoft
index|[
name|i
index|]
operator|.
name|ds_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|admsw_init_bufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|admsw_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SW_DEVS
condition|;
name|i
operator|++
control|)
block|{
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifmedia
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|admsw_mediachange
argument_list|,
name|admsw_mediastatus
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifmedia
index|[
name|i
index|]
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifmedia
index|[
name|i
index|]
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifmedia
index|[
name|i
index|]
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifmedia
index|[
name|i
index|]
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifmedia
index|[
name|i
index|]
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifmedia
index|[
name|i
index|]
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifnet
index|[
name|i
index|]
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
comment|/* Setup interface parameters */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|admsw_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|admsw_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|admsw_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|admsw_init
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Mbps
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|max
argument_list|(
name|ADMSW_NTXLDESC
argument_list|,
name|IFQ_MAXLEN
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|max
argument_list|(
name|ADMSW_NTXLDESC
argument_list|,
name|IFQ_MAXLEN
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_MTU
expr_stmt|;
comment|/* Attach the interface. */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|enaddr
argument_list|)
expr_stmt|;
name|enaddr
index|[
literal|5
index|]
operator|++
expr_stmt|;
block|}
comment|/* XXX: admwdog_attach(sc); */
comment|/* leave interrupts and cpu port disabled */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|admsw_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|printf
argument_list|(
literal|"TODO: DETACH\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * admsw_shutdown:  *  *	Make sure the interface is stopped at reboot time.  */
end_comment

begin_function
specifier|static
name|int
name|admsw_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|admsw_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SW_DEVS
condition|;
name|i
operator|++
control|)
name|admsw_stop
argument_list|(
name|sc
operator|->
name|sc_ifnet
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * admsw_start:		[ifnet interface function]  *  *	Start packet transmission on the interface.  */
end_comment

begin_function
specifier|static
name|void
name|admsw_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|admsw_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|admsw_descsoft
modifier|*
name|ds
decl_stmt|;
name|struct
name|admsw_desc
modifier|*
name|desc
decl_stmt|;
name|bus_dmamap_t
name|dmamap
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nexttx
decl_stmt|,
name|len
decl_stmt|,
name|i
decl_stmt|;
specifier|static
name|int
name|vlan
init|=
literal|0
decl_stmt|;
comment|/* 	 * Loop through the send queues, setting up transmit descriptors 	 * unitl we drain the queues, or use up all available transmit 	 * descriptors. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|vlan
operator|++
expr_stmt|;
if|if
condition|(
name|vlan
operator|==
name|SW_DEVS
condition|)
name|vlan
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|vlan
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ifp
operator|=
name|sc
operator|->
name|sc_ifnet
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|==
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* Grab a packet off the queue. */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
break|break;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|SW_DEVS
condition|)
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|vlan
condition|)
return|return;
block|}
name|vlan
operator|=
name|i
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* Get a spare descriptor. */
if|if
condition|(
name|sc
operator|->
name|sc_txfree
operator|==
literal|0
condition|)
block|{
comment|/* No more slots left; notify upper layer. */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
name|nexttx
operator|=
name|sc
operator|->
name|sc_txnext
expr_stmt|;
name|desc
operator|=
operator|&
name|sc
operator|->
name|sc_txldescs
index|[
name|nexttx
index|]
expr_stmt|;
name|ds
operator|=
operator|&
name|sc
operator|->
name|sc_txlsoft
index|[
name|nexttx
index|]
expr_stmt|;
name|dmamap
operator|=
name|ds
operator|->
name|ds_dmamap
expr_stmt|;
comment|/* 		 * Load the DMA map.  If this fails, the packet either 		 * didn't fit in the alloted number of segments, or we 		 * were short on resources.  In this case, we'll copy 		 * and try again. 		 */
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|ETHER_MIN_LEN
operator|||
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_bufs_dmat
argument_list|,
name|dmamap
argument_list|,
name|m0
argument_list|,
name|admsw_mbuf_map_addr
argument_list|,
name|ds
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to allocate Tx mbuf\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to allocate Tx cluster\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
expr_stmt|;
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|ETHER_MIN_LEN
condition|)
block|{
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|<
name|ETHER_MIN_LEN
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
name|panic
argument_list|(
literal|"admsw_start: M_TRAILINGSPACE\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
literal|0
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|ETHER_MIN_LEN
expr_stmt|;
block|}
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_bufs_dmat
argument_list|,
name|dmamap
argument_list|,
name|m
argument_list|,
name|admsw_mbuf_map_addr
argument_list|,
name|ds
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to load Tx buffer, error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
block|}
comment|/* 		 * WE ARE NOW COMMITTED TO TRANSMITTING THE PACKET. 		 */
comment|/* Sync the DMA map. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_bufs_dmat
argument_list|,
name|dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_nsegs
operator|!=
literal|1
operator|&&
name|ds
operator|->
name|ds_nsegs
operator|!=
literal|2
condition|)
name|panic
argument_list|(
literal|"admsw_start: nsegs == %d\n"
argument_list|,
name|ds
operator|->
name|ds_nsegs
argument_list|)
expr_stmt|;
name|desc
operator|->
name|data
operator|=
name|ds
operator|->
name|ds_addr
index|[
literal|0
index|]
expr_stmt|;
name|desc
operator|->
name|len
operator|=
name|len
operator|=
name|ds
operator|->
name|ds_len
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_nsegs
operator|>
literal|1
condition|)
block|{
name|len
operator|+=
name|ds
operator|->
name|ds_len
index|[
literal|1
index|]
expr_stmt|;
name|desc
operator|->
name|cntl
operator|=
name|ds
operator|->
name|ds_addr
index|[
literal|1
index|]
operator||
name|ADM5120_DMA_BUF2ENABLE
expr_stmt|;
block|}
else|else
name|desc
operator|->
name|cntl
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|status
operator|=
operator|(
name|len
operator|<<
name|ADM5120_DMA_LENSHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|vlan
operator|)
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
operator|==
name|ETHERTYPE_IP
operator|&&
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
condition|)
name|desc
operator|->
name|status
operator||=
name|ADM5120_DMA_CSUM
expr_stmt|;
if|if
condition|(
name|nexttx
operator|==
name|ADMSW_NTXLDESC
operator|-
literal|1
condition|)
name|desc
operator|->
name|data
operator||=
name|ADM5120_DMA_RINGEND
expr_stmt|;
name|desc
operator|->
name|data
operator||=
name|ADM5120_DMA_OWN
expr_stmt|;
comment|/* Sync the descriptor. */
name|ADMSW_CDTXLSYNC
argument_list|(
name|sc
argument_list|,
name|nexttx
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|SEND_TRIG_REG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* printf("send slot %d\n",nexttx); */
comment|/* 		 * Store a pointer to the packet so we can free it later. 		 */
name|ds
operator|->
name|ds_mbuf
operator|=
name|m0
expr_stmt|;
comment|/* Advance the Tx pointer. */
name|sc
operator|->
name|sc_txfree
operator|--
expr_stmt|;
name|sc
operator|->
name|sc_txnext
operator|=
name|ADMSW_NEXTTXL
argument_list|(
name|nexttx
argument_list|)
expr_stmt|;
comment|/* Pass the packet to any BPF listeners. */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
comment|/* Set a watchdog timer in case the chip flakes out. */
name|sc
operator|->
name|sc_ifnet
index|[
literal|0
index|]
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * admsw_watchdog:	[ifnet interface function]  *  *	Watchdog timer handler.  */
end_comment

begin_function
specifier|static
name|void
name|admsw_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|admsw_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|vlan
decl_stmt|;
comment|/* Check if an interrupt was lost. */
if|if
condition|(
name|sc
operator|->
name|sc_txfree
operator|==
name|ADMSW_NTXLDESC
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"watchdog false alarm\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ifnet
index|[
literal|0
index|]
operator|->
name|if_timer
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"watchdog timer is %d!\n"
argument_list|,
name|sc
operator|->
name|sc_ifnet
index|[
literal|0
index|]
operator|->
name|if_timer
argument_list|)
expr_stmt|;
name|admsw_txintr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_txfree
operator|==
name|ADMSW_NTXLDESC
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"tx IRQ lost (queue empty)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ifnet
index|[
literal|0
index|]
operator|->
name|if_timer
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"tx IRQ lost (timer recharged)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device timeout, txfree = %d\n"
argument_list|,
name|sc
operator|->
name|sc_txfree
argument_list|)
expr_stmt|;
for|for
control|(
name|vlan
operator|=
literal|0
init|;
name|vlan
operator|<
name|SW_DEVS
condition|;
name|vlan
operator|++
control|)
name|admsw_stop
argument_list|(
name|sc
operator|->
name|sc_ifnet
index|[
name|vlan
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|admsw_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Try to get more packets going. */
name|admsw_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * admsw_ioctl:		[ifnet interface function]  *  *	Handle control requests from the operator.  */
end_comment

begin_function
specifier|static
name|int
name|admsw_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|admsw_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifdrv
modifier|*
name|ifd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|port
decl_stmt|;
name|ADMSW_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|port
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|port
operator|<
name|SW_DEVS
condition|)
if|if
condition|(
name|ifp
operator|==
name|sc
operator|->
name|sc_ifnet
index|[
name|port
index|]
condition|)
break|break;
else|else
name|port
operator|++
expr_stmt|;
if|if
condition|(
name|port
operator|>=
name|SW_DEVS
condition|)
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
else|else
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|sc
operator|->
name|sc_ifmedia
index|[
name|port
index|]
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGDRVSPEC
case|:
case|case
name|SIOCSDRVSPEC
case|:
name|ifd
operator|=
operator|(
expr|struct
name|ifdrv
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|ifd
operator|->
name|ifd_cmd
operator|!=
literal|0
operator|||
name|ifd
operator|->
name|ifd_len
operator|!=
sizeof|sizeof
argument_list|(
name|vlan_matrix
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmd
operator|==
name|SIOCGDRVSPEC
condition|)
block|{
name|error
operator|=
name|copyout
argument_list|(
name|vlan_matrix
argument_list|,
name|ifd
operator|->
name|ifd_data
argument_list|,
sizeof|sizeof
argument_list|(
name|vlan_matrix
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|copyin
argument_list|(
name|ifd
operator|->
name|ifd_data
argument_list|,
name|vlan_matrix
argument_list|,
sizeof|sizeof
argument_list|(
name|vlan_matrix
argument_list|)
argument_list|)
expr_stmt|;
name|admsw_setvlan
argument_list|(
name|sc
argument_list|,
name|vlan_matrix
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
comment|/* 			 * Multicast list has changed; set the hardware filter 			 * accordingly. 			 */
name|admsw_set_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
comment|/* Try to get more packets going. */
name|admsw_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ADMSW_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * admsw_intr:  *  *	Interrupt service routine.  */
end_comment

begin_function
specifier|static
name|int
name|admsw_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|admsw_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|pending
decl_stmt|;
name|pending
operator|=
name|REG_READ
argument_list|(
name|ADMSW_INT_ST
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|ADMSW_INT_ST
argument_list|,
name|pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndevs
operator|==
literal|0
condition|)
return|return
operator|(
name|FILTER_STRAY
operator|)
return|;
if|if
condition|(
operator|(
name|pending
operator|&
name|ADMSW_INTR_RHD
operator|)
operator|!=
literal|0
condition|)
name|admsw_rxintr
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pending
operator|&
name|ADMSW_INTR_RLD
operator|)
operator|!=
literal|0
condition|)
name|admsw_rxintr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pending
operator|&
name|ADMSW_INTR_SHD
operator|)
operator|!=
literal|0
condition|)
name|admsw_txintr
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pending
operator|&
name|ADMSW_INTR_SLD
operator|)
operator|!=
literal|0
condition|)
name|admsw_txintr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * admsw_txintr:  *  *	Helper; handle transmit interrupts.  */
end_comment

begin_function
specifier|static
name|void
name|admsw_txintr
parameter_list|(
name|struct
name|admsw_softc
modifier|*
name|sc
parameter_list|,
name|int
name|prio
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|admsw_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|admsw_descsoft
modifier|*
name|ds
decl_stmt|;
name|int
name|i
decl_stmt|,
name|vlan
decl_stmt|;
name|int
name|gotone
init|=
literal|0
decl_stmt|;
comment|/* printf("txintr: txdirty: %d, txfree: %d\n",sc->sc_txdirty, sc->sc_txfree); */
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|sc_txdirty
init|;
name|sc
operator|->
name|sc_txfree
operator|!=
name|ADMSW_NTXLDESC
condition|;
name|i
operator|=
name|ADMSW_NEXTTXL
argument_list|(
name|i
argument_list|)
control|)
block|{
name|ADMSW_CDTXLSYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|&
name|sc
operator|->
name|sc_txldescs
index|[
name|i
index|]
expr_stmt|;
name|ds
operator|=
operator|&
name|sc
operator|->
name|sc_txlsoft
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|data
operator|&
name|ADM5120_DMA_OWN
condition|)
block|{
name|ADMSW_CDTXLSYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
break|break;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_bufs_dmat
argument_list|,
name|ds
operator|->
name|ds_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_bufs_dmat
argument_list|,
name|ds
operator|->
name|ds_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|ds
operator|->
name|ds_mbuf
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_mbuf
operator|=
name|NULL
expr_stmt|;
name|vlan
operator|=
name|ffs
argument_list|(
name|desc
operator|->
name|status
operator|&
literal|0x3f
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|vlan
operator|<
literal|0
operator|||
name|vlan
operator|>=
name|SW_DEVS
condition|)
name|panic
argument_list|(
literal|"admsw_txintr: bad vlan\n"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifnet
index|[
name|vlan
index|]
expr_stmt|;
name|gotone
operator|=
literal|1
expr_stmt|;
comment|/* printf("clear tx slot %d\n",i); */
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_txfree
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|gotone
condition|)
block|{
name|sc
operator|->
name|sc_txdirty
operator|=
name|i
expr_stmt|;
for|for
control|(
name|vlan
operator|=
literal|0
init|;
name|vlan
operator|<
name|SW_DEVS
condition|;
name|vlan
operator|++
control|)
name|sc
operator|->
name|sc_ifnet
index|[
name|vlan
index|]
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifnet
index|[
literal|0
index|]
expr_stmt|;
comment|/* Try to queue more packets. */
name|admsw_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 		 * If there are no more pending transmissions, 		 * cancel the watchdog timer. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_txfree
operator|==
name|ADMSW_NTXLDESC
condition|)
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
block|}
comment|/* printf("txintr end: txdirty: %d, txfree: %d\n",sc->sc_txdirty, sc->sc_txfree); */
block|}
end_function

begin_comment
comment|/*  * admsw_rxintr:  *  *	Helper; handle receive interrupts.  */
end_comment

begin_function
specifier|static
name|void
name|admsw_rxintr
parameter_list|(
name|struct
name|admsw_softc
modifier|*
name|sc
parameter_list|,
name|int
name|high
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|admsw_descsoft
modifier|*
name|ds
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|stat
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|port
decl_stmt|,
name|vlan
decl_stmt|;
comment|/* printf("rxintr\n"); */
if|if
condition|(
name|high
condition|)
name|panic
argument_list|(
literal|"admsw_rxintr: high priority packet\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|ADMSW_CDRXLSYNC
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxptr
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_rxldescs
index|[
name|sc
operator|->
name|sc_rxptr
index|]
operator|.
name|data
operator|&
name|ADM5120_DMA_OWN
operator|)
operator|==
literal|0
condition|)
name|ADMSW_CDRXLSYNC
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxptr
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
else|else
block|{
name|i
operator|=
name|sc
operator|->
name|sc_rxptr
expr_stmt|;
do|do
block|{
name|ADMSW_CDRXLSYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|i
operator|=
name|ADMSW_NEXTRXL
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* the ring is empty, just return. */
if|if
condition|(
name|i
operator|==
name|sc
operator|->
name|sc_rxptr
condition|)
return|return;
name|ADMSW_CDRXLSYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sc
operator|->
name|sc_rxldescs
index|[
name|i
index|]
operator|.
name|data
operator|&
name|ADM5120_DMA_OWN
condition|)
do|;
name|ADMSW_CDRXLSYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|ADMSW_CDRXLSYNC
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxptr
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_rxldescs
index|[
name|sc
operator|->
name|sc_rxptr
index|]
operator|.
name|data
operator|&
name|ADM5120_DMA_OWN
operator|)
operator|==
literal|0
condition|)
name|ADMSW_CDRXLSYNC
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxptr
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
else|else
block|{
name|ADMSW_CDRXLSYNC
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxptr
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* We've fallen behind the chip: catch it. */
if|#
directive|if
literal|0
block|device_printf(sc->sc_dev,  			   "RX ring resync, base=%x, work=%x, %d -> %d\n", 			    REG_READ(RECV_LBADDR_REG), 			    REG_READ(RECV_LWADDR_REG), sc->sc_rxptr, i);
endif|#
directive|endif
name|sc
operator|->
name|sc_rxptr
operator|=
name|i
expr_stmt|;
comment|/* ADMSW_EVCNT_INCR(&sc->sc_ev_rxsync); */
block|}
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|sc_rxptr
init|;
condition|;
name|i
operator|=
name|ADMSW_NEXTRXL
argument_list|(
name|i
argument_list|)
control|)
block|{
name|ds
operator|=
operator|&
name|sc
operator|->
name|sc_rxlsoft
index|[
name|i
index|]
expr_stmt|;
name|ADMSW_CDRXLSYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rxldescs
index|[
name|i
index|]
operator|.
name|data
operator|&
name|ADM5120_DMA_OWN
condition|)
block|{
name|ADMSW_CDRXLSYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* printf("process slot %d\n",i); */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_bufs_dmat
argument_list|,
name|ds
operator|->
name|ds_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|stat
operator|=
name|sc
operator|->
name|sc_rxldescs
index|[
name|i
index|]
operator|.
name|status
expr_stmt|;
name|len
operator|=
operator|(
name|stat
operator|&
name|ADM5120_DMA_LEN
operator|)
operator|>>
name|ADM5120_DMA_LENSHIFT
expr_stmt|;
name|len
operator|-=
name|ETHER_CRC_LEN
expr_stmt|;
name|port
operator|=
operator|(
name|stat
operator|&
name|ADM5120_DMA_PORTID
operator|)
operator|>>
name|ADM5120_DMA_PORTSHIFT
expr_stmt|;
for|for
control|(
name|vlan
operator|=
literal|0
init|;
name|vlan
operator|<
name|SW_DEVS
condition|;
name|vlan
operator|++
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|port
operator|)
operator|&
name|vlan_matrix
index|[
name|vlan
index|]
condition|)
break|break;
if|if
condition|(
name|vlan
operator|==
name|SW_DEVS
condition|)
name|vlan
operator|=
literal|0
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifnet
index|[
name|vlan
index|]
expr_stmt|;
name|m
operator|=
name|ds
operator|->
name|ds_mbuf
expr_stmt|;
if|if
condition|(
name|admsw_add_rxlbuf
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|ADMSW_INIT_RXLDESC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_bufs_dmat
argument_list|,
name|ds
operator|->
name|ds_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|ADM5120_DMA_TYPE
operator|)
operator|==
name|ADM5120_DMA_TYPE_IP
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_CHECKED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|ADM5120_DMA_CSUMFAIL
operator|)
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Pass it on. */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
block|}
comment|/* Update the receive pointer. */
name|sc
operator|->
name|sc_rxptr
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * admsw_init:		[ifnet interface function]  *  *	Initialize the interface.  */
end_comment

begin_function
specifier|static
name|void
name|admsw_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|admsw_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SW_DEVS
condition|;
name|i
operator|++
control|)
block|{
name|ifp
operator|=
name|sc
operator|->
name|sc_ifnet
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ndevs
operator|==
literal|0
condition|)
block|{
name|admsw_init_bufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|admsw_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|CPUP_CONF_REG
argument_list|,
name|CPUP_CONF_CRCP
operator||
name|CPUP_CONF_DUNP_MASK
operator||
name|CPUP_CONF_DMCP_MASK
argument_list|)
expr_stmt|;
comment|/* clear all pending interrupts */
name|REG_WRITE
argument_list|(
name|ADMSW_INT_ST
argument_list|,
name|INT_MASK
argument_list|)
expr_stmt|;
comment|/* enable needed interrupts */
name|REG_WRITE
argument_list|(
name|ADMSW_INT_MASK
argument_list|,
name|REG_READ
argument_list|(
name|ADMSW_INT_MASK
argument_list|)
operator|&
operator|~
operator|(
name|ADMSW_INTR_SHD
operator||
name|ADMSW_INTR_SLD
operator||
name|ADMSW_INTR_RHD
operator||
name|ADMSW_INTR_RLD
operator||
name|ADMSW_INTR_HDF
operator||
name|ADMSW_INTR_LDF
operator|)
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|ndevs
operator|++
expr_stmt|;
block|}
comment|/* mark iface as running */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
comment|/* Set the receive filter. */
name|admsw_set_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * admsw_stop:		[ifnet interface function]  *  *	Stop transmission on the interface.  */
end_comment

begin_function
specifier|static
name|void
name|admsw_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|disable
parameter_list|)
block|{
name|struct
name|admsw_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
if|if
condition|(
operator|--
name|sc
operator|->
name|ndevs
operator|==
literal|0
condition|)
block|{
comment|/* printf("debug: de-initializing hardware\n"); */
comment|/* disable cpu port */
name|REG_WRITE
argument_list|(
name|CPUP_CONF_REG
argument_list|,
name|CPUP_CONF_DCPUP
operator||
name|CPUP_CONF_CRCP
operator||
name|CPUP_CONF_DUNP_MASK
operator||
name|CPUP_CONF_DMCP_MASK
argument_list|)
expr_stmt|;
comment|/* XXX We should disable, then clear? --dyoung */
comment|/* clear all pending interrupts */
name|REG_WRITE
argument_list|(
name|ADMSW_INT_ST
argument_list|,
name|INT_MASK
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|REG_WRITE
argument_list|(
name|ADMSW_INT_MASK
argument_list|,
name|INT_MASK
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the interface as down and cancel the watchdog timer. */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * admsw_set_filter:  *  *	Set up the receive filter.  */
end_comment

begin_function
specifier|static
name|void
name|admsw_set_filter
parameter_list|(
name|struct
name|admsw_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|allmc
decl_stmt|,
name|anymc
decl_stmt|,
name|conf
decl_stmt|,
name|promisc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
comment|/* Find which ports should be operated in promisc mode. */
name|allmc
operator|=
name|anymc
operator|=
name|promisc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SW_DEVS
condition|;
name|i
operator|++
control|)
block|{
name|ifp
operator|=
name|sc
operator|->
name|sc_ifnet
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|promisc
operator||=
name|vlan_matrix
index|[
name|i
index|]
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_ALLMULTI
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|anymc
operator||=
name|vlan_matrix
index|[
name|i
index|]
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|conf
operator|=
name|REG_READ
argument_list|(
name|CPUP_CONF_REG
argument_list|)
expr_stmt|;
comment|/* 1 Disable forwarding of unknown& multicast packets to 	 *   CPU on all ports. 	 * 2 Enable forwarding of unknown& multicast packets to 	 *   CPU on ports where IFF_PROMISC or IFF_ALLMULTI is set. 	 */
name|conf
operator||=
name|CPUP_CONF_DUNP_MASK
operator||
name|CPUP_CONF_DMCP_MASK
expr_stmt|;
comment|/* Enable forwarding of unknown packets to CPU on selected ports. */
name|conf
operator|^=
operator|(
operator|(
name|promisc
operator|<<
name|CPUP_CONF_DUNP_SHIFT
operator|)
operator|&
name|CPUP_CONF_DUNP_MASK
operator|)
expr_stmt|;
name|conf
operator|^=
operator|(
operator|(
name|allmc
operator|<<
name|CPUP_CONF_DMCP_SHIFT
operator|)
operator|&
name|CPUP_CONF_DMCP_MASK
operator|)
expr_stmt|;
name|conf
operator|^=
operator|(
operator|(
name|anymc
operator|<<
name|CPUP_CONF_DMCP_SHIFT
operator|)
operator|&
name|CPUP_CONF_DMCP_MASK
operator|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|CPUP_CONF_REG
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * admsw_add_rxbuf:  *  *	Add a receive buffer to the indicated descriptor.  */
end_comment

begin_function
name|int
name|admsw_add_rxbuf
parameter_list|(
name|struct
name|admsw_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|high
parameter_list|)
block|{
name|struct
name|admsw_descsoft
modifier|*
name|ds
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|high
condition|)
name|ds
operator|=
operator|&
name|sc
operator|->
name|sc_rxhsoft
index|[
name|idx
index|]
expr_stmt|;
else|else
name|ds
operator|=
operator|&
name|sc
operator|->
name|sc_rxlsoft
index|[
name|idx
index|]
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
if|if
condition|(
name|ds
operator|->
name|ds_mbuf
operator|!=
name|NULL
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_bufs_dmat
argument_list|,
name|ds
operator|->
name|ds_dmamap
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_mbuf
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_bufs_dmat
argument_list|,
name|ds
operator|->
name|ds_dmamap
argument_list|,
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|,
name|m
operator|->
name|m_ext
operator|.
name|ext_size
argument_list|,
name|admsw_rxbuf_map_addr
argument_list|,
name|ds
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't load rx DMA map %d, error = %d\n"
argument_list|,
name|idx
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"admsw_add_rxbuf"
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_bufs_dmat
argument_list|,
name|ds
operator|->
name|ds_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|high
condition|)
name|ADMSW_INIT_RXHDESC
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
expr_stmt|;
else|else
name|ADMSW_INIT_RXLDESC
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|admsw_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|admsw_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|port
init|=
literal|0
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|int
name|old
decl_stmt|,
name|new
decl_stmt|,
name|val
decl_stmt|;
while|while
condition|(
name|port
operator|<
name|SW_DEVS
condition|)
block|{
if|if
condition|(
name|ifp
operator|==
name|sc
operator|->
name|sc_ifnet
index|[
name|port
index|]
condition|)
break|break;
else|else
name|port
operator|++
expr_stmt|;
block|}
name|ifm
operator|=
operator|&
name|sc
operator|->
name|sc_ifmedia
index|[
name|port
index|]
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|==
name|IFM_AUTO
condition|)
block|{
name|val
operator|=
name|PHY_CNTL2_AUTONEG
operator||
name|PHY_CNTL2_100M
operator||
name|PHY_CNTL2_FDX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|==
name|IFM_100_TX
condition|)
block|{
if|if
condition|(
operator|(
name|ifm
operator|->
name|ifm_media
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_FDX
condition|)
name|val
operator|=
name|PHY_CNTL2_100M
operator||
name|PHY_CNTL2_FDX
expr_stmt|;
else|else
name|val
operator|=
name|PHY_CNTL2_100M
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|==
name|IFM_10_T
condition|)
block|{
if|if
condition|(
operator|(
name|ifm
operator|->
name|ifm_media
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_FDX
condition|)
name|val
operator|=
name|PHY_CNTL2_FDX
expr_stmt|;
else|else
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
name|old
operator|=
name|REG_READ
argument_list|(
name|PHY_CNTL2_REG
argument_list|)
expr_stmt|;
name|new
operator|=
name|old
operator|&
operator|~
operator|(
operator|(
name|PHY_CNTL2_AUTONEG
operator||
name|PHY_CNTL2_100M
operator||
name|PHY_CNTL2_FDX
operator|)
operator|<<
name|port
operator|)
expr_stmt|;
name|new
operator||=
operator|(
name|val
operator|<<
name|port
operator|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|old
condition|)
name|REG_WRITE
argument_list|(
name|PHY_CNTL2_REG
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|admsw_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|admsw_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|port
init|=
literal|0
decl_stmt|;
name|int
name|status
decl_stmt|;
while|while
condition|(
name|port
operator|<
name|SW_DEVS
condition|)
block|{
if|if
condition|(
name|ifp
operator|==
name|sc
operator|->
name|sc_ifnet
index|[
name|port
index|]
condition|)
break|break;
else|else
name|port
operator|++
expr_stmt|;
block|}
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
name|status
operator|=
name|REG_READ
argument_list|(
name|PHY_ST_REG
argument_list|)
operator|>>
name|port
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|PHY_ST_LINKUP
operator|)
operator|==
literal|0
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_NONE
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
operator|(
name|status
operator|&
name|PHY_ST_100M
operator|)
condition|?
name|IFM_100_TX
else|:
name|IFM_10_T
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|PHY_ST_FDX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|admsw_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|admsw_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|admsw_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|admsw_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|admsw_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|admsw_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|admsw_driver
init|=
block|{
literal|"admsw"
block|,
name|admsw_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|admsw_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|admsw
argument_list|,
name|obio
argument_list|,
name|admsw_driver
argument_list|,
name|admsw_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|admsw
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

