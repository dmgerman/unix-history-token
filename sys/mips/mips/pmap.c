begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  * Copyright (c) 1994 John S. Dyson  * All rights reserved.  * Copyright (c) 1994 David Greenman  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and William Jolitz of UUNET Technologies Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from:	@(#)pmap.c	7.7 (Berkeley)	5/12/91  *	from: src/sys/i386/i386/pmap.c,v 1.250.2.8 2000/11/21 00:09:14 ps  *	JNPR: pmap.c,v 1.11.2.1 2007/08/16 11:51:06 girish  */
end_comment

begin_comment
comment|/*  *	Manages physical address maps.  *  *	In addition to hardware address maps, this  *	module is called upon to provide software-use-only  *	maps which may or may not be stored in the same  *	form as hardware maps.	These pseudo-maps are  *	used to store intermediate results from copy  *	operations to and from address spaces.  *  *	Since the information managed by this module is  *	also stored by the logical address mapping module,  *	this module may throw away valid virtual-to-physical  *	mappings at almost any time.  However, invalidations  *	of virtual-to-physical mappings must be done as  *	requested.  *  *	In order to cope with hardware architectures which  *	make virtual-to-physical map invalidates expensive,  *	this module may delay invalidate or reduced protection  *	operations until such time as they are actually  *	necessary.  This module is given full information as  *	to which processors are currently using which maps,  *	and to when physical maps must be made correct.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_pmap.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/cache.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/tlb.h>
end_include

begin_undef
undef|#
directive|undef
name|PMAP_DEBUG
end_undef

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
end_if

begin_define
define|#
directive|define
name|PMAP_INLINE
value|__inline
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PMAP_INLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PV_STATS
end_ifdef

begin_define
define|#
directive|define
name|PV_STAT
parameter_list|(
name|x
parameter_list|)
value|do { x ; } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PV_STAT
parameter_list|(
name|x
parameter_list|)
value|do { } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get PDEs and PTEs for user/kernel address space  */
end_comment

begin_define
define|#
directive|define
name|pmap_seg_index
parameter_list|(
name|v
parameter_list|)
value|(((v)>> SEGSHIFT)& (NPDEPG - 1))
end_define

begin_define
define|#
directive|define
name|pmap_pde_index
parameter_list|(
name|v
parameter_list|)
value|(((v)>> PDRSHIFT)& (NPDEPG - 1))
end_define

begin_define
define|#
directive|define
name|pmap_pte_index
parameter_list|(
name|v
parameter_list|)
value|(((v)>> PAGE_SHIFT)& (NPTEPG - 1))
end_define

begin_define
define|#
directive|define
name|pmap_pde_pindex
parameter_list|(
name|v
parameter_list|)
value|((v)>> PDRSHIFT)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__mips_n64
end_ifdef

begin_define
define|#
directive|define
name|NUPDE
value|(NPDEPG * NPDEPG)
end_define

begin_define
define|#
directive|define
name|NUSERPGTBLS
value|(NUPDE + NPDEPG)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NUPDE
value|(NPDEPG)
end_define

begin_define
define|#
directive|define
name|NUSERPGTBLS
value|(NUPDE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|is_kernel_pmap
parameter_list|(
name|x
parameter_list|)
value|((x) == kernel_pmap)
end_define

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pd_entry_t
modifier|*
name|kernel_segmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of first avail page (after kernel bss) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of last avail page (end of kernel AS) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nkpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pmap_max_asid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max ASID supported by the system */
end_comment

begin_define
define|#
directive|define
name|PMAP_ASID_RESERVED
value|0
end_define

begin_decl_stmt
name|vm_offset_t
name|kernel_vm_end
init|=
name|VM_MIN_KERNEL_ADDRESS
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|pmap_asid_alloc
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Isolate the global pv list lock from data and other locks to prevent false  * sharing within the cache.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|rwlock
name|lock
decl_stmt|;
name|char
name|padding
index|[
name|CACHE_LINE_SIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rwlock
argument_list|)
index|]
decl_stmt|;
block|}
name|pvh_global
name|__aligned
argument_list|(
name|CACHE_LINE_SIZE
argument_list|)
struct|;
end_struct

begin_define
define|#
directive|define
name|pvh_global_lock
value|pvh_global.lock
end_define

begin_comment
comment|/*  * Data for the pv entry allocation mechanism  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|pch
argument_list|,
argument|pv_chunk
argument_list|)
name|pv_chunks
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|pv_chunks
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pv_entry_count
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|free_pv_chunk
parameter_list|(
name|struct
name|pv_chunk
modifier|*
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pv_entry_t
name|pv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pv_entry_t
name|get_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|boolean_t
name|try
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|pmap_pv_reclaim
parameter_list|(
name|pmap_t
name|locked_pmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_pvh_free
parameter_list|(
name|struct
name|md_page
modifier|*
name|pvh
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pv_entry_t
name|pmap_pvh_remove
parameter_list|(
name|struct
name|md_page
modifier|*
name|pvh
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|pmap_changebit
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|bit
parameter_list|,
name|boolean_t
name|setem
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|pmap_enter_quick_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_remove_pte
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|,
name|pt_entry_t
modifier|*
name|ptq
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
name|pde
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_remove_page
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_remove_entry
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|pmap_try_insert_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_update_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pt_entry_t
name|pte
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_invalidate_all
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_invalidate_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_pmap_unwire_pte_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|pmap_allocpte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|_pmap_allocpte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|unsigned
name|ptepindex
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_unuse_pt
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|pd_entry_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pt_entry_t
name|init_pte_prot
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function_decl
specifier|static
name|void
name|pmap_invalidate_page_action
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_update_page_action
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__mips_n64
end_ifndef

begin_comment
comment|/*  * This structure is for high memory (memory above 512Meg in 32 bit) support.  * The highmem area does not have a KSEG0 mapping, and we need a mechanism to  * do temporary per-CPU mappings for pmap_zero_page, pmap_copy_page etc.  *  * At bootup, we reserve 2 virtual pages per CPU for mapping highmem pages. To   * access a highmem physical address on a CPU, we map the physical address to  * the reserved virtual address for the CPU in the kernel pagetable.  This is   * done with interrupts disabled(although a spinlock and sched_pin would be   * sufficient).  */
end_comment

begin_struct
struct|struct
name|local_sysmaps
block|{
name|vm_offset_t
name|base
decl_stmt|;
name|uint32_t
name|saved_intr
decl_stmt|;
name|uint16_t
name|valid1
decl_stmt|,
name|valid2
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|local_sysmaps
name|sysmap_lmem
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
name|void
name|pmap_alloc_lmem_map
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|sysmap_lmem
index|[
name|i
index|]
operator|.
name|base
operator|=
name|virtual_avail
expr_stmt|;
name|virtual_avail
operator|+=
name|PAGE_SIZE
operator|*
literal|2
expr_stmt|;
name|sysmap_lmem
index|[
name|i
index|]
operator|.
name|valid1
operator|=
name|sysmap_lmem
index|[
name|i
index|]
operator|.
name|valid2
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|vm_offset_t
name|pmap_lmem_map1
parameter_list|(
name|vm_paddr_t
name|phys
parameter_list|)
block|{
name|struct
name|local_sysmaps
modifier|*
name|sysm
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|npte
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|uint32_t
name|intr
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|intr
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|sysm
operator|=
operator|&
name|sysmap_lmem
index|[
name|cpu
index|]
expr_stmt|;
name|sysm
operator|->
name|saved_intr
operator|=
name|intr
expr_stmt|;
name|va
operator|=
name|sysm
operator|->
name|base
expr_stmt|;
name|npte
operator|=
name|TLBLO_PA_TO_PFN
argument_list|(
name|phys
argument_list|)
operator||
name|PTE_D
operator||
name|PTE_V
operator||
name|PTE_G
operator||
name|PTE_W
operator||
name|PTE_C_CACHE
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
name|npte
expr_stmt|;
name|sysm
operator|->
name|valid1
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|va
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|vm_offset_t
name|pmap_lmem_map2
parameter_list|(
name|vm_paddr_t
name|phys1
parameter_list|,
name|vm_paddr_t
name|phys2
parameter_list|)
block|{
name|struct
name|local_sysmaps
modifier|*
name|sysm
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|npte
decl_stmt|;
name|vm_offset_t
name|va1
decl_stmt|,
name|va2
decl_stmt|;
name|uint32_t
name|intr
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|intr
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|sysm
operator|=
operator|&
name|sysmap_lmem
index|[
name|cpu
index|]
expr_stmt|;
name|sysm
operator|->
name|saved_intr
operator|=
name|intr
expr_stmt|;
name|va1
operator|=
name|sysm
operator|->
name|base
expr_stmt|;
name|va2
operator|=
name|sysm
operator|->
name|base
operator|+
name|PAGE_SIZE
expr_stmt|;
name|npte
operator|=
name|TLBLO_PA_TO_PFN
argument_list|(
name|phys1
argument_list|)
operator||
name|PTE_D
operator||
name|PTE_V
operator||
name|PTE_G
operator||
name|PTE_W
operator||
name|PTE_C_CACHE
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va1
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
name|npte
expr_stmt|;
name|npte
operator|=
name|TLBLO_PA_TO_PFN
argument_list|(
name|phys2
argument_list|)
operator||
name|PTE_D
operator||
name|PTE_V
operator||
name|PTE_G
operator||
name|PTE_W
operator||
name|PTE_C_CACHE
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va2
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
name|npte
expr_stmt|;
name|sysm
operator|->
name|valid1
operator|=
literal|1
expr_stmt|;
name|sysm
operator|->
name|valid2
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|va1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pmap_lmem_unmap
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|local_sysmaps
modifier|*
name|sysm
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|sysm
operator|=
operator|&
name|sysmap_lmem
index|[
name|cpu
index|]
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|sysm
operator|->
name|base
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
name|PTE_G
expr_stmt|;
name|tlb_invalidate_address
argument_list|(
name|kernel_pmap
argument_list|,
name|sysm
operator|->
name|base
argument_list|)
expr_stmt|;
name|sysm
operator|->
name|valid1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sysm
operator|->
name|valid2
condition|)
block|{
name|pte
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|sysm
operator|->
name|base
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
name|PTE_G
expr_stmt|;
name|tlb_invalidate_address
argument_list|(
name|kernel_pmap
argument_list|,
name|sysm
operator|->
name|base
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|sysm
operator|->
name|valid2
operator|=
literal|0
expr_stmt|;
block|}
name|intr_restore
argument_list|(
name|sysm
operator|->
name|saved_intr
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __mips_n64 */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pmap_alloc_lmem_map
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|__inline
name|vm_offset_t
name|pmap_lmem_map1
parameter_list|(
name|vm_paddr_t
name|phys
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|vm_offset_t
name|pmap_lmem_map2
parameter_list|(
name|vm_paddr_t
name|phys1
parameter_list|,
name|vm_paddr_t
name|phys2
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|vm_offset_t
name|pmap_lmem_unmap
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__mips_n64 */
end_comment

begin_comment
comment|/*  * Page table entry lookup routines.  */
end_comment

begin_function
specifier|static
name|__inline
name|pd_entry_t
modifier|*
name|pmap_segmap
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
operator|&
name|pmap
operator|->
name|pm_segtab
index|[
name|pmap_seg_index
argument_list|(
name|va
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__mips_n64
end_ifdef

begin_function
specifier|static
name|__inline
name|pd_entry_t
modifier|*
name|pmap_pdpe_to_pde
parameter_list|(
name|pd_entry_t
modifier|*
name|pdpe
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pde
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
operator|*
name|pdpe
expr_stmt|;
return|return
operator|(
operator|&
name|pde
index|[
name|pmap_pde_index
argument_list|(
name|va
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pd_entry_t
modifier|*
name|pmap_pde
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pdpe
decl_stmt|;
name|pdpe
operator|=
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdpe
operator|==
name|NULL
operator|||
operator|*
name|pdpe
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|pmap_pdpe_to_pde
argument_list|(
name|pdpe
argument_list|,
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|__inline
name|pd_entry_t
modifier|*
name|pmap_pdpe_to_pde
parameter_list|(
name|pd_entry_t
modifier|*
name|pdpe
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|pdpe
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pd_entry_t
modifier|*
name|pmap_pde
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__inline
name|pt_entry_t
modifier|*
name|pmap_pde_to_pte
parameter_list|(
name|pd_entry_t
modifier|*
name|pde
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pte
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
operator|*
name|pde
expr_stmt|;
return|return
operator|(
operator|&
name|pte
index|[
name|pmap_pte_index
argument_list|(
name|va
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_function
name|pt_entry_t
modifier|*
name|pmap_pte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde
operator|==
name|NULL
operator|||
operator|*
name|pde
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|pmap_pde_to_pte
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_steal_memory
parameter_list|(
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_paddr_t
name|bank_size
decl_stmt|,
name|pa
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bank_size
operator|=
name|phys_avail
index|[
literal|1
index|]
operator|-
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|size
operator|>
name|bank_size
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|phys_avail
index|[
name|i
index|]
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
block|}
name|phys_avail
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|phys_avail
index|[
literal|0
index|]
condition|)
name|panic
argument_list|(
literal|"pmap_steal_memory: out of memory"
argument_list|)
expr_stmt|;
name|bank_size
operator|=
name|phys_avail
index|[
literal|1
index|]
operator|-
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
block|}
name|pa
operator|=
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
name|phys_avail
index|[
literal|0
index|]
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|MIPS_DIRECT_MAPPABLE
argument_list|(
name|pa
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"Out of memory below 512Meg?"
argument_list|)
expr_stmt|;
name|va
operator|=
name|MIPS_PHYS_TO_DIRECT
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|va
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bootstrap the system enough to run with virtual memory.  This  * assumes that the phys_avail array has been initialized.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_create_kernel_pagetable
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|vm_offset_t
name|ptaddr
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
ifdef|#
directive|ifdef
name|__mips_n64
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|vm_offset_t
name|pdaddr
decl_stmt|;
name|int
name|npt
decl_stmt|,
name|npde
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate segment table for the kernel 	 */
name|kernel_segmap
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|pmap_steal_memory
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate second level page tables for the kernel 	 */
ifdef|#
directive|ifdef
name|__mips_n64
name|npde
operator|=
name|howmany
argument_list|(
name|NKPT
argument_list|,
name|NPDEPG
argument_list|)
expr_stmt|;
name|pdaddr
operator|=
name|pmap_steal_memory
argument_list|(
name|PAGE_SIZE
operator|*
name|npde
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nkpt
operator|=
name|NKPT
expr_stmt|;
name|ptaddr
operator|=
name|pmap_steal_memory
argument_list|(
name|PAGE_SIZE
operator|*
name|nkpt
argument_list|)
expr_stmt|;
comment|/* 	 * The R[4-7]?00 stores only one copy of the Global bit in the 	 * translation lookaside buffer for each 2 page entry. Thus invalid 	 * entrys must have the Global bit set so when Entry LO and Entry HI 	 * G bits are anded together they will produce a global bit to store 	 * in the tlb. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pte
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|ptaddr
init|;
name|i
operator|<
operator|(
name|nkpt
operator|*
name|NPTEPG
operator|)
condition|;
name|i
operator|++
operator|,
name|pte
operator|++
control|)
operator|*
name|pte
operator|=
name|PTE_G
expr_stmt|;
ifdef|#
directive|ifdef
name|__mips_n64
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|npt
operator|=
name|nkpt
init|;
name|npt
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|kernel_segmap
index|[
name|i
index|]
operator|=
call|(
name|pd_entry_t
call|)
argument_list|(
name|pdaddr
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pde
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|kernel_segmap
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NPDEPG
operator|&&
name|npt
operator|>
literal|0
condition|;
name|j
operator|++
operator|,
name|npt
operator|--
control|)
name|pde
index|[
name|j
index|]
operator|=
call|(
name|pd_entry_t
call|)
argument_list|(
name|ptaddr
operator|+
operator|(
name|i
operator|*
name|NPDEPG
operator|+
name|j
operator|)
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|pmap_seg_index
argument_list|(
name|VM_MIN_KERNEL_ADDRESS
argument_list|)
init|;
name|i
operator|<
name|nkpt
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|kernel_segmap
index|[
name|j
index|]
operator|=
call|(
name|pd_entry_t
call|)
argument_list|(
name|ptaddr
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PMAP_LOCK_INIT
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_segtab
operator|=
name|kernel_segmap
expr_stmt|;
name|CPU_FILL
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_active
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_asid
index|[
literal|0
index|]
operator|.
name|asid
operator|=
name|PMAP_ASID_RESERVED
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_asid
index|[
literal|0
index|]
operator|.
name|gen
operator|=
literal|0
expr_stmt|;
name|kernel_vm_end
operator|+=
name|nkpt
operator|*
name|NPTEPG
operator|*
name|PAGE_SIZE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_bootstrap
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|need_local_mappings
init|=
literal|0
decl_stmt|;
comment|/* Sort. */
name|again
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
comment|/* 		 * Keep the memory aligned on page boundary. 		 */
name|phys_avail
index|[
name|i
index|]
operator|=
name|round_page
argument_list|(
name|phys_avail
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|trunc_page
argument_list|(
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|2
condition|)
continue|continue;
if|if
condition|(
name|phys_avail
index|[
name|i
operator|-
literal|2
index|]
operator|>
name|phys_avail
index|[
name|i
index|]
condition|)
block|{
name|vm_paddr_t
name|ptemp
index|[
literal|2
index|]
decl_stmt|;
name|ptemp
index|[
literal|0
index|]
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|0
index|]
expr_stmt|;
name|ptemp
index|[
literal|1
index|]
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|0
index|]
operator|=
name|phys_avail
index|[
name|i
operator|-
literal|2
index|]
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|phys_avail
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|phys_avail
index|[
name|i
operator|-
literal|2
index|]
operator|=
name|ptemp
index|[
literal|0
index|]
expr_stmt|;
name|phys_avail
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|ptemp
index|[
literal|1
index|]
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
comment|/* 	 * In 32 bit, we may have memory which cannot be mapped directly. 	 * This memory will need temporary mapping before it can be 	 * accessed. 	 */
if|if
condition|(
operator|!
name|MIPS_DIRECT_MAPPABLE
argument_list|(
name|phys_avail
index|[
name|i
operator|-
literal|1
index|]
operator|-
literal|1
argument_list|)
condition|)
name|need_local_mappings
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Copy the phys_avail[] array before we start stealing memory from it. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|physmem_desc
index|[
name|i
index|]
operator|=
name|phys_avail
index|[
name|i
index|]
expr_stmt|;
name|physmem_desc
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|Maxmem
operator|=
name|atop
argument_list|(
name|phys_avail
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"Physical memory chunk(s):\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|vm_paddr_t
name|size
decl_stmt|;
name|size
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|phys_avail
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%#08jx - %#08jx, %ju bytes (%ju pages)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|phys_avail
index|[
name|i
index|]
argument_list|,
operator|(
name|uintmax_t
operator|)
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|-
literal|1
argument_list|,
operator|(
name|uintmax_t
operator|)
name|size
argument_list|,
operator|(
name|uintmax_t
operator|)
name|size
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Maxmem is 0x%0jx\n"
argument_list|,
name|ptoa
argument_list|(
operator|(
name|uintmax_t
operator|)
name|Maxmem
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Steal the message buffer from the beginning of memory. 	 */
name|msgbufp
operator|=
operator|(
expr|struct
name|msgbuf
operator|*
operator|)
name|pmap_steal_memory
argument_list|(
name|msgbufsize
argument_list|)
expr_stmt|;
name|msgbufinit
argument_list|(
name|msgbufp
argument_list|,
name|msgbufsize
argument_list|)
expr_stmt|;
comment|/* 	 * Steal thread0 kstack. 	 */
name|kstack0
operator|=
name|pmap_steal_memory
argument_list|(
name|KSTACK_PAGES
operator|<<
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
name|virtual_avail
operator|=
name|VM_MIN_KERNEL_ADDRESS
expr_stmt|;
name|virtual_end
operator|=
name|VM_MAX_KERNEL_ADDRESS
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* 	 * Steal some virtual address space to map the pcpu area. 	 */
name|virtual_avail
operator|=
name|roundup2
argument_list|(
name|virtual_avail
argument_list|,
name|PAGE_SIZE
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pcpup
operator|=
operator|(
expr|struct
name|pcpu
operator|*
operator|)
name|virtual_avail
expr_stmt|;
name|virtual_avail
operator|+=
name|PAGE_SIZE
operator|*
literal|2
expr_stmt|;
comment|/* 	 * Initialize the wired TLB entry mapping the pcpu region for 	 * the BSP at 'pcpup'. Up until this point we were operating 	 * with the 'pcpup' for the BSP pointing to a virtual address 	 * in KSEG0 so there was no need for a TLB mapping. 	 */
name|mips_pcpu_tlb_init
argument_list|(
name|PCPU_ADDR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"pcpu is available at virtual address %p.\n"
argument_list|,
name|pcpup
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|need_local_mappings
condition|)
name|pmap_alloc_lmem_map
argument_list|()
expr_stmt|;
name|pmap_create_kernel_pagetable
argument_list|()
expr_stmt|;
name|pmap_max_asid
operator|=
name|VMNUM_PIDS
expr_stmt|;
name|mips_wr_entryhi
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mips_wr_pagemask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the global pv list lock. 	 */
name|rw_init
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
literal|"pmap pv global"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a vm_page's machine-dependent fields.  */
end_comment

begin_function
name|void
name|pmap_page_init
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Initialize the pmap module.  *	Called by vm_init, to initialize any structures that the pmap  *	system needs to map virtual memory.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/***************************************************  * Low level helper routines.....  ***************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
specifier|static
name|__inline
name|void
name|pmap_call_on_active_cpus
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|cpuid
decl_stmt|,
name|cpu
decl_stmt|,
name|self
decl_stmt|;
name|cpuset_t
name|active_cpus
decl_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_kernel_pmap
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|fn
argument_list|,
name|NULL
argument_list|,
name|arg
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Force ASID update on inactive CPUs */
name|CPU_FOREACH
argument_list|(
argument|cpu
argument_list|)
block|{
if|if
condition|(
operator|!
name|CPU_ISSET
argument_list|(
name|cpu
argument_list|,
operator|&
name|pmap
operator|->
name|pm_active
argument_list|)
condition|)
name|pmap
operator|->
name|pm_asid
index|[
name|cpu
index|]
operator|.
name|gen
operator|=
literal|0
expr_stmt|;
block|}
name|cpuid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
comment|/*  	 * XXX: barrier/locking for active?  	 * 	 * Take a snapshot of active here, any further changes are ignored. 	 * tlb update/invalidate should be harmless on inactive CPUs 	 */
name|active_cpus
operator|=
name|pmap
operator|->
name|pm_active
expr_stmt|;
name|self
operator|=
name|CPU_ISSET
argument_list|(
name|cpuid
argument_list|,
operator|&
name|active_cpus
argument_list|)
expr_stmt|;
name|CPU_CLR
argument_list|(
name|cpuid
argument_list|,
operator|&
name|active_cpus
argument_list|)
expr_stmt|;
comment|/* Optimize for the case where this cpu is the only active one */
if|if
condition|(
name|CPU_EMPTY
argument_list|(
operator|&
name|active_cpus
argument_list|)
condition|)
block|{
if|if
condition|(
name|self
condition|)
name|fn
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|self
condition|)
name|CPU_SET
argument_list|(
name|cpuid
argument_list|,
operator|&
name|active_cpus
argument_list|)
expr_stmt|;
name|smp_rendezvous_cpus
argument_list|(
name|active_cpus
argument_list|,
name|NULL
argument_list|,
name|fn
argument_list|,
name|NULL
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|sched_unpin
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !SMP */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pmap_call_on_active_cpus
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|cpuid
decl_stmt|;
if|if
condition|(
name|is_kernel_pmap
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|fn
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
name|cpuid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPU_ISSET
argument_list|(
name|cpuid
argument_list|,
operator|&
name|pmap
operator|->
name|pm_active
argument_list|)
condition|)
name|pmap
operator|->
name|pm_asid
index|[
name|cpuid
index|]
operator|.
name|gen
operator|=
literal|0
expr_stmt|;
else|else
name|fn
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP */
end_comment

begin_function
specifier|static
name|void
name|pmap_invalidate_all
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|pmap_call_on_active_cpus
argument_list|(
name|pmap
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|tlb_invalidate_all_user
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|pmap_invalidate_page_arg
block|{
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|pmap_invalidate_page_action
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pmap_invalidate_page_arg
modifier|*
name|p
init|=
name|arg
decl_stmt|;
name|tlb_invalidate_address
argument_list|(
name|p
operator|->
name|pmap
argument_list|,
name|p
operator|->
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_invalidate_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|pmap_invalidate_page_arg
name|arg
decl_stmt|;
name|arg
operator|.
name|pmap
operator|=
name|pmap
expr_stmt|;
name|arg
operator|.
name|va
operator|=
name|va
expr_stmt|;
name|pmap_call_on_active_cpus
argument_list|(
name|pmap
argument_list|,
name|pmap_invalidate_page_action
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|pmap_update_page_arg
block|{
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|pt_entry_t
name|pte
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|pmap_update_page_action
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pmap_update_page_arg
modifier|*
name|p
init|=
name|arg
decl_stmt|;
name|tlb_update
argument_list|(
name|p
operator|->
name|pmap
argument_list|,
name|p
operator|->
name|va
argument_list|,
name|p
operator|->
name|pte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_update_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pt_entry_t
name|pte
parameter_list|)
block|{
name|struct
name|pmap_update_page_arg
name|arg
decl_stmt|;
name|arg
operator|.
name|pmap
operator|=
name|pmap
expr_stmt|;
name|arg
operator|.
name|va
operator|=
name|va
expr_stmt|;
name|arg
operator|.
name|pte
operator|=
name|pte
expr_stmt|;
name|pmap_call_on_active_cpus
argument_list|(
name|pmap
argument_list|,
name|pmap_update_page_action
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract  *	Function:  *		Extract the physical page address associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
name|vm_paddr_t
name|pmap_extract
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_offset_t
name|retval
init|=
literal|0
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
condition|)
block|{
name|retval
operator|=
name|TLBLO_PTE_TO_PA
argument_list|(
operator|*
name|pte
argument_list|)
operator||
operator|(
name|va
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract_and_hold  *	Function:  *		Atomically extract and hold the physical page  *		with the given pmap and virtual address pair  *		if that mapping permits the given protection.  */
end_comment

begin_function
name|vm_page_t
name|pmap_extract_and_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|pt_entry_t
name|pte
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|pa
operator|=
literal|0
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|retry
label|:
name|ptep
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptep
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|pte
operator|=
operator|*
name|ptep
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|pte_test
argument_list|(
operator|&
name|pte
argument_list|,
name|PTE_V
argument_list|)
operator|&&
operator|(
name|pte_test
argument_list|(
operator|&
name|pte
argument_list|,
name|PTE_D
argument_list|)
operator|||
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|vm_page_pa_tryrelock
argument_list|(
name|pmap
argument_list|,
name|TLBLO_PTE_TO_PA
argument_list|(
name|pte
argument_list|)
argument_list|,
operator|&
name|pa
argument_list|)
condition|)
goto|goto
name|retry
goto|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TLBLO_PTE_TO_PA
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|PA_UNLOCK_COND
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * Low level mapping routines.....  ***************************************************/
end_comment

begin_comment
comment|/*  * add a wired page to the kva  */
end_comment

begin_function
name|void
name|pmap_kenter_attr
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|,
name|int
name|attr
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pt_entry_t
name|opte
decl_stmt|,
name|npte
decl_stmt|;
ifdef|#
directive|ifdef
name|PMAP_DEBUG
name|printf
argument_list|(
literal|"pmap_kenter:  va: %p -> pa: %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|npte
operator|=
name|TLBLO_PA_TO_PFN
argument_list|(
name|pa
argument_list|)
operator||
name|PTE_D
operator||
name|PTE_V
operator||
name|PTE_G
operator||
name|PTE_W
operator||
name|attr
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|opte
operator|=
operator|*
name|pte
expr_stmt|;
operator|*
name|pte
operator|=
name|npte
expr_stmt|;
if|if
condition|(
name|pte_test
argument_list|(
operator|&
name|opte
argument_list|,
name|PTE_V
argument_list|)
operator|&&
name|opte
operator|!=
name|npte
condition|)
name|pmap_update_page
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|,
name|npte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_kenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|is_cacheable_mem
argument_list|(
name|pa
argument_list|)
argument_list|,
operator|(
literal|"pmap_kenter: memory at 0x%lx is not cacheable"
operator|,
operator|(
name|u_long
operator|)
name|pa
operator|)
argument_list|)
expr_stmt|;
name|pmap_kenter_attr
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|PTE_C_CACHE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove a page from the kernel pagetables  */
end_comment

begin_comment
comment|/* PMAP_INLINE */
end_comment

begin_function
name|void
name|pmap_kremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
comment|/* 	 * Write back all caches from the page being destroyed 	 */
name|mips_dcache_wbinv_range_index
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
name|PTE_G
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Used to map a range of physical addresses into kernel  *	virtual address space.  *  *	The value passed in '*virt' is a suggested virtual address for  *	the mapping. Architectures which can support a direct-mapped  *	physical to virtual region can return the appropriate address  *	within that region, leaving '*virt' unchanged. Other  *	architectures should map the pages starting at '*virt' and  *	update '*virt' with the first usable address after the mapped  *	region.  *  *	Use XKPHYS for 64 bit, and KSEG0 where possible for 32 bit.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_paddr_t
name|start
parameter_list|,
name|vm_paddr_t
name|end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|,
name|sva
decl_stmt|;
if|if
condition|(
name|MIPS_DIRECT_MAPPABLE
argument_list|(
name|end
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
name|MIPS_PHYS_TO_DIRECT
argument_list|(
name|start
argument_list|)
operator|)
return|;
name|va
operator|=
name|sva
operator|=
operator|*
name|virt
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|start
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
operator|*
name|virt
operator|=
name|va
expr_stmt|;
return|return
operator|(
name|sva
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a list of wired pages to the kva  * this routine is only used for temporary  * kernel mappings that do not need to have  * page modification or references recorded.  * Note that old mappings are simply written  * over.  The page *must* be wired.  */
end_comment

begin_function
name|void
name|pmap_qenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|origva
init|=
name|va
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|pmap_flush_pvcache
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|mips_dcache_wbinv_range_index
argument_list|(
name|origva
argument_list|,
name|PAGE_SIZE
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this routine jerks page mappings from the  * kernel -- it is meant only for temporary mappings.  */
end_comment

begin_function
name|void
name|pmap_qremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|int
name|count
parameter_list|)
block|{
comment|/* 	 * No need to wb/inv caches here,  	 *   pmap_kremove will do it for us 	 */
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|pmap_kremove
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***************************************************  * Page table page management routines.....  ***************************************************/
end_comment

begin_comment
comment|/*  Revision 1.507  *  * Simplify the reference counting of page table pages.	 Specifically, use  * the page table page's wired count rather than its hold count to contain  * the reference count.  */
end_comment

begin_comment
comment|/*  * This routine unholds page table pages, and if the hold count  * drops to zero, then it decrements the wire count.  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|int
name|pmap_unwire_pte_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
operator|--
name|m
operator|->
name|wire_count
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
return|return
operator|(
name|_pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_pmap_unwire_pte_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * unmap the page table page 	 */
ifdef|#
directive|ifdef
name|__mips_n64
if|if
condition|(
name|m
operator|->
name|pindex
operator|<
name|NUPDE
condition|)
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
else|else
name|pde
operator|=
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
else|#
directive|else
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|pde
operator|=
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|__mips_n64
if|if
condition|(
name|m
operator|->
name|pindex
operator|<
name|NUPDE
condition|)
block|{
name|pd_entry_t
modifier|*
name|pdp
decl_stmt|;
name|vm_page_t
name|pdpg
decl_stmt|;
comment|/* 		 * Recursively decrement next level pagetable refcount 		 */
name|pdp
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
operator|*
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pdpg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|MIPS_DIRECT_TO_PHYS
argument_list|(
name|pdp
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|pdpg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * If the page is finally unwired, simply free it. 	 */
name|vm_page_free_zero
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * After removing a page table entry, this routine is used to  * conditionally free the page, and manage the hold/wire counts.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_unuse_pt
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
name|pde
parameter_list|)
block|{
name|vm_page_t
name|mpte
decl_stmt|;
if|if
condition|(
name|va
operator|>=
name|VM_MAXUSER_ADDRESS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KASSERT
argument_list|(
name|pde
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_unuse_pt: pde != 0"
operator|)
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|MIPS_DIRECT_TO_PHYS
argument_list|(
name|pde
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|mpte
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_pinit0
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_segtab
operator|=
name|kernel_segmap
expr_stmt|;
name|CPU_ZERO
argument_list|(
operator|&
name|pmap
operator|->
name|pm_active
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|pmap
operator|->
name|pm_asid
index|[
name|i
index|]
operator|.
name|asid
operator|=
name|PMAP_ASID_RESERVED
expr_stmt|;
name|pmap
operator|->
name|pm_asid
index|[
name|i
index|]
operator|.
name|gen
operator|=
literal|0
expr_stmt|;
block|}
name|PCPU_SET
argument_list|(
name|curpmap
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
name|pmap
operator|->
name|pm_stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_grow_direct_page_cache
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|__mips_n64
name|vm_pageout_grow_cache
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
name|MIPS_XKPHYS_LARGEST_PHYS
argument_list|)
expr_stmt|;
else|#
directive|else
name|vm_pageout_grow_cache
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
name|MIPS_KSEG0_LARGEST_PHYS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|vm_page_t
name|pmap_alloc_direct_page
parameter_list|(
name|unsigned
name|int
name|index
parameter_list|,
name|int
name|req
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|m
operator|=
name|vm_page_alloc_freelist
argument_list|(
name|VM_FREELIST_DIRECT
argument_list|,
name|req
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|pmap_zero_page
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|pindex
operator|=
name|index
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure,  * such as one in a vmspace structure.  */
end_comment

begin_function
name|int
name|pmap_pinit
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|vm_offset_t
name|ptdva
decl_stmt|;
name|vm_page_t
name|ptdpg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 	 * allocate the page directory page 	 */
while|while
condition|(
operator|(
name|ptdpg
operator|=
name|pmap_alloc_direct_page
argument_list|(
name|NUSERPGTBLS
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|pmap_grow_direct_page_cache
argument_list|()
expr_stmt|;
name|ptdva
operator|=
name|MIPS_PHYS_TO_DIRECT
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|ptdpg
argument_list|)
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_segtab
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|ptdva
expr_stmt|;
name|CPU_ZERO
argument_list|(
operator|&
name|pmap
operator|->
name|pm_active
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|pmap
operator|->
name|pm_asid
index|[
name|i
index|]
operator|.
name|asid
operator|=
name|PMAP_ASID_RESERVED
expr_stmt|;
name|pmap
operator|->
name|pm_asid
index|[
name|i
index|]
operator|.
name|gen
operator|=
literal|0
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
name|pmap
operator|->
name|pm_stats
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this routine is called if the page table page is not  * mapped correctly.  */
end_comment

begin_function
specifier|static
name|vm_page_t
name|_pmap_allocpte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|unsigned
name|ptepindex
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_offset_t
name|pageva
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_WAITOK
operator|)
operator|)
operator|==
name|M_NOWAIT
operator|||
operator|(
name|flags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_WAITOK
operator|)
operator|)
operator|==
name|M_WAITOK
argument_list|,
operator|(
literal|"_pmap_allocpte: flags is neither M_NOWAIT nor M_WAITOK"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Find or fabricate a new pagetable page 	 */
if|if
condition|(
operator|(
name|m
operator|=
name|pmap_alloc_direct_page
argument_list|(
name|ptepindex
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|M_WAITOK
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|pmap_grow_direct_page_cache
argument_list|()
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Indicate the need to retry.	While waiting, the page 		 * table page may have been allocated. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Map the pagetable page into the process address space, if it 	 * isn't already there. 	 */
name|pageva
operator|=
name|MIPS_PHYS_TO_DIRECT
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__mips_n64
if|if
condition|(
name|ptepindex
operator|>=
name|NUPDE
condition|)
block|{
name|pmap
operator|->
name|pm_segtab
index|[
name|ptepindex
operator|-
name|NUPDE
index|]
operator|=
operator|(
name|pd_entry_t
operator|)
name|pageva
expr_stmt|;
block|}
else|else
block|{
name|pd_entry_t
modifier|*
name|pdep
decl_stmt|,
modifier|*
name|pde
decl_stmt|;
name|int
name|segindex
init|=
name|ptepindex
operator|>>
operator|(
name|SEGSHIFT
operator|-
name|PDRSHIFT
operator|)
decl_stmt|;
name|int
name|pdeindex
init|=
name|ptepindex
operator|&
operator|(
name|NPDEPG
operator|-
literal|1
operator|)
decl_stmt|;
name|vm_page_t
name|pg
decl_stmt|;
name|pdep
operator|=
operator|&
name|pmap
operator|->
name|pm_segtab
index|[
name|segindex
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|pdep
operator|==
name|NULL
condition|)
block|{
comment|/* recurse for allocating page dir */
if|if
condition|(
name|_pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|NUPDE
operator|+
name|segindex
argument_list|,
name|flags
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* alloc failed, release current */
operator|--
name|m
operator|->
name|wire_count
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_free_zero
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
name|pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|MIPS_DIRECT_TO_PHYS
argument_list|(
operator|*
name|pdep
argument_list|)
argument_list|)
expr_stmt|;
name|pg
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
comment|/* Next level entry */
name|pde
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
operator|*
name|pdep
expr_stmt|;
name|pde
index|[
name|pdeindex
index|]
operator|=
operator|(
name|pd_entry_t
operator|)
name|pageva
expr_stmt|;
block|}
else|#
directive|else
name|pmap
operator|->
name|pm_segtab
index|[
name|ptepindex
index|]
operator|=
operator|(
name|pd_entry_t
operator|)
name|pageva
expr_stmt|;
endif|#
directive|endif
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|pmap_allocpte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|ptepindex
decl_stmt|;
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_WAITOK
operator|)
operator|)
operator|==
name|M_NOWAIT
operator|||
operator|(
name|flags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_WAITOK
operator|)
operator|)
operator|==
name|M_WAITOK
argument_list|,
operator|(
literal|"pmap_allocpte: flags is neither M_NOWAIT nor M_WAITOK"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate pagetable page index 	 */
name|ptepindex
operator|=
name|pmap_pde_pindex
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|retry
label|:
comment|/* 	 * Get the page directory entry 	 */
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * If the page table page is mapped, we just increment the hold 	 * count, and activate it. 	 */
if|if
condition|(
name|pde
operator|!=
name|NULL
operator|&&
operator|*
name|pde
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|MIPS_DIRECT_TO_PHYS
argument_list|(
operator|*
name|pde
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Here if the pte page isn't mapped, or if it has been 		 * deallocated. 		 */
name|m
operator|=
name|_pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|ptepindex
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|&&
operator|(
name|flags
operator|&
name|M_WAITOK
operator|)
condition|)
goto|goto
name|retry
goto|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * Pmap allocation/deallocation routines.  ***************************************************/
end_comment

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|vm_offset_t
name|ptdva
decl_stmt|;
name|vm_page_t
name|ptdpg
decl_stmt|;
name|KASSERT
argument_list|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_release: pmap resident count %ld != 0"
operator|,
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|)
argument_list|)
expr_stmt|;
name|ptdva
operator|=
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_segtab
expr_stmt|;
name|ptdpg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|MIPS_DIRECT_TO_PHYS
argument_list|(
name|ptdva
argument_list|)
argument_list|)
expr_stmt|;
name|ptdpg
operator|->
name|wire_count
operator|--
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_free_zero
argument_list|(
name|ptdpg
argument_list|)
expr_stmt|;
name|PMAP_LOCK_DESTROY
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * grow the number of kernel page table entries, if needed  */
end_comment

begin_function
name|void
name|pmap_growkernel
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|vm_page_t
name|nkpg
decl_stmt|;
name|pd_entry_t
modifier|*
name|pde
decl_stmt|,
modifier|*
name|pdpe
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|kernel_map
operator|->
name|system_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|addr
operator|=
name|roundup2
argument_list|(
name|addr
argument_list|,
name|NBSEG
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|-
literal|1
operator|>=
name|kernel_map
operator|->
name|max_offset
condition|)
name|addr
operator|=
name|kernel_map
operator|->
name|max_offset
expr_stmt|;
while|while
condition|(
name|kernel_vm_end
operator|<
name|addr
condition|)
block|{
name|pdpe
operator|=
name|pmap_segmap
argument_list|(
name|kernel_pmap
argument_list|,
name|kernel_vm_end
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__mips_n64
if|if
condition|(
operator|*
name|pdpe
operator|==
literal|0
condition|)
block|{
comment|/* new intermediate page table entry */
name|nkpg
operator|=
name|pmap_alloc_direct_page
argument_list|(
name|nkpt
argument_list|,
name|VM_ALLOC_INTERRUPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkpg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_growkernel: no memory to grow kernel"
argument_list|)
expr_stmt|;
operator|*
name|pdpe
operator|=
operator|(
name|pd_entry_t
operator|)
name|MIPS_PHYS_TO_DIRECT
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|nkpg
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
comment|/* try again */
block|}
endif|#
directive|endif
name|pde
operator|=
name|pmap_pdpe_to_pde
argument_list|(
name|pdpe
argument_list|,
name|kernel_vm_end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pde
operator|!=
literal|0
condition|)
block|{
name|kernel_vm_end
operator|=
operator|(
name|kernel_vm_end
operator|+
name|NBPDR
operator|)
operator|&
operator|~
name|PDRMASK
expr_stmt|;
if|if
condition|(
name|kernel_vm_end
operator|-
literal|1
operator|>=
name|kernel_map
operator|->
name|max_offset
condition|)
block|{
name|kernel_vm_end
operator|=
name|kernel_map
operator|->
name|max_offset
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
comment|/* 		 * This index is bogus, but out of the way 		 */
name|nkpg
operator|=
name|pmap_alloc_direct_page
argument_list|(
name|nkpt
argument_list|,
name|VM_ALLOC_INTERRUPT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nkpg
condition|)
name|panic
argument_list|(
literal|"pmap_growkernel: no memory to grow kernel"
argument_list|)
expr_stmt|;
name|nkpt
operator|++
expr_stmt|;
operator|*
name|pde
operator|=
operator|(
name|pd_entry_t
operator|)
name|MIPS_PHYS_TO_DIRECT
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|nkpg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * The R[4-7]?00 stores only one copy of the Global bit in 		 * the translation lookaside buffer for each 2 page entry. 		 * Thus invalid entrys must have the Global bit set so when 		 * Entry LO and Entry HI G bits are anded together they will 		 * produce a global bit to store in the tlb. 		 */
name|pte
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
operator|*
name|pde
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPTEPG
condition|;
name|i
operator|++
control|)
name|pte
index|[
name|i
index|]
operator|=
name|PTE_G
expr_stmt|;
name|kernel_vm_end
operator|=
operator|(
name|kernel_vm_end
operator|+
name|NBPDR
operator|)
operator|&
operator|~
name|PDRMASK
expr_stmt|;
if|if
condition|(
name|kernel_vm_end
operator|-
literal|1
operator|>=
name|kernel_map
operator|->
name|max_offset
condition|)
block|{
name|kernel_vm_end
operator|=
name|kernel_map
operator|->
name|max_offset
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/***************************************************  * page management routines.  ***************************************************/
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pv_chunk
argument_list|)
operator|==
name|PAGE_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__mips_n64
end_ifdef

begin_expr_stmt
name|CTASSERT
argument_list|(
name|_NPCM
operator|==
literal|3
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|_NPCPV
operator|==
literal|168
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|CTASSERT
argument_list|(
name|_NPCM
operator|==
literal|11
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|_NPCPV
operator|==
literal|336
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|pv_chunk
operator|*
name|pv_to_chunk
argument_list|(
argument|pv_entry_t pv
argument_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|pv_chunk
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|pv
operator|&
operator|~
operator|(
name|uintptr_t
operator|)
name|PAGE_MASK
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_define
define|#
directive|define
name|PV_PMAP
parameter_list|(
name|pv
parameter_list|)
value|(pv_to_chunk(pv)->pc_pmap)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__mips_n64
end_ifdef

begin_define
define|#
directive|define
name|PC_FREE0_1
value|0xfffffffffffffffful
end_define

begin_define
define|#
directive|define
name|PC_FREE2
value|0x000000fffffffffful
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PC_FREE0_9
value|0xfffffffful
end_define

begin_comment
comment|/* Free values for index 0 through 9 */
end_comment

begin_define
define|#
directive|define
name|PC_FREE10
value|0x0000fffful
end_define

begin_comment
comment|/* Free values for index 10 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|u_long
name|pc_freemask
index|[
name|_NPCM
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|__mips_n64
name|PC_FREE0_1
block|,
name|PC_FREE0_1
block|,
name|PC_FREE2
else|#
directive|else
name|PC_FREE0_9
block|,
name|PC_FREE0_9
block|,
name|PC_FREE0_9
block|,
name|PC_FREE0_9
block|,
name|PC_FREE0_9
block|,
name|PC_FREE0_9
block|,
name|PC_FREE0_9
block|,
name|PC_FREE0_9
block|,
name|PC_FREE0_9
block|,
name|PC_FREE0_9
block|,
name|PC_FREE10
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"VM/pmap parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_count
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PV_STATS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|pc_chunk_count
decl_stmt|,
name|pc_chunk_allocs
decl_stmt|,
name|pc_chunk_frees
decl_stmt|,
name|pc_chunk_tryfail
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_count
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry chunks"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_allocs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_allocs
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry chunks allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_frees
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_frees
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry chunks frees"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_tryfail
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_tryfail
argument_list|,
literal|0
argument_list|,
literal|"Number of times tried to get a chunk page but failed."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|long
name|pv_entry_frees
decl_stmt|,
name|pv_entry_allocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pv_entry_spare
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_frees
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_frees
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry frees"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_allocs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_allocs
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry allocs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_spare
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_spare
argument_list|,
literal|0
argument_list|,
literal|"Current number of spare pv entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * We are in a serious low memory condition.  Resort to  * drastic measures to free some pages so we can allocate  * another pv entry chunk.  */
end_comment

begin_function
specifier|static
name|vm_page_t
name|pmap_pv_reclaim
parameter_list|(
name|pmap_t
name|locked_pmap
parameter_list|)
block|{
name|struct
name|pch
name|newtail
decl_stmt|;
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|;
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|oldpte
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
name|m_pc
decl_stmt|;
name|u_long
name|inuse
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|field
decl_stmt|,
name|freed
decl_stmt|,
name|idx
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|locked_pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pmap
operator|=
name|NULL
expr_stmt|;
name|m_pc
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|newtail
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pv_chunks
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pv_chunks
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|pc
operator|->
name|pc_pmap
condition|)
block|{
if|if
condition|(
name|pmap
operator|!=
name|NULL
condition|)
block|{
name|pmap_invalidate_all
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|locked_pmap
condition|)
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|pmap
operator|=
name|pc
operator|->
name|pc_pmap
expr_stmt|;
comment|/* Avoid deadlock and lock recursion. */
if|if
condition|(
name|pmap
operator|>
name|locked_pmap
condition|)
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pmap
operator|!=
name|locked_pmap
operator|&&
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|pmap
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|newtail
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Destroy every non-wired, 4 KB page mapping in the chunk. 		 */
name|freed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
block|{
for|for
control|(
name|inuse
operator|=
operator|~
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|&
name|pc_freemask
index|[
name|field
index|]
init|;
name|inuse
operator|!=
literal|0
condition|;
name|inuse
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
name|bit
operator|)
control|)
block|{
name|bit
operator|=
name|ffsl
argument_list|(
name|inuse
argument_list|)
operator|-
literal|1
expr_stmt|;
name|idx
operator|=
name|field
operator|*
sizeof|sizeof
argument_list|(
name|inuse
argument_list|)
operator|*
name|NBBY
operator|+
name|bit
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
name|idx
index|]
expr_stmt|;
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pde
operator|!=
name|NULL
operator|&&
operator|*
name|pde
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_pv_reclaim: pde"
operator|)
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pde_to_pte
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|oldpte
operator|=
operator|*
name|pte
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|pte_test
argument_list|(
operator|&
name|oldpte
argument_list|,
name|PTE_W
argument_list|)
argument_list|,
operator|(
literal|"wired pte for unwired page"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_kernel_pmap
argument_list|(
name|pmap
argument_list|)
condition|)
operator|*
name|pte
operator|=
name|PTE_G
expr_stmt|;
else|else
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TLBLO_PTE_TO_PA
argument_list|(
name|oldpte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte_test
argument_list|(
operator|&
name|oldpte
argument_list|,
name|PTE_D
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&
name|PV_TABLE_REF
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
block|{
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&=
operator|~
operator|(
name|PV_TABLE_REF
operator||
name|PV_TABLE_MOD
operator|)
expr_stmt|;
block|}
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator||=
literal|1UL
operator|<<
name|bit
expr_stmt|;
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
operator|*
name|pde
argument_list|)
expr_stmt|;
name|freed
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|freed
operator|==
literal|0
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|newtail
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Every freed mapping is for a 4 KB page. */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
name|freed
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_frees
operator|+=
name|freed
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|+=
name|freed
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|-=
name|freed
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|!=
name|pc_freemask
index|[
name|field
index|]
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|newtail
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
comment|/* 				 * One freed pv entry in locked_pmap is 				 * sufficient. 				 */
if|if
condition|(
name|pmap
operator|==
name|locked_pmap
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
if|if
condition|(
name|field
operator|==
name|_NPCM
condition|)
block|{
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|-=
name|_NPCPV
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_count
operator|--
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_frees
operator|++
argument_list|)
expr_stmt|;
comment|/* Entire chunk is free; return it. */
name|m_pc
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|MIPS_DIRECT_TO_PHYS
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
name|TAILQ_CONCAT
argument_list|(
operator|&
name|pv_chunks
argument_list|,
operator|&
name|newtail
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|NULL
condition|)
block|{
name|pmap_invalidate_all
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|locked_pmap
condition|)
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m_pc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * free the pv_entry back to the free list  */
end_comment

begin_function
specifier|static
name|void
name|free_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pv_entry_t
name|pv
parameter_list|)
block|{
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|field
decl_stmt|,
name|idx
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_frees
operator|++
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|++
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|--
expr_stmt|;
name|pc
operator|=
name|pv_to_chunk
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|idx
operator|=
name|pv
operator|-
operator|&
name|pc
operator|->
name|pc_pventry
index|[
literal|0
index|]
expr_stmt|;
name|field
operator|=
name|idx
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|NBBY
operator|)
expr_stmt|;
name|bit
operator|=
name|idx
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|NBBY
operator|)
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator||=
literal|1ul
operator|<<
name|bit
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|_NPCM
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
name|idx
index|]
operator|!=
name|pc_freemask
index|[
name|idx
index|]
condition|)
block|{
comment|/* 			 * 98% of the time, pc is already at the head of the 			 * list.  If it isn't already, move it to the head. 			 */
if|if
condition|(
name|__predict_false
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
operator|!=
name|pc
argument_list|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|free_pv_chunk
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_pv_chunk
parameter_list|(
name|struct
name|pv_chunk
modifier|*
name|pc
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pv_chunks
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|-=
name|_NPCPV
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_count
operator|--
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_frees
operator|++
argument_list|)
expr_stmt|;
comment|/* entire chunk is free, return it */
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|MIPS_DIRECT_TO_PHYS
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a new pv_entry, allocating a block from the system  * when needed.  */
end_comment

begin_function
specifier|static
name|pv_entry_t
name|get_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|boolean_t
name|try
parameter_list|)
block|{
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|field
decl_stmt|,
name|idx
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_allocs
operator|++
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|++
expr_stmt|;
name|retry
label|:
name|pc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
block|{
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
condition|)
block|{
name|bit
operator|=
name|ffsl
argument_list|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|field
operator|<
name|_NPCM
condition|)
block|{
name|idx
operator|=
name|field
operator|*
sizeof|sizeof
argument_list|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
argument_list|)
operator|*
name|NBBY
operator|+
name|bit
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
name|idx
index|]
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|&=
operator|~
operator|(
literal|1ul
operator|<<
name|bit
operator|)
expr_stmt|;
comment|/* If this was the last item, move it to tail */
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|!=
literal|0
condition|)
block|{
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|--
argument_list|)
expr_stmt|;
return|return
operator|(
name|pv
operator|)
return|;
comment|/* not full, return */
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|--
argument_list|)
expr_stmt|;
return|return
operator|(
name|pv
operator|)
return|;
block|}
block|}
comment|/* No free items, allocate another chunk */
name|m
operator|=
name|vm_page_alloc_freelist
argument_list|(
name|VM_FREELIST_DIRECT
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|try
condition|)
block|{
name|pv_entry_count
operator|--
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_tryfail
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m
operator|=
name|pmap_pv_reclaim
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|retry
goto|;
block|}
name|PV_STAT
argument_list|(
name|pc_chunk_count
operator|++
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_allocs
operator|++
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
expr|struct
name|pv_chunk
operator|*
operator|)
name|MIPS_PHYS_TO_DIRECT
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_pmap
operator|=
name|pmap
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
literal|0
index|]
operator|=
name|pc_freemask
index|[
literal|0
index|]
operator|&
operator|~
literal|1ul
expr_stmt|;
comment|/* preallocated bit 0 */
for|for
control|(
name|field
operator|=
literal|1
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|=
name|pc_freemask
index|[
name|field
index|]
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pv_chunks
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
literal|0
index|]
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|+=
name|_NPCPV
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|pv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If it is the first entry on the list, it is actually  * in the header and we must copy the following entry up  * to the header.  Otherwise we must search the list for  * the entry.  In either case we free the now unused entry.  */
end_comment

begin_function
specifier|static
name|pv_entry_t
name|pmap_pvh_remove
parameter_list|(
name|struct
name|md_page
modifier|*
name|pvh
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pvh->pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|pmap
operator|==
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|pv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_pvh_free
parameter_list|(
name|struct
name|md_page
modifier|*
name|pvh
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pv
operator|=
name|pmap_pvh_remove
argument_list|(
name|pvh
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pv
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_pvh_free: pv not found, pa %lx va %lx"
operator|,
operator|(
name|u_long
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|member2struct
argument_list|(
name|vm_page
argument_list|,
name|md
argument_list|,
name|pvh
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|va
operator|)
argument_list|)
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pmap
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_remove_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|pmap_pvh_free
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Conditionally create a pv entry.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|pmap_try_insert_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pv
operator|=
name|get_pv_entry
argument_list|(
name|pmap
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pmap_remove_pte: do the things to unmap a page in a process  */
end_comment

begin_function
specifier|static
name|int
name|pmap_remove_pte
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|,
name|pt_entry_t
modifier|*
name|ptq
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
name|pde
parameter_list|)
block|{
name|pt_entry_t
name|oldpte
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|oldpte
operator|=
operator|*
name|ptq
expr_stmt|;
if|if
condition|(
name|is_kernel_pmap
argument_list|(
name|pmap
argument_list|)
condition|)
operator|*
name|ptq
operator|=
name|PTE_G
expr_stmt|;
else|else
operator|*
name|ptq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pte_test
argument_list|(
operator|&
name|oldpte
argument_list|,
name|PTE_W
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|-=
literal|1
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
literal|1
expr_stmt|;
name|pa
operator|=
name|TLBLO_PTE_TO_PA
argument_list|(
name|oldpte
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_is_managed
argument_list|(
name|pa
argument_list|)
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte_test
argument_list|(
operator|&
name|oldpte
argument_list|,
name|PTE_D
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
name|pte_test
argument_list|(
operator|&
name|oldpte
argument_list|,
name|PTE_RO
argument_list|)
argument_list|,
operator|(
literal|"%s: modified page not writable: va: %p, pte: %#jx"
operator|,
name|__func__
operator|,
operator|(
name|void
operator|*
operator|)
name|va
operator|,
operator|(
name|uintmax_t
operator|)
name|oldpte
operator|)
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&
name|PV_TABLE_REF
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&=
operator|~
operator|(
name|PV_TABLE_REF
operator||
name|PV_TABLE_MOD
operator|)
expr_stmt|;
name|pmap_remove_entry
argument_list|(
name|pmap
argument_list|,
name|m
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|pde
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a single page from a process address space  */
end_comment

begin_function
specifier|static
name|void
name|pmap_remove_page
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptq
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde
operator|==
name|NULL
operator|||
operator|*
name|pde
operator|==
literal|0
condition|)
return|return;
name|ptq
operator|=
name|pmap_pde_to_pte
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * if there is no pte for this address, just skip it!!! 	 */
if|if
condition|(
operator|!
name|pte_test
argument_list|(
name|ptq
argument_list|,
name|PTE_V
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* 	 * Write back all caches from the page being destroyed 	 */
name|mips_dcache_wbinv_range_index
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * get a local va for mappings for this pmap. 	 */
operator|(
name|void
operator|)
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|ptq
argument_list|,
name|va
argument_list|,
operator|*
name|pde
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  *	Remove the given range of addresses from the specified map.  *  *	It is assumed that the start and end are properly  *	rounded to the page size.  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|vm_offset_t
name|va_next
decl_stmt|;
name|pd_entry_t
modifier|*
name|pde
decl_stmt|,
modifier|*
name|pdpe
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
condition|)
return|return;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 	 * special handling of removing one page.  a very common operation 	 * and easy to short circuit some code. 	 */
if|if
condition|(
operator|(
name|sva
operator|+
name|PAGE_SIZE
operator|)
operator|==
name|eva
condition|)
block|{
name|pmap_remove_page
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
init|;
name|sva
operator|<
name|eva
condition|;
name|sva
operator|=
name|va_next
control|)
block|{
name|pdpe
operator|=
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__mips_n64
if|if
condition|(
operator|*
name|pdpe
operator|==
literal|0
condition|)
block|{
name|va_next
operator|=
operator|(
name|sva
operator|+
name|NBSEG
operator|)
operator|&
operator|~
name|SEGMASK
expr_stmt|;
if|if
condition|(
name|va_next
operator|<
name|sva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|va_next
operator|=
operator|(
name|sva
operator|+
name|NBPDR
operator|)
operator|&
operator|~
name|PDRMASK
expr_stmt|;
if|if
condition|(
name|va_next
operator|<
name|sva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
name|pde
operator|=
name|pmap_pdpe_to_pde
argument_list|(
name|pdpe
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pde
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|va_next
operator|>
name|eva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
for|for
control|(
name|pte
operator|=
name|pmap_pde_to_pte
argument_list|(
name|pde
argument_list|,
name|sva
argument_list|)
init|;
name|sva
operator|!=
name|va_next
condition|;
name|pte
operator|++
operator|,
name|sva
operator|+=
name|PAGE_SIZE
control|)
block|{
name|pmap_remove_page
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_remove_all  *	Function:  *		Removes this physical page from  *		all physical maps in which it resides.  *		Reflects back modify bits to the pager.  *  *	Notes:  *		Original versions of this routine were very  *		inefficient because they iteratively called  *		pmap_remove (slow...)  */
end_comment

begin_function
name|void
name|pmap_remove_all
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_remove_all: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&
name|PV_TABLE_REF
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 		 * If it's last mapping writeback all caches from  		 * the page being destroyed 	 	 */
if|if
condition|(
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_list
argument_list|)
operator|==
name|NULL
condition|)
name|mips_dcache_wbinv_range_index
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pde
operator|!=
name|NULL
operator|&&
operator|*
name|pde
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_remove_all: pde"
operator|)
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pde_to_pte
argument_list|(
name|pde
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|tpte
operator|=
operator|*
name|pte
expr_stmt|;
if|if
condition|(
name|is_kernel_pmap
argument_list|(
name|pmap
argument_list|)
condition|)
operator|*
name|pte
operator|=
name|PTE_G
expr_stmt|;
else|else
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pte_test
argument_list|(
operator|&
name|tpte
argument_list|,
name|PTE_W
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
comment|/* 		 * Update the vm_page_t clean and reference bits. 		 */
if|if
condition|(
name|pte_test
argument_list|(
operator|&
name|tpte
argument_list|,
name|PTE_D
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
name|pte_test
argument_list|(
operator|&
name|tpte
argument_list|,
name|PTE_RO
argument_list|)
argument_list|,
operator|(
literal|"%s: modified page not writable: va: %p, pte: %#jx"
operator|,
name|__func__
operator|,
operator|(
name|void
operator|*
operator|)
name|pv
operator|->
name|pv_va
operator|,
operator|(
name|uintmax_t
operator|)
name|tpte
operator|)
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|*
name|pde
argument_list|)
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pmap
argument_list|,
name|pv
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&=
operator|~
operator|(
name|PV_TABLE_REF
operator||
name|PV_TABLE_MOD
operator|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Set the physical protection on the  *	specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pd_entry_t
modifier|*
name|pde
decl_stmt|,
modifier|*
name|pdpe
decl_stmt|;
name|vm_offset_t
name|va_next
decl_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
return|return;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sva
operator|<
name|eva
condition|;
name|sva
operator|=
name|va_next
control|)
block|{
name|pt_entry_t
name|pbits
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|pdpe
operator|=
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__mips_n64
if|if
condition|(
operator|*
name|pdpe
operator|==
literal|0
condition|)
block|{
name|va_next
operator|=
operator|(
name|sva
operator|+
name|NBSEG
operator|)
operator|&
operator|~
name|SEGMASK
expr_stmt|;
if|if
condition|(
name|va_next
operator|<
name|sva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|va_next
operator|=
operator|(
name|sva
operator|+
name|NBPDR
operator|)
operator|&
operator|~
name|PDRMASK
expr_stmt|;
if|if
condition|(
name|va_next
operator|<
name|sva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
name|pde
operator|=
name|pmap_pdpe_to_pde
argument_list|(
name|pdpe
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde
operator|==
name|NULL
operator|||
operator|*
name|pde
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|va_next
operator|>
name|eva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
for|for
control|(
name|pte
operator|=
name|pmap_pde_to_pte
argument_list|(
name|pde
argument_list|,
name|sva
argument_list|)
init|;
name|sva
operator|!=
name|va_next
condition|;
name|pte
operator|++
operator|,
name|sva
operator|+=
name|PAGE_SIZE
control|)
block|{
comment|/* Skip invalid PTEs */
if|if
condition|(
operator|!
name|pte_test
argument_list|(
name|pte
argument_list|,
name|PTE_V
argument_list|)
condition|)
continue|continue;
name|pbits
operator|=
operator|*
name|pte
expr_stmt|;
name|pa
operator|=
name|TLBLO_PTE_TO_PA
argument_list|(
name|pbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_is_managed
argument_list|(
name|pa
argument_list|)
operator|&&
name|pte_test
argument_list|(
operator|&
name|pbits
argument_list|,
name|PTE_D
argument_list|)
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&=
operator|~
name|PV_TABLE_MOD
expr_stmt|;
block|}
name|pte_clear
argument_list|(
operator|&
name|pbits
argument_list|,
name|PTE_D
argument_list|)
expr_stmt|;
name|pte_set
argument_list|(
operator|&
name|pbits
argument_list|,
name|PTE_RO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbits
operator|!=
operator|*
name|pte
condition|)
block|{
operator|*
name|pte
operator|=
name|pbits
expr_stmt|;
name|pmap_update_page
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|pbits
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Insert the given physical page (p) at  *	the specified virtual address (v) in the  *	target physical map with the protection requested.  *  *	If specified, the page will be wired down, meaning  *	that the related pte can not be reclaimed.  *  *	NB:  This is the only routine which MAY NOT lazy-evaluate  *	or lose information.  That is, this routine must actually  *	insert this page into the given map NOW.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|access
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|,
name|opa
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pt_entry_t
name|origpte
decl_stmt|,
name|newpte
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_page_t
name|mpte
decl_stmt|,
name|om
decl_stmt|;
name|pt_entry_t
name|rw
init|=
literal|0
decl_stmt|;
name|va
operator|&=
operator|~
name|PAGE_MASK
expr_stmt|;
name|KASSERT
argument_list|(
name|va
operator|<=
name|VM_MAX_KERNEL_ADDRESS
argument_list|,
operator|(
literal|"pmap_enter: toobig"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
operator|(
name|VPO_UNMANAGED
operator||
name|VPO_BUSY
operator|)
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_enter: page %p is not busy"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|NULL
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 	 * In the case that a page table page is not resident, we are 	 * creating it here. 	 */
if|if
condition|(
name|va
operator|<
name|VM_MAXUSER_ADDRESS
condition|)
block|{
name|mpte
operator|=
name|pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * Page Directory table entry not valid, we need a new PT page 	 */
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_enter: invalid page directory, pdir=%p, va=%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pmap
operator|->
name|pm_segtab
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va
argument_list|)
expr_stmt|;
block|}
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|om
operator|=
name|NULL
expr_stmt|;
name|origpte
operator|=
operator|*
name|pte
expr_stmt|;
name|opa
operator|=
name|TLBLO_PTE_TO_PA
argument_list|(
name|origpte
argument_list|)
expr_stmt|;
comment|/* 	 * Mapping has not changed, must be protection or wiring change. 	 */
if|if
condition|(
name|pte_test
argument_list|(
operator|&
name|origpte
argument_list|,
name|PTE_V
argument_list|)
operator|&&
name|opa
operator|==
name|pa
condition|)
block|{
comment|/* 		 * Wiring change, just update stats. We don't worry about 		 * wiring PT pages as they remain resident as long as there 		 * are valid mappings in them. Hence, if a user page is 		 * wired, the PT page will be also. 		 */
if|if
condition|(
name|wired
operator|&&
operator|!
name|pte_test
argument_list|(
operator|&
name|origpte
argument_list|,
name|PTE_W
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wired
operator|&&
name|pte_test
argument_list|(
operator|&
name|origpte
argument_list|,
name|PTE_W
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|pte_test
argument_list|(
operator|&
name|origpte
argument_list|,
name|PTE_D
operator||
name|PTE_RO
argument_list|)
argument_list|,
operator|(
literal|"%s: modified page not writable: va: %p, pte: %#jx"
operator|,
name|__func__
operator|,
operator|(
name|void
operator|*
operator|)
name|va
operator|,
operator|(
name|uintmax_t
operator|)
name|origpte
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Remove extra pte reference 		 */
if|if
condition|(
name|mpte
condition|)
name|mpte
operator|->
name|wire_count
operator|--
expr_stmt|;
if|if
condition|(
name|page_is_managed
argument_list|(
name|opa
argument_list|)
condition|)
block|{
name|om
operator|=
name|m
expr_stmt|;
block|}
goto|goto
name|validate
goto|;
block|}
name|pv
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Mapping has changed, invalidate old range and fall through to 	 * handle validating new mapping. 	 */
if|if
condition|(
name|opa
condition|)
block|{
if|if
condition|(
name|pte_test
argument_list|(
operator|&
name|origpte
argument_list|,
name|PTE_W
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
if|if
condition|(
name|page_is_managed
argument_list|(
name|opa
argument_list|)
condition|)
block|{
name|om
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|opa
argument_list|)
expr_stmt|;
name|pv
operator|=
name|pmap_pvh_remove
argument_list|(
operator|&
name|om
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mpte
operator|!=
name|NULL
condition|)
block|{
name|mpte
operator|->
name|wire_count
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|mpte
operator|->
name|wire_count
operator|>
literal|0
argument_list|,
operator|(
literal|"pmap_enter: missing reference to page table page,"
literal|" va: %p"
operator|,
operator|(
name|void
operator|*
operator|)
name|va
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
comment|/* 	 * Enter on the PV list if part of our managed memory. Note that we 	 * raise IPL while manipulating pv_table since pmap_enter can be 	 * called at interrupt time. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|va
operator|<
name|kmi
operator|.
name|clean_sva
operator|||
name|va
operator|>=
name|kmi
operator|.
name|clean_eva
argument_list|,
operator|(
literal|"pmap_enter: managed mapping within the clean submap"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|==
name|NULL
condition|)
name|pv
operator|=
name|get_pv_entry
argument_list|(
name|pmap
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pv
operator|!=
name|NULL
condition|)
name|free_pv_entry
argument_list|(
name|pmap
argument_list|,
name|pv
argument_list|)
expr_stmt|;
comment|/* 	 * Increment counters 	 */
if|if
condition|(
name|wired
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|validate
label|:
if|if
condition|(
operator|(
name|access
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
condition|)
name|m
operator|->
name|md
operator|.
name|pv_flags
operator||=
name|PV_TABLE_MOD
operator||
name|PV_TABLE_REF
expr_stmt|;
name|rw
operator|=
name|init_pte_prot
argument_list|(
name|va
argument_list|,
name|m
argument_list|,
name|prot
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAP_DEBUG
name|printf
argument_list|(
literal|"pmap_enter:  va: %p -> pa: %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Now validate mapping with desired protection/wiring. 	 */
name|newpte
operator|=
name|TLBLO_PA_TO_PFN
argument_list|(
name|pa
argument_list|)
operator||
name|rw
operator||
name|PTE_V
expr_stmt|;
if|if
condition|(
name|is_cacheable_mem
argument_list|(
name|pa
argument_list|)
condition|)
name|newpte
operator||=
name|PTE_C_CACHE
expr_stmt|;
else|else
name|newpte
operator||=
name|PTE_C_UNCACHED
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|newpte
operator||=
name|PTE_W
expr_stmt|;
if|if
condition|(
name|is_kernel_pmap
argument_list|(
name|pmap
argument_list|)
condition|)
name|newpte
operator||=
name|PTE_G
expr_stmt|;
comment|/* 	 * if the mapping or permission bits are different, we need to 	 * update the pte. 	 */
if|if
condition|(
name|origpte
operator|!=
name|newpte
condition|)
block|{
if|if
condition|(
name|pte_test
argument_list|(
operator|&
name|origpte
argument_list|,
name|PTE_V
argument_list|)
condition|)
block|{
operator|*
name|pte
operator|=
name|newpte
expr_stmt|;
if|if
condition|(
name|page_is_managed
argument_list|(
name|opa
argument_list|)
operator|&&
operator|(
name|opa
operator|!=
name|pa
operator|)
condition|)
block|{
if|if
condition|(
name|om
operator|->
name|md
operator|.
name|pv_flags
operator|&
name|PV_TABLE_REF
condition|)
name|vm_page_aflag_set
argument_list|(
name|om
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
name|om
operator|->
name|md
operator|.
name|pv_flags
operator|&=
operator|~
operator|(
name|PV_TABLE_REF
operator||
name|PV_TABLE_MOD
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|pte_test
argument_list|(
operator|&
name|origpte
argument_list|,
name|PTE_D
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
name|pte_test
argument_list|(
operator|&
name|origpte
argument_list|,
name|PTE_RO
argument_list|)
argument_list|,
operator|(
literal|"pmap_enter: modified page not writable:"
literal|" va: %p, pte: %#jx"
operator|,
operator|(
name|void
operator|*
operator|)
name|va
operator|,
operator|(
name|uintmax_t
operator|)
name|origpte
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_is_managed
argument_list|(
name|opa
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|om
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|page_is_managed
argument_list|(
name|opa
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|om
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|om
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pte
operator|=
name|newpte
expr_stmt|;
block|}
block|}
name|pmap_update_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|newpte
argument_list|)
expr_stmt|;
comment|/* 	 * Sync I& D caches for executable pages.  Do this only if the 	 * target pmap belongs to the current process.  Otherwise, an 	 * unresolvable TLB miss may occur. 	 */
if|if
condition|(
operator|!
name|is_kernel_pmap
argument_list|(
name|pmap
argument_list|)
operator|&&
operator|(
name|pmap
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|)
operator|&&
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
condition|)
block|{
name|mips_icache_sync_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|mips_dcache_wbinv_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this code makes some *MAJOR* assumptions:  * 1. Current pmap& pmap exists.  * 2. Not wired.  * 3. Read access.  * 4. No page table pages.  * but is *MUCH* faster than pmap_enter...  */
end_comment

begin_function
name|void
name|pmap_enter_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pmap_enter_quick_locked
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|pmap_enter_quick_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|KASSERT
argument_list|(
name|va
operator|<
name|kmi
operator|.
name|clean_sva
operator|||
name|va
operator|>=
name|kmi
operator|.
name|clean_eva
operator|||
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_enter_quick_locked: managed mapping within the clean submap"
operator|)
argument_list|)
expr_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * In the case that a page table page is not resident, we are 	 * creating it here. 	 */
if|if
condition|(
name|va
operator|<
name|VM_MAXUSER_ADDRESS
condition|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|unsigned
name|ptepindex
decl_stmt|;
comment|/* 		 * Calculate pagetable page index 		 */
name|ptepindex
operator|=
name|pmap_pde_pindex
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpte
operator|&&
operator|(
name|mpte
operator|->
name|pindex
operator|==
name|ptepindex
operator|)
condition|)
block|{
name|mpte
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Get the page directory entry 			 */
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 			 * If the page table page is mapped, we just 			 * increment the hold count, and activate it. 			 */
if|if
condition|(
name|pde
operator|&&
operator|*
name|pde
operator|!=
literal|0
condition|)
block|{
name|mpte
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|MIPS_DIRECT_TO_PHYS
argument_list|(
operator|*
name|pde
argument_list|)
argument_list|)
expr_stmt|;
name|mpte
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|mpte
operator|=
name|_pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|ptepindex
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpte
operator|==
name|NULL
condition|)
return|return
operator|(
name|mpte
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
name|mpte
operator|=
name|NULL
expr_stmt|;
block|}
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte_test
argument_list|(
name|pte
argument_list|,
name|PTE_V
argument_list|)
condition|)
block|{
if|if
condition|(
name|mpte
operator|!=
name|NULL
condition|)
block|{
name|mpte
operator|->
name|wire_count
operator|--
expr_stmt|;
name|mpte
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|mpte
operator|)
return|;
block|}
comment|/* 	 * Enter on the PV list if part of our managed memory. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
operator|&&
operator|!
name|pmap_try_insert_pv_entry
argument_list|(
name|pmap
argument_list|,
name|mpte
argument_list|,
name|va
argument_list|,
name|m
argument_list|)
condition|)
block|{
if|if
condition|(
name|mpte
operator|!=
name|NULL
condition|)
block|{
name|pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|mpte
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|mpte
operator|)
return|;
block|}
comment|/* 	 * Increment counters 	 */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Now validate mapping with RO protection 	 */
operator|*
name|pte
operator|=
name|TLBLO_PA_TO_PFN
argument_list|(
name|pa
argument_list|)
operator||
name|PTE_V
expr_stmt|;
if|if
condition|(
name|is_cacheable_mem
argument_list|(
name|pa
argument_list|)
condition|)
operator|*
name|pte
operator||=
name|PTE_C_CACHE
expr_stmt|;
else|else
operator|*
name|pte
operator||=
name|PTE_C_UNCACHED
expr_stmt|;
if|if
condition|(
name|is_kernel_pmap
argument_list|(
name|pmap
argument_list|)
condition|)
operator|*
name|pte
operator||=
name|PTE_G
expr_stmt|;
else|else
block|{
operator|*
name|pte
operator||=
name|PTE_RO
expr_stmt|;
comment|/* 		 * Sync I& D caches.  Do this only if the target pmap 		 * belongs to the current process.  Otherwise, an 		 * unresolvable TLB miss may occur. */
if|if
condition|(
name|pmap
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
condition|)
block|{
name|va
operator|&=
operator|~
name|PAGE_MASK
expr_stmt|;
name|mips_icache_sync_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|mips_dcache_wbinv_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mpte
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a temporary mapping for a physical address.  This is only intended  * to be used for panic dumps.  *  * Use XKPHYS for 64 bit, and KSEG0 where possible for 32 bit.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_kenter_temporary
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: ERROR!!! More than one page of virtual address mapping not supported\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|MIPS_DIRECT_MAPPABLE
argument_list|(
name|pa
argument_list|)
condition|)
block|{
name|va
operator|=
name|MIPS_PHYS_TO_DIRECT
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|__mips_n64
comment|/* XXX : to be converted to new style */
name|int
name|cpu
decl_stmt|;
name|register_t
name|intr
decl_stmt|;
name|struct
name|local_sysmaps
modifier|*
name|sysm
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|npte
decl_stmt|;
comment|/* If this is used other than for dumps, we may need to leave 		 * interrupts disasbled on return. If crash dumps don't work when 		 * we get to this point, we might want to consider this (leaving things 		 * disabled as a starting point ;-) 	 	 */
name|intr
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|sysm
operator|=
operator|&
name|sysmap_lmem
index|[
name|cpu
index|]
expr_stmt|;
comment|/* Since this is for the debugger, no locks or any other fun */
name|npte
operator|=
name|TLBLO_PA_TO_PFN
argument_list|(
name|pa
argument_list|)
operator||
name|PTE_D
operator||
name|PTE_V
operator||
name|PTE_G
operator||
name|PTE_W
operator||
name|PTE_C_CACHE
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|sysm
operator|->
name|base
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
name|npte
expr_stmt|;
name|sysm
operator|->
name|valid1
operator|=
literal|1
expr_stmt|;
name|pmap_update_page
argument_list|(
name|kernel_pmap
argument_list|,
name|sysm
operator|->
name|base
argument_list|,
name|npte
argument_list|)
expr_stmt|;
name|va
operator|=
name|sysm
operator|->
name|base
expr_stmt|;
name|intr_restore
argument_list|(
name|intr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|va
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_kenter_temporary_free
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|__mips_n64
comment|/* XXX : to be converted to new style */
name|int
name|cpu
decl_stmt|;
name|register_t
name|intr
decl_stmt|;
name|struct
name|local_sysmaps
modifier|*
name|sysm
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|MIPS_DIRECT_MAPPABLE
argument_list|(
name|pa
argument_list|)
condition|)
block|{
comment|/* nothing to do for this case */
return|return;
block|}
ifndef|#
directive|ifndef
name|__mips_n64
comment|/* XXX : to be converted to new style */
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|sysm
operator|=
operator|&
name|sysmap_lmem
index|[
name|cpu
index|]
expr_stmt|;
if|if
condition|(
name|sysm
operator|->
name|valid1
condition|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|intr
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|sysm
operator|->
name|base
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
name|PTE_G
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|kernel_pmap
argument_list|,
name|sysm
operator|->
name|base
argument_list|)
expr_stmt|;
name|intr_restore
argument_list|(
name|intr
argument_list|)
expr_stmt|;
name|sysm
operator|->
name|valid1
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Maps a sequence of resident pages belonging to the same object.  * The sequence begins with the given page m_start.  This page is  * mapped at the given virtual address start.  Each subsequent page is  * mapped at a virtual address that is offset from start by the same  * amount as the page is offset from m_start within the object.  The  * last page in the sequence is the page with the largest offset from  * m_start that can be mapped at a virtual address less than the given  * virtual address end.  Not every virtual page between start and end  * is mapped; only those for which a resident page exists with the  * corresponding offset from m_start are mapped.  */
end_comment

begin_function
name|void
name|pmap_enter_object
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_page_t
name|m_start
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|,
name|mpte
decl_stmt|;
name|vm_pindex_t
name|diff
decl_stmt|,
name|psize
decl_stmt|;
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|m_start
operator|->
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|psize
operator|=
name|atop
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
name|m_start
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|diff
operator|=
name|m
operator|->
name|pindex
operator|-
name|m_start
operator|->
name|pindex
operator|)
operator|<
name|psize
condition|)
block|{
name|mpte
operator|=
name|pmap_enter_quick_locked
argument_list|(
name|pmap
argument_list|,
name|start
operator|+
name|ptoa
argument_list|(
name|diff
argument_list|)
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|mpte
argument_list|)
expr_stmt|;
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_object_init_pt preloads the ptes for a given object  * into the specified pmap.  This eliminates the blast of soft  * faults on process startup and immediately after an mmap.  */
end_comment

begin_function
name|void
name|pmap_object_init_pt
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
operator|||
name|object
operator|->
name|type
operator|==
name|OBJT_SG
argument_list|,
operator|(
literal|"pmap_object_init_pt: non-device object"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_change_wiring  *	Function:	Change the wiring attribute for a map/virtual-address  *			pair.  *	In/out conditions:  *			The mapping must already exist in the pmap.  */
end_comment

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|wired
operator|&&
operator|!
name|pte_test
argument_list|(
name|pte
argument_list|,
name|PTE_W
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wired
operator|&&
name|pte_test
argument_list|(
name|pte
argument_list|,
name|PTE_W
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
comment|/* 	 * Wiring is not a hardware characteristic so there is no need to 	 * invalidate TLB. 	 */
if|if
condition|(
name|wired
condition|)
name|pte_set
argument_list|(
name|pte
argument_list|,
name|PTE_W
argument_list|)
expr_stmt|;
else|else
name|pte_clear
argument_list|(
name|pte
argument_list|,
name|PTE_W
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Copy the range specified by src_addr/len  *	from the source map to the range dst_addr/len  *	in the destination map.  *  *	This routine is only advisory and need not do anything.  */
end_comment

begin_function
name|void
name|pmap_copy
parameter_list|(
name|pmap_t
name|dst_pmap
parameter_list|,
name|pmap_t
name|src_pmap
parameter_list|,
name|vm_offset_t
name|dst_addr
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|vm_offset_t
name|src_addr
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  *	pmap_zero_page zeros the specified hardware page by mapping  *	the page into KVM and using bzero to clear its contents.  *  * 	Use XKPHYS for 64 bit, and KSEG0 where possible for 32 bit.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|vm_paddr_t
name|phys
init|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|MIPS_DIRECT_MAPPABLE
argument_list|(
name|phys
argument_list|)
condition|)
block|{
name|va
operator|=
name|MIPS_PHYS_TO_DIRECT
argument_list|(
name|phys
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|mips_dcache_wbinv_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|va
operator|=
name|pmap_lmem_map1
argument_list|(
name|phys
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|mips_dcache_wbinv_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pmap_lmem_unmap
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_area zeros the specified hardware page by mapping  *	the page into KVM and using bzero to clear its contents.  *  *	off and size may not cover an area beyond a single hardware page.  */
end_comment

begin_function
name|void
name|pmap_zero_page_area
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|vm_paddr_t
name|phys
init|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|MIPS_DIRECT_MAPPABLE
argument_list|(
name|phys
argument_list|)
condition|)
block|{
name|va
operator|=
name|MIPS_PHYS_TO_DIRECT
argument_list|(
name|phys
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|caddr_t
operator|)
name|va
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mips_dcache_wbinv_range
argument_list|(
name|va
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|va
operator|=
name|pmap_lmem_map1
argument_list|(
name|phys
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|va
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mips_dcache_wbinv_range
argument_list|(
name|va
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pmap_lmem_unmap
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pmap_zero_page_idle
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|vm_paddr_t
name|phys
init|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|MIPS_DIRECT_MAPPABLE
argument_list|(
name|phys
argument_list|)
condition|)
block|{
name|va
operator|=
name|MIPS_PHYS_TO_DIRECT
argument_list|(
name|phys
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|mips_dcache_wbinv_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|va
operator|=
name|pmap_lmem_map1
argument_list|(
name|phys
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|mips_dcache_wbinv_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pmap_lmem_unmap
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	pmap_copy_page copies the specified (machine independent)  *	page by mapping the page into virtual memory and using  *	bcopy to copy the page, one machine dependent page at a  *	time.  *  * 	Use XKPHYS for 64 bit, and KSEG0 where possible for 32 bit.  */
end_comment

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|vm_page_t
name|src
parameter_list|,
name|vm_page_t
name|dst
parameter_list|)
block|{
name|vm_offset_t
name|va_src
decl_stmt|,
name|va_dst
decl_stmt|;
name|vm_paddr_t
name|phys_src
init|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|vm_paddr_t
name|phys_dst
init|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|MIPS_DIRECT_MAPPABLE
argument_list|(
name|phys_src
argument_list|)
operator|&&
name|MIPS_DIRECT_MAPPABLE
argument_list|(
name|phys_dst
argument_list|)
condition|)
block|{
comment|/* easy case, all can be accessed via KSEG0 */
comment|/* 		 * Flush all caches for VA that are mapped to this page 		 * to make sure that data in SDRAM is up to date 		 */
name|pmap_flush_pvcache
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|mips_dcache_wbinv_range_index
argument_list|(
name|MIPS_PHYS_TO_DIRECT
argument_list|(
name|phys_dst
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|va_src
operator|=
name|MIPS_PHYS_TO_DIRECT
argument_list|(
name|phys_src
argument_list|)
expr_stmt|;
name|va_dst
operator|=
name|MIPS_PHYS_TO_DIRECT
argument_list|(
name|phys_dst
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|va_src
argument_list|,
operator|(
name|caddr_t
operator|)
name|va_dst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|mips_dcache_wbinv_range
argument_list|(
name|va_dst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|va_src
operator|=
name|pmap_lmem_map2
argument_list|(
name|phys_src
argument_list|,
name|phys_dst
argument_list|)
expr_stmt|;
name|va_dst
operator|=
name|va_src
operator|+
name|PAGE_SIZE
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|va_src
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va_dst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|mips_dcache_wbinv_range
argument_list|(
name|va_dst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pmap_lmem_unmap
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Returns true if the pmap's pv is one of the first  * 16 pvs linked to from this page.  This count may  * be changed upwards or downwards in the future; it  * is only necessary that true be returned for a small  * subset of pmaps for proper page aging.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_exists_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|loops
init|=
literal|0
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_page_exists_quick: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
operator|==
name|pmap
condition|)
block|{
name|rv
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|loops
operator|++
expr_stmt|;
if|if
condition|(
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove all pages from specified address space  * this aids process exit speeds.  Also, this code  * is special cased for current process only, but  * can have the more generic (and slightly slower)  * mode enabled.  This is much faster than pmap_remove  * in the case of running down an entire address space.  */
end_comment

begin_function
name|void
name|pmap_remove_pages
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|,
modifier|*
name|npc
decl_stmt|;
name|u_long
name|inuse
decl_stmt|,
name|bitmask
decl_stmt|;
name|int
name|allfree
decl_stmt|,
name|bit
decl_stmt|,
name|field
decl_stmt|,
name|idx
decl_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|vmspace_pmap
argument_list|(
name|curthread
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"warning: pmap_remove_pages called with non-current pmap\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|pc
argument_list|,
argument|&pmap->pm_pvchunk
argument_list|,
argument|pc_list
argument_list|,
argument|npc
argument_list|)
block|{
name|allfree
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
block|{
name|inuse
operator|=
operator|~
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|&
name|pc_freemask
index|[
name|field
index|]
expr_stmt|;
while|while
condition|(
name|inuse
operator|!=
literal|0
condition|)
block|{
name|bit
operator|=
name|ffsl
argument_list|(
name|inuse
argument_list|)
operator|-
literal|1
expr_stmt|;
name|bitmask
operator|=
literal|1UL
operator|<<
name|bit
expr_stmt|;
name|idx
operator|=
name|field
operator|*
sizeof|sizeof
argument_list|(
name|inuse
argument_list|)
operator|*
name|NBBY
operator|+
name|bit
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
name|idx
index|]
expr_stmt|;
name|inuse
operator|&=
operator|~
name|bitmask
expr_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pde
operator|!=
name|NULL
operator|&&
operator|*
name|pde
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_remove_pages: pde"
operator|)
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pde_to_pte
argument_list|(
name|pde
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pte_test
argument_list|(
name|pte
argument_list|,
name|PTE_V
argument_list|)
condition|)
name|panic
argument_list|(
literal|"pmap_remove_pages: bad pte"
argument_list|)
expr_stmt|;
name|tpte
operator|=
operator|*
name|pte
expr_stmt|;
comment|/*  * We cannot remove wired pages from a process' mapping at this time  */
if|if
condition|(
name|pte_test
argument_list|(
operator|&
name|tpte
argument_list|,
name|PTE_W
argument_list|)
condition|)
block|{
name|allfree
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
operator|*
name|pte
operator|=
name|is_kernel_pmap
argument_list|(
name|pmap
argument_list|)
condition|?
name|PTE_G
else|:
literal|0
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TLBLO_PTE_TO_PA
argument_list|(
name|tpte
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_remove_pages: bad tpte %#jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|tpte
operator|)
argument_list|)
expr_stmt|;
comment|/* 				 * Update the vm_page_t clean and reference bits. 				 */
if|if
condition|(
name|pte_test
argument_list|(
operator|&
name|tpte
argument_list|,
name|PTE_D
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Mark free */
name|PV_STAT
argument_list|(
name|pv_entry_frees
operator|++
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|++
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|--
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator||=
name|bitmask
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|*
name|pde
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allfree
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|free_pv_chunk
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
name|pmap_invalidate_all
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_testbit tests bits in pte's  * note that the testbit/changebit routines are inline,  * and a lot of things compile-time evaluate.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|pmap_testbit
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|boolean_t
name|rv
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|rv
operator|=
name|pte_test
argument_list|(
name|pte
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
break|break;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this routine is used to clear dirty bits in ptes  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pmap_changebit
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|bit
parameter_list|,
name|boolean_t
name|setem
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
condition|)
return|return;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
comment|/* 	 * Loop over all current mappings setting/clearing as appropos If 	 * setting RO do we need to clear the VAC? 	 */
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
name|setem
condition|)
block|{
operator|*
name|pte
operator||=
name|bit
expr_stmt|;
name|pmap_update_page
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|*
name|pte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pt_entry_t
name|pbits
init|=
operator|*
name|pte
decl_stmt|;
if|if
condition|(
name|pbits
operator|&
name|bit
condition|)
block|{
if|if
condition|(
name|bit
operator|==
name|PTE_D
condition|)
block|{
if|if
condition|(
name|pbits
operator|&
name|PTE_D
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
operator|(
name|pbits
operator|&
operator|~
name|PTE_D
operator|)
operator||
name|PTE_RO
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pte
operator|=
name|pbits
operator|&
operator|~
name|bit
expr_stmt|;
block|}
name|pmap_update_page
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|*
name|pte
argument_list|)
expr_stmt|;
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|setem
operator|&&
name|bit
operator|==
name|PTE_D
condition|)
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_page_wired_mappings:  *  *	Return the number of managed mappings to the given physical page  *	that are wired.  */
end_comment

begin_function
name|int
name|pmap_page_wired_mappings
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|count
operator|)
return|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte_test
argument_list|(
name|pte
argument_list|,
name|PTE_W
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the write and modified bits in each of the given page's mappings.  */
end_comment

begin_function
name|void
name|pmap_remove_write
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pmap_t
name|pmap
decl_stmt|;
name|pt_entry_t
name|pbits
decl_stmt|,
modifier|*
name|pte
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_remove_write: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not VPO_BUSY, then PGA_WRITEABLE cannot be set by 	 * another thread while the object is locked.  Thus, if PGA_WRITEABLE 	 * is clear, no page table entries need updating. 	 */
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|m
operator|->
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_BUSY
operator|)
operator|==
literal|0
operator|&&
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
operator|&&
name|pte_test
argument_list|(
name|pte
argument_list|,
name|PTE_V
argument_list|)
argument_list|,
operator|(
literal|"page on pv_list has no pte"
operator|)
argument_list|)
expr_stmt|;
name|pbits
operator|=
operator|*
name|pte
expr_stmt|;
if|if
condition|(
name|pte_test
argument_list|(
operator|&
name|pbits
argument_list|,
name|PTE_D
argument_list|)
condition|)
block|{
name|pte_clear
argument_list|(
operator|&
name|pbits
argument_list|,
name|PTE_D
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&=
operator|~
name|PV_TABLE_MOD
expr_stmt|;
block|}
name|pte_set
argument_list|(
operator|&
name|pbits
argument_list|,
name|PTE_RO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbits
operator|!=
operator|*
name|pte
condition|)
block|{
operator|*
name|pte
operator|=
name|pbits
expr_stmt|;
name|pmap_update_page
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pbits
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_ts_referenced:  *  *	Return the count of reference bits for a page, clearing all of them.  */
end_comment

begin_function
name|int
name|pmap_ts_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_ts_referenced: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&
name|PV_TABLE_REF
condition|)
block|{
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&=
operator|~
name|PV_TABLE_REF
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_modified:  *  *	Return whether or not the specified physical page was modified  *	in any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|boolean_t
name|rv
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_is_modified: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not VPO_BUSY, then PGA_WRITEABLE cannot be 	 * concurrently set while the object is locked.  Thus, if PGA_WRITEABLE 	 * is clear, no PTEs can have PTE_D set. 	 */
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|m
operator|->
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_BUSY
operator|)
operator|==
literal|0
operator|&&
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&
name|PV_TABLE_MOD
condition|)
name|rv
operator|=
name|TRUE
expr_stmt|;
else|else
name|rv
operator|=
name|pmap_testbit
argument_list|(
name|m
argument_list|,
name|PTE_D
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* N/C */
end_comment

begin_comment
comment|/*  *	pmap_is_prefaultable:  *  *	Return whether or not the specified virtual address is elgible  *	for prefault.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_prefaultable
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde
operator|!=
name|NULL
operator|&&
operator|*
name|pde
operator|!=
literal|0
condition|)
block|{
name|pte
operator|=
name|pmap_pde_to_pte
argument_list|(
name|pde
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|rv
operator|=
operator|(
operator|*
name|pte
operator|==
literal|0
operator|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Clear the modify bits on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_clear_modify: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|m
operator|->
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_BUSY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_clear_modify: page %p is busy"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not PGA_WRITEABLE, then no PTEs can have PTE_D set. 	 * If the object containing the page is locked and the page is not 	 * VPO_BUSY, then PGA_WRITEABLE cannot be concurrently set. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&
name|PV_TABLE_MOD
condition|)
block|{
name|pmap_changebit
argument_list|(
name|m
argument_list|,
name|PTE_D
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&=
operator|~
name|PV_TABLE_MOD
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_referenced:  *  *	Return whether or not the specified physical page was referenced  *	in any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_is_referenced: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&
name|PV_TABLE_REF
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_clear_reference:  *  *	Clear the reference bit on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_reference
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_clear_reference: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&
name|PV_TABLE_REF
condition|)
block|{
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&=
operator|~
name|PV_TABLE_REF
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Miscellaneous support routines follow  */
end_comment

begin_comment
comment|/*  * Map a set of physical memory pages into the kernel virtual  * address space. Return a pointer to where it is mapped. This  * routine is intended to be used for mapping device memory,  * NOT real memory.  */
end_comment

begin_comment
comment|/*  * Map a set of physical memory pages into the kernel virtual  * address space. Return a pointer to where it is mapped. This  * routine is intended to be used for mapping device memory,  * NOT real memory.  *  * Use XKPHYS uncached for 64 bit, and KSEG1 where possible for 32 bit.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_mapdev
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|,
name|tmpva
decl_stmt|,
name|offset
decl_stmt|;
comment|/*  	 * KSEG1 maps only first 512M of phys address space. For  	 * pa> 0x20000000 we should make proper mapping * using pmap_kenter. 	 */
if|if
condition|(
name|MIPS_DIRECT_MAPPABLE
argument_list|(
name|pa
operator|+
name|size
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|MIPS_PHYS_TO_DIRECT_UNCACHED
argument_list|(
name|pa
argument_list|)
operator|)
return|;
else|else
block|{
name|offset
operator|=
name|pa
operator|&
name|PAGE_MASK
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|size
operator|+
name|offset
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|va
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|va
condition|)
name|panic
argument_list|(
literal|"pmap_mapdev: Couldn't alloc kernel virtual memory"
argument_list|)
expr_stmt|;
name|pa
operator|=
name|trunc_page
argument_list|(
name|pa
argument_list|)
expr_stmt|;
for|for
control|(
name|tmpva
operator|=
name|va
init|;
name|size
operator|>
literal|0
condition|;
control|)
block|{
name|pmap_kenter_attr
argument_list|(
name|tmpva
argument_list|,
name|pa
argument_list|,
name|PTE_C_UNCACHED
argument_list|)
expr_stmt|;
name|size
operator|-=
name|PAGE_SIZE
expr_stmt|;
name|tmpva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|va
operator|+
name|offset
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_unmapdev
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|__mips_n64
name|vm_offset_t
name|base
decl_stmt|,
name|offset
decl_stmt|,
name|tmpva
decl_stmt|;
comment|/* If the address is within KSEG1 then there is nothing to do */
if|if
condition|(
name|va
operator|>=
name|MIPS_KSEG1_START
operator|&&
name|va
operator|<=
name|MIPS_KSEG1_END
condition|)
return|return;
name|base
operator|=
name|trunc_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|offset
operator|=
name|va
operator|&
name|PAGE_MASK
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|size
operator|+
name|offset
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|tmpva
operator|=
name|base
init|;
name|tmpva
operator|<
name|base
operator|+
name|size
condition|;
name|tmpva
operator|+=
name|PAGE_SIZE
control|)
name|pmap_kremove
argument_list|(
name|tmpva
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * perform the pmap work for mincore  */
end_comment

begin_function
name|int
name|pmap_mincore
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_paddr_t
modifier|*
name|locked_pa
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|val
decl_stmt|;
name|boolean_t
name|managed
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|retry
label|:
name|ptep
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|pte
operator|=
operator|(
name|ptep
operator|!=
name|NULL
operator|)
condition|?
operator|*
name|ptep
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|pte_test
argument_list|(
operator|&
name|pte
argument_list|,
name|PTE_V
argument_list|)
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|val
operator|=
name|MINCORE_INCORE
expr_stmt|;
if|if
condition|(
name|pte_test
argument_list|(
operator|&
name|pte
argument_list|,
name|PTE_D
argument_list|)
condition|)
name|val
operator||=
name|MINCORE_MODIFIED
operator||
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
name|pa
operator|=
name|TLBLO_PTE_TO_PA
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|managed
operator|=
name|page_is_managed
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|managed
condition|)
block|{
comment|/* 		 * This may falsely report the given address as 		 * MINCORE_REFERENCED.  Unfortunately, due to the lack of 		 * per-PTE reference information, it is impossible to 		 * determine if the address is MINCORE_REFERENCED.   		 */
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_REFERENCED
operator|)
operator|!=
literal|0
condition|)
name|val
operator||=
name|MINCORE_REFERENCED
operator||
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|MINCORE_MODIFIED_OTHER
operator||
name|MINCORE_REFERENCED_OTHER
operator|)
operator|)
operator|!=
operator|(
name|MINCORE_MODIFIED_OTHER
operator||
name|MINCORE_REFERENCED_OTHER
operator|)
operator|&&
name|managed
condition|)
block|{
comment|/* Ensure that "PHYS_TO_VM_PAGE(pa)->object" doesn't change. */
if|if
condition|(
name|vm_page_pa_tryrelock
argument_list|(
name|pmap
argument_list|,
name|pa
argument_list|,
name|locked_pa
argument_list|)
condition|)
goto|goto
name|retry
goto|;
block|}
else|else
name|out
label|:
name|PA_UNLOCK_COND
argument_list|(
operator|*
name|locked_pa
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_activate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|pmap_t
name|pmap
decl_stmt|,
name|oldpmap
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|u_int
name|cpuid
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|pmap
operator|=
name|vmspace_pmap
argument_list|(
name|p
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|PCPU_GET
argument_list|(
name|curpmap
argument_list|)
expr_stmt|;
name|cpuid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldpmap
condition|)
name|CPU_CLR_ATOMIC
argument_list|(
name|cpuid
argument_list|,
operator|&
name|oldpmap
operator|->
name|pm_active
argument_list|)
expr_stmt|;
name|CPU_SET_ATOMIC
argument_list|(
name|cpuid
argument_list|,
operator|&
name|pmap
operator|->
name|pm_active
argument_list|)
expr_stmt|;
name|pmap_asid_alloc
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|curthread
condition|)
block|{
name|PCPU_SET
argument_list|(
name|segbase
argument_list|,
name|pmap
operator|->
name|pm_segtab
argument_list|)
expr_stmt|;
name|mips_wr_entryhi
argument_list|(
name|pmap
operator|->
name|pm_asid
index|[
name|cpuid
index|]
operator|.
name|asid
argument_list|)
expr_stmt|;
block|}
name|PCPU_SET
argument_list|(
name|curpmap
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_sync_icache
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|sz
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  *	Increase the starting virtual address of the given mapping if a  *	different alignment might result in more superpage mappings.  */
end_comment

begin_function
name|void
name|pmap_align_superpage
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_offset_t
modifier|*
name|addr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_offset_t
name|superpage_offset
decl_stmt|;
if|if
condition|(
name|size
operator|<
name|NBSEG
condition|)
return|return;
if|if
condition|(
name|object
operator|!=
name|NULL
operator|&&
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_COLORED
operator|)
operator|!=
literal|0
condition|)
name|offset
operator|+=
name|ptoa
argument_list|(
name|object
operator|->
name|pg_color
argument_list|)
expr_stmt|;
name|superpage_offset
operator|=
name|offset
operator|&
name|SEGMASK
expr_stmt|;
if|if
condition|(
name|size
operator|-
operator|(
operator|(
name|NBSEG
operator|-
name|superpage_offset
operator|)
operator|&
name|SEGMASK
operator|)
operator|<
name|NBSEG
operator|||
operator|(
operator|*
name|addr
operator|&
name|SEGMASK
operator|)
operator|==
name|superpage_offset
condition|)
return|return;
if|if
condition|(
operator|(
operator|*
name|addr
operator|&
name|SEGMASK
operator|)
operator|<
name|superpage_offset
condition|)
operator|*
name|addr
operator|=
operator|(
operator|*
name|addr
operator|&
operator|~
name|SEGMASK
operator|)
operator|+
name|superpage_offset
expr_stmt|;
else|else
operator|*
name|addr
operator|=
operator|(
operator|(
operator|*
name|addr
operator|+
name|SEGMASK
operator|)
operator|&
operator|~
name|SEGMASK
operator|)
operator|+
name|superpage_offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 	Increase the starting virtual address of the given mapping so  * 	that it is aligned to not be the second page in a TLB entry.  * 	This routine assumes that the length is appropriately-sized so  * 	that the allocation does not share a TLB entry at all if required.  */
end_comment

begin_function
name|void
name|pmap_align_tlb
parameter_list|(
name|vm_offset_t
modifier|*
name|addr
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|*
name|addr
operator|&
name|PAGE_SIZE
operator|)
operator|==
literal|0
condition|)
return|return;
operator|*
name|addr
operator|+=
name|PAGE_SIZE
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|ptable
argument_list|,
argument|ddb_pid_dump
argument_list|)
end_macro

begin_block
block|{
name|pmap_t
name|pmap
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|NULL
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
if|if
condition|(
name|have_addr
condition|)
block|{
name|td
operator|=
name|db_lookup_thread
argument_list|(
name|addr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
block|{
name|db_printf
argument_list|(
literal|"Invalid pid or tid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_vmspace
operator|==
name|NULL
condition|)
block|{
name|db_printf
argument_list|(
literal|"No vmspace for process"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pmap
operator|=
name|vmspace_pmap
argument_list|(
name|p
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
block|}
else|else
name|pmap
operator|=
name|kernel_pmap
expr_stmt|;
name|db_printf
argument_list|(
literal|"pmap:%p segtab:%p asid:%x generation:%x\n"
argument_list|,
name|pmap
argument_list|,
name|pmap
operator|->
name|pm_segtab
argument_list|,
name|pmap
operator|->
name|pm_asid
index|[
literal|0
index|]
operator|.
name|asid
argument_list|,
name|pmap
operator|->
name|pm_asid
index|[
literal|0
index|]
operator|.
name|gen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPDEPG
condition|;
name|i
operator|++
control|)
block|{
name|pd_entry_t
modifier|*
name|pdpe
decl_stmt|;
name|pt_entry_t
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
name|pte
decl_stmt|;
name|pdpe
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|pmap
operator|->
name|pm_segtab
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pdpe
operator|==
name|NULL
condition|)
continue|continue;
name|db_printf
argument_list|(
literal|"[%4d] %p\n"
argument_list|,
name|i
argument_list|,
name|pdpe
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__mips_n64
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NPDEPG
condition|;
name|j
operator|++
control|)
block|{
name|pde
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|pdpe
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|pde
operator|==
name|NULL
condition|)
continue|continue;
name|db_printf
argument_list|(
literal|"\t[%4d] %p\n"
argument_list|,
name|j
argument_list|,
name|pde
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|j
operator|=
literal|0
expr_stmt|;
name|pde
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|pdpe
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NPTEPG
condition|;
name|k
operator|++
control|)
block|{
name|pte
operator|=
name|pde
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|pte
operator|==
literal|0
operator|||
operator|!
name|pte_test
argument_list|(
operator|&
name|pte
argument_list|,
name|PTE_V
argument_list|)
condition|)
continue|continue;
name|pa
operator|=
name|TLBLO_PTE_TO_PA
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|va
operator|=
operator|(
operator|(
name|u_long
operator|)
name|i
operator|<<
name|SEGSHIFT
operator|)
operator||
operator|(
name|j
operator|<<
name|PDRSHIFT
operator|)
operator||
operator|(
name|k
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\t\t[%04d] va: %p pte: %8jx pa:%jx\n"
argument_list|,
name|k
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pte
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pa
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
specifier|static
name|void
name|pads
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
function_decl|;
name|void
name|pmap_pvdump
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|)
function_decl|;
comment|/* print address space of pmap*/
specifier|static
name|void
name|pads
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
name|unsigned
name|va
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
if|if
condition|(
name|pm
operator|==
name|kernel_pmap
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPTEPG
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pm
operator|->
name|pm_segtab
index|[
name|i
index|]
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NPTEPG
condition|;
name|j
operator|++
control|)
block|{
name|va
operator|=
operator|(
name|i
operator|<<
name|SEGSHIFT
operator|)
operator|+
operator|(
name|j
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|kernel_pmap
operator|&&
name|va
operator|<
name|KERNBASE
condition|)
continue|continue;
if|if
condition|(
name|pm
operator|!=
name|kernel_pmap
operator|&&
name|va
operator|>=
name|VM_MAXUSER_ADDRESS
condition|)
continue|continue;
name|ptep
operator|=
name|pmap_pte
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte_test
argument_list|(
name|ptep
argument_list|,
name|PTE_V
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%x:%x "
argument_list|,
name|va
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|ptep
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|pmap_pvdump
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|)
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|printf
argument_list|(
literal|"pa %x"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_list
argument_list|)
control|)
block|{
name|printf
argument_list|(
literal|" -> pmap %p, va %x"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|pads
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
comment|/* N/C */
endif|#
directive|endif
comment|/*  * Allocate TLB address space tag (called ASID or TLBPID) and return it.  * It takes almost as much or more time to search the TLB for a  * specific ASID and flush those entries as it does to flush the entire TLB.  * Therefore, when we allocate a new ASID, we just take the next number. When  * we run out of numbers, we flush the TLB, increment the generation count  * and start over. ASID zero is reserved for kernel use.  */
specifier|static
name|void
name|pmap_asid_alloc
parameter_list|(
name|pmap
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
block|{
if|if
condition|(
name|pmap
operator|->
name|pm_asid
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|.
name|asid
operator|!=
name|PMAP_ASID_RESERVED
operator|&&
name|pmap
operator|->
name|pm_asid
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|.
name|gen
operator|==
name|PCPU_GET
argument_list|(
name|asid_generation
argument_list|)
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
name|PCPU_GET
argument_list|(
name|next_asid
argument_list|)
operator|==
name|pmap_max_asid
condition|)
block|{
name|tlb_invalidate_all_user
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|asid_generation
argument_list|,
operator|(
name|PCPU_GET
argument_list|(
name|asid_generation
argument_list|)
operator|+
literal|1
operator|)
operator|&
name|ASIDGEN_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCPU_GET
argument_list|(
name|asid_generation
argument_list|)
operator|==
literal|0
condition|)
block|{
name|PCPU_SET
argument_list|(
name|asid_generation
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|PCPU_SET
argument_list|(
name|next_asid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 0 means invalid */
block|}
name|pmap
operator|->
name|pm_asid
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|.
name|asid
operator|=
name|PCPU_GET
argument_list|(
name|next_asid
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_asid
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|.
name|gen
operator|=
name|PCPU_GET
argument_list|(
name|asid_generation
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|next_asid
argument_list|,
name|PCPU_GET
argument_list|(
name|next_asid
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|page_is_managed
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|vm_offset_t
name|pgnum
init|=
name|atop
argument_list|(
name|pa
argument_list|)
decl_stmt|;
if|if
condition|(
name|pgnum
operator|>=
name|first_page
condition|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|pt_entry_t
name|init_pte_prot
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|pt_entry_t
name|rw
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
condition|)
name|rw
operator|=
name|PTE_V
operator||
name|PTE_RO
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|md
operator|.
name|pv_flags
operator|&
name|PV_TABLE_MOD
operator|)
operator|!=
literal|0
condition|)
name|rw
operator|=
name|PTE_V
operator||
name|PTE_D
expr_stmt|;
else|else
name|rw
operator|=
name|PTE_V
expr_stmt|;
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Needn't emulate a modified bit for unmanaged pages. */
name|rw
operator|=
name|PTE_V
operator||
name|PTE_D
expr_stmt|;
return|return
operator|(
name|rw
operator|)
return|;
block|}
comment|/*  * pmap_emulate_modified : do dirty bit emulation  *  * On SMP, update just the local TLB, other CPUs will update their  * TLBs from PTE lazily, if they get the exception.  * Returns 0 in case of sucess, 1 if the page is read only and we  * need to fault.  */
name|int
name|pmap_emulate_modified
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_emulate_modified: can't find PTE"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* It is possible that some other CPU changed m-bit */
if|if
condition|(
operator|!
name|pte_test
argument_list|(
name|pte
argument_list|,
name|PTE_V
argument_list|)
operator|||
name|pte_test
argument_list|(
name|pte
argument_list|,
name|PTE_D
argument_list|)
condition|)
block|{
name|tlb_update
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
operator|*
name|pte
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|pte_test
argument_list|(
name|pte
argument_list|,
name|PTE_V
argument_list|)
operator|||
name|pte_test
argument_list|(
name|pte
argument_list|,
name|PTE_D
argument_list|)
condition|)
name|panic
argument_list|(
literal|"pmap_emulate_modified: invalid pte"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pte_test
argument_list|(
name|pte
argument_list|,
name|PTE_RO
argument_list|)
condition|)
block|{
comment|/* write to read only page in the kernel */
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|pte_set
argument_list|(
name|pte
argument_list|,
name|PTE_D
argument_list|)
expr_stmt|;
name|tlb_update
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
operator|*
name|pte
argument_list|)
expr_stmt|;
name|pa
operator|=
name|TLBLO_PTE_TO_PA
argument_list|(
operator|*
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page_is_managed
argument_list|(
name|pa
argument_list|)
condition|)
name|panic
argument_list|(
literal|"pmap_emulate_modified: unmanaged page"
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_flags
operator||=
operator|(
name|PV_TABLE_REF
operator||
name|PV_TABLE_MOD
operator|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  *	Routine:	pmap_kextract  *	Function:  *		Extract the physical page address associated  *		virtual address.  */
name|vm_paddr_t
name|pmap_kextract
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|int
name|mapped
decl_stmt|;
comment|/* 	 * First, the direct-mapped regions. 	 */
if|#
directive|if
name|defined
argument_list|(
name|__mips_n64
argument_list|)
if|if
condition|(
name|va
operator|>=
name|MIPS_XKPHYS_START
operator|&&
name|va
operator|<
name|MIPS_XKPHYS_END
condition|)
return|return
operator|(
name|MIPS_XKPHYS_TO_PHYS
argument_list|(
name|va
argument_list|)
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|va
operator|>=
name|MIPS_KSEG0_START
operator|&&
name|va
operator|<
name|MIPS_KSEG0_END
condition|)
return|return
operator|(
name|MIPS_KSEG0_TO_PHYS
argument_list|(
name|va
argument_list|)
operator|)
return|;
if|if
condition|(
name|va
operator|>=
name|MIPS_KSEG1_START
operator|&&
name|va
operator|<
name|MIPS_KSEG1_END
condition|)
return|return
operator|(
name|MIPS_KSEG1_TO_PHYS
argument_list|(
name|va
argument_list|)
operator|)
return|;
comment|/* 	 * User virtual addresses. 	 */
if|if
condition|(
name|va
operator|<
name|VM_MAXUSER_ADDRESS
condition|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
if|if
condition|(
name|curproc
operator|&&
name|curproc
operator|->
name|p_vmspace
condition|)
block|{
name|ptep
operator|=
name|pmap_pte
argument_list|(
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptep
condition|)
block|{
return|return
operator|(
name|TLBLO_PTE_TO_PA
argument_list|(
operator|*
name|ptep
argument_list|)
operator||
operator|(
name|va
operator|&
name|PAGE_MASK
operator|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Should be kernel virtual here, otherwise fail 	 */
name|mapped
operator|=
operator|(
name|va
operator|>=
name|MIPS_KSEG2_START
operator|||
name|va
operator|<
name|MIPS_KSEG2_END
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__mips_n64
argument_list|)
name|mapped
operator|=
name|mapped
operator|||
operator|(
name|va
operator|>=
name|MIPS_XKSEG_START
operator|||
name|va
operator|<
name|MIPS_XKSEG_END
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Kernel virtual. 	 */
if|if
condition|(
name|mapped
condition|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
comment|/* Is the kernel pmap initialized? */
if|if
condition|(
operator|!
name|CPU_EMPTY
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_active
argument_list|)
condition|)
block|{
comment|/* It's inside the virtual address range */
name|ptep
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptep
condition|)
block|{
return|return
operator|(
name|TLBLO_PTE_TO_PA
argument_list|(
operator|*
name|ptep
argument_list|)
operator||
operator|(
name|va
operator|&
name|PAGE_MASK
operator|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"%s for unknown address space %p."
argument_list|,
name|__func__
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va
argument_list|)
expr_stmt|;
block|}
name|void
name|pmap_flush_pvcache
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_list
argument_list|)
control|)
block|{
name|mips_dcache_wbinv_range_index
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

end_unit

