begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004-2005, Juniper Networks, Inc.  * All rights reserved.  *  *	JNPR: db_trace.c,v 1.8 2007/08/09 11:23:32 katta  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/stack.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<machine/db_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/mips_opcode.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/trap.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_decl_stmt
specifier|extern
name|char
name|_locore
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|_locoreEnd
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|edata
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A function using a stack frame has the following instruction as the first  * one: addiu sp,sp,-<frame_size>  *  * We make use of this to detect starting address of a function. This works  * better than using 'j ra' instruction to signify end of the previous  * function (for e.g. functions like boot() or panic() do not actually  * emit a 'j ra' instruction).  *  * XXX the abi does not require that the addiu instruction be the first one.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_START_OF_FUNCTION
parameter_list|(
name|ins
parameter_list|)
value|(((ins)& 0xffff8000) == 0x27bd8000)
end_define

begin_comment
comment|/*  * MIPS ABI 3.0 requires that all functions return using the 'j ra' instruction  *  * XXX gcc doesn't do this for functions with __noreturn__ attribute.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_END_OF_FUNCTION
parameter_list|(
name|ins
parameter_list|)
value|((ins) == 0x03e00008)
end_define

begin_comment
comment|/*  * kdbpeekD(addr) - skip one word starting at 'addr', then read the second word  */
end_comment

begin_define
define|#
directive|define
name|kdbpeekD
parameter_list|(
name|addr
parameter_list|)
value|kdbpeek(((int *)(addr)) + 1)
end_define

begin_comment
comment|/*  * Functions ``special'' enough to print by name  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|Name
parameter_list|(
name|_fn
parameter_list|)
value|{ (void*)_fn, # _fn }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Name
parameter_list|(
name|_fn
parameter_list|)
value|{ _fn, "_fn"}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
struct|struct
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|names
index|[]
init|=
block|{
name|Name
argument_list|(
name|trap
argument_list|)
block|,
name|Name
argument_list|(
name|MipsKernGenException
argument_list|)
block|,
name|Name
argument_list|(
name|MipsUserGenException
argument_list|)
block|,
name|Name
argument_list|(
name|MipsKernIntr
argument_list|)
block|,
name|Name
argument_list|(
name|MipsUserIntr
argument_list|)
block|,
name|Name
argument_list|(
name|cpu_switch
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Map a function address to a string name, if known; or a hex string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fn_name
parameter_list|(
name|uintptr_t
name|addr
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|17
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|db_expr_t
name|diff
decl_stmt|;
name|c_db_sym_t
name|sym
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
name|diff
operator|=
literal|0
expr_stmt|;
name|symname
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|db_search_symbol
argument_list|(
operator|(
name|db_addr_t
operator|)
name|addr
argument_list|,
name|DB_STGY_ANY
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|db_symbol_values
argument_list|(
name|sym
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|symname
argument_list|,
operator|(
name|db_expr_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|symname
operator|&&
name|diff
operator|==
literal|0
condition|)
return|return
operator|(
name|symname
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|names
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|names
index|[
name|i
index|]
operator|.
name|addr
operator|==
operator|(
name|void
operator|*
operator|)
name|addr
condition|)
return|return
operator|(
name|names
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|void
name|stacktrace_subr
parameter_list|(
name|register_t
name|pc
parameter_list|,
name|register_t
name|sp
parameter_list|,
name|register_t
name|ra
parameter_list|,
name|int
function_decl|(
modifier|*
name|printfn
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
block|{
name|InstFmt
name|i
decl_stmt|;
comment|/* 	 * Arrays for a0..a3 registers and flags if content 	 * of these registers is valid, e.g. obtained from the stack 	 */
name|int
name|valid_args
index|[
literal|4
index|]
decl_stmt|;
name|uintptr_t
name|args
index|[
literal|4
index|]
decl_stmt|;
name|uintptr_t
name|va
decl_stmt|,
name|subr
decl_stmt|;
name|unsigned
name|instr
decl_stmt|,
name|mask
decl_stmt|;
name|unsigned
name|int
name|frames
init|=
literal|0
decl_stmt|;
name|int
name|more
decl_stmt|,
name|stksize
decl_stmt|,
name|j
decl_stmt|;
comment|/* Jump here when done with a frame, to start a new one */
name|loop
label|:
comment|/* 	 * Invalidate arguments values 	 */
name|valid_args
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|valid_args
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|valid_args
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|valid_args
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Jump here after a nonstandard (interrupt handler) frame */
name|stksize
operator|=
literal|0
expr_stmt|;
name|subr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|frames
operator|++
operator|>
literal|100
condition|)
block|{
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"\nstackframe count exceeded\n"
argument_list|)
expr_stmt|;
comment|/* return breaks stackframe-size heuristics with gcc -O2 */
goto|goto
name|finish
goto|;
comment|/* XXX */
block|}
comment|/* check for bad SP: could foul up next frame */
comment|/*XXX MIPS64 bad: this hard-coded SP is lame */
if|if
condition|(
name|sp
operator|&
literal|3
operator|||
name|sp
operator|<
literal|0x80000000
condition|)
block|{
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"SP 0x%x: not in kernel\n"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|ra
operator|=
literal|0
expr_stmt|;
name|subr
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
define|#
directive|define
name|Between
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
define|\
value|( ((x)<= (y))&& ((y)< (z)) )
define|#
directive|define
name|pcBetween
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|Between((uintptr_t)a, pc, (uintptr_t)b)
comment|/* 	 * Check for current PC in  exception handler code that don't have a 	 * preceding "j ra" at the tail of the preceding function. Depends 	 * on relative ordering of functions in exception.S, swtch.S. 	 */
if|if
condition|(
name|pcBetween
argument_list|(
name|MipsKernGenException
argument_list|,
name|MipsUserGenException
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|uintptr_t
operator|)
name|MipsKernGenException
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|MipsUserGenException
argument_list|,
name|MipsKernIntr
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|uintptr_t
operator|)
name|MipsUserGenException
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|MipsKernIntr
argument_list|,
name|MipsUserIntr
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|uintptr_t
operator|)
name|MipsKernIntr
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|MipsUserIntr
argument_list|,
name|MipsTLBInvalidException
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|uintptr_t
operator|)
name|MipsUserIntr
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|MipsTLBInvalidException
argument_list|,
name|MipsTLBMissException
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|uintptr_t
operator|)
name|MipsTLBInvalidException
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|fork_trampoline
argument_list|,
name|savectx
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|uintptr_t
operator|)
name|fork_trampoline
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|savectx
argument_list|,
name|mips_cpu_throw
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|uintptr_t
operator|)
name|savectx
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|mips_cpu_throw
argument_list|,
name|cpu_switch
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|uintptr_t
operator|)
name|cpu_throw
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|cpu_switch
argument_list|,
name|MipsSwitchFPState
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|uintptr_t
operator|)
name|cpu_switch
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|_locore
argument_list|,
name|_locoreEnd
argument_list|)
condition|)
block|{
name|subr
operator|=
operator|(
name|uintptr_t
operator|)
name|_locore
expr_stmt|;
name|ra
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* check for bad PC */
comment|/*XXX MIPS64 bad: These hard coded constants are lame */
if|if
condition|(
name|pc
operator|&
literal|3
operator|||
name|pc
operator|<
operator|(
name|uintptr_t
operator|)
literal|0x80000000
operator|||
name|pc
operator|>=
operator|(
name|uintptr_t
operator|)
name|edata
condition|)
block|{
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"PC 0x%x: not in kernel\n"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|ra
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Find the beginning of the current subroutine by scanning 	 * backwards from the current PC for the end of the previous 	 * subroutine. 	 */
if|if
condition|(
operator|!
name|subr
condition|)
block|{
name|va
operator|=
name|pc
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|instr
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|MIPS_START_OF_FUNCTION
argument_list|(
name|instr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|MIPS_END_OF_FUNCTION
argument_list|(
name|instr
argument_list|)
condition|)
block|{
comment|/* skip over branch-delay slot instruction */
name|va
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
break|break;
block|}
name|va
operator|-=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
comment|/* skip over nulls which might separate .o files */
while|while
condition|(
operator|(
name|instr
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
name|va
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|va
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|subr
operator|=
name|va
expr_stmt|;
block|}
comment|/* scan forwards to find stack size and any saved registers */
name|stksize
operator|=
literal|0
expr_stmt|;
name|more
operator|=
literal|3
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|va
operator|=
name|subr
init|;
name|more
condition|;
name|va
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|,
name|more
operator|=
operator|(
name|more
operator|==
literal|3
operator|)
condition|?
literal|3
else|:
name|more
operator|-
literal|1
control|)
block|{
comment|/* stop if hit our current position */
if|if
condition|(
name|va
operator|>=
name|pc
condition|)
break|break;
name|instr
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
name|va
argument_list|)
expr_stmt|;
name|i
operator|.
name|word
operator|=
name|instr
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|JType
operator|.
name|op
condition|)
block|{
case|case
name|OP_SPECIAL
case|:
switch|switch
condition|(
name|i
operator|.
name|RType
operator|.
name|func
condition|)
block|{
case|case
name|OP_JR
case|:
case|case
name|OP_JALR
case|:
name|more
operator|=
literal|2
expr_stmt|;
comment|/* stop after next instruction */
break|break;
case|case
name|OP_SYSCALL
case|:
case|case
name|OP_BREAK
case|:
name|more
operator|=
literal|1
expr_stmt|;
comment|/* stop now */
block|}
empty_stmt|;
break|break;
case|case
name|OP_BCOND
case|:
case|case
name|OP_J
case|:
case|case
name|OP_JAL
case|:
case|case
name|OP_BEQ
case|:
case|case
name|OP_BNE
case|:
case|case
name|OP_BLEZ
case|:
case|case
name|OP_BGTZ
case|:
name|more
operator|=
literal|2
expr_stmt|;
comment|/* stop after next instruction */
break|break;
case|case
name|OP_COP0
case|:
case|case
name|OP_COP1
case|:
case|case
name|OP_COP2
case|:
case|case
name|OP_COP3
case|:
switch|switch
condition|(
name|i
operator|.
name|RType
operator|.
name|rs
condition|)
block|{
case|case
name|OP_BCx
case|:
case|case
name|OP_BCy
case|:
name|more
operator|=
literal|2
expr_stmt|;
comment|/* stop after next instruction */
block|}
empty_stmt|;
break|break;
case|case
name|OP_SW
case|:
comment|/* look for saved registers on the stack */
if|if
condition|(
name|i
operator|.
name|IType
operator|.
name|rs
operator|!=
literal|29
condition|)
break|break;
comment|/* only restore the first one */
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|.
name|IType
operator|.
name|rt
operator|)
condition|)
break|break;
name|mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|.
name|IType
operator|.
name|rt
operator|)
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|IType
operator|.
name|rt
condition|)
block|{
case|case
literal|4
case|:
comment|/* a0 */
name|args
index|[
literal|0
index|]
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
name|valid_args
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* a1 */
name|args
index|[
literal|1
index|]
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
name|valid_args
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* a2 */
name|args
index|[
literal|2
index|]
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
name|valid_args
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* a3 */
name|args
index|[
literal|3
index|]
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
name|valid_args
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|31
case|:
comment|/* ra */
name|ra
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_SD
case|:
comment|/* look for saved registers on the stack */
if|if
condition|(
name|i
operator|.
name|IType
operator|.
name|rs
operator|!=
literal|29
condition|)
break|break;
comment|/* only restore the first one */
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|.
name|IType
operator|.
name|rt
operator|)
condition|)
break|break;
name|mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|.
name|IType
operator|.
name|rt
operator|)
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|IType
operator|.
name|rt
condition|)
block|{
case|case
literal|4
case|:
comment|/* a0 */
name|args
index|[
literal|0
index|]
operator|=
name|kdbpeekD
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
name|valid_args
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* a1 */
name|args
index|[
literal|1
index|]
operator|=
name|kdbpeekD
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
name|valid_args
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* a2 */
name|args
index|[
literal|2
index|]
operator|=
name|kdbpeekD
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
name|valid_args
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* a3 */
name|args
index|[
literal|3
index|]
operator|=
name|kdbpeekD
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
name|valid_args
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|31
case|:
comment|/* ra */
name|ra
operator|=
name|kdbpeekD
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_ADDI
case|:
case|case
name|OP_ADDIU
case|:
comment|/* look for stack pointer adjustment */
if|if
condition|(
name|i
operator|.
name|IType
operator|.
name|rs
operator|!=
literal|29
operator|||
name|i
operator|.
name|IType
operator|.
name|rt
operator|!=
literal|29
condition|)
break|break;
name|stksize
operator|=
operator|-
operator|(
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
expr_stmt|;
block|}
block|}
name|done
label|:
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"%s+%x ("
argument_list|,
name|fn_name
argument_list|(
name|subr
argument_list|)
argument_list|,
name|pc
operator|-
name|subr
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>
literal|0
condition|)
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid_args
index|[
name|j
index|]
condition|)
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"%x"
argument_list|,
name|args
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|") ra %x sp %x sz %d\n"
argument_list|,
name|ra
argument_list|,
name|sp
argument_list|,
name|stksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ra
condition|)
block|{
if|if
condition|(
name|pc
operator|==
name|ra
operator|&&
name|stksize
operator|==
literal|0
condition|)
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"stacktrace: loop!\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|pc
operator|=
name|ra
expr_stmt|;
name|sp
operator|+=
name|stksize
expr_stmt|;
name|ra
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
else|else
block|{
name|finish
label|:
if|if
condition|(
name|curproc
condition|)
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"pid %d\n"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"curproc NULL\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|db_md_set_watchpoint
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|size
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|db_md_clr_watchpoint
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|size
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|db_md_list_watchpoints
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|db_trace_self
parameter_list|(
name|void
parameter_list|)
block|{
name|db_trace_thread
argument_list|(
name|curthread
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|db_trace_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|thr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|register_t
name|pc
decl_stmt|,
name|ra
decl_stmt|,
name|sp
decl_stmt|;
name|struct
name|pcb
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|thr
operator|==
name|curthread
condition|)
block|{
name|sp
operator|=
operator|(
name|register_t
operator|)
name|__builtin_frame_address
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ra
operator|=
operator|(
name|register_t
operator|)
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
expr_stmt|;
asm|__asm __volatile(
literal|"jal 99f\n"
literal|"nop\n"
literal|"99:\n"
literal|"move %0, $31\n"
comment|/* get ra */
literal|"move $31, %1\n"
comment|/* restore ra */
operator|:
literal|"=r"
operator|(
name|pc
operator|)
operator|:
literal|"r"
operator|(
name|ra
operator|)
block|)
empty_stmt|;
block|}
end_function

begin_else
else|else
block|{
name|ctx
operator|=
name|kdb_thr_ctx
argument_list|(
name|thr
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|(
name|register_t
operator|)
name|ctx
operator|->
name|pcb_context
index|[
name|PREG_SP
index|]
expr_stmt|;
name|pc
operator|=
operator|(
name|register_t
operator|)
name|ctx
operator|->
name|pcb_context
index|[
name|PREG_PC
index|]
expr_stmt|;
name|ra
operator|=
operator|(
name|register_t
operator|)
name|ctx
operator|->
name|pcb_context
index|[
name|PREG_RA
index|]
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|stacktrace_subr
argument_list|(
name|pc
argument_list|,
name|sp
argument_list|,
name|ra
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
operator|...
argument_list|)
operator|)
name|db_printf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_macro
unit|}  void
name|db_show_mdpcpu
argument_list|(
argument|struct pcpu *pc
argument_list|)
end_macro

begin_block
block|{
name|db_printf
argument_list|(
literal|"ipis	    = 0x%x\n"
argument_list|,
name|pc
operator|->
name|pc_pending_ipis
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"next ASID    = %d\n"
argument_list|,
name|pc
operator|->
name|pc_next_asid
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"GENID	    = %d\n"
argument_list|,
name|pc
operator|->
name|pc_asid_generation
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

end_unit

