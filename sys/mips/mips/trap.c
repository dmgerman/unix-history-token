begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: trap.c,v 1.19 1998/09/30 12:40:41 pefo Exp $	*/
end_comment

begin_comment
comment|/* tracked to 1.23 */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and Ralph Campbell.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * from: Utah Hdr: trap.c 1.32 91/04/06  *  *	from: @(#)trap.c	8.5 (Berkeley) 1/11/94  *	JNPR: trap.c,v 1.13.2.2 2007/08/29 10:03:49 girish  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_global.h"
end_include

begin_define
define|#
directive|define
name|NO_REG_DEFS
value|1
end_define

begin_comment
comment|/* Prevent asm.h from including regdef.h */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<machine/trap.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/mips_opcode.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/regnum.h>
end_include

begin_include
include|#
directive|include
file|<machine/rm7000.h>
end_include

begin_include
include|#
directive|include
file|<machine/archtype.h>
end_include

begin_include
include|#
directive|include
file|<machine/asm.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<machine/db_machdep.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TRAP_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|trap_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|unsigned
name|onfault_table
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|MipsKernGenException
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MipsUserGenException
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MipsKernIntr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MipsUserIntr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MipsTLBInvalidException
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MipsKernTLBInvalidException
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MipsUserTLBInvalidException
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MipsTLBMissException
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|log_bad_page_fault
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|trapframe
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|log_frame_dump
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_mapping_info
parameter_list|(
name|vm_offset_t
parameter_list|,
name|pd_entry_t
modifier|*
modifier|*
parameter_list|,
name|pt_entry_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|TRAP_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|trap_frame_dump
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
name|edata
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|machExceptionTable
index|[]
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
block|{
comment|/*  * The kernel exception handlers.  */
name|MipsKernIntr
operator|,
comment|/* external interrupt */
function_decl|MipsKernGenException
operator|,
comment|/* TLB modification */
function_decl|MipsKernTLBInvalidException
operator|,
comment|/* TLB miss (load or instr. fetch) */
function_decl|MipsKernTLBInvalidException
operator|,
comment|/* TLB miss (store) */
function_decl|MipsKernGenException
operator|,
comment|/* address error (load or I-fetch) */
function_decl|MipsKernGenException
operator|,
comment|/* address error (store) */
function_decl|MipsKernGenException
operator|,
comment|/* bus error (I-fetch) */
function_decl|MipsKernGenException
operator|,
comment|/* bus error (load or store) */
function_decl|MipsKernGenException
operator|,
comment|/* system call */
function_decl|MipsKernGenException
operator|,
comment|/* breakpoint */
function_decl|MipsKernGenException
operator|,
comment|/* reserved instruction */
function_decl|MipsKernGenException
operator|,
comment|/* coprocessor unusable */
function_decl|MipsKernGenException
operator|,
comment|/* arithmetic overflow */
function_decl|MipsKernGenException
operator|,
comment|/* trap exception */
function_decl|MipsKernGenException
operator|,
comment|/* virtual coherence exception inst */
function_decl|MipsKernGenException
operator|,
comment|/* floating point exception */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* watch exception */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* virtual coherence exception data */
comment|/*  * The user exception handlers.  */
function_decl|MipsUserIntr
operator|,
comment|/* 0 */
function_decl|MipsUserGenException
operator|,
comment|/* 1 */
function_decl|MipsUserTLBInvalidException
operator|,
comment|/* 2 */
function_decl|MipsUserTLBInvalidException
operator|,
comment|/* 3 */
function_decl|MipsUserGenException
operator|,
comment|/* 4 */
function_decl|MipsUserGenException
operator|,
comment|/* 5 */
function_decl|MipsUserGenException
operator|,
comment|/* 6 */
function_decl|MipsUserGenException
operator|,
comment|/* 7 */
function_decl|MipsUserGenException
operator|,
comment|/* 8 */
function_decl|MipsUserGenException
operator|,
comment|/* 9 */
function_decl|MipsUserGenException
operator|,
comment|/* 10 */
function_decl|MipsUserGenException
operator|,
comment|/* 11 */
function_decl|MipsUserGenException
operator|,
comment|/* 12 */
function_decl|MipsUserGenException
operator|,
comment|/* 13 */
function_decl|MipsUserGenException
operator|,
comment|/* 14 */
function_decl|MipsUserGenException
operator|,
comment|/* 15 */
function_decl|MipsUserGenException
operator|,
comment|/* 16 */
function_decl|MipsUserGenException
operator|,
comment|/* 17 */
function_decl|MipsUserGenException
operator|,
comment|/* 18 */
function_decl|MipsUserGenException
operator|,
comment|/* 19 */
function_decl|MipsUserGenException
operator|,
comment|/* 20 */
function_decl|MipsUserGenException
operator|,
comment|/* 21 */
function_decl|MipsUserGenException
operator|,
comment|/* 22 */
function_decl|MipsUserGenException
operator|,
comment|/* 23 */
function_decl|MipsUserGenException
operator|,
comment|/* 24 */
function_decl|MipsUserGenException
operator|,
comment|/* 25 */
function_decl|MipsUserGenException
operator|,
comment|/* 26 */
function_decl|MipsUserGenException
operator|,
comment|/* 27 */
function_decl|MipsUserGenException
operator|,
comment|/* 28 */
function_decl|MipsUserGenException
operator|,
comment|/* 29 */
function_decl|MipsUserGenException
operator|,
comment|/* 20 */
function_decl|MipsUserGenException
operator|,
end_function_decl

begin_comment
comment|/* 31 */
end_comment

begin_decl_stmt
unit|};
name|char
modifier|*
name|trap_type
index|[]
init|=
block|{
literal|"external interrupt"
block|,
literal|"TLB modification"
block|,
literal|"TLB miss (load or instr. fetch)"
block|,
literal|"TLB miss (store)"
block|,
literal|"address error (load or I-fetch)"
block|,
literal|"address error (store)"
block|,
literal|"bus error (I-fetch)"
block|,
literal|"bus error (load or store)"
block|,
literal|"system call"
block|,
literal|"breakpoint"
block|,
literal|"reserved instruction"
block|,
literal|"coprocessor unusable"
block|,
literal|"arithmetic overflow"
block|,
literal|"trap"
block|,
literal|"virtual coherency instruction"
block|,
literal|"floating point"
block|,
literal|"reserved 16"
block|,
literal|"reserved 17"
block|,
literal|"reserved 18"
block|,
literal|"reserved 19"
block|,
literal|"reserved 20"
block|,
literal|"reserved 21"
block|,
literal|"reserved 22"
block|,
literal|"watch"
block|,
literal|"reserved 24"
block|,
literal|"reserved 25"
block|,
literal|"reserved 26"
block|,
literal|"reserved 27"
block|,
literal|"reserved 28"
block|,
literal|"reserved 29"
block|,
literal|"reserved 30"
block|,
literal|"virtual coherency data"
block|, }
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|DDB
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|)
end_if

begin_decl_stmt
name|struct
name|trapdebug
name|trapdebug
index|[
name|TRAPSIZE
index|]
decl_stmt|,
modifier|*
name|trp
init|=
name|trapdebug
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DDB
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG
argument_list|)
end_if

begin_function_decl
name|void
name|stacktrace
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|logstacktrace
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|kdbpeek
parameter_list|(
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* extern functions printed by name in stack backtraces */
end_comment

begin_function_decl
specifier|extern
name|void
name|MipsTLBMiss
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MipsUserSyscallException
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
name|_locore
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|_locoreEnd
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB || DEBUG */
end_comment

begin_function_decl
specifier|extern
name|void
name|MipsSwitchFPState
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|trapframe
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MipsFPTrap
parameter_list|(
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int
name|trap
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int
name|MipsEmulateBranch
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|KERNLAND
parameter_list|(
name|x
parameter_list|)
value|((int)(x)< 0)
end_define

begin_define
define|#
directive|define
name|DELAYBRANCH
parameter_list|(
name|x
parameter_list|)
value|((int)(x)< 0)
end_define

begin_comment
comment|/*  * kdbpeekD(addr) - skip one word starting at 'addr', then read the second word  */
end_comment

begin_define
define|#
directive|define
name|kdbpeekD
parameter_list|(
name|addr
parameter_list|)
value|kdbpeek(((int *)(addr)) + 1)
end_define

begin_decl_stmt
name|int
name|rrs_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * MIPS load/store access type  */
end_comment

begin_enum
enum|enum
block|{
name|MIPS_LHU_ACCESS
init|=
literal|1
block|,
name|MIPS_LH_ACCESS
block|,
name|MIPS_LWU_ACCESS
block|,
name|MIPS_LW_ACCESS
block|,
name|MIPS_LD_ACCESS
block|,
name|MIPS_SH_ACCESS
block|,
name|MIPS_SW_ACCESS
block|,
name|MIPS_SD_ACCESS
block|}
enum|;
end_enum

begin_decl_stmt
name|char
modifier|*
name|access_name
index|[]
init|=
block|{
literal|"Load Halfword Unsigned"
block|,
literal|"Load Halfword"
block|,
literal|"Load Word Unsigned"
block|,
literal|"Load Word"
block|,
literal|"Load Doubleword"
block|,
literal|"Store Halfword"
block|,
literal|"Store Word"
block|,
literal|"Store Doubleword"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|allow_unaligned_acc
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|allow_unaligned_acc
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|allow_unaligned_acc
argument_list|,
literal|0
argument_list|,
literal|"Allow unaligned accesses"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|emulate_unaligned_access
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|syscallnames
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Handle an exception.  * Called from MipsKernGenException() or MipsUserGenException()  * when a processor trap occurs.  * In the case of a kernel trap, we return the pc where to resume if  * p->p_addr->u_pcb.pcb_onfault is set, otherwise, return old pc.  */
end_comment

begin_function
name|u_int
name|trap
parameter_list|(
name|trapframe
parameter_list|)
name|struct
name|trapframe
modifier|*
name|trapframe
decl_stmt|;
block|{
name|int
name|type
decl_stmt|,
name|usermode
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|ucode
init|=
literal|0
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|unsigned
name|int
name|entry
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|int
name|quad_syscall
init|=
literal|0
decl_stmt|;
name|int
name|access_type
decl_stmt|;
name|ksiginfo_t
name|ksi
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|register_t
name|addr
init|=
literal|0
decl_stmt|;
name|trapdebug_enter
argument_list|(
name|trapframe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
operator|(
name|trapframe
operator|->
name|cause
operator|&
name|CR_EXC_CODE
operator|)
operator|>>
name|CR_EXC_CODE_SHIFT
expr_stmt|;
if|if
condition|(
name|USERMODE
argument_list|(
name|trapframe
operator|->
name|sr
argument_list|)
condition|)
block|{
name|type
operator||=
name|T_USER
expr_stmt|;
name|usermode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|usermode
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Enable hardware interrupts if they were on before the trap. If it 	 * was off disable all so we don't accidently enable it when doing a 	 * return to userland. 	 */
if|if
condition|(
name|trapframe
operator|->
name|sr
operator|&
name|SR_INT_ENAB
condition|)
block|{
name|set_intr_mask
argument_list|(
operator|~
operator|(
name|trapframe
operator|->
name|sr
operator|&
name|ALL_INT_MASK
operator|)
argument_list|)
expr_stmt|;
name|enableintr
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|disableintr
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TRAP_DEBUG
if|if
condition|(
name|trap_debug
condition|)
block|{
specifier|static
name|vm_offset_t
name|last_badvaddr
init|=
literal|0
decl_stmt|;
specifier|static
name|vm_offset_t
name|this_badvaddr
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|pid
decl_stmt|;
name|printf
argument_list|(
literal|"trap type %x (%s - "
argument_list|,
name|type
argument_list|,
name|trap_type
index|[
name|type
operator|&
operator|(
operator|~
name|T_USER
operator|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|T_USER
condition|)
name|printf
argument_list|(
literal|"user mode)\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"kernel mode)\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|printf
argument_list|(
literal|"cpuid = %d\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MachTLBGetPID
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"badaddr = %p, pc = %p, ra = %p, sp = %p, sr = 0x%x, pid = %d, ASID = 0x%x\n"
argument_list|,
name|trapframe
operator|->
name|badvaddr
argument_list|,
name|trapframe
operator|->
name|pc
argument_list|,
name|trapframe
operator|->
name|ra
argument_list|,
name|trapframe
operator|->
name|sp
argument_list|,
name|trapframe
operator|->
name|sr
argument_list|,
operator|(
name|curproc
condition|?
name|curproc
operator|->
name|p_pid
else|:
operator|-
literal|1
operator|)
argument_list|,
name|pid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
operator|&
operator|~
name|T_USER
condition|)
block|{
case|case
name|T_TLB_MOD
case|:
case|case
name|T_TLB_LD_MISS
case|:
case|case
name|T_TLB_ST_MISS
case|:
case|case
name|T_ADDR_ERR_LD
case|:
case|case
name|T_ADDR_ERR_ST
case|:
name|this_badvaddr
operator|=
name|trapframe
operator|->
name|badvaddr
expr_stmt|;
break|break;
case|case
name|T_SYSCALL
case|:
name|this_badvaddr
operator|=
name|trapframe
operator|->
name|ra
expr_stmt|;
break|break;
default|default:
name|this_badvaddr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|last_badvaddr
operator|==
name|this_badvaddr
operator|)
operator|&&
operator|(
operator|(
name|type
operator|&
operator|~
name|T_USER
operator|)
operator|!=
name|T_SYSCALL
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|count
operator|==
literal|3
condition|)
block|{
name|trap_frame_dump
argument_list|(
name|trapframe
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"too many faults at %p\n"
argument_list|,
name|last_badvaddr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|last_badvaddr
operator|=
name|this_badvaddr
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_MCHECK
case|:
ifdef|#
directive|ifdef
name|DDB
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|trapframe
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"MCHECK\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_TLB_MOD
case|:
comment|/* check for kernel address */
if|if
condition|(
name|KERNLAND
argument_list|(
name|trapframe
operator|->
name|badvaddr
argument_list|)
condition|)
block|{
name|vm_offset_t
name|pa
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pte
operator|=
name|pmap_segmap
argument_list|(
name|kernel_pmap
argument_list|,
name|trapframe
operator|->
name|badvaddr
argument_list|)
operator|)
condition|)
name|panic
argument_list|(
literal|"trap: ktlbmod: invalid segmap"
argument_list|)
expr_stmt|;
name|pte
operator|+=
operator|(
name|trapframe
operator|->
name|badvaddr
operator|>>
name|PGSHIFT
operator|)
operator|&
operator|(
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
name|entry
operator|=
operator|*
name|pte
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* It is possible that some other CPU changed m-bit */
if|if
condition|(
operator|!
name|mips_pg_v
argument_list|(
name|entry
argument_list|)
operator|||
operator|(
name|entry
operator|&
name|mips_pg_m_bit
argument_list|()
operator|)
condition|)
block|{
name|trapframe
operator|->
name|badvaddr
operator|&=
operator|~
name|PGOFSET
expr_stmt|;
name|pmap_update_page
argument_list|(
name|kernel_pmap
argument_list|,
name|trapframe
operator|->
name|badvaddr
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|mips_pg_v
argument_list|(
name|entry
argument_list|)
operator|||
operator|(
name|entry
operator|&
name|mips_pg_m_bit
argument_list|()
operator|)
condition|)
name|panic
argument_list|(
literal|"trap: ktlbmod: invalid pte"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|entry
operator|&
name|mips_pg_ro_bit
argument_list|()
condition|)
block|{
comment|/* write to read only page in the kernel */
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
goto|goto
name|kernel_fault
goto|;
block|}
name|entry
operator||=
name|mips_pg_m_bit
argument_list|()
expr_stmt|;
operator|*
name|pte
operator|=
name|entry
expr_stmt|;
name|trapframe
operator|->
name|badvaddr
operator|&=
operator|~
name|PGOFSET
expr_stmt|;
name|pmap_update_page
argument_list|(
name|kernel_pmap
argument_list|,
name|trapframe
operator|->
name|badvaddr
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|pa
operator|=
name|mips_tlbpfn_to_paddr
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page_is_managed
argument_list|(
name|pa
argument_list|)
condition|)
name|panic
argument_list|(
literal|"trap: ktlbmod: unmanaged page"
argument_list|)
expr_stmt|;
name|pmap_set_modified
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
case|case
name|T_TLB_MOD
operator|+
name|T_USER
case|:
block|{
name|vm_offset_t
name|pa
decl_stmt|;
name|pmap
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pte
operator|=
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|trapframe
operator|->
name|badvaddr
argument_list|)
operator|)
condition|)
name|panic
argument_list|(
literal|"trap: utlbmod: invalid segmap"
argument_list|)
expr_stmt|;
name|pte
operator|+=
operator|(
name|trapframe
operator|->
name|badvaddr
operator|>>
name|PGSHIFT
operator|)
operator|&
operator|(
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
name|entry
operator|=
operator|*
name|pte
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* It is possible that some other CPU changed m-bit */
if|if
condition|(
operator|!
name|mips_pg_v
argument_list|(
name|entry
argument_list|)
operator|||
operator|(
name|entry
operator|&
name|mips_pg_m_bit
argument_list|()
operator|)
condition|)
block|{
name|trapframe
operator|->
name|badvaddr
operator|=
operator|(
name|trapframe
operator|->
name|badvaddr
operator|&
operator|~
name|PGOFSET
operator|)
expr_stmt|;
name|pmap_update_page
argument_list|(
name|pmap
argument_list|,
name|trapframe
operator|->
name|badvaddr
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|mips_pg_v
argument_list|(
name|entry
argument_list|)
operator|||
operator|(
name|entry
operator|&
name|mips_pg_m_bit
argument_list|()
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"trap: utlbmod: invalid pte"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|entry
operator|&
name|mips_pg_ro_bit
argument_list|()
condition|)
block|{
comment|/* write to read only page */
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
goto|goto
name|dofault
goto|;
block|}
name|entry
operator||=
name|mips_pg_m_bit
argument_list|()
expr_stmt|;
operator|*
name|pte
operator|=
name|entry
expr_stmt|;
name|trapframe
operator|->
name|badvaddr
operator|=
operator|(
name|trapframe
operator|->
name|badvaddr
operator|&
operator|~
name|PGOFSET
operator|)
expr_stmt|;
name|pmap_update_page
argument_list|(
name|pmap
argument_list|,
name|trapframe
operator|->
name|badvaddr
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|trapframe
operator|->
name|badvaddr
operator||=
operator|(
name|pmap
operator|->
name|pm_asid
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|.
name|asid
operator|<<
name|VMTLB_PID_SHIFT
operator|)
expr_stmt|;
name|pa
operator|=
name|mips_tlbpfn_to_paddr
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page_is_managed
argument_list|(
name|pa
argument_list|)
condition|)
name|panic
argument_list|(
literal|"trap: utlbmod: unmanaged page"
argument_list|)
expr_stmt|;
name|pmap_set_modified
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|usermode
condition|)
block|{
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
block|}
goto|goto
name|out
goto|;
block|}
case|case
name|T_TLB_LD_MISS
case|:
case|case
name|T_TLB_ST_MISS
case|:
name|ftype
operator|=
operator|(
name|type
operator|==
name|T_TLB_ST_MISS
operator|)
condition|?
name|VM_PROT_WRITE
else|:
name|VM_PROT_READ
expr_stmt|;
comment|/* check for kernel address */
if|if
condition|(
name|KERNLAND
argument_list|(
name|trapframe
operator|->
name|badvaddr
argument_list|)
condition|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|kernel_fault
label|:
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|trapframe
operator|->
name|badvaddr
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_fault
argument_list|(
name|kernel_map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
if|if
condition|(
operator|(
name|i
operator|=
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|)
operator|!=
literal|0
condition|)
block|{
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|onfault_table
index|[
name|i
index|]
operator|)
return|;
block|}
goto|goto
name|err
goto|;
block|}
comment|/* 		 * It is an error for the kernel to access user space except 		 * through the copyin/copyout routines. 		 */
if|if
condition|(
operator|(
name|i
operator|=
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|)
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* check for fuswintr() or suswintr() getting a page fault */
if|if
condition|(
name|i
operator|==
literal|4
condition|)
block|{
return|return
operator|(
name|onfault_table
index|[
name|i
index|]
operator|)
return|;
block|}
goto|goto
name|dofault
goto|;
case|case
name|T_TLB_LD_MISS
operator|+
name|T_USER
case|:
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
goto|goto
name|dofault
goto|;
case|case
name|T_TLB_ST_MISS
operator|+
name|T_USER
case|:
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
name|dofault
label|:
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|trapframe
operator|->
name|badvaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vm_offset_t
operator|)
name|trapframe
operator|->
name|badvaddr
operator|>=
name|VM_MIN_KERNEL_ADDRESS
condition|)
block|{
comment|/* 				 * Don't allow user-mode faults in kernel 				 * address space. 				 */
goto|goto
name|nogo
goto|;
block|}
comment|/* 			 * Keep swapout from messing with us during this 			 * critical time. 			 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMFAULT_TRACE
name|printf
argument_list|(
literal|"vm_fault(%x (pmap %x), %x (%x), %x, %d) -> %x at pc %x\n"
argument_list|,
name|map
argument_list|,
operator|&
name|vm
operator|->
name|vm_pmap
argument_list|,
name|va
argument_list|,
name|trapframe
operator|->
name|badvaddr
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|,
name|rv
argument_list|,
name|trapframe
operator|->
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
operator|!
name|usermode
condition|)
block|{
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
block|}
goto|goto
name|out
goto|;
block|}
name|nogo
label|:
if|if
condition|(
operator|!
name|usermode
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|)
operator|!=
literal|0
condition|)
block|{
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|onfault_table
index|[
name|i
index|]
operator|)
return|;
block|}
goto|goto
name|err
goto|;
block|}
name|ucode
operator|=
name|ftype
expr_stmt|;
name|i
operator|=
operator|(
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
operator|)
expr_stmt|;
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
name|msg
operator|=
literal|"BAD_PAGE_FAULT"
expr_stmt|;
name|log_bad_page_fault
argument_list|(
name|msg
argument_list|,
name|trapframe
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|T_ADDR_ERR_LD
operator|+
name|T_USER
case|:
comment|/* misaligned or kseg access */
case|case
name|T_ADDR_ERR_ST
operator|+
name|T_USER
case|:
comment|/* misaligned or kseg access */
if|if
condition|(
name|allow_unaligned_acc
condition|)
block|{
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|type
operator|==
operator|(
name|T_ADDR_ERR_LD
operator|+
name|T_USER
operator|)
condition|)
name|mode
operator|=
name|VM_PROT_READ
expr_stmt|;
else|else
name|mode
operator|=
name|VM_PROT_WRITE
expr_stmt|;
comment|/* 			 * ADDR_ERR faults have higher priority than TLB 			 * Miss faults.  Therefore, it is necessary to 			 * verify that the faulting address is a valid 			 * virtual address within the process' address space 			 * before trying to emulate the unaligned access. 			 */
if|if
condition|(
name|useracc
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|trapframe
operator|->
name|badvaddr
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|access_type
operator|=
name|emulate_unaligned_access
argument_list|(
name|trapframe
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_type
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|msg
operator|=
literal|"ADDRESS_ERR"
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|T_BUS_ERR_IFETCH
operator|+
name|T_USER
case|:
comment|/* BERR asserted to cpu */
case|case
name|T_BUS_ERR_LD_ST
operator|+
name|T_USER
case|:
comment|/* BERR asserted to cpu */
name|ucode
operator|=
literal|0
expr_stmt|;
comment|/* XXX should be VM_PROT_something */
name|i
operator|=
name|SIGBUS
expr_stmt|;
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
name|msg
operator|=
literal|"BUS_ERR"
expr_stmt|;
name|log_bad_page_fault
argument_list|(
name|msg
argument_list|,
name|trapframe
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SYSCALL
operator|+
name|T_USER
case|:
block|{
name|struct
name|trapframe
modifier|*
name|locr0
init|=
name|td
operator|->
name|td_frame
decl_stmt|;
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
name|unsigned
name|int
name|code
decl_stmt|;
name|int
name|nargs
decl_stmt|,
name|nsaved
decl_stmt|;
name|register_t
name|args
index|[
literal|8
index|]
decl_stmt|;
comment|/* 			 * note: PCPU_LAZY_INC() can only be used if we can 			 * afford occassional inaccuracy in the count. 			 */
name|PCPU_LAZY_INC
argument_list|(
name|cnt
operator|.
name|v_syscall
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|!=
name|p
operator|->
name|p_ucred
condition|)
name|cred_update_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KSE
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_SA
condition|)
name|thread_user_enter
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* compute next PC after syscall instruction */
name|td
operator|->
name|td_pcb
operator|->
name|pcb_tpc
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
comment|/* Remember if restart */
if|if
condition|(
name|DELAYBRANCH
argument_list|(
name|trapframe
operator|->
name|cause
argument_list|)
condition|)
block|{
comment|/* Check BD bit */
name|locr0
operator|->
name|pc
operator|=
name|MipsEmulateBranch
argument_list|(
name|locr0
argument_list|,
name|trapframe
operator|->
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|locr0
operator|->
name|pc
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
name|locr0
operator|->
name|v0
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SYS_syscall
case|:
comment|/* 				 * Code is first argument, followed by 				 * actual args. 				 */
name|code
operator|=
name|locr0
operator|->
name|a0
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|locr0
operator|->
name|a1
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|locr0
operator|->
name|a2
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|locr0
operator|->
name|a3
expr_stmt|;
name|nsaved
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|SYS___syscall
case|:
comment|/* 				 * Like syscall, but code is a quad, so as 				 * to maintain quad alignment for the rest 				 * of the arguments. 				 */
if|if
condition|(
name|_QUAD_LOWWORD
operator|==
literal|0
condition|)
block|{
name|code
operator|=
name|locr0
operator|->
name|a0
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|locr0
operator|->
name|a1
expr_stmt|;
block|}
name|args
index|[
literal|0
index|]
operator|=
name|locr0
operator|->
name|a2
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|locr0
operator|->
name|a3
expr_stmt|;
name|nsaved
operator|=
literal|2
expr_stmt|;
name|quad_syscall
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|args
index|[
literal|0
index|]
operator|=
name|locr0
operator|->
name|a0
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|locr0
operator|->
name|a1
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|locr0
operator|->
name|a2
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|locr0
operator|->
name|a3
expr_stmt|;
name|nsaved
operator|=
literal|4
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TRAP_DEBUG
name|printf
argument_list|(
literal|"SYSCALL #%d pid:%u\n"
argument_list|,
name|code
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
condition|)
name|code
operator|&=
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
literal|0
index|]
expr_stmt|;
else|else
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|code
index|]
expr_stmt|;
name|nargs
operator|=
name|callp
operator|->
name|sy_narg
expr_stmt|;
if|if
condition|(
name|nargs
operator|>
name|nsaved
condition|)
block|{
name|i
operator|=
name|copyin
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|locr0
operator|->
name|sp
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
index|[
name|nsaved
index|]
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|nargs
operator|-
name|nsaved
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|locr0
operator|->
name|v0
operator|=
name|i
expr_stmt|;
name|locr0
operator|->
name|a3
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|code
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|code
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|locr0
operator|->
name|v1
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|DDB
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|)
if|if
condition|(
name|trp
operator|==
name|trapdebug
condition|)
name|trapdebug
index|[
name|TRAPSIZE
operator|-
literal|1
index|]
operator|.
name|code
operator|=
name|code
expr_stmt|;
else|else
name|trp
index|[
operator|-
literal|1
index|]
operator|.
name|code
operator|=
name|code
expr_stmt|;
endif|#
directive|endif
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCE
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|PTRACESTOP_SC
argument_list|(
name|p
argument_list|,
name|td
argument_list|,
name|S_PT_SCE
argument_list|)
expr_stmt|;
name|i
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|td
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 			 * Reinitialize proc pointer `p' as it may be 			 * different if this is a child returning from fork 			 * syscall. 			 */
block|td = curthread; 			locr0 = td->td_frame;
endif|#
directive|endif
name|trapdebug_enter
argument_list|(
name|locr0
argument_list|,
operator|-
name|code
argument_list|)
expr_stmt|;
name|cpu_set_syscall_retval
argument_list|(
name|td
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 			 * The sync'ing of I& D caches for SYS_ptrace() is 			 * done by procfs_domem() through procfs_rwmem() 			 * instead of being done here under a special check 			 * for SYS_ptrace(). 			 */
name|done
label|:
comment|/* 			 * Check for misbehavior. 			 */
name|WITNESS_WARN
argument_list|(
name|WARN_PANIC
argument_list|,
name|NULL
argument_list|,
literal|"System call %s returning"
argument_list|,
operator|(
name|code
operator|>=
literal|0
operator|&&
name|code
operator|<
name|SYS_MAXSYSCALL
operator|)
condition|?
name|syscallnames
index|[
name|code
index|]
else|:
literal|"???"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|td
operator|->
name|td_critnest
operator|==
literal|0
argument_list|,
operator|(
literal|"System call %s returning in a critical section"
operator|,
operator|(
name|code
operator|>=
literal|0
operator|&&
name|code
operator|<
name|SYS_MAXSYSCALL
operator|)
condition|?
name|syscallnames
index|[
name|code
index|]
else|:
literal|"???"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|td
operator|->
name|td_locks
operator|==
literal|0
argument_list|,
operator|(
literal|"System call %s returning with %d locks held"
operator|,
operator|(
name|code
operator|>=
literal|0
operator|&&
name|code
operator|<
name|SYS_MAXSYSCALL
operator|)
condition|?
name|syscallnames
index|[
name|code
index|]
else|:
literal|"???"
operator|,
name|td
operator|->
name|td_locks
operator|)
argument_list|)
expr_stmt|;
name|userret
argument_list|(
name|td
argument_list|,
name|trapframe
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|code
argument_list|,
name|i
argument_list|,
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * This works because errno is findable through the 			 * register set.  If we ever support an emulation 			 * where this is not the case, this code will need 			 * to be revisited. 			 */
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCX
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|PTRACESTOP_SC
argument_list|(
name|p
argument_list|,
name|td
argument_list|,
name|S_PT_SCX
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DDB
case|case
name|T_BREAK
case|:
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|trapframe
argument_list|)
expr_stmt|;
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
endif|#
directive|endif
case|case
name|T_BREAK
operator|+
name|T_USER
case|:
block|{
name|unsigned
name|int
name|va
decl_stmt|,
name|instr
decl_stmt|;
comment|/* compute address of break instruction */
name|va
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|DELAYBRANCH
argument_list|(
name|trapframe
operator|->
name|cause
argument_list|)
condition|)
name|va
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* read break instruction */
name|instr
operator|=
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n", 			    p->p_comm, p->p_pid, instr, trapframe->pc, 			    p->p_md.md_ss_addr, p->p_md.md_ss_instr);
comment|/* XXX */
endif|#
directive|endif
if|if
condition|(
name|td
operator|->
name|td_md
operator|.
name|md_ss_addr
operator|!=
name|va
operator|||
name|instr
operator|!=
name|BREAK_SSTEP
condition|)
block|{
name|i
operator|=
name|SIGTRAP
expr_stmt|;
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
break|break;
block|}
comment|/* 			 * The restoration of the original instruction and 			 * the clearing of the berakpoint will be done later 			 * by the call to ptrace_clear_single_step() in 			 * issignal() when SIGTRAP is processed. 			 */
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
block|}
case|case
name|T_IWATCH
operator|+
name|T_USER
case|:
case|case
name|T_DWATCH
operator|+
name|T_USER
case|:
block|{
name|unsigned
name|int
name|va
decl_stmt|;
comment|/* compute address of trapped instruction */
name|va
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|DELAYBRANCH
argument_list|(
name|trapframe
operator|->
name|cause
argument_list|)
condition|)
name|va
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"watch exception @ 0x%x\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
name|addr
operator|=
name|va
expr_stmt|;
break|break;
block|}
case|case
name|T_TRAP
operator|+
name|T_USER
case|:
block|{
name|unsigned
name|int
name|va
decl_stmt|,
name|instr
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|locr0
init|=
name|td
operator|->
name|td_frame
decl_stmt|;
comment|/* compute address of trap instruction */
name|va
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|DELAYBRANCH
argument_list|(
name|trapframe
operator|->
name|cause
argument_list|)
condition|)
name|va
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* read break instruction */
name|instr
operator|=
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|DELAYBRANCH
argument_list|(
name|trapframe
operator|->
name|cause
argument_list|)
condition|)
block|{
comment|/* Check BD bit */
name|locr0
operator|->
name|pc
operator|=
name|MipsEmulateBranch
argument_list|(
name|locr0
argument_list|,
name|trapframe
operator|->
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|locr0
operator|->
name|pc
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|va
expr_stmt|;
name|i
operator|=
name|SIGEMT
expr_stmt|;
comment|/* Stuff it with something for now */
break|break;
block|}
case|case
name|T_RES_INST
operator|+
name|T_USER
case|:
name|i
operator|=
name|SIGILL
expr_stmt|;
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
break|break;
case|case
name|T_C2E
case|:
case|case
name|T_C2E
operator|+
name|T_USER
case|:
goto|goto
name|err
goto|;
break|break;
case|case
name|T_COP_UNUSABLE
case|:
goto|goto
name|err
goto|;
break|break;
case|case
name|T_COP_UNUSABLE
operator|+
name|T_USER
case|:
if|#
directive|if
name|defined
argument_list|(
name|SOFTFLOAT
argument_list|)
comment|/* FP (COP1) instruction */
if|if
condition|(
operator|(
name|trapframe
operator|->
name|cause
operator|&
name|CR_COP_ERR
operator|)
operator|==
literal|0x10000000
condition|)
block|{
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|trapframe
operator|->
name|cause
operator|&
name|CR_COP_ERR
operator|)
operator|!=
literal|0x10000000
condition|)
block|{
name|i
operator|=
name|SIGILL
expr_stmt|;
comment|/* only FPU instructions allowed */
break|break;
block|}
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
name|MipsSwitchFPState
argument_list|(
name|PCPU_GET
argument_list|(
name|fpcurthread
argument_list|)
argument_list|,
name|td
operator|->
name|td_frame
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|fpcurthread
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_frame
operator|->
name|sr
operator||=
name|SR_COP_1_BIT
expr_stmt|;
name|td
operator|->
name|td_md
operator|.
name|md_flags
operator||=
name|MDTD_FPUSED
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|T_FPE
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|DDB
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|)
name|trapDump
argument_list|(
literal|"fpintr"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"FPU Trap: PC %x CR %x SR %x\n"
argument_list|,
name|trapframe
operator|->
name|pc
argument_list|,
name|trapframe
operator|->
name|cause
argument_list|,
name|trapframe
operator|->
name|sr
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
endif|#
directive|endif
case|case
name|T_FPE
operator|+
name|T_USER
case|:
name|MachFPTrap
argument_list|(
name|trapframe
operator|->
name|sr
argument_list|,
name|trapframe
operator|->
name|cause
argument_list|,
name|trapframe
operator|->
name|pc
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|T_OVFLOW
operator|+
name|T_USER
case|:
name|i
operator|=
name|SIGFPE
expr_stmt|;
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
break|break;
case|case
name|T_ADDR_ERR_LD
case|:
comment|/* misaligned access */
case|case
name|T_ADDR_ERR_ST
case|:
comment|/* misaligned access */
ifdef|#
directive|ifdef
name|TRAP_DEBUG
name|printf
argument_list|(
literal|"+++ ADDR_ERR: type = %d, badvaddr = %x\n"
argument_list|,
name|type
argument_list|,
name|trapframe
operator|->
name|badvaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Only allow emulation on a user address */
if|if
condition|(
name|allow_unaligned_acc
operator|&&
operator|(
operator|(
name|vm_offset_t
operator|)
name|trapframe
operator|->
name|badvaddr
operator|<
name|VM_MAXUSER_ADDRESS
operator|)
condition|)
block|{
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|T_ADDR_ERR_LD
condition|)
name|mode
operator|=
name|VM_PROT_READ
expr_stmt|;
else|else
name|mode
operator|=
name|VM_PROT_WRITE
expr_stmt|;
comment|/* 			 * ADDR_ERR faults have higher priority than TLB 			 * Miss faults.  Therefore, it is necessary to 			 * verify that the faulting address is a valid 			 * virtual address within the process' address space 			 * before trying to emulate the unaligned access. 			 */
if|if
condition|(
name|useracc
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|trapframe
operator|->
name|badvaddr
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|access_type
operator|=
name|emulate_unaligned_access
argument_list|(
name|trapframe
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_type
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
block|}
block|}
block|}
comment|/* FALLTHROUGH */
case|case
name|T_BUS_ERR_LD_ST
case|:
comment|/* BERR asserted to cpu */
if|if
condition|(
operator|(
name|i
operator|=
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|)
operator|!=
literal|0
condition|)
block|{
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|onfault_table
index|[
name|i
index|]
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
default|default:
name|err
label|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|stacktrace
argument_list|(
operator|!
name|usermode
condition|?
name|trapframe
else|:
name|td
operator|->
name|td_frame
argument_list|)
expr_stmt|;
name|trapDump
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SMP
name|printf
argument_list|(
literal|"cpu:%d-"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"Trap cause = %d (%s - "
argument_list|,
name|type
argument_list|,
name|trap_type
index|[
name|type
operator|&
operator|(
operator|~
name|T_USER
operator|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|T_USER
condition|)
name|printf
argument_list|(
literal|"user mode)\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"kernel mode)\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRAP_DEBUG
name|printf
argument_list|(
literal|"badvaddr = %x, pc = %x, ra = %x, sr = 0x%x\n"
argument_list|,
name|trapframe
operator|->
name|badvaddr
argument_list|,
name|trapframe
operator|->
name|pc
argument_list|,
name|trapframe
operator|->
name|ra
argument_list|,
name|trapframe
operator|->
name|sr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|debugger_on_panic
operator|||
name|kdb_active
condition|)
block|{
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|trapframe
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_frame
operator|->
name|pc
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
name|td
operator|->
name|td_frame
operator|->
name|cause
operator|=
name|trapframe
operator|->
name|cause
expr_stmt|;
name|td
operator|->
name|td_frame
operator|->
name|badvaddr
operator|=
name|trapframe
operator|->
name|badvaddr
expr_stmt|;
name|ksiginfo_init_trap
argument_list|(
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|ksi_signo
operator|=
name|i
expr_stmt|;
name|ksi
operator|.
name|ksi_code
operator|=
name|ucode
expr_stmt|;
name|ksi
operator|.
name|ksi_addr
operator|=
operator|(
name|void
operator|*
operator|)
name|addr
expr_stmt|;
name|ksi
operator|.
name|ksi_trapno
operator|=
name|type
expr_stmt|;
name|trapsignal
argument_list|(
name|td
argument_list|,
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* 	 * Note: we should only get here if returning to user mode. 	 */
name|userret
argument_list|(
name|td
argument_list|,
name|trapframe
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|DDB
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|)
end_if

begin_function
name|void
name|trapDump
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|disableintr
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"trapDump(%s)\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TRAPSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|trp
operator|==
name|trapdebug
condition|)
block|{
name|trp
operator|=
operator|&
name|trapdebug
index|[
name|TRAPSIZE
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|trp
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|trp
operator|->
name|cause
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"%s: ADR %x PC %x CR %x SR %x\n"
argument_list|,
name|trap_type
index|[
operator|(
name|trp
operator|->
name|cause
operator|&
name|CR_EXC_CODE
operator|)
operator|>>
name|CR_EXC_CODE_SHIFT
index|]
argument_list|,
name|trp
operator|->
name|vadr
argument_list|,
name|trp
operator|->
name|pc
argument_list|,
name|trp
operator|->
name|cause
argument_list|,
name|trp
operator|->
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   RA %x SP %x code %d\n"
argument_list|,
name|trp
operator|->
name|ra
argument_list|,
name|trp
operator|->
name|sp
argument_list|,
name|trp
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
name|restoreintr
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Return the resulting PC as if the branch was executed.  */
end_comment

begin_function
name|u_int
name|MipsEmulateBranch
parameter_list|(
name|struct
name|trapframe
modifier|*
name|framePtr
parameter_list|,
name|int
name|instPC
parameter_list|,
name|int
name|fpcCSR
parameter_list|,
name|u_int
name|instptr
parameter_list|)
block|{
name|InstFmt
name|inst
decl_stmt|;
name|register_t
modifier|*
name|regsPtr
init|=
operator|(
name|register_t
operator|*
operator|)
name|framePtr
decl_stmt|;
name|unsigned
name|retAddr
init|=
literal|0
decl_stmt|;
name|int
name|condition
decl_stmt|;
define|#
directive|define
name|GetBranchDest
parameter_list|(
name|InstPtr
parameter_list|,
name|inst
parameter_list|)
define|\
value|((unsigned)InstPtr + 4 + ((short)inst.IType.imm<< 2))
if|if
condition|(
name|instptr
condition|)
block|{
if|if
condition|(
name|instptr
operator|<
name|MIPS_KSEG0_START
condition|)
name|inst
operator|.
name|word
operator|=
name|fuword
argument_list|(
operator|(
name|void
operator|*
operator|)
name|instptr
argument_list|)
expr_stmt|;
else|else
name|inst
operator|=
operator|*
operator|(
name|InstFmt
operator|*
operator|)
name|instptr
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|vm_offset_t
operator|)
name|instPC
operator|<
name|MIPS_KSEG0_START
condition|)
name|inst
operator|.
name|word
operator|=
name|fuword
argument_list|(
operator|(
name|void
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|inst
operator|=
operator|*
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
name|int
operator|)
name|inst
operator|.
name|JType
operator|.
name|op
condition|)
block|{
case|case
name|OP_SPECIAL
case|:
switch|switch
condition|(
operator|(
name|int
operator|)
name|inst
operator|.
name|RType
operator|.
name|func
condition|)
block|{
case|case
name|OP_JR
case|:
case|case
name|OP_JALR
case|:
name|retAddr
operator|=
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
expr_stmt|;
break|break;
default|default:
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OP_BCOND
case|:
switch|switch
condition|(
operator|(
name|int
operator|)
name|inst
operator|.
name|IType
operator|.
name|rt
condition|)
block|{
case|case
name|OP_BLTZ
case|:
case|case
name|OP_BLTZL
case|:
case|case
name|OP_BLTZAL
case|:
case|case
name|OP_BLTZALL
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|<
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
name|instPC
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BGEZ
case|:
case|case
name|OP_BGEZL
case|:
case|case
name|OP_BGEZAL
case|:
case|case
name|OP_BGEZALL
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|>=
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
name|instPC
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_TGEI
case|:
case|case
name|OP_TGEIU
case|:
case|case
name|OP_TLTI
case|:
case|case
name|OP_TLTIU
case|:
case|case
name|OP_TEQI
case|:
case|case
name|OP_TNEI
case|:
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
comment|/* Like syscall... */
break|break;
default|default:
name|panic
argument_list|(
literal|"MipsEmulateBranch: Bad branch cond"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_J
case|:
case|case
name|OP_JAL
case|:
name|retAddr
operator|=
operator|(
name|inst
operator|.
name|JType
operator|.
name|target
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|unsigned
operator|)
name|instPC
operator|&
literal|0xF0000000
operator|)
expr_stmt|;
break|break;
case|case
name|OP_BEQ
case|:
case|case
name|OP_BEQL
case|:
if|if
condition|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
operator|==
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rt
index|]
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
name|instPC
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BNE
case|:
case|case
name|OP_BNEL
case|:
if|if
condition|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
operator|!=
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rt
index|]
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
name|instPC
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BLEZ
case|:
case|case
name|OP_BLEZL
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|<=
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
name|instPC
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BGTZ
case|:
case|case
name|OP_BGTZL
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|>
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
name|instPC
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_COP1
case|:
switch|switch
condition|(
name|inst
operator|.
name|RType
operator|.
name|rs
condition|)
block|{
case|case
name|OP_BCx
case|:
case|case
name|OP_BCy
case|:
if|if
condition|(
operator|(
name|inst
operator|.
name|RType
operator|.
name|rt
operator|&
name|COPz_BC_TF_MASK
operator|)
operator|==
name|COPz_BC_TRUE
condition|)
name|condition
operator|=
name|fpcCSR
operator|&
name|FPC_COND_BIT
expr_stmt|;
else|else
name|condition
operator|=
operator|!
operator|(
name|fpcCSR
operator|&
name|FPC_COND_BIT
operator|)
expr_stmt|;
if|if
condition|(
name|condition
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
name|instPC
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
default|default:
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
block|}
break|break;
default|default:
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
block|}
return|return
operator|(
name|retAddr
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DDB
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG
argument_list|)
end_if

begin_define
define|#
directive|define
name|MIPS_JR_RA
value|0x03e00008
end_define

begin_comment
comment|/* instruction code for jr ra */
end_comment

begin_comment
comment|/* forward */
end_comment

begin_function_decl
name|char
modifier|*
name|fn_name
parameter_list|(
name|unsigned
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Print a stack backtrace.  */
end_comment

begin_function
name|void
name|stacktrace
parameter_list|(
name|struct
name|trapframe
modifier|*
name|regs
parameter_list|)
block|{
name|stacktrace_subr
argument_list|(
name|regs
argument_list|,
name|printf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stacktrace_subr
parameter_list|(
name|struct
name|trapframe
modifier|*
name|regs
parameter_list|,
name|int
function_decl|(
modifier|*
name|printfn
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
block|{
name|InstFmt
name|i
decl_stmt|;
name|unsigned
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|pc
decl_stmt|,
name|sp
decl_stmt|,
name|fp
decl_stmt|,
name|ra
decl_stmt|,
name|va
decl_stmt|,
name|subr
decl_stmt|;
name|unsigned
name|instr
decl_stmt|,
name|mask
decl_stmt|;
name|unsigned
name|int
name|frames
init|=
literal|0
decl_stmt|;
name|int
name|more
decl_stmt|,
name|stksize
decl_stmt|;
comment|/* get initial values from the exception frame */
name|sp
operator|=
name|regs
operator|->
name|sp
expr_stmt|;
name|pc
operator|=
name|regs
operator|->
name|pc
expr_stmt|;
name|fp
operator|=
name|regs
operator|->
name|s8
expr_stmt|;
name|ra
operator|=
name|regs
operator|->
name|ra
expr_stmt|;
comment|/* May be a 'leaf' function */
name|a0
operator|=
name|regs
operator|->
name|a0
expr_stmt|;
name|a1
operator|=
name|regs
operator|->
name|a1
expr_stmt|;
name|a2
operator|=
name|regs
operator|->
name|a2
expr_stmt|;
name|a3
operator|=
name|regs
operator|->
name|a3
expr_stmt|;
comment|/* Jump here when done with a frame, to start a new one */
name|loop
label|:
comment|/* Jump here after a nonstandard (interrupt handler) frame */
name|stksize
operator|=
literal|0
expr_stmt|;
name|subr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|frames
operator|++
operator|>
literal|100
condition|)
block|{
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"\nstackframe count exceeded\n"
argument_list|)
expr_stmt|;
comment|/* return breaks stackframe-size heuristics with gcc -O2 */
goto|goto
name|finish
goto|;
comment|/* XXX */
block|}
comment|/* check for bad SP: could foul up next frame */
if|if
condition|(
name|sp
operator|&
literal|3
operator|||
name|sp
operator|<
literal|0x80000000
condition|)
block|{
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"SP 0x%x: not in kernel\n"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|ra
operator|=
literal|0
expr_stmt|;
name|subr
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
define|#
directive|define
name|Between
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
define|\
value|( ((x)<= (y))&& ((y)< (z)) )
define|#
directive|define
name|pcBetween
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|Between((unsigned)a, pc, (unsigned)b)
comment|/* 	 * Check for current PC in  exception handler code that don't have a 	 * preceding "j ra" at the tail of the preceding function. Depends 	 * on relative ordering of functions in exception.S, swtch.S. 	 */
if|if
condition|(
name|pcBetween
argument_list|(
name|MipsKernGenException
argument_list|,
name|MipsUserGenException
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|unsigned
operator|)
name|MipsKernGenException
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|MipsUserGenException
argument_list|,
name|MipsKernIntr
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|unsigned
operator|)
name|MipsUserGenException
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|MipsKernIntr
argument_list|,
name|MipsUserIntr
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|unsigned
operator|)
name|MipsKernIntr
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|MipsUserIntr
argument_list|,
name|MipsTLBInvalidException
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|unsigned
operator|)
name|MipsUserIntr
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|MipsTLBInvalidException
argument_list|,
name|MipsKernTLBInvalidException
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|unsigned
operator|)
name|MipsTLBInvalidException
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|MipsKernTLBInvalidException
argument_list|,
name|MipsUserTLBInvalidException
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|unsigned
operator|)
name|MipsKernTLBInvalidException
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|MipsUserTLBInvalidException
argument_list|,
name|MipsTLBMissException
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|unsigned
operator|)
name|MipsUserTLBInvalidException
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|cpu_switch
argument_list|,
name|MipsSwitchFPState
argument_list|)
condition|)
name|subr
operator|=
operator|(
name|unsigned
operator|)
name|cpu_switch
expr_stmt|;
elseif|else
if|if
condition|(
name|pcBetween
argument_list|(
name|_locore
argument_list|,
name|_locoreEnd
argument_list|)
condition|)
block|{
name|subr
operator|=
operator|(
name|unsigned
operator|)
name|_locore
expr_stmt|;
name|ra
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* check for bad PC */
if|if
condition|(
name|pc
operator|&
literal|3
operator|||
name|pc
operator|<
operator|(
name|unsigned
operator|)
literal|0x80000000
operator|||
name|pc
operator|>=
operator|(
name|unsigned
operator|)
name|edata
condition|)
block|{
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"PC 0x%x: not in kernel\n"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|ra
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Find the beginning of the current subroutine by scanning 	 * backwards from the current PC for the end of the previous 	 * subroutine. 	 */
if|if
condition|(
operator|!
name|subr
condition|)
block|{
name|va
operator|=
name|pc
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|instr
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
name|va
argument_list|)
operator|)
operator|!=
name|MIPS_JR_RA
condition|)
name|va
operator|-=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|va
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* skip back over branch& delay slot */
comment|/* skip over nulls which might separate .o files */
while|while
condition|(
operator|(
name|instr
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
name|va
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|va
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|subr
operator|=
name|va
expr_stmt|;
block|}
comment|/* scan forwards to find stack size and any saved registers */
name|stksize
operator|=
literal|0
expr_stmt|;
name|more
operator|=
literal|3
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|va
operator|=
name|subr
init|;
name|more
condition|;
name|va
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|,
name|more
operator|=
operator|(
name|more
operator|==
literal|3
operator|)
condition|?
literal|3
else|:
name|more
operator|-
literal|1
control|)
block|{
comment|/* stop if hit our current position */
if|if
condition|(
name|va
operator|>=
name|pc
condition|)
break|break;
name|instr
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
name|va
argument_list|)
expr_stmt|;
name|i
operator|.
name|word
operator|=
name|instr
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|JType
operator|.
name|op
condition|)
block|{
case|case
name|OP_SPECIAL
case|:
switch|switch
condition|(
name|i
operator|.
name|RType
operator|.
name|func
condition|)
block|{
case|case
name|OP_JR
case|:
case|case
name|OP_JALR
case|:
name|more
operator|=
literal|2
expr_stmt|;
comment|/* stop after next instruction */
break|break;
case|case
name|OP_SYSCALL
case|:
case|case
name|OP_BREAK
case|:
name|more
operator|=
literal|1
expr_stmt|;
comment|/* stop now */
block|}
empty_stmt|;
break|break;
case|case
name|OP_BCOND
case|:
case|case
name|OP_J
case|:
case|case
name|OP_JAL
case|:
case|case
name|OP_BEQ
case|:
case|case
name|OP_BNE
case|:
case|case
name|OP_BLEZ
case|:
case|case
name|OP_BGTZ
case|:
name|more
operator|=
literal|2
expr_stmt|;
comment|/* stop after next instruction */
break|break;
case|case
name|OP_COP0
case|:
case|case
name|OP_COP1
case|:
case|case
name|OP_COP2
case|:
case|case
name|OP_COP3
case|:
switch|switch
condition|(
name|i
operator|.
name|RType
operator|.
name|rs
condition|)
block|{
case|case
name|OP_BCx
case|:
case|case
name|OP_BCy
case|:
name|more
operator|=
literal|2
expr_stmt|;
comment|/* stop after next instruction */
block|}
empty_stmt|;
break|break;
case|case
name|OP_SW
case|:
comment|/* look for saved registers on the stack */
if|if
condition|(
name|i
operator|.
name|IType
operator|.
name|rs
operator|!=
literal|29
condition|)
break|break;
comment|/* only restore the first one */
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|.
name|IType
operator|.
name|rt
operator|)
condition|)
break|break;
name|mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|.
name|IType
operator|.
name|rt
operator|)
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|IType
operator|.
name|rt
condition|)
block|{
case|case
literal|4
case|:
comment|/* a0 */
name|a0
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* a1 */
name|a1
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* a2 */
name|a2
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* a3 */
name|a3
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|30
case|:
comment|/* fp */
name|fp
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|31
case|:
comment|/* ra */
name|ra
operator|=
name|kdbpeek
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_SD
case|:
comment|/* look for saved registers on the stack */
if|if
condition|(
name|i
operator|.
name|IType
operator|.
name|rs
operator|!=
literal|29
condition|)
break|break;
comment|/* only restore the first one */
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|.
name|IType
operator|.
name|rt
operator|)
condition|)
break|break;
name|mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|.
name|IType
operator|.
name|rt
operator|)
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|IType
operator|.
name|rt
condition|)
block|{
case|case
literal|4
case|:
comment|/* a0 */
name|a0
operator|=
name|kdbpeekD
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* a1 */
name|a1
operator|=
name|kdbpeekD
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* a2 */
name|a2
operator|=
name|kdbpeekD
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* a3 */
name|a3
operator|=
name|kdbpeekD
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|30
case|:
comment|/* fp */
name|fp
operator|=
name|kdbpeekD
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|31
case|:
comment|/* ra */
name|ra
operator|=
name|kdbpeekD
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_ADDI
case|:
case|case
name|OP_ADDIU
case|:
comment|/* look for stack pointer adjustment */
if|if
condition|(
name|i
operator|.
name|IType
operator|.
name|rs
operator|!=
literal|29
operator|||
name|i
operator|.
name|IType
operator|.
name|rt
operator|!=
literal|29
condition|)
break|break;
name|stksize
operator|=
operator|-
operator|(
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
operator|)
expr_stmt|;
block|}
block|}
name|done
label|:
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"%s+%x (%x,%x,%x,%x) ra %x sz %d\n"
argument_list|,
name|fn_name
argument_list|(
name|subr
argument_list|)
argument_list|,
name|pc
operator|-
name|subr
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|ra
argument_list|,
name|stksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ra
condition|)
block|{
if|if
condition|(
name|pc
operator|==
name|ra
operator|&&
name|stksize
operator|==
literal|0
condition|)
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"stacktrace: loop!\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|pc
operator|=
name|ra
expr_stmt|;
name|sp
operator|+=
name|stksize
expr_stmt|;
name|ra
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
else|else
block|{
name|finish
label|:
if|if
condition|(
name|curproc
condition|)
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"pid %d\n"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|printfn
call|)
argument_list|(
literal|"curproc NULL\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Functions ``special'' enough to print by name  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|Name
parameter_list|(
name|_fn
parameter_list|)
value|{ (void*)_fn, # _fn }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Name
parameter_list|(
name|_fn
parameter_list|)
value|{ _fn, "_fn"}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
struct|struct
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|names
index|[]
init|=
block|{
name|Name
argument_list|(
name|trap
argument_list|)
block|,
name|Name
argument_list|(
name|MipsKernGenException
argument_list|)
block|,
name|Name
argument_list|(
name|MipsUserGenException
argument_list|)
block|,
name|Name
argument_list|(
name|MipsKernIntr
argument_list|)
block|,
name|Name
argument_list|(
name|MipsUserIntr
argument_list|)
block|,
name|Name
argument_list|(
name|cpu_switch
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Map a function address to a string name, if known; or a hex string.  */
end_comment

begin_function
name|char
modifier|*
name|fn_name
parameter_list|(
name|unsigned
name|addr
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|17
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DDB
name|db_expr_t
name|diff
decl_stmt|;
name|c_db_sym_t
name|sym
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
name|diff
operator|=
literal|0
expr_stmt|;
name|symname
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|db_search_symbol
argument_list|(
operator|(
name|db_addr_t
operator|)
name|addr
argument_list|,
name|DB_STGY_ANY
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|db_symbol_values
argument_list|(
name|sym
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|symname
argument_list|,
operator|(
name|db_expr_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|symname
operator|&&
name|diff
operator|==
literal|0
condition|)
return|return
operator|(
name|symname
operator|)
return|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|names
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|names
index|[
name|i
index|]
operator|.
name|addr
operator|==
operator|(
name|void
operator|*
operator|)
name|addr
condition|)
return|return
operator|(
name|names
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

begin_function
specifier|static
name|void
name|log_frame_dump
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Trapframe Register Dump:\n"
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tzero: %08x\tat: %08x\tv0: %08x\tv1: %08x\n"
argument_list|,
literal|0
argument_list|,
name|frame
operator|->
name|ast
argument_list|,
name|frame
operator|->
name|v0
argument_list|,
name|frame
operator|->
name|v1
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\ta0: %08x\ta1: %08x\ta2: %08x\ta3: %08x\n"
argument_list|,
name|frame
operator|->
name|a0
argument_list|,
name|frame
operator|->
name|a1
argument_list|,
name|frame
operator|->
name|a2
argument_list|,
name|frame
operator|->
name|a3
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tt0: %08x\tt1: %08x\tt2: %08x\tt3: %08x\n"
argument_list|,
name|frame
operator|->
name|t0
argument_list|,
name|frame
operator|->
name|t1
argument_list|,
name|frame
operator|->
name|t2
argument_list|,
name|frame
operator|->
name|t3
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tt4: %08x\tt5: %08x\tt6: %08x\tt7: %08x\n"
argument_list|,
name|frame
operator|->
name|t4
argument_list|,
name|frame
operator|->
name|t5
argument_list|,
name|frame
operator|->
name|t6
argument_list|,
name|frame
operator|->
name|t7
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tt8: %08x\tt9: %08x\ts0: %08x\ts1: %08x\n"
argument_list|,
name|frame
operator|->
name|t8
argument_list|,
name|frame
operator|->
name|t9
argument_list|,
name|frame
operator|->
name|s0
argument_list|,
name|frame
operator|->
name|s1
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\ts2: %08x\ts3: %08x\ts4: %08x\ts5: %08x\n"
argument_list|,
name|frame
operator|->
name|s2
argument_list|,
name|frame
operator|->
name|s3
argument_list|,
name|frame
operator|->
name|s4
argument_list|,
name|frame
operator|->
name|s5
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\ts6: %08x\ts7: %08x\tk0: %08x\tk1: %08x\n"
argument_list|,
name|frame
operator|->
name|s6
argument_list|,
name|frame
operator|->
name|s7
argument_list|,
name|frame
operator|->
name|k0
argument_list|,
name|frame
operator|->
name|k1
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tgp: %08x\tsp: %08x\ts8: %08x\tra: %08x\n"
argument_list|,
name|frame
operator|->
name|gp
argument_list|,
name|frame
operator|->
name|sp
argument_list|,
name|frame
operator|->
name|s8
argument_list|,
name|frame
operator|->
name|ra
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tsr: %08x\tmullo: %08x\tmulhi: %08x\tbadvaddr: %08x\n"
argument_list|,
name|frame
operator|->
name|sr
argument_list|,
name|frame
operator|->
name|mullo
argument_list|,
name|frame
operator|->
name|mulhi
argument_list|,
name|frame
operator|->
name|badvaddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IC_REG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tcause: %08x\tpc: %08x\tic: %08x\n"
argument_list|,
name|frame
operator|->
name|cause
argument_list|,
name|frame
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|ic
argument_list|)
expr_stmt|;
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tcause: %08x\tpc: %08x\n"
argument_list|,
name|frame
operator|->
name|cause
argument_list|,
name|frame
operator|->
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TRAP_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|trap_frame_dump
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Trapframe Register Dump:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tzero: %08x\tat: %08x\tv0: %08x\tv1: %08x\n"
argument_list|,
literal|0
argument_list|,
name|frame
operator|->
name|ast
argument_list|,
name|frame
operator|->
name|v0
argument_list|,
name|frame
operator|->
name|v1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ta0: %08x\ta1: %08x\ta2: %08x\ta3: %08x\n"
argument_list|,
name|frame
operator|->
name|a0
argument_list|,
name|frame
operator|->
name|a1
argument_list|,
name|frame
operator|->
name|a2
argument_list|,
name|frame
operator|->
name|a3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tt0: %08x\tt1: %08x\tt2: %08x\tt3: %08x\n"
argument_list|,
name|frame
operator|->
name|t0
argument_list|,
name|frame
operator|->
name|t1
argument_list|,
name|frame
operator|->
name|t2
argument_list|,
name|frame
operator|->
name|t3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tt4: %08x\tt5: %08x\tt6: %08x\tt7: %08x\n"
argument_list|,
name|frame
operator|->
name|t4
argument_list|,
name|frame
operator|->
name|t5
argument_list|,
name|frame
operator|->
name|t6
argument_list|,
name|frame
operator|->
name|t7
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tt8: %08x\tt9: %08x\ts0: %08x\ts1: %08x\n"
argument_list|,
name|frame
operator|->
name|t8
argument_list|,
name|frame
operator|->
name|t9
argument_list|,
name|frame
operator|->
name|s0
argument_list|,
name|frame
operator|->
name|s1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ts2: %08x\ts3: %08x\ts4: %08x\ts5: %08x\n"
argument_list|,
name|frame
operator|->
name|s2
argument_list|,
name|frame
operator|->
name|s3
argument_list|,
name|frame
operator|->
name|s4
argument_list|,
name|frame
operator|->
name|s5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ts6: %08x\ts7: %08x\tk0: %08x\tk1: %08x\n"
argument_list|,
name|frame
operator|->
name|s6
argument_list|,
name|frame
operator|->
name|s7
argument_list|,
name|frame
operator|->
name|k0
argument_list|,
name|frame
operator|->
name|k1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tgp: %08x\tsp: %08x\ts8: %08x\tra: %08x\n"
argument_list|,
name|frame
operator|->
name|gp
argument_list|,
name|frame
operator|->
name|sp
argument_list|,
name|frame
operator|->
name|s8
argument_list|,
name|frame
operator|->
name|ra
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tsr: %08x\tmullo: %08x\tmulhi: %08x\tbadvaddr: %08x\n"
argument_list|,
name|frame
operator|->
name|sr
argument_list|,
name|frame
operator|->
name|mullo
argument_list|,
name|frame
operator|->
name|mulhi
argument_list|,
name|frame
operator|->
name|badvaddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IC_REG
name|printf
argument_list|(
literal|"\tcause: %08x\tpc: %08x\tic: %08x\n"
argument_list|,
name|frame
operator|->
name|cause
argument_list|,
name|frame
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|ic
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"\tcause: %08x\tpc: %08x\n"
argument_list|,
name|frame
operator|->
name|cause
argument_list|,
name|frame
operator|->
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|get_mapping_info
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
modifier|*
modifier|*
name|pdepp
parameter_list|,
name|pt_entry_t
modifier|*
modifier|*
name|ptepp
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|pd_entry_t
modifier|*
name|pdep
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|pdep
operator|=
operator|(
operator|&
operator|(
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|.
name|pm_segtab
index|[
name|va
operator|>>
name|SEGSHIFT
index|]
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|pdep
condition|)
name|ptep
operator|=
name|pmap_pte
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
else|else
name|ptep
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
literal|0
expr_stmt|;
operator|*
name|pdepp
operator|=
name|pdep
expr_stmt|;
operator|*
name|ptepp
operator|=
name|ptep
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|log_bad_page_fault
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|,
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|,
name|int
name|trap_type
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|pd_entry_t
modifier|*
name|pdep
decl_stmt|;
name|unsigned
name|int
modifier|*
name|addr
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|char
modifier|*
name|read_or_write
decl_stmt|;
name|register_t
name|pc
decl_stmt|;
name|trap_type
operator|&=
operator|~
name|T_USER
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|printf
argument_list|(
literal|"cpuid = %d\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|trap_type
condition|)
block|{
case|case
name|T_TLB_ST_MISS
case|:
case|case
name|T_ADDR_ERR_ST
case|:
name|read_or_write
operator|=
literal|"write"
expr_stmt|;
break|break;
case|case
name|T_TLB_LD_MISS
case|:
case|case
name|T_ADDR_ERR_LD
case|:
case|case
name|T_BUS_ERR_IFETCH
case|:
name|read_or_write
operator|=
literal|"read"
expr_stmt|;
break|break;
default|default:
name|read_or_write
operator|=
literal|""
expr_stmt|;
block|}
name|pc
operator|=
name|frame
operator|->
name|pc
operator|+
operator|(
name|DELAYBRANCH
argument_list|(
name|frame
operator|->
name|cause
argument_list|)
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: pid %d (%s), uid %d: pc 0x%x got a %s fault at 0x%x\n"
argument_list|,
name|msg
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_ucred
condition|?
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
else|:
operator|-
literal|1
argument_list|,
name|pc
argument_list|,
name|read_or_write
argument_list|,
name|frame
operator|->
name|badvaddr
argument_list|)
expr_stmt|;
comment|/* log registers in trap frame */
name|log_frame_dump
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|get_mapping_info
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|,
operator|&
name|pdep
argument_list|,
operator|&
name|ptep
argument_list|)
expr_stmt|;
comment|/* 	 * Dump a few words around faulting instruction, if the addres is 	 * valid. 	 */
if|if
condition|(
operator|!
operator|(
name|pc
operator|&
literal|3
operator|)
operator|&&
operator|(
name|pc
operator|!=
name|frame
operator|->
name|badvaddr
operator|)
operator|&&
operator|(
name|trap_type
operator|!=
name|T_BUS_ERR_IFETCH
operator|)
operator|&&
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|4
argument_list|,
name|VM_PROT_READ
argument_list|)
condition|)
block|{
comment|/* dump page table entry for faulting instruction */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Page table info for pc address 0x%x: pde = %p, pte = 0x%lx\n"
argument_list|,
name|pc
argument_list|,
operator|*
name|pdep
argument_list|,
name|ptep
condition|?
operator|*
name|ptep
else|:
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|pc
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Dumping 4 words starting at pc address %p: \n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%08x %08x %08x %08x\n"
argument_list|,
name|addr
index|[
literal|0
index|]
argument_list|,
name|addr
index|[
literal|1
index|]
argument_list|,
name|addr
index|[
literal|2
index|]
argument_list|,
name|addr
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pc address 0x%x is inaccessible, pde = 0x%p, pte = 0x%lx\n"
argument_list|,
name|pc
argument_list|,
operator|*
name|pdep
argument_list|,
name|ptep
condition|?
operator|*
name|ptep
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*	panic("Bad trap");*/
block|}
end_function

begin_comment
comment|/*  * Unaligned load/store emulation  */
end_comment

begin_function
specifier|static
name|int
name|mips_unaligned_load_store
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|,
name|register_t
name|addr
parameter_list|,
name|register_t
name|pc
parameter_list|)
block|{
name|register_t
modifier|*
name|reg
init|=
operator|(
name|register_t
operator|*
operator|)
name|frame
decl_stmt|;
name|u_int32_t
name|inst
init|=
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|pc
operator|)
decl_stmt|;
name|u_int32_t
name|value_msb
decl_stmt|,
name|value
decl_stmt|;
name|int
name|access_type
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|MIPS_INST_OPCODE
argument_list|(
name|inst
argument_list|)
condition|)
block|{
case|case
name|OP_LHU
case|:
name|lbu_macro
argument_list|(
name|value_msb
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
name|lbu_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|value
operator||=
name|value_msb
operator|<<
literal|8
expr_stmt|;
name|reg
index|[
name|MIPS_INST_RT
argument_list|(
name|inst
argument_list|)
index|]
operator|=
name|value
expr_stmt|;
name|access_type
operator|=
name|MIPS_LHU_ACCESS
expr_stmt|;
break|break;
case|case
name|OP_LH
case|:
name|lb_macro
argument_list|(
name|value_msb
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
name|lbu_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|value
operator||=
name|value_msb
operator|<<
literal|8
expr_stmt|;
name|reg
index|[
name|MIPS_INST_RT
argument_list|(
name|inst
argument_list|)
index|]
operator|=
name|value
expr_stmt|;
name|access_type
operator|=
name|MIPS_LH_ACCESS
expr_stmt|;
break|break;
case|case
name|OP_LWU
case|:
name|lwl_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|3
expr_stmt|;
name|lwr_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|value
operator|&=
literal|0xffffffff
expr_stmt|;
name|reg
index|[
name|MIPS_INST_RT
argument_list|(
name|inst
argument_list|)
index|]
operator|=
name|value
expr_stmt|;
name|access_type
operator|=
name|MIPS_LWU_ACCESS
expr_stmt|;
break|break;
case|case
name|OP_LW
case|:
name|lwl_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|3
expr_stmt|;
name|lwr_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|reg
index|[
name|MIPS_INST_RT
argument_list|(
name|inst
argument_list|)
index|]
operator|=
name|value
expr_stmt|;
name|access_type
operator|=
name|MIPS_LW_ACCESS
expr_stmt|;
break|break;
case|case
name|OP_SH
case|:
name|value
operator|=
name|reg
index|[
name|MIPS_INST_RT
argument_list|(
name|inst
argument_list|)
index|]
expr_stmt|;
name|value_msb
operator|=
name|value
operator|>>
literal|8
expr_stmt|;
name|sb_macro
argument_list|(
name|value_msb
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
name|sb_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|access_type
operator|=
name|MIPS_SH_ACCESS
expr_stmt|;
break|break;
case|case
name|OP_SW
case|:
name|value
operator|=
name|reg
index|[
name|MIPS_INST_RT
argument_list|(
name|inst
argument_list|)
index|]
expr_stmt|;
name|swl_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|3
expr_stmt|;
name|swr_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|access_type
operator|=
name|MIPS_SW_ACCESS
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|access_type
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_unaligned_access
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|register_t
name|pc
decl_stmt|;
name|int
name|access_type
init|=
literal|0
decl_stmt|;
name|pc
operator|=
name|frame
operator|->
name|pc
operator|+
operator|(
name|DELAYBRANCH
argument_list|(
name|frame
operator|->
name|cause
argument_list|)
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
comment|/* 	 * Fall through if it's instruction fetch exception 	 */
if|if
condition|(
operator|!
operator|(
operator|(
name|pc
operator|&
literal|3
operator|)
operator|||
operator|(
name|pc
operator|==
name|frame
operator|->
name|badvaddr
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Handle unaligned load and store 		 */
comment|/* 		 * Return access type if the instruction was emulated. 		 * Otherwise restore pc and fall through. 		 */
name|access_type
operator|=
name|mips_unaligned_load_store
argument_list|(
name|frame
argument_list|,
name|frame
operator|->
name|badvaddr
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_type
condition|)
block|{
if|if
condition|(
name|DELAYBRANCH
argument_list|(
name|frame
operator|->
name|cause
argument_list|)
condition|)
name|frame
operator|->
name|pc
operator|=
name|MipsEmulateBranch
argument_list|(
name|frame
argument_list|,
name|frame
operator|->
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|frame
operator|->
name|pc
operator|+=
literal|4
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Unaligned %s: pc=0x%x, badvaddr=0x%x\n"
argument_list|,
name|access_name
index|[
name|access_type
operator|-
literal|1
index|]
argument_list|,
name|pc
argument_list|,
name|frame
operator|->
name|badvaddr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|access_type
return|;
block|}
end_function

end_unit

