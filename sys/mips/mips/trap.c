begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: trap.c,v 1.19 1998/09/30 12:40:41 pefo Exp $	*/
end_comment

begin_comment
comment|/* tracked to 1.23 */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and Ralph Campbell.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * from: Utah Hdr: trap.c 1.32 91/04/06  *  *	from: @(#)trap.c	8.5 (Berkeley) 1/11/94  *	JNPR: trap.c,v 1.13.2.2 2007/08/29 10:03:49 girish  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<machine/trap.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/mips_opcode.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/regnum.h>
end_include

begin_include
include|#
directive|include
file|<machine/tls.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<machine/db_machdep.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
end_ifdef

begin_include
include|#
directive|include
file|<sys/dtrace_bsd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TRAP_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|trap_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|trap_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|trap_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug information on all traps"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|lbu_macro
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
define|\
value|__asm __volatile ("lbu %0, 0x0(%1)"				\ 			: "=r" (data)
comment|/* outputs */
value|\ 			: "r" (addr));
end_define

begin_comment
comment|/* inputs */
end_comment

begin_define
define|#
directive|define
name|lb_macro
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
define|\
value|__asm __volatile ("lb %0, 0x0(%1)"				\ 			: "=r" (data)
comment|/* outputs */
value|\ 			: "r" (addr));
end_define

begin_comment
comment|/* inputs */
end_comment

begin_define
define|#
directive|define
name|lwl_macro
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
define|\
value|__asm __volatile ("lwl %0, 0x0(%1)"				\ 			: "=r" (data)
comment|/* outputs */
value|\ 			: "r" (addr));
end_define

begin_comment
comment|/* inputs */
end_comment

begin_define
define|#
directive|define
name|lwr_macro
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
define|\
value|__asm __volatile ("lwr %0, 0x0(%1)"				\ 			: "=r" (data)
comment|/* outputs */
value|\ 			: "r" (addr));
end_define

begin_comment
comment|/* inputs */
end_comment

begin_define
define|#
directive|define
name|ldl_macro
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
define|\
value|__asm __volatile ("ldl %0, 0x0(%1)"				\ 			: "=r" (data)
comment|/* outputs */
value|\ 			: "r" (addr));
end_define

begin_comment
comment|/* inputs */
end_comment

begin_define
define|#
directive|define
name|ldr_macro
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
define|\
value|__asm __volatile ("ldr %0, 0x0(%1)"				\ 			: "=r" (data)
comment|/* outputs */
value|\ 			: "r" (addr));
end_define

begin_comment
comment|/* inputs */
end_comment

begin_define
define|#
directive|define
name|sb_macro
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
define|\
value|__asm __volatile ("sb %0, 0x0(%1)"				\ 			:
comment|/* outputs */
value|\ 			: "r" (data), "r" (addr));
end_define

begin_comment
comment|/* inputs */
end_comment

begin_define
define|#
directive|define
name|swl_macro
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
define|\
value|__asm __volatile ("swl %0, 0x0(%1)"				\ 			:
comment|/* outputs */
value|\ 			: "r" (data), "r" (addr));
end_define

begin_comment
comment|/* inputs */
end_comment

begin_define
define|#
directive|define
name|swr_macro
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
define|\
value|__asm __volatile ("swr %0, 0x0(%1)"				\ 			:
comment|/* outputs */
value|\ 			: "r" (data), "r" (addr));
end_define

begin_comment
comment|/* inputs */
end_comment

begin_define
define|#
directive|define
name|sdl_macro
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
define|\
value|__asm __volatile ("sdl %0, 0x0(%1)"				\ 			:
comment|/* outputs */
value|\ 			: "r" (data), "r" (addr));
end_define

begin_comment
comment|/* inputs */
end_comment

begin_define
define|#
directive|define
name|sdr_macro
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
define|\
value|__asm __volatile ("sdr %0, 0x0(%1)"				\ 			:
comment|/* outputs */
value|\ 			: "r" (data), "r" (addr));
end_define

begin_comment
comment|/* inputs */
end_comment

begin_function_decl
specifier|static
name|void
name|log_illegal_instruction
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|trapframe
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|log_bad_page_fault
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|trapframe
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|log_frame_dump
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_mapping_info
parameter_list|(
name|vm_offset_t
parameter_list|,
name|pd_entry_t
modifier|*
modifier|*
parameter_list|,
name|pt_entry_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|dtrace_invop_jump_addr
function_decl|)
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|TRAP_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|trap_frame_dump
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
function_decl|(
modifier|*
name|machExceptionTable
index|[]
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
block|{
comment|/*  * The kernel exception handlers.  */
name|MipsKernIntr
operator|,
comment|/* external interrupt */
function_decl|MipsKernGenException
operator|,
comment|/* TLB modification */
function_decl|MipsTLBInvalidException
operator|,
comment|/* TLB miss (load or instr. fetch) */
function_decl|MipsTLBInvalidException
operator|,
comment|/* TLB miss (store) */
function_decl|MipsKernGenException
operator|,
comment|/* address error (load or I-fetch) */
function_decl|MipsKernGenException
operator|,
comment|/* address error (store) */
function_decl|MipsKernGenException
operator|,
comment|/* bus error (I-fetch) */
function_decl|MipsKernGenException
operator|,
comment|/* bus error (load or store) */
function_decl|MipsKernGenException
operator|,
comment|/* system call */
function_decl|MipsKernGenException
operator|,
comment|/* breakpoint */
function_decl|MipsKernGenException
operator|,
comment|/* reserved instruction */
function_decl|MipsKernGenException
operator|,
comment|/* coprocessor unusable */
function_decl|MipsKernGenException
operator|,
comment|/* arithmetic overflow */
function_decl|MipsKernGenException
operator|,
comment|/* trap exception */
function_decl|MipsKernGenException
operator|,
comment|/* virtual coherence exception inst */
function_decl|MipsKernGenException
operator|,
comment|/* floating point exception */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* watch exception */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* reserved */
function_decl|MipsKernGenException
operator|,
comment|/* virtual coherence exception data */
comment|/*  * The user exception handlers.  */
function_decl|MipsUserIntr
operator|,
comment|/* 0 */
function_decl|MipsUserGenException
operator|,
comment|/* 1 */
function_decl|MipsTLBInvalidException
operator|,
comment|/* 2 */
function_decl|MipsTLBInvalidException
operator|,
comment|/* 3 */
function_decl|MipsUserGenException
operator|,
comment|/* 4 */
function_decl|MipsUserGenException
operator|,
comment|/* 5 */
function_decl|MipsUserGenException
operator|,
comment|/* 6 */
function_decl|MipsUserGenException
operator|,
comment|/* 7 */
function_decl|MipsUserGenException
operator|,
comment|/* 8 */
function_decl|MipsUserGenException
operator|,
comment|/* 9 */
function_decl|MipsUserGenException
operator|,
comment|/* 10 */
function_decl|MipsUserGenException
operator|,
comment|/* 11 */
function_decl|MipsUserGenException
operator|,
comment|/* 12 */
function_decl|MipsUserGenException
operator|,
comment|/* 13 */
function_decl|MipsUserGenException
operator|,
comment|/* 14 */
function_decl|MipsUserGenException
operator|,
comment|/* 15 */
function_decl|MipsUserGenException
operator|,
comment|/* 16 */
function_decl|MipsUserGenException
operator|,
comment|/* 17 */
function_decl|MipsUserGenException
operator|,
comment|/* 18 */
function_decl|MipsUserGenException
operator|,
comment|/* 19 */
function_decl|MipsUserGenException
operator|,
comment|/* 20 */
function_decl|MipsUserGenException
operator|,
comment|/* 21 */
function_decl|MipsUserGenException
operator|,
comment|/* 22 */
function_decl|MipsUserGenException
operator|,
comment|/* 23 */
function_decl|MipsUserGenException
operator|,
comment|/* 24 */
function_decl|MipsUserGenException
operator|,
comment|/* 25 */
function_decl|MipsUserGenException
operator|,
comment|/* 26 */
function_decl|MipsUserGenException
operator|,
comment|/* 27 */
function_decl|MipsUserGenException
operator|,
comment|/* 28 */
function_decl|MipsUserGenException
operator|,
comment|/* 29 */
function_decl|MipsUserGenException
operator|,
comment|/* 20 */
function_decl|MipsUserGenException
operator|,
end_function_decl

begin_comment
comment|/* 31 */
end_comment

begin_decl_stmt
unit|};
name|char
modifier|*
name|trap_type
index|[]
init|=
block|{
literal|"external interrupt"
block|,
literal|"TLB modification"
block|,
literal|"TLB miss (load or instr. fetch)"
block|,
literal|"TLB miss (store)"
block|,
literal|"address error (load or I-fetch)"
block|,
literal|"address error (store)"
block|,
literal|"bus error (I-fetch)"
block|,
literal|"bus error (load or store)"
block|,
literal|"system call"
block|,
literal|"breakpoint"
block|,
literal|"reserved instruction"
block|,
literal|"coprocessor unusable"
block|,
literal|"arithmetic overflow"
block|,
literal|"trap"
block|,
literal|"virtual coherency instruction"
block|,
literal|"floating point"
block|,
literal|"reserved 16"
block|,
literal|"reserved 17"
block|,
literal|"reserved 18"
block|,
literal|"reserved 19"
block|,
literal|"reserved 20"
block|,
literal|"reserved 21"
block|,
literal|"reserved 22"
block|,
literal|"watch"
block|,
literal|"reserved 24"
block|,
literal|"reserved 25"
block|,
literal|"reserved 26"
block|,
literal|"reserved 27"
block|,
literal|"reserved 28"
block|,
literal|"reserved 29"
block|,
literal|"reserved 30"
block|,
literal|"virtual coherency data"
block|, }
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|DDB
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|)
end_if

begin_decl_stmt
name|struct
name|trapdebug
name|trapdebug
index|[
name|TRAPSIZE
index|]
decl_stmt|,
modifier|*
name|trp
init|=
name|trapdebug
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DDB
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG
argument_list|)
end_if

begin_function_decl
name|void
name|stacktrace
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|logstacktrace
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|KERNLAND
parameter_list|(
name|x
parameter_list|)
value|((vm_offset_t)(x)>= VM_MIN_KERNEL_ADDRESS&& (vm_offset_t)(x)< VM_MAX_KERNEL_ADDRESS)
end_define

begin_define
define|#
directive|define
name|DELAYBRANCH
parameter_list|(
name|x
parameter_list|)
value|((int)(x)< 0)
end_define

begin_comment
comment|/*  * MIPS load/store access type  */
end_comment

begin_enum
enum|enum
block|{
name|MIPS_LHU_ACCESS
init|=
literal|1
block|,
name|MIPS_LH_ACCESS
block|,
name|MIPS_LWU_ACCESS
block|,
name|MIPS_LW_ACCESS
block|,
name|MIPS_LD_ACCESS
block|,
name|MIPS_SH_ACCESS
block|,
name|MIPS_SW_ACCESS
block|,
name|MIPS_SD_ACCESS
block|}
enum|;
end_enum

begin_decl_stmt
name|char
modifier|*
name|access_name
index|[]
init|=
block|{
literal|"Load Halfword Unsigned"
block|,
literal|"Load Halfword"
block|,
literal|"Load Word Unsigned"
block|,
literal|"Load Word"
block|,
literal|"Load Doubleword"
block|,
literal|"Store Halfword"
block|,
literal|"Store Word"
block|,
literal|"Store Doubleword"
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_CNMIPS
end_ifdef

begin_include
include|#
directive|include
file|<machine/octeon_cop2.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|allow_unaligned_acc
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|allow_unaligned_acc
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|allow_unaligned_acc
argument_list|,
literal|0
argument_list|,
literal|"Allow unaligned accesses"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * FP emulation is assumed to work on O32, but the code is outdated and crufty  * enough that it's a more sensible default to have it disabled when using  * other ABIs.  At the very least, it needs a lot of help in using  * type-semantic ABI-oblivious macros for everything it does.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__mips_o32
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|emulate_fp
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|emulate_fp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|emulate_fp
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|emulate_fp
argument_list|,
literal|0
argument_list|,
literal|"Emulate unimplemented FPU instructions"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|emulate_unaligned_access
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fswintrberr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* XXX */
end_comment

begin_function
name|int
name|cpu_fetch_syscall_args
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|trapframe
modifier|*
name|locr0
decl_stmt|;
name|struct
name|sysentvec
modifier|*
name|se
decl_stmt|;
name|struct
name|syscall_args
modifier|*
name|sa
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nsaved
decl_stmt|;
name|locr0
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
name|sa
operator|=
operator|&
name|td
operator|->
name|td_sa
expr_stmt|;
name|bzero
argument_list|(
name|sa
operator|->
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compute next PC after syscall instruction */
name|td
operator|->
name|td_pcb
operator|->
name|pcb_tpc
operator|=
name|sa
operator|->
name|trapframe
operator|->
name|pc
expr_stmt|;
comment|/* Remember if restart */
if|if
condition|(
name|DELAYBRANCH
argument_list|(
name|sa
operator|->
name|trapframe
operator|->
name|cause
argument_list|)
condition|)
comment|/* Check BD bit */
name|locr0
operator|->
name|pc
operator|=
name|MipsEmulateBranch
argument_list|(
name|locr0
argument_list|,
name|sa
operator|->
name|trapframe
operator|->
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|locr0
operator|->
name|pc
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|sa
operator|->
name|code
operator|=
name|locr0
operator|->
name|v0
expr_stmt|;
switch|switch
condition|(
name|sa
operator|->
name|code
condition|)
block|{
case|case
name|SYS___syscall
case|:
case|case
name|SYS_syscall
case|:
comment|/* 		 * This is an indirect syscall, in which the code is the first argument. 		 */
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|__mips_n32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__mips_n64
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD32
argument_list|)
if|if
condition|(
name|sa
operator|->
name|code
operator|==
name|SYS___syscall
operator|&&
name|SV_PROC_FLAG
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|SV_ILP32
argument_list|)
condition|)
block|{
comment|/* 			 * Like syscall, but code is a quad, so as to maintain alignment 			 * for the rest of the arguments. 			 */
if|if
condition|(
name|_QUAD_LOWWORD
operator|==
literal|0
condition|)
name|sa
operator|->
name|code
operator|=
name|locr0
operator|->
name|a0
expr_stmt|;
else|else
name|sa
operator|->
name|code
operator|=
name|locr0
operator|->
name|a1
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|0
index|]
operator|=
name|locr0
operator|->
name|a2
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|1
index|]
operator|=
name|locr0
operator|->
name|a3
expr_stmt|;
name|nsaved
operator|=
literal|2
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* 		 * This is either not a quad syscall, or is a quad syscall with a 		 * new ABI in which quads fit in a single register. 		 */
name|sa
operator|->
name|code
operator|=
name|locr0
operator|->
name|a0
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|0
index|]
operator|=
name|locr0
operator|->
name|a1
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|1
index|]
operator|=
name|locr0
operator|->
name|a2
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|2
index|]
operator|=
name|locr0
operator|->
name|a3
expr_stmt|;
name|nsaved
operator|=
literal|3
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__mips_n32
argument_list|)
operator|||
name|defined
argument_list|(
name|__mips_n64
argument_list|)
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
operator|!
name|SV_PROC_FLAG
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|SV_ILP32
argument_list|)
condition|)
block|{
endif|#
directive|endif
comment|/* 			 * Non-o32 ABIs support more arguments in registers. 			 */
name|sa
operator|->
name|args
index|[
literal|3
index|]
operator|=
name|locr0
operator|->
name|a4
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|4
index|]
operator|=
name|locr0
operator|->
name|a5
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|5
index|]
operator|=
name|locr0
operator|->
name|a6
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|6
index|]
operator|=
name|locr0
operator|->
name|a7
expr_stmt|;
name|nsaved
operator|+=
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
block|}
endif|#
directive|endif
endif|#
directive|endif
break|break;
default|default:
comment|/* 		 * A direct syscall, arguments are just parameters to the syscall. 		 */
name|sa
operator|->
name|args
index|[
literal|0
index|]
operator|=
name|locr0
operator|->
name|a0
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|1
index|]
operator|=
name|locr0
operator|->
name|a1
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|2
index|]
operator|=
name|locr0
operator|->
name|a2
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|3
index|]
operator|=
name|locr0
operator|->
name|a3
expr_stmt|;
name|nsaved
operator|=
literal|4
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__mips_n32
argument_list|)
operator|||
name|defined
argument_list|(
name|__mips_n64
argument_list|)
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
operator|!
name|SV_PROC_FLAG
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|SV_ILP32
argument_list|)
condition|)
block|{
endif|#
directive|endif
comment|/* 			 * Non-o32 ABIs support more arguments in registers. 			 */
name|sa
operator|->
name|args
index|[
literal|4
index|]
operator|=
name|locr0
operator|->
name|a4
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|5
index|]
operator|=
name|locr0
operator|->
name|a5
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|6
index|]
operator|=
name|locr0
operator|->
name|a6
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|7
index|]
operator|=
name|locr0
operator|->
name|a7
expr_stmt|;
name|nsaved
operator|+=
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
block|}
endif|#
directive|endif
endif|#
directive|endif
break|break;
block|}
ifdef|#
directive|ifdef
name|TRAP_DEBUG
if|if
condition|(
name|trap_debug
condition|)
name|printf
argument_list|(
literal|"SYSCALL #%d pid:%u\n"
argument_list|,
name|sa
operator|->
name|code
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|se
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_sysent
expr_stmt|;
comment|/* 	 * XXX 	 * Shouldn't this go before switching on the code? 	 */
if|if
condition|(
name|se
operator|->
name|sv_mask
condition|)
name|sa
operator|->
name|code
operator|&=
name|se
operator|->
name|sv_mask
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|code
operator|>=
name|se
operator|->
name|sv_size
condition|)
name|sa
operator|->
name|callp
operator|=
operator|&
name|se
operator|->
name|sv_table
index|[
literal|0
index|]
expr_stmt|;
else|else
name|sa
operator|->
name|callp
operator|=
operator|&
name|se
operator|->
name|sv_table
index|[
name|sa
operator|->
name|code
index|]
expr_stmt|;
name|sa
operator|->
name|narg
operator|=
name|sa
operator|->
name|callp
operator|->
name|sy_narg
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|narg
operator|>
name|nsaved
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__mips_n32
argument_list|)
operator|||
name|defined
argument_list|(
name|__mips_n64
argument_list|)
comment|/* 		 * XXX 		 * Is this right for new ABIs?  I think the 4 there 		 * should be 8, size there are 8 registers to skip, 		 * not 4, but I'm not certain. 		 */
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
operator|!
name|SV_PROC_FLAG
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|SV_ILP32
argument_list|)
condition|)
endif|#
directive|endif
name|printf
argument_list|(
literal|"SYSCALL #%u pid:%u, narg (%u)> nsaved (%u).\n"
argument_list|,
name|sa
operator|->
name|code
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|sa
operator|->
name|narg
argument_list|,
name|nsaved
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__mips_n32
argument_list|)
operator|||
name|defined
argument_list|(
name|__mips_n64
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|COMPAT_FREEBSD32
argument_list|)
if|if
condition|(
name|SV_PROC_FLAG
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|SV_ILP32
argument_list|)
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|int32_t
name|arg
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* XXX GCC is awful.  */
for|for
control|(
name|i
operator|=
name|nsaved
init|;
name|i
operator|<
name|sa
operator|->
name|narg
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|copyin
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|intptr_t
argument_list|)
argument_list|(
name|locr0
operator|->
name|sp
operator|+
operator|(
literal|4
operator|+
operator|(
name|i
operator|-
name|nsaved
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|arg
argument_list|,
sizeof|sizeof
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|sa
operator|->
name|args
index|[
name|i
index|]
operator|=
name|arg
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|error
operator|=
name|copyin
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|intptr_t
argument_list|)
argument_list|(
name|locr0
operator|->
name|sp
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sa
operator|->
name|args
index|[
name|nsaved
index|]
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|sa
operator|->
name|narg
operator|-
name|nsaved
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|locr0
operator|->
name|v0
operator|=
name|error
expr_stmt|;
name|locr0
operator|->
name|a3
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|locr0
operator|->
name|v1
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|__FBSDID
end_undef

begin_define
define|#
directive|define
name|__FBSDID
parameter_list|(
name|x
parameter_list|)
end_define

begin_include
include|#
directive|include
file|"../../kern/subr_syscall.c"
end_include

begin_comment
comment|/*  * Handle an exception.  * Called from MipsKernGenException() or MipsUserGenException()  * when a processor trap occurs.  * In the case of a kernel trap, we return the pc where to resume if  * p->p_addr->u_pcb.pcb_onfault is set, otherwise, return old pc.  */
end_comment

begin_function
name|register_t
name|trap
parameter_list|(
name|struct
name|trapframe
modifier|*
name|trapframe
parameter_list|)
block|{
name|int
name|type
decl_stmt|,
name|usermode
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|ucode
init|=
literal|0
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|int
name|access_type
decl_stmt|;
name|ksiginfo_t
name|ksi
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|intptr_t
name|addr
init|=
literal|0
decl_stmt|;
name|register_t
name|pc
decl_stmt|;
name|int
name|cop
decl_stmt|;
name|register_t
modifier|*
name|frame_regs
decl_stmt|;
name|trapdebug_enter
argument_list|(
name|trapframe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
operator|(
name|trapframe
operator|->
name|cause
operator|&
name|MIPS_CR_EXC_CODE
operator|)
operator|>>
name|MIPS_CR_EXC_CODE_SHIFT
expr_stmt|;
if|if
condition|(
name|TRAPF_USERMODE
argument_list|(
name|trapframe
argument_list|)
condition|)
block|{
name|type
operator||=
name|T_USER
expr_stmt|;
name|usermode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|usermode
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Enable hardware interrupts if they were on before the trap. If it 	 * was off disable all so we don't accidently enable it when doing a 	 * return to userland. 	 */
if|if
condition|(
name|trapframe
operator|->
name|sr
operator|&
name|MIPS_SR_INT_IE
condition|)
block|{
name|set_intr_mask
argument_list|(
name|trapframe
operator|->
name|sr
operator|&
name|MIPS_SR_INT_MASK
argument_list|)
expr_stmt|;
name|intr_enable
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|intr_disable
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TRAP_DEBUG
if|if
condition|(
name|trap_debug
condition|)
block|{
specifier|static
name|vm_offset_t
name|last_badvaddr
init|=
literal|0
decl_stmt|;
specifier|static
name|vm_offset_t
name|this_badvaddr
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|pid
decl_stmt|;
name|printf
argument_list|(
literal|"trap type %x (%s - "
argument_list|,
name|type
argument_list|,
name|trap_type
index|[
name|type
operator|&
operator|(
operator|~
name|T_USER
operator|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|T_USER
condition|)
name|printf
argument_list|(
literal|"user mode)\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"kernel mode)\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|printf
argument_list|(
literal|"cpuid = %d\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pid
operator|=
name|mips_rd_entryhi
argument_list|()
operator|&
name|TLBHI_ASID_MASK
expr_stmt|;
name|printf
argument_list|(
literal|"badaddr = %#jx, pc = %#jx, ra = %#jx, sp = %#jx, sr = %jx, pid = %d, ASID = %u\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|trapframe
operator|->
name|badvaddr
argument_list|,
operator|(
name|intmax_t
operator|)
name|trapframe
operator|->
name|pc
argument_list|,
operator|(
name|intmax_t
operator|)
name|trapframe
operator|->
name|ra
argument_list|,
operator|(
name|intmax_t
operator|)
name|trapframe
operator|->
name|sp
argument_list|,
operator|(
name|intmax_t
operator|)
name|trapframe
operator|->
name|sr
argument_list|,
operator|(
name|curproc
condition|?
name|curproc
operator|->
name|p_pid
else|:
operator|-
literal|1
operator|)
argument_list|,
name|pid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
operator|&
operator|~
name|T_USER
condition|)
block|{
case|case
name|T_TLB_MOD
case|:
case|case
name|T_TLB_LD_MISS
case|:
case|case
name|T_TLB_ST_MISS
case|:
case|case
name|T_ADDR_ERR_LD
case|:
case|case
name|T_ADDR_ERR_ST
case|:
name|this_badvaddr
operator|=
name|trapframe
operator|->
name|badvaddr
expr_stmt|;
break|break;
case|case
name|T_SYSCALL
case|:
name|this_badvaddr
operator|=
name|trapframe
operator|->
name|ra
expr_stmt|;
break|break;
default|default:
name|this_badvaddr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|last_badvaddr
operator|==
name|this_badvaddr
operator|)
operator|&&
operator|(
operator|(
name|type
operator|&
operator|~
name|T_USER
operator|)
operator|!=
name|T_SYSCALL
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|count
operator|==
literal|3
condition|)
block|{
name|trap_frame_dump
argument_list|(
name|trapframe
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"too many faults at %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|last_badvaddr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|last_badvaddr
operator|=
name|this_badvaddr
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
comment|/* 	 * A trap can occur while DTrace executes a probe. Before 	 * executing the probe, DTrace blocks re-scheduling and sets 	 * a flag in its per-cpu flags to indicate that it doesn't 	 * want to fault. On returning from the probe, the no-fault 	 * flag is cleared and finally re-scheduling is enabled. 	 * 	 * If the DTrace kernel module has registered a trap handler, 	 * call it and if it returns non-zero, assume that it has 	 * handled the trap and modified the trap frame so that this 	 * function can return normally. 	 */
comment|/* 	 * XXXDTRACE: add pid probe handler here (if ever) 	 */
if|if
condition|(
operator|!
name|usermode
condition|)
block|{
if|if
condition|(
name|dtrace_trap_func
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|dtrace_trap_func
call|)
argument_list|(
name|trapframe
argument_list|,
name|type
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_MCHECK
case|:
ifdef|#
directive|ifdef
name|DDB
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|trapframe
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"MCHECK\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_TLB_MOD
case|:
comment|/* check for kernel address */
if|if
condition|(
name|KERNLAND
argument_list|(
name|trapframe
operator|->
name|badvaddr
argument_list|)
condition|)
block|{
if|if
condition|(
name|pmap_emulate_modified
argument_list|(
name|kernel_pmap
argument_list|,
name|trapframe
operator|->
name|badvaddr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
goto|goto
name|kernel_fault
goto|;
block|}
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
case|case
name|T_TLB_MOD
operator|+
name|T_USER
case|:
name|pmap
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
if|if
condition|(
name|pmap_emulate_modified
argument_list|(
name|pmap
argument_list|,
name|trapframe
operator|->
name|badvaddr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
goto|goto
name|dofault
goto|;
block|}
if|if
condition|(
operator|!
name|usermode
condition|)
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
goto|goto
name|out
goto|;
case|case
name|T_TLB_LD_MISS
case|:
case|case
name|T_TLB_ST_MISS
case|:
name|ftype
operator|=
operator|(
name|type
operator|==
name|T_TLB_ST_MISS
operator|)
condition|?
name|VM_PROT_WRITE
else|:
name|VM_PROT_READ
expr_stmt|;
comment|/* check for kernel address */
if|if
condition|(
name|KERNLAND
argument_list|(
name|trapframe
operator|->
name|badvaddr
argument_list|)
condition|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|kernel_fault
label|:
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|trapframe
operator|->
name|badvaddr
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_fault
argument_list|(
name|kernel_map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
if|if
condition|(
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|!=
name|NULL
condition|)
block|{
name|pc
operator|=
operator|(
name|register_t
operator|)
operator|(
name|intptr_t
operator|)
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|pc
operator|)
return|;
block|}
goto|goto
name|err
goto|;
block|}
comment|/* 		 * It is an error for the kernel to access user space except 		 * through the copyin/copyout routines. 		 */
if|if
condition|(
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* check for fuswintr() or suswintr() getting a page fault */
comment|/* XXX There must be a nicer way to do this.  */
if|if
condition|(
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|==
name|fswintrberr
condition|)
block|{
name|pc
operator|=
operator|(
name|register_t
operator|)
operator|(
name|intptr_t
operator|)
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|pc
operator|)
return|;
block|}
goto|goto
name|dofault
goto|;
case|case
name|T_TLB_LD_MISS
operator|+
name|T_USER
case|:
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
goto|goto
name|dofault
goto|;
case|case
name|T_TLB_ST_MISS
operator|+
name|T_USER
case|:
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
name|dofault
label|:
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|trapframe
operator|->
name|badvaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|KERNLAND
argument_list|(
name|trapframe
operator|->
name|badvaddr
argument_list|)
condition|)
block|{
comment|/* 				 * Don't allow user-mode faults in kernel 				 * address space. 				 */
goto|goto
name|nogo
goto|;
block|}
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
comment|/* 			 * XXXDTRACE: add dtrace_doubletrap_func here? 			 */
ifdef|#
directive|ifdef
name|VMFAULT_TRACE
name|printf
argument_list|(
literal|"vm_fault(%p (pmap %p), %p (%p), %x, %d) -> %x at pc %p\n"
argument_list|,
name|map
argument_list|,
operator|&
name|vm
operator|->
name|vm_pmap
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|trapframe
operator|->
name|badvaddr
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|,
name|rv
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|trapframe
operator|->
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
operator|!
name|usermode
condition|)
block|{
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
block|}
goto|goto
name|out
goto|;
block|}
name|nogo
label|:
if|if
condition|(
operator|!
name|usermode
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|!=
name|NULL
condition|)
block|{
name|pc
operator|=
operator|(
name|register_t
operator|)
operator|(
name|intptr_t
operator|)
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|pc
operator|)
return|;
block|}
goto|goto
name|err
goto|;
block|}
name|ucode
operator|=
name|ftype
expr_stmt|;
name|i
operator|=
operator|(
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
operator|)
expr_stmt|;
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
name|msg
operator|=
literal|"BAD_PAGE_FAULT"
expr_stmt|;
name|log_bad_page_fault
argument_list|(
name|msg
argument_list|,
name|trapframe
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|T_ADDR_ERR_LD
operator|+
name|T_USER
case|:
comment|/* misaligned or kseg access */
case|case
name|T_ADDR_ERR_ST
operator|+
name|T_USER
case|:
comment|/* misaligned or kseg access */
if|if
condition|(
name|trapframe
operator|->
name|badvaddr
operator|<
literal|0
operator|||
name|trapframe
operator|->
name|badvaddr
operator|>=
name|VM_MAXUSER_ADDRESS
condition|)
block|{
name|msg
operator|=
literal|"ADDRESS_SPACE_ERR"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|allow_unaligned_acc
condition|)
block|{
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|type
operator|==
operator|(
name|T_ADDR_ERR_LD
operator|+
name|T_USER
operator|)
condition|)
name|mode
operator|=
name|VM_PROT_READ
expr_stmt|;
else|else
name|mode
operator|=
name|VM_PROT_WRITE
expr_stmt|;
name|access_type
operator|=
name|emulate_unaligned_access
argument_list|(
name|trapframe
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_type
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|msg
operator|=
literal|"ALIGNMENT_FIX_ERR"
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
literal|"ADDRESS_ERR"
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
name|T_BUS_ERR_IFETCH
operator|+
name|T_USER
case|:
comment|/* BERR asserted to cpu */
case|case
name|T_BUS_ERR_LD_ST
operator|+
name|T_USER
case|:
comment|/* BERR asserted to cpu */
name|ucode
operator|=
literal|0
expr_stmt|;
comment|/* XXX should be VM_PROT_something */
name|i
operator|=
name|SIGBUS
expr_stmt|;
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
name|msg
operator|=
literal|"BUS_ERR"
expr_stmt|;
name|log_bad_page_fault
argument_list|(
name|msg
argument_list|,
name|trapframe
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SYSCALL
operator|+
name|T_USER
case|:
block|{
name|int
name|error
decl_stmt|;
name|td
operator|->
name|td_sa
operator|.
name|trapframe
operator|=
name|trapframe
expr_stmt|;
name|error
operator|=
name|syscallenter
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|DDB
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|)
if|if
condition|(
name|trp
operator|==
name|trapdebug
condition|)
name|trapdebug
index|[
name|TRAPSIZE
operator|-
literal|1
index|]
operator|.
name|code
operator|=
name|td
operator|->
name|td_sa
operator|.
name|code
expr_stmt|;
else|else
name|trp
index|[
operator|-
literal|1
index|]
operator|.
name|code
operator|=
name|td
operator|->
name|td_sa
operator|.
name|code
expr_stmt|;
endif|#
directive|endif
name|trapdebug_enter
argument_list|(
name|td
operator|->
name|td_frame
argument_list|,
operator|-
name|td
operator|->
name|td_sa
operator|.
name|code
argument_list|)
expr_stmt|;
comment|/* 			 * The sync'ing of I& D caches for SYS_ptrace() is 			 * done by procfs_domem() through procfs_rwmem() 			 * instead of being done here under a special check 			 * for SYS_ptrace(). 			 */
name|syscallret
argument_list|(
name|td
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|KDTRACE_HOOKS
argument_list|)
operator|||
name|defined
argument_list|(
name|DDB
argument_list|)
case|case
name|T_BREAK
case|:
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
if|if
condition|(
operator|!
name|usermode
operator|&&
name|dtrace_invop_jump_addr
operator|!=
literal|0
condition|)
block|{
name|dtrace_invop_jump_addr
argument_list|(
name|trapframe
argument_list|)
expr_stmt|;
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DDB
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|trapframe
argument_list|)
expr_stmt|;
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
endif|#
directive|endif
endif|#
directive|endif
case|case
name|T_BREAK
operator|+
name|T_USER
case|:
block|{
name|intptr_t
name|va
decl_stmt|;
name|uint32_t
name|instr
decl_stmt|;
comment|/* compute address of break instruction */
name|va
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|DELAYBRANCH
argument_list|(
name|trapframe
operator|->
name|cause
argument_list|)
condition|)
name|va
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* read break instruction */
name|instr
operator|=
name|fuword32
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n", 			    p->p_comm, p->p_pid, instr, trapframe->pc, 			    p->p_md.md_ss_addr, p->p_md.md_ss_instr);
comment|/* XXX */
endif|#
directive|endif
if|if
condition|(
name|td
operator|->
name|td_md
operator|.
name|md_ss_addr
operator|!=
name|va
operator|||
name|instr
operator|!=
name|MIPS_BREAK_SSTEP
condition|)
block|{
name|i
operator|=
name|SIGTRAP
expr_stmt|;
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
break|break;
block|}
comment|/* 			 * The restoration of the original instruction and 			 * the clearing of the berakpoint will be done later 			 * by the call to ptrace_clear_single_step() in 			 * issignal() when SIGTRAP is processed. 			 */
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
block|}
case|case
name|T_IWATCH
operator|+
name|T_USER
case|:
case|case
name|T_DWATCH
operator|+
name|T_USER
case|:
block|{
name|intptr_t
name|va
decl_stmt|;
comment|/* compute address of trapped instruction */
name|va
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|DELAYBRANCH
argument_list|(
name|trapframe
operator|->
name|cause
argument_list|)
condition|)
name|va
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"watch exception @ %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va
argument_list|)
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
name|addr
operator|=
name|va
expr_stmt|;
break|break;
block|}
case|case
name|T_TRAP
operator|+
name|T_USER
case|:
block|{
name|intptr_t
name|va
decl_stmt|;
name|uint32_t
name|instr
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|locr0
init|=
name|td
operator|->
name|td_frame
decl_stmt|;
comment|/* compute address of trap instruction */
name|va
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|DELAYBRANCH
argument_list|(
name|trapframe
operator|->
name|cause
argument_list|)
condition|)
name|va
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* read break instruction */
name|instr
operator|=
name|fuword32
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|DELAYBRANCH
argument_list|(
name|trapframe
operator|->
name|cause
argument_list|)
condition|)
block|{
comment|/* Check BD bit */
name|locr0
operator|->
name|pc
operator|=
name|MipsEmulateBranch
argument_list|(
name|locr0
argument_list|,
name|trapframe
operator|->
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|locr0
operator|->
name|pc
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|va
expr_stmt|;
name|i
operator|=
name|SIGEMT
expr_stmt|;
comment|/* Stuff it with something for now */
break|break;
block|}
case|case
name|T_RES_INST
operator|+
name|T_USER
case|:
block|{
name|InstFmt
name|inst
decl_stmt|;
name|inst
operator|=
operator|*
operator|(
name|InstFmt
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|trapframe
operator|->
name|pc
expr_stmt|;
switch|switch
condition|(
name|inst
operator|.
name|RType
operator|.
name|op
condition|)
block|{
case|case
name|OP_SPECIAL3
case|:
switch|switch
condition|(
name|inst
operator|.
name|RType
operator|.
name|func
condition|)
block|{
case|case
name|OP_RDHWR
case|:
comment|/* Register 29 used for TLS */
if|if
condition|(
name|inst
operator|.
name|RType
operator|.
name|rd
operator|==
literal|29
condition|)
block|{
name|frame_regs
operator|=
operator|&
operator|(
name|trapframe
operator|->
name|zero
operator|)
expr_stmt|;
name|frame_regs
index|[
name|inst
operator|.
name|RType
operator|.
name|rt
index|]
operator|=
operator|(
name|register_t
operator|)
operator|(
name|intptr_t
operator|)
name|td
operator|->
name|td_md
operator|.
name|md_tls
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__mips_n64
argument_list|)
operator|&&
name|defined
argument_list|(
name|COMPAT_FREEBSD32
argument_list|)
if|if
condition|(
name|SV_PROC_FLAG
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|SV_ILP32
argument_list|)
condition|)
name|frame_regs
index|[
name|inst
operator|.
name|RType
operator|.
name|rt
index|]
operator|+=
name|TLS_TP_OFFSET
operator|+
name|TLS_TCB_SIZE32
expr_stmt|;
else|else
endif|#
directive|endif
name|frame_regs
index|[
name|inst
operator|.
name|RType
operator|.
name|rt
index|]
operator|+=
name|TLS_TP_OFFSET
operator|+
name|TLS_TCB_SIZE
expr_stmt|;
name|trapframe
operator|->
name|pc
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
block|}
break|break;
block|}
name|log_illegal_instruction
argument_list|(
literal|"RES_INST"
argument_list|,
name|trapframe
argument_list|)
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
block|}
break|break;
case|case
name|T_C2E
case|:
case|case
name|T_C2E
operator|+
name|T_USER
case|:
goto|goto
name|err
goto|;
break|break;
case|case
name|T_COP_UNUSABLE
case|:
ifdef|#
directive|ifdef
name|CPU_CNMIPS
name|cop
operator|=
operator|(
name|trapframe
operator|->
name|cause
operator|&
name|MIPS_CR_COP_ERR
operator|)
operator|>>
name|MIPS_CR_COP_ERR_SHIFT
expr_stmt|;
comment|/* Handle only COP2 exception */
if|if
condition|(
name|cop
operator|!=
literal|2
condition|)
goto|goto
name|err
goto|;
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
comment|/* save userland cop2 context if it has been touched */
if|if
condition|(
operator|(
name|td
operator|->
name|td_md
operator|.
name|md_flags
operator|&
name|MDTD_COP2USED
operator|)
operator|&&
operator|(
name|td
operator|->
name|td_md
operator|.
name|md_cop2owner
operator|==
name|COP2_OWNER_USERLAND
operator|)
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_md
operator|.
name|md_ucop2
condition|)
name|octeon_cop2_save
argument_list|(
name|td
operator|->
name|td_md
operator|.
name|md_ucop2
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"COP2 was used in user mode but md_ucop2 is NULL"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|->
name|td_md
operator|.
name|md_cop2
operator|==
name|NULL
condition|)
block|{
name|td
operator|->
name|td_md
operator|.
name|md_cop2
operator|=
name|octeon_cop2_alloc_ctx
argument_list|()
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_md
operator|.
name|md_cop2
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"Failed to allocate COP2 context"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|td
operator|->
name|td_md
operator|.
name|md_cop2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|td
operator|->
name|td_md
operator|.
name|md_cop2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|octeon_cop2_restore
argument_list|(
name|td
operator|->
name|td_md
operator|.
name|md_cop2
argument_list|)
expr_stmt|;
comment|/* Make userland re-request its context */
name|td
operator|->
name|td_frame
operator|->
name|sr
operator|&=
operator|~
name|MIPS_SR_COP_2_BIT
expr_stmt|;
name|td
operator|->
name|td_md
operator|.
name|md_flags
operator||=
name|MDTD_COP2USED
expr_stmt|;
name|td
operator|->
name|td_md
operator|.
name|md_cop2owner
operator|=
name|COP2_OWNER_KERNEL
expr_stmt|;
comment|/* Enable COP2, it will be disabled in cpu_switch */
name|mips_wr_status
argument_list|(
name|mips_rd_status
argument_list|()
operator||
name|MIPS_SR_COP_2_BIT
argument_list|)
expr_stmt|;
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
else|#
directive|else
goto|goto
name|err
goto|;
break|break;
endif|#
directive|endif
case|case
name|T_COP_UNUSABLE
operator|+
name|T_USER
case|:
name|cop
operator|=
operator|(
name|trapframe
operator|->
name|cause
operator|&
name|MIPS_CR_COP_ERR
operator|)
operator|>>
name|MIPS_CR_COP_ERR_SHIFT
expr_stmt|;
if|if
condition|(
name|cop
operator|==
literal|1
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CPU_HAVEFPU
argument_list|)
comment|/* FP (COP1) instruction */
name|log_illegal_instruction
argument_list|(
literal|"COP1_UNUSABLE"
argument_list|,
name|trapframe
argument_list|)
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
else|#
directive|else
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
name|MipsSwitchFPState
argument_list|(
name|PCPU_GET
argument_list|(
name|fpcurthread
argument_list|)
argument_list|,
name|td
operator|->
name|td_frame
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|fpcurthread
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_frame
operator|->
name|sr
operator||=
name|MIPS_SR_COP_1_BIT
expr_stmt|;
name|td
operator|->
name|td_md
operator|.
name|md_flags
operator||=
name|MDTD_FPUSED
expr_stmt|;
goto|goto
name|out
goto|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|CPU_CNMIPS
elseif|else
if|if
condition|(
name|cop
operator|==
literal|2
condition|)
block|{
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
if|if
condition|(
operator|(
name|td
operator|->
name|td_md
operator|.
name|md_flags
operator|&
name|MDTD_COP2USED
operator|)
operator|&&
operator|(
name|td
operator|->
name|td_md
operator|.
name|md_cop2owner
operator|==
name|COP2_OWNER_KERNEL
operator|)
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_md
operator|.
name|md_cop2
condition|)
name|octeon_cop2_save
argument_list|(
name|td
operator|->
name|td_md
operator|.
name|md_cop2
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"COP2 was used in kernel mode but md_cop2 is NULL"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|->
name|td_md
operator|.
name|md_ucop2
operator|==
name|NULL
condition|)
block|{
name|td
operator|->
name|td_md
operator|.
name|md_ucop2
operator|=
name|octeon_cop2_alloc_ctx
argument_list|()
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_md
operator|.
name|md_ucop2
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"Failed to allocate userland COP2 context"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|td
operator|->
name|td_md
operator|.
name|md_ucop2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|td
operator|->
name|td_md
operator|.
name|md_ucop2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|octeon_cop2_restore
argument_list|(
name|td
operator|->
name|td_md
operator|.
name|md_ucop2
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_frame
operator|->
name|sr
operator||=
name|MIPS_SR_COP_2_BIT
expr_stmt|;
name|td
operator|->
name|td_md
operator|.
name|md_flags
operator||=
name|MDTD_COP2USED
expr_stmt|;
name|td
operator|->
name|td_md
operator|.
name|md_cop2owner
operator|=
name|COP2_OWNER_USERLAND
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
else|else
block|{
name|log_illegal_instruction
argument_list|(
literal|"COPn_UNUSABLE"
argument_list|,
name|trapframe
argument_list|)
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
comment|/* only FPU instructions allowed */
break|break;
block|}
case|case
name|T_FPE
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|DDB
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|)
name|trapDump
argument_list|(
literal|"fpintr"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"FPU Trap: PC %#jx CR %x SR %x\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|trapframe
operator|->
name|pc
argument_list|,
operator|(
name|unsigned
operator|)
name|trapframe
operator|->
name|cause
argument_list|,
operator|(
name|unsigned
operator|)
name|trapframe
operator|->
name|sr
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
endif|#
directive|endif
case|case
name|T_FPE
operator|+
name|T_USER
case|:
if|if
condition|(
operator|!
name|emulate_fp
condition|)
block|{
name|i
operator|=
name|SIGILL
expr_stmt|;
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
break|break;
block|}
name|MipsFPTrap
argument_list|(
name|trapframe
operator|->
name|sr
argument_list|,
name|trapframe
operator|->
name|cause
argument_list|,
name|trapframe
operator|->
name|pc
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|T_OVFLOW
operator|+
name|T_USER
case|:
name|i
operator|=
name|SIGFPE
expr_stmt|;
name|addr
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
break|break;
case|case
name|T_ADDR_ERR_LD
case|:
comment|/* misaligned access */
case|case
name|T_ADDR_ERR_ST
case|:
comment|/* misaligned access */
ifdef|#
directive|ifdef
name|TRAP_DEBUG
if|if
condition|(
name|trap_debug
condition|)
block|{
name|printf
argument_list|(
literal|"+++ ADDR_ERR: type = %d, badvaddr = %#jx\n"
argument_list|,
name|type
argument_list|,
operator|(
name|intmax_t
operator|)
name|trapframe
operator|->
name|badvaddr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Only allow emulation on a user address */
if|if
condition|(
name|allow_unaligned_acc
operator|&&
operator|(
operator|(
name|vm_offset_t
operator|)
name|trapframe
operator|->
name|badvaddr
operator|<
name|VM_MAXUSER_ADDRESS
operator|)
condition|)
block|{
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|T_ADDR_ERR_LD
condition|)
name|mode
operator|=
name|VM_PROT_READ
expr_stmt|;
else|else
name|mode
operator|=
name|VM_PROT_WRITE
expr_stmt|;
name|access_type
operator|=
name|emulate_unaligned_access
argument_list|(
name|trapframe
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_type
operator|!=
literal|0
condition|)
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
case|case
name|T_BUS_ERR_LD_ST
case|:
comment|/* BERR asserted to cpu */
if|if
condition|(
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|!=
name|NULL
condition|)
block|{
name|pc
operator|=
operator|(
name|register_t
operator|)
operator|(
name|intptr_t
operator|)
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|pc
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
default|default:
name|err
label|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|stacktrace
argument_list|(
operator|!
name|usermode
condition|?
name|trapframe
else|:
name|td
operator|->
name|td_frame
argument_list|)
expr_stmt|;
name|trapDump
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SMP
name|printf
argument_list|(
literal|"cpu:%d-"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"Trap cause = %d (%s - "
argument_list|,
name|type
argument_list|,
name|trap_type
index|[
name|type
operator|&
operator|(
operator|~
name|T_USER
operator|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|T_USER
condition|)
name|printf
argument_list|(
literal|"user mode)\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"kernel mode)\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRAP_DEBUG
if|if
condition|(
name|trap_debug
condition|)
name|printf
argument_list|(
literal|"badvaddr = %#jx, pc = %#jx, ra = %#jx, sr = %#jxx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|trapframe
operator|->
name|badvaddr
argument_list|,
operator|(
name|intmax_t
operator|)
name|trapframe
operator|->
name|pc
argument_list|,
operator|(
name|intmax_t
operator|)
name|trapframe
operator|->
name|ra
argument_list|,
operator|(
name|intmax_t
operator|)
name|trapframe
operator|->
name|sr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|debugger_on_panic
operator|||
name|kdb_active
condition|)
block|{
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|trapframe
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_frame
operator|->
name|pc
operator|=
name|trapframe
operator|->
name|pc
expr_stmt|;
name|td
operator|->
name|td_frame
operator|->
name|cause
operator|=
name|trapframe
operator|->
name|cause
expr_stmt|;
name|td
operator|->
name|td_frame
operator|->
name|badvaddr
operator|=
name|trapframe
operator|->
name|badvaddr
expr_stmt|;
name|ksiginfo_init_trap
argument_list|(
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|ksi_signo
operator|=
name|i
expr_stmt|;
name|ksi
operator|.
name|ksi_code
operator|=
name|ucode
expr_stmt|;
name|ksi
operator|.
name|ksi_addr
operator|=
operator|(
name|void
operator|*
operator|)
name|addr
expr_stmt|;
name|ksi
operator|.
name|ksi_trapno
operator|=
name|type
expr_stmt|;
name|trapsignal
argument_list|(
name|td
argument_list|,
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* 	 * Note: we should only get here if returning to user mode. 	 */
name|userret
argument_list|(
name|td
argument_list|,
name|trapframe
argument_list|)
expr_stmt|;
return|return
operator|(
name|trapframe
operator|->
name|pc
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|DDB
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|)
end_if

begin_function
name|void
name|trapDump
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|register_t
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|s
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"trapDump(%s)\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TRAPSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|trp
operator|==
name|trapdebug
condition|)
block|{
name|trp
operator|=
operator|&
name|trapdebug
index|[
name|TRAPSIZE
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|trp
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|trp
operator|->
name|cause
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"%s: ADR %jx PC %jx CR %jx SR %jx\n"
argument_list|,
name|trap_type
index|[
operator|(
name|trp
operator|->
name|cause
operator|&
name|MIPS_CR_EXC_CODE
operator|)
operator|>>
name|MIPS_CR_EXC_CODE_SHIFT
index|]
argument_list|,
operator|(
name|intmax_t
operator|)
name|trp
operator|->
name|vadr
argument_list|,
operator|(
name|intmax_t
operator|)
name|trp
operator|->
name|pc
argument_list|,
operator|(
name|intmax_t
operator|)
name|trp
operator|->
name|cause
argument_list|,
operator|(
name|intmax_t
operator|)
name|trp
operator|->
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   RA %jx SP %jx code %d\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|trp
operator|->
name|ra
argument_list|,
operator|(
name|intmax_t
operator|)
name|trp
operator|->
name|sp
argument_list|,
operator|(
name|int
operator|)
name|trp
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
name|intr_restore
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Return the resulting PC as if the branch was executed.  */
end_comment

begin_function
name|uintptr_t
name|MipsEmulateBranch
parameter_list|(
name|struct
name|trapframe
modifier|*
name|framePtr
parameter_list|,
name|uintptr_t
name|instPC
parameter_list|,
name|int
name|fpcCSR
parameter_list|,
name|uintptr_t
name|instptr
parameter_list|)
block|{
name|InstFmt
name|inst
decl_stmt|;
name|register_t
modifier|*
name|regsPtr
init|=
operator|(
name|register_t
operator|*
operator|)
name|framePtr
decl_stmt|;
name|uintptr_t
name|retAddr
init|=
literal|0
decl_stmt|;
name|int
name|condition
decl_stmt|;
define|#
directive|define
name|GetBranchDest
parameter_list|(
name|InstPtr
parameter_list|,
name|inst
parameter_list|)
define|\
value|(InstPtr + 4 + ((short)inst.IType.imm<< 2))
if|if
condition|(
name|instptr
condition|)
block|{
if|if
condition|(
name|instptr
operator|<
name|MIPS_KSEG0_START
condition|)
name|inst
operator|.
name|word
operator|=
name|fuword32
argument_list|(
operator|(
name|void
operator|*
operator|)
name|instptr
argument_list|)
expr_stmt|;
else|else
name|inst
operator|=
operator|*
operator|(
name|InstFmt
operator|*
operator|)
name|instptr
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|vm_offset_t
operator|)
name|instPC
operator|<
name|MIPS_KSEG0_START
condition|)
name|inst
operator|.
name|word
operator|=
name|fuword32
argument_list|(
operator|(
name|void
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|inst
operator|=
operator|*
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
name|int
operator|)
name|inst
operator|.
name|JType
operator|.
name|op
condition|)
block|{
case|case
name|OP_SPECIAL
case|:
switch|switch
condition|(
operator|(
name|int
operator|)
name|inst
operator|.
name|RType
operator|.
name|func
condition|)
block|{
case|case
name|OP_JR
case|:
case|case
name|OP_JALR
case|:
name|retAddr
operator|=
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
expr_stmt|;
break|break;
default|default:
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OP_BCOND
case|:
switch|switch
condition|(
operator|(
name|int
operator|)
name|inst
operator|.
name|IType
operator|.
name|rt
condition|)
block|{
case|case
name|OP_BLTZ
case|:
case|case
name|OP_BLTZL
case|:
case|case
name|OP_BLTZAL
case|:
case|case
name|OP_BLTZALL
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|<
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
name|instPC
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BGEZ
case|:
case|case
name|OP_BGEZL
case|:
case|case
name|OP_BGEZAL
case|:
case|case
name|OP_BGEZALL
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|>=
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
name|instPC
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_TGEI
case|:
case|case
name|OP_TGEIU
case|:
case|case
name|OP_TLTI
case|:
case|case
name|OP_TLTIU
case|:
case|case
name|OP_TEQI
case|:
case|case
name|OP_TNEI
case|:
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
comment|/* Like syscall... */
break|break;
default|default:
name|panic
argument_list|(
literal|"MipsEmulateBranch: Bad branch cond"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_J
case|:
case|case
name|OP_JAL
case|:
name|retAddr
operator|=
operator|(
name|inst
operator|.
name|JType
operator|.
name|target
operator|<<
literal|2
operator|)
operator||
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|instPC
operator|+
literal|4
argument_list|)
operator|&
literal|0xF0000000
operator|)
expr_stmt|;
break|break;
case|case
name|OP_BEQ
case|:
case|case
name|OP_BEQL
case|:
if|if
condition|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
operator|==
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rt
index|]
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
name|instPC
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BNE
case|:
case|case
name|OP_BNEL
case|:
if|if
condition|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
operator|!=
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rt
index|]
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
name|instPC
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BLEZ
case|:
case|case
name|OP_BLEZL
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|<=
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
name|instPC
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BGTZ
case|:
case|case
name|OP_BGTZL
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|>
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
name|instPC
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_COP1
case|:
switch|switch
condition|(
name|inst
operator|.
name|RType
operator|.
name|rs
condition|)
block|{
case|case
name|OP_BCx
case|:
case|case
name|OP_BCy
case|:
if|if
condition|(
operator|(
name|inst
operator|.
name|RType
operator|.
name|rt
operator|&
name|COPz_BC_TF_MASK
operator|)
operator|==
name|COPz_BC_TRUE
condition|)
name|condition
operator|=
name|fpcCSR
operator|&
name|MIPS_FPU_COND_BIT
expr_stmt|;
else|else
name|condition
operator|=
operator|!
operator|(
name|fpcCSR
operator|&
name|MIPS_FPU_COND_BIT
operator|)
expr_stmt|;
if|if
condition|(
name|condition
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
name|instPC
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
default|default:
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
block|}
break|break;
default|default:
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
block|}
return|return
operator|(
name|retAddr
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DDB
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG
argument_list|)
end_if

begin_comment
comment|/*  * Print a stack backtrace.  */
end_comment

begin_function
name|void
name|stacktrace
parameter_list|(
name|struct
name|trapframe
modifier|*
name|regs
parameter_list|)
block|{
name|stacktrace_subr
argument_list|(
name|regs
operator|->
name|pc
argument_list|,
name|regs
operator|->
name|sp
argument_list|,
name|regs
operator|->
name|ra
argument_list|,
name|printf
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|log_frame_dump
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Trapframe Register Dump:\n"
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tzero: %#jx\tat: %#jx\tv0: %#jx\tv1: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
literal|0
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|ast
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|v0
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|v1
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\ta0: %#jx\ta1: %#jx\ta2: %#jx\ta3: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a0
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a1
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a2
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a3
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__mips_n32
argument_list|)
operator|||
name|defined
argument_list|(
name|__mips_n64
argument_list|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\ta4: %#jx\ta5: %#jx\ta6: %#jx\ta6: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a4
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a5
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a6
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a7
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tt0: %#jx\tt1: %#jx\tt2: %#jx\tt3: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t0
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t1
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t2
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t3
argument_list|)
expr_stmt|;
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tt0: %#jx\tt1: %#jx\tt2: %#jx\tt3: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t0
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t1
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t2
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t3
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tt4: %#jx\tt5: %#jx\tt6: %#jx\tt7: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t4
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t5
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t6
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t7
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tt8: %#jx\tt9: %#jx\ts0: %#jx\ts1: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t8
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t9
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s0
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s1
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\ts2: %#jx\ts3: %#jx\ts4: %#jx\ts5: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s2
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s3
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s4
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s5
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\ts6: %#jx\ts7: %#jx\tk0: %#jx\tk1: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s6
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s7
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|k0
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|k1
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tgp: %#jx\tsp: %#jx\ts8: %#jx\tra: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|gp
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|sp
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s8
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|ra
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tsr: %#jx\tmullo: %#jx\tmulhi: %#jx\tbadvaddr: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|sr
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|mullo
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|mulhi
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|badvaddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IC_REG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tcause: %#jx\tpc: %#jx\tic: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|cause
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|pc
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|ic
argument_list|)
expr_stmt|;
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"\tcause: %#jx\tpc: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|cause
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TRAP_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|trap_frame_dump
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Trapframe Register Dump:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tzero: %#jx\tat: %#jx\tv0: %#jx\tv1: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
literal|0
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|ast
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|v0
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|v1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ta0: %#jx\ta1: %#jx\ta2: %#jx\ta3: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a0
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a1
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a2
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a3
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__mips_n32
argument_list|)
operator|||
name|defined
argument_list|(
name|__mips_n64
argument_list|)
name|printf
argument_list|(
literal|"\ta4: %#jx\ta5: %#jx\ta6: %#jx\ta7: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a4
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a5
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a6
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|a7
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tt0: %#jx\tt1: %#jx\tt2: %#jx\tt3: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t0
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t1
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t2
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t3
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"\tt0: %#jx\tt1: %#jx\tt2: %#jx\tt3: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t0
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t1
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t2
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tt4: %#jx\tt5: %#jx\tt6: %#jx\tt7: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t4
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t5
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t6
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t7
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"\tt8: %#jx\tt9: %#jx\ts0: %#jx\ts1: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t8
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|t9
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s0
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ts2: %#jx\ts3: %#jx\ts4: %#jx\ts5: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s2
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s3
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s4
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ts6: %#jx\ts7: %#jx\tk0: %#jx\tk1: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s6
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s7
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|k0
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|k1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tgp: %#jx\tsp: %#jx\ts8: %#jx\tra: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|gp
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|sp
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|s8
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|ra
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tsr: %#jx\tmullo: %#jx\tmulhi: %#jx\tbadvaddr: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|sr
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|mullo
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|mulhi
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|badvaddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IC_REG
name|printf
argument_list|(
literal|"\tcause: %#jx\tpc: %#jx\tic: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|cause
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|pc
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|ic
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"\tcause: %#jx\tpc: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|cause
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|get_mapping_info
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
modifier|*
modifier|*
name|pdepp
parameter_list|,
name|pt_entry_t
modifier|*
modifier|*
name|ptepp
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|pd_entry_t
modifier|*
name|pdep
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|pdep
operator|=
operator|(
operator|&
operator|(
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|.
name|pm_segtab
index|[
operator|(
name|va
operator|>>
name|SEGSHIFT
operator|)
operator|&
operator|(
name|NPDEPG
operator|-
literal|1
operator|)
index|]
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|pdep
condition|)
name|ptep
operator|=
name|pmap_pte
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
else|else
name|ptep
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
literal|0
expr_stmt|;
operator|*
name|pdepp
operator|=
name|pdep
expr_stmt|;
operator|*
name|ptepp
operator|=
name|ptep
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|log_illegal_instruction
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|pd_entry_t
modifier|*
name|pdep
decl_stmt|;
name|unsigned
name|int
modifier|*
name|addr
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|register_t
name|pc
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|printf
argument_list|(
literal|"cpuid = %d\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pc
operator|=
name|frame
operator|->
name|pc
operator|+
operator|(
name|DELAYBRANCH
argument_list|(
name|frame
operator|->
name|cause
argument_list|)
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: pid %d tid %ld (%s), uid %d: pc %#jx ra %#jx\n"
argument_list|,
name|msg
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_tid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_ucred
condition|?
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
else|:
operator|-
literal|1
argument_list|,
operator|(
name|intmax_t
operator|)
name|pc
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|ra
argument_list|)
expr_stmt|;
comment|/* log registers in trap frame */
name|log_frame_dump
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|get_mapping_info
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|,
operator|&
name|pdep
argument_list|,
operator|&
name|ptep
argument_list|)
expr_stmt|;
comment|/* 	 * Dump a few words around faulting instruction, if the addres is 	 * valid. 	 */
if|if
condition|(
operator|!
operator|(
name|pc
operator|&
literal|3
operator|)
operator|&&
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
operator|(
name|intptr_t
operator|)
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|4
argument_list|,
name|VM_PROT_READ
argument_list|)
condition|)
block|{
comment|/* dump page table entry for faulting instruction */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Page table info for pc address %#jx: pde = %p, pte = %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|pc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
operator|*
name|pdep
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|ptep
condition|?
operator|*
name|ptep
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|pc
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Dumping 4 words starting at pc address %p: \n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%08x %08x %08x %08x\n"
argument_list|,
name|addr
index|[
literal|0
index|]
argument_list|,
name|addr
index|[
literal|1
index|]
argument_list|,
name|addr
index|[
literal|2
index|]
argument_list|,
name|addr
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pc address %#jx is inaccessible, pde = %p, pte = %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|pc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
operator|*
name|pdep
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|ptep
condition|?
operator|*
name|ptep
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|log_bad_page_fault
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|,
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|,
name|int
name|trap_type
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|pd_entry_t
modifier|*
name|pdep
decl_stmt|;
name|unsigned
name|int
modifier|*
name|addr
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|read_or_write
decl_stmt|;
name|register_t
name|pc
decl_stmt|;
name|trap_type
operator|&=
operator|~
name|T_USER
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|printf
argument_list|(
literal|"cpuid = %d\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|trap_type
condition|)
block|{
case|case
name|T_TLB_MOD
case|:
case|case
name|T_TLB_ST_MISS
case|:
case|case
name|T_ADDR_ERR_ST
case|:
name|read_or_write
operator|=
literal|"write"
expr_stmt|;
break|break;
case|case
name|T_TLB_LD_MISS
case|:
case|case
name|T_ADDR_ERR_LD
case|:
case|case
name|T_BUS_ERR_IFETCH
case|:
name|read_or_write
operator|=
literal|"read"
expr_stmt|;
break|break;
default|default:
name|read_or_write
operator|=
literal|"unknown"
expr_stmt|;
block|}
name|pc
operator|=
name|frame
operator|->
name|pc
operator|+
operator|(
name|DELAYBRANCH
argument_list|(
name|frame
operator|->
name|cause
argument_list|)
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: pid %d tid %ld (%s), uid %d: pc %#jx got a %s fault "
literal|"(type %#x) at %#jx\n"
argument_list|,
name|msg
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_tid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_ucred
condition|?
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
else|:
operator|-
literal|1
argument_list|,
operator|(
name|intmax_t
operator|)
name|pc
argument_list|,
name|read_or_write
argument_list|,
name|trap_type
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|badvaddr
argument_list|)
expr_stmt|;
comment|/* log registers in trap frame */
name|log_frame_dump
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|get_mapping_info
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|,
operator|&
name|pdep
argument_list|,
operator|&
name|ptep
argument_list|)
expr_stmt|;
comment|/* 	 * Dump a few words around faulting instruction, if the addres is 	 * valid. 	 */
if|if
condition|(
operator|!
operator|(
name|pc
operator|&
literal|3
operator|)
operator|&&
operator|(
name|pc
operator|!=
name|frame
operator|->
name|badvaddr
operator|)
operator|&&
operator|(
name|trap_type
operator|!=
name|T_BUS_ERR_IFETCH
operator|)
operator|&&
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
operator|(
name|intptr_t
operator|)
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|4
argument_list|,
name|VM_PROT_READ
argument_list|)
condition|)
block|{
comment|/* dump page table entry for faulting instruction */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Page table info for pc address %#jx: pde = %p, pte = %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|pc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
operator|*
name|pdep
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|ptep
condition|?
operator|*
name|ptep
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|pc
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Dumping 4 words starting at pc address %p: \n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%08x %08x %08x %08x\n"
argument_list|,
name|addr
index|[
literal|0
index|]
argument_list|,
name|addr
index|[
literal|1
index|]
argument_list|,
name|addr
index|[
literal|2
index|]
argument_list|,
name|addr
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pc address %#jx is inaccessible, pde = %p, pte = %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|pc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
operator|*
name|pdep
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|ptep
condition|?
operator|*
name|ptep
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|get_mapping_info
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|frame
operator|->
name|badvaddr
argument_list|,
operator|&
name|pdep
argument_list|,
operator|&
name|ptep
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Page table info for bad address %#jx: pde = %p, pte = %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|badvaddr
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
operator|*
name|pdep
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|ptep
condition|?
operator|*
name|ptep
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unaligned load/store emulation  */
end_comment

begin_function
specifier|static
name|int
name|mips_unaligned_load_store
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|,
name|int
name|mode
parameter_list|,
name|register_t
name|addr
parameter_list|,
name|register_t
name|pc
parameter_list|)
block|{
name|register_t
modifier|*
name|reg
init|=
operator|(
name|register_t
operator|*
operator|)
name|frame
decl_stmt|;
name|u_int32_t
name|inst
init|=
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|pc
operator|)
decl_stmt|;
name|register_t
name|value_msb
decl_stmt|,
name|value
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
comment|/* 	 * ADDR_ERR faults have higher priority than TLB 	 * Miss faults.  Therefore, it is necessary to 	 * verify that the faulting address is a valid 	 * virtual address within the process' address space 	 * before trying to emulate the unaligned access. 	 */
switch|switch
condition|(
name|MIPS_INST_OPCODE
argument_list|(
name|inst
argument_list|)
condition|)
block|{
case|case
name|OP_LHU
case|:
case|case
name|OP_LH
case|:
case|case
name|OP_SH
case|:
name|size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|OP_LWU
case|:
case|case
name|OP_LW
case|:
case|case
name|OP_SW
case|:
name|size
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|OP_LD
case|:
case|case
name|OP_SD
case|:
name|size
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: unhandled opcode in address error: %#x\n"
argument_list|,
name|__func__
argument_list|,
name|MIPS_INST_OPCODE
argument_list|(
name|inst
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|useracc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rounddown2
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|,
name|size
argument_list|)
argument_list|,
name|size
operator|*
literal|2
argument_list|,
name|mode
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * XXX 	 * Handle LL/SC LLD/SCD. 	 */
switch|switch
condition|(
name|MIPS_INST_OPCODE
argument_list|(
name|inst
argument_list|)
condition|)
block|{
case|case
name|OP_LHU
case|:
name|KASSERT
argument_list|(
name|mode
operator|==
name|VM_PROT_READ
argument_list|,
operator|(
literal|"access mode must be read for load instruction."
operator|)
argument_list|)
expr_stmt|;
name|lbu_macro
argument_list|(
name|value_msb
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
name|lbu_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|value
operator||=
name|value_msb
operator|<<
literal|8
expr_stmt|;
name|reg
index|[
name|MIPS_INST_RT
argument_list|(
name|inst
argument_list|)
index|]
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|MIPS_LHU_ACCESS
operator|)
return|;
case|case
name|OP_LH
case|:
name|KASSERT
argument_list|(
name|mode
operator|==
name|VM_PROT_READ
argument_list|,
operator|(
literal|"access mode must be read for load instruction."
operator|)
argument_list|)
expr_stmt|;
name|lb_macro
argument_list|(
name|value_msb
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
name|lbu_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|value
operator||=
name|value_msb
operator|<<
literal|8
expr_stmt|;
name|reg
index|[
name|MIPS_INST_RT
argument_list|(
name|inst
argument_list|)
index|]
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|MIPS_LH_ACCESS
operator|)
return|;
case|case
name|OP_LWU
case|:
name|KASSERT
argument_list|(
name|mode
operator|==
name|VM_PROT_READ
argument_list|,
operator|(
literal|"access mode must be read for load instruction."
operator|)
argument_list|)
expr_stmt|;
name|lwl_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|3
expr_stmt|;
name|lwr_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|value
operator|&=
literal|0xffffffff
expr_stmt|;
name|reg
index|[
name|MIPS_INST_RT
argument_list|(
name|inst
argument_list|)
index|]
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|MIPS_LWU_ACCESS
operator|)
return|;
case|case
name|OP_LW
case|:
name|KASSERT
argument_list|(
name|mode
operator|==
name|VM_PROT_READ
argument_list|,
operator|(
literal|"access mode must be read for load instruction."
operator|)
argument_list|)
expr_stmt|;
name|lwl_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|3
expr_stmt|;
name|lwr_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|reg
index|[
name|MIPS_INST_RT
argument_list|(
name|inst
argument_list|)
index|]
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|MIPS_LW_ACCESS
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|__mips_n32
argument_list|)
operator|||
name|defined
argument_list|(
name|__mips_n64
argument_list|)
case|case
name|OP_LD
case|:
name|KASSERT
argument_list|(
name|mode
operator|==
name|VM_PROT_READ
argument_list|,
operator|(
literal|"access mode must be read for load instruction."
operator|)
argument_list|)
expr_stmt|;
name|ldl_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|7
expr_stmt|;
name|ldr_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|reg
index|[
name|MIPS_INST_RT
argument_list|(
name|inst
argument_list|)
index|]
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|MIPS_LD_ACCESS
operator|)
return|;
endif|#
directive|endif
case|case
name|OP_SH
case|:
name|KASSERT
argument_list|(
name|mode
operator|==
name|VM_PROT_WRITE
argument_list|,
operator|(
literal|"access mode must be write for store instruction."
operator|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|reg
index|[
name|MIPS_INST_RT
argument_list|(
name|inst
argument_list|)
index|]
expr_stmt|;
name|value_msb
operator|=
name|value
operator|>>
literal|8
expr_stmt|;
name|sb_macro
argument_list|(
name|value_msb
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
name|sb_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|MIPS_SH_ACCESS
operator|)
return|;
case|case
name|OP_SW
case|:
name|KASSERT
argument_list|(
name|mode
operator|==
name|VM_PROT_WRITE
argument_list|,
operator|(
literal|"access mode must be write for store instruction."
operator|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|reg
index|[
name|MIPS_INST_RT
argument_list|(
name|inst
argument_list|)
index|]
expr_stmt|;
name|swl_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|3
expr_stmt|;
name|swr_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|MIPS_SW_ACCESS
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|__mips_n32
argument_list|)
operator|||
name|defined
argument_list|(
name|__mips_n64
argument_list|)
case|case
name|OP_SD
case|:
name|KASSERT
argument_list|(
name|mode
operator|==
name|VM_PROT_WRITE
argument_list|,
operator|(
literal|"access mode must be write for store instruction."
operator|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|reg
index|[
name|MIPS_INST_RT
argument_list|(
name|inst
argument_list|)
index|]
expr_stmt|;
name|sdl_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|7
expr_stmt|;
name|sdr_macro
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|MIPS_SD_ACCESS
operator|)
return|;
endif|#
directive|endif
block|}
name|panic
argument_list|(
literal|"%s: should not be reached."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX TODO: SMP?  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|unaligned_lasterr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unaligned_curerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unaligned_pps_log_limit
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|unaligned_log_pps_limit
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|unaligned_pps_log_limit
argument_list|,
literal|0
argument_list|,
literal|"limit number of userland unaligned log messages per second"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|emulate_unaligned_access
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|register_t
name|pc
decl_stmt|;
name|int
name|access_type
init|=
literal|0
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|pc
operator|=
name|frame
operator|->
name|pc
operator|+
operator|(
name|DELAYBRANCH
argument_list|(
name|frame
operator|->
name|cause
argument_list|)
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
comment|/* 	 * Fall through if it's instruction fetch exception 	 */
if|if
condition|(
operator|!
operator|(
operator|(
name|pc
operator|&
literal|3
operator|)
operator|||
operator|(
name|pc
operator|==
name|frame
operator|->
name|badvaddr
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Handle unaligned load and store 		 */
comment|/* 		 * Return access type if the instruction was emulated. 		 * Otherwise restore pc and fall through. 		 */
name|access_type
operator|=
name|mips_unaligned_load_store
argument_list|(
name|frame
argument_list|,
name|mode
argument_list|,
name|frame
operator|->
name|badvaddr
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_type
condition|)
block|{
if|if
condition|(
name|DELAYBRANCH
argument_list|(
name|frame
operator|->
name|cause
argument_list|)
condition|)
name|frame
operator|->
name|pc
operator|=
name|MipsEmulateBranch
argument_list|(
name|frame
argument_list|,
name|frame
operator|->
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|frame
operator|->
name|pc
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|unaligned_lasterr
argument_list|,
operator|&
name|unaligned_curerr
argument_list|,
name|unaligned_pps_log_limit
argument_list|)
condition|)
block|{
comment|/* XXX TODO: keep global/tid/pid counters? */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Unaligned %s: pid=%ld (%s), tid=%ld, "
literal|"pc=%#jx, badvaddr=%#jx\n"
argument_list|,
name|access_name
index|[
name|access_type
operator|-
literal|1
index|]
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_tid
argument_list|,
operator|(
name|intmax_t
operator|)
name|pc
argument_list|,
operator|(
name|intmax_t
operator|)
name|frame
operator|->
name|badvaddr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|access_type
return|;
block|}
end_function

end_unit

