begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: machdep.c,v 1.33 1998/09/15 10:58:54 pefo Exp $	*/
end_comment

begin_comment
comment|/* tracked to 1.38 */
end_comment

begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department, The Mach Operating System project at  * Carnegie-Mellon University and Ralph Campbell.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)machdep.c	8.3 (Berkeley) 1/12/94  *	Id: machdep.c,v 1.33 1998/09/15 10:58:54 pefo Exp  *	JNPR: machdep.c,v 1.11.2.3 2007/08/29 12:24:49  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_md.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/asm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bootinfo.h>
end_include

begin_include
include|#
directive|include
file|<machine/cache.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpuregs.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<machine/hwfunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/tlb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_define
define|#
directive|define
name|BOOTINFO_DEBUG
value|0
end_define

begin_decl_stmt
name|char
name|machine
index|[]
init|=
literal|"mips"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRING
argument_list|(
name|_hw
argument_list|,
name|HW_MACHINE
argument_list|,
name|machine
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|machine
argument_list|,
literal|0
argument_list|,
literal|"Machine class"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|cpu_model
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRING
argument_list|(
name|_hw
argument_list|,
name|HW_MODEL
argument_list|,
name|model
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|cpu_model
argument_list|,
literal|0
argument_list|,
literal|"Machine model"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|cpu_board
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRING
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|board
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|cpu_board
argument_list|,
literal|0
argument_list|,
literal|"Machine board"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cold
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|realmem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|Maxmem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cpu_clock
init|=
name|MIPS_DEFAULT_HZ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|clockrate
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|cpu_clock
argument_list|,
literal|0
argument_list|,
literal|"CPU instruction clock rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|clocks_running
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|kstack0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Each entry in the pcpu_space[] array is laid out in the following manner:  * struct pcpu for cpu 'n'	pcpu_space[n]  * boot stack for cpu 'n'	pcpu_space[n] + PAGE_SIZE * 2 - CALLFRAME_SIZ  *  * Note that the boot stack grows downwards and we assume that we never  * use enough stack space to trample over the 'struct pcpu' that is at  * the beginning of the array.  *  * The array is aligned on a (PAGE_SIZE * 2) boundary so that the 'struct pcpu'  * is always in the even page frame of the wired TLB entry on SMP kernels.  *  * The array is in the .data section so that the stack does not get zeroed out  * when the .bss section is zeroed.  */
end_comment

begin_decl_stmt
name|char
name|pcpu_space
index|[
name|MAXCPU
index|]
index|[
name|PAGE_SIZE
operator|*
literal|2
index|]
decl|\
name|__aligned
argument_list|(
name|PAGE_SIZE
operator|*
literal|2
argument_list|)
name|__section
argument_list|(
literal|".data"
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pcpu
modifier|*
name|pcpup
init|=
operator|(
expr|struct
name|pcpu
operator|*
operator|)
name|pcpu_space
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_paddr_t
name|phys_avail
index|[
name|PHYS_AVAIL_ENTRIES
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_paddr_t
name|physmem_desc
index|[
name|PHYS_AVAIL_ENTRIES
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_paddr_t
name|dump_avail
index|[
name|PHYS_AVAIL_ENTRIES
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UNIMPLEMENTED
end_ifdef

begin_decl_stmt
name|struct
name|platform
name|platform
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|cpu_startup
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSINIT
argument_list|(
name|cpu
argument_list|,
name|SI_SUB_CPU
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|cpu_startup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|kva_md_info
name|kmi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cpucfg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of processor config register */
end_comment

begin_decl_stmt
name|int
name|num_tlbentries
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the CPU tlb */
end_comment

begin_decl_stmt
name|int
name|cputype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|MipsException
index|[]
decl_stmt|,
name|MipsExceptionEnd
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TLB miss handler address and end */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|MipsTLBMiss
index|[]
decl_stmt|,
name|MipsTLBMissEnd
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cache error handler */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|MipsCache
index|[]
decl_stmt|,
name|MipsCacheEnd
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MIPS wait skip region */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|MipsWaitStart
index|[]
decl_stmt|,
name|MipsWaitEnd
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|edata
index|[]
decl_stmt|,
name|end
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|bootdev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bootinfo
name|bootinfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * First kseg0 address available for use. By default it's equal to&end.  * But in some cases there might be additional data placed right after   * _end by loader or ELF trampoline.  */
end_comment

begin_decl_stmt
name|vm_offset_t
name|kernel_kseg0_end
init|=
operator|(
name|vm_offset_t
operator|)
operator|&
name|end
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|cpu_startup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
if|if
condition|(
name|boothowto
operator|&
name|RB_VERBOSE
condition|)
name|bootverbose
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"real memory  = %ju (%juK bytes)\n"
argument_list|,
name|ptoa
argument_list|(
operator|(
name|uintmax_t
operator|)
name|realmem
argument_list|)
argument_list|,
name|ptoa
argument_list|(
operator|(
name|uintmax_t
operator|)
name|realmem
argument_list|)
operator|/
literal|1024
argument_list|)
expr_stmt|;
comment|/* 	 * Display any holes after the first chunk of extended memory. 	 */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|int
name|indx
decl_stmt|;
name|printf
argument_list|(
literal|"Physical memory chunk(s):\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|indx
operator|=
literal|0
init|;
name|phys_avail
index|[
name|indx
operator|+
literal|1
index|]
operator|!=
literal|0
condition|;
name|indx
operator|+=
literal|2
control|)
block|{
name|vm_paddr_t
name|size1
init|=
name|phys_avail
index|[
name|indx
operator|+
literal|1
index|]
operator|-
name|phys_avail
index|[
name|indx
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"0x%08jx - 0x%08jx, %ju bytes (%ju pages)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|phys_avail
index|[
name|indx
index|]
argument_list|,
operator|(
name|uintmax_t
operator|)
name|phys_avail
index|[
name|indx
operator|+
literal|1
index|]
operator|-
literal|1
argument_list|,
operator|(
name|uintmax_t
operator|)
name|size1
argument_list|,
operator|(
name|uintmax_t
operator|)
name|size1
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
name|vm_ksubmap_init
argument_list|(
operator|&
name|kmi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"avail memory = %ju (%juMB)\n"
argument_list|,
name|ptoa
argument_list|(
operator|(
name|uintmax_t
operator|)
name|vm_cnt
operator|.
name|v_free_count
argument_list|)
argument_list|,
name|ptoa
argument_list|(
operator|(
name|uintmax_t
operator|)
name|vm_cnt
operator|.
name|v_free_count
argument_list|)
operator|/
literal|1048576
argument_list|)
expr_stmt|;
name|cpu_init_interrupts
argument_list|()
expr_stmt|;
comment|/* 	 * Set up buffers, so they can be used to read disk labels. 	 */
name|bufinit
argument_list|()
expr_stmt|;
name|vm_pager_bufferinit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shutdown the CPU as much as possible  */
end_comment

begin_function
name|void
name|cpu_reset
parameter_list|(
name|void
parameter_list|)
block|{
name|platform_reset
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush the D-cache for non-DMA I/O so that the I-cache can  * be made coherent later.  */
end_comment

begin_function
name|void
name|cpu_flush_dcache
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
comment|/* TBD */
block|}
end_function

begin_comment
comment|/* Get current clock frequency for the given cpu id. */
end_comment

begin_function
name|int
name|cpu_est_clockrate
parameter_list|(
name|int
name|cpu_id
parameter_list|,
name|uint64_t
modifier|*
name|rate
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shutdown the CPU as much as possible  */
end_comment

begin_function
name|void
name|cpu_halt
parameter_list|(
name|void
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
empty_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|bootinfo
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|bootinfo
argument_list|,
name|bootinfo
argument_list|,
literal|"Bootinfo struct: kernel filename, BIOS harddisk geometry, etc"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Initialize per cpu data structures, include curthread.  */
end_comment

begin_function
name|void
name|mips_pcpu0_init
parameter_list|()
block|{
comment|/* Initialize pcpu info of cpu-zero */
name|pcpu_init
argument_list|(
name|PCPU_ADDR
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcpu
argument_list|)
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|curthread
argument_list|,
operator|&
name|thread0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize mips and configure to run kernel  */
end_comment

begin_function
name|void
name|mips_proc0_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|platform_processor_id
argument_list|()
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"BSP must be processor number 0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|proc_linkup0
argument_list|(
operator|&
name|proc0
argument_list|,
operator|&
name|thread0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|kstack0
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"kstack0 is not aligned on a page boundary: 0x%0lx"
operator|,
operator|(
name|long
operator|)
name|kstack0
operator|)
argument_list|)
expr_stmt|;
name|thread0
operator|.
name|td_kstack
operator|=
name|kstack0
expr_stmt|;
name|thread0
operator|.
name|td_kstack_pages
operator|=
name|KSTACK_PAGES
expr_stmt|;
comment|/*  	 * Do not use cpu_thread_alloc to initialize these fields  	 * thread0 is the only thread that has kstack located in KSEG0  	 * while cpu_thread_alloc handles kstack allocated in KSEG2. 	 */
name|thread0
operator|.
name|td_pcb
operator|=
operator|(
expr|struct
name|pcb
operator|*
operator|)
operator|(
name|thread0
operator|.
name|td_kstack
operator|+
name|thread0
operator|.
name|td_kstack_pages
operator|*
name|PAGE_SIZE
operator|)
operator|-
literal|1
expr_stmt|;
name|thread0
operator|.
name|td_frame
operator|=
operator|&
name|thread0
operator|.
name|td_pcb
operator|->
name|pcb_regs
expr_stmt|;
comment|/* Steal memory for the dynamic per-cpu area. */
name|dpcpu_init
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pmap_steal_memory
argument_list|(
name|DPCPU_SIZE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|curpcb
argument_list|,
name|thread0
operator|.
name|td_pcb
argument_list|)
expr_stmt|;
comment|/* 	 * There is no need to initialize md_upte array for thread0 as it's 	 * located in .bss section and should be explicitly zeroed during  	 * kernel initialization. 	 */
block|}
end_function

begin_function
name|void
name|cpu_initclocks
parameter_list|(
name|void
parameter_list|)
block|{
name|platform_initclocks
argument_list|()
expr_stmt|;
name|cpu_initclocks_bsp
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|msgbuf
modifier|*
name|msgbufp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize the hardware exception vectors, and the jump table used to  * call locore cache and TLB management functions, based on the kind  * of CPU the kernel is running on.  */
end_comment

begin_function
name|void
name|mips_vector_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Make sure that the Wait region logic is not been  	 * changed 	 */
if|if
condition|(
name|MipsWaitEnd
operator|-
name|MipsWaitStart
operator|!=
literal|16
condition|)
name|panic
argument_list|(
literal|"startup: MIPS wait region not correct"
argument_list|)
expr_stmt|;
comment|/* 	 * Copy down exception vector code. 	 */
if|if
condition|(
name|MipsTLBMissEnd
operator|-
name|MipsTLBMiss
operator|>
literal|0x80
condition|)
name|panic
argument_list|(
literal|"startup: UTLB code too large"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MipsCacheEnd
operator|-
name|MipsCache
operator|>
literal|0x80
condition|)
name|panic
argument_list|(
literal|"startup: Cache error code too large"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|MipsTLBMiss
argument_list|,
operator|(
name|void
operator|*
operator|)
name|MIPS_UTLB_MISS_EXC_VEC
argument_list|,
name|MipsTLBMissEnd
operator|-
name|MipsTLBMiss
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRW: Why don't we install the XTLB handler for all 64-bit 	 * architectures? 	 */
if|#
directive|if
name|defined
argument_list|(
name|__mips_n64
argument_list|)
operator|||
name|defined
argument_list|(
name|CPU_RMI
argument_list|)
operator|||
name|defined
argument_list|(
name|CPU_NLM
argument_list|)
operator|||
name|defined
argument_list|(
name|CPU_BERI
argument_list|)
comment|/* Fake, but sufficient, for the 32-bit with 64-bit hardware addresses  */
name|bcopy
argument_list|(
name|MipsTLBMiss
argument_list|,
operator|(
name|void
operator|*
operator|)
name|MIPS_XTLB_MISS_EXC_VEC
argument_list|,
name|MipsTLBMissEnd
operator|-
name|MipsTLBMiss
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
name|MipsException
argument_list|,
operator|(
name|void
operator|*
operator|)
name|MIPS_GEN_EXC_VEC
argument_list|,
name|MipsExceptionEnd
operator|-
name|MipsException
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|MipsCache
argument_list|,
operator|(
name|void
operator|*
operator|)
name|MIPS_CACHE_ERR_EXC_VEC
argument_list|,
name|MipsCacheEnd
operator|-
name|MipsCache
argument_list|)
expr_stmt|;
comment|/* 	 * Clear out the I and D caches. 	 */
name|mips_icache_sync_all
argument_list|()
expr_stmt|;
name|mips_dcache_wbinv_all
argument_list|()
expr_stmt|;
comment|/*  	 * Mask all interrupts. Each interrupt will be enabled 	 * when handler is installed for it 	 */
name|set_intr_mask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear BEV in SR so we start handling our own exceptions */
name|mips_wr_status
argument_list|(
name|mips_rd_status
argument_list|()
operator|&
operator|~
name|MIPS_SR_BEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fix kernel_kseg0_end address in case trampoline placed debug sympols   * data there  */
end_comment

begin_function
name|void
name|mips_postboot_fixup
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|fake_preload
index|[
literal|256
index|]
decl_stmt|;
name|caddr_t
name|preload_ptr
init|=
operator|(
name|caddr_t
operator|)
operator|&
name|fake_preload
index|[
literal|0
index|]
decl_stmt|;
name|size_t
name|size
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|PRELOAD_PUSH_VALUE
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
value|do {		\ 	*(type *)(preload_ptr + size) = (value);	\ 	size += sizeof(type);				\ } while (0);
comment|/* 	 * Provide kernel module file information 	 */
name|PRELOAD_PUSH_VALUE
argument_list|(
name|uint32_t
argument_list|,
name|MODINFO_NAME
argument_list|)
expr_stmt|;
name|PRELOAD_PUSH_VALUE
argument_list|(
name|uint32_t
argument_list|,
name|strlen
argument_list|(
literal|"kernel"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|preload_ptr
operator|+
name|size
operator|)
argument_list|,
literal|"kernel"
argument_list|)
expr_stmt|;
name|size
operator|+=
name|strlen
argument_list|(
literal|"kernel"
argument_list|)
operator|+
literal|1
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|PRELOAD_PUSH_VALUE
argument_list|(
name|uint32_t
argument_list|,
name|MODINFO_TYPE
argument_list|)
expr_stmt|;
name|PRELOAD_PUSH_VALUE
argument_list|(
name|uint32_t
argument_list|,
name|strlen
argument_list|(
literal|"elf kernel"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|preload_ptr
operator|+
name|size
operator|)
argument_list|,
literal|"elf kernel"
argument_list|)
expr_stmt|;
name|size
operator|+=
name|strlen
argument_list|(
literal|"elf kernel"
argument_list|)
operator|+
literal|1
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|PRELOAD_PUSH_VALUE
argument_list|(
name|uint32_t
argument_list|,
name|MODINFO_ADDR
argument_list|)
expr_stmt|;
name|PRELOAD_PUSH_VALUE
argument_list|(
name|uint32_t
argument_list|,
sizeof|sizeof
argument_list|(
name|vm_offset_t
argument_list|)
argument_list|)
expr_stmt|;
name|PRELOAD_PUSH_VALUE
argument_list|(
name|vm_offset_t
argument_list|,
name|KERNLOADADDR
argument_list|)
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|PRELOAD_PUSH_VALUE
argument_list|(
name|uint32_t
argument_list|,
name|MODINFO_SIZE
argument_list|)
expr_stmt|;
name|PRELOAD_PUSH_VALUE
argument_list|(
name|uint32_t
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
name|PRELOAD_PUSH_VALUE
argument_list|(
name|size_t
argument_list|,
operator|(
name|size_t
operator|)
operator|&
name|end
operator|-
name|KERNLOADADDR
argument_list|)
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
comment|/* End marker */
name|PRELOAD_PUSH_VALUE
argument_list|(
name|uint32_t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRELOAD_PUSH_VALUE
argument_list|(
name|uint32_t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PRELOAD_PUSH_VALUE
name|KASSERT
argument_list|(
operator|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|fake_preload
argument_list|)
operator|)
argument_list|,
operator|(
literal|"fake preload size is more thenallocated"
operator|)
argument_list|)
expr_stmt|;
name|preload_metadata
operator|=
operator|(
name|void
operator|*
operator|)
name|fake_preload
expr_stmt|;
ifdef|#
directive|ifdef
name|DDB
name|Elf_Size
modifier|*
name|trampoline_data
init|=
operator|(
name|Elf_Size
operator|*
operator|)
name|kernel_kseg0_end
decl_stmt|;
name|Elf_Size
name|symtabsize
init|=
literal|0
decl_stmt|;
name|vm_offset_t
name|ksym_start
decl_stmt|;
name|vm_offset_t
name|ksym_end
decl_stmt|;
if|if
condition|(
name|trampoline_data
index|[
literal|0
index|]
operator|==
name|SYMTAB_MAGIC
condition|)
block|{
name|symtabsize
operator|=
name|trampoline_data
index|[
literal|1
index|]
expr_stmt|;
name|kernel_kseg0_end
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Size
argument_list|)
expr_stmt|;
comment|/* start of .symtab */
name|ksym_start
operator|=
name|kernel_kseg0_end
expr_stmt|;
name|kernel_kseg0_end
operator|+=
name|symtabsize
expr_stmt|;
comment|/* end of .strtab */
name|ksym_end
operator|=
name|kernel_kseg0_end
expr_stmt|;
name|db_fetch_ksymtab
argument_list|(
name|ksym_start
argument_list|,
name|ksym_end
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
name|void
name|mips_pcpu_tlb_init
parameter_list|(
name|struct
name|pcpu
modifier|*
name|pcpu
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|pt_entry_t
name|pte
decl_stmt|;
comment|/* 	 * Map the pcpu structure at the virtual address 'pcpup'. 	 * We use a wired tlb index to do this one-time mapping. 	 */
name|pa
operator|=
name|vtophys
argument_list|(
name|pcpu
argument_list|)
expr_stmt|;
name|pte
operator|=
name|PTE_D
operator||
name|PTE_V
operator||
name|PTE_G
operator||
name|PTE_C_CACHE
expr_stmt|;
name|tlb_insert_wired
argument_list|(
name|PCPU_TLB_ENTRY
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|pcpup
argument_list|,
name|TLBLO_PA_TO_PFN
argument_list|(
name|pa
argument_list|)
operator||
name|pte
argument_list|,
name|TLBLO_PA_TO_PFN
argument_list|(
name|pa
operator|+
name|PAGE_SIZE
argument_list|)
operator||
name|pte
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Initialise a struct pcpu.  */
end_comment

begin_function
name|void
name|cpu_pcpu_init
parameter_list|(
name|struct
name|pcpu
modifier|*
name|pcpu
parameter_list|,
name|int
name|cpuid
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|pcpu
operator|->
name|pc_next_asid
operator|=
literal|1
expr_stmt|;
name|pcpu
operator|->
name|pc_asid_generation
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
operator|(
name|vm_offset_t
operator|)
name|pcpup
operator|>=
name|VM_MIN_KERNEL_ADDRESS
operator|&&
operator|(
name|vm_offset_t
operator|)
name|pcpup
operator|<=
name|VM_MAX_KERNEL_ADDRESS
condition|)
block|{
name|mips_pcpu_tlb_init
argument_list|(
name|pcpu
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|fill_dbregs
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|dbreg
modifier|*
name|dbregs
parameter_list|)
block|{
comment|/* No debug registers on mips */
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_dbregs
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|dbreg
modifier|*
name|dbregs
parameter_list|)
block|{
comment|/* No debug registers on mips */
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spinlock_enter
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|register_t
name|intr
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_md
operator|.
name|md_spinlock_count
operator|==
literal|0
condition|)
block|{
name|intr
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|td
operator|->
name|td_md
operator|.
name|md_spinlock_count
operator|=
literal|1
expr_stmt|;
name|td
operator|->
name|td_md
operator|.
name|md_saved_intr
operator|=
name|intr
expr_stmt|;
block|}
else|else
name|td
operator|->
name|td_md
operator|.
name|md_spinlock_count
operator|++
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spinlock_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|register_t
name|intr
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|intr
operator|=
name|td
operator|->
name|td_md
operator|.
name|md_saved_intr
expr_stmt|;
name|td
operator|->
name|td_md
operator|.
name|md_spinlock_count
operator|--
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_md
operator|.
name|md_spinlock_count
operator|==
literal|0
condition|)
name|intr_restore
argument_list|(
name|intr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * call platform specific code to halt (until next interrupt) for the idle loop  */
end_comment

begin_function
name|void
name|cpu_idle
parameter_list|(
name|int
name|busy
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|mips_rd_status
argument_list|()
operator|&
name|MIPS_SR_INT_IE
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"interrupts disabled in idle process."
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|mips_rd_status
argument_list|()
operator|&
name|MIPS_INT_MASK
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"all interrupts masked in idle process."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|busy
condition|)
block|{
name|critical_enter
argument_list|()
expr_stmt|;
name|cpu_idleclock
argument_list|()
expr_stmt|;
block|}
name|mips_wait
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|busy
condition|)
block|{
name|cpu_activeclock
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|cpu_idle_wakeup
parameter_list|(
name|int
name|cpu
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|is_cacheable_mem
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|physmem_desc
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|pa
operator|>=
name|physmem_desc
index|[
name|i
index|]
operator|&&
name|pa
operator|<
name|physmem_desc
index|[
name|i
operator|+
literal|1
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

