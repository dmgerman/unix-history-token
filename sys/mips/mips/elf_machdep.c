begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 1996-1998 John D. Polstra.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	from: src/sys/i386/i386/elf_machdep.c,v 1.20 2004/08/11 02:35:05 marcel  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_elf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/cache.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__mips_n64
end_ifdef

begin_decl_stmt
name|struct
name|sysentvec
name|elf64_freebsd_sysvec
init|=
block|{
operator|.
name|sv_size
operator|=
name|SYS_MAXSYSCALL
block|,
operator|.
name|sv_table
operator|=
name|sysent
block|,
operator|.
name|sv_mask
operator|=
literal|0
block|,
operator|.
name|sv_errsize
operator|=
literal|0
block|,
operator|.
name|sv_errtbl
operator|=
name|NULL
block|,
operator|.
name|sv_transtrap
operator|=
name|NULL
block|,
operator|.
name|sv_fixup
operator|=
name|__elfN
argument_list|(
name|freebsd_fixup
argument_list|)
block|,
operator|.
name|sv_sendsig
operator|=
name|sendsig
block|,
operator|.
name|sv_sigcode
operator|=
name|sigcode
block|,
operator|.
name|sv_szsigcode
operator|=
operator|&
name|szsigcode
block|,
operator|.
name|sv_name
operator|=
literal|"FreeBSD ELF64"
block|,
operator|.
name|sv_coredump
operator|=
name|__elfN
argument_list|(
name|coredump
argument_list|)
block|,
operator|.
name|sv_imgact_try
operator|=
name|NULL
block|,
operator|.
name|sv_minsigstksz
operator|=
name|MINSIGSTKSZ
block|,
operator|.
name|sv_pagesize
operator|=
name|PAGE_SIZE
block|,
operator|.
name|sv_minuser
operator|=
name|VM_MIN_ADDRESS
block|,
operator|.
name|sv_maxuser
operator|=
name|VM_MAXUSER_ADDRESS
block|,
operator|.
name|sv_usrstack
operator|=
name|USRSTACK
block|,
operator|.
name|sv_psstrings
operator|=
name|PS_STRINGS
block|,
operator|.
name|sv_stackprot
operator|=
name|VM_PROT_ALL
block|,
operator|.
name|sv_copyout_strings
operator|=
name|exec_copyout_strings
block|,
operator|.
name|sv_setregs
operator|=
name|exec_setregs
block|,
operator|.
name|sv_fixlimit
operator|=
name|NULL
block|,
operator|.
name|sv_maxssiz
operator|=
name|NULL
block|,
operator|.
name|sv_flags
operator|=
name|SV_ABI_FREEBSD
operator||
name|SV_LP64
block|,
operator|.
name|sv_set_syscall_retval
operator|=
name|cpu_set_syscall_retval
block|,
operator|.
name|sv_fetch_syscall_args
operator|=
name|cpu_fetch_syscall_args
block|,
operator|.
name|sv_syscallnames
operator|=
name|syscallnames
block|,
operator|.
name|sv_schedtail
operator|=
name|NULL
block|,
operator|.
name|sv_thread_detach
operator|=
name|NULL
block|,
operator|.
name|sv_trap
operator|=
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf64_Brandinfo
name|freebsd_brand_info
init|=
block|{
operator|.
name|brand
operator|=
name|ELFOSABI_FREEBSD
block|,
operator|.
name|machine
operator|=
name|EM_MIPS
block|,
operator|.
name|compat_3_brand
operator|=
literal|"FreeBSD"
block|,
operator|.
name|emul_path
operator|=
name|NULL
block|,
operator|.
name|interp_path
operator|=
literal|"/libexec/ld-elf.so.1"
block|,
operator|.
name|sysvec
operator|=
operator|&
name|elf64_freebsd_sysvec
block|,
operator|.
name|interp_newpath
operator|=
name|NULL
block|,
operator|.
name|flags
operator|=
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|elf64
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_ANY
argument_list|,
operator|(
name|sysinit_cfunc_t
operator|)
name|elf64_insert_brand_entry
argument_list|,
operator|&
name|freebsd_brand_info
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|elf64_dump_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
name|__unused
parameter_list|,
name|void
modifier|*
name|dst
name|__unused
parameter_list|,
name|size_t
modifier|*
name|off
name|__unused
parameter_list|)
block|{ }
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|sysentvec
name|elf32_freebsd_sysvec
init|=
block|{
operator|.
name|sv_size
operator|=
name|SYS_MAXSYSCALL
block|,
operator|.
name|sv_table
operator|=
name|sysent
block|,
operator|.
name|sv_mask
operator|=
literal|0
block|,
operator|.
name|sv_errsize
operator|=
literal|0
block|,
operator|.
name|sv_errtbl
operator|=
name|NULL
block|,
operator|.
name|sv_transtrap
operator|=
name|NULL
block|,
operator|.
name|sv_fixup
operator|=
name|__elfN
argument_list|(
name|freebsd_fixup
argument_list|)
block|,
operator|.
name|sv_sendsig
operator|=
name|sendsig
block|,
operator|.
name|sv_sigcode
operator|=
name|sigcode
block|,
operator|.
name|sv_szsigcode
operator|=
operator|&
name|szsigcode
block|,
operator|.
name|sv_name
operator|=
literal|"FreeBSD ELF32"
block|,
operator|.
name|sv_coredump
operator|=
name|__elfN
argument_list|(
name|coredump
argument_list|)
block|,
operator|.
name|sv_imgact_try
operator|=
name|NULL
block|,
operator|.
name|sv_minsigstksz
operator|=
name|MINSIGSTKSZ
block|,
operator|.
name|sv_pagesize
operator|=
name|PAGE_SIZE
block|,
operator|.
name|sv_minuser
operator|=
name|VM_MIN_ADDRESS
block|,
operator|.
name|sv_maxuser
operator|=
name|VM_MAXUSER_ADDRESS
block|,
operator|.
name|sv_usrstack
operator|=
name|USRSTACK
block|,
operator|.
name|sv_psstrings
operator|=
name|PS_STRINGS
block|,
operator|.
name|sv_stackprot
operator|=
name|VM_PROT_ALL
block|,
operator|.
name|sv_copyout_strings
operator|=
name|exec_copyout_strings
block|,
operator|.
name|sv_setregs
operator|=
name|exec_setregs
block|,
operator|.
name|sv_fixlimit
operator|=
name|NULL
block|,
operator|.
name|sv_maxssiz
operator|=
name|NULL
block|,
operator|.
name|sv_flags
operator|=
name|SV_ABI_FREEBSD
operator||
name|SV_ILP32
block|,
operator|.
name|sv_set_syscall_retval
operator|=
name|cpu_set_syscall_retval
block|,
operator|.
name|sv_fetch_syscall_args
operator|=
name|cpu_fetch_syscall_args
block|,
operator|.
name|sv_syscallnames
operator|=
name|syscallnames
block|,
operator|.
name|sv_schedtail
operator|=
name|NULL
block|,
operator|.
name|sv_thread_detach
operator|=
name|NULL
block|,
operator|.
name|sv_trap
operator|=
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf32_Brandinfo
name|freebsd_brand_info
init|=
block|{
operator|.
name|brand
operator|=
name|ELFOSABI_FREEBSD
block|,
operator|.
name|machine
operator|=
name|EM_MIPS
block|,
operator|.
name|compat_3_brand
operator|=
literal|"FreeBSD"
block|,
operator|.
name|emul_path
operator|=
name|NULL
block|,
operator|.
name|interp_path
operator|=
literal|"/libexec/ld-elf.so.1"
block|,
operator|.
name|sysvec
operator|=
operator|&
name|elf32_freebsd_sysvec
block|,
operator|.
name|interp_newpath
operator|=
name|NULL
block|,
operator|.
name|flags
operator|=
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|elf32
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
operator|(
name|sysinit_cfunc_t
operator|)
name|elf32_insert_brand_entry
argument_list|,
operator|&
name|freebsd_brand_info
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|elf32_dump_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
name|__unused
parameter_list|,
name|void
modifier|*
name|dst
name|__unused
parameter_list|,
name|size_t
modifier|*
name|off
name|__unused
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The following MIPS relocation code for tracking multiple  * consecutive HI32/LO32 entries is because of the following:  *  * https://dmz-portal.mips.com/wiki/MIPS_relocation_types  *  * ===  *  * + R_MIPS_HI16  *  * An R_MIPS_HI16 must be followed eventually by an associated R_MIPS_LO16  * relocation record in the same SHT_REL section. The contents of the two  * fields to be relocated are combined to form a full 32-bit addend AHL.  * An R_MIPS_LO16 entry which does not immediately follow a R_MIPS_HI16 is  * combined with the most recent one encountered, i.e. multiple R_MIPS_LO16  * entries may be associated with a single R_MIPS_HI16. Use of these  * relocation types in a SHT_REL section is discouraged and may be  * forbidden to avoid this complication.  *  * A GNU extension allows multiple R_MIPS_HI16 records to share the same  * R_MIPS_LO16 relocation record(s). The association works like this within  * a single relocation section:  *  * + From the beginning of the section moving to the end of the section,  *   until R_MIPS_LO16 is not found each found R_MIPS_HI16 relocation will  *   be associated with the first R_MIPS_LO16.  *  * + Until another R_MIPS_HI16 record is found all found R_MIPS_LO16  *   relocations found are associated with the last R_MIPS_HI16.  *  * ===  *  * This is so gcc can do dead code detection/removal without having to  * generate HI/LO pairs even if one of them would be deleted.  *  * So, the summary is:  *  * + A HI16 entry must occur before any LO16 entries;  * + Multiple consecutive HI16 RELA entries need to be buffered until the  *   first LO16 RELA entry occurs - and then all HI16 RELA relocations use  *   the offset in the LOW16 RELA for calculating their offsets;  * + The last HI16 RELA entry before a LO16 RELA entry is used (the AHL)  *   for the first subsequent LO16 calculation;  * + If multiple consecutive LO16 RELA entries occur, only the first  *   LO16 RELA entry triggers an update of buffered HI16 RELA entries;  *   any subsequent LO16 RELA entry before another HI16 RELA entry will  *   not cause any further updates to the HI16 RELA entries.  *  * Additionally, flush out any outstanding HI16 entries that don't have  * a LO16 entry in case some garbage entries are left in the file.  */
end_comment

begin_struct_decl
struct_decl|struct
name|mips_tmp_reloc
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|mips_tmp_reloc
block|{
name|struct
name|mips_tmp_reloc
modifier|*
name|next
decl_stmt|;
name|Elf_Addr
name|ahl
decl_stmt|;
name|Elf32_Addr
modifier|*
name|where_hi16
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mips_tmp_reloc
modifier|*
name|ml
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Add a temporary relocation (ie, a HI16 reloc type.)  */
end_comment

begin_function
specifier|static
name|int
name|mips_tmp_reloc_add
parameter_list|(
name|Elf_Addr
name|ahl
parameter_list|,
name|Elf32_Addr
modifier|*
name|where_hi16
parameter_list|)
block|{
name|struct
name|mips_tmp_reloc
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mips_tmp_reloc
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: failed to malloc\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|r
operator|->
name|ahl
operator|=
name|ahl
expr_stmt|;
name|r
operator|->
name|where_hi16
operator|=
name|where_hi16
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|ml
expr_stmt|;
name|ml
operator|=
name|r
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush the temporary relocation list.  *  * This should be done after a file is completely loaded  * so no stale relocations exist to confuse the next  * load.  */
end_comment

begin_function
specifier|static
name|void
name|mips_tmp_reloc_flush
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mips_tmp_reloc
modifier|*
name|r
decl_stmt|,
modifier|*
name|rn
decl_stmt|;
name|r
operator|=
name|ml
expr_stmt|;
name|ml
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
name|rn
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|r
operator|=
name|rn
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get an entry from the reloc list; or NULL if we've run out.  */
end_comment

begin_function
specifier|static
name|struct
name|mips_tmp_reloc
modifier|*
name|mips_tmp_reloc_get
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mips_tmp_reloc
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|ml
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ml
operator|=
name|ml
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a relocation entry.  */
end_comment

begin_function
specifier|static
name|void
name|mips_tmp_reloc_free
parameter_list|(
name|struct
name|mips_tmp_reloc
modifier|*
name|r
parameter_list|)
block|{
name|free
argument_list|(
name|r
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process one elf relocation with addend. */
end_comment

begin_function
specifier|static
name|int
name|elf_reloc_internal
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|Elf_Addr
name|relocbase
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|local
parameter_list|,
name|elf_lookup_fn
name|lookup
parameter_list|)
block|{
name|Elf32_Addr
modifier|*
name|where
init|=
operator|(
name|Elf32_Addr
operator|*
operator|)
name|NULL
decl_stmt|;
name|Elf_Addr
name|addr
decl_stmt|;
name|Elf_Addr
name|addend
init|=
operator|(
name|Elf_Addr
operator|)
literal|0
decl_stmt|;
name|Elf_Word
name|rtype
init|=
operator|(
name|Elf_Word
operator|)
literal|0
decl_stmt|,
name|symidx
decl_stmt|;
name|struct
name|mips_tmp_reloc
modifier|*
name|r
decl_stmt|;
specifier|const
name|Elf_Rel
modifier|*
name|rel
init|=
name|NULL
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|rela
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Store the last seen ahl from a HI16 for LO16 processing */
specifier|static
name|Elf_Addr
name|last_ahl
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ELF_RELOC_REL
case|:
name|rel
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
name|data
expr_stmt|;
name|where
operator|=
operator|(
name|Elf32_Addr
operator|*
operator|)
operator|(
name|relocbase
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|rtype
operator|=
name|ELF_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|symidx
operator|=
name|ELF_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rtype
condition|)
block|{
case|case
name|R_MIPS_64
case|:
name|addend
operator|=
operator|*
operator|(
name|Elf64_Addr
operator|*
operator|)
name|where
expr_stmt|;
break|break;
default|default:
name|addend
operator|=
operator|*
name|where
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ELF_RELOC_RELA
case|:
name|rela
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
name|data
expr_stmt|;
name|where
operator|=
operator|(
name|Elf32_Addr
operator|*
operator|)
operator|(
name|relocbase
operator|+
name|rela
operator|->
name|r_offset
operator|)
expr_stmt|;
name|addend
operator|=
name|rela
operator|->
name|r_addend
expr_stmt|;
name|rtype
operator|=
name|ELF_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|symidx
operator|=
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unknown reloc type %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|rtype
condition|)
block|{
case|case
name|R_MIPS_NONE
case|:
comment|/* none */
break|break;
case|case
name|R_MIPS_32
case|:
comment|/* S + A */
name|error
operator|=
name|lookup
argument_list|(
name|lf
argument_list|,
name|symidx
argument_list|,
literal|1
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|addr
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|*
name|where
operator|!=
name|addr
condition|)
operator|*
name|where
operator|=
operator|(
name|Elf32_Addr
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|R_MIPS_26
case|:
comment|/* ((A<< 2) | (P& 0xf0000000) + S)>> 2 */
name|error
operator|=
name|lookup
argument_list|(
name|lf
argument_list|,
name|symidx
argument_list|,
literal|1
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|addend
operator|&=
literal|0x03ffffff
expr_stmt|;
comment|/* 		 * Addendum for .rela R_MIPS_26 is not shifted right 		 */
if|if
condition|(
name|rela
operator|==
name|NULL
condition|)
name|addend
operator|<<=
literal|2
expr_stmt|;
name|addr
operator|+=
operator|(
operator|(
name|Elf_Addr
operator|)
name|where
operator|&
literal|0xf0000000
operator|)
operator||
name|addend
expr_stmt|;
name|addr
operator|>>=
literal|2
expr_stmt|;
operator|*
name|where
operator|&=
operator|~
literal|0x03ffffff
expr_stmt|;
operator|*
name|where
operator||=
name|addr
operator|&
literal|0x03ffffff
expr_stmt|;
break|break;
case|case
name|R_MIPS_64
case|:
comment|/* S + A */
name|error
operator|=
name|lookup
argument_list|(
name|lf
argument_list|,
name|symidx
argument_list|,
literal|1
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|addr
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|Elf64_Addr
operator|*
operator|)
name|where
operator|!=
name|addr
condition|)
operator|*
operator|(
name|Elf64_Addr
operator|*
operator|)
name|where
operator|=
name|addr
expr_stmt|;
break|break;
comment|/* 	 * Handle the two GNU extension cases: 	 * 	 * + Multiple HI16s followed by a LO16, and 	 * + A HI16 followed by multiple LO16s. 	 * 	 * The former is tricky - the HI16 relocations need 	 * to be buffered until a LO16 occurs, at which point 	 * each HI16 is replayed against the LO16 relocation entry 	 * (with the relevant overflow information.) 	 * 	 * The latter should be easy to handle - when the 	 * first LO16 is seen, write out and flush the 	 * HI16 buffer.  Any subsequent LO16 entries will 	 * find a blank relocation buffer. 	 * 	 */
case|case
name|R_MIPS_HI16
case|:
comment|/* ((AHL + S) - ((short)(AHL + S))>> 16 */
if|if
condition|(
name|rela
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|lookup
argument_list|(
name|lf
argument_list|,
name|symidx
argument_list|,
literal|1
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|addr
operator|+=
name|addend
expr_stmt|;
operator|*
name|where
operator|&=
literal|0xffff0000
expr_stmt|;
operator|*
name|where
operator||=
operator|(
operator|(
operator|(
operator|(
name|long
name|long
operator|)
name|addr
operator|+
literal|0x8000LL
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Add a temporary relocation to the list; 			 * will pop it off / free the list when 			 * we've found a suitable HI16. 			 */
if|if
condition|(
name|mips_tmp_reloc_add
argument_list|(
name|addend
operator|<<
literal|16
argument_list|,
name|where
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 			 * Track the last seen HI16 AHL for use by 			 * the first LO16 AHL calculation. 			 * 			 * The assumption is any intermediary deleted 			 * LO16's were optimised out, so the last 			 * HI16 before the LO16 is the "true" relocation 			 * entry to use for that LO16 write. 			 */
name|last_ahl
operator|=
name|addend
operator|<<
literal|16
expr_stmt|;
block|}
break|break;
case|case
name|R_MIPS_LO16
case|:
comment|/* AHL + S */
if|if
condition|(
name|rela
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|lookup
argument_list|(
name|lf
argument_list|,
name|symidx
argument_list|,
literal|1
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|addr
operator|+=
name|addend
expr_stmt|;
operator|*
name|where
operator|&=
literal|0xffff0000
expr_stmt|;
operator|*
name|where
operator||=
name|addr
operator|&
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
name|Elf_Addr
name|tmp_ahl
decl_stmt|;
name|Elf_Addr
name|tmp_addend
decl_stmt|;
name|tmp_ahl
operator|=
name|last_ahl
operator|+
operator|(
name|int16_t
operator|)
name|addend
expr_stmt|;
name|error
operator|=
name|lookup
argument_list|(
name|lf
argument_list|,
name|symidx
argument_list|,
literal|1
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tmp_addend
operator|=
name|addend
operator|&
literal|0xffff0000
expr_stmt|;
comment|/* Use the last seen ahl for calculating addend */
name|tmp_addend
operator||=
call|(
name|uint16_t
call|)
argument_list|(
name|tmp_ahl
operator|+
name|addr
argument_list|)
expr_stmt|;
operator|*
name|where
operator|=
name|tmp_addend
expr_stmt|;
comment|/* 			 * This logic implements the "we saw multiple HI16 			 * before a LO16" assignment /and/ "we saw multiple 			 * LO16s". 			 * 			 * Multiple LO16s will be handled as a blank 			 * relocation list. 			 * 			 * Multple HI16's are iterated over here. 			 */
while|while
condition|(
operator|(
name|r
operator|=
name|mips_tmp_reloc_get
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Elf_Addr
name|rahl
decl_stmt|;
comment|/* 				 * We have the ahl from the HI16 entry, so 				 * offset it by the 16 bits of the low ahl. 				 */
name|rahl
operator|=
name|r
operator|->
name|ahl
expr_stmt|;
name|rahl
operator|+=
operator|(
name|int16_t
operator|)
name|addend
expr_stmt|;
name|tmp_addend
operator|=
operator|*
operator|(
name|r
operator|->
name|where_hi16
operator|)
expr_stmt|;
name|tmp_addend
operator|&=
literal|0xffff0000
expr_stmt|;
name|tmp_addend
operator||=
operator|(
operator|(
name|rahl
operator|+
name|addr
operator|)
operator|-
call|(
name|int16_t
call|)
argument_list|(
name|rahl
operator|+
name|addr
argument_list|)
operator|)
operator|>>
literal|16
expr_stmt|;
operator|*
operator|(
name|r
operator|->
name|where_hi16
operator|)
operator|=
name|tmp_addend
expr_stmt|;
name|mips_tmp_reloc_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|R_MIPS_HIGHER
case|:
comment|/* %higher(A+S) */
name|error
operator|=
name|lookup
argument_list|(
name|lf
argument_list|,
name|symidx
argument_list|,
literal|1
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|addr
operator|+=
name|addend
expr_stmt|;
operator|*
name|where
operator|&=
literal|0xffff0000
expr_stmt|;
operator|*
name|where
operator||=
operator|(
operator|(
operator|(
name|long
name|long
operator|)
name|addr
operator|+
literal|0x80008000LL
operator|)
operator|>>
literal|32
operator|)
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
name|R_MIPS_HIGHEST
case|:
comment|/* %highest(A+S) */
name|error
operator|=
name|lookup
argument_list|(
name|lf
argument_list|,
name|symidx
argument_list|,
literal|1
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|addr
operator|+=
name|addend
expr_stmt|;
operator|*
name|where
operator|&=
literal|0xffff0000
expr_stmt|;
operator|*
name|where
operator||=
operator|(
operator|(
operator|(
name|long
name|long
operator|)
name|addr
operator|+
literal|0x800080008000LL
operator|)
operator|>>
literal|48
operator|)
operator|&
literal|0xffff
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"kldload: unexpected relocation type %d\n"
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|elf_reloc
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|Elf_Addr
name|relocbase
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|type
parameter_list|,
name|elf_lookup_fn
name|lookup
parameter_list|)
block|{
return|return
operator|(
name|elf_reloc_internal
argument_list|(
name|lf
argument_list|,
name|relocbase
argument_list|,
name|data
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|lookup
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|elf_reloc_local
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|Elf_Addr
name|relocbase
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|type
parameter_list|,
name|elf_lookup_fn
name|lookup
parameter_list|)
block|{
return|return
operator|(
name|elf_reloc_internal
argument_list|(
name|lf
argument_list|,
name|relocbase
argument_list|,
name|data
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
name|lookup
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|elf_cpu_load_file
parameter_list|(
name|linker_file_t
name|lf
name|__unused
parameter_list|)
block|{
comment|/* 	 * Sync the I and D caches to make sure our relocations are visible. 	 */
name|mips_icache_sync_all
argument_list|()
expr_stmt|;
comment|/* Flush outstanding relocations */
name|mips_tmp_reloc_flush
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|elf_cpu_unload_file
parameter_list|(
name|linker_file_t
name|lf
name|__unused
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

