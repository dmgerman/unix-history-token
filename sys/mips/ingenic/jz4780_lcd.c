begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Jared McNeill<jmcneill@invisible.ca>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Ingenic JZ4780 LCD Controller  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/fbio.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<dev/videomode/videomode.h>
end_include

begin_include
include|#
directive|include
file|<dev/videomode/edidvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/extres/clk/clk.h>
end_include

begin_include
include|#
directive|include
file|<mips/ingenic/jz4780_lcd.h>
end_include

begin_include
include|#
directive|include
file|"fb_if.h"
end_include

begin_include
include|#
directive|include
file|"hdmi_if.h"
end_include

begin_define
define|#
directive|define
name|FB_DEFAULT_W
value|800
end_define

begin_define
define|#
directive|define
name|FB_DEFAULT_H
value|600
end_define

begin_define
define|#
directive|define
name|FB_DEFAULT_REF
value|60
end_define

begin_define
define|#
directive|define
name|FB_BPP
value|32
end_define

begin_define
define|#
directive|define
name|FB_ALIGN
value|(16 * 4)
end_define

begin_define
define|#
directive|define
name|FB_MAX_BW
value|(1920 * 1080 * 60)
end_define

begin_define
define|#
directive|define
name|FB_MAX_W
value|2048
end_define

begin_define
define|#
directive|define
name|FB_MAX_H
value|2048
end_define

begin_define
define|#
directive|define
name|FB_DIVIDE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + ((y) / 2)) / (y))
end_define

begin_define
define|#
directive|define
name|PCFG_MAGIC
value|0xc7ff2100
end_define

begin_define
define|#
directive|define
name|DOT_CLOCK_TO_HZ
parameter_list|(
name|c
parameter_list|)
value|((c) * 1000)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|VM_MEMATTR_WRITE_COMBINING
end_ifndef

begin_define
define|#
directive|define
name|VM_MEMATTR_WRITE_COMBINING
value|VM_MEMATTR_UNCACHEABLE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|jzlcd_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|device_t
name|fbdev
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
index|[
literal|1
index|]
decl_stmt|;
comment|/* Clocks */
name|clk_t
name|clk
decl_stmt|;
name|clk_t
name|clk_pix
decl_stmt|;
comment|/* Framebuffer */
name|struct
name|fb_info
name|info
decl_stmt|;
name|size_t
name|fbsize
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
comment|/* HDMI */
name|eventhandler_tag
name|hdmi_evh
decl_stmt|;
comment|/* Frame descriptor DMA */
name|bus_dma_tag_t
name|fdesc_tag
decl_stmt|;
name|bus_dmamap_t
name|fdesc_map
decl_stmt|;
name|bus_addr_t
name|fdesc_paddr
decl_stmt|;
name|struct
name|lcd_frame_descriptor
modifier|*
name|fdesc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|jzlcd_spec
index|[]
init|=
block|{
block|{
name|SYS_RES_MEMORY
block|,
literal|0
block|,
name|RF_ACTIVE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LCD_READ
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
value|bus_read_4((sc)->res[0], (reg))
end_define

begin_define
define|#
directive|define
name|LCD_WRITE
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
value|bus_write_4((sc)->res[0], (reg), (val))
end_define

begin_function
specifier|static
name|int
name|jzlcd_allocfb
parameter_list|(
name|struct
name|jzlcd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|vaddr
operator|=
name|kmem_alloc_contig
argument_list|(
name|kernel_arena
argument_list|,
name|sc
operator|->
name|fbsize
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|FB_ALIGN
argument_list|,
literal|0
argument_list|,
name|VM_MEMATTR_WRITE_COMBINING
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vaddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate FB memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sc
operator|->
name|paddr
operator|=
name|pmap_kextract
argument_list|(
name|sc
operator|->
name|vaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|jzlcd_freefb
parameter_list|(
name|struct
name|jzlcd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|kmem_free
argument_list|(
name|kernel_arena
argument_list|,
name|sc
operator|->
name|vaddr
argument_list|,
name|sc
operator|->
name|fbsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jzlcd_start
parameter_list|(
name|struct
name|jzlcd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
comment|/* Clear status registers */
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDSTATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDOSDS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable the controller */
name|ctrl
operator|=
name|LCD_READ
argument_list|(
name|sc
argument_list|,
name|LCDCTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|LCDCTRL_ENA
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|LCDCTRL_DIS
expr_stmt|;
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDCTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jzlcd_stop
parameter_list|(
name|struct
name|jzlcd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|LCD_READ
argument_list|(
name|sc
argument_list|,
name|LCDCTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctrl
operator|&
name|LCDCTRL_ENA
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Disable the controller and wait for it to stop */
name|ctrl
operator||=
name|LCDCTRL_DIS
expr_stmt|;
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDCTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|LCD_READ
argument_list|(
name|sc
argument_list|,
name|LCDSTATE
argument_list|)
operator|&
name|LCDSTATE_LDD
operator|)
operator|==
literal|0
condition|)
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* Clear all status except for disable */
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDSTATE
argument_list|,
name|LCD_READ
argument_list|(
name|sc
argument_list|,
name|LCDSTATE
argument_list|)
operator|&
operator|~
name|LCDSTATE_LDD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jzlcd_setup_descriptor
parameter_list|(
name|struct
name|jzlcd_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|videomode
modifier|*
name|mode
parameter_list|,
name|u_int
name|desno
parameter_list|)
block|{
name|struct
name|lcd_frame_descriptor
modifier|*
name|fdesc
decl_stmt|;
name|int
name|line_sz
decl_stmt|;
comment|/* Frame size is specified in # words */
name|line_sz
operator|=
operator|(
name|mode
operator|->
name|hdisplay
operator|*
name|FB_BPP
operator|)
operator|>>
literal|3
expr_stmt|;
name|line_sz
operator|=
operator|(
operator|(
name|line_sz
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|fdesc
operator|=
name|sc
operator|->
name|fdesc
operator|+
name|desno
expr_stmt|;
if|if
condition|(
name|desno
operator|==
literal|0
condition|)
name|fdesc
operator|->
name|next
operator|=
name|sc
operator|->
name|fdesc_paddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|lcd_frame_descriptor
argument_list|)
expr_stmt|;
else|else
name|fdesc
operator|->
name|next
operator|=
name|sc
operator|->
name|fdesc_paddr
expr_stmt|;
name|fdesc
operator|->
name|physaddr
operator|=
name|sc
operator|->
name|paddr
expr_stmt|;
name|fdesc
operator|->
name|id
operator|=
name|desno
expr_stmt|;
name|fdesc
operator|->
name|cmd
operator|=
name|LCDCMD_FRM_EN
operator||
operator|(
name|line_sz
operator|*
name|mode
operator|->
name|vdisplay
operator|)
expr_stmt|;
name|fdesc
operator|->
name|offs
operator|=
literal|0
expr_stmt|;
name|fdesc
operator|->
name|pw
operator|=
literal|0
expr_stmt|;
name|fdesc
operator|->
name|cnum_pos
operator|=
name|LCDPOS_BPP01_18_24
operator||
name|LCDPOS_PREMULTI01
operator||
operator|(
name|desno
operator|==
literal|0
condition|?
name|LCDPOS_COEF_BLE01_1
else|:
name|LCDPOS_COEF_SLE01
operator|)
expr_stmt|;
name|fdesc
operator|->
name|dessize
operator|=
name|LCDDESSIZE_ALPHA
operator||
operator|(
operator|(
name|mode
operator|->
name|vdisplay
operator|-
literal|1
operator|)
operator|<<
name|LCDDESSIZE_HEIGHT_SHIFT
operator|)
operator||
operator|(
operator|(
name|mode
operator|->
name|hdisplay
operator|-
literal|1
operator|)
operator|<<
name|LCDDESSIZE_WIDTH_SHIFT
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|jzlcd_set_videomode
parameter_list|(
name|struct
name|jzlcd_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|videomode
modifier|*
name|mode
parameter_list|)
block|{
name|u_int
name|hbp
decl_stmt|,
name|hfp
decl_stmt|,
name|hsw
decl_stmt|,
name|vbp
decl_stmt|,
name|vfp
decl_stmt|,
name|vsw
decl_stmt|;
name|u_int
name|hds
decl_stmt|,
name|hde
decl_stmt|,
name|ht
decl_stmt|,
name|vds
decl_stmt|,
name|vde
decl_stmt|,
name|vt
decl_stmt|;
name|uint32_t
name|ctrl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|hbp
operator|=
name|mode
operator|->
name|htotal
operator|-
name|mode
operator|->
name|hsync_end
expr_stmt|;
name|hfp
operator|=
name|mode
operator|->
name|hsync_start
operator|-
name|mode
operator|->
name|hdisplay
expr_stmt|;
name|hsw
operator|=
name|mode
operator|->
name|hsync_end
operator|-
name|mode
operator|->
name|hsync_start
expr_stmt|;
name|vbp
operator|=
name|mode
operator|->
name|vtotal
operator|-
name|mode
operator|->
name|vsync_end
expr_stmt|;
name|vfp
operator|=
name|mode
operator|->
name|vsync_start
operator|-
name|mode
operator|->
name|vdisplay
expr_stmt|;
name|vsw
operator|=
name|mode
operator|->
name|vsync_end
operator|-
name|mode
operator|->
name|vsync_start
expr_stmt|;
name|hds
operator|=
name|hsw
operator|+
name|hbp
expr_stmt|;
name|hde
operator|=
name|hds
operator|+
name|mode
operator|->
name|hdisplay
expr_stmt|;
name|ht
operator|=
name|hde
operator|+
name|hfp
expr_stmt|;
name|vds
operator|=
name|vsw
operator|+
name|vbp
expr_stmt|;
name|vde
operator|=
name|vds
operator|+
name|mode
operator|->
name|vdisplay
expr_stmt|;
name|vt
operator|=
name|vde
operator|+
name|vfp
expr_stmt|;
comment|/* Setup timings */
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDVAT
argument_list|,
operator|(
name|ht
operator|<<
name|LCDVAT_HT_SHIFT
operator|)
operator||
operator|(
name|vt
operator|<<
name|LCDVAT_VT_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDDAH
argument_list|,
operator|(
name|hds
operator|<<
name|LCDDAH_HDS_SHIFT
operator|)
operator||
operator|(
name|hde
operator|<<
name|LCDDAH_HDE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDDAV
argument_list|,
operator|(
name|vds
operator|<<
name|LCDDAV_VDS_SHIFT
operator|)
operator||
operator|(
name|vde
operator|<<
name|LCDDAV_VDE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDHSYNC
argument_list|,
name|hsw
argument_list|)
expr_stmt|;
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDVSYNC
argument_list|,
name|vsw
argument_list|)
expr_stmt|;
comment|/* Set configuration */
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDCFG
argument_list|,
name|LCDCFG_NEWDES
operator||
name|LCDCFG_RECOVER
operator||
name|LCDCFG_24
operator||
name|LCDCFG_PSM
operator||
name|LCDCFG_CLSM
operator||
name|LCDCFG_SPLM
operator||
name|LCDCFG_REVM
operator||
name|LCDCFG_PCP
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|LCD_READ
argument_list|(
name|sc
argument_list|,
name|LCDCTRL
argument_list|)
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|LCDCTRL_BST
expr_stmt|;
name|ctrl
operator||=
name|LCDCTRL_BST_64
operator||
name|LCDCTRL_OFUM
expr_stmt|;
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDCTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDPCFG
argument_list|,
name|PCFG_MAGIC
argument_list|)
expr_stmt|;
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDRGBC
argument_list|,
name|LCDRGBC_RGBFMT
argument_list|)
expr_stmt|;
comment|/* Update registers */
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDSTATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup frame descriptors */
name|jzlcd_setup_descriptor
argument_list|(
name|sc
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jzlcd_setup_descriptor
argument_list|(
name|sc
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fdesc_tag
argument_list|,
name|sc
operator|->
name|fdesc_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Setup DMA channels */
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDDA0
argument_list|,
name|sc
operator|->
name|fdesc_paddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|lcd_frame_descriptor
argument_list|)
argument_list|)
expr_stmt|;
name|LCD_WRITE
argument_list|(
name|sc
argument_list|,
name|LCDDA1
argument_list|,
name|sc
operator|->
name|fdesc_paddr
argument_list|)
expr_stmt|;
comment|/* Set display clock */
name|error
operator|=
name|clk_set_freq
argument_list|(
name|sc
operator|->
name|clk_pix
argument_list|,
name|DOT_CLOCK_TO_HZ
argument_list|(
name|mode
operator|->
name|dot_clock
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to set pixel clock to %u Hz\n"
argument_list|,
name|DOT_CLOCK_TO_HZ
argument_list|(
name|mode
operator|->
name|dot_clock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jzlcd_configure
parameter_list|(
name|struct
name|jzlcd_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|videomode
modifier|*
name|mode
parameter_list|)
block|{
name|size_t
name|fbsize
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fbsize
operator|=
name|round_page
argument_list|(
name|mode
operator|->
name|hdisplay
operator|*
name|mode
operator|->
name|vdisplay
operator|*
operator|(
name|FB_BPP
operator|/
name|NBBY
operator|)
argument_list|)
expr_stmt|;
comment|/* Detach the old FB device */
if|if
condition|(
name|sc
operator|->
name|fbdev
operator|!=
name|NULL
condition|)
block|{
name|device_delete_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|fbdev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fbdev
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* If the FB size has changed, free the old FB memory */
if|if
condition|(
name|sc
operator|->
name|fbsize
operator|>
literal|0
operator|&&
name|sc
operator|->
name|fbsize
operator|!=
name|fbsize
condition|)
block|{
name|jzlcd_freefb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vaddr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Allocate the FB if necessary */
name|sc
operator|->
name|fbsize
operator|=
name|fbsize
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vaddr
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|jzlcd_allocfb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate FB memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
comment|/* Setup video mode */
name|error
operator|=
name|jzlcd_set_videomode
argument_list|(
name|sc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Attach framebuffer device */
name|sc
operator|->
name|info
operator|.
name|fb_name
operator|=
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|info
operator|.
name|fb_vbase
operator|=
operator|(
name|intptr_t
operator|)
name|sc
operator|->
name|vaddr
expr_stmt|;
name|sc
operator|->
name|info
operator|.
name|fb_pbase
operator|=
name|sc
operator|->
name|paddr
expr_stmt|;
name|sc
operator|->
name|info
operator|.
name|fb_size
operator|=
name|sc
operator|->
name|fbsize
expr_stmt|;
name|sc
operator|->
name|info
operator|.
name|fb_bpp
operator|=
name|sc
operator|->
name|info
operator|.
name|fb_depth
operator|=
name|FB_BPP
expr_stmt|;
name|sc
operator|->
name|info
operator|.
name|fb_stride
operator|=
name|mode
operator|->
name|hdisplay
operator|*
operator|(
name|FB_BPP
operator|/
name|NBBY
operator|)
expr_stmt|;
name|sc
operator|->
name|info
operator|.
name|fb_width
operator|=
name|mode
operator|->
name|hdisplay
expr_stmt|;
name|sc
operator|->
name|info
operator|.
name|fb_height
operator|=
name|mode
operator|->
name|vdisplay
expr_stmt|;
ifdef|#
directive|ifdef
name|VM_MEMATTR_WRITE_COMBINING
name|sc
operator|->
name|info
operator|.
name|fb_flags
operator|=
name|FB_FLAG_MEMATTR
expr_stmt|;
name|sc
operator|->
name|info
operator|.
name|fb_memattr
operator|=
name|VM_MEMATTR_WRITE_COMBINING
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|fbdev
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"fbd"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fbdev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to add fbd child\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|error
operator|=
name|device_probe_and_attach
argument_list|(
name|sc
operator|->
name|fbdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to attach fbd device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jzlcd_get_bandwidth
parameter_list|(
specifier|const
name|struct
name|videomode
modifier|*
name|mode
parameter_list|)
block|{
name|int
name|refresh
decl_stmt|;
name|refresh
operator|=
name|FB_DIVIDE
argument_list|(
name|FB_DIVIDE
argument_list|(
name|DOT_CLOCK_TO_HZ
argument_list|(
name|mode
operator|->
name|dot_clock
argument_list|)
argument_list|,
name|mode
operator|->
name|htotal
argument_list|)
argument_list|,
name|mode
operator|->
name|vtotal
argument_list|)
expr_stmt|;
return|return
name|mode
operator|->
name|hdisplay
operator|*
name|mode
operator|->
name|vdisplay
operator|*
name|refresh
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jzlcd_mode_supported
parameter_list|(
specifier|const
name|struct
name|videomode
modifier|*
name|mode
parameter_list|)
block|{
comment|/* Width and height must be less than 2048 */
if|if
condition|(
name|mode
operator|->
name|hdisplay
operator|>
name|FB_MAX_W
operator|||
name|mode
operator|->
name|vdisplay
operator|>
name|FB_MAX_H
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Bandwidth check */
if|if
condition|(
name|jzlcd_get_bandwidth
argument_list|(
name|mode
argument_list|)
operator|>
name|FB_MAX_BW
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Interlace modes not yet supported by the driver */
if|if
condition|(
operator|(
name|mode
operator|->
name|flags
operator|&
name|VID_INTERLACE
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|videomode
modifier|*
name|jzlcd_find_mode
parameter_list|(
name|struct
name|edid_info
modifier|*
name|ei
parameter_list|)
block|{
specifier|const
name|struct
name|videomode
modifier|*
name|best
decl_stmt|;
name|int
name|n
decl_stmt|,
name|bw
decl_stmt|,
name|best_bw
decl_stmt|;
comment|/* If the preferred mode is OK, just use it */
if|if
condition|(
name|jzlcd_mode_supported
argument_list|(
name|ei
operator|->
name|edid_preferred_mode
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ei
operator|->
name|edid_preferred_mode
return|;
comment|/* Pick the mode with the highest bandwidth requirements */
name|best
operator|=
name|NULL
expr_stmt|;
name|best_bw
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ei
operator|->
name|edid_nmodes
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|jzlcd_mode_supported
argument_list|(
operator|&
name|ei
operator|->
name|edid_modes
index|[
name|n
index|]
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|bw
operator|=
name|jzlcd_get_bandwidth
argument_list|(
operator|&
name|ei
operator|->
name|edid_modes
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bw
operator|>
name|FB_MAX_BW
condition|)
continue|continue;
if|if
condition|(
name|best
operator|==
name|NULL
operator|||
name|bw
operator|>
name|best_bw
condition|)
block|{
name|best
operator|=
operator|&
name|ei
operator|->
name|edid_modes
index|[
name|n
index|]
expr_stmt|;
name|best_bw
operator|=
name|bw
expr_stmt|;
block|}
block|}
return|return
name|best
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|jzlcd_hdmi_event
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|device_t
name|hdmi_dev
parameter_list|)
block|{
specifier|const
name|struct
name|videomode
modifier|*
name|mode
decl_stmt|;
name|struct
name|videomode
name|hdmi_mode
decl_stmt|;
name|struct
name|jzlcd_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|edid_info
name|ei
decl_stmt|;
name|uint8_t
modifier|*
name|edid
decl_stmt|;
name|uint32_t
name|edid_len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|edid
operator|=
name|NULL
expr_stmt|;
name|edid_len
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|HDMI_GET_EDID
argument_list|(
name|hdmi_dev
argument_list|,
operator|&
name|edid
argument_list|,
operator|&
name|edid_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to get EDID: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|edid_parse
argument_list|(
name|edid
argument_list|,
operator|&
name|ei
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to parse EDID: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|edid_print
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
name|mode
operator|=
name|jzlcd_find_mode
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If a suitable mode could not be found, try the default */
if|if
condition|(
name|mode
operator|==
name|NULL
condition|)
name|mode
operator|=
name|pick_mode_by_ref
argument_list|(
name|FB_DEFAULT_W
argument_list|,
name|FB_DEFAULT_H
argument_list|,
name|FB_DEFAULT_REF
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to find usable video mode\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"using %dx%d\n"
argument_list|,
name|mode
operator|->
name|hdisplay
argument_list|,
name|mode
operator|->
name|vdisplay
argument_list|)
expr_stmt|;
comment|/* Stop the controller */
name|jzlcd_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Configure LCD controller */
name|error
operator|=
name|jzlcd_configure
argument_list|(
name|sc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to configure FB: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Enable HDMI TX */
name|hdmi_mode
operator|=
operator|*
name|mode
expr_stmt|;
name|HDMI_SET_VIDEOMODE
argument_list|(
name|hdmi_dev
argument_list|,
operator|&
name|hdmi_mode
argument_list|)
expr_stmt|;
comment|/* Start the controller! */
name|jzlcd_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jzlcd_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|jzlcd_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
literal|"ingenic,jz4780-lcd"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Ingenic JZ4780 LCD Controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jzlcd_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|jzlcd_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|jzlcd_spec
argument_list|,
name|sc
operator|->
name|res
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate resources for device\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|clk_get_by_ofw_name
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"lcd_clk"
argument_list|,
operator|&
name|sc
operator|->
name|clk
argument_list|)
operator|!=
literal|0
operator|||
name|clk_get_by_ofw_name
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"lcd_pixclk"
argument_list|,
operator|&
name|sc
operator|->
name|clk_pix
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot get clocks\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|clk_enable
argument_list|(
name|sc
operator|->
name|clk
argument_list|)
operator|!=
literal|0
operator|||
name|clk_enable
argument_list|(
name|sc
operator|->
name|clk_pix
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot enable clocks\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lcd_frame_descriptor
argument_list|)
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lcd_frame_descriptor
argument_list|)
operator|*
literal|2
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lcd_frame_descriptor
argument_list|)
operator|*
literal|2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|fdesc_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot create bus dma tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|fdesc_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|fdesc
argument_list|,
name|BUS_DMA_NOCACHE
operator||
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc
operator|->
name|fdesc_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate dma descriptor\n"
argument_list|)
expr_stmt|;
goto|goto
name|dmaalloc_failed
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|fdesc_tag
argument_list|,
name|sc
operator|->
name|fdesc_map
argument_list|,
name|sc
operator|->
name|fdesc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lcd_frame_descriptor
argument_list|)
operator|*
literal|2
argument_list|,
name|jzlcd_dmamap_cb
argument_list|,
operator|&
name|sc
operator|->
name|fdesc_paddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot load dma map\n"
argument_list|)
expr_stmt|;
goto|goto
name|dmaload_failed
goto|;
block|}
name|sc
operator|->
name|hdmi_evh
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|hdmi_event
argument_list|,
name|jzlcd_hdmi_event
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|dmaload_failed
label|:
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|fdesc_tag
argument_list|,
name|sc
operator|->
name|fdesc
argument_list|,
name|sc
operator|->
name|fdesc_map
argument_list|)
expr_stmt|;
name|dmaalloc_failed
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|fdesc_tag
argument_list|)
expr_stmt|;
name|failed
label|:
if|if
condition|(
name|sc
operator|->
name|clk_pix
operator|!=
name|NULL
condition|)
name|clk_release
argument_list|(
name|sc
operator|->
name|clk
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|clk
operator|!=
name|NULL
condition|)
name|clk_release
argument_list|(
name|sc
operator|->
name|clk
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|jzlcd_spec
argument_list|,
name|sc
operator|->
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|fb_info
modifier|*
name|jzlcd_fb_getinfo
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|jzlcd_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|sc
operator|->
name|info
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|jzlcd_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|jzlcd_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|jzlcd_attach
argument_list|)
block|,
comment|/* FB interface */
name|DEVMETHOD
argument_list|(
name|fb_getinfo
argument_list|,
name|jzlcd_fb_getinfo
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|jzlcd_driver
init|=
block|{
literal|"fb"
block|,
name|jzlcd_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|jzlcd_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|jzlcd_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|fb
argument_list|,
name|simplebus
argument_list|,
name|jzlcd_driver
argument_list|,
name|jzlcd_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

