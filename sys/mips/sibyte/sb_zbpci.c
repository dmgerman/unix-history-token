begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Neelkanth Natu  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcib_private.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_include
include|#
directive|include
file|"sb_bus_space.h"
end_include

begin_include
include|#
directive|include
file|"sb_scd.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
specifier|static
struct|struct
block|{
name|vm_offset_t
name|vaddr
decl_stmt|;
name|vm_paddr_t
name|paddr
decl_stmt|;
block|}
name|zbpci_config_space
index|[
name|MAXCPU
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|vm_paddr_t
name|CFG_PADDR_BASE
init|=
literal|0xFE000000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_long
name|PCI_IOSPACE_ADDR
init|=
literal|0xFC000000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_long
name|PCI_IOSPACE_SIZE
init|=
literal|0x02000000
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PCI_MATCH_BYTE_LANES_START
value|0x40000000
end_define

begin_define
define|#
directive|define
name|PCI_MATCH_BYTE_LANES_END
value|0x5FFFFFFF
end_define

begin_define
define|#
directive|define
name|PCI_MATCH_BYTE_LANES_SIZE
value|0x20000000
end_define

begin_define
define|#
directive|define
name|PCI_MATCH_BIT_LANES_MASK
value|(1<< 29)
end_define

begin_define
define|#
directive|define
name|PCI_MATCH_BIT_LANES_START
value|0x60000000
end_define

begin_define
define|#
directive|define
name|PCI_MATCH_BIT_LANES_END
value|0x7FFFFFFF
end_define

begin_define
define|#
directive|define
name|PCI_MATCH_BIT_LANES_SIZE
value|0x20000000
end_define

begin_decl_stmt
specifier|static
name|struct
name|rman
name|port_rman
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zbpci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Broadcom/Sibyte PCI I/O Bridge"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zbpci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|rid
decl_stmt|,
name|size
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
comment|/* 	 * Reserve the physical memory window used to map PCI I/O space. 	 */
name|rid
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|PCI_IOSPACE_ADDR
argument_list|,
name|PCI_IOSPACE_ADDR
operator|+
name|PCI_IOSPACE_SIZE
operator|-
literal|1
argument_list|,
name|PCI_IOSPACE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"Cannot allocate resource for PCI I/O space mapping."
argument_list|)
expr_stmt|;
name|port_rman
operator|.
name|rm_start
operator|=
literal|0
expr_stmt|;
name|port_rman
operator|.
name|rm_end
operator|=
name|PCI_IOSPACE_SIZE
operator|-
literal|1
expr_stmt|;
name|port_rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|port_rman
operator|.
name|rm_descr
operator|=
literal|"PCI I/O ports"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|port_rman
argument_list|)
operator|!=
literal|0
operator|||
name|rman_manage_region
argument_list|(
operator|&
name|port_rman
argument_list|,
literal|0
argument_list|,
name|PCI_IOSPACE_SIZE
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: port_rman"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Reserve the the physical memory that is used to read/write to the 	 * pci config space but don't activate it. We are using a page worth 	 * of KVA as a window over this region. 	 */
name|rid
operator|=
literal|1
expr_stmt|;
name|size
operator|=
operator|(
name|PCI_BUSMAX
operator|+
literal|1
operator|)
operator|*
operator|(
name|PCI_SLOTMAX
operator|+
literal|1
operator|)
operator|*
operator|(
name|PCI_FUNCMAX
operator|+
literal|1
operator|)
operator|*
literal|256
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|CFG_PADDR_BASE
argument_list|,
name|CFG_PADDR_BASE
operator|+
name|size
operator|-
literal|1
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"Cannot allocate resource for config space accesses."
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate the entire "match bit lanes" address space. 	 */
if|#
directive|if
name|_BYTE_ORDER
operator|==
name|_BIG_ENDIAN
name|rid
operator|=
literal|2
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|PCI_MATCH_BIT_LANES_START
argument_list|,
name|PCI_MATCH_BIT_LANES_END
argument_list|,
name|PCI_MATCH_BIT_LANES_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"Cannot allocate resource for pci match bit lanes."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _BYTE_ORDER ==_BIG_ENDIAN */
comment|/* 	 * Allocate KVA for accessing PCI config space. 	 */
name|va
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
operator|*
name|mp_ncpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate virtual addresses for "
literal|"config space access.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|mp_ncpus
condition|;
operator|++
name|n
control|)
name|zbpci_config_space
index|[
name|n
index|]
operator|.
name|vaddr
operator|=
name|va
operator|+
name|n
operator|*
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 * Sibyte has the PCI bus hierarchy rooted at bus 0 and HT-PCI 	 * hierarchy rooted at bus 1. 	 */
if|if
condition|(
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pci"
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"zbpci_attach: could not add pci bus 0.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pci"
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"zbpci_attach: could not add pci bus 1.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"attached.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|zbpci_alloc_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
comment|/* 	 * Handle PCI I/O port resources here and pass everything else to nexus. 	 */
if|if
condition|(
name|type
operator|!=
name|SYS_RES_IOPORT
condition|)
block|{
name|res
operator|=
name|bus_generic_alloc_resource
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
name|res
operator|=
name|rman_reserve_resource
argument_list|(
operator|&
name|port_rman
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rman_set_rid
argument_list|(
name|res
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
comment|/* Activate the resource is requested */
if|if
condition|(
name|flags
operator|&
name|RF_ACTIVE
condition|)
block|{
if|if
condition|(
name|bus_activate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|res
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rman_release_resource
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zbpci_activate_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|void
modifier|*
name|vaddr
decl_stmt|;
name|u_long
name|orig_paddr
decl_stmt|,
name|paddr
decl_stmt|,
name|psize
decl_stmt|;
name|paddr
operator|=
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|psize
operator|=
name|rman_get_size
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|orig_paddr
operator|=
name|paddr
expr_stmt|;
if|#
directive|if
name|_BYTE_ORDER
operator|==
name|_BIG_ENDIAN
comment|/* 	 * The CFE allocates PCI memory resources that map to the 	 * "match byte lanes" address space. This address space works 	 * best for DMA transfers because it does not do any automatic 	 * byte swaps when data crosses the pci-cpu interface. 	 * 	 * This also makes it sub-optimal for accesses to PCI device 	 * registers because it exposes the little-endian nature of 	 * the PCI bus to the big-endian CPU. The Sibyte has another 	 * address window called the "match bit lanes" window which 	 * automatically swaps bytes when data crosses the pci-cpu 	 * interface. 	 * 	 * We "assume" that any bus_space memory accesses done by the 	 * CPU to a PCI device are register/configuration accesses and 	 * are done through the "match bit lanes" window. Any DMA 	 * transfers will continue to be through the "match byte lanes" 	 * window because the PCI BAR registers will not be changed. 	 */
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
condition|)
block|{
if|if
condition|(
name|paddr
operator|>=
name|PCI_MATCH_BYTE_LANES_START
operator|&&
name|paddr
operator|+
name|psize
operator|-
literal|1
operator|<=
name|PCI_MATCH_BYTE_LANES_END
condition|)
block|{
name|paddr
operator||=
name|PCI_MATCH_BIT_LANES_MASK
expr_stmt|;
name|rman_set_start
argument_list|(
name|res
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
name|rman_set_end
argument_list|(
name|res
argument_list|,
name|paddr
operator|+
name|psize
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|type
operator|!=
name|SYS_RES_IOPORT
condition|)
block|{
name|error
operator|=
name|bus_generic_activate_resource
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|#
directive|if
name|_BYTE_ORDER
operator|==
name|_BIG_ENDIAN
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
condition|)
block|{
name|rman_set_start
argument_list|(
name|res
argument_list|,
name|orig_paddr
argument_list|)
expr_stmt|;
name|rman_set_end
argument_list|(
name|res
argument_list|,
name|orig_paddr
operator|+
name|psize
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Map the I/O space resource through the memory window starting 	 * at PCI_IOSPACE_ADDR. 	 */
name|vaddr
operator|=
name|pmap_mapdev
argument_list|(
name|paddr
operator|+
name|PCI_IOSPACE_ADDR
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|rman_set_virtual
argument_list|(
name|res
argument_list|,
name|vaddr
argument_list|)
expr_stmt|;
name|rman_set_bustag
argument_list|(
name|res
argument_list|,
name|mips_bus_space_generic
argument_list|)
expr_stmt|;
name|rman_set_bushandle
argument_list|(
name|res
argument_list|,
operator|(
name|bus_space_handle_t
operator|)
name|vaddr
argument_list|)
expr_stmt|;
return|return
operator|(
name|rman_activate_resource
argument_list|(
name|res
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zbpci_release_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|SYS_RES_IOPORT
condition|)
return|return
operator|(
name|bus_generic_release_resource
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
if|if
condition|(
name|rman_get_flags
argument_list|(
name|r
argument_list|)
operator|&
name|RF_ACTIVE
condition|)
block|{
name|error
operator|=
name|bus_deactivate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|rman_release_resource
argument_list|(
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zbpci_deactivate_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|SYS_RES_IOPORT
condition|)
block|{
return|return
operator|(
name|bus_generic_deactivate_resource
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|pmap_unmapdev
argument_list|(
name|va
argument_list|,
name|rman_get_size
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rman_deactivate_resource
argument_list|(
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zbpci_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCIB_IVAR_DOMAIN
case|:
operator|*
name|result
operator|=
literal|0
expr_stmt|;
comment|/* single PCI domain */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PCIB_IVAR_BUS
case|:
operator|*
name|result
operator|=
name|device_get_unit
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|/* PCI bus 0 or 1 */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * We rely on the CFE to have configured the intline correctly to point to  * one of PCI-A/PCI-B/PCI-C/PCI-D in the interupt mapper.  */
end_comment

begin_function
specifier|static
name|int
name|zbpci_route_interrupt
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
return|return
operator|(
name|PCI_INVALID_IRQ
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is expected to be called in a critical section since it  * changes the per-cpu pci config space va-to-pa mappings.  */
end_comment

begin_function
specifier|static
name|vm_offset_t
name|zbpci_config_space_va
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
name|vm_offset_t
name|va_page
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|,
name|pa_page
decl_stmt|;
if|if
condition|(
name|bus
operator|<=
name|PCI_BUSMAX
operator|&&
name|slot
operator|<=
name|PCI_SLOTMAX
operator|&&
name|func
operator|<=
name|PCI_FUNCMAX
operator|&&
name|reg
operator|<=
name|PCI_REGMAX
operator|&&
operator|(
name|bytes
operator|==
literal|1
operator|||
name|bytes
operator|==
literal|2
operator|||
name|bytes
operator|==
literal|4
operator|)
operator|&&
operator|(
operator|(
name|reg
operator|&
operator|(
name|bytes
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|va_page
operator|=
name|zbpci_config_space
index|[
name|cpu
index|]
operator|.
name|vaddr
expr_stmt|;
name|pa
operator|=
name|CFG_PADDR_BASE
operator||
operator|(
name|bus
operator|<<
literal|16
operator|)
operator||
operator|(
name|slot
operator|<<
literal|11
operator|)
operator||
operator|(
name|func
operator|<<
literal|8
operator|)
operator||
name|reg
expr_stmt|;
if|#
directive|if
name|_BYTE_ORDER
operator|==
name|_BIG_ENDIAN
name|pa
operator|=
name|pa
operator|^
operator|(
literal|4
operator|-
name|bytes
operator|)
expr_stmt|;
endif|#
directive|endif
name|pa_page
operator|=
name|pa
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|zbpci_config_space
index|[
name|cpu
index|]
operator|.
name|paddr
operator|!=
name|pa_page
condition|)
block|{
name|pmap_kremove
argument_list|(
name|va_page
argument_list|)
expr_stmt|;
name|pmap_kenter
argument_list|(
name|va_page
argument_list|,
name|pa_page
argument_list|)
expr_stmt|;
name|zbpci_config_space
index|[
name|cpu
index|]
operator|.
name|paddr
operator|=
name|pa_page
expr_stmt|;
block|}
return|return
operator|(
name|va_page
operator|+
operator|(
name|pa
operator|-
name|pa_page
operator|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|zbpci_read_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|r
parameter_list|,
name|int
name|w
parameter_list|)
block|{
name|uint32_t
name|data
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|va
operator|=
name|zbpci_config_space_va
argument_list|(
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|r
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"zbpci_read_config: invalid %d/%d/%d[%d] %d\n"
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|r
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|w
condition|)
block|{
case|case
literal|4
case|:
name|data
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|va
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|data
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|va
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|data
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|va
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"zbpci_read_config: invalid width %d\n"
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
name|critical_exit
argument_list|()
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zbpci_write_config
parameter_list|(
name|device_t
name|d
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|r
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|int
name|w
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|va
operator|=
name|zbpci_config_space_va
argument_list|(
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|r
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"zbpci_write_config: invalid %d/%d/%d[%d] %d/%d\n"
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|r
argument_list|,
name|data
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|w
condition|)
block|{
case|case
literal|4
case|:
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|va
operator|=
name|data
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|va
operator|=
name|data
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|va
operator|=
name|data
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"zbpci_write_config: invalid width %d\n"
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|zbpci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|zbpci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|zbpci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|zbpci_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|bus_generic_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|zbpci_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|zbpci_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|zbpci_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|zbpci_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bus_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|bus_generic_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_add_child
argument_list|,
name|bus_generic_add_child
argument_list|)
block|,
comment|/* pcib interface */
name|DEVMETHOD
argument_list|(
name|pcib_maxslots
argument_list|,
name|pcib_maxslots
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_read_config
argument_list|,
name|zbpci_read_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_write_config
argument_list|,
name|zbpci_write_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_route_interrupt
argument_list|,
name|zbpci_route_interrupt
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The "zbpci" class inherits from the "pcib" base class. Therefore in  * addition to drivers that belong to the "zbpci" class we will also  * consider drivers belonging to the "pcib" when probing children of  * "zbpci".  */
end_comment

begin_expr_stmt
name|DEFINE_CLASS_1
argument_list|(
name|zbpci
argument_list|,
name|zbpci_driver
argument_list|,
name|zbpci_methods
argument_list|,
literal|0
argument_list|,
name|pcib_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|zbpci_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|zbpci
argument_list|,
name|zbbus
argument_list|,
name|zbpci_driver
argument_list|,
name|zbpci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Big endian bus space routines  */
end_comment

begin_if
if|#
directive|if
name|_BYTE_ORDER
operator|==
name|_BIG_ENDIAN
end_if

begin_comment
comment|/*  * The CPU correctly deals with the big-endian to little-endian swap if  * we are accessing 4 bytes at a time. However if we want to read 1 or 2  * bytes then we need to fudge the address generated by the CPU such that  * it generates the right byte enables on the PCI bus.  */
end_comment

begin_function
specifier|static
name|bus_addr_t
name|sb_match_bit_lane_addr
parameter_list|(
name|bus_addr_t
name|addr
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|vm_offset_t
name|pa
decl_stmt|;
name|pa
operator|=
name|vtophys
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|>=
name|PCI_MATCH_BIT_LANES_START
operator|&&
name|pa
operator|<=
name|PCI_MATCH_BIT_LANES_END
condition|)
return|return
operator|(
name|addr
operator|^
operator|(
literal|4
operator|-
name|bytes
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|sb_big_endian_read8
parameter_list|(
name|bus_addr_t
name|addr
parameter_list|)
block|{
name|bus_addr_t
name|addr2
decl_stmt|;
name|addr2
operator|=
name|sb_match_bit_lane_addr
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|readb
argument_list|(
name|addr2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint16_t
name|sb_big_endian_read16
parameter_list|(
name|bus_addr_t
name|addr
parameter_list|)
block|{
name|bus_addr_t
name|addr2
decl_stmt|;
name|addr2
operator|=
name|sb_match_bit_lane_addr
argument_list|(
name|addr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|readw
argument_list|(
name|addr2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|sb_big_endian_read32
parameter_list|(
name|bus_addr_t
name|addr
parameter_list|)
block|{
name|bus_addr_t
name|addr2
decl_stmt|;
name|addr2
operator|=
name|sb_match_bit_lane_addr
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|readl
argument_list|(
name|addr2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sb_big_endian_write8
parameter_list|(
name|bus_addr_t
name|addr
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|bus_addr_t
name|addr2
decl_stmt|;
name|addr2
operator|=
name|sb_match_bit_lane_addr
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|writeb
argument_list|(
name|addr2
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sb_big_endian_write16
parameter_list|(
name|bus_addr_t
name|addr
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|bus_addr_t
name|addr2
decl_stmt|;
name|addr2
operator|=
name|sb_match_bit_lane_addr
argument_list|(
name|addr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|writew
argument_list|(
name|addr2
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sb_big_endian_write32
parameter_list|(
name|bus_addr_t
name|addr
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bus_addr_t
name|addr2
decl_stmt|;
name|addr2
operator|=
name|sb_match_bit_lane_addr
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|writel
argument_list|(
name|addr2
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _BIG_ENDIAN */
end_comment

end_unit

