begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Neelkanth Natu  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcib_private.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_include
include|#
directive|include
file|"sb_scd.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
specifier|static
struct|struct
block|{
name|vm_offset_t
name|vaddr
decl_stmt|;
name|vm_paddr_t
name|paddr
decl_stmt|;
block|}
name|zbpci_config_space
index|[
name|MAXCPU
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|vm_paddr_t
name|CFG_PADDR_BASE
init|=
literal|0xFE000000
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zbpci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Broadcom/Sibyte PCI I/O Bridge"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zbpci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|rid
decl_stmt|,
name|size
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
comment|/* 	 * Reserve the the physical memory that is used to read/write to the 	 * pci config space but don't activate it. We are using a page worth 	 * of KVA as a window over this region. 	 */
name|rid
operator|=
literal|0
expr_stmt|;
name|size
operator|=
operator|(
name|PCI_BUSMAX
operator|+
literal|1
operator|)
operator|*
operator|(
name|PCI_SLOTMAX
operator|+
literal|1
operator|)
operator|*
operator|(
name|PCI_FUNCMAX
operator|+
literal|1
operator|)
operator|*
literal|256
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|CFG_PADDR_BASE
argument_list|,
name|CFG_PADDR_BASE
operator|+
name|size
operator|-
literal|1
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Cannot allocate resource for config space accesses."
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate KVA for accessing PCI config space. 	 */
name|va
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
operator|*
name|mp_ncpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate virtual addresses for "
literal|"config space access.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|mp_ncpus
condition|;
operator|++
name|n
control|)
block|{
name|zbpci_config_space
index|[
name|n
index|]
operator|.
name|vaddr
operator|=
name|va
operator|+
name|n
operator|*
name|PAGE_SIZE
expr_stmt|;
block|}
comment|/* 	 * Sibyte has the PCI bus hierarchy rooted at bus 0 and HT-PCI 	 * hierarchy rooted at bus 1. 	 */
if|if
condition|(
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pci"
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"zbpci_attach: could not add pci bus 0.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pci"
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"zbpci_attach: could not add pci bus 1.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"attached.\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zbpci_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCIB_IVAR_DOMAIN
case|:
operator|*
name|result
operator|=
literal|0
expr_stmt|;
comment|/* single PCI domain */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PCIB_IVAR_BUS
case|:
operator|*
name|result
operator|=
name|device_get_unit
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|/* PCI bus 0 or 1 */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * We rely on the CFE to have configured the intline correctly to point to  * one of PCI-A/PCI-B/PCI-C/PCI-D in the interupt mapper.  */
end_comment

begin_function
specifier|static
name|int
name|zbpci_route_interrupt
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
return|return
operator|(
name|PCI_INVALID_IRQ
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is expected to be called in a critical section since it  * changes the per-cpu pci config space va-to-pa mappings.  */
end_comment

begin_function
specifier|static
name|vm_offset_t
name|zbpci_config_space_va
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
name|vm_offset_t
name|va_page
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|,
name|pa_page
decl_stmt|;
if|if
condition|(
name|bus
operator|<=
name|PCI_BUSMAX
operator|&&
name|slot
operator|<=
name|PCI_SLOTMAX
operator|&&
name|func
operator|<=
name|PCI_FUNCMAX
operator|&&
name|reg
operator|<=
name|PCI_REGMAX
operator|&&
operator|(
name|bytes
operator|==
literal|1
operator|||
name|bytes
operator|==
literal|2
operator|||
name|bytes
operator|==
literal|4
operator|)
operator|&&
operator|(
operator|(
name|reg
operator|&
operator|(
name|bytes
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|va_page
operator|=
name|zbpci_config_space
index|[
name|cpu
index|]
operator|.
name|vaddr
expr_stmt|;
name|pa
operator|=
name|CFG_PADDR_BASE
operator||
operator|(
name|bus
operator|<<
literal|16
operator|)
operator||
operator|(
name|slot
operator|<<
literal|11
operator|)
operator||
operator|(
name|func
operator|<<
literal|8
operator|)
operator||
name|reg
expr_stmt|;
name|pa_page
operator|=
name|pa
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|zbpci_config_space
index|[
name|cpu
index|]
operator|.
name|paddr
operator|!=
name|pa_page
condition|)
block|{
name|pmap_kremove
argument_list|(
name|va_page
argument_list|)
expr_stmt|;
name|pmap_kenter
argument_list|(
name|va_page
argument_list|,
name|pa_page
argument_list|)
expr_stmt|;
name|zbpci_config_space
index|[
name|cpu
index|]
operator|.
name|paddr
operator|=
name|pa_page
expr_stmt|;
block|}
return|return
operator|(
name|va_page
operator|+
operator|(
name|pa
operator|-
name|pa_page
operator|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|zbpci_read_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|r
parameter_list|,
name|int
name|w
parameter_list|)
block|{
name|uint32_t
name|data
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|va
operator|=
name|zbpci_config_space_va
argument_list|(
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|r
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"zbpci_read_config: invalid %d/%d/%d[%d] %d\n"
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|r
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|w
condition|)
block|{
case|case
literal|4
case|:
name|data
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|va
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|data
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|va
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|data
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|va
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"zbpci_read_config: invalid width %d\n"
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
name|critical_exit
argument_list|()
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zbpci_write_config
parameter_list|(
name|device_t
name|d
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|r
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|int
name|w
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|va
operator|=
name|zbpci_config_space_va
argument_list|(
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|r
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"zbpci_write_config: invalid %d/%d/%d[%d] %d/%d\n"
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|r
argument_list|,
name|data
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|w
condition|)
block|{
case|case
literal|4
case|:
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|va
operator|=
name|data
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|va
operator|=
name|data
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|va
operator|=
name|data
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"zbpci_write_config: invalid width %d\n"
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|zbpci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|zbpci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|zbpci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|zbpci_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|bus_generic_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|bus_generic_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|bus_generic_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bus_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|bus_generic_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_add_child
argument_list|,
name|bus_generic_add_child
argument_list|)
block|,
comment|/* pcib interface */
name|DEVMETHOD
argument_list|(
name|pcib_maxslots
argument_list|,
name|pcib_maxslots
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_read_config
argument_list|,
name|zbpci_read_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_write_config
argument_list|,
name|zbpci_write_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_route_interrupt
argument_list|,
name|zbpci_route_interrupt
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The "zbpci" class inherits from the "pcib" base class. Therefore in  * addition to drivers that belong to the "zbpci" class we will also  * consider drivers belonging to the "pcib" when probing children of  * "zbpci".  */
end_comment

begin_expr_stmt
name|DECLARE_CLASS
argument_list|(
name|pcib_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_CLASS_1
argument_list|(
name|zbpci
argument_list|,
name|zbpci_driver
argument_list|,
name|zbpci_methods
argument_list|,
literal|0
argument_list|,
name|pcib_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|zbpci_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|zbpci
argument_list|,
name|zbbus
argument_list|,
name|zbpci_driver
argument_list|,
name|zbpci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

