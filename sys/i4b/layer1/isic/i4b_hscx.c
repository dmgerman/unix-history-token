begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 2000 Hellmuth Michaelis. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	i4b - Siemens HSCX chip (B-channel) handling  *	--------------------------------------------  *  *	$Id: i4b_hscx.c,v 1.7 2000/05/29 15:41:41 hm Exp $   *  * $FreeBSD$  *  *      last edit-date: [Mon May 29 16:44:50 2000]  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"isic.h"
end_include

begin_if
if|#
directive|if
name|NISIC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_trace.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_isic.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_hscx.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_l1.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_global.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_mbuf.h>
end_include

begin_comment
comment|/*---------------------------------------------------------------------------*  *	HSCX IRQ Handler  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|isic_hscx_irq
parameter_list|(
specifier|register
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|ista
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|u_char
name|ex_irq
parameter_list|)
block|{
specifier|register
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|u_char
name|exir
init|=
literal|0
decl_stmt|;
name|int
name|activity
init|=
operator|-
literal|1
decl_stmt|;
name|u_char
name|cmd
init|=
literal|0
decl_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"%#x"
argument_list|,
name|ista
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex_irq
condition|)
block|{
comment|/* get channel extended irq reg */
name|exir
operator|=
name|HSCX_READ
argument_list|(
name|h_chan
argument_list|,
name|H_EXIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|exir
operator|&
name|HSCX_EXIR_RFO
condition|)
block|{
name|chan
operator|->
name|stat_RFO
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"ex_irq: receive data overflow"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|exir
operator|&
name|HSCX_EXIR_XDU
operator|)
operator|&&
operator|(
name|chan
operator|->
name|bprot
operator|!=
name|BPROT_NONE
operator|)
condition|)
comment|/* xmit data underrun */
block|{
name|chan
operator|->
name|stat_XDU
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"ex_irq: xmit data underrun"
argument_list|)
expr_stmt|;
name|isic_hscx_cmd
argument_list|(
name|sc
argument_list|,
name|h_chan
argument_list|,
name|HSCX_CMDR_XRES
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_head
operator|!=
name|NULL
condition|)
comment|/* don't continue to transmit this buffer */
block|{
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* rx message end, end of frame */
if|if
condition|(
name|ista
operator|&
name|HSCX_ISTA_RME
condition|)
block|{
specifier|register
name|int
name|fifo_data_len
decl_stmt|;
name|u_char
name|rsta
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|rsta
operator|=
name|HSCX_READ
argument_list|(
name|h_chan
argument_list|,
name|H_RSTA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rsta
operator|&
literal|0xf0
operator|)
operator|!=
literal|0xa0
condition|)
block|{
if|if
condition|(
operator|(
name|rsta
operator|&
name|HSCX_RSTA_VFR
operator|)
operator|==
literal|0
condition|)
block|{
name|chan
operator|->
name|stat_VFR
operator|++
expr_stmt|;
name|cmd
operator||=
operator|(
name|HSCX_CMDR_RHR
operator|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"received invalid Frame"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|rsta
operator|&
name|HSCX_RSTA_RDO
condition|)
block|{
name|chan
operator|->
name|stat_RDO
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"receive data overflow"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rsta
operator|&
name|HSCX_RSTA_CRC
operator|)
operator|==
literal|0
condition|)
block|{
name|chan
operator|->
name|stat_CRC
operator|++
expr_stmt|;
name|cmd
operator||=
operator|(
name|HSCX_CMDR_RHR
operator|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"CRC check failed"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|rsta
operator|&
name|HSCX_RSTA_RAB
condition|)
block|{
name|chan
operator|->
name|stat_RAB
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"Receive message aborted"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
block|}
name|fifo_data_len
operator|=
operator|(
operator|(
name|HSCX_READ
argument_list|(
name|h_chan
argument_list|,
name|H_RBCL
argument_list|)
operator|)
operator|&
operator|(
operator|(
name|sc
operator|->
name|sc_bfifolen
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|fifo_data_len
operator|==
literal|0
condition|)
name|fifo_data_len
operator|=
name|sc
operator|->
name|sc_bfifolen
expr_stmt|;
comment|/* all error conditions checked, now decide and take action */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chan
operator|->
name|in_mbuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|chan
operator|->
name|in_mbuf
operator|=
name|i4b_Bgetmbuf
argument_list|(
name|BCH_MAX_DATALEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"L1 isic_hscx_irq: RME, cannot allocate mbuf!\n"
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
name|fifo_data_len
operator|-=
literal|1
expr_stmt|;
comment|/* last byte in fifo is RSTA ! */
if|if
condition|(
operator|(
name|chan
operator|->
name|in_len
operator|+
name|fifo_data_len
operator|)
operator|<=
name|BCH_MAX_DATALEN
condition|)
block|{
comment|/* read data from HSCX fifo */
name|HSCX_RDFIFO
argument_list|(
name|h_chan
argument_list|,
name|chan
operator|->
name|in_cbptr
argument_list|,
name|fifo_data_len
argument_list|)
expr_stmt|;
name|cmd
operator||=
operator|(
name|HSCX_CMDR_RMC
operator|)
expr_stmt|;
name|isic_hscx_cmd
argument_list|(
name|sc
argument_list|,
name|h_chan
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|in_len
operator|+=
name|fifo_data_len
expr_stmt|;
name|chan
operator|->
name|rxcount
operator|+=
name|fifo_data_len
expr_stmt|;
comment|/* setup mbuf data length */
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_RX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0ISICUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_NT
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_rx_data_ready
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|)
expr_stmt|;
name|activity
operator|=
name|ACT_RX
expr_stmt|;
comment|/* mark buffer ptr as unused */
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"RAWHDLC rx buffer overflow in RME, in_len=%d, fifolen=%d"
argument_list|,
name|chan
operator|->
name|in_len
argument_list|,
name|fifo_data_len
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
name|cmd
operator||=
operator|(
name|HSCX_CMDR_RHR
operator||
name|HSCX_CMDR_RMC
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|chan
operator|->
name|in_mbuf
operator|!=
name|NULL
condition|)
block|{
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|in_mbuf
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
name|cmd
operator||=
operator|(
name|HSCX_CMDR_RMC
operator|)
expr_stmt|;
block|}
block|}
comment|/* rx fifo full */
if|if
condition|(
name|ista
operator|&
name|HSCX_ISTA_RPF
condition|)
block|{
if|if
condition|(
name|chan
operator|->
name|in_mbuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|chan
operator|->
name|in_mbuf
operator|=
name|i4b_Bgetmbuf
argument_list|(
name|BCH_MAX_DATALEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"L1 isic_hscx_irq: RPF, cannot allocate mbuf!\n"
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
name|chan
operator|->
name|rxcount
operator|+=
name|sc
operator|->
name|sc_bfifolen
expr_stmt|;
if|if
condition|(
operator|(
name|chan
operator|->
name|in_len
operator|+
name|sc
operator|->
name|sc_bfifolen
operator|)
operator|<=
name|BCH_MAX_DATALEN
condition|)
block|{
comment|/* read data from HSCX fifo */
name|HSCX_RDFIFO
argument_list|(
name|h_chan
argument_list|,
name|chan
operator|->
name|in_cbptr
argument_list|,
name|sc
operator|->
name|sc_bfifolen
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|+=
name|sc
operator|->
name|sc_bfifolen
expr_stmt|;
name|chan
operator|->
name|in_len
operator|+=
name|sc
operator|->
name|sc_bfifolen
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_NONE
condition|)
block|{
comment|/* setup mbuf data length */
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_RX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0ISICUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_NT
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
comment|/* silence detection */
if|if
condition|(
operator|!
operator|(
name|i4b_l1_bchan_tel_silence
argument_list|(
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
argument_list|)
operator|)
condition|)
name|activity
operator|=
name|ACT_RX
expr_stmt|;
operator|(
name|void
operator|)
name|IF_HANDOFF
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
argument_list|,
name|chan
operator|->
name|in_mbuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* signal upper driver that data is available */
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_rx_data_ready
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* alloc new buffer */
if|if
condition|(
operator|(
name|chan
operator|->
name|in_mbuf
operator|=
name|i4b_Bgetmbuf
argument_list|(
name|BCH_MAX_DATALEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"L1 isic_hscx_irq: RPF, cannot allocate new mbuf!\n"
argument_list|)
expr_stmt|;
comment|/* setup new data ptr */
name|chan
operator|->
name|in_cbptr
operator|=
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
expr_stmt|;
comment|/* read data from HSCX fifo */
name|HSCX_RDFIFO
argument_list|(
name|h_chan
argument_list|,
name|chan
operator|->
name|in_cbptr
argument_list|,
name|sc
operator|->
name|sc_bfifolen
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|+=
name|sc
operator|->
name|sc_bfifolen
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
name|sc
operator|->
name|sc_bfifolen
expr_stmt|;
name|chan
operator|->
name|rxcount
operator|+=
name|sc
operator|->
name|sc_bfifolen
expr_stmt|;
block|}
else|else
block|{
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"RAWHDLC rx buffer overflow in RPF, in_len=%d"
argument_list|,
name|chan
operator|->
name|in_len
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
name|cmd
operator||=
operator|(
name|HSCX_CMDR_RHR
operator|)
expr_stmt|;
block|}
block|}
comment|/* command to release fifo space */
name|cmd
operator||=
name|HSCX_CMDR_RMC
expr_stmt|;
block|}
comment|/* transmit fifo empty, new data can be written to fifo */
if|if
condition|(
name|ista
operator|&
name|HSCX_ISTA_XPR
condition|)
block|{
comment|/* 		 * for a description what is going on here, please have 		 * a look at isic_bchannel_start() in i4b_bchan.c ! 		 */
name|int
name|activity
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|nextlen
decl_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"unit %d, chan %d - XPR, Tx Fifo Empty!"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|h_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_cur
operator|==
name|NULL
condition|)
comment|/* last frame is transmitted */
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
argument_list|,
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_head
operator|==
name|NULL
condition|)
block|{
name|chan
operator|->
name|state
operator|&=
operator|~
name|HSCX_TX_ACTIVE
expr_stmt|;
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_tx_queue_empty
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|->
name|state
operator||=
name|HSCX_TX_ACTIVE
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_head
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_TX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0ISICUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_TE
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_NONE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|i4b_l1_bchan_tel_silence
argument_list|(
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|)
operator|)
condition|)
name|activity
operator|=
name|ACT_TX
expr_stmt|;
block|}
else|else
block|{
name|activity
operator|=
name|ACT_TX
expr_stmt|;
block|}
block|}
block|}
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|chan
operator|->
name|out_mbuf_cur
operator|&&
name|len
operator|!=
name|sc
operator|->
name|sc_bfifolen
condition|)
block|{
name|nextlen
operator|=
name|min
argument_list|(
name|chan
operator|->
name|out_mbuf_cur_len
argument_list|,
name|sc
operator|->
name|sc_bfifolen
operator|-
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTDEF
name|printf
argument_list|(
literal|"i:mh=%x, mc=%x, mcp=%x, mcl=%d l=%d nl=%d # "
argument_list|,
name|chan
operator|->
name|out_mbuf_head
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
argument_list|,
name|chan
operator|->
name|out_mbuf_cur_ptr
argument_list|,
name|chan
operator|->
name|out_mbuf_cur_len
argument_list|,
name|len
argument_list|,
name|next_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|isic_hscx_waitxfw
argument_list|(
name|sc
argument_list|,
name|h_chan
argument_list|)
expr_stmt|;
comment|/* necessary !!! */
name|HSCX_WRFIFO
argument_list|(
name|h_chan
argument_list|,
name|chan
operator|->
name|out_mbuf_cur_ptr
argument_list|,
name|nextlen
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|HSCX_CMDR_XTF
expr_stmt|;
name|len
operator|+=
name|nextlen
expr_stmt|;
name|chan
operator|->
name|txcount
operator|+=
name|nextlen
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|+=
name|nextlen
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|-=
name|nextlen
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_cur_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_next
operator|)
operator|!=
name|NULL
condition|)
block|{
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_TX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0ISICUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_TE
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|chan
operator|->
name|bprot
operator|!=
name|BPROT_NONE
condition|)
name|cmd
operator||=
name|HSCX_CMDR_XME
expr_stmt|;
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
name|chan
operator|->
name|out_mbuf_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|cmd
condition|)
comment|/* is there a command for the HSCX ? */
block|{
name|isic_hscx_cmd
argument_list|(
name|sc
argument_list|,
name|h_chan
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* yes, to HSCX */
block|}
comment|/* call timeout handling routine */
if|if
condition|(
name|activity
operator|==
name|ACT_RX
operator|||
name|activity
operator|==
name|ACT_TX
condition|)
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_activity
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|,
name|activity
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	HSCX initialization  *  *	for telephony: extended transparent mode 1  *	for raw hdlc:  transparent mode 0  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|isic_hscx_init
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|int
name|activate
parameter_list|)
block|{
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* mask irq's */
if|if
condition|(
name|sc
operator|->
name|sc_ipac
condition|)
block|{
comment|/* CCR1: Power Up, Clock Mode 5 */
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_CCR1
argument_list|,
name|HSCX_CCR1_PU
operator||
comment|/* power up */
name|HSCX_CCR1_CM1
argument_list|)
expr_stmt|;
comment|/* IPAC clock mode 5 */
block|}
else|else
block|{
comment|/* CCR1: Power Up, Clock Mode 5 */
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_CCR1
argument_list|,
name|HSCX_CCR1_PU
operator||
comment|/* power up */
name|HSCX_CCR1_CM2
operator||
comment|/* HSCX clock mode 5 */
name|HSCX_CCR1_CM0
argument_list|)
expr_stmt|;
block|}
comment|/* XAD1: Transmit Address Byte 1 */
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_XAD1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* XAD2: Transmit Address Byte 2 */
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_XAD2
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* RAH2: Receive Address Byte High Reg. 2 */
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_RAH2
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* XBCH: reset Transmit Byte Count High */
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_XBCH
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* RLCR: reset Receive Length Check Register */
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_RLCR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* CCR2: set tx/rx clock shift bit 0	*/
comment|/*       disable CTS irq, disable RIE irq*/
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_CCR2
argument_list|,
name|HSCX_CCR2_XCS0
operator||
name|HSCX_CCR2_RCS0
argument_list|)
expr_stmt|;
comment|/* XCCR: tx bit count per time slot */
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_XCCR
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
comment|/* RCCR: rx bit count per time slot */
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_RCCR
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bustyp
operator|==
name|BUS_TYPE_IOM2
condition|)
block|{
switch|switch
condition|(
name|h_chan
condition|)
block|{
case|case
name|HSCX_CH_A
case|:
comment|/* Prepare HSCX channel A */
comment|/* TSAX: tx clock shift bits 1& 2	*/
comment|/*       tx time slot number		*/
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_TSAX
argument_list|,
literal|0x2f
argument_list|)
expr_stmt|;
comment|/* TSAR: rx clock shift bits 1& 2	*/
comment|/*       rx time slot number		*/
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_TSAR
argument_list|,
literal|0x2f
argument_list|)
expr_stmt|;
break|break;
case|case
name|HSCX_CH_B
case|:
comment|/* Prepare HSCX channel B */
comment|/* TSAX: tx clock shift bits 1& 2	*/
comment|/*       tx time slot number		*/
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_TSAX
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* TSAR: rx clock shift bits 1& 2	*/
comment|/*       rx time slot number		*/
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_TSAR
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* IOM 1 setup */
block|{
comment|/* TSAX: tx clock shift bits 1& 2	*/
comment|/*       tx time slot number		*/
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_TSAX
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
comment|/* TSAR: rx clock shift bits 1& 2	*/
comment|/*       rx time slot number		*/
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_TSAR
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|activate
condition|)
block|{
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_RHDLC
condition|)
block|{
comment|/* HDLC Frames, transparent mode 0 */
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_MODE
argument_list|,
name|HSCX_MODE_MDS1
operator||
name|HSCX_MODE_RAC
operator||
name|HSCX_MODE_RTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Raw Telephony, extended transparent mode 1 */
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_MODE
argument_list|,
name|HSCX_MODE_MDS1
operator||
name|HSCX_MODE_MDS0
operator||
name|HSCX_MODE_ADM
operator||
name|HSCX_MODE_RTS
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|isic_hscx_cmd(sc, h_chan, HSCX_CMDR_RHR|HSCX_CMDR_XRES);
else|#
directive|else
name|isic_hscx_cmd
argument_list|(
name|sc
argument_list|,
name|h_chan
argument_list|,
name|HSCX_CMDR_RHR
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* TSAX: tx time slot */
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_TSAX
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* TSAR: rx time slot */
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_TSAR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Raw Telephony, extended transparent mode 1 */
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_MODE
argument_list|,
name|HSCX_MODE_MDS1
operator||
name|HSCX_MODE_MDS0
operator||
name|HSCX_MODE_ADM
operator||
name|HSCX_MODE_RTS
argument_list|)
expr_stmt|;
block|}
comment|/* don't touch ICA, EXA and EXB bits, this could be HSCX_CH_B */
comment|/* always disable RSC and TIN */
name|chan
operator|->
name|hscx_mask
operator||=
name|HSCX_MASK_RSC
operator||
name|HSCX_MASK_TIN
expr_stmt|;
if|if
condition|(
name|activate
condition|)
block|{
comment|/* enable */
name|chan
operator|->
name|hscx_mask
operator|&=
operator|~
operator|(
name|HSCX_MASK_RME
operator||
name|HSCX_MASK_RPF
operator||
name|HSCX_MASK_XPR
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* disable */
name|chan
operator|->
name|hscx_mask
operator||=
name|HSCX_MASK_RME
operator||
name|HSCX_MASK_RPF
operator||
name|HSCX_MASK_XPR
expr_stmt|;
block|}
comment|/* handle ICA, EXA, and EXB via interrupt mask of channel b */
if|if
condition|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|)
block|{
if|if
condition|(
name|activate
condition|)
name|HSCX_B_IMASK
operator|&=
operator|~
operator|(
name|HSCX_MASK_EXA
operator||
name|HSCX_MASK_ICA
operator|)
expr_stmt|;
else|else
name|HSCX_B_IMASK
operator||=
name|HSCX_MASK_EXA
operator||
name|HSCX_MASK_ICA
expr_stmt|;
name|HSCX_WRITE
argument_list|(
name|HSCX_CH_A
argument_list|,
name|H_MASK
argument_list|,
name|HSCX_A_IMASK
argument_list|)
expr_stmt|;
name|HSCX_WRITE
argument_list|(
name|HSCX_CH_B
argument_list|,
name|H_MASK
argument_list|,
name|HSCX_B_IMASK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|activate
condition|)
name|HSCX_B_IMASK
operator|&=
operator|~
name|HSCX_MASK_EXB
expr_stmt|;
else|else
name|HSCX_B_IMASK
operator||=
name|HSCX_MASK_EXB
expr_stmt|;
name|HSCX_WRITE
argument_list|(
name|HSCX_CH_B
argument_list|,
name|H_MASK
argument_list|,
name|HSCX_B_IMASK
argument_list|)
expr_stmt|;
block|}
comment|/* clear spurious interrupts left over */
if|if
condition|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|)
block|{
name|HSCX_READ
argument_list|(
name|h_chan
argument_list|,
name|H_EXIR
argument_list|)
expr_stmt|;
name|HSCX_READ
argument_list|(
name|h_chan
argument_list|,
name|H_ISTA
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* mask ICA, because it must not be cleared by reading ISTA */
block|{
name|HSCX_WRITE
argument_list|(
name|HSCX_CH_B
argument_list|,
name|H_MASK
argument_list|,
name|HSCX_B_IMASK
operator||
name|HSCX_MASK_ICA
argument_list|)
expr_stmt|;
name|HSCX_READ
argument_list|(
name|h_chan
argument_list|,
name|H_EXIR
argument_list|)
expr_stmt|;
name|HSCX_READ
argument_list|(
name|h_chan
argument_list|,
name|H_ISTA
argument_list|)
expr_stmt|;
name|HSCX_WRITE
argument_list|(
name|HSCX_CH_B
argument_list|,
name|H_MASK
argument_list|,
name|HSCX_B_IMASK
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	write command to HSCX command register  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|isic_hscx_cmd
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|unsigned
name|char
name|cmd
parameter_list|)
block|{
name|int
name|timeout
init|=
literal|20
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|HSCX_READ
argument_list|(
name|h_chan
argument_list|,
name|H_STAR
argument_list|)
operator|)
operator|&
name|HSCX_STAR_CEC
operator|)
operator|&&
name|timeout
condition|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_H_ERR
argument_list|,
literal|"HSCX wait for CEC timeout!"
argument_list|)
expr_stmt|;
block|}
name|HSCX_WRITE
argument_list|(
name|h_chan
argument_list|,
name|H_CMDR
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	wait for HSCX transmit FIFO write enable  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|isic_hscx_waitxfw
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|h_chan
parameter_list|)
block|{
define|#
directive|define
name|WAITVAL
value|50
define|#
directive|define
name|WAITTO
value|200
name|int
name|timeout
init|=
name|WAITTO
decl_stmt|;
while|while
condition|(
operator|(
operator|!
operator|(
operator|(
operator|(
name|HSCX_READ
argument_list|(
name|h_chan
argument_list|,
name|H_STAR
argument_list|)
operator|)
operator|&
operator|(
name|HSCX_STAR_CEC
operator||
name|HSCX_STAR_XFW
operator|)
operator|)
operator|==
name|HSCX_STAR_XFW
operator|)
operator|)
operator|&&
name|timeout
condition|)
block|{
name|DELAY
argument_list|(
name|WAITVAL
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_H_ERR
argument_list|,
literal|"HSCX wait for XFW timeout!"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timeout
operator|!=
name|WAITTO
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"HSCX wait for XFW time: %d uS"
argument_list|,
operator|(
name|WAITTO
operator|-
name|timeout
operator|)
operator|*
literal|50
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NISIC> 0 */
end_comment

end_unit

