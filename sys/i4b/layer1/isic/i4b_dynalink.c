begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   Copyright (c) 1998 Martijn Plak. All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *   3. Neither the name of the author nor the names of any co-contributors  *      may be used to endorse or promote products derived from this software  *      without specific prior written permission.  *   4. Altered versions must be plainly marked as such, and must not be  *      misrepresented as being the original software and/or documentation.  *     *   THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  *   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  *   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  *   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  *   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  *   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  *   SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	isdn4bsd layer1 driver for Dynalink IS64PH isdn TA  *	==================================================  *  *      $Id: i4b_dynalink.c,v 1.1 2000/09/04 09:17:26 hm Exp $  *  * $FreeBSD$  *  *      last edit-date: [Mon Sep  4 09:47:18 2000]  *  *---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*	NOTES: 	 	This driver was written for the Dynalink IS64PH ISDN TA, based on two  	Siemens chips (HSCX 21525 and ISAC 2186). It is sold in the Netherlands. 	 	model numbers found on (my) card: 		IS64PH, TAS100H-N, P/N:89590555, TA200S100045521 	 	chips: 	 		Siemens PSB 21525N, HSCX TE V2.1 		Siemens PSB 2186N, ISAC-S TE V1.1 		95MS14, PNP 	 	plug-and-play info:  		device id 	"ASU1688"  		vendor id 	0x88167506  		serial 		0x00000044 		i/o port	4 byte alignment, 4 bytes requested,  				10 bit i/o decoding, 0x100-0x3f8 (?) 		irq		3,4,5,9,10,11,12,15, high true, edge sensitive 			 	At the moment I'm writing this Dynalink is replacing this card with  	one based on a single Siemens chip (IPAC). It will apparently be sold  	under the same model name.  	This driver might also work for Asuscom cards. */
end_comment

begin_include
include|#
directive|include
file|"isic.h"
end_include

begin_include
include|#
directive|include
file|"opt_i4b.h"
end_include

begin_if
if|#
directive|if
operator|(
name|NISIC
operator|>
literal|0
operator|)
operator|&&
name|defined
argument_list|(
name|DYNALINK
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_isic.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_isac.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_hscx.h>
end_include

begin_comment
comment|/* io address mapping */
end_comment

begin_define
define|#
directive|define
name|ISAC
value|0
end_define

begin_define
define|#
directive|define
name|HSCX
value|1
end_define

begin_define
define|#
directive|define
name|ADDR
value|2
end_define

begin_comment
comment|/* ADDR bits */
end_comment

begin_define
define|#
directive|define
name|ADDRMASK
value|0x7F
end_define

begin_define
define|#
directive|define
name|RESET
value|0x80
end_define

begin_comment
comment|/* HSCX register offsets */
end_comment

begin_define
define|#
directive|define
name|HSCXA
value|0x00
end_define

begin_define
define|#
directive|define
name|HSCXB
value|0x40
end_define

begin_comment
comment|/*	LOW-LEVEL DEVICE ACCESS */
end_comment

begin_function
specifier|static
name|void
name|dynalink_read_fifo
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|bus_space_tag_t
name|t
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_read_multi_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ISAC
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXA
argument_list|)
expr_stmt|;
name|bus_space_read_multi_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXB
argument_list|)
expr_stmt|;
name|bus_space_read_multi_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dynalink_write_fifo
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|bus_space_tag_t
name|t
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_multi_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ISAC
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXA
argument_list|)
expr_stmt|;
name|bus_space_write_multi_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXB
argument_list|)
expr_stmt|;
name|bus_space_write_multi_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dynalink_write_reg
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|reg
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|bus_space_tag_t
name|t
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ISAC
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXA
operator|+
name|reg
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXB
operator|+
name|reg
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|dynalink_read_reg
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|reg
parameter_list|)
block|{
name|bus_space_tag_t
name|t
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|bus_space_read_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ISAC
argument_list|)
return|;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXA
operator|+
name|reg
argument_list|)
expr_stmt|;
return|return
name|bus_space_read_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|)
return|;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXB
operator|+
name|reg
argument_list|)
expr_stmt|;
return|return
name|bus_space_read_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* attach callback routine */
end_comment

begin_function
name|int
name|isic_attach_Dyn
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* get unit */
name|struct
name|l1_softc
modifier|*
name|sc
init|=
operator|&
name|l1_sc
index|[
name|unit
index|]
decl_stmt|;
comment|/* pointer to softc */
name|struct
name|i4b_info
modifier|*
name|info
init|=
operator|&
operator|(
name|sc
operator|->
name|sc_resources
operator|)
decl_stmt|;
name|bus_space_tag_t
name|t
init|=
name|rman_get_bustag
argument_list|(
name|info
operator|->
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|rman_get_bushandle
argument_list|(
name|info
operator|->
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* fill in l1_softc structure */
name|sc
operator|->
name|readreg
operator|=
name|dynalink_read_reg
expr_stmt|;
name|sc
operator|->
name|writereg
operator|=
name|dynalink_write_reg
expr_stmt|;
name|sc
operator|->
name|readfifo
operator|=
name|dynalink_read_fifo
expr_stmt|;
name|sc
operator|->
name|writefifo
operator|=
name|dynalink_write_fifo
expr_stmt|;
name|sc
operator|->
name|clearirq
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_cardtyp
operator|=
name|CARD_TYPEP_DYNALINK
expr_stmt|;
name|sc
operator|->
name|sc_bustyp
operator|=
name|BUS_TYPE_IOM2
expr_stmt|;
name|sc
operator|->
name|sc_ipac
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bfifolen
operator|=
name|HSCX_FIFO_LEN
expr_stmt|;
comment|/* Read HSCX A/B VSTR.  Expected value is 0x05 (V2.1). */
if|if
condition|(
operator|(
operator|(
name|HSCX_READ
argument_list|(
literal|0
argument_list|,
name|H_VSTR
argument_list|)
operator|&
literal|0xf
operator|)
operator|!=
literal|0x5
operator|)
operator|||
operator|(
operator|(
name|HSCX_READ
argument_list|(
literal|1
argument_list|,
name|H_VSTR
argument_list|)
operator|&
literal|0xf
operator|)
operator|!=
literal|0x5
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"isic%d: HSCX VSTR test failed for Dynalink\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"isic%d: HSC0: VSTR: %#x\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|HSCX_READ
argument_list|(
literal|0
argument_list|,
name|H_VSTR
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"isic%d: HSC1: VSTR: %#x\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|HSCX_READ
argument_list|(
literal|1
argument_list|,
name|H_VSTR
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* reset card */
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|10
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|10
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (NISIC> 0)&& defined(DYNALINK) */
end_comment

end_unit

