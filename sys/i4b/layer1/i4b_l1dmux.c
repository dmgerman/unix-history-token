begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000 Hellmuth Michaelis. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	i4b_l1dmux.c - isdn4bsd layer 1 driver multiplexer  *	--------------------------------------------------  *  *	$Id: i4b_l1dmux.c,v 1.12 2000/06/02 16:14:36 hm Exp $  *  * $FreeBSD$  *  *      last edit-date: [Fri Jun  2 14:37:39 2000]  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"isic.h"
end_include

begin_include
include|#
directive|include
file|"iwic.h"
end_include

begin_include
include|#
directive|include
file|"ifpi.h"
end_include

begin_include
include|#
directive|include
file|"ifpnp.h"
end_include

begin_include
include|#
directive|include
file|"ihfc.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_trace.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_l1.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_l1l2.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_global.h>
end_include

begin_comment
comment|/*  * this code is nothing but a big dynamic switch to multiplex and demultiplex  * layer 1 hardware isdn drivers to a common layer 2.  *  * when a card is successfully attached at system boot time, the driver for  * this card calls the routine i4b_l1_mph_status_ind() with status = STI_ATTACH.  *  * This command is used to setup the tables for converting a "driver unit" and  * "driver type" pair (encoded in the calls from the hardware driver to the  * routines in this source file) to a "unit number" used in layer 2 and the  * layers above (up to and including the isdnd daemon) and for converting  * layer 2 units back to calling the appropriate driver and driver unit  * number.  *  * Example: in my setup, a Winbond (iwic) card is probed first and gets  * driver unit number 0, driver type 1 in layer 1. This becomes unit  * number 0 in layer 2 and up. The second card probed is a Teles card  * (isic) and gets driver unit number 0, driver type 0 in layer 1. This  * becomes unit number 1 in layer 1 and up.  *  * To add support for a new driver, add a new driver number to i4b_l1.h:  * currently we have L1DRVR_ISIC and L1DRVR_IWIC, so you would add  * L1DRVR_FOO. More you would want to add a L0FOOUNIT to encode unit  * numbers in your driver. You then have to add a l1foounittab[] and  * add an entry to the getl1tab() routine for your driver. The only  * thing left now is to write your driver with the support functions  * for this multiplexer ;-)  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|i4b_l1_debug
init|=
name|L1_DEBUG_DEFAULT
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|NISIC
operator|>
literal|0
end_if

begin_decl_stmt
specifier|static
name|int
name|l1isicunittab
index|[
name|MAXL1UNITS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NIWIC
operator|>
literal|0
end_if

begin_decl_stmt
specifier|static
name|int
name|l1iwicunittab
index|[
name|MAXL1UNITS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NIFPI
operator|>
literal|0
end_if

begin_decl_stmt
specifier|static
name|int
name|l1ifpiunittab
index|[
name|MAXL1UNITS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NIHFC
operator|>
literal|0
end_if

begin_decl_stmt
specifier|static
name|int
name|l1ihfcunittab
index|[
name|MAXL1UNITS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NIFPNP
operator|>
literal|0
end_if

begin_decl_stmt
specifier|static
name|int
name|l1ifpnpunittab
index|[
name|MAXL1UNITS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|numl1units
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|l1drvunittab
index|[
name|MAXL1UNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|i4b_l1mux_func
modifier|*
name|l1mux_func
index|[
name|MAXL1DRVR
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|i4b_l1_ph_data_req
parameter_list|(
name|int
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i4b_l1_ph_activate_req
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* from i4btrc driver i4b_trace.c */
end_comment

begin_function_decl
name|int
name|get_trace_data_from_l1
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|what
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* from layer 2 */
end_comment

begin_function_decl
name|int
name|i4b_ph_data_ind
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|i4b_ph_activate_ind
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|i4b_ph_deactivate_ind
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|i4b_mph_status_ind
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* layer 1 lme */
end_comment

begin_function_decl
name|int
name|i4b_l1_mph_command_req
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*---------------------------------------------------------------------------*  *	jump table: interface function pointers L1/L2 interface   *---------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
name|struct
name|i4b_l1l2_func
name|i4b_l1l2_func
init|=
block|{
comment|/* Layer 1 --> Layer 2 */
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|,
expr|struct
name|mbuf
operator|*
argument_list|)
operator|)
name|i4b_ph_data_ind
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|i4b_ph_activate_ind
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|i4b_ph_deactivate_ind
block|,
comment|/* Layer 2 --> Layer 1 */
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|,
expr|struct
name|mbuf
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|i4b_l1_ph_data_req
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|i4b_l1_ph_activate_req
block|,
comment|/* Layer 1 --> trace interface driver, ISDN trace data */
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|i4b_trace_hdr_t
operator|*
argument_list|,
name|int
argument_list|,
name|u_char
operator|*
argument_list|)
operator|)
name|get_trace_data_from_l1
block|,
comment|/* Driver control and status information */
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
operator|)
name|i4b_mph_status_ind
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|i4b_l1_mph_command_req
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*---------------------------------------------------------------------------*  *	return a pointer to a layer 0 drivers unit tab  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|__inline
name|int
modifier|*
name|getl1tab
parameter_list|(
name|int
name|drv
parameter_list|)
block|{
switch|switch
condition|(
name|drv
condition|)
block|{
if|#
directive|if
name|NISIC
operator|>
literal|0
case|case
name|L1DRVR_ISIC
case|:
return|return
operator|(
name|l1isicunittab
operator|)
return|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NIWIC
operator|>
literal|0
case|case
name|L1DRVR_IWIC
case|:
return|return
operator|(
name|l1iwicunittab
operator|)
return|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NIFPI
operator|>
literal|0
case|case
name|L1DRVR_IFPI
case|:
return|return
operator|(
name|l1ifpiunittab
operator|)
return|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NIHFC
operator|>
literal|0
case|case
name|L1DRVR_IHFC
case|:
return|return
operator|(
name|l1ihfcunittab
operator|)
return|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NIFPNP
operator|>
literal|0
case|case
name|L1DRVR_IFPNP
case|:
return|return
operator|(
name|l1ifpnpunittab
operator|)
return|;
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*===========================================================================*  *	B - Channel (data transfer)  *===========================================================================*/
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	return the address of ISDN drivers linktab	  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|isdn_link_t
modifier|*
name|i4b_l1_ret_linktab
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|int
name|drv_unit
decl_stmt|,
name|ch_unit
decl_stmt|;
name|drv_unit
operator|=
name|L0DRVR
argument_list|(
name|l1drvunittab
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|ch_unit
operator|=
name|L0UNIT
argument_list|(
name|l1drvunittab
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_PRIM
argument_list|,
literal|"unit %d -> drv %d / drvunit %d"
argument_list|,
name|unit
argument_list|,
name|drv_unit
argument_list|,
name|ch_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|drv_unit
operator|>=
name|MAXL1DRVR
operator|||
name|l1mux_func
index|[
name|drv_unit
index|]
operator|==
name|NULL
operator|||
name|l1mux_func
index|[
name|drv_unit
index|]
operator|->
name|ret_linktab
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"i4b_l1_ret_linktab: unknown driver type %d\n"
argument_list|,
name|drv_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|l1mux_func
index|[
name|drv_unit
index|]
operator|->
name|ret_linktab
argument_list|(
name|ch_unit
argument_list|,
name|channel
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	set the ISDN driver linktab  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l1_set_linktab
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|channel
parameter_list|,
name|drvr_link_t
modifier|*
name|dlt
parameter_list|)
block|{
name|int
name|drv_unit
decl_stmt|,
name|ch_unit
decl_stmt|;
name|drv_unit
operator|=
name|L0DRVR
argument_list|(
name|l1drvunittab
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|ch_unit
operator|=
name|L0UNIT
argument_list|(
name|l1drvunittab
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_PRIM
argument_list|,
literal|"unit %d -> drv %d / drvunit %d"
argument_list|,
name|unit
argument_list|,
name|drv_unit
argument_list|,
name|ch_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|drv_unit
operator|>=
name|MAXL1DRVR
operator|||
name|l1mux_func
index|[
name|drv_unit
index|]
operator|==
name|NULL
operator|||
name|l1mux_func
index|[
name|drv_unit
index|]
operator|->
name|set_linktab
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"i4b_l1_set_linktab: unknown driver type %d\n"
argument_list|,
name|drv_unit
argument_list|)
expr_stmt|;
name|l1mux_func
index|[
name|drv_unit
index|]
operator|->
name|set_linktab
argument_list|(
name|ch_unit
argument_list|,
name|channel
argument_list|,
name|dlt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*===========================================================================*  *	trace D- and B-Channel support  *===========================================================================*/
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	L0 -> L1 trace information to trace driver  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|i4b_l1_trace_ind
parameter_list|(
name|i4b_trace_hdr_t
modifier|*
name|hdr
parameter_list|,
name|int
name|len
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
specifier|register
name|int
modifier|*
name|tab
decl_stmt|;
if|if
condition|(
operator|(
name|tab
operator|=
name|getl1tab
argument_list|(
name|L0DRVR
argument_list|(
name|hdr
operator|->
name|unit
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"i4b_l1_trace_ind: unknown driver type %d\n"
argument_list|,
name|L0DRVR
argument_list|(
name|hdr
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_PRIM
argument_list|,
literal|"(drv %d / drvunit %d) -> unit %d"
argument_list|,
name|L0DRVR
argument_list|(
name|hdr
operator|->
name|unit
argument_list|)
argument_list|,
name|L0UNIT
argument_list|(
name|hdr
operator|->
name|unit
argument_list|)
argument_list|,
name|tab
index|[
name|L0UNIT
argument_list|(
name|hdr
operator|->
name|unit
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|unit
operator|=
name|tab
index|[
name|L0UNIT
argument_list|(
name|hdr
operator|->
name|unit
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
name|MPH_Trace_Ind
argument_list|(
name|hdr
argument_list|,
name|len
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*===========================================================================*  *	D - Channel (signalling)  *===========================================================================*/
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	L0 -> L1 status indication from hardware  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|i4b_l1_mph_status_ind
parameter_list|(
name|int
name|drv_unit
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|parm
parameter_list|,
name|struct
name|i4b_l1mux_func
modifier|*
name|l1mux_func_p
parameter_list|)
block|{
specifier|register
name|int
modifier|*
name|tab
decl_stmt|;
comment|/* 	 * in case the status STI_ATTACH is sent from the hardware, the 	 * driver has just attached itself and we need to initialize 	 * the tables and assorted variables. 	 */
if|if
condition|(
name|status
operator|==
name|STI_ATTACH
condition|)
block|{
if|if
condition|(
name|l1mux_func_p
operator|==
operator|(
expr|struct
name|i4b_l1mux_func
operator|*
operator|)
literal|0
condition|)
name|panic
argument_list|(
literal|"i4b_l1_mph_status_ind: i4b_l1mux_func pointer is NULL\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numl1units
operator|<
name|MAXL1UNITS
condition|)
block|{
if|if
condition|(
operator|(
name|tab
operator|=
name|getl1tab
argument_list|(
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"i4b_l1_mph_status_ind: unknown driver type %d\n"
argument_list|,
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
argument_list|)
expr_stmt|;
name|tab
index|[
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
index|]
operator|=
name|numl1units
expr_stmt|;
name|l1drvunittab
index|[
name|numl1units
index|]
operator|=
name|drv_unit
expr_stmt|;
name|l1mux_func
index|[
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
index|]
operator|=
name|l1mux_func_p
expr_stmt|;
switch|switch
condition|(
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
condition|)
block|{
if|#
directive|if
name|NISIC
operator|>
literal|0
case|case
name|L1DRVR_ISIC
case|:
name|printf
argument_list|(
literal|"isic%d: passive stack unit %d\n"
argument_list|,
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
argument_list|,
name|numl1units
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NIWIC
operator|>
literal|0
case|case
name|L1DRVR_IWIC
case|:
name|printf
argument_list|(
literal|"iwic%d: passive stack unit %d\n"
argument_list|,
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
argument_list|,
name|numl1units
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NIFPI
operator|>
literal|0
case|case
name|L1DRVR_IFPI
case|:
name|printf
argument_list|(
literal|"ifpi%d: passive stack unit %d\n"
argument_list|,
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
argument_list|,
name|numl1units
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NIFPNP
operator|>
literal|0
case|case
name|L1DRVR_IFPNP
case|:
name|printf
argument_list|(
literal|"ifpnp%d: passive stack unit %d\n"
argument_list|,
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
argument_list|,
name|numl1units
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NIHFC
operator|>
literal|0
case|case
name|L1DRVR_IHFC
case|:
name|printf
argument_list|(
literal|"ihfc%d: passive stack unit %d\n"
argument_list|,
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
argument_list|,
name|numl1units
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|NDBGL1
argument_list|(
name|L1_PRIM
argument_list|,
literal|"ATTACH drv %d, drvunit %d -> unit %d"
argument_list|,
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
argument_list|,
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
argument_list|,
name|numl1units
argument_list|)
expr_stmt|;
name|numl1units
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|tab
operator|=
name|getl1tab
argument_list|(
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"i4b_l1_mph_status_ind: unknown driver type %d\n"
argument_list|,
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
argument_list|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_PRIM
argument_list|,
literal|"(drv %d / drvunit %d) -> unit %d\n"
argument_list|,
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
argument_list|,
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
argument_list|,
name|tab
index|[
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|MPH_Status_Ind
argument_list|(
name|tab
index|[
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
index|]
argument_list|,
name|status
argument_list|,
name|parm
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	L0 -> L1 data from hardware  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|i4b_l1_ph_data_ind
parameter_list|(
name|int
name|drv_unit
parameter_list|,
name|struct
name|mbuf
modifier|*
name|data
parameter_list|)
block|{
specifier|register
name|int
modifier|*
name|tab
decl_stmt|;
if|if
condition|(
operator|(
name|tab
operator|=
name|getl1tab
argument_list|(
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"i4b_l1_ph_data_ind: unknown driver type %d\n"
argument_list|,
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|NDBGL1(L1_PRIM, "(drv %d / drvunit %d) -> unit %d", L0DRVR(drv_unit), L0UNIT(drv_unit), tab[L0UNIT(drv_unit)]);
endif|#
directive|endif
return|return
operator|(
name|PH_Data_Ind
argument_list|(
name|tab
index|[
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
index|]
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	L0 -> L1 activate indication from hardware  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|i4b_l1_ph_activate_ind
parameter_list|(
name|int
name|drv_unit
parameter_list|)
block|{
specifier|register
name|int
modifier|*
name|tab
decl_stmt|;
if|if
condition|(
operator|(
name|tab
operator|=
name|getl1tab
argument_list|(
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"i4b_l1_ph_activate_ind: unknown driver type %d\n"
argument_list|,
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
argument_list|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_PRIM
argument_list|,
literal|"(drv %d / drvunit %d) -> unit %d"
argument_list|,
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
argument_list|,
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
argument_list|,
name|tab
index|[
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|PH_Act_Ind
argument_list|(
name|tab
index|[
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	L0 -> L1 deactivate indication from hardware  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|i4b_l1_ph_deactivate_ind
parameter_list|(
name|int
name|drv_unit
parameter_list|)
block|{
specifier|register
name|int
modifier|*
name|tab
decl_stmt|;
if|if
condition|(
operator|(
name|tab
operator|=
name|getl1tab
argument_list|(
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"i4b_l1_ph_deactivate_ind: unknown driver type %d\n"
argument_list|,
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
argument_list|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_PRIM
argument_list|,
literal|"(drv %d / drvunit %d) -> unit %d"
argument_list|,
name|L0DRVR
argument_list|(
name|drv_unit
argument_list|)
argument_list|,
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
argument_list|,
name|tab
index|[
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|PH_Deact_Ind
argument_list|(
name|tab
index|[
name|L0UNIT
argument_list|(
name|drv_unit
argument_list|)
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	L2 -> L1 command to hardware  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|i4b_l1_mph_command_req
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|command
parameter_list|,
name|void
modifier|*
name|parm
parameter_list|)
block|{
specifier|register
name|int
name|drv_unit
init|=
name|L0DRVR
argument_list|(
name|l1drvunittab
index|[
name|unit
index|]
argument_list|)
decl_stmt|;
specifier|register
name|int
name|ch_unit
init|=
name|L0UNIT
argument_list|(
name|l1drvunittab
index|[
name|unit
index|]
argument_list|)
decl_stmt|;
name|NDBGL1
argument_list|(
name|L1_PRIM
argument_list|,
literal|"unit %d -> drv %d / drvunit %d"
argument_list|,
name|unit
argument_list|,
name|drv_unit
argument_list|,
name|ch_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|drv_unit
operator|>=
name|MAXL1DRVR
operator|||
name|l1mux_func
index|[
name|drv_unit
index|]
operator|==
name|NULL
operator|||
name|l1mux_func
index|[
name|drv_unit
index|]
operator|->
name|mph_command_req
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"i4b_l1_mph_command_req: unknown driver type %d\n"
argument_list|,
name|drv_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|l1mux_func
index|[
name|drv_unit
index|]
operator|->
name|mph_command_req
argument_list|(
name|ch_unit
argument_list|,
name|command
argument_list|,
name|parm
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	L2 -> L1 data to be transmitted to hardware  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|i4b_l1_ph_data_req
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|mbuf
modifier|*
name|data
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|register
name|int
name|drv_unit
init|=
name|L0DRVR
argument_list|(
name|l1drvunittab
index|[
name|unit
index|]
argument_list|)
decl_stmt|;
specifier|register
name|int
name|ch_unit
init|=
name|L0UNIT
argument_list|(
name|l1drvunittab
index|[
name|unit
index|]
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|NDBGL1(L1_PRIM, "unit %d -> drv %d / drvunit %d", unit, drv_unit, ch_unit);
endif|#
directive|endif
if|if
condition|(
name|drv_unit
operator|>=
name|MAXL1DRVR
operator|||
name|l1mux_func
index|[
name|drv_unit
index|]
operator|==
name|NULL
operator|||
name|l1mux_func
index|[
name|drv_unit
index|]
operator|->
name|ph_data_req
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"i4b_l1_ph_data_req: unknown driver type %d\n"
argument_list|,
name|drv_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|l1mux_func
index|[
name|drv_unit
index|]
operator|->
name|ph_data_req
argument_list|(
name|ch_unit
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	L2 -> L1 activate request to hardware  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|i4b_l1_ph_activate_req
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|int
name|drv_unit
init|=
name|L0DRVR
argument_list|(
name|l1drvunittab
index|[
name|unit
index|]
argument_list|)
decl_stmt|;
specifier|register
name|int
name|ch_unit
init|=
name|L0UNIT
argument_list|(
name|l1drvunittab
index|[
name|unit
index|]
argument_list|)
decl_stmt|;
name|NDBGL1
argument_list|(
name|L1_PRIM
argument_list|,
literal|"unit %d -> drv %d / drvunit %d"
argument_list|,
name|unit
argument_list|,
name|drv_unit
argument_list|,
name|ch_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|drv_unit
operator|>=
name|MAXL1DRVR
operator|||
name|l1mux_func
index|[
name|drv_unit
index|]
operator|==
name|NULL
operator|||
name|l1mux_func
index|[
name|drv_unit
index|]
operator|->
name|ph_activate_req
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"i4b_l1_ph_activate_req: unknown driver type %d\n"
argument_list|,
name|drv_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|l1mux_func
index|[
name|drv_unit
index|]
operator|->
name|ph_activate_req
argument_list|(
name|ch_unit
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* EOF */
end_comment

end_unit

