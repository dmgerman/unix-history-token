begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 2000 Hellmuth Michaelis. All rights reserved.  * Copyright (c) 2001 Gary Jennejohn. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	i4b_ifpi2_isac.c - i4b Fritz PCI Version 2 ISACSX handler  *	--------------------------------------------  *	$Id$   *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_i4b.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_trace.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_l1.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_isic.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_hscx.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/ifpi2/i4b_ifpi2_ext.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/ifpi2/i4b_ifpi2_isacsx.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_global.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_mbuf.h>
end_include

begin_function_decl
specifier|static
name|u_char
name|ifpi2_isacsx_exir_hdlr
parameter_list|(
specifier|register
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|exir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ifpi2_isacsx_ind_hdlr
parameter_list|(
specifier|register
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ind
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* the ISACSX has 2 mask registers of interest - cannot use ISAC_IMASK */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|isacsx_imaskd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|isacsx_imask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*---------------------------------------------------------------------------*  *	ISACSX interrupt service routine  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|ifpi2_isacsx_irq
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ista
parameter_list|)
block|{
specifier|register
name|u_char
name|c
init|=
literal|0
decl_stmt|;
specifier|register
name|u_char
name|istad
init|=
literal|0
decl_stmt|;
name|NDBGL1
argument_list|(
name|L1_F_MSG
argument_list|,
literal|"unit %d: ista = 0x%02x"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|ista
argument_list|)
expr_stmt|;
comment|/* was it an HDLC interrupt ? */
if|if
condition|(
name|ista
operator|&
name|ISACSX_ISTA_ICD
condition|)
block|{
name|istad
operator|=
name|ISAC_READ
argument_list|(
name|I_ISTAD
argument_list|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_F_MSG
argument_list|,
literal|"unit %d: istad = 0x%02x"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|istad
argument_list|)
expr_stmt|;
if|if
condition|(
name|istad
operator|&
operator|(
name|ISACSX_ISTAD_RFO
operator||
name|ISACSX_ISTAD_XMR
operator||
name|ISACSX_ISTAD_XDU
operator|)
condition|)
block|{
comment|/* not really EXIR, but very similar */
name|c
operator||=
name|ifpi2_isacsx_exir_hdlr
argument_list|(
name|sc
argument_list|,
name|istad
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|istad
operator|&
name|ISACSX_ISTAD_RME
condition|)
comment|/* receive message end */
block|{
specifier|register
name|int
name|rest
decl_stmt|;
name|u_char
name|rsta
decl_stmt|;
comment|/* get rx status register */
name|rsta
operator|=
name|ISAC_READ
argument_list|(
name|I_RSTAD
argument_list|)
expr_stmt|;
comment|/* Check for Frame and CRC valid */
if|if
condition|(
operator|(
name|rsta
operator|&
name|ISACSX_RSTAD_MASK
operator|)
operator|!=
operator|(
name|ISACSX_RSTAD_VFR
operator||
name|ISACSX_RSTAD_CRC
operator|)
condition|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|rsta
operator|&
name|ISACSX_RSTAD_VFR
operator|)
condition|)
comment|/* VFR error */
block|{
name|error
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"unit %d: Frame not valid error"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|rsta
operator|&
name|ISACSX_RSTAD_CRC
operator|)
condition|)
comment|/* CRC error */
block|{
name|error
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"unit %d: CRC error"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsta
operator|&
name|ISACSX_RSTAD_RDO
condition|)
comment|/* ReceiveDataOverflow */
block|{
name|error
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"unit %d: Data Overrun error"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsta
operator|&
name|ISACSX_RSTAD_RAB
condition|)
comment|/* ReceiveABorted */
block|{
name|error
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"unit %d: Receive Aborted error"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"unit %d: RME unknown error, RSTAD = 0x%02x!"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|rsta
argument_list|)
expr_stmt|;
name|i4b_Dfreembuf
argument_list|(
name|sc
operator|->
name|sc_ibuf
argument_list|)
expr_stmt|;
name|c
operator||=
name|ISACSX_CMDRD_RMC
operator||
name|ISACSX_CMDRD_RRES
expr_stmt|;
name|sc
operator|->
name|sc_ibuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ib
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_CMDRD
argument_list|,
name|ISACSX_CMDRD_RMC
operator||
name|ISACSX_CMDRD_RRES
argument_list|)
expr_stmt|;
return|return;
block|}
name|rest
operator|=
operator|(
name|ISAC_READ
argument_list|(
name|I_RBCLD
argument_list|)
operator|&
operator|(
name|ISACSX_FIFO_LEN
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|rest
operator|==
literal|0
condition|)
name|rest
operator|=
name|ISACSX_FIFO_LEN
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ibuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ibuf
operator|=
name|i4b_Dgetmbuf
argument_list|(
name|rest
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_ib
operator|=
name|sc
operator|->
name|sc_ibuf
operator|->
name|m_data
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"ifpi2_isacsx_irq: RME, i4b_Dgetmbuf returns NULL!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|<=
operator|(
name|MAX_DFRAME_LEN
operator|-
name|rest
operator|)
condition|)
block|{
name|ISAC_RDFIFO
argument_list|(
name|sc
operator|->
name|sc_ib
argument_list|,
name|rest
argument_list|)
expr_stmt|;
comment|/* the  last byte contains status, strip it */
name|sc
operator|->
name|sc_ilen
operator|+=
name|rest
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_ibuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|sc
operator|->
name|sc_ibuf
operator|->
name|m_len
operator|=
name|sc
operator|->
name|sc_ilen
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_D_RX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0IFPI2UNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
name|TRC_CH_D
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_NT
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_dcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|sc
operator|->
name|sc_ibuf
operator|->
name|m_len
argument_list|,
name|sc
operator|->
name|sc_ibuf
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
name|c
operator||=
name|ISACSX_CMDRD_RMC
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_enabled
operator|&&
operator|(
name|ctrl_desc
index|[
name|sc
operator|->
name|sc_unit
index|]
operator|.
name|protocol
operator|!=
name|PROTOCOL_D64S
operator|)
condition|)
block|{
name|i4b_l1_ph_data_ind
argument_list|(
name|L0IFPI2UNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_ibuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i4b_Dfreembuf
argument_list|(
name|sc
operator|->
name|sc_ibuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"RME, input buffer overflow!"
argument_list|)
expr_stmt|;
name|i4b_Dfreembuf
argument_list|(
name|sc
operator|->
name|sc_ibuf
argument_list|)
expr_stmt|;
name|c
operator||=
name|ISACSX_CMDRD_RMC
operator||
name|ISACSX_CMDRD_RRES
expr_stmt|;
block|}
name|sc
operator|->
name|sc_ibuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ib
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|istad
operator|&
name|ISACSX_ISTAD_RPF
condition|)
comment|/* receive fifo full */
block|{
if|if
condition|(
name|sc
operator|->
name|sc_ibuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ibuf
operator|=
name|i4b_Dgetmbuf
argument_list|(
name|MAX_DFRAME_LEN
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_ib
operator|=
name|sc
operator|->
name|sc_ibuf
operator|->
name|m_data
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"ifpi2_isacsx_irq: RPF, i4b_Dgetmbuf returns NULL!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|<=
operator|(
name|MAX_DFRAME_LEN
operator|-
name|ISACSX_FIFO_LEN
operator|)
condition|)
block|{
name|ISAC_RDFIFO
argument_list|(
name|sc
operator|->
name|sc_ib
argument_list|,
name|ISACSX_FIFO_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|+=
name|ISACSX_FIFO_LEN
expr_stmt|;
name|sc
operator|->
name|sc_ib
operator|+=
name|ISACSX_FIFO_LEN
expr_stmt|;
name|c
operator||=
name|ISACSX_CMDRD_RMC
expr_stmt|;
block|}
else|else
block|{
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"RPF, input buffer overflow!"
argument_list|)
expr_stmt|;
name|i4b_Dfreembuf
argument_list|(
name|sc
operator|->
name|sc_ibuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ibuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ib
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|c
operator||=
name|ISACSX_CMDRD_RMC
operator||
name|ISACSX_CMDRD_RRES
expr_stmt|;
block|}
block|}
if|if
condition|(
name|istad
operator|&
name|ISACSX_ISTAD_XPR
condition|)
comment|/* transmit fifo empty (XPR bit set) */
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_obuf2
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_obuf
operator|==
name|NULL
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_freeflag
operator|=
name|sc
operator|->
name|sc_freeflag2
expr_stmt|;
name|sc
operator|->
name|sc_obuf
operator|=
name|sc
operator|->
name|sc_obuf2
expr_stmt|;
name|sc
operator|->
name|sc_op
operator|=
name|sc
operator|->
name|sc_obuf
operator|->
name|m_data
expr_stmt|;
name|sc
operator|->
name|sc_ol
operator|=
name|sc
operator|->
name|sc_obuf
operator|->
name|m_len
expr_stmt|;
name|sc
operator|->
name|sc_obuf2
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTDEF
name|printf
argument_list|(
literal|"ob2=%x, op=%x, ol=%d, f=%d #"
argument_list|,
name|sc
operator|->
name|sc_obuf
argument_list|,
name|sc
operator|->
name|sc_op
argument_list|,
name|sc
operator|->
name|sc_ol
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NOTDEF
name|printf
argument_list|(
literal|"ob=%x, op=%x, ol=%d, f=%d #"
argument_list|,
name|sc
operator|->
name|sc_obuf
argument_list|,
name|sc
operator|->
name|sc_op
argument_list|,
name|sc
operator|->
name|sc_ol
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|sc
operator|->
name|sc_obuf
condition|)
block|{
name|ISAC_WRFIFO
argument_list|(
name|sc
operator|->
name|sc_op
argument_list|,
name|min
argument_list|(
name|sc
operator|->
name|sc_ol
argument_list|,
name|ISACSX_FIFO_LEN
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ol
operator|>
name|ISACSX_FIFO_LEN
condition|)
comment|/* length> 32 ? */
block|{
name|sc
operator|->
name|sc_op
operator|+=
name|ISACSX_FIFO_LEN
expr_stmt|;
comment|/* bufferptr+32 */
name|sc
operator|->
name|sc_ol
operator|-=
name|ISACSX_FIFO_LEN
expr_stmt|;
comment|/* length - 32 */
name|c
operator||=
name|ISACSX_CMDRD_XTF
expr_stmt|;
comment|/* set XTF bit */
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_freeflag
condition|)
block|{
name|i4b_Dfreembuf
argument_list|(
name|sc
operator|->
name|sc_obuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_freeflag
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|sc_obuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_op
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ol
operator|=
literal|0
expr_stmt|;
name|c
operator||=
name|ISACSX_CMDRD_XTF
operator||
name|ISACSX_CMDRD_XME
expr_stmt|;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|ISAC_TX_ACTIVE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ista
operator|&
name|ISACSX_ISTA_CIC
condition|)
comment|/* channel status change CISQ */
block|{
specifier|register
name|u_char
name|ci
decl_stmt|;
comment|/* get command/indication rx register*/
name|ci
operator|=
name|ISAC_READ
argument_list|(
name|I_CIR0
argument_list|)
expr_stmt|;
comment|/* C/I code change IRQ (flag already cleared by CIR0 read) */
if|if
condition|(
name|ci
operator|&
name|ISACSX_CIR0_CIC0
condition|)
name|ifpi2_isacsx_ind_hdlr
argument_list|(
name|sc
argument_list|,
operator|(
name|ci
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
condition|)
block|{
name|ISAC_WRITE
argument_list|(
name|I_CMDRD
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	ISACSX L1 Extended IRQ handler  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|u_char
name|ifpi2_isacsx_exir_hdlr
parameter_list|(
specifier|register
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|exir
parameter_list|)
block|{
name|u_char
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exir
operator|&
name|ISACSX_ISTAD_XMR
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"EXIRQ Tx Message Repeat"
argument_list|)
expr_stmt|;
name|c
operator||=
name|ISACSX_CMDRD_XRES
expr_stmt|;
block|}
if|if
condition|(
name|exir
operator|&
name|ISACSX_ISTAD_XDU
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"EXIRQ Tx Data Underrun"
argument_list|)
expr_stmt|;
name|c
operator||=
name|ISACSX_CMDRD_XRES
expr_stmt|;
block|}
if|if
condition|(
name|exir
operator|&
name|ISACSX_ISTAD_RFO
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"EXIRQ Rx Frame Overflow"
argument_list|)
expr_stmt|;
name|c
operator||=
name|ISACSX_CMDRD_RMC
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* all blocked per default */
block|if(exir& ISACSX_EXIR_SOV) 	{ 		NDBGL1(L1_I_ERR, "EXIRQ Sync Xfer Overflow"); 	}  	if(exir& ISACSX_EXIR_MOS) 	{ 		NDBGL1(L1_I_ERR, "EXIRQ Monitor Status"); 	}  	if(exir& ISACSX_EXIR_SAW) 	{
comment|/* cannot happen, STCR:TSF is set to 0 */
block|NDBGL1(L1_I_ERR, "EXIRQ Subscriber Awake"); 	}  	if(exir& ISACSX_EXIR_WOV) 	{
comment|/* cannot happen, STCR:TSF is set to 0 */
block|NDBGL1(L1_I_ERR, "EXIRQ Watchdog Timer Overflow"); 	}
endif|#
directive|endif
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	ISACSX L1 Indication handler  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ifpi2_isacsx_ind_hdlr
parameter_list|(
specifier|register
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ind
parameter_list|)
block|{
specifier|register
name|int
name|event
decl_stmt|;
switch|switch
condition|(
name|ind
condition|)
block|{
case|case
name|ISACSX_CIR0_IAI8
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx AI8 in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bustyp
operator|==
name|BUS_TYPE_IOM2
condition|)
name|ifpi2_isacsx_l1_cmd
argument_list|(
name|sc
argument_list|,
name|CMD_AR8
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO48
expr_stmt|;
name|i4b_l1_mph_status_ind
argument_list|(
name|L0IFPI2UNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
argument_list|,
name|STI_L1STAT
argument_list|,
name|LAYER_ACTIVE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISACSX_CIR0_IAI10
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx AI10 in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bustyp
operator|==
name|BUS_TYPE_IOM2
condition|)
name|ifpi2_isacsx_l1_cmd
argument_list|(
name|sc
argument_list|,
name|CMD_AR10
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO410
expr_stmt|;
name|i4b_l1_mph_status_ind
argument_list|(
name|L0IFPI2UNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
argument_list|,
name|STI_L1STAT
argument_list|,
name|LAYER_ACTIVE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISACSX_CIR0_IRSY
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx RSY in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_RSY
expr_stmt|;
break|break;
case|case
name|ISACSX_CIR0_IPU
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx PU in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_PU
expr_stmt|;
break|break;
case|case
name|ISACSX_CIR0_IDR
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx DR in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|ifpi2_isacsx_l1_cmd
argument_list|(
name|sc
argument_list|,
name|CMD_DIU
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_DR
expr_stmt|;
break|break;
case|case
name|ISACSX_CIR0_IDID
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx DID in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO0
expr_stmt|;
name|i4b_l1_mph_status_ind
argument_list|(
name|L0IFPI2UNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
argument_list|,
name|STI_L1STAT
argument_list|,
name|LAYER_IDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISACSX_CIR0_IDIS
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx DIS in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_DIS
expr_stmt|;
break|break;
case|case
name|ISACSX_CIR0_IEI
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx EI in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|ifpi2_isacsx_l1_cmd
argument_list|(
name|sc
argument_list|,
name|CMD_DIU
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_EI
expr_stmt|;
break|break;
case|case
name|ISACSX_CIR0_IARD
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx ARD in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO2
expr_stmt|;
break|break;
case|case
name|ISACSX_CIR0_ITI
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx TI in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO0
expr_stmt|;
break|break;
case|case
name|ISACSX_CIR0_IATI
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx ATI in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO0
expr_stmt|;
break|break;
case|case
name|ISACSX_CIR0_ISD
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx SD in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO0
expr_stmt|;
break|break;
default|default:
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"UNKNOWN Indication 0x%x in state %s"
argument_list|,
name|ind
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO0
expr_stmt|;
break|break;
block|}
name|ifpi2_next_state
argument_list|(
name|sc
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	execute a layer 1 command  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|ifpi2_isacsx_l1_cmd
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|command
parameter_list|)
block|{
name|u_char
name|cmd
decl_stmt|;
ifdef|#
directive|ifdef
name|I4B_SMP_WORKAROUND
comment|/* XXXXXXXXXXXXXXXXXXX */
comment|/* 	 * patch from Wolfgang Helbig: 	 * 	 * Here is a patch that makes i4b work on an SMP: 	 * The card (TELES 16.3) didn't interrupt on an SMP machine. 	 * This is a gross workaround, but anyway it works *and* provides 	 * some information as how to finally fix this problem. 	 */
name|HSCX_WRITE
argument_list|(
literal|0
argument_list|,
name|H_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|HSCX_WRITE
argument_list|(
literal|1
argument_list|,
name|H_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASKD
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|HSCX_WRITE
argument_list|(
literal|0
argument_list|,
name|H_MASK
argument_list|,
name|HSCX_A_IMASK
argument_list|)
expr_stmt|;
name|HSCX_WRITE
argument_list|(
literal|1
argument_list|,
name|H_MASK
argument_list|,
name|HSCX_B_IMASK
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASKD
argument_list|,
name|isacsx_imaskd
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
name|isacsx_imask
argument_list|)
expr_stmt|;
comment|/* XXXXXXXXXXXXXXXXXXX */
endif|#
directive|endif
comment|/* I4B_SMP_WORKAROUND */
if|if
condition|(
name|command
operator|<
literal|0
operator|||
name|command
operator|>
name|CMD_ILL
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"illegal cmd 0x%x in state %s"
argument_list|,
name|command
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|cmd
operator|=
name|ISACSX_CIX0_LOW
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|CMD_TIM
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"tx TIM in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator||=
operator|(
name|ISACSX_CIX0_CTIM
operator|<<
literal|4
operator|)
expr_stmt|;
break|break;
case|case
name|CMD_RS
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"tx RS in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator||=
operator|(
name|ISACSX_CIX0_CRS
operator|<<
literal|4
operator|)
expr_stmt|;
break|break;
case|case
name|CMD_AR8
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"tx AR8 in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator||=
operator|(
name|ISACSX_CIX0_CAR8
operator|<<
literal|4
operator|)
expr_stmt|;
break|break;
case|case
name|CMD_AR10
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"tx AR10 in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator||=
operator|(
name|ISACSX_CIX0_CAR10
operator|<<
literal|4
operator|)
expr_stmt|;
break|break;
case|case
name|CMD_DIU
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"tx DIU in state %s"
argument_list|,
name|ifpi2_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator||=
operator|(
name|ISACSX_CIX0_CDIU
operator|<<
literal|4
operator|)
expr_stmt|;
break|break;
block|}
name|ISAC_WRITE
argument_list|(
name|I_CIX0
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	L1 ISACSX initialization  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|ifpi2_isacsx_init
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|isacsx_imaskd
operator|=
literal|0xff
expr_stmt|;
comment|/* disable all irqs */
name|isacsx_imask
operator|=
literal|0xff
expr_stmt|;
comment|/* disable all irqs */
name|ISAC_WRITE
argument_list|(
name|I_MASKD
argument_list|,
name|isacsx_imaskd
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
name|isacsx_imask
argument_list|)
expr_stmt|;
comment|/* the ISACSX only runs in IOM-2 mode */
name|NDBGL1
argument_list|(
name|L1_I_SETUP
argument_list|,
literal|"configuring for IOM-2 mode"
argument_list|)
expr_stmt|;
comment|/* TR_CONF0: Transceiver Configuration Register 0: 	 *	DIS_TR - transceiver enabled 	 *	EN_ICV - normal operation 	 *	EXLP - no external loop 	 *	LDD - automatic clock generation 	 */
name|ISAC_WRITE
argument_list|(
name|I_WTR_CONF0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* TR_CONF2: Transceiver Configuration Register 1: 	 *	DIS_TX - transmitter enabled 	 *	PDS - phase deviation 2 S-bits 	 *	RLP - remote line loop open 	 */
name|ISAC_WRITE
argument_list|(
name|I_WTR_CONF2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* MODED: Mode Register: 	 *	MDSx - transparent mode 0 	 *	TMD  - timer mode = external 	 *	RAC  - Receiver enabled 	 *	DIMx - digital i/f mode 	 */
name|ISAC_WRITE
argument_list|(
name|I_WMODED
argument_list|,
name|ISACSX_MODED_MDS2
operator||
name|ISACSX_MODED_MDS1
operator||
name|ISACSX_MODED_RAC
operator||
name|ISACSX_MODED_DIM0
argument_list|)
expr_stmt|;
comment|/* enabled interrupts: 	 * =================== 	 * RME  - receive message end 	 * RPF  - receive pool full 	 * RPO  - receive pool overflow 	 * XPR  - transmit pool ready 	 * XMR  - transmit message repeat 	 * XDU  - transmit data underrun 	 */
name|isacsx_imaskd
operator|=
name|ISACSX_MASKD_LOW
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASKD
argument_list|,
name|isacsx_imaskd
argument_list|)
expr_stmt|;
comment|/* enabled interrupts: 	 * =================== 	 * ICD - HDLC interrupt from D-channel 	 * CIC - C/I channel change 	 */
name|isacsx_imask
operator|=
operator|~
operator|(
name|ISACSX_MASK_ICD
operator||
name|ISACSX_MASK_CIC
operator|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
name|isacsx_imask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

