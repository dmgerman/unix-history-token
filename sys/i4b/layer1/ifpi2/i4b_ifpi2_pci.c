begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  *   Copyright (c) 2001 Gary Jennejohn. All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *   3. Neither the name of the author nor the names of any co-contributors  *      may be used to endorse or promote products derived from this software  *      without specific prior written permission.  *   4. Altered versions must be plainly marked as such, and must not be  *      misrepresented as being the original software and/or documentation.  *     *   THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  *   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  *   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  *   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  *   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  *   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  *   SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------  *  *	i4b_ifpi2_pci.c: AVM Fritz!Card PCI hardware driver  *	--------------------------------------------------  *	$Id$  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_i4b.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_trace.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_global.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_l1.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_isic.h>
end_include

begin_comment
comment|/*#include<i4b/layer1/isic/i4b_isac.h>*/
end_comment

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_hscx.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/ifpi2/i4b_ifpi2_ext.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/ifpi2/i4b_ifpi2_isacsx.h>
end_include

begin_define
define|#
directive|define
name|PCI_AVMA1_VID
value|0x1244
end_define

begin_define
define|#
directive|define
name|PCI_AVMA1_V2_DID
value|0x0e00
end_define

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|avma1pp2_disable
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp2_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hscx_write_reg
parameter_list|(
name|int
parameter_list|,
name|u_int
parameter_list|,
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
name|hscx_read_reg
parameter_list|(
name|int
parameter_list|,
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|hscx_read_reg_int
parameter_list|(
name|int
parameter_list|,
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hscx_read_fifo
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hscx_write_fifo
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp2_hscx_int_handler
parameter_list|(
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp2_hscx_intr
parameter_list|(
name|int
parameter_list|,
name|u_int
parameter_list|,
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp2_init_linktab
parameter_list|(
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp2_bchannel_setup
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp2_bchannel_start
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp2_hscx_init
parameter_list|(
name|struct
name|l1_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp2_bchannel_stat
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|bchan_statistics_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp2_set_linktab
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|drvr_link_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isdn_link_t
modifier|*
name|avma1pp2_ret_linktab
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|avma1pp2_pci_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|avma1pp2_hscx_fifo
parameter_list|(
name|l1_bchan_state_t
modifier|*
parameter_list|,
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|avma1pp2_attach_avma1pp
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ifpi2_isacsx_intr
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|avma1pp2_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|avma1pp2_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|avma1pp2_attach_avma1pp
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|avma1pp2_disable
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|avma1pp2_pci_driver
init|=
block|{
literal|"ifpi2-"
block|,
name|avma1pp2_pci_methods
block|,
expr|sizeof
operator|(
expr|struct
name|l1_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|avma1pp2_pci_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|avma1pp2
argument_list|,
name|pci
argument_list|,
name|avma1pp2_pci_driver
argument_list|,
name|avma1pp2_pci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* jump table for multiplex routines */
end_comment

begin_decl_stmt
name|struct
name|i4b_l1mux_func
name|avma1pp2_l1mux_func
init|=
block|{
name|avma1pp2_ret_linktab
block|,
name|avma1pp2_set_linktab
block|,
name|ifpi2_mph_command_req
block|,
name|ifpi2_ph_data_req
block|,
name|ifpi2_ph_activate_req
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|l1_softc
modifier|*
name|ifpi2_scp
index|[
name|IFPI2_MAXUNIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*---------------------------------------------------------------------------*  *	AVM PCI Fritz!Card V. 2 special registers  *---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  *	AVM PCI Status Latch 0 read only bits  */
end_comment

begin_define
define|#
directive|define
name|ASL_IRQ_ISAC
value|0x01
end_define

begin_comment
comment|/* ISAC  interrupt, active high */
end_comment

begin_define
define|#
directive|define
name|ASL_IRQ_HSCX
value|0x02
end_define

begin_comment
comment|/* HSX   interrupt, active high */
end_comment

begin_define
define|#
directive|define
name|ASL_IRQ_TIMER
value|0x04
end_define

begin_comment
comment|/* Timer interrupt, active high */
end_comment

begin_define
define|#
directive|define
name|ASL_IRQ_BCHAN
value|ASL_IRQ_HSCX
end_define

begin_comment
comment|/* actually active high */
end_comment

begin_define
define|#
directive|define
name|ASL_IRQ_Pending
value|(ASL_IRQ_ISAC | ASL_IRQ_HSCX | ASL_IRQ_TIMER)
end_define

begin_comment
comment|/*  *	AVM PCI Status Latch 0 read only bits  */
end_comment

begin_define
define|#
directive|define
name|ASL_RESET
value|0x01
end_define

begin_define
define|#
directive|define
name|ASL_TIMERRESET
value|0x04
end_define

begin_define
define|#
directive|define
name|ASL_ENABLE_INT
value|0x08
end_define

begin_comment
comment|/*  * "HSCX" status bits  */
end_comment

begin_define
define|#
directive|define
name|HSCX_STAT_RME
value|0x01
end_define

begin_define
define|#
directive|define
name|HSCX_STAT_RDO
value|0x10
end_define

begin_define
define|#
directive|define
name|HSCX_STAT_CRCVFRRAB
value|0x0E
end_define

begin_define
define|#
directive|define
name|HSCX_STAT_CRCVFR
value|0x06
end_define

begin_define
define|#
directive|define
name|HSCX_STAT_RML_MASK
value|0x3f00
end_define

begin_comment
comment|/*  * "HSCX" interrupt bits  */
end_comment

begin_define
define|#
directive|define
name|HSCX_INT_XPR
value|0x80
end_define

begin_define
define|#
directive|define
name|HSCX_INT_XDU
value|0x40
end_define

begin_define
define|#
directive|define
name|HSCX_INT_RPR
value|0x20
end_define

begin_define
define|#
directive|define
name|HSCX_INT_MASK
value|0xE0
end_define

begin_comment
comment|/*  * "HSCX" command bits  */
end_comment

begin_define
define|#
directive|define
name|HSCX_CMD_XRS
value|0x80
end_define

begin_define
define|#
directive|define
name|HSCX_CMD_XME
value|0x01
end_define

begin_define
define|#
directive|define
name|HSCX_CMD_RRS
value|0x20
end_define

begin_define
define|#
directive|define
name|HSCX_CMD_XML_MASK
value|0x3f00
end_define

begin_comment
comment|/* "HSCX" mode bits */
end_comment

begin_define
define|#
directive|define
name|HSCX_MODE_ITF_FLG
value|0x01
end_define

begin_define
define|#
directive|define
name|HSCX_MODE_TRANS
value|0x02
end_define

begin_comment
comment|/* offsets to various registers in the ASIC, evidently */
end_comment

begin_define
define|#
directive|define
name|STAT0_OFFSET
value|0x02
end_define

begin_define
define|#
directive|define
name|HSCX_FIFO1
value|0x10
end_define

begin_define
define|#
directive|define
name|HSCX_FIFO2
value|0x18
end_define

begin_define
define|#
directive|define
name|HSCX_STAT1
value|0x14
end_define

begin_define
define|#
directive|define
name|HSCX_STAT2
value|0x1c
end_define

begin_define
define|#
directive|define
name|ISACSX_INDEX
value|0x04
end_define

begin_define
define|#
directive|define
name|ISACSX_DATA
value|0x08
end_define

begin_comment
comment|/*  * Commands and parameters are sent to the "HSCX" as a long, but the  * fields are handled as bytes.  *  * The long contains:  *	(prot<< 16)|(txl<< 8)|cmd  *  * where:  *	prot = protocol to use  *	txl = transmit length  *	cmd = the command to be executed  *  * The fields are defined as u_char in struct l1_softc.  *  * Macro to coalesce the byte fields into a u_int  */
end_comment

begin_define
define|#
directive|define
name|AVMA1PPSETCMDLONG
parameter_list|(
name|f
parameter_list|)
value|(f) = ((sc->avma1pp_cmd) | (sc->avma1pp_txl<< 8) \  					| (sc->avma1pp_prot<< 16))
end_define

begin_comment
comment|/*  * to prevent deactivating the "HSCX" when both channels are active we  * define an HSCX_ACTIVE flag which is or'd into the channel's state  * flag in avma1pp2_bchannel_setup upon active and cleared upon deactivation.  * It is set high to allow room for new flags.  */
end_comment

begin_define
define|#
directive|define
name|HSCX_AVMA1PP_ACTIVE
value|0x1000
end_define

begin_comment
comment|/*---------------------------------------------------------------------------*  *	AVM read fifo routines  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|avma1pp2_read_fifo
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_4
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISACSX_INDEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* evidently each byte must be read as a long */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|bus_space_read_4
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISACSX_DATA
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|hscx_read_fifo
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|hscx_read_fifo
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hscx_read_fifo
parameter_list|(
name|int
name|chan
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|ip
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|int
name|dataoff
decl_stmt|;
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|dataoff
operator|=
name|chan
condition|?
name|HSCX_FIFO2
else|:
name|HSCX_FIFO1
expr_stmt|;
name|ip
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|buf
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
comment|/* what if len isn't a multiple of sizeof(int) and buf is */
comment|/* too small ???? */
while|while
condition|(
name|cnt
operator|<
name|len
condition|)
block|{
operator|*
name|ip
operator|++
operator|=
name|bus_space_read_4
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|dataoff
argument_list|)
expr_stmt|;
name|cnt
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	AVM write fifo routines  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|avma1pp2_write_fifo
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_4
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISACSX_INDEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* evidently each byte must written as a long */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|bus_space_write_4
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISACSX_DATA
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|hscx_write_fifo
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|hscx_write_fifo
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hscx_write_fifo
parameter_list|(
name|int
name|chan
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|ip
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|int
name|dataoff
decl_stmt|;
name|l1_bchan_state_t
modifier|*
name|Bchan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|chan
index|]
decl_stmt|;
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|dataoff
operator|=
name|chan
condition|?
name|HSCX_FIFO2
else|:
name|HSCX_FIFO1
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|&=
operator|~
name|HSCX_CMD_XME
expr_stmt|;
name|sc
operator|->
name|avma1pp_txl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Bchan
operator|->
name|out_mbuf_cur
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|Bchan
operator|->
name|bprot
operator|!=
name|BPROT_NONE
condition|)
name|sc
operator|->
name|avma1pp_cmd
operator||=
name|HSCX_CMD_XME
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
name|sc
operator|->
name|sc_bfifolen
condition|)
name|sc
operator|->
name|avma1pp_txl
operator|=
name|len
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
comment|/* borrow cnt */
name|AVMA1PPSETCMDLONG
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|chan
argument_list|,
name|cnt
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|buf
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cnt
operator|<
name|len
condition|)
block|{
name|bus_space_write_4
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|dataoff
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|++
expr_stmt|;
name|cnt
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	AVM write register routines  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|avma1pp2_write_reg
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_4
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISACSX_INDEX
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISACSX_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|hscx_write_reg
argument_list|(
literal|0
argument_list|,
name|data
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|hscx_write_reg
argument_list|(
literal|1
argument_list|,
name|data
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hscx_write_reg
parameter_list|(
name|int
name|chan
parameter_list|,
name|u_int
name|val
parameter_list|,
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|u_int
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|chan
operator|==
literal|0
condition|?
name|HSCX_STAT1
else|:
name|HSCX_STAT2
operator|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	AVM read register routines  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|u_int8_t
name|avma1pp2_read_reg
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|)
block|{
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|u_int8_t
name|val
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_4
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISACSX_INDEX
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|u_int8_t
operator|)
name|bus_space_read_4
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISACSX_DATA
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
case|case
name|ISIC_WHAT_HSCXA
case|:
return|return
name|hscx_read_reg
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|)
return|;
case|case
name|ISIC_WHAT_HSCXB
case|:
return|return
name|hscx_read_reg
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u_char
name|hscx_read_reg
parameter_list|(
name|int
name|chan
parameter_list|,
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|hscx_read_reg_int
argument_list|(
name|chan
argument_list|,
name|sc
argument_list|)
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * need to be able to return an int because the RBCH is in the 2nd  * byte.  */
end_comment

begin_function
specifier|static
name|u_int
name|hscx_read_reg_int
parameter_list|(
name|int
name|chan
parameter_list|,
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|u_int
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|chan
operator|==
literal|0
condition|?
name|HSCX_STAT1
else|:
name|HSCX_STAT2
operator|)
expr_stmt|;
return|return
operator|(
name|bus_space_read_4
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	avma1pp2_probe - probe for a card  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|avma1pp2_pci_probe
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|u_int16_t
name|did
decl_stmt|,
name|vid
decl_stmt|;
name|vid
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|did
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vid
operator|==
name|PCI_AVMA1_VID
operator|)
operator|&&
operator|(
name|did
operator|==
name|PCI_AVMA1_V2_DID
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"AVM Fritz!Card PCI Version 2"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	avma1pp2_attach_avma1pp - attach Fritz!Card PCI  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|avma1pp2_attach_avma1pp
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|l1_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|v
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_int16_t
name|did
decl_stmt|,
name|vid
decl_stmt|;
name|void
modifier|*
name|ih
init|=
literal|0
decl_stmt|;
name|bus_space_handle_t
name|bhandle
decl_stmt|;
name|bus_space_tag_t
name|btag
decl_stmt|;
name|l1_bchan_state_t
modifier|*
name|chan
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|vid
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|did
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|l1_softc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* probably not really required */
if|if
condition|(
name|unit
operator|>=
name|IFPI2_MAXUNIT
condition|)
block|{
name|printf
argument_list|(
literal|"ifpi2-%d: Error, unit>= IFPI_MAXUNIT!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|vid
operator|!=
name|PCI_AVMA1_VID
operator|)
operator|&&
operator|(
name|did
operator|!=
name|PCI_AVMA1_V2_DID
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ifpi2-%d: unknown device!?\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifpi2_scp
index|[
name|unit
index|]
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_resources
operator|.
name|io_rid
index|[
literal|0
index|]
operator|=
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|sc_resources
operator|.
name|io_rid
index|[
literal|0
index|]
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ifpi2-%d: couldn't map IO port\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Allocate interrupt */
name|sc
operator|->
name|sc_resources
operator|.
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_resources
operator|.
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|sc_resources
operator|.
name|irq_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_resources
operator|.
name|irq
operator|==
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ifpi2-%d: couldn't map interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_resources
operator|.
name|irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|NULL
argument_list|,
name|avma1pp2_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_resources
operator|.
name|irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ifpi2-%d: couldn't set up irq\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|sc_unit
operator|=
name|unit
expr_stmt|;
comment|/* end of new-bus stuff */
name|ISAC_BASE
operator|=
operator|(
name|caddr_t
operator|)
name|ISIC_WHAT_ISAC
expr_stmt|;
name|HSCX_A_BASE
operator|=
operator|(
name|caddr_t
operator|)
name|ISIC_WHAT_HSCXA
expr_stmt|;
name|HSCX_B_BASE
operator|=
operator|(
name|caddr_t
operator|)
name|ISIC_WHAT_HSCXB
expr_stmt|;
comment|/* setup access routines */
name|sc
operator|->
name|clearirq
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|readreg
operator|=
name|avma1pp2_read_reg
expr_stmt|;
name|sc
operator|->
name|writereg
operator|=
name|avma1pp2_write_reg
expr_stmt|;
name|sc
operator|->
name|readfifo
operator|=
name|avma1pp2_read_fifo
expr_stmt|;
name|sc
operator|->
name|writefifo
operator|=
name|avma1pp2_write_fifo
expr_stmt|;
comment|/* setup card type */
name|sc
operator|->
name|sc_cardtyp
operator|=
name|CARD_TYPEP_AVMA1PCI_V2
expr_stmt|;
comment|/* setup IOM bus type */
name|sc
operator|->
name|sc_bustyp
operator|=
name|BUS_TYPE_IOM2
expr_stmt|;
comment|/* set up some other miscellaneous things */
name|sc
operator|->
name|sc_ipac
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bfifolen
operator|=
name|HSCX_FIFO_LEN
expr_stmt|;
comment|/* reset the card */
comment|/* the Linux driver does this to clear any pending ISAC interrupts */
name|v
operator|=
literal|0
expr_stmt|;
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_RMODED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_V2_DEBUG
name|printf
argument_list|(
literal|"avma1pp2_attach: I_MODED %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_ISTAD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_V2_DEBUG
name|printf
argument_list|(
literal|"avma1pp2_attach: I_ISTAD %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_ISTA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_V2_DEBUG
name|printf
argument_list|(
literal|"avma1pp2_attach: I_ISTA %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ISAC_WRITE
argument_list|(
name|I_MASKD
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* the Linux driver does this to clear any pending HSCX interrupts */
name|v
operator|=
name|hscx_read_reg_int
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_V2_DEBUG
name|printf
argument_list|(
literal|"avma1pp2_attach: 0 HSCX_STAT %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|hscx_read_reg_int
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_V2_DEBUG
name|printf
argument_list|(
literal|"avma1pp2_attach: 1 HSCX_STAT %x\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|STAT0_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* 10 ms */
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|STAT0_OFFSET
argument_list|,
name|ASL_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* 10 ms */
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|STAT0_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* 10 ms */
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|STAT0_OFFSET
argument_list|,
name|ASL_TIMERRESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* 10 ms */
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|STAT0_OFFSET
argument_list|,
name|ASL_ENABLE_INT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* 10 ms */
comment|/* from here to the end would normally be done in isic_pciattach */
name|printf
argument_list|(
literal|"ifpi2-%d: ISACSX %s\n"
argument_list|,
name|unit
argument_list|,
literal|"PSB3186"
argument_list|)
expr_stmt|;
comment|/* init the ISAC */
name|ifpi2_isacsx_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>
literal|4
comment|/* Init the channel mutexes */
name|chan
operator|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_A
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
operator|.
name|ifq_mtx
argument_list|)
condition|)
name|mtx_init
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"i4b_avma1pp2_rx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
operator|.
name|ifq_mtx
argument_list|)
condition|)
name|mtx_init
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"i4b_avma1pp2_tx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|chan
operator|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_B
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
operator|.
name|ifq_mtx
argument_list|)
condition|)
name|mtx_init
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"i4b_avma1pp2_rx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
operator|.
name|ifq_mtx
argument_list|)
condition|)
name|mtx_init
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"i4b_avma1pp2_tx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* init the "HSCX" */
name|avma1pp2_bchannel_setup
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
name|HSCX_CH_A
argument_list|,
name|BPROT_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|avma1pp2_bchannel_setup
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
name|HSCX_CH_B
argument_list|,
name|BPROT_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* can't use the normal B-Channel stuff */
name|avma1pp2_init_linktab
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set trace level */
name|sc
operator|->
name|sc_trace
operator|=
name|TRACE_OFF
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ISAC_IDLE
expr_stmt|;
name|sc
operator|->
name|sc_ibuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ib
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_obuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_op
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ol
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_freeflag
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_obuf2
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_freeflag2
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_T3_callout
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_T4_callout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* init higher protocol layers */
name|i4b_l1_mph_status_ind
argument_list|(
name|L0IFPI2UNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
argument_list|,
name|STI_ATTACH
argument_list|,
name|sc
operator|->
name|sc_cardtyp
argument_list|,
operator|&
name|avma1pp2_l1mux_func
argument_list|)
expr_stmt|;
name|fail
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this is the real interrupt routine  */
end_comment

begin_function
specifier|static
name|void
name|avma1pp2_hscx_intr
parameter_list|(
name|int
name|h_chan
parameter_list|,
name|u_int
name|stat
parameter_list|,
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|register
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|int
name|activity
init|=
operator|-
literal|1
decl_stmt|;
name|u_int
name|param
init|=
literal|0
decl_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"%#x"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|HSCX_INT_XDU
operator|)
operator|&&
operator|(
name|chan
operator|->
name|bprot
operator|!=
name|BPROT_NONE
operator|)
condition|)
comment|/* xmit data underrun */
block|{
name|chan
operator|->
name|stat_XDU
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"xmit data underrun"
argument_list|)
expr_stmt|;
comment|/* abort the transmission */
name|sc
operator|->
name|avma1pp_txl
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator||=
name|HSCX_CMD_XRS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|&=
operator|~
name|HSCX_CMD_XRS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_head
operator|!=
name|NULL
condition|)
comment|/* don't continue to transmit this buffer */
block|{
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * The following is based on examination of the Linux driver. 	 * 	 * The logic here is different than with a "real" HSCX; all kinds 	 * of information (interrupt/status bits) are in stat. 	 *		HSCX_INT_RPR indicates a receive interrupt 	 *			HSCX_STAT_RDO indicates an overrun condition, abort - 	 *			otherwise read the bytes ((stat& HSCX_STZT_RML_MASK)>> 8) 	 *			HSCX_STAT_RME indicates end-of-frame and apparently any 	 *			CRC/framing errors are only reported in this state. 	 *				if ((stat& HSCX_STAT_CRCVFRRAB) != HSCX_STAT_CRCVFR) 	 *					CRC/framing error 	 */
if|if
condition|(
name|stat
operator|&
name|HSCX_INT_RPR
condition|)
block|{
specifier|register
name|int
name|fifo_data_len
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* always have to read the FIFO, so use a scratch buffer */
name|u_char
name|scrbuf
index|[
name|HSCX_FIFO_LEN
index|]
decl_stmt|;
if|if
condition|(
name|stat
operator|&
name|HSCX_STAT_RDO
condition|)
block|{
name|chan
operator|->
name|stat_RDO
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"receive data overflow"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
comment|/* 		 * check whether we're receiving data for an inactive B-channel 		 * and discard it. This appears to happen for telephony when 		 * both B-channels are active and one is deactivated. Since 		 * it is not really possible to deactivate the channel in that 		 * case (the ASIC seems to deactivate _both_ channels), the 		 * "deactivated" channel keeps receiving data which can lead 		 * to exhaustion of mbufs and a kernel panic. 		 * 		 * This is a hack, but it's the only solution I can think of 		 * without having the documentation for the ASIC. 		 * GJ - 28 Nov 1999 		 */
if|if
condition|(
name|chan
operator|->
name|state
operator|==
name|HSCX_IDLE
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"toss data from %d"
argument_list|,
name|h_chan
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
name|fifo_data_len
operator|=
operator|(
operator|(
name|stat
operator|&
name|HSCX_STAT_RML_MASK
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|fifo_data_len
operator|==
literal|0
condition|)
name|fifo_data_len
operator|=
name|sc
operator|->
name|sc_bfifolen
expr_stmt|;
comment|/* ALWAYS read data from HSCX fifo */
name|HSCX_RDFIFO
argument_list|(
name|h_chan
argument_list|,
name|scrbuf
argument_list|,
name|fifo_data_len
argument_list|)
expr_stmt|;
name|chan
operator|->
name|rxcount
operator|+=
name|fifo_data_len
expr_stmt|;
comment|/* all error conditions checked, now decide and take action */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chan
operator|->
name|in_mbuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|chan
operator|->
name|in_mbuf
operator|=
name|i4b_Bgetmbuf
argument_list|(
name|BCH_MAX_DATALEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"L1 avma1pp2_hscx_intr: RME, cannot allocate mbuf!\n"
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|chan
operator|->
name|in_len
operator|+
name|fifo_data_len
operator|)
operator|<=
name|BCH_MAX_DATALEN
condition|)
block|{
comment|/* OK to copy the data */
name|bcopy
argument_list|(
name|scrbuf
argument_list|,
name|chan
operator|->
name|in_cbptr
argument_list|,
name|fifo_data_len
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|+=
name|fifo_data_len
expr_stmt|;
name|chan
operator|->
name|in_len
operator|+=
name|fifo_data_len
expr_stmt|;
comment|/* setup mbuf data length */
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_RX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0IFPI2UNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_NT
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|HSCX_STAT_RME
condition|)
block|{
if|if
condition|(
operator|(
name|stat
operator|&
name|HSCX_STAT_CRCVFRRAB
operator|)
operator|==
name|HSCX_STAT_CRCVFR
condition|)
block|{
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_rx_data_ready
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|)
expr_stmt|;
name|activity
operator|=
name|ACT_RX
expr_stmt|;
comment|/* mark buffer ptr as unused */
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|->
name|stat_CRC
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"CRC/RAB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|in_mbuf
operator|!=
name|NULL
condition|)
block|{
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|in_mbuf
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* END enough space in mbuf */
else|else
block|{
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_NONE
condition|)
block|{
comment|/* setup mbuf data length */
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_RX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0IFPI2UNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_NT
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|i4b_l1_bchan_tel_silence
argument_list|(
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
argument_list|)
operator|)
condition|)
name|activity
operator|=
name|ACT_RX
expr_stmt|;
comment|/* move rx'd data to rx queue */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>
literal|4
operator|(
name|void
operator|)
name|IF_HANDOFF
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
argument_list|,
name|chan
operator|->
name|in_mbuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|IF_QFULL
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
argument_list|)
operator|)
condition|)
block|{
name|IF_ENQUEUE
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
argument_list|,
name|chan
operator|->
name|in_mbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|in_mbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* signal upper layer that data are available */
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_rx_data_ready
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* alloc new buffer */
if|if
condition|(
operator|(
name|chan
operator|->
name|in_mbuf
operator|=
name|i4b_Bgetmbuf
argument_list|(
name|BCH_MAX_DATALEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"L1 avma1pp2_hscx_intr: RPF, cannot allocate new mbuf!\n"
argument_list|)
expr_stmt|;
comment|/* setup new data ptr */
name|chan
operator|->
name|in_cbptr
operator|=
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
expr_stmt|;
comment|/* OK to copy the data */
name|bcopy
argument_list|(
name|scrbuf
argument_list|,
name|chan
operator|->
name|in_cbptr
argument_list|,
name|fifo_data_len
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|+=
name|fifo_data_len
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
name|fifo_data_len
expr_stmt|;
name|chan
operator|->
name|rxcount
operator|+=
name|fifo_data_len
expr_stmt|;
block|}
else|else
block|{
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"RAWHDLC rx buffer overflow in RPF, in_len=%d"
argument_list|,
name|chan
operator|->
name|in_len
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* if(error == 0) */
else|else
block|{
comment|/* land here for RDO */
if|if
condition|(
name|chan
operator|->
name|in_mbuf
operator|!=
name|NULL
condition|)
block|{
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|in_mbuf
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|avma1pp_txl
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator||=
name|HSCX_CMD_RRS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|&=
operator|~
name|HSCX_CMD_RRS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* transmit fifo empty, new data can be written to fifo */
if|if
condition|(
name|stat
operator|&
name|HSCX_INT_XPR
condition|)
block|{
comment|/* 		 * for a description what is going on here, please have 		 * a look at isic_bchannel_start() in i4b_bchan.c ! 		 */
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"unit %d, chan %d - XPR, Tx Fifo Empty!"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|h_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_cur
operator|==
name|NULL
condition|)
comment|/* last frame is transmitted */
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
argument_list|,
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_head
operator|==
name|NULL
condition|)
block|{
name|chan
operator|->
name|state
operator|&=
operator|~
name|HSCX_TX_ACTIVE
expr_stmt|;
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_tx_queue_empty
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|->
name|state
operator||=
name|HSCX_TX_ACTIVE
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_head
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_TX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0IFPI2UNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_TE
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_NONE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|i4b_l1_bchan_tel_silence
argument_list|(
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|)
operator|)
condition|)
name|activity
operator|=
name|ACT_TX
expr_stmt|;
block|}
else|else
block|{
name|activity
operator|=
name|ACT_TX
expr_stmt|;
block|}
block|}
block|}
name|avma1pp2_hscx_fifo
argument_list|(
name|chan
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* call timeout handling routine */
if|if
condition|(
name|activity
operator|==
name|ACT_RX
operator|||
name|activity
operator|==
name|ACT_TX
condition|)
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_activity
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|,
name|activity
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this is the main routine which checks each channel and then calls  * the real interrupt routine as appropriate  */
end_comment

begin_function
specifier|static
name|void
name|avma1pp2_hscx_int_handler
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|stat
decl_stmt|;
comment|/* has to be a u_int because the byte count is in the 2nd byte */
name|stat
operator|=
name|hscx_read_reg_int
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|HSCX_INT_MASK
condition|)
name|avma1pp2_hscx_intr
argument_list|(
literal|0
argument_list|,
name|stat
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|stat
operator|=
name|hscx_read_reg_int
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|HSCX_INT_MASK
condition|)
name|avma1pp2_hscx_intr
argument_list|(
literal|1
argument_list|,
name|stat
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|avma1pp2_disable
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* could be still be wrong, but seems to prevent hangs */
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|STAT0_OFFSET
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|avma1pp2_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|u_char
name|stat
decl_stmt|;
name|struct
name|l1_softc
modifier|*
name|sc
decl_stmt|;
name|bus_space_handle_t
name|bhandle
decl_stmt|;
name|bus_space_tag_t
name|btag
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|stat
operator|=
name|bus_space_read_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|STAT0_OFFSET
argument_list|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"stat %x"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
comment|/* was there an interrupt from this card ? */
if|if
condition|(
operator|(
name|stat
operator|&
name|ASL_IRQ_Pending
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* no */
comment|/* For slow machines loop as long as an interrupt is active */
for|for
control|(
init|;
operator|(
operator|(
name|stat
operator|&
name|ASL_IRQ_Pending
operator|)
operator|!=
literal|0
operator|)
condition|;
control|)
block|{
comment|/* interrupts are high active */
if|if
condition|(
name|stat
operator|&
name|ASL_IRQ_TIMER
condition|)
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"timer interrupt ???"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|ASL_IRQ_HSCX
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"HSCX"
argument_list|)
expr_stmt|;
name|avma1pp2_hscx_int_handler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|ASL_IRQ_ISAC
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"ISAC"
argument_list|)
expr_stmt|;
name|ifpi2_isacsx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|stat
operator|=
name|bus_space_read_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|STAT0_OFFSET
argument_list|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"stat %x"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|avma1pp2_hscx_init
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|int
name|activate
parameter_list|)
block|{
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|u_int
name|param
init|=
literal|0
decl_stmt|;
name|NDBGL1
argument_list|(
name|L1_BCHAN
argument_list|,
literal|"unit=%d, channel=%d, %s"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|h_chan
argument_list|,
name|activate
condition|?
literal|"activate"
else|:
literal|"deactivate"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|sc
operator|->
name|avma1pp_prot
operator|=
name|sc
operator|->
name|avma1pp_txl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|activate
operator|==
literal|0
condition|)
block|{
comment|/* only deactivate if both channels are idle */
if|if
condition|(
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_A
index|]
operator|.
name|state
operator|!=
name|HSCX_IDLE
operator|||
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_B
index|]
operator|.
name|state
operator|!=
name|HSCX_IDLE
condition|)
block|{
return|return;
block|}
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|HSCX_CMD_XRS
operator||
name|HSCX_CMD_RRS
expr_stmt|;
name|sc
operator|->
name|avma1pp_prot
operator|=
name|HSCX_MODE_TRANS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_RHDLC
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_BCHAN
argument_list|,
literal|"BPROT_RHDLC"
argument_list|)
expr_stmt|;
comment|/* HDLC Frames, transparent mode 0 */
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|HSCX_CMD_XRS
operator||
name|HSCX_CMD_RRS
expr_stmt|;
name|sc
operator|->
name|avma1pp_prot
operator|=
name|HSCX_MODE_ITF_FLG
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|HSCX_CMD_XRS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|NDBGL1
argument_list|(
name|L1_BCHAN
argument_list|,
literal|"BPROT_NONE??"
argument_list|)
expr_stmt|;
comment|/* Raw Telephony, extended transparent mode 1 */
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|HSCX_CMD_XRS
operator||
name|HSCX_CMD_RRS
expr_stmt|;
name|sc
operator|->
name|avma1pp_prot
operator|=
name|HSCX_MODE_TRANS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|HSCX_CMD_XRS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|avma1pp2_bchannel_setup
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|int
name|bprot
parameter_list|,
name|int
name|activate
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|ifpi2_scp
index|[
name|unit
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|isic_find_sc
argument_list|(
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|int
name|s
init|=
name|SPLI4B
argument_list|()
decl_stmt|;
if|if
condition|(
name|activate
operator|==
literal|0
condition|)
block|{
comment|/* deactivation */
name|chan
operator|->
name|state
operator|=
name|HSCX_IDLE
expr_stmt|;
name|avma1pp2_hscx_init
argument_list|(
name|sc
argument_list|,
name|h_chan
argument_list|,
name|activate
argument_list|)
expr_stmt|;
block|}
name|NDBGL1
argument_list|(
name|L1_BCHAN
argument_list|,
literal|"unit=%d, channel=%d, %s"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|h_chan
argument_list|,
name|activate
condition|?
literal|"activate"
else|:
literal|"deactivate"
argument_list|)
expr_stmt|;
comment|/* general part */
name|chan
operator|->
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
comment|/* unit number */
name|chan
operator|->
name|channel
operator|=
name|h_chan
expr_stmt|;
comment|/* B channel */
name|chan
operator|->
name|bprot
operator|=
name|bprot
expr_stmt|;
comment|/* B channel protocol */
name|chan
operator|->
name|state
operator|=
name|HSCX_IDLE
expr_stmt|;
comment|/* B channel state */
comment|/* receiver part */
name|chan
operator|->
name|rx_queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|i4b_Bcleanifq
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
argument_list|)
expr_stmt|;
comment|/* clean rx queue */
name|chan
operator|->
name|rxcount
operator|=
literal|0
expr_stmt|;
comment|/* reset rx counter */
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|in_mbuf
argument_list|)
expr_stmt|;
comment|/* clean rx mbuf */
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
comment|/* reset mbuf ptr */
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
comment|/* reset mbuf curr ptr */
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
comment|/* reset mbuf data len */
comment|/* transmitter part */
name|chan
operator|->
name|tx_queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|i4b_Bcleanifq
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
argument_list|)
expr_stmt|;
comment|/* clean tx queue */
name|chan
operator|->
name|txcount
operator|=
literal|0
expr_stmt|;
comment|/* reset tx counter */
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
comment|/* clean tx mbuf */
name|chan
operator|->
name|out_mbuf_head
operator|=
name|NULL
expr_stmt|;
comment|/* reset head mbuf ptr */
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|NULL
expr_stmt|;
comment|/* reset current mbuf ptr */
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* reset current mbuf data ptr */
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
literal|0
expr_stmt|;
comment|/* reset current mbuf data cnt */
if|if
condition|(
name|activate
operator|!=
literal|0
condition|)
block|{
comment|/* activation */
name|avma1pp2_hscx_init
argument_list|(
name|sc
argument_list|,
name|h_chan
argument_list|,
name|activate
argument_list|)
expr_stmt|;
name|chan
operator|->
name|state
operator||=
name|HSCX_AVMA1PP_ACTIVE
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|avma1pp2_bchannel_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|ifpi2_scp
index|[
name|unit
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|isic_find_sc
argument_list|(
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|register
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|activity
init|=
operator|-
literal|1
decl_stmt|;
name|s
operator|=
name|SPLI4B
argument_list|()
expr_stmt|;
comment|/* enter critical section */
if|if
condition|(
name|chan
operator|->
name|state
operator|&
name|HSCX_TX_ACTIVE
condition|)
comment|/* already running ? */
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
comment|/* yes, leave */
block|}
comment|/* get next mbuf from queue */
name|IF_DEQUEUE
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
argument_list|,
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_head
operator|==
name|NULL
condition|)
comment|/* queue empty ? */
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* leave critical section */
return|return;
comment|/* yes, exit */
block|}
comment|/* init current mbuf values */
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_head
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
expr_stmt|;
comment|/* activity indicator for timeout handling */
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_NONE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|i4b_l1_bchan_tel_silence
argument_list|(
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|)
operator|)
condition|)
name|activity
operator|=
name|ACT_TX
expr_stmt|;
block|}
else|else
block|{
name|activity
operator|=
name|ACT_TX
expr_stmt|;
block|}
name|chan
operator|->
name|state
operator||=
name|HSCX_TX_ACTIVE
expr_stmt|;
comment|/* we start transmitting */
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_TX
condition|)
comment|/* if trace, send mbuf to trace dev */
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0IFPI2UNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_TE
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
name|avma1pp2_hscx_fifo
argument_list|(
name|chan
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* call timeout handling routine */
if|if
condition|(
name|activity
operator|==
name|ACT_RX
operator|||
name|activity
operator|==
name|ACT_TX
condition|)
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_activity
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|,
name|activity
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	return the address of isic drivers linktab	  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|isdn_link_t
modifier|*
name|avma1pp2_ret_linktab
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|ifpi2_scp
index|[
name|unit
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|isic_find_sc
argument_list|(
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|channel
index|]
decl_stmt|;
return|return
operator|(
operator|&
name|chan
operator|->
name|isic_isdn_linktab
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	set the driver linktab in the b channel softc  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|avma1pp2_set_linktab
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|channel
parameter_list|,
name|drvr_link_t
modifier|*
name|dlt
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|ifpi2_scp
index|[
name|unit
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|isic_find_sc
argument_list|(
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|channel
index|]
decl_stmt|;
name|chan
operator|->
name|isic_drvr_linktab
operator|=
name|dlt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	initialize our local linktab  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|avma1pp2_init_linktab
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_A
index|]
decl_stmt|;
name|isdn_link_t
modifier|*
name|lt
init|=
operator|&
name|chan
operator|->
name|isic_isdn_linktab
decl_stmt|;
comment|/* make sure the hardware driver is known to layer 4 */
comment|/* avoid overwriting if already set */
if|if
condition|(
name|ctrl_types
index|[
name|CTRL_PASSIVE
index|]
operator|.
name|set_linktab
operator|==
name|NULL
condition|)
block|{
name|ctrl_types
index|[
name|CTRL_PASSIVE
index|]
operator|.
name|set_linktab
operator|=
name|i4b_l1_set_linktab
expr_stmt|;
name|ctrl_types
index|[
name|CTRL_PASSIVE
index|]
operator|.
name|get_linktab
operator|=
name|i4b_l1_ret_linktab
expr_stmt|;
block|}
comment|/* local setup */
name|lt
operator|->
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|lt
operator|->
name|channel
operator|=
name|HSCX_CH_A
expr_stmt|;
name|lt
operator|->
name|bch_config
operator|=
name|avma1pp2_bchannel_setup
expr_stmt|;
name|lt
operator|->
name|bch_tx_start
operator|=
name|avma1pp2_bchannel_start
expr_stmt|;
name|lt
operator|->
name|bch_stat
operator|=
name|avma1pp2_bchannel_stat
expr_stmt|;
name|lt
operator|->
name|tx_queue
operator|=
operator|&
name|chan
operator|->
name|tx_queue
expr_stmt|;
comment|/* used by non-HDLC data transfers, i.e. telephony drivers */
name|lt
operator|->
name|rx_queue
operator|=
operator|&
name|chan
operator|->
name|rx_queue
expr_stmt|;
comment|/* used by HDLC data transfers, i.e. ipr and isp drivers */
name|lt
operator|->
name|rx_mbuf
operator|=
operator|&
name|chan
operator|->
name|in_mbuf
expr_stmt|;
name|chan
operator|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_B
index|]
expr_stmt|;
name|lt
operator|=
operator|&
name|chan
operator|->
name|isic_isdn_linktab
expr_stmt|;
name|lt
operator|->
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|lt
operator|->
name|channel
operator|=
name|HSCX_CH_B
expr_stmt|;
name|lt
operator|->
name|bch_config
operator|=
name|avma1pp2_bchannel_setup
expr_stmt|;
name|lt
operator|->
name|bch_tx_start
operator|=
name|avma1pp2_bchannel_start
expr_stmt|;
name|lt
operator|->
name|bch_stat
operator|=
name|avma1pp2_bchannel_stat
expr_stmt|;
name|lt
operator|->
name|tx_queue
operator|=
operator|&
name|chan
operator|->
name|tx_queue
expr_stmt|;
comment|/* used by non-HDLC data transfers, i.e. telephony drivers */
name|lt
operator|->
name|rx_queue
operator|=
operator|&
name|chan
operator|->
name|rx_queue
expr_stmt|;
comment|/* used by HDLC data transfers, i.e. ipr and isp drivers */
name|lt
operator|->
name|rx_mbuf
operator|=
operator|&
name|chan
operator|->
name|in_mbuf
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * use this instead of isic_bchannel_stat in i4b_bchan.c because it's static  */
end_comment

begin_function
specifier|static
name|void
name|avma1pp2_bchannel_stat
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|bchan_statistics_t
modifier|*
name|bsp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|ifpi2_scp
index|[
name|unit
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|isic_find_sc
argument_list|(
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|SPLI4B
argument_list|()
expr_stmt|;
name|bsp
operator|->
name|outbytes
operator|=
name|chan
operator|->
name|txcount
expr_stmt|;
name|bsp
operator|->
name|inbytes
operator|=
name|chan
operator|->
name|rxcount
expr_stmt|;
name|chan
operator|->
name|txcount
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|rxcount
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	fill HSCX fifo with data from the current mbuf  *	Put this here until it can go into i4b_hscx.c  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|avma1pp2_hscx_fifo
parameter_list|(
name|l1_bchan_state_t
modifier|*
name|chan
parameter_list|,
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|nextlen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|cmd
init|=
literal|0
decl_stmt|;
comment|/* using a scratch buffer simplifies writing to the FIFO */
name|u_char
name|scrbuf
index|[
name|HSCX_FIFO_LEN
index|]
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * fill the HSCX tx fifo with data from the current mbuf. if 	 * current mbuf holds less data than HSCX fifo length, try to 	 * get the next mbuf from (a possible) mbuf chain. if there is 	 * not enough data in a single mbuf or in a chain, then this 	 * is the last mbuf and we tell the HSCX that it has to send 	 * CRC and closing flag 	 */
while|while
condition|(
name|chan
operator|->
name|out_mbuf_cur
operator|&&
name|len
operator|!=
name|sc
operator|->
name|sc_bfifolen
condition|)
block|{
name|nextlen
operator|=
name|min
argument_list|(
name|chan
operator|->
name|out_mbuf_cur_len
argument_list|,
name|sc
operator|->
name|sc_bfifolen
operator|-
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTDEF
name|printf
argument_list|(
literal|"i:mh=%p, mc=%p, mcp=%p, mcl=%d l=%d nl=%d # "
argument_list|,
name|chan
operator|->
name|out_mbuf_head
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
argument_list|,
name|chan
operator|->
name|out_mbuf_cur_ptr
argument_list|,
name|chan
operator|->
name|out_mbuf_cur_len
argument_list|,
name|len
argument_list|,
name|nextlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cmd
operator||=
name|HSCX_CMDR_XTF
expr_stmt|;
comment|/* collect the data in the scratch buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nextlen
condition|;
name|i
operator|++
control|)
name|scrbuf
index|[
name|i
operator|+
name|len
index|]
operator|=
name|chan
operator|->
name|out_mbuf_cur_ptr
index|[
name|i
index|]
expr_stmt|;
name|len
operator|+=
name|nextlen
expr_stmt|;
name|chan
operator|->
name|txcount
operator|+=
name|nextlen
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|+=
name|nextlen
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|-=
name|nextlen
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_cur_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_next
operator|)
operator|!=
name|NULL
condition|)
block|{
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_TX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0IFPI2UNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|chan
operator|->
name|channel
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_TE
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|chan
operator|->
name|bprot
operator|!=
name|BPROT_NONE
condition|)
name|cmd
operator||=
name|HSCX_CMDR_XME
expr_stmt|;
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
name|chan
operator|->
name|out_mbuf_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* write what we have from the scratch buf to the HSCX fifo */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|HSCX_WRFIFO
argument_list|(
name|chan
operator|->
name|channel
argument_list|,
name|scrbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	ifpi2 - ISAC interrupt routine  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ifpi2_isacsx_intr
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|register
name|u_char
name|isacsx_irq_stat
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* get isac irq status */
comment|/* ISTA tells us whether it was a C/I or HDLC int. */
name|isacsx_irq_stat
operator|=
name|ISAC_READ
argument_list|(
name|I_ISTA
argument_list|)
expr_stmt|;
if|if
condition|(
name|isacsx_irq_stat
condition|)
name|ifpi2_isacsx_irq
argument_list|(
name|sc
argument_list|,
name|isacsx_irq_stat
argument_list|)
expr_stmt|;
comment|/* isac handler */
else|else
break|break;
block|}
name|ISAC_WRITE
argument_list|(
name|I_MASKD
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASKD
argument_list|,
name|isacsx_imaskd
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
name|isacsx_imask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	ifpi2_recover - try to recover from irq lockup  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|ifpi2_recover
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|printf
argument_list|(
literal|"ifpi2_recover %d\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* fix me later */
block|u_char byte;
comment|/* get isac irq status */
block|byte = ISAC_READ(I_ISTA);  	NDBGL1(L1_ERROR, "  ISAC: ISTA = 0x%x", byte); 	 	if(byte& ISACSX_ISTA_EXI) 		NDBGL1(L1_ERROR, "  ISAC: EXIR = 0x%x", (u_char)ISAC_READ(I_EXIR));  	if(byte& ISACSX_ISTA_CISQ) 	{ 		byte = ISAC_READ(I_CIRR); 	 		NDBGL1(L1_ERROR, "  ISAC: CISQ = 0x%x", byte); 		 		if(byte& ISACSX_CIRR_SQC) 			NDBGL1(L1_ERROR, "  ISAC: SQRR = 0x%x", (u_char)ISAC_READ(I_SQRR)); 	}  	NDBGL1(L1_ERROR, "  ISAC: IMASK = 0x%x", ISACSX_IMASK);  	ISAC_WRITE(I_MASKD, 0xff);	 	ISAC_WRITE(I_MASK, 0xff);	 	DELAY(100); 	ISAC_WRITE(I_MASKD, isacsx_imaskd); 	ISAC_WRITE(I_MASK, isacsx_imask);
endif|#
directive|endif
block|}
end_function

end_unit

