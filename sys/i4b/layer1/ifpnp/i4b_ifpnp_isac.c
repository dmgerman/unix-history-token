begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 2000 Hellmuth Michaelis. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	i4b_ifpnp_isac.c - i4b Fritz PnP ISAC handler  *	---------------------------------------------  *  *	$Id: i4b_ifpnp_isac.c,v 1.3 2000/05/29 15:41:41 hm Exp $   *	$Ust: src/i4b/layer1-nb/ifpnp/i4b_ifpnp_isac.c,v 1.4 2000/04/18 08:03:05 ust Exp $  *  * $FreeBSD$  *  *      last edit-date: [Mon May 29 15:24:49 2000]  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"ifpnp.h"
end_include

begin_if
if|#
directive|if
operator|(
name|NIFPNP
operator|>
literal|0
operator|)
end_if

begin_include
include|#
directive|include
file|"opt_i4b.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_trace.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_l1.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_isic.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_isac.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_hscx.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/ifpnp/i4b_ifpnp_ext.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_global.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_mbuf.h>
end_include

begin_function_decl
specifier|static
name|u_char
name|ifpnp_isac_exir_hdlr
parameter_list|(
specifier|register
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|exir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ifpnp_isac_ind_hdlr
parameter_list|(
specifier|register
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ind
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*---------------------------------------------------------------------------*  *	ISAC interrupt service routine  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|ifpnp_isac_irq
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ista
parameter_list|)
block|{
specifier|register
name|u_char
name|c
init|=
literal|0
decl_stmt|;
name|NDBGL1
argument_list|(
name|L1_F_MSG
argument_list|,
literal|"unit %d: ista = 0x%02x"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|ista
argument_list|)
expr_stmt|;
if|if
condition|(
name|ista
operator|&
name|ISAC_ISTA_EXI
condition|)
comment|/* extended interrupt */
block|{
name|c
operator||=
name|ifpnp_isac_exir_hdlr
argument_list|(
name|sc
argument_list|,
name|ISAC_READ
argument_list|(
name|I_EXIR
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ista
operator|&
name|ISAC_ISTA_RME
condition|)
comment|/* receive message end */
block|{
specifier|register
name|int
name|rest
decl_stmt|;
name|u_char
name|rsta
decl_stmt|;
comment|/* get rx status register */
name|rsta
operator|=
name|ISAC_READ
argument_list|(
name|I_RSTA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rsta
operator|&
name|ISAC_RSTA_MASK
operator|)
operator|!=
literal|0x20
condition|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|rsta
operator|&
name|ISAC_RSTA_CRC
operator|)
condition|)
comment|/* CRC error */
block|{
name|error
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"unit %d: CRC error"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsta
operator|&
name|ISAC_RSTA_RDO
condition|)
comment|/* ReceiveDataOverflow */
block|{
name|error
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"unit %d: Data Overrun error"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsta
operator|&
name|ISAC_RSTA_RAB
condition|)
comment|/* ReceiveABorted */
block|{
name|error
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"unit %d: Receive Aborted error"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"unit %d: RME unknown error, RSTA = 0x%02x!"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|rsta
argument_list|)
expr_stmt|;
name|i4b_Dfreembuf
argument_list|(
name|sc
operator|->
name|sc_ibuf
argument_list|)
expr_stmt|;
name|c
operator||=
name|ISAC_CMDR_RMC
operator||
name|ISAC_CMDR_RRES
expr_stmt|;
name|sc
operator|->
name|sc_ibuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ib
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_CMDR
argument_list|,
name|ISAC_CMDR_RMC
operator||
name|ISAC_CMDR_RRES
argument_list|)
expr_stmt|;
name|ISACCMDRWRDELAY
argument_list|()
expr_stmt|;
return|return;
block|}
name|rest
operator|=
operator|(
name|ISAC_READ
argument_list|(
name|I_RBCL
argument_list|)
operator|&
operator|(
name|ISAC_FIFO_LEN
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|rest
operator|==
literal|0
condition|)
name|rest
operator|=
name|ISAC_FIFO_LEN
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ibuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ibuf
operator|=
name|i4b_Dgetmbuf
argument_list|(
name|rest
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_ib
operator|=
name|sc
operator|->
name|sc_ibuf
operator|->
name|m_data
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"ifpnp_isac_irq: RME, i4b_Dgetmbuf returns NULL!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|<=
operator|(
name|MAX_DFRAME_LEN
operator|-
name|rest
operator|)
condition|)
block|{
name|ISAC_RDFIFO
argument_list|(
name|sc
operator|->
name|sc_ib
argument_list|,
name|rest
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|+=
name|rest
expr_stmt|;
name|sc
operator|->
name|sc_ibuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|sc
operator|->
name|sc_ibuf
operator|->
name|m_len
operator|=
name|sc
operator|->
name|sc_ilen
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_D_RX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0IFPNPUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
name|TRC_CH_D
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_NT
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_dcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|sc
operator|->
name|sc_ibuf
operator|->
name|m_len
argument_list|,
name|sc
operator|->
name|sc_ibuf
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
name|c
operator||=
name|ISAC_CMDR_RMC
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_enabled
operator|&&
operator|(
name|ctrl_desc
index|[
name|sc
operator|->
name|sc_unit
index|]
operator|.
name|protocol
operator|!=
name|PROTOCOL_D64S
operator|)
condition|)
block|{
name|i4b_l1_ph_data_ind
argument_list|(
name|L0IFPNPUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_ibuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i4b_Dfreembuf
argument_list|(
name|sc
operator|->
name|sc_ibuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"RME, input buffer overflow!"
argument_list|)
expr_stmt|;
name|i4b_Dfreembuf
argument_list|(
name|sc
operator|->
name|sc_ibuf
argument_list|)
expr_stmt|;
name|c
operator||=
name|ISAC_CMDR_RMC
operator||
name|ISAC_CMDR_RRES
expr_stmt|;
block|}
name|sc
operator|->
name|sc_ibuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ib
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ista
operator|&
name|ISAC_ISTA_RPF
condition|)
comment|/* receive fifo full */
block|{
if|if
condition|(
name|sc
operator|->
name|sc_ibuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ibuf
operator|=
name|i4b_Dgetmbuf
argument_list|(
name|MAX_DFRAME_LEN
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_ib
operator|=
name|sc
operator|->
name|sc_ibuf
operator|->
name|m_data
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"ifpnp_isac_irq: RPF, i4b_Dgetmbuf returns NULL!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|<=
operator|(
name|MAX_DFRAME_LEN
operator|-
name|ISAC_FIFO_LEN
operator|)
condition|)
block|{
name|ISAC_RDFIFO
argument_list|(
name|sc
operator|->
name|sc_ib
argument_list|,
name|ISAC_FIFO_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|+=
name|ISAC_FIFO_LEN
expr_stmt|;
name|sc
operator|->
name|sc_ib
operator|+=
name|ISAC_FIFO_LEN
expr_stmt|;
name|c
operator||=
name|ISAC_CMDR_RMC
expr_stmt|;
block|}
else|else
block|{
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"RPF, input buffer overflow!"
argument_list|)
expr_stmt|;
name|i4b_Dfreembuf
argument_list|(
name|sc
operator|->
name|sc_ibuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ibuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ib
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|c
operator||=
name|ISAC_CMDR_RMC
operator||
name|ISAC_CMDR_RRES
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ista
operator|&
name|ISAC_ISTA_XPR
condition|)
comment|/* transmit fifo empty (XPR bit set) */
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_obuf2
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_obuf
operator|==
name|NULL
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_freeflag
operator|=
name|sc
operator|->
name|sc_freeflag2
expr_stmt|;
name|sc
operator|->
name|sc_obuf
operator|=
name|sc
operator|->
name|sc_obuf2
expr_stmt|;
name|sc
operator|->
name|sc_op
operator|=
name|sc
operator|->
name|sc_obuf
operator|->
name|m_data
expr_stmt|;
name|sc
operator|->
name|sc_ol
operator|=
name|sc
operator|->
name|sc_obuf
operator|->
name|m_len
expr_stmt|;
name|sc
operator|->
name|sc_obuf2
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTDEF
name|printf
argument_list|(
literal|"ob2=%x, op=%x, ol=%d, f=%d #"
argument_list|,
name|sc
operator|->
name|sc_obuf
argument_list|,
name|sc
operator|->
name|sc_op
argument_list|,
name|sc
operator|->
name|sc_ol
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NOTDEF
name|printf
argument_list|(
literal|"ob=%x, op=%x, ol=%d, f=%d #"
argument_list|,
name|sc
operator|->
name|sc_obuf
argument_list|,
name|sc
operator|->
name|sc_op
argument_list|,
name|sc
operator|->
name|sc_ol
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|sc
operator|->
name|sc_obuf
condition|)
block|{
name|ISAC_WRFIFO
argument_list|(
name|sc
operator|->
name|sc_op
argument_list|,
name|min
argument_list|(
name|sc
operator|->
name|sc_ol
argument_list|,
name|ISAC_FIFO_LEN
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ol
operator|>
name|ISAC_FIFO_LEN
condition|)
comment|/* length> 32 ? */
block|{
name|sc
operator|->
name|sc_op
operator|+=
name|ISAC_FIFO_LEN
expr_stmt|;
comment|/* bufferptr+32 */
name|sc
operator|->
name|sc_ol
operator|-=
name|ISAC_FIFO_LEN
expr_stmt|;
comment|/* length - 32 */
name|c
operator||=
name|ISAC_CMDR_XTF
expr_stmt|;
comment|/* set XTF bit */
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_freeflag
condition|)
block|{
name|i4b_Dfreembuf
argument_list|(
name|sc
operator|->
name|sc_obuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_freeflag
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|sc_obuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_op
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ol
operator|=
literal|0
expr_stmt|;
name|c
operator||=
name|ISAC_CMDR_XTF
operator||
name|ISAC_CMDR_XME
expr_stmt|;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|ISAC_TX_ACTIVE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ista
operator|&
name|ISAC_ISTA_CISQ
condition|)
comment|/* channel status change CISQ */
block|{
specifier|register
name|u_char
name|ci
decl_stmt|;
comment|/* get command/indication rx register*/
name|ci
operator|=
name|ISAC_READ
argument_list|(
name|I_CIRR
argument_list|)
expr_stmt|;
comment|/* if S/Q IRQ, read SQC reg to clr SQC IRQ */
if|if
condition|(
name|ci
operator|&
name|ISAC_CIRR_SQC
condition|)
operator|(
name|void
operator|)
name|ISAC_READ
argument_list|(
name|I_SQRR
argument_list|)
expr_stmt|;
comment|/* C/I code change IRQ (flag already cleared by CIRR read) */
if|if
condition|(
name|ci
operator|&
name|ISAC_CIRR_CIC0
condition|)
name|ifpnp_isac_ind_hdlr
argument_list|(
name|sc
argument_list|,
operator|(
name|ci
operator|>>
literal|2
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
condition|)
block|{
name|ISAC_WRITE
argument_list|(
name|I_CMDR
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ISACCMDRWRDELAY
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	ISAC L1 Extended IRQ handler  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|u_char
name|ifpnp_isac_exir_hdlr
parameter_list|(
specifier|register
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|exir
parameter_list|)
block|{
name|u_char
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exir
operator|&
name|ISAC_EXIR_XMR
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"EXIRQ Tx Message Repeat"
argument_list|)
expr_stmt|;
name|c
operator||=
name|ISAC_CMDR_XRES
expr_stmt|;
block|}
if|if
condition|(
name|exir
operator|&
name|ISAC_EXIR_XDU
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"EXIRQ Tx Data Underrun"
argument_list|)
expr_stmt|;
name|c
operator||=
name|ISAC_CMDR_XRES
expr_stmt|;
block|}
if|if
condition|(
name|exir
operator|&
name|ISAC_EXIR_PCE
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"EXIRQ Protocol Error"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exir
operator|&
name|ISAC_EXIR_RFO
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"EXIRQ Rx Frame Overflow"
argument_list|)
expr_stmt|;
name|c
operator||=
name|ISAC_CMDR_RMC
operator||
name|ISAC_CMDR_RRES
expr_stmt|;
block|}
if|if
condition|(
name|exir
operator|&
name|ISAC_EXIR_SOV
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"EXIRQ Sync Xfer Overflow"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exir
operator|&
name|ISAC_EXIR_MOS
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"EXIRQ Monitor Status"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exir
operator|&
name|ISAC_EXIR_SAW
condition|)
block|{
comment|/* cannot happen, STCR:TSF is set to 0 */
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"EXIRQ Subscriber Awake"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exir
operator|&
name|ISAC_EXIR_WOV
condition|)
block|{
comment|/* cannot happen, STCR:TSF is set to 0 */
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"EXIRQ Watchdog Timer Overflow"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	ISAC L1 Indication handler  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ifpnp_isac_ind_hdlr
parameter_list|(
specifier|register
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ind
parameter_list|)
block|{
specifier|register
name|int
name|event
decl_stmt|;
switch|switch
condition|(
name|ind
condition|)
block|{
case|case
name|ISAC_CIRR_IAI8
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx AI8 in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bustyp
operator|==
name|BUS_TYPE_IOM2
condition|)
name|ifpnp_isac_l1_cmd
argument_list|(
name|sc
argument_list|,
name|CMD_AR8
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO48
expr_stmt|;
name|i4b_l1_mph_status_ind
argument_list|(
name|L0IFPNPUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
argument_list|,
name|STI_L1STAT
argument_list|,
name|LAYER_ACTIVE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISAC_CIRR_IAI10
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx AI10 in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bustyp
operator|==
name|BUS_TYPE_IOM2
condition|)
name|ifpnp_isac_l1_cmd
argument_list|(
name|sc
argument_list|,
name|CMD_AR10
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO410
expr_stmt|;
name|i4b_l1_mph_status_ind
argument_list|(
name|L0IFPNPUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
argument_list|,
name|STI_L1STAT
argument_list|,
name|LAYER_ACTIVE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISAC_CIRR_IRSY
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx RSY in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_RSY
expr_stmt|;
break|break;
case|case
name|ISAC_CIRR_IPU
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx PU in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_PU
expr_stmt|;
break|break;
case|case
name|ISAC_CIRR_IDR
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx DR in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|ifpnp_isac_l1_cmd
argument_list|(
name|sc
argument_list|,
name|CMD_DIU
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_DR
expr_stmt|;
break|break;
case|case
name|ISAC_CIRR_IDID
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx DID in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO0
expr_stmt|;
name|i4b_l1_mph_status_ind
argument_list|(
name|L0IFPNPUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
argument_list|,
name|STI_L1STAT
argument_list|,
name|LAYER_IDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISAC_CIRR_IDIS
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx DIS in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_DIS
expr_stmt|;
break|break;
case|case
name|ISAC_CIRR_IEI
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx EI in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|ifpnp_isac_l1_cmd
argument_list|(
name|sc
argument_list|,
name|CMD_DIU
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_EI
expr_stmt|;
break|break;
case|case
name|ISAC_CIRR_IARD
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx ARD in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO2
expr_stmt|;
break|break;
case|case
name|ISAC_CIRR_ITI
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx TI in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO0
expr_stmt|;
break|break;
case|case
name|ISAC_CIRR_IATI
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx ATI in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO0
expr_stmt|;
break|break;
case|case
name|ISAC_CIRR_ISD
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"rx SD in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO0
expr_stmt|;
break|break;
default|default:
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"UNKNOWN Indication 0x%x in state %s"
argument_list|,
name|ind
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|EV_INFO0
expr_stmt|;
break|break;
block|}
name|ifpnp_next_state
argument_list|(
name|sc
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	execute a layer 1 command  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|ifpnp_isac_l1_cmd
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|command
parameter_list|)
block|{
name|u_char
name|cmd
decl_stmt|;
ifdef|#
directive|ifdef
name|I4B_SMP_WORKAROUND
comment|/* XXXXXXXXXXXXXXXXXXX */
comment|/* 	 * patch from Wolfgang Helbig: 	 * 	 * Here is a patch that makes i4b work on an SMP: 	 * The card (TELES 16.3) didn't interrupt on an SMP machine. 	 * This is a gross workaround, but anyway it works *and* provides 	 * some information as how to finally fix this problem. 	 */
name|HSCX_WRITE
argument_list|(
literal|0
argument_list|,
name|H_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|HSCX_WRITE
argument_list|(
literal|1
argument_list|,
name|H_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|HSCX_WRITE
argument_list|(
literal|0
argument_list|,
name|H_MASK
argument_list|,
name|HSCX_A_IMASK
argument_list|)
expr_stmt|;
name|HSCX_WRITE
argument_list|(
literal|1
argument_list|,
name|H_MASK
argument_list|,
name|HSCX_B_IMASK
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
name|ISAC_IMASK
argument_list|)
expr_stmt|;
comment|/* XXXXXXXXXXXXXXXXXXX */
endif|#
directive|endif
comment|/* I4B_SMP_WORKAROUND */
if|if
condition|(
name|command
operator|<
literal|0
operator|||
name|command
operator|>
name|CMD_ILL
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_I_ERR
argument_list|,
literal|"illegal cmd 0x%x in state %s"
argument_list|,
name|command
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bustyp
operator|==
name|BUS_TYPE_IOM2
condition|)
name|cmd
operator|=
name|ISAC_CIX0_LOW
expr_stmt|;
else|else
name|cmd
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|CMD_TIM
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"tx TIM in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator||=
operator|(
name|ISAC_CIXR_CTIM
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
case|case
name|CMD_RS
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"tx RS in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator||=
operator|(
name|ISAC_CIXR_CRS
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
case|case
name|CMD_AR8
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"tx AR8 in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator||=
operator|(
name|ISAC_CIXR_CAR8
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
case|case
name|CMD_AR10
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"tx AR10 in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator||=
operator|(
name|ISAC_CIXR_CAR10
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
case|case
name|CMD_DIU
case|:
name|NDBGL1
argument_list|(
name|L1_I_CICO
argument_list|,
literal|"tx DIU in state %s"
argument_list|,
name|ifpnp_printstate
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator||=
operator|(
name|ISAC_CIXR_CDIU
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
block|}
name|ISAC_WRITE
argument_list|(
name|I_CIXR
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	L1 ISAC initialization  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|ifpnp_isac_init
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ISAC_IMASK
operator|=
literal|0xff
expr_stmt|;
comment|/* disable all irqs */
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
name|ISAC_IMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bustyp
operator|!=
name|BUS_TYPE_IOM2
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_I_SETUP
argument_list|,
literal|"configuring for IOM-1 mode"
argument_list|)
expr_stmt|;
comment|/* ADF2: Select mode IOM-1 */
name|ISAC_WRITE
argument_list|(
name|I_ADF2
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* SPCR: serial port control register: 		 *	SPU - software power up = 0 		 *	SAC - SIP port high Z 		 *	SPM - timing mode 0 		 *	TLP - test loop = 0 		 *	C1C, C2C - B1 and B2 switched to/from SPa 		 */
name|ISAC_WRITE
argument_list|(
name|I_SPCR
argument_list|,
name|ISAC_SPCR_C1C1
operator||
name|ISAC_SPCR_C2C1
argument_list|)
expr_stmt|;
comment|/* SQXR: S/Q channel xmit register:                  *	SQIE - S/Q IRQ enable = 0 		 *	SQX1-4 - Fa bits = 1 		 */
name|ISAC_WRITE
argument_list|(
name|I_SQXR
argument_list|,
name|ISAC_SQXR_SQX1
operator||
name|ISAC_SQXR_SQX2
operator||
name|ISAC_SQXR_SQX3
operator||
name|ISAC_SQXR_SQX4
argument_list|)
expr_stmt|;
comment|/* ADF1: additional feature reg 1: 		 *	WTC - watchdog = 0 		 *	TEM - test mode = 0 		 *	PFS - pre-filter = 0 		 *	CFS - IOM clock/frame always active 		 *	FSC1/2 - polarity of 8kHz strobe 		 *	ITF - interframe fill = idle 		 */
name|ISAC_WRITE
argument_list|(
name|I_ADF1
argument_list|,
name|ISAC_ADF1_FC2
argument_list|)
expr_stmt|;
comment|/* ADF1 */
comment|/* STCR: sync transfer control reg: 		 *	TSF - terminal secific functions = 0 		 *	TBA - TIC bus address = 7 		 *	STx/SCx = 0 		 */
name|ISAC_WRITE
argument_list|(
name|I_STCR
argument_list|,
name|ISAC_STCR_TBA2
operator||
name|ISAC_STCR_TBA1
operator||
name|ISAC_STCR_TBA0
argument_list|)
expr_stmt|;
comment|/* MODE: Mode Register: 		 *	MDSx - transparent mode 2 		 *	TMD  - timer mode = external 		 *	RAC  - Receiver enabled 		 *	DIMx - digital i/f mode 		 */
name|ISAC_WRITE
argument_list|(
name|I_MODE
argument_list|,
name|ISAC_MODE_MDS2
operator||
name|ISAC_MODE_MDS1
operator||
name|ISAC_MODE_RAC
operator||
name|ISAC_MODE_DIM0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NDBGL1
argument_list|(
name|L1_I_SETUP
argument_list|,
literal|"configuring for IOM-2 mode"
argument_list|)
expr_stmt|;
comment|/* ADF2: Select mode IOM-2 */
name|ISAC_WRITE
argument_list|(
name|I_ADF2
argument_list|,
name|ISAC_ADF2_IMS
argument_list|)
expr_stmt|;
comment|/* SPCR: serial port control register: 		 *	SPU - software power up = 0 		 *	SPM - timing mode 0 		 *	TLP - test loop = 0 		 *	C1C, C2C - B1 + C1 and B2 + IC2 monitoring 		 */
name|ISAC_WRITE
argument_list|(
name|I_SPCR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* SQXR: S/Q channel xmit register: 		 *	IDC  - IOM direction = 0 (master) 		 *	CFS  - Config Select = 0 (clock always active) 		 *	CI1E - C/I channel 1 IRQ enable = 0                  *	SQIE - S/Q IRQ enable = 0 		 *	SQX1-4 - Fa bits = 1 		 */
name|ISAC_WRITE
argument_list|(
name|I_SQXR
argument_list|,
name|ISAC_SQXR_SQX1
operator||
name|ISAC_SQXR_SQX2
operator||
name|ISAC_SQXR_SQX3
operator||
name|ISAC_SQXR_SQX4
argument_list|)
expr_stmt|;
comment|/* ADF1: additional feature reg 1: 		 *	WTC - watchdog = 0 		 *	TEM - test mode = 0 		 *	PFS - pre-filter = 0 		 *	IOF - IOM i/f off = 0 		 *	ITF - interframe fill = idle 		 */
name|ISAC_WRITE
argument_list|(
name|I_ADF1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* STCR: sync transfer control reg: 		 *	TSF - terminal secific functions = 0 		 *	TBA - TIC bus address = 7 		 *	STx/SCx = 0 		 */
name|ISAC_WRITE
argument_list|(
name|I_STCR
argument_list|,
name|ISAC_STCR_TBA2
operator||
name|ISAC_STCR_TBA1
operator||
name|ISAC_STCR_TBA0
argument_list|)
expr_stmt|;
comment|/* MODE: Mode Register: 		 *	MDSx - transparent mode 2 		 *	TMD  - timer mode = external 		 *	RAC  - Receiver enabled 		 *	DIMx - digital i/f mode 		 */
name|ISAC_WRITE
argument_list|(
name|I_MODE
argument_list|,
name|ISAC_MODE_MDS2
operator||
name|ISAC_MODE_MDS1
operator||
name|ISAC_MODE_RAC
operator||
name|ISAC_MODE_DIM0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOTDEF
comment|/* 	 * XXX a transmitter reset causes an ISAC tx IRQ which will not 	 * be serviced at attach time under some circumstances leaving 	 * the associated IRQ line on the ISA bus active. This prevents 	 * any further interrupts to be serviced because no low -> high 	 * transition can take place anymore. (-hm) 	 */
comment|/* command register: 	 *	RRES - HDLC receiver reset 	 *	XRES - transmitter reset 	 */
name|ISAC_WRITE
argument_list|(
name|I_CMDR
argument_list|,
name|ISAC_CMDR_RRES
operator||
name|ISAC_CMDR_XRES
argument_list|)
expr_stmt|;
name|ISACCMDRWRDELAY
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* enabled interrupts: 	 * =================== 	 * RME  - receive message end 	 * RPF  - receive pool full 	 * XPR  - transmit pool ready 	 * CISQ - CI or S/Q channel change 	 * EXI  - extended interrupt 	 */
name|ISAC_IMASK
operator|=
name|ISAC_MASK_RSC
operator||
comment|/* auto mode only	*/
name|ISAC_MASK_TIN
operator||
comment|/* timer irq		*/
name|ISAC_MASK_SIN
expr_stmt|;
comment|/* sync xfer irq	*/
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
name|ISAC_IMASK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NIFPNP> 0 */
end_comment

end_unit

