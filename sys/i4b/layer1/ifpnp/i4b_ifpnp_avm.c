begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   Copyright (c) 1999, 2000 Udo Schweigert. All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *   3. Neither the name of the author nor the names of any co-contributors  *      may be used to endorse or promote products derived from this software  *      without specific prior written permission.  *   4. Altered versions must be plainly marked as such, and must not be  *      misrepresented as being the original software and/or documentation.  *     *   THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  *   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  *   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  *   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  *   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  *   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  *   SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	i4b_ifpnp_avm.c: AVM Fritz!Card PnP hardware driver  *	---------------------------------------------------  *  *	$Id: i4b_ifpnp_avm.c,v 1.3 2000/05/29 15:41:41 hm Exp $  *	$Ust: src/i4b/layer1-nb/ifpnp/i4b_ifpnp_avm.c,v 1.6 2000/04/18 08:32:32 ust Exp $  *  * $FreeBSD$  *  *      last edit-date: [Mon May 29 15:24:43 2000]  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"ifpnp.h"
end_include

begin_include
include|#
directive|include
file|"opt_i4b.h"
end_include

begin_if
if|#
directive|if
operator|(
name|NIFPNP
operator|>
literal|0
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_trace.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_global.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_l1.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_isic.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_isac.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_hscx.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/ifpnp/i4b_ifpnp_ext.h>
end_include

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|avm_pnp_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hscx_write_reg
parameter_list|(
name|int
parameter_list|,
name|u_int
parameter_list|,
name|struct
name|l1_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hscx_write_reg_val
parameter_list|(
name|int
parameter_list|,
name|u_int
parameter_list|,
name|u_int8_t
parameter_list|,
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|hscx_read_reg
parameter_list|(
name|int
parameter_list|,
name|u_int
parameter_list|,
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hscx_read_fifo
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hscx_write_fifo
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avm_pnp_hscx_int_handler
parameter_list|(
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avm_pnp_hscx_intr
parameter_list|(
name|int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avm_pnp_init_linktab
parameter_list|(
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avm_pnp_bchannel_setup
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avm_pnp_bchannel_start
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avm_pnp_hscx_init
parameter_list|(
name|struct
name|l1_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avm_pnp_bchannel_stat
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|bchan_statistics_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avm_pnp_set_linktab
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|drvr_link_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isdn_link_t
modifier|*
name|avm_pnp_ret_linktab
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|avm_pnp_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|avm_pnp_hscx_fifo
parameter_list|(
name|l1_bchan_state_t
modifier|*
parameter_list|,
name|struct
name|l1_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|avm_pnp_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ifpnp_isac_intr
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|avm_pnp_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|avm_pnp_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|avm_pnp_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|avm_pnp_driver
init|=
block|{
literal|"ifpnp"
block|,
name|avm_pnp_methods
block|,
expr|sizeof
operator|(
expr|struct
name|l1_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|avm_pnp_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|avm_pnp
argument_list|,
name|isa
argument_list|,
name|avm_pnp_driver
argument_list|,
name|avm_pnp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* jump table for multiplex routines */
end_comment

begin_decl_stmt
name|struct
name|i4b_l1mux_func
name|avm_pnp_l1mux_func
init|=
block|{
name|avm_pnp_ret_linktab
block|,
name|avm_pnp_set_linktab
block|,
name|ifpnp_mph_command_req
block|,
name|ifpnp_ph_data_req
block|,
name|ifpnp_ph_activate_req
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|l1_softc
modifier|*
name|ifpnp_scp
index|[
name|IFPNP_MAXUNIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*---------------------------------------------------------------------------*  *	AVM PnP Fritz!Card special registers  *---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  *	register offsets from i/o base  */
end_comment

begin_define
define|#
directive|define
name|CLASS_OFFSET
value|0x00
end_define

begin_define
define|#
directive|define
name|REVISION_OFFSET
value|0x01
end_define

begin_define
define|#
directive|define
name|STAT0_OFFSET
value|0x02
end_define

begin_define
define|#
directive|define
name|STAT1_OFFSET
value|0x03
end_define

begin_define
define|#
directive|define
name|ADDR_REG_OFFSET
value|0x04
end_define

begin_comment
comment|/*#define MODREG_OFFSET		0x06 #define VERREG_OFFSET           0x07*/
end_comment

begin_comment
comment|/* these 2 are used to select an ISAC register set */
end_comment

begin_define
define|#
directive|define
name|ISAC_LO_REG_OFFSET
value|0x04
end_define

begin_define
define|#
directive|define
name|ISAC_HI_REG_OFFSET
value|0x06
end_define

begin_comment
comment|/* offset higher than this goes to the HI register set */
end_comment

begin_define
define|#
directive|define
name|MAX_LO_REG_OFFSET
value|0x2f
end_define

begin_comment
comment|/* mask for the offset */
end_comment

begin_define
define|#
directive|define
name|ISAC_REGSET_MASK
value|0x0f
end_define

begin_comment
comment|/* the offset from the base to the ISAC registers */
end_comment

begin_define
define|#
directive|define
name|ISAC_REG_OFFSET
value|0x10
end_define

begin_comment
comment|/* the offset from the base to the ISAC FIFO */
end_comment

begin_define
define|#
directive|define
name|ISAC_FIFO
value|0x02
end_define

begin_comment
comment|/* not really the HSCX, but sort of */
end_comment

begin_define
define|#
directive|define
name|HSCX_FIFO
value|0x00
end_define

begin_define
define|#
directive|define
name|HSCX_STAT
value|0x04
end_define

begin_comment
comment|/*  *	AVM PnP Status Latch 0 read only bits  */
end_comment

begin_define
define|#
directive|define
name|ASL_IRQ_ISAC
value|0x01
end_define

begin_comment
comment|/* ISAC  interrupt, active low */
end_comment

begin_define
define|#
directive|define
name|ASL_IRQ_HSCX
value|0x02
end_define

begin_comment
comment|/* HSX   interrupt, active low */
end_comment

begin_define
define|#
directive|define
name|ASL_IRQ_TIMER
value|0x04
end_define

begin_comment
comment|/* Timer interrupt, active low */
end_comment

begin_define
define|#
directive|define
name|ASL_IRQ_BCHAN
value|ASL_IRQ_HSCX
end_define

begin_comment
comment|/* actually active LOW */
end_comment

begin_define
define|#
directive|define
name|ASL_IRQ_Pending
value|(ASL_IRQ_ISAC | ASL_IRQ_HSCX | ASL_IRQ_TIMER)
end_define

begin_comment
comment|/*  *	AVM Status Latch 0 write only bits  */
end_comment

begin_define
define|#
directive|define
name|ASL_RESET_ALL
value|0x01
end_define

begin_comment
comment|/* reset siemens IC's, active 1 */
end_comment

begin_define
define|#
directive|define
name|ASL_TIMERDISABLE
value|0x02
end_define

begin_comment
comment|/* active high */
end_comment

begin_define
define|#
directive|define
name|ASL_TIMERRESET
value|0x04
end_define

begin_comment
comment|/* active high */
end_comment

begin_define
define|#
directive|define
name|ASL_ENABLE_INT
value|0x08
end_define

begin_comment
comment|/* active high */
end_comment

begin_define
define|#
directive|define
name|ASL_TESTBIT
value|0x10
end_define

begin_comment
comment|/* active high */
end_comment

begin_comment
comment|/*  *	AVM Status Latch 1 write only bits  */
end_comment

begin_define
define|#
directive|define
name|ASL1_INTSEL
value|0x0f
end_define

begin_comment
comment|/* active high */
end_comment

begin_define
define|#
directive|define
name|ASL1_ENABLE_IOM
value|0x80
end_define

begin_comment
comment|/* active high */
end_comment

begin_comment
comment|/*  * "HSCX" mode bits  */
end_comment

begin_define
define|#
directive|define
name|HSCX_MODE_ITF_FLG
value|0x01
end_define

begin_define
define|#
directive|define
name|HSCX_MODE_TRANS
value|0x02
end_define

begin_define
define|#
directive|define
name|HSCX_MODE_CCR_7
value|0x04
end_define

begin_define
define|#
directive|define
name|HSCX_MODE_CCR_16
value|0x08
end_define

begin_define
define|#
directive|define
name|HSCX_MODE_TESTLOOP
value|0x80
end_define

begin_comment
comment|/*  * "HSCX" status bits  */
end_comment

begin_define
define|#
directive|define
name|HSCX_STAT_RME
value|0x01
end_define

begin_define
define|#
directive|define
name|HSCX_STAT_RDO
value|0x10
end_define

begin_define
define|#
directive|define
name|HSCX_STAT_CRCVFRRAB
value|0x0E
end_define

begin_define
define|#
directive|define
name|HSCX_STAT_CRCVFR
value|0x06
end_define

begin_define
define|#
directive|define
name|HSCX_STAT_RML_MASK
value|0x3f00
end_define

begin_comment
comment|/*  * "HSCX" interrupt bits  */
end_comment

begin_define
define|#
directive|define
name|HSCX_INT_XPR
value|0x80
end_define

begin_define
define|#
directive|define
name|HSCX_INT_XDU
value|0x40
end_define

begin_define
define|#
directive|define
name|HSCX_INT_RPR
value|0x20
end_define

begin_define
define|#
directive|define
name|HSCX_INT_MASK
value|0xE0
end_define

begin_comment
comment|/*  * "HSCX" command bits  */
end_comment

begin_define
define|#
directive|define
name|HSCX_CMD_XRS
value|0x80
end_define

begin_define
define|#
directive|define
name|HSCX_CMD_XME
value|0x01
end_define

begin_define
define|#
directive|define
name|HSCX_CMD_RRS
value|0x20
end_define

begin_define
define|#
directive|define
name|HSCX_CMD_XML_MASK
value|0x3f00
end_define

begin_comment
comment|/*  * to prevent deactivating the "HSCX" when both channels are active we  * define an HSCX_ACTIVE flag which is or'd into the channel's state  * flag in avm_pnp_bchannel_setup upon active and cleared upon deactivation.  * It is set high to allow room for new flags.  */
end_comment

begin_define
define|#
directive|define
name|HSCX_AVMA1PP_ACTIVE
value|0x1000
end_define

begin_comment
comment|/*---------------------------------------------------------------------------*  *	AVM read fifo routines  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|avm_pnp_read_fifo
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ADDR_REG_OFFSET
argument_list|,
name|ISAC_FIFO
argument_list|)
expr_stmt|;
name|bus_space_read_multi_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISAC_REG_OFFSET
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|hscx_read_fifo
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|hscx_read_fifo
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hscx_read_fifo
parameter_list|(
name|int
name|chan
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|ip
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ADDR_REG_OFFSET
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cnt
operator|++
operator|<
name|len
condition|)
block|{
operator|*
name|ip
operator|++
operator|=
name|bus_space_read_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISAC_REG_OFFSET
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	AVM write fifo routines  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|avm_pnp_write_fifo
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ADDR_REG_OFFSET
argument_list|,
name|ISAC_FIFO
argument_list|)
expr_stmt|;
name|bus_space_write_multi_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISAC_REG_OFFSET
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|hscx_write_fifo
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|hscx_write_fifo
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hscx_write_fifo
parameter_list|(
name|int
name|chan
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|ip
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|l1_bchan_state_t
modifier|*
name|Bchan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|chan
index|]
decl_stmt|;
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|&=
operator|~
name|HSCX_CMD_XME
expr_stmt|;
name|sc
operator|->
name|avma1pp_txl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Bchan
operator|->
name|out_mbuf_cur
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|Bchan
operator|->
name|bprot
operator|!=
name|BPROT_NONE
condition|)
name|sc
operator|->
name|avma1pp_cmd
operator||=
name|HSCX_CMD_XME
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
name|sc
operator|->
name|sc_bfifolen
condition|)
name|sc
operator|->
name|avma1pp_txl
operator|=
name|len
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cnt
operator|++
operator|<
name|len
condition|)
block|{
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISAC_REG_OFFSET
argument_list|,
operator|*
name|ip
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	AVM write register routines  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|avm_pnp_write_reg
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|u_char
name|reg_bank
decl_stmt|;
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|reg_bank
operator|=
operator|(
name|offs
operator|>
name|MAX_LO_REG_OFFSET
operator|)
condition|?
name|ISAC_HI_REG_OFFSET
else|:
name|ISAC_LO_REG_OFFSET
expr_stmt|;
comment|/* set the register bank */
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ADDR_REG_OFFSET
argument_list|,
name|reg_bank
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISAC_REG_OFFSET
operator|+
operator|(
name|offs
operator|&
name|ISAC_REGSET_MASK
operator|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|hscx_write_reg_val
argument_list|(
literal|0
argument_list|,
name|offs
argument_list|,
name|data
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|hscx_write_reg_val
argument_list|(
literal|1
argument_list|,
name|offs
argument_list|,
name|data
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hscx_write_reg
parameter_list|(
name|int
name|chan
parameter_list|,
name|u_int
name|off
parameter_list|,
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|which
parameter_list|)
block|{
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* point at the correct channel */
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ADDR_REG_OFFSET
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|which
operator|&
literal|4
condition|)
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISAC_REG_OFFSET
operator|+
name|off
operator|+
literal|2
argument_list|,
name|sc
operator|->
name|avma1pp_prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|which
operator|&
literal|2
condition|)
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISAC_REG_OFFSET
operator|+
name|off
operator|+
literal|1
argument_list|,
name|sc
operator|->
name|avma1pp_txl
argument_list|)
expr_stmt|;
if|if
condition|(
name|which
operator|&
literal|1
condition|)
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISAC_REG_OFFSET
operator|+
name|off
argument_list|,
name|sc
operator|->
name|avma1pp_cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hscx_write_reg_val
parameter_list|(
name|int
name|chan
parameter_list|,
name|u_int
name|off
parameter_list|,
name|u_int8_t
name|val
parameter_list|,
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* point at the correct channel */
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ADDR_REG_OFFSET
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISAC_REG_OFFSET
operator|+
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	AVM read register routines  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|u_int8_t
name|avm_pnp_read_reg
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|)
block|{
name|u_char
name|reg_bank
decl_stmt|;
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|reg_bank
operator|=
operator|(
name|offs
operator|>
name|MAX_LO_REG_OFFSET
operator|)
condition|?
name|ISAC_HI_REG_OFFSET
else|:
name|ISAC_LO_REG_OFFSET
expr_stmt|;
comment|/* set the register bank */
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ADDR_REG_OFFSET
argument_list|,
name|reg_bank
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_space_read_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISAC_REG_OFFSET
operator|+
operator|(
name|offs
operator|&
name|ISAC_REGSET_MASK
operator|)
argument_list|)
operator|)
return|;
case|case
name|ISIC_WHAT_HSCXA
case|:
return|return
name|hscx_read_reg
argument_list|(
literal|0
argument_list|,
name|offs
argument_list|,
name|sc
argument_list|)
return|;
case|case
name|ISIC_WHAT_HSCXB
case|:
return|return
name|hscx_read_reg
argument_list|(
literal|1
argument_list|,
name|offs
argument_list|,
name|sc
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|hscx_read_reg
parameter_list|(
name|int
name|chan
parameter_list|,
name|u_int
name|off
parameter_list|,
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_space_handle_t
name|bhandle
init|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|btag
init|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* point at the correct channel */
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ADDR_REG_OFFSET
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_space_read_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|ISAC_REG_OFFSET
operator|+
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|ifpnp_ids
block|{
name|u_long
name|vend_id
decl_stmt|;
name|char
modifier|*
name|id_str
decl_stmt|;
block|}
name|ifpnp_ids
index|[]
init|=
block|{
block|{
literal|0x0009cd06
block|,
literal|"AVM Fritz!Card PnP"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*---------------------------------------------------------------------------*  *	avm_pnp_probe - probe for a card  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|avm_pnp_probe
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|ifpnp_ids
modifier|*
name|ids
decl_stmt|;
comment|/* pnp id's */
name|char
modifier|*
name|string
init|=
name|NULL
decl_stmt|;
comment|/* the name */
name|u_int32_t
name|vend_id
init|=
name|isa_get_vendorid
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* vendor id */
comment|/* search table of knowd id's */
for|for
control|(
name|ids
operator|=
name|ifpnp_ids
init|;
name|ids
operator|->
name|vend_id
operator|!=
literal|0
condition|;
name|ids
operator|++
control|)
block|{
if|if
condition|(
name|vend_id
operator|==
name|ids
operator|->
name|vend_id
condition|)
block|{
name|string
operator|=
name|ids
operator|->
name|id_str
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|string
condition|)
comment|/* set name if we have one */
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|string
argument_list|)
expr_stmt|;
comment|/* set description */
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|ENXIO
return|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	avm_pnp_attach - attach Fritz!Card PnP  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|avm_pnp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|l1_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|v
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_int16_t
name|vid
decl_stmt|;
name|void
modifier|*
name|ih
init|=
literal|0
decl_stmt|;
name|bus_space_handle_t
name|bhandle
decl_stmt|;
name|bus_space_tag_t
name|btag
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|vid
operator|=
name|isa_get_vendorid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|l1_softc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* probably not really required */
if|if
condition|(
name|unit
operator|>
name|IFPNP_MAXUNIT
condition|)
block|{
name|printf
argument_list|(
literal|"avm_pnp%d: Error, unit> IFPNP_MAXUNIT!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ifpnp_scp
index|[
name|unit
index|]
operator|=
name|sc
expr_stmt|;
comment|/* get io_base */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|sc_resources
operator|.
name|io_rid
index|[
literal|0
index|]
argument_list|,
literal|0UL
argument_list|,
operator|~
literal|0UL
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"avm_pnp_attach: Couldn't get my io_base.\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"avm_pnp%d: couldn't map IO port\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* will not be used for pnp devices */
name|sc
operator|->
name|sc_port
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* get irq, release io_base if we don't get it */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_resources
operator|.
name|irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|sc_resources
operator|.
name|irq_rid
argument_list|,
literal|0UL
argument_list|,
operator|~
literal|0UL
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"avm_pnp%d: Could not get irq.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* not needed */
name|sc
operator|->
name|sc_irq
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|irq
argument_list|)
expr_stmt|;
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_resources
operator|.
name|irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|avm_pnp_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|ih
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_unit
operator|=
name|unit
expr_stmt|;
comment|/* end of new-bus stuff */
name|ISAC_BASE
operator|=
operator|(
name|caddr_t
operator|)
name|ISIC_WHAT_ISAC
expr_stmt|;
name|HSCX_A_BASE
operator|=
operator|(
name|caddr_t
operator|)
name|ISIC_WHAT_HSCXA
expr_stmt|;
name|HSCX_B_BASE
operator|=
operator|(
name|caddr_t
operator|)
name|ISIC_WHAT_HSCXB
expr_stmt|;
comment|/* setup access routines */
name|sc
operator|->
name|clearirq
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|readreg
operator|=
name|avm_pnp_read_reg
expr_stmt|;
name|sc
operator|->
name|writereg
operator|=
name|avm_pnp_write_reg
expr_stmt|;
name|sc
operator|->
name|readfifo
operator|=
name|avm_pnp_read_fifo
expr_stmt|;
name|sc
operator|->
name|writefifo
operator|=
name|avm_pnp_write_fifo
expr_stmt|;
comment|/* setup card type */
name|sc
operator|->
name|sc_cardtyp
operator|=
name|CARD_TYPEP_AVM_PNP
expr_stmt|;
comment|/* setup IOM bus type */
name|sc
operator|->
name|sc_bustyp
operator|=
name|BUS_TYPE_IOM2
expr_stmt|;
comment|/* set up some other miscellaneous things */
name|sc
operator|->
name|sc_ipac
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bfifolen
operator|=
name|HSCX_FIFO_LEN
expr_stmt|;
comment|/* reset the card */
comment|/* the Linux driver does this to clear any pending ISAC interrupts */
name|v
operator|=
literal|0
expr_stmt|;
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_STAR
argument_list|)
expr_stmt|;
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_MODE
argument_list|)
expr_stmt|;
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_ADF2
argument_list|)
expr_stmt|;
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_ISTA
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|ISAC_ISTA_EXI
condition|)
block|{
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_EXIR
argument_list|)
expr_stmt|;
block|}
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_CIRR
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* the Linux driver does this to clear any pending HSCX interrupts */
name|v
operator|=
name|hscx_read_reg
argument_list|(
literal|0
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|v
operator|=
name|hscx_read_reg
argument_list|(
literal|1
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|STAT0_OFFSET
argument_list|,
name|ASL_RESET_ALL
operator||
name|ASL_TIMERDISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* 10 ms */
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|STAT1_OFFSET
argument_list|,
name|ASL1_ENABLE_IOM
operator||
name|sc
operator|->
name|sc_irq
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* 10 ms */
name|bus_space_write_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|STAT0_OFFSET
argument_list|,
name|ASL_TIMERRESET
operator||
name|ASL_ENABLE_INT
operator||
name|ASL_TIMERDISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* 10 ms */
name|printf
argument_list|(
literal|"ifpnp%d: AVM Fritz!Card PnP Class %#x Revision %d \n"
argument_list|,
name|unit
argument_list|,
name|bus_space_read_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|CLASS_OFFSET
argument_list|)
argument_list|,
name|bus_space_read_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|REVISION_OFFSET
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ifpnp%d: ISAC %s (IOM-%c)\n"
argument_list|,
name|unit
argument_list|,
literal|"2085 Version A1/A2 or 2086/2186 Version 1.1"
argument_list|,
name|sc
operator|->
name|sc_bustyp
operator|==
name|BUS_TYPE_IOM1
condition|?
literal|'1'
else|:
literal|'2'
argument_list|)
expr_stmt|;
comment|/* init the ISAC */
name|ifpnp_isac_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* init the "HSCX" */
name|avm_pnp_bchannel_setup
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
name|HSCX_CH_A
argument_list|,
name|BPROT_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|avm_pnp_bchannel_setup
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
name|HSCX_CH_B
argument_list|,
name|BPROT_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* can't use the normal B-Channel stuff */
name|avm_pnp_init_linktab
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set trace level */
name|sc
operator|->
name|sc_trace
operator|=
name|TRACE_OFF
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ISAC_IDLE
expr_stmt|;
name|sc
operator|->
name|sc_ibuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ib
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_obuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_op
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ol
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_freeflag
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_obuf2
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_freeflag2
operator|=
literal|0
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_T3_callout
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_T4_callout
argument_list|)
expr_stmt|;
comment|/* init higher protocol layers */
name|i4b_l1_mph_status_ind
argument_list|(
name|L0IFPNPUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
argument_list|,
name|STI_ATTACH
argument_list|,
name|sc
operator|->
name|sc_cardtyp
argument_list|,
operator|&
name|avm_pnp_l1mux_func
argument_list|)
expr_stmt|;
name|fail
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this is the real interrupt routine  */
end_comment

begin_function
specifier|static
name|void
name|avm_pnp_hscx_intr
parameter_list|(
name|int
name|h_chan
parameter_list|,
name|u_int
name|stat
parameter_list|,
name|u_int
name|cnt
parameter_list|,
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|register
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|int
name|activity
init|=
operator|-
literal|1
decl_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"%#x"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|HSCX_INT_XDU
operator|)
operator|&&
operator|(
name|chan
operator|->
name|bprot
operator|!=
name|BPROT_NONE
operator|)
condition|)
comment|/* xmit data underrun */
block|{
name|chan
operator|->
name|stat_XDU
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"xmit data underrun"
argument_list|)
expr_stmt|;
comment|/* abort the transmission */
name|sc
operator|->
name|avma1pp_txl
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator||=
name|HSCX_CMD_XRS
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|&=
operator|~
name|HSCX_CMD_XRS
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_head
operator|!=
name|NULL
condition|)
comment|/* don't continue to transmit this buffer */
block|{
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * The following is based on examination of the Linux driver. 	 * 	 * The logic here is different than with a "real" HSCX; all kinds 	 * of information (interrupt/status bits) are in stat. 	 *		HSCX_INT_RPR indicates a receive interrupt 	 *			HSCX_STAT_RDO indicates an overrun condition, abort - 	 *			otherwise read the bytes ((stat& HSCX_STZT_RML_MASK)>> 8) 	 *			HSCX_STAT_RME indicates end-of-frame and apparently any 	 *			CRC/framing errors are only reported in this state. 	 *				if ((stat& HSCX_STAT_CRCVFRRAB) != HSCX_STAT_CRCVFR) 	 *					CRC/framing error 	 */
if|if
condition|(
name|stat
operator|&
name|HSCX_INT_RPR
condition|)
block|{
specifier|register
name|int
name|fifo_data_len
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* always have to read the FIFO, so use a scratch buffer */
name|u_char
name|scrbuf
index|[
name|HSCX_FIFO_LEN
index|]
decl_stmt|;
if|if
condition|(
name|stat
operator|&
name|HSCX_STAT_RDO
condition|)
block|{
name|chan
operator|->
name|stat_RDO
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"receive data overflow"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
comment|/* 		 * check whether we're receiving data for an inactive B-channel 		 * and discard it. This appears to happen for telephony when 		 * both B-channels are active and one is deactivated. Since 		 * it is not really possible to deactivate the channel in that 		 * case (the ASIC seems to deactivate _both_ channels), the 		 * "deactivated" channel keeps receiving data which can lead 		 * to exhaustion of mbufs and a kernel panic. 		 * 		 * This is a hack, but it's the only solution I can think of 		 * without having the documentation for the ASIC. 		 * GJ - 28 Nov 1999 		 */
if|if
condition|(
name|chan
operator|->
name|state
operator|==
name|HSCX_IDLE
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"toss data from %d"
argument_list|,
name|h_chan
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
name|fifo_data_len
operator|=
name|cnt
expr_stmt|;
if|if
condition|(
name|fifo_data_len
operator|==
literal|0
condition|)
name|fifo_data_len
operator|=
name|sc
operator|->
name|sc_bfifolen
expr_stmt|;
comment|/* ALWAYS read data from HSCX fifo */
name|HSCX_RDFIFO
argument_list|(
name|h_chan
argument_list|,
name|scrbuf
argument_list|,
name|fifo_data_len
argument_list|)
expr_stmt|;
name|chan
operator|->
name|rxcount
operator|+=
name|fifo_data_len
expr_stmt|;
comment|/* all error conditions checked, now decide and take action */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chan
operator|->
name|in_mbuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|chan
operator|->
name|in_mbuf
operator|=
name|i4b_Bgetmbuf
argument_list|(
name|BCH_MAX_DATALEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"L1 avm_pnp_hscx_intr: RME, cannot allocate mbuf!\n"
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|chan
operator|->
name|in_len
operator|+
name|fifo_data_len
operator|)
operator|<=
name|BCH_MAX_DATALEN
condition|)
block|{
comment|/* OK to copy the data */
name|bcopy
argument_list|(
name|scrbuf
argument_list|,
name|chan
operator|->
name|in_cbptr
argument_list|,
name|fifo_data_len
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|+=
name|fifo_data_len
expr_stmt|;
name|chan
operator|->
name|in_len
operator|+=
name|fifo_data_len
expr_stmt|;
comment|/* setup mbuf data length */
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_RX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0IFPNPUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_NT
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|HSCX_STAT_RME
condition|)
block|{
if|if
condition|(
operator|(
name|stat
operator|&
name|HSCX_STAT_CRCVFRRAB
operator|)
operator|==
name|HSCX_STAT_CRCVFR
condition|)
block|{
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_rx_data_ready
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|)
expr_stmt|;
name|activity
operator|=
name|ACT_RX
expr_stmt|;
comment|/* mark buffer ptr as unused */
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|->
name|stat_CRC
operator|++
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"CRC/RAB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|in_mbuf
operator|!=
name|NULL
condition|)
block|{
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|in_mbuf
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* END enough space in mbuf */
else|else
block|{
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_NONE
condition|)
block|{
comment|/* setup mbuf data length */
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_RX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0IFPNPUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_NT
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|i4b_l1_bchan_tel_silence
argument_list|(
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
argument_list|)
operator|)
condition|)
name|activity
operator|=
name|ACT_RX
expr_stmt|;
comment|/* move rx'd data to rx queue */
operator|(
name|void
operator|)
name|IF_HANDOFF
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
argument_list|,
name|chan
operator|->
name|in_mbuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* signal upper layer that data are available */
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_rx_data_ready
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* alloc new buffer */
if|if
condition|(
operator|(
name|chan
operator|->
name|in_mbuf
operator|=
name|i4b_Bgetmbuf
argument_list|(
name|BCH_MAX_DATALEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"L1 avm_pnp_hscx_intr: RPF, cannot allocate new mbuf!\n"
argument_list|)
expr_stmt|;
comment|/* setup new data ptr */
name|chan
operator|->
name|in_cbptr
operator|=
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
expr_stmt|;
comment|/* OK to copy the data */
name|bcopy
argument_list|(
name|scrbuf
argument_list|,
name|chan
operator|->
name|in_cbptr
argument_list|,
name|fifo_data_len
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|+=
name|fifo_data_len
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
name|fifo_data_len
expr_stmt|;
name|chan
operator|->
name|rxcount
operator|+=
name|fifo_data_len
expr_stmt|;
block|}
else|else
block|{
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"RAWHDLC rx buffer overflow in RPF, in_len=%d"
argument_list|,
name|chan
operator|->
name|in_len
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* if(error == 0) */
else|else
block|{
comment|/* land here for RDO */
if|if
condition|(
name|chan
operator|->
name|in_mbuf
operator|!=
name|NULL
condition|)
block|{
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|in_mbuf
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|avma1pp_txl
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator||=
name|HSCX_CMD_RRS
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|&=
operator|~
name|HSCX_CMD_RRS
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* transmit fifo empty, new data can be written to fifo */
if|if
condition|(
name|stat
operator|&
name|HSCX_INT_XPR
condition|)
block|{
comment|/* 		 * for a description what is going on here, please have 		 * a look at isic_bchannel_start() in i4b_bchan.c ! 		 */
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"unit %d, chan %d - XPR, Tx Fifo Empty!"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|h_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_cur
operator|==
name|NULL
condition|)
comment|/* last frame is transmitted */
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
argument_list|,
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_head
operator|==
name|NULL
condition|)
block|{
name|chan
operator|->
name|state
operator|&=
operator|~
name|HSCX_TX_ACTIVE
expr_stmt|;
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_tx_queue_empty
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|->
name|state
operator||=
name|HSCX_TX_ACTIVE
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_head
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_TX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0IFPNPUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_TE
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_NONE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|i4b_l1_bchan_tel_silence
argument_list|(
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|)
operator|)
condition|)
name|activity
operator|=
name|ACT_TX
expr_stmt|;
block|}
else|else
block|{
name|activity
operator|=
name|ACT_TX
expr_stmt|;
block|}
block|}
block|}
name|avm_pnp_hscx_fifo
argument_list|(
name|chan
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* call timeout handling routine */
if|if
condition|(
name|activity
operator|==
name|ACT_RX
operator|||
name|activity
operator|==
name|ACT_TX
condition|)
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_activity
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|,
name|activity
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this is the main routine which checks each channel and then calls  * the real interrupt routine as appropriate  */
end_comment

begin_function
specifier|static
name|void
name|avm_pnp_hscx_int_handler
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|stat
init|=
literal|0
decl_stmt|;
name|u_char
name|cnt
init|=
literal|0
decl_stmt|;
name|stat
operator|=
name|hscx_read_reg
argument_list|(
literal|0
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|HSCX_INT_RPR
condition|)
name|cnt
operator|=
name|hscx_read_reg
argument_list|(
literal|0
argument_list|,
name|HSCX_STAT
operator|+
literal|1
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|HSCX_INT_MASK
condition|)
name|avm_pnp_hscx_intr
argument_list|(
literal|0
argument_list|,
name|stat
argument_list|,
name|cnt
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|stat
operator|=
name|hscx_read_reg
argument_list|(
literal|1
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|HSCX_INT_RPR
condition|)
name|cnt
operator|=
name|hscx_read_reg
argument_list|(
literal|1
argument_list|,
name|HSCX_STAT
operator|+
literal|1
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|HSCX_INT_MASK
condition|)
name|avm_pnp_hscx_intr
argument_list|(
literal|1
argument_list|,
name|stat
argument_list|,
name|cnt
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|avm_pnp_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|u_char
name|stat
decl_stmt|;
name|struct
name|l1_softc
modifier|*
name|sc
decl_stmt|;
name|bus_space_handle_t
name|bhandle
decl_stmt|;
name|bus_space_tag_t
name|btag
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|stat
operator|=
name|bus_space_read_1
argument_list|(
name|btag
argument_list|,
name|bhandle
argument_list|,
name|STAT0_OFFSET
argument_list|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"stat %x"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
comment|/* was there an interrupt from this card ? */
if|if
condition|(
operator|(
name|stat
operator|&
name|ASL_IRQ_Pending
operator|)
operator|==
name|ASL_IRQ_Pending
condition|)
return|return;
comment|/* no */
comment|/* interrupts are low active */
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|ASL_IRQ_TIMER
operator|)
condition|)
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"timer interrupt ???"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|ASL_IRQ_HSCX
operator|)
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"HSCX"
argument_list|)
expr_stmt|;
name|avm_pnp_hscx_int_handler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|ASL_IRQ_ISAC
operator|)
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"ISAC"
argument_list|)
expr_stmt|;
name|ifpnp_isac_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|avm_pnp_hscx_init
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|int
name|activate
parameter_list|)
block|{
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|NDBGL1
argument_list|(
name|L1_BCHAN
argument_list|,
literal|"unit=%d, channel=%d, %s"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|h_chan
argument_list|,
name|activate
condition|?
literal|"activate"
else|:
literal|"deactivate"
argument_list|)
expr_stmt|;
if|if
condition|(
name|activate
operator|==
literal|0
condition|)
block|{
comment|/* only deactivate if both channels are idle */
if|if
condition|(
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_A
index|]
operator|.
name|state
operator|!=
name|HSCX_IDLE
operator|||
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_B
index|]
operator|.
name|state
operator|!=
name|HSCX_IDLE
condition|)
block|{
return|return;
block|}
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|HSCX_CMD_XRS
operator||
name|HSCX_CMD_RRS
expr_stmt|;
name|sc
operator|->
name|avma1pp_prot
operator|=
name|HSCX_MODE_TRANS
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_RHDLC
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_BCHAN
argument_list|,
literal|"BPROT_RHDLC"
argument_list|)
expr_stmt|;
comment|/* HDLC Frames, transparent mode 0 */
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|HSCX_CMD_XRS
operator||
name|HSCX_CMD_RRS
expr_stmt|;
name|sc
operator|->
name|avma1pp_prot
operator|=
name|HSCX_MODE_ITF_FLG
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|HSCX_CMD_XRS
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|NDBGL1
argument_list|(
name|L1_BCHAN
argument_list|,
literal|"BPROT_NONE??"
argument_list|)
expr_stmt|;
comment|/* Raw Telephony, extended transparent mode 1 */
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|HSCX_CMD_XRS
operator||
name|HSCX_CMD_RRS
expr_stmt|;
name|sc
operator|->
name|avma1pp_prot
operator|=
name|HSCX_MODE_TRANS
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|HSCX_CMD_XRS
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|avm_pnp_bchannel_setup
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|int
name|bprot
parameter_list|,
name|int
name|activate
parameter_list|)
block|{
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|ifpnp_scp
index|[
name|unit
index|]
decl_stmt|;
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|int
name|s
init|=
name|SPLI4B
argument_list|()
decl_stmt|;
if|if
condition|(
name|activate
operator|==
literal|0
condition|)
block|{
comment|/* deactivation */
name|chan
operator|->
name|state
operator|=
name|HSCX_IDLE
expr_stmt|;
name|avm_pnp_hscx_init
argument_list|(
name|sc
argument_list|,
name|h_chan
argument_list|,
name|activate
argument_list|)
expr_stmt|;
block|}
name|NDBGL1
argument_list|(
name|L1_BCHAN
argument_list|,
literal|"unit=%d, channel=%d, %s"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|h_chan
argument_list|,
name|activate
condition|?
literal|"activate"
else|:
literal|"deactivate"
argument_list|)
expr_stmt|;
comment|/* general part */
name|chan
operator|->
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
comment|/* unit number */
name|chan
operator|->
name|channel
operator|=
name|h_chan
expr_stmt|;
comment|/* B channel */
name|chan
operator|->
name|bprot
operator|=
name|bprot
expr_stmt|;
comment|/* B channel protocol */
name|chan
operator|->
name|state
operator|=
name|HSCX_IDLE
expr_stmt|;
comment|/* B channel state */
comment|/* receiver part */
name|chan
operator|->
name|rx_queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"i4b_avm_pnp_rx"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|i4b_Bcleanifq
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
argument_list|)
expr_stmt|;
comment|/* clean rx queue */
name|chan
operator|->
name|rxcount
operator|=
literal|0
expr_stmt|;
comment|/* reset rx counter */
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|in_mbuf
argument_list|)
expr_stmt|;
comment|/* clean rx mbuf */
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
comment|/* reset mbuf ptr */
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
comment|/* reset mbuf curr ptr */
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
comment|/* reset mbuf data len */
comment|/* transmitter part */
name|chan
operator|->
name|tx_queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"i4b_avm_pnp_tx"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|i4b_Bcleanifq
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
argument_list|)
expr_stmt|;
comment|/* clean tx queue */
name|chan
operator|->
name|txcount
operator|=
literal|0
expr_stmt|;
comment|/* reset tx counter */
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
comment|/* clean tx mbuf */
name|chan
operator|->
name|out_mbuf_head
operator|=
name|NULL
expr_stmt|;
comment|/* reset head mbuf ptr */
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|NULL
expr_stmt|;
comment|/* reset current mbuf ptr */
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* reset current mbuf data ptr */
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
literal|0
expr_stmt|;
comment|/* reset current mbuf data cnt */
if|if
condition|(
name|activate
operator|!=
literal|0
condition|)
block|{
comment|/* activation */
name|avm_pnp_hscx_init
argument_list|(
name|sc
argument_list|,
name|h_chan
argument_list|,
name|activate
argument_list|)
expr_stmt|;
name|chan
operator|->
name|state
operator||=
name|HSCX_AVMA1PP_ACTIVE
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|avm_pnp_bchannel_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|)
block|{
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|ifpnp_scp
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|activity
init|=
operator|-
literal|1
decl_stmt|;
name|s
operator|=
name|SPLI4B
argument_list|()
expr_stmt|;
comment|/* enter critical section */
if|if
condition|(
name|chan
operator|->
name|state
operator|&
name|HSCX_TX_ACTIVE
condition|)
comment|/* already running ? */
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
comment|/* yes, leave */
block|}
comment|/* get next mbuf from queue */
name|IF_DEQUEUE
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
argument_list|,
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_head
operator|==
name|NULL
condition|)
comment|/* queue empty ? */
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* leave critical section */
return|return;
comment|/* yes, exit */
block|}
comment|/* init current mbuf values */
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_head
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
expr_stmt|;
comment|/* activity indicator for timeout handling */
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_NONE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|i4b_l1_bchan_tel_silence
argument_list|(
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|)
operator|)
condition|)
name|activity
operator|=
name|ACT_TX
expr_stmt|;
block|}
else|else
block|{
name|activity
operator|=
name|ACT_TX
expr_stmt|;
block|}
name|chan
operator|->
name|state
operator||=
name|HSCX_TX_ACTIVE
expr_stmt|;
comment|/* we start transmitting */
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_TX
condition|)
comment|/* if trace, send mbuf to trace dev */
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0IFPNPUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_TE
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
name|avm_pnp_hscx_fifo
argument_list|(
name|chan
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* call timeout handling routine */
if|if
condition|(
name|activity
operator|==
name|ACT_RX
operator|||
name|activity
operator|==
name|ACT_TX
condition|)
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_activity
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|,
name|activity
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	return the address of isic drivers linktab	  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|isdn_link_t
modifier|*
name|avm_pnp_ret_linktab
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|ifpnp_scp
index|[
name|unit
index|]
decl_stmt|;
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|channel
index|]
decl_stmt|;
return|return
operator|(
operator|&
name|chan
operator|->
name|isic_isdn_linktab
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	set the driver linktab in the b channel softc  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|avm_pnp_set_linktab
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|channel
parameter_list|,
name|drvr_link_t
modifier|*
name|dlt
parameter_list|)
block|{
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|ifpnp_scp
index|[
name|unit
index|]
decl_stmt|;
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|channel
index|]
decl_stmt|;
name|chan
operator|->
name|isic_drvr_linktab
operator|=
name|dlt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	initialize our local linktab  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|avm_pnp_init_linktab
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_A
index|]
decl_stmt|;
name|isdn_link_t
modifier|*
name|lt
init|=
operator|&
name|chan
operator|->
name|isic_isdn_linktab
decl_stmt|;
comment|/* make sure the hardware driver is known to layer 4 */
comment|/* avoid overwriting if already set */
if|if
condition|(
name|ctrl_types
index|[
name|CTRL_PASSIVE
index|]
operator|.
name|set_linktab
operator|==
name|NULL
condition|)
block|{
name|ctrl_types
index|[
name|CTRL_PASSIVE
index|]
operator|.
name|set_linktab
operator|=
name|avm_pnp_set_linktab
expr_stmt|;
name|ctrl_types
index|[
name|CTRL_PASSIVE
index|]
operator|.
name|get_linktab
operator|=
name|avm_pnp_ret_linktab
expr_stmt|;
block|}
comment|/* local setup */
name|lt
operator|->
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|lt
operator|->
name|channel
operator|=
name|HSCX_CH_A
expr_stmt|;
name|lt
operator|->
name|bch_config
operator|=
name|avm_pnp_bchannel_setup
expr_stmt|;
name|lt
operator|->
name|bch_tx_start
operator|=
name|avm_pnp_bchannel_start
expr_stmt|;
name|lt
operator|->
name|bch_stat
operator|=
name|avm_pnp_bchannel_stat
expr_stmt|;
name|lt
operator|->
name|tx_queue
operator|=
operator|&
name|chan
operator|->
name|tx_queue
expr_stmt|;
comment|/* used by non-HDLC data transfers, i.e. telephony drivers */
name|lt
operator|->
name|rx_queue
operator|=
operator|&
name|chan
operator|->
name|rx_queue
expr_stmt|;
comment|/* used by HDLC data transfers, i.e. ipr and isp drivers */
name|lt
operator|->
name|rx_mbuf
operator|=
operator|&
name|chan
operator|->
name|in_mbuf
expr_stmt|;
name|chan
operator|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_B
index|]
expr_stmt|;
name|lt
operator|=
operator|&
name|chan
operator|->
name|isic_isdn_linktab
expr_stmt|;
name|lt
operator|->
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|lt
operator|->
name|channel
operator|=
name|HSCX_CH_B
expr_stmt|;
name|lt
operator|->
name|bch_config
operator|=
name|avm_pnp_bchannel_setup
expr_stmt|;
name|lt
operator|->
name|bch_tx_start
operator|=
name|avm_pnp_bchannel_start
expr_stmt|;
name|lt
operator|->
name|bch_stat
operator|=
name|avm_pnp_bchannel_stat
expr_stmt|;
name|lt
operator|->
name|tx_queue
operator|=
operator|&
name|chan
operator|->
name|tx_queue
expr_stmt|;
comment|/* used by non-HDLC data transfers, i.e. telephony drivers */
name|lt
operator|->
name|rx_queue
operator|=
operator|&
name|chan
operator|->
name|rx_queue
expr_stmt|;
comment|/* used by HDLC data transfers, i.e. ipr and isp drivers */
name|lt
operator|->
name|rx_mbuf
operator|=
operator|&
name|chan
operator|->
name|in_mbuf
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * use this instead of isic_bchannel_stat in i4b_bchan.c because it's static  */
end_comment

begin_function
specifier|static
name|void
name|avm_pnp_bchannel_stat
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|bchan_statistics_t
modifier|*
name|bsp
parameter_list|)
block|{
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|ifpnp_scp
index|[
name|unit
index|]
decl_stmt|;
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|SPLI4B
argument_list|()
expr_stmt|;
name|bsp
operator|->
name|outbytes
operator|=
name|chan
operator|->
name|txcount
expr_stmt|;
name|bsp
operator|->
name|inbytes
operator|=
name|chan
operator|->
name|rxcount
expr_stmt|;
name|chan
operator|->
name|txcount
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|rxcount
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	fill HSCX fifo with data from the current mbuf  *	Put this here until it can go into i4b_hscx.c  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|avm_pnp_hscx_fifo
parameter_list|(
name|l1_bchan_state_t
modifier|*
name|chan
parameter_list|,
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|nextlen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|cmd
init|=
literal|0
decl_stmt|;
comment|/* using a scratch buffer simplifies writing to the FIFO */
name|u_char
name|scrbuf
index|[
name|HSCX_FIFO_LEN
index|]
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * fill the HSCX tx fifo with data from the current mbuf. if 	 * current mbuf holds less data than HSCX fifo length, try to 	 * get the next mbuf from (a possible) mbuf chain. if there is 	 * not enough data in a single mbuf or in a chain, then this 	 * is the last mbuf and we tell the HSCX that it has to send 	 * CRC and closing flag 	 */
while|while
condition|(
name|chan
operator|->
name|out_mbuf_cur
operator|&&
name|len
operator|!=
name|sc
operator|->
name|sc_bfifolen
condition|)
block|{
name|nextlen
operator|=
name|min
argument_list|(
name|chan
operator|->
name|out_mbuf_cur_len
argument_list|,
name|sc
operator|->
name|sc_bfifolen
operator|-
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTDEF
name|printf
argument_list|(
literal|"i:mh=%p, mc=%p, mcp=%p, mcl=%d l=%d nl=%d # "
argument_list|,
name|chan
operator|->
name|out_mbuf_head
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
argument_list|,
name|chan
operator|->
name|out_mbuf_cur_ptr
argument_list|,
name|chan
operator|->
name|out_mbuf_cur_len
argument_list|,
name|len
argument_list|,
name|nextlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cmd
operator||=
name|HSCX_CMDR_XTF
expr_stmt|;
comment|/* collect the data in the scratch buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nextlen
condition|;
name|i
operator|++
control|)
name|scrbuf
index|[
name|i
operator|+
name|len
index|]
operator|=
name|chan
operator|->
name|out_mbuf_cur_ptr
index|[
name|i
index|]
expr_stmt|;
name|len
operator|+=
name|nextlen
expr_stmt|;
name|chan
operator|->
name|txcount
operator|+=
name|nextlen
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|+=
name|nextlen
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|-=
name|nextlen
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_cur_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_next
operator|)
operator|!=
name|NULL
condition|)
block|{
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_TX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|L0IFPNPUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|chan
operator|->
name|channel
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_TE
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|chan
operator|->
name|bprot
operator|!=
name|BPROT_NONE
condition|)
name|cmd
operator||=
name|HSCX_CMDR_XME
expr_stmt|;
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
name|chan
operator|->
name|out_mbuf_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* write what we have from the scratch buf to the HSCX fifo */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|HSCX_WRFIFO
argument_list|(
name|chan
operator|->
name|channel
argument_list|,
name|scrbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	ifpnp - ISAC interrupt routine  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ifpnp_isac_intr
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|register
name|u_char
name|isac_irq_stat
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* get isac irq status */
name|isac_irq_stat
operator|=
name|ISAC_READ
argument_list|(
name|I_ISTA
argument_list|)
expr_stmt|;
if|if
condition|(
name|isac_irq_stat
condition|)
name|ifpnp_isac_irq
argument_list|(
name|sc
argument_list|,
name|isac_irq_stat
argument_list|)
expr_stmt|;
comment|/* isac handler */
else|else
break|break;
block|}
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
name|ISAC_IMASK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	ifpnp_recover - try to recover from irq lockup  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|ifpnp_recover
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|byte
decl_stmt|;
comment|/* get isac irq status */
name|byte
operator|=
name|ISAC_READ
argument_list|(
name|I_ISTA
argument_list|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_ERROR
argument_list|,
literal|"  ISAC: ISTA = 0x%x"
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte
operator|&
name|ISAC_ISTA_EXI
condition|)
name|NDBGL1
argument_list|(
name|L1_ERROR
argument_list|,
literal|"  ISAC: EXIR = 0x%x"
argument_list|,
operator|(
name|u_char
operator|)
name|ISAC_READ
argument_list|(
name|I_EXIR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte
operator|&
name|ISAC_ISTA_CISQ
condition|)
block|{
name|byte
operator|=
name|ISAC_READ
argument_list|(
name|I_CIRR
argument_list|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_ERROR
argument_list|,
literal|"  ISAC: CISQ = 0x%x"
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte
operator|&
name|ISAC_CIRR_SQC
condition|)
name|NDBGL1
argument_list|(
name|L1_ERROR
argument_list|,
literal|"  ISAC: SQRR = 0x%x"
argument_list|,
operator|(
name|u_char
operator|)
name|ISAC_READ
argument_list|(
name|I_SQRR
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|NDBGL1
argument_list|(
name|L1_ERROR
argument_list|,
literal|"  ISAC: IMASK = 0x%x"
argument_list|,
name|ISAC_IMASK
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
name|ISAC_IMASK
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NIFPNP> 0 */
end_comment

end_unit

