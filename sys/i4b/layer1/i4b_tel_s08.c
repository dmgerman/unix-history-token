begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   Copyright (c) 1996 Arne Helme. All rights reserved.  *  *   Copyright (c) 1996 Gary Jennejohn. All rights reserved.   *  *   Copyright (c) 1997, 1998 Hellmuth Michaelis. All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *   3. Neither the name of the author nor the names of any co-contributors  *      may be used to endorse or promote products derived from this software  *      without specific prior written permission.  *   4. Altered versions must be plainly marked as such, and must not be  *      misrepresented as being the original software and/or documentation.  *     *   THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  *   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  *   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  *   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  *   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  *   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  *   SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	isic - I4B Siemens ISDN Chipset Driver for Teles S0/8 and clones  *	================================================================  *  *	$Id: i4b_tel_s08.c,v 1.13 1998/12/05 18:04:59 hm Exp $   *  *      last edit-date: [Fri Dec  4 10:39:12 1998]  *  *	-hm	clean up  *	-hm	more cleanup  *      -hm     NetBSD patches from Martin  *	-hm	making it finally work (checked with board revision 1.2)  *	-hm	converting asm -> C  *  *---------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"isic.h"
end_include

begin_include
include|#
directive|include
file|"opt_i4b.h"
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NISIC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NISIC
operator|>
literal|0
operator|&&
name|defined
argument_list|(
name|TEL_S0_8
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
end_if

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<machine/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_ioctl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i4b/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<i4b/i4b_ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_l1.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_isac.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_hscx.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_global.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_l1l2.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_mbuf.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_decl_stmt
specifier|static
name|u_int8_t
name|tels08_read_reg
name|__P
argument_list|(
operator|(
expr|struct
name|isic_softc
operator|*
name|sc
operator|,
name|int
name|what
operator|,
name|bus_size_t
name|offs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tels08_write_reg
name|__P
argument_list|(
operator|(
expr|struct
name|isic_softc
operator|*
name|sc
operator|,
name|int
name|what
operator|,
name|bus_size_t
name|offs
operator|,
name|u_int8_t
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tels08_write_fifo
name|__P
argument_list|(
operator|(
expr|struct
name|isic_softc
operator|*
name|sc
operator|,
name|int
name|what
operator|,
specifier|const
name|void
operator|*
name|data
operator|,
name|size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tels08_read_fifo
name|__P
argument_list|(
operator|(
expr|struct
name|isic_softc
operator|*
name|sc
operator|,
name|int
name|what
operator|,
name|void
operator|*
name|buf
operator|,
name|size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Teles S0/8 write register routine  *---------------------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
specifier|static
name|void
name|tels08_write_reg
parameter_list|(
name|u_char
modifier|*
name|base
parameter_list|,
name|u_int
name|i
parameter_list|,
name|u_int
name|v
parameter_list|)
block|{
if|if
condition|(
name|i
operator|&
literal|0x01
condition|)
name|i
operator||=
literal|0x200
expr_stmt|;
name|base
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|bus_size_t
name|offset
index|[]
init|=
block|{
literal|0x100
block|,
literal|0x180
block|,
literal|0x1c0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tels08_write_reg
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
decl_stmt|;
name|offs
operator|+=
name|offset
index|[
name|what
index|]
expr_stmt|;
if|if
condition|(
name|offs
operator|&
literal|0x01
condition|)
name|offs
operator||=
literal|0x200
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|offs
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Teles S0/8 read register routine  *---------------------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
specifier|static
name|u_char
name|tels08_read_reg
parameter_list|(
name|u_char
modifier|*
name|base
parameter_list|,
name|u_int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|&
literal|0x1
condition|)
name|i
operator||=
literal|0x200
expr_stmt|;
return|return
operator|(
name|base
index|[
name|i
index|]
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|u_int8_t
name|tels08_read_reg
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|)
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
decl_stmt|;
name|offs
operator|+=
name|offset
index|[
name|what
index|]
expr_stmt|;
if|if
condition|(
name|offs
operator|&
literal|0x01
condition|)
name|offs
operator||=
literal|0x200
expr_stmt|;
return|return
name|bus_space_read_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|offs
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Teles S0/8 fifo read/write access  *---------------------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
specifier|static
name|void
name|tels08_memcpyb
parameter_list|(
name|void
modifier|*
name|to
parameter_list|,
specifier|const
name|void
modifier|*
name|from
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
control|)
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|to
operator|)
operator|++
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|from
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|tels08_write_fifo
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
decl_stmt|;
name|bus_space_write_region_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|offset
index|[
name|what
index|]
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tels08_read_fifo
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
decl_stmt|;
name|bus_space_read_region_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|offset
index|[
name|what
index|]
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------------------------*  *	isic_probe_s08 - probe for Teles S0/8 and compatibles  *---------------------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
name|int
name|isic_probe_s08
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|isic_softc
modifier|*
name|sc
init|=
operator|&
name|isic_sc
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
comment|/* check max unit range */
if|if
condition|(
name|dev
operator|->
name|id_unit
operator|>=
name|ISIC_MAXUNIT
condition|)
block|{
name|printf
argument_list|(
literal|"isic%d: Error, unit %d>= ISIC_MAXUNIT for Teles S0/8!\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|sc_unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
comment|/* check IRQ validity */
switch|switch
condition|(
name|ffs
argument_list|(
name|dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
condition|)
block|{
case|case
literal|2
case|:
case|case
literal|9
case|:
comment|/* XXX */
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"isic%d: Error, invalid IRQ [%d] specified for Teles S0/8!\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|ffs
argument_list|(
name|dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
name|sc
operator|->
name|sc_irq
operator|=
name|dev
operator|->
name|id_irq
expr_stmt|;
comment|/* check if we got an iobase */
if|if
condition|(
name|dev
operator|->
name|id_iobase
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"isic%d: Error, iobase specified for Teles S0/8!\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* check if inside memory range of 0xA0000 .. 0xDF000 */
if|if
condition|(
operator|(
name|kvtop
argument_list|(
name|dev
operator|->
name|id_maddr
argument_list|)
operator|<
literal|0xa0000
operator|)
operator|||
operator|(
name|kvtop
argument_list|(
name|dev
operator|->
name|id_maddr
argument_list|)
operator|>
literal|0xdf000
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"isic%d: Error, mem addr 0x%lx outside 0xA0000-0xDF000 for Teles S0/8!\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|kvtop
argument_list|(
name|dev
operator|->
name|id_maddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|sc_vmem_addr
operator|=
operator|(
name|caddr_t
operator|)
name|dev
operator|->
name|id_maddr
expr_stmt|;
name|dev
operator|->
name|id_msize
operator|=
literal|0x1000
expr_stmt|;
comment|/* setup ISAC access routines */
name|sc
operator|->
name|clearirq
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|readreg
operator|=
name|tels08_read_reg
expr_stmt|;
name|sc
operator|->
name|writereg
operator|=
name|tels08_write_reg
expr_stmt|;
name|sc
operator|->
name|readfifo
operator|=
name|tels08_memcpyb
expr_stmt|;
name|sc
operator|->
name|writefifo
operator|=
name|tels08_memcpyb
expr_stmt|;
comment|/* setup card type */
name|sc
operator|->
name|sc_cardtyp
operator|=
name|CARD_TYPEP_8
expr_stmt|;
comment|/* setup IOM bus type */
name|sc
operator|->
name|sc_bustyp
operator|=
name|BUS_TYPE_IOM1
expr_stmt|;
name|sc
operator|->
name|sc_ipac
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bfifolen
operator|=
name|HSCX_FIFO_LEN
expr_stmt|;
comment|/* setup ISAC base addr */
name|ISAC_BASE
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|dev
operator|->
name|id_maddr
operator|)
operator|+
literal|0x100
argument_list|)
expr_stmt|;
comment|/* setup HSCX base addr */
name|HSCX_A_BASE
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|dev
operator|->
name|id_maddr
operator|)
operator|+
literal|0x180
argument_list|)
expr_stmt|;
name|HSCX_B_BASE
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|dev
operator|->
name|id_maddr
operator|)
operator|+
literal|0x1c0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|isic_probe_s08
parameter_list|(
name|struct
name|isic_attach_args
modifier|*
name|ia
parameter_list|)
block|{
comment|/* no real sensible probe is easy - write to fifo memory 	   and read back to verify there is memory doesn't work, 	   because you talk to tx fifo and rcv fifo. So, just check 	   HSCX version, which at least fails if no card present  	   at the given location. */
name|bus_space_tag_t
name|t
init|=
name|ia
operator|->
name|ia_maps
index|[
literal|0
index|]
operator|.
name|t
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|ia
operator|->
name|ia_maps
index|[
literal|0
index|]
operator|.
name|h
decl_stmt|;
name|u_int8_t
name|v1
decl_stmt|,
name|v2
decl_stmt|;
comment|/* HSCX A VSTR */
name|v1
operator|=
name|bus_space_read_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|offset
index|[
literal|1
index|]
operator|+
name|H_VSTR
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|v1
operator|!=
name|HSCX_VA1
operator|&&
name|v1
operator|!=
name|HSCX_VA2
operator|&&
name|v1
operator|!=
name|HSCX_VA3
operator|&&
name|v1
operator|!=
name|HSCX_V21
condition|)
return|return
literal|0
return|;
comment|/* HSCX B VSTR */
name|v2
operator|=
name|bus_space_read_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|offset
index|[
literal|2
index|]
operator|+
name|H_VSTR
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|v2
operator|!=
name|HSCX_VA1
operator|&&
name|v2
operator|!=
name|HSCX_VA2
operator|&&
name|v2
operator|!=
name|HSCX_VA3
operator|&&
name|v2
operator|!=
name|HSCX_V21
condition|)
return|return
literal|0
return|;
comment|/* both HSCX channels should have the same version... */
if|if
condition|(
name|v1
operator|!=
name|v2
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------------------------*  *	isic_attach_s08 - attach Teles S0/8 and compatibles  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__FreeBSD__
name|isic_attach_s08
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
else|#
directive|else
function|isic_attach_s08
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|isic_softc
modifier|*
name|sc
init|=
operator|&
name|isic_sc
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
else|#
directive|else
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
decl_stmt|;
endif|#
directive|endif
comment|/* set card off */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|sc
operator|->
name|sc_vmem_addr
index|[
literal|0x80
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
literal|0x80
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|5
argument_list|)
expr_stmt|;
comment|/* set card on */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|sc
operator|->
name|sc_vmem_addr
index|[
literal|0x80
index|]
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
literal|0x80
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|5
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__FreeBSD__
comment|/* setup ISAC access routines */
name|sc
operator|->
name|clearirq
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|readreg
operator|=
name|tels08_read_reg
expr_stmt|;
name|sc
operator|->
name|writereg
operator|=
name|tels08_write_reg
expr_stmt|;
name|sc
operator|->
name|readfifo
operator|=
name|tels08_read_fifo
expr_stmt|;
name|sc
operator|->
name|writefifo
operator|=
name|tels08_write_fifo
expr_stmt|;
comment|/* setup card type */
name|sc
operator|->
name|sc_cardtyp
operator|=
name|CARD_TYPEP_8
expr_stmt|;
comment|/* setup IOM bus type */
name|sc
operator|->
name|sc_bustyp
operator|=
name|BUS_TYPE_IOM1
expr_stmt|;
name|sc
operator|->
name|sc_ipac
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bfifolen
operator|=
name|HSCX_FIFO_LEN
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISIC> 0 */
end_comment

end_unit

