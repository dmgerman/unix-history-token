begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   Copyright (c) 2000, 2001 Sergio Prallon. All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *   3. Neither the name of the author nor the names of any co-contributors  *      may be used to endorse or promote products derived from this software  *      without specific prior written permission.  *   4. Altered versions must be plainly marked as such, and must not be  *      misrepresented as being the original software and/or documentation.  *     *   THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  *   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  *   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  *   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  *   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  *   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  *   SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	i4b_itjc_pci.c: NetJet-S hardware driver  *	----------------------------------------  *  * $FreeBSD$  *  *      last edit-date: [Thu Jan 11 11:29:38 2001]  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"opt_i4b.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_trace.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_global.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_l1.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/itjc/i4b_hdlc.h>
end_include

begin_comment
comment|/* XXXXXXXXXXXXXXXXXXXXXXXX */
end_comment

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_isic.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/isic/i4b_isac.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/itjc/i4b_itjc_ext.h>
end_include

begin_define
define|#
directive|define
name|PCI_TJNET_VID
value|(0xe159)
end_define

begin_define
define|#
directive|define
name|PCI_TJ300_DID
value|(0x0001)
end_define

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|itjc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|itjc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|itjc_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|itjc_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|itjc_dma_start
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|itjc_dma_stop
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|itjc_isac_intr
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|itjc_init_linktab
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|itjc_bchannel_setup
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|int
name|bprot
parameter_list|,
name|int
name|activate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|itjc_bchannel_stat
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|bchan_statistics_t
modifier|*
name|bsp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Shorter names to bus resource manager routines.  */
end_comment

begin_define
define|#
directive|define
name|itjc_bus_setup
parameter_list|(
name|sc
parameter_list|)
define|\
value|bus_space_handle_t h =						\ 		rman_get_bushandle((sc)->sc_resources.io_base[0]);	\ 	bus_space_tag_t    t =						\ 		rman_get_bustag((sc)->sc_resources.io_base[0]);
end_define

begin_define
define|#
directive|define
name|itjc_read_1
parameter_list|(
name|port
parameter_list|)
value|(bus_space_read_1(t, h, (port)))
end_define

begin_define
define|#
directive|define
name|itjc_read_4
parameter_list|(
name|port
parameter_list|)
value|(bus_space_read_4(t, h, (port)))
end_define

begin_define
define|#
directive|define
name|itjc_write_1
parameter_list|(
name|port
parameter_list|,
name|data
parameter_list|)
value|(bus_space_write_1(t, h, (port), (data)))
end_define

begin_define
define|#
directive|define
name|itjc_write_4
parameter_list|(
name|port
parameter_list|,
name|data
parameter_list|)
value|(bus_space_write_4(t, h, (port), (data)))
end_define

begin_define
define|#
directive|define
name|itjc_read_multi_1
parameter_list|(
name|port
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
define|\
value|(bus_space_read_multi_1(t, h, (port), (buf), (size)))
end_define

begin_define
define|#
directive|define
name|itjc_write_multi_1
parameter_list|(
name|port
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
define|\
value|(bus_space_write_multi_1(t, h, (port), (buf), (size)))
end_define

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Glue data to register ourselves as a PCI device driver.  *---------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|itjc_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|itjc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|itjc_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|itjc_shutdown
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|itjc_pci_driver
init|=
block|{
literal|"itjc"
block|,
name|itjc_pci_methods
block|,
expr|sizeof
operator|(
expr|struct
name|l1_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|itjc_pci_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|netjet
argument_list|,
name|pci
argument_list|,
name|itjc_pci_driver
argument_list|,
name|itjc_pci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Jump table for multiplex routines.  */
end_comment

begin_decl_stmt
name|struct
name|i4b_l1mux_func
name|itjc_l1mux_func
init|=
block|{
name|itjc_ret_linktab
block|,
name|itjc_set_linktab
block|,
name|itjc_mph_command_req
block|,
name|itjc_ph_data_req
block|,
name|itjc_ph_activate_req
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|l1_softc
modifier|*
name|itjc_scp
index|[
name|ITJC_MAXUNIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Tiger300/320 PCI ASIC registers.  *---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  *	Register offsets from i/o base.  */
end_comment

begin_enum
enum|enum
name|tiger_regs
block|{
name|TIGER_RESET_PIB_CL_TIME
init|=
literal|0x00
block|,
name|TIGER_DMA_OPER
init|=
literal|0x01
block|,
name|TIGER_AUX_PORT_CNTL
init|=
literal|0x02
block|,
name|TIGER_AUX_PORT_DATA
init|=
literal|0x03
block|,
name|TIGER_INT0_MASK
init|=
literal|0x04
block|,
name|TIGER_INT1_MASK
init|=
literal|0x05
block|,
name|TIGER_INT0_STATUS
init|=
literal|0x06
block|,
name|TIGER_INT1_STATUS
init|=
literal|0x07
block|,
name|TIGER_DMA_WR_START_ADDR
init|=
literal|0x08
block|,
name|TIGER_DMA_WR_INT_ADDR
init|=
literal|0x0C
block|,
name|TIGER_DMA_WR_END_ADDR
init|=
literal|0x10
block|,
name|TIGER_DMA_WR_CURR_ADDR
init|=
literal|0x14
block|,
name|TIGER_DMA_RD_START_ADDR
init|=
literal|0x18
block|,
name|TIGER_DMA_RD_INT_ADDR
init|=
literal|0x1C
block|,
name|TIGER_DMA_RD_END_ADDR
init|=
literal|0x20
block|,
name|TIGER_DMA_RD_CURR_ADDR
init|=
literal|0x24
block|,
name|TIGER_PULSE_COUNTER
init|=
literal|0x28
block|, }
enum|;
end_enum

begin_comment
comment|/*  * Bits on the above registers.  */
end_comment

begin_enum
enum|enum
name|tiger_reg_bits
block|{
comment|/* Reset and PIB Cycle Timing */
name|TIGER_DMA_OP_MODE_MASK
init|=
literal|0x80
block|,
name|TIGER_SELF_ADDR_DMA
init|=
literal|0x00
block|,
comment|/* Wrap around ending addr */
name|TIGER_NORMAL_DMA
init|=
literal|0x80
block|,
comment|/* Stop at ending addr */
name|TIGER_DMA_INT_MODE_MASK
init|=
literal|0x40
block|,
name|TIGER_DONT_LATCH_DMA_INT
init|=
literal|0x00
block|,
comment|/* Bits on int0 status will be 						   set only while curr addr 						   equals int or end addr */
name|TIGER_LATCH_DMA_INT
init|=
literal|0x40
block|,
comment|/* Bits on int0 status remain 						   set until cleared by CPU */
name|TIGER_PIB_CYCLE_TIMING_MASK
init|=
literal|0x30
block|,
name|TIGER_PIB_3_CYCLES
init|=
literal|0x00
block|,
name|TIGER_PIB_5_CYCLES
init|=
literal|0x01
block|,
name|TIGER_PIB_12_CYCLES
init|=
literal|0x10
block|,
name|TIGER_RESET_MASK
init|=
literal|0x0F
block|,
name|TIGER_RESET_PULSE_COUNT
init|=
literal|0x08
block|,
name|TIGER_RESET_SERIAL_PORT
init|=
literal|0x04
block|,
name|TIGER_RESET_DMA_LOGIC
init|=
literal|0x02
block|,
name|TIGER_RESET_EXTERNAL
init|=
literal|0x01
block|,
name|TIGER_RESET_ALL
init|=
literal|0x0F
block|,
comment|/* DMA Operation */
name|TIGER_DMA_RESTART_MASK
init|=
literal|0x02
block|,
name|TIGER_HOLD_DMA
init|=
literal|0x00
block|,
name|TIGER_RESTART_DMA
init|=
literal|0x00
block|,
name|TIGER_DMA_ENABLE_MASK
init|=
literal|0x01
block|,
name|TIGER_ENABLE_DMA
init|=
literal|0x01
block|,
name|TIGER_DISABLE_DMA
init|=
literal|0x00
block|,
comment|/* AUX Port Control& Data plus Interrupt 1 Mask& Status  */
name|TIGER_AUX_7_MASK
init|=
literal|0x80
block|,
name|TIGER_AUX_6_MASK
init|=
literal|0x40
block|,
name|TIGER_AUX_5_MASK
init|=
literal|0x20
block|,
name|TIGER_AUX_4_MASK
init|=
literal|0x10
block|,
name|TIGER_ISAC_INT_MASK
init|=
literal|0x10
block|,
name|TIGER_AUX_3_MASK
init|=
literal|0x08
block|,
name|TIGER_AUX_2_MASK
init|=
literal|0x04
block|,
name|TIGER_AUX_1_MASK
init|=
literal|0x02
block|,
name|TIGER_AUX_0_MASK
init|=
literal|0x01
block|,
comment|/* AUX Port Control */
name|TIGER_AUX_7_IS_INPUT
init|=
literal|0x00
block|,
name|TIGER_AUX_7_IS_OUTPUT
init|=
literal|0x80
block|,
name|TIGER_AUX_6_IS_INPUT
init|=
literal|0x00
block|,
name|TIGER_AUX_6_IS_OUTPUT
init|=
literal|0x40
block|,
name|TIGER_AUX_5_IS_INPUT
init|=
literal|0x00
block|,
name|TIGER_AUX_5_IS_OUTPUT
init|=
literal|0x20
block|,
name|TIGER_AUX_4_IS_INPUT
init|=
literal|0x00
block|,
name|TIGER_AUX_4_IS_OUTPUT
init|=
literal|0x10
block|,
name|TIGER_AUX_3_IS_INPUT
init|=
literal|0x00
block|,
name|TIGER_AUX_3_IS_OUTPUT
init|=
literal|0x80
block|,
name|TIGER_AUX_2_IS_INPUT
init|=
literal|0x00
block|,
name|TIGER_AUX_2_IS_OUTPUT
init|=
literal|0x40
block|,
name|TIGER_AUX_1_IS_INPUT
init|=
literal|0x00
block|,
name|TIGER_AUX_1_IS_OUTPUT
init|=
literal|0x20
block|,
name|TIGER_AUX_0_IS_INPUT
init|=
literal|0x00
block|,
name|TIGER_AUX_0_IS_OUTPUT
init|=
literal|0x10
block|,
name|TIGER_AUX_NJ_DEFAULT
init|=
literal|0xEF
block|,
comment|/* All but ISAC int is output */
comment|/* Interrupt 0 Mask& Status */
name|TIGER_PCI_TARGET_ABORT_INT_MASK
init|=
literal|0x20
block|,
name|TIGER_NO_TGT_ABORT_INT
init|=
literal|0x00
block|,
name|TIGER_TARGET_ABORT_INT
init|=
literal|0x20
block|,
name|TIGER_PCI_MASTER_ABORT_INT_MASK
init|=
literal|0x10
block|,
name|TIGER_NO_MST_ABORT_INT
init|=
literal|0x00
block|,
name|TIGER_MASTER_ABORT_INT
init|=
literal|0x10
block|,
name|TIGER_DMA_RD_END_INT_MASK
init|=
literal|0x08
block|,
name|TIGER_NO_RD_END_INT
init|=
literal|0x00
block|,
name|TIGER_RD_END_INT
init|=
literal|0x08
block|,
name|TIGER_DMA_RD_INT_INT_MASK
init|=
literal|0x04
block|,
name|TIGER_NO_RD_INT_INT
init|=
literal|0x00
block|,
name|TIGER_RD_INT_INT
init|=
literal|0x04
block|,
name|TIGER_DMA_WR_END_INT_MASK
init|=
literal|0x02
block|,
name|TIGER_NO_WR_END_INT
init|=
literal|0x00
block|,
name|TIGER_WR_END_INT
init|=
literal|0x02
block|,
name|TIGER_DMA_WR_INT_INT_MASK
init|=
literal|0x01
block|,
name|TIGER_NO_WR_INT_INT
init|=
literal|0x00
block|,
name|TIGER_WR_INT_INT
init|=
literal|0x01
block|,
comment|/* Interrupt 1 Mask& Status */
name|TIGER_NO_AUX_7_INT
init|=
literal|0x00
block|,
name|TIGER_AUX_7_INT
init|=
literal|0x80
block|,
name|TIGER_NO_AUX_6_INT
init|=
literal|0x00
block|,
name|TIGER_AUX_6_INT
init|=
literal|0x40
block|,
name|TIGER_NO_AUX_5_INT
init|=
literal|0x00
block|,
name|TIGER_AUX_5_INT
init|=
literal|0x20
block|,
name|TIGER_NO_AUX_4_INT
init|=
literal|0x00
block|,
name|TIGER_AUX_4_INT
init|=
literal|0x10
block|,
name|TIGER_NO_ISAC_INT
init|=
literal|0x00
block|,
name|TIGER_ISAC_INT
init|=
literal|0x10
block|,
name|TIGER_NO_AUX_3_INT
init|=
literal|0x00
block|,
name|TIGER_AUX_3_INT
init|=
literal|0x08
block|,
name|TIGER_NO_AUX_2_INT
init|=
literal|0x00
block|,
name|TIGER_AUX_2_INT
init|=
literal|0x04
block|,
name|TIGER_NO_AUX_1_INT
init|=
literal|0x00
block|,
name|TIGER_AUX_1_INT
init|=
literal|0x02
block|,
name|TIGER_NO_AUX_0_INT
init|=
literal|0x00
block|,
name|TIGER_AUX_0_INT
init|=
literal|0x01
block|}
enum|;
end_enum

begin_comment
comment|/*  * Peripheral Interface Bus definitions. This is an ISA like bus  * created by the Tiger ASIC to keep ISA chips like the ISAC happy  * on a PCI environment.  *  * Since the PIB only supplies 4 addressing lines, the 2 higher bits  * (A4& A5) of the ISAC register addresses are wired on the 2 lower  * AUX lines. Another restriction is that all I/O to the PIB (8bit  * wide) is mapped on the PCI side as 32bit data. So the PCI address  * of a given ISAC register has to be multiplied by 4 before being  * added to the PIB base offset.  */
end_comment

begin_enum
enum|enum
name|tiger_pib_regs_defs
block|{
comment|/* Offset from the I/O base to the ISAC registers. */
name|PIB_OFFSET
init|=
literal|0xC0
block|,
name|PIB_LO_ADDR_MASK
init|=
literal|0x0F
block|,
name|PIB_HI_ADDR_MASK
init|=
literal|0x30
block|,
name|PIB_LO_ADDR_SHIFT
init|=
literal|2
block|,
comment|/* Align on dword boundary */
name|PIB_HI_ADDR_SHIFT
init|=
literal|4
comment|/* Right shift to AUX_1& AUX_0 */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|itjc_set_pib_addr_msb
parameter_list|(
name|a
parameter_list|)
define|\
value|(									\ 	itjc_write_1(TIGER_AUX_PORT_DATA,				\ 		((a)& PIB_HI_ADDR_MASK)>> PIB_HI_ADDR_SHIFT)		\ )
end_define

begin_define
define|#
directive|define
name|itjc_pib_2_pci
parameter_list|(
name|a
parameter_list|)
define|\
value|(									\ 	(((a)& PIB_LO_ADDR_MASK)<< PIB_LO_ADDR_SHIFT) + PIB_OFFSET	\ )
end_define

begin_define
define|#
directive|define
name|itjc_get_dma_offset
parameter_list|(
name|ctx
parameter_list|,
name|reg
parameter_list|)
define|\
value|(									\ 	(u_int16_t)((bus_addr_t)itjc_read_4((reg)) - (ctx)->bus_addr)	\ )
end_define

begin_comment
comment|/*  * IOM-2 serial channel 0 DMA data ring buffers.  *  * The Tiger300/320 ASIC do not nothing more than transfer via DMA the  * first 32 bits of every IOM-2 frame on the serial interface to the  * ISAC. So we have no framing/deframing facilities like we would have  * with an HSCX, having to do the job with CPU cycles. On the plus side  * we are able to specify large rings which can limit the occurrence of  * over/underruns.  */
end_comment

begin_enum
enum|enum
block|{
name|ITJC_RING_SLOT_WORDS
init|=
literal|64
block|,
name|ITJC_RING_WORDS
init|=
literal|3
operator|*
name|ITJC_RING_SLOT_WORDS
block|,
name|ITJC_RING_SLOT_BYTES
init|=
literal|4
operator|*
name|ITJC_RING_SLOT_WORDS
block|,
name|ITJC_RING_BYTES
init|=
literal|4
operator|*
name|ITJC_RING_WORDS
block|,
name|ITJC_DMA_POOL_WORDS
init|=
literal|2
operator|*
name|ITJC_RING_WORDS
block|,
name|ITJC_DMA_POOL_BYTES
init|=
literal|4
operator|*
name|ITJC_DMA_POOL_WORDS
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|itjc_ring_add
parameter_list|(
name|x
parameter_list|,
name|d
parameter_list|)
value|(((x) + 4 * (d)) % ITJC_RING_BYTES)
end_define

begin_define
define|#
directive|define
name|itjc_ring_sub
parameter_list|(
name|x
parameter_list|,
name|d
parameter_list|)
value|(((x) + ITJC_RING_BYTES - 4 * (d))	\ 					% ITJC_RING_BYTES)
end_define

begin_enum
enum|enum
block|{
name|TIGER_CH_A
init|=
literal|0
block|,
name|TIGER_CH_B
init|=
literal|1
block|,
name|HSCX_CH_A
init|=
literal|0
block|,
comment|/* For compatibility reasons. */
name|HSCX_CH_B
init|=
literal|1
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|ITJC_TEL_SILENCE_BYTE
init|=
literal|0x00
block|,
name|ITJC_HDLC_FLAG_BYTE
init|=
literal|0x7E
block|,
name|ITJC_HDLC_ABORT_BYTE
init|=
literal|0xFF
block|}
enum|;
end_enum

begin_comment
comment|/*  * Hardware DMA control block (one per card).  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|ITJC_DS_LOAD_FAILED
init|=
operator|-
literal|1
block|,
name|ITJC_DS_FREE
init|=
literal|0
block|,
name|ITJC_DS_LOADING
block|,
name|ITJC_DS_STOPPED
block|,
name|ITJC_DS_RUNNING
block|}
name|dma_state_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|dma_state_t
name|state
decl_stmt|;
name|u_int8_t
modifier|*
name|pool
decl_stmt|;
name|bus_addr_t
name|bus_addr
decl_stmt|;
name|bus_dma_tag_t
name|tag
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|error
decl_stmt|;
block|}
name|dma_context_t
typedef|;
end_typedef

begin_decl_stmt
name|dma_context_t
name|dma_context
index|[
name|ITJC_MAXUNIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * B-channel DMA control blocks (4 per card -- 1 RX& 1 TX per channel).  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|ITJC_RS_IDLE
init|=
literal|0
block|,
name|ITJC_RS_ACTIVE
block|}
name|dma_rx_state_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|ITJC_TS_IDLE
init|=
literal|0
block|,
name|ITJC_TS_ACTIVE
block|,
name|ITJC_TS_AFTER_XDU
block|}
name|dma_tx_state_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_int8_t
modifier|*
name|ring
decl_stmt|;
name|bus_addr_t
name|bus_addr
decl_stmt|;
name|u_int16_t
name|next_read
decl_stmt|;
name|u_int16_t
name|hdlc_len
decl_stmt|;
name|u_int16_t
name|hdlc_tmp
decl_stmt|;
name|u_int16_t
name|hdlc_crc
decl_stmt|;
name|u_int16_t
name|hdlc_ib
decl_stmt|;
name|u_int8_t
name|hdlc_blevel
decl_stmt|;
name|u_int8_t
name|hdlc_flag
decl_stmt|;
name|dma_rx_state_t
name|state
decl_stmt|;
block|}
name|dma_rx_context_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_int8_t
modifier|*
name|ring
decl_stmt|;
name|bus_addr_t
name|bus_addr
decl_stmt|;
name|u_int16_t
name|next_write
decl_stmt|;
name|u_int32_t
name|hdlc_tmp
decl_stmt|;
name|u_int16_t
name|hdlc_blevel
decl_stmt|;
name|u_int16_t
name|hdlc_crc
decl_stmt|;
name|u_int16_t
name|hdlc_ib
decl_stmt|;
name|u_int16_t
name|next_frame
decl_stmt|;
name|u_int16_t
name|filled
decl_stmt|;
name|u_int8_t
name|hdlc_flag
decl_stmt|;
name|dma_tx_state_t
name|state
decl_stmt|;
block|}
name|dma_tx_context_t
typedef|;
end_typedef

begin_decl_stmt
name|dma_rx_context_t
name|dma_rx_context
index|[
name|ITJC_MAXUNIT
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dma_tx_context_t
name|dma_tx_context
index|[
name|ITJC_MAXUNIT
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Used by the mbuf handling functions.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|ITJC_MB_CURR
init|=
literal|0
block|,
name|ITJC_MB_NEXT
init|=
literal|1
block|,
name|ITJC_MB_NEW
init|=
literal|2
block|}
name|which_mb_t
typedef|;
end_typedef

begin_comment
comment|/*---------------------------------------------------------------------------*  *	itjc_map_callback - get DMA bus address from resource mgr.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|itjc_map_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|dma_context_t
modifier|*
name|ctx
init|=
operator|(
name|dma_context_t
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ctx
operator|->
name|error
operator|=
name|error
expr_stmt|;
name|ctx
operator|->
name|state
operator|=
name|ITJC_DS_LOAD_FAILED
expr_stmt|;
return|return;
block|}
name|ctx
operator|->
name|bus_addr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
name|ctx
operator|->
name|state
operator|=
name|ITJC_DS_STOPPED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	itjc_dma_start - Complete DMA setup& start the Tiger DMA engine.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|itjc_dma_start
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|unit
init|=
name|sc
operator|->
name|sc_unit
decl_stmt|;
name|dma_context_t
modifier|*
name|ctx
init|=
operator|&
name|dma_context
index|[
name|unit
index|]
decl_stmt|;
name|dma_rx_context_t
modifier|*
name|rxc
init|=
operator|&
name|dma_rx_context
index|[
name|unit
index|]
index|[
literal|0
index|]
decl_stmt|;
name|dma_tx_context_t
modifier|*
name|txc
init|=
operator|&
name|dma_tx_context
index|[
name|unit
index|]
index|[
literal|0
index|]
decl_stmt|;
name|bus_addr_t
name|ba
decl_stmt|;
name|u_int8_t
name|i
decl_stmt|;
name|u_int32_t
modifier|*
name|pool_end
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
name|itjc_bus_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* See if it is already running. */
if|if
condition|(
name|ctx
operator|->
name|state
operator|==
name|ITJC_DS_RUNNING
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ctx
operator|->
name|state
operator|==
name|ITJC_DS_LOAD_FAILED
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_ERROR
argument_list|,
literal|"itjc%d: dma_start: DMA map loading "
literal|"failed (error=%d).\n"
argument_list|,
name|unit
argument_list|,
name|ctx
operator|->
name|error
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ctx
operator|->
name|state
operator|!=
name|ITJC_DS_STOPPED
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_ERROR
argument_list|,
literal|"itjc%d: dma_start: Unexpected DMA "
literal|"state (%d).\n"
argument_list|,
name|unit
argument_list|,
name|ctx
operator|->
name|state
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Initialize the DMA control structures (hardware& B-channel). 	 */
name|ba
operator|=
name|ctx
operator|->
name|bus_addr
expr_stmt|;
name|txc
operator|->
name|ring
operator|=
name|ctx
operator|->
name|pool
operator|+
name|TIGER_CH_A
expr_stmt|;
name|rxc
operator|->
name|ring
operator|=
name|ctx
operator|->
name|pool
operator|+
name|TIGER_CH_A
operator|+
name|ITJC_RING_BYTES
expr_stmt|;
name|txc
operator|->
name|bus_addr
operator|=
name|ba
expr_stmt|;
name|rxc
operator|->
name|bus_addr
operator|=
name|ba
operator|+
name|ITJC_RING_BYTES
expr_stmt|;
operator|++
name|rxc
expr_stmt|;
operator|++
name|txc
expr_stmt|;
name|txc
operator|->
name|ring
operator|=
name|ctx
operator|->
name|pool
operator|+
name|TIGER_CH_B
expr_stmt|;
name|rxc
operator|->
name|ring
operator|=
name|ctx
operator|->
name|pool
operator|+
name|TIGER_CH_B
operator|+
name|ITJC_RING_BYTES
expr_stmt|;
name|txc
operator|->
name|bus_addr
operator|=
name|ba
expr_stmt|;
name|rxc
operator|->
name|bus_addr
operator|=
name|ba
operator|+
name|ITJC_RING_BYTES
expr_stmt|;
comment|/* 	 * Fill the DMA ring buffers with IOM-2 channel 0 frames made of 	 * idle/abort sequences for the B& D channels and NOP for IOM-2 	 * cmd/ind, monitor handshake& data. 	 */
name|pool_end
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|ctx
operator|->
name|pool
operator|+
name|ITJC_DMA_POOL_WORDS
expr_stmt|;
for|for
control|(
name|ip
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|ctx
operator|->
name|pool
init|;
name|ip
operator|<
name|pool_end
condition|;
operator|++
name|ip
control|)
operator|*
name|ip
operator|=
literal|0xFFFFFFFF
expr_stmt|;
comment|/* 	 * Program the Tiger DMA gears. 	 */
name|itjc_write_4
argument_list|(
name|TIGER_DMA_WR_START_ADDR
argument_list|,
name|ba
argument_list|)
expr_stmt|;
name|itjc_write_4
argument_list|(
name|TIGER_DMA_WR_INT_ADDR
argument_list|,
name|ba
operator|+
name|ITJC_RING_SLOT_BYTES
operator|-
literal|4
argument_list|)
expr_stmt|;
name|itjc_write_4
argument_list|(
name|TIGER_DMA_WR_END_ADDR
argument_list|,
name|ba
operator|+
name|ITJC_RING_BYTES
operator|-
literal|4
argument_list|)
expr_stmt|;
name|ba
operator|+=
name|ITJC_RING_BYTES
expr_stmt|;
name|itjc_write_4
argument_list|(
name|TIGER_DMA_RD_START_ADDR
argument_list|,
name|ba
argument_list|)
expr_stmt|;
name|itjc_write_4
argument_list|(
name|TIGER_DMA_RD_INT_ADDR
argument_list|,
name|ba
operator|+
name|ITJC_RING_SLOT_BYTES
operator|*
literal|2
operator|-
literal|4
argument_list|)
expr_stmt|;
name|itjc_write_4
argument_list|(
name|TIGER_DMA_RD_END_ADDR
argument_list|,
name|ba
operator|+
name|ITJC_RING_BYTES
operator|-
literal|4
argument_list|)
expr_stmt|;
name|itjc_write_1
argument_list|(
name|TIGER_INT0_MASK
argument_list|,
name|TIGER_WR_END_INT
operator||
name|TIGER_WR_INT_INT
operator||
name|TIGER_RD_INT_INT
argument_list|)
expr_stmt|;
name|itjc_write_1
argument_list|(
name|TIGER_DMA_OPER
argument_list|,
name|TIGER_ENABLE_DMA
argument_list|)
expr_stmt|;
comment|/* 	 * See if it really started. 	 */
name|ba
operator|=
name|itjc_read_4
argument_list|(
name|TIGER_DMA_RD_CURR_ADDR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
block|{
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ba
operator|!=
name|itjc_read_4
argument_list|(
name|TIGER_DMA_RD_CURR_ADDR
argument_list|)
condition|)
block|{
name|ctx
operator|->
name|state
operator|=
name|ITJC_DS_RUNNING
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|NDBGL1
argument_list|(
name|L1_ERROR
argument_list|,
literal|"itjc%d: dma_start: DMA start failed.\n "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	itjc_dma_stop - Stop the Tiger DMA engine.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|itjc_dma_stop
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|dma_context_t
modifier|*
name|ctx
init|=
operator|&
name|dma_context
index|[
name|sc
operator|->
name|sc_unit
index|]
decl_stmt|;
name|itjc_bus_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Only stop the DMA if it is running. */
if|if
condition|(
name|ctx
operator|->
name|state
operator|!=
name|ITJC_DS_RUNNING
condition|)
return|return;
name|itjc_write_1
argument_list|(
name|TIGER_DMA_OPER
argument_list|,
name|TIGER_DISABLE_DMA
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|state
operator|=
name|ITJC_DS_STOPPED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	itjc_bchannel_dma_setup - The DMA side of itjc_bchannel_setup.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|itjc_bchannel_dma_setup
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|int
name|activate
parameter_list|)
block|{
name|dma_rx_context_t
modifier|*
name|rxc
init|=
operator|&
name|dma_rx_context
index|[
name|sc
operator|->
name|sc_unit
index|]
index|[
name|h_chan
index|]
decl_stmt|;
name|dma_tx_context_t
modifier|*
name|txc
init|=
operator|&
name|dma_tx_context
index|[
name|sc
operator|->
name|sc_unit
index|]
index|[
name|h_chan
index|]
decl_stmt|;
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|u_int8_t
name|fill_byte
decl_stmt|,
modifier|*
name|ring_end
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|s
init|=
name|SPLI4B
argument_list|()
decl_stmt|;
name|itjc_bus_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|activate
condition|)
block|{
comment|/* 		 * Get the DMA engine going if it's not running already. 		 */
name|itjc_dma_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rxc
operator|->
name|hdlc_len
operator|=
name|rxc
operator|->
name|hdlc_tmp
operator|=
name|rxc
operator|->
name|hdlc_crc
operator|=
literal|0
expr_stmt|;
name|rxc
operator|->
name|hdlc_ib
operator|=
name|rxc
operator|->
name|hdlc_blevel
operator|=
name|rxc
operator|->
name|hdlc_flag
operator|=
literal|0
expr_stmt|;
name|txc
operator|->
name|hdlc_tmp
operator|=
name|txc
operator|->
name|hdlc_blevel
operator|=
name|txc
operator|->
name|hdlc_crc
operator|=
literal|0
expr_stmt|;
name|txc
operator|->
name|hdlc_ib
operator|=
literal|0
expr_stmt|;
name|txc
operator|->
name|hdlc_flag
operator|=
literal|2
expr_stmt|;
name|txc
operator|->
name|filled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_NONE
condition|)
name|fill_byte
operator|=
name|ITJC_TEL_SILENCE_BYTE
expr_stmt|;
else|else
name|fill_byte
operator|=
name|ITJC_HDLC_ABORT_BYTE
expr_stmt|;
name|ring_end
operator|=
name|rxc
operator|->
name|ring
operator|+
name|ITJC_RING_BYTES
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|rxc
operator|->
name|ring
init|;
name|cp
operator|<
name|ring_end
condition|;
name|cp
operator|+=
literal|4
control|)
operator|*
name|cp
operator|=
name|fill_byte
expr_stmt|;
name|ring_end
operator|=
name|txc
operator|->
name|ring
operator|+
name|ITJC_RING_BYTES
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|txc
operator|->
name|ring
init|;
name|cp
operator|<
name|ring_end
condition|;
name|cp
operator|+=
literal|4
control|)
operator|*
name|cp
operator|=
name|fill_byte
expr_stmt|;
name|rxc
operator|->
name|next_read
operator|=
name|itjc_get_dma_offset
argument_list|(
name|rxc
argument_list|,
name|TIGER_DMA_RD_CURR_ADDR
argument_list|)
expr_stmt|;
name|txc
operator|->
name|next_frame
operator|=
name|txc
operator|->
name|next_write
operator|=
name|itjc_get_dma_offset
argument_list|(
name|txc
argument_list|,
name|TIGER_DMA_WR_CURR_ADDR
argument_list|)
expr_stmt|;
name|rxc
operator|->
name|state
operator|=
name|ITJC_RS_ACTIVE
expr_stmt|;
name|txc
operator|->
name|state
operator|=
name|ITJC_TS_AFTER_XDU
expr_stmt|;
block|}
else|else
block|{
name|dma_rx_context_t
modifier|*
name|rxc2
decl_stmt|;
name|txc
operator|->
name|state
operator|=
name|ITJC_TS_IDLE
expr_stmt|;
name|rxc
operator|->
name|state
operator|=
name|ITJC_RS_IDLE
expr_stmt|;
name|rxc2
operator|=
operator|&
name|dma_rx_context
index|[
name|sc
operator|->
name|sc_unit
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|rxc2
operator|->
name|state
operator|==
name|ITJC_RS_IDLE
operator|&&
name|rxc2
index|[
literal|1
index|]
operator|.
name|state
operator|==
name|ITJC_RS_IDLE
condition|)
name|itjc_dma_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Mbuf& if_queues management routines.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|u_int8_t
modifier|*
name|itjc_get_rx_mbuf
parameter_list|(
name|l1_bchan_state_t
modifier|*
name|chan
parameter_list|,
name|u_int8_t
modifier|*
modifier|*
name|dst_end_p
parameter_list|,
name|which_mb_t
name|which
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbuf
init|=
name|chan
operator|->
name|in_mbuf
decl_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
operator|&&
name|which
operator|==
name|ITJC_MB_NEW
condition|)
block|{
if|if
condition|(
operator|(
name|mbuf
operator|=
name|i4b_Bgetmbuf
argument_list|(
name|BCH_MAX_DATALEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"itjc_get_rx_mbuf: cannot allocate mbuf!"
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|=
name|mbuf
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|mbuf
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dst_end_p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mbuf
operator|!=
name|NULL
condition|)
operator|*
name|dst_end_p
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|mbuf
operator|->
name|m_data
operator|)
operator|+
name|BCH_MAX_DATALEN
expr_stmt|;
else|else
operator|*
name|dst_end_p
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|chan
operator|->
name|in_cbptr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|itjc_save_rx_mbuf
parameter_list|(
name|l1_bchan_state_t
modifier|*
name|chan
parameter_list|,
name|u_int8_t
modifier|*
name|dst
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbuf
init|=
name|chan
operator|->
name|in_mbuf
decl_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
operator|&&
name|mbuf
operator|!=
name|NULL
condition|)
block|{
name|chan
operator|->
name|in_cbptr
operator|=
name|dst
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
name|dst
operator|-
operator|(
name|u_int8_t
operator|*
operator|)
name|mbuf
operator|->
name|m_data
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dst
operator|==
name|NULL
operator|&&
name|mbuf
operator|==
name|NULL
condition|)
block|{
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"itjc_save_rx_mbuf: stale pointer dst=%p mbuf=%p "
literal|"in_cbptr=%p in_len=%d"
argument_list|,
name|dst
argument_list|,
name|mbuf
argument_list|,
name|chan
operator|->
name|in_cbptr
argument_list|,
name|chan
operator|->
name|in_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|itjc_free_rx_mbuf
parameter_list|(
name|l1_bchan_state_t
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbuf
init|=
name|chan
operator|->
name|in_mbuf
decl_stmt|;
if|if
condition|(
name|mbuf
operator|!=
name|NULL
condition|)
name|i4b_Bfreembuf
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|itjc_put_rx_mbuf
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|l1_bchan_state_t
modifier|*
name|chan
parameter_list|,
name|u_int16_t
name|len
parameter_list|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
init|=
name|chan
operator|->
name|in_mbuf
decl_stmt|;
name|u_int8_t
modifier|*
name|data
init|=
name|mbuf
operator|->
name|m_data
decl_stmt|;
name|int
name|activity
init|=
literal|1
decl_stmt|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mbuf
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_RX
condition|)
block|{
name|hdr
operator|.
name|unit
operator|=
name|L0ITJCUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|chan
operator|->
name|channel
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_NT
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|len
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_NONE
condition|)
block|{
name|activity
operator|=
operator|!
name|i4b_l1_bchan_tel_silence
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* move rx'd data to rx queue */
if|if
condition|(
operator|!
name|_IF_QFULL
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
argument_list|)
condition|)
block|{
name|IF_ENQUEUE
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i4b_Bfreembuf
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|chan
operator|->
name|rxcount
operator|+=
name|len
expr_stmt|;
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_rx_data_ready
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|activity
condition|)
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_activity
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|,
name|ACT_RX
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|itjc_free_tx_mbufs
parameter_list|(
name|chan
parameter_list|)
define|\
value|{									\ 	i4b_Bfreembuf((chan)->out_mbuf_head);				\ 	(chan)->out_mbuf_cur = (chan)->out_mbuf_head = NULL;		\ 	(chan)->out_mbuf_cur_ptr = NULL;				\ 	(chan)->out_mbuf_cur_len = 0;					\ }
end_define

begin_function
specifier|static
name|u_int16_t
name|itjc_get_tx_mbuf
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|l1_bchan_state_t
modifier|*
name|chan
parameter_list|,
name|u_int8_t
modifier|*
modifier|*
name|src_p
parameter_list|,
name|which_mb_t
name|which
parameter_list|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
init|=
name|chan
operator|->
name|out_mbuf_cur
decl_stmt|;
name|u_int8_t
name|activity
init|=
literal|1
decl_stmt|;
name|u_int16_t
name|len
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|ITJC_MB_CURR
case|:
if|if
condition|(
name|mbuf
operator|!=
name|NULL
condition|)
block|{
operator|*
name|src_p
operator|=
name|chan
operator|->
name|out_mbuf_cur_ptr
expr_stmt|;
return|return
name|chan
operator|->
name|out_mbuf_cur_len
return|;
block|}
break|break;
case|case
name|ITJC_MB_NEXT
case|:
if|if
condition|(
name|mbuf
operator|!=
name|NULL
condition|)
block|{
name|chan
operator|->
name|txcount
operator|+=
name|mbuf
operator|->
name|m_len
expr_stmt|;
name|mbuf
operator|=
name|mbuf
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|mbuf
operator|!=
name|NULL
condition|)
goto|goto
name|new_mbuf
goto|;
block|}
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
operator|*
name|src_p
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_head
operator|!=
name|NULL
condition|)
block|{
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
name|chan
operator|->
name|out_mbuf_head
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|ITJC_MB_NEW
case|:
if|if
condition|(
name|mbuf
operator|!=
name|NULL
condition|)
name|chan
operator|->
name|txcount
operator|+=
name|mbuf
operator|->
name|m_len
expr_stmt|;
block|}
if|if
condition|(
name|chan
operator|->
name|out_mbuf_head
operator|!=
name|NULL
condition|)
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
block|{
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_head
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
operator|*
name|src_p
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|state
operator|&=
operator|~
operator|(
name|HSCX_TX_ACTIVE
operator|)
expr_stmt|;
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_tx_queue_empty
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|chan
operator|->
name|out_mbuf_head
operator|=
name|mbuf
expr_stmt|;
name|new_mbuf
label|:
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|mbuf
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|data
operator|=
name|mbuf
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
name|len
operator|=
name|mbuf
operator|->
name|m_len
expr_stmt|;
name|chan
operator|->
name|state
operator||=
name|HSCX_TX_ACTIVE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_TX
condition|)
block|{
name|hdr
operator|.
name|unit
operator|=
name|L0ITJCUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|chan
operator|->
name|channel
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_TE
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|i4b_l1_trace_ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|len
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_NONE
condition|)
name|activity
operator|=
operator|!
name|i4b_l1_bchan_tel_silence
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|activity
condition|)
call|(
modifier|*
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|bch_activity
call|)
argument_list|(
name|chan
operator|->
name|isic_drvr_linktab
operator|->
name|unit
argument_list|,
name|ACT_TX
argument_list|)
expr_stmt|;
operator|*
name|src_p
operator|=
name|data
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_define
define|#
directive|define
name|itjc_save_tx_mbuf
parameter_list|(
name|chan
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
define|\
value|(									\ 	(chan)->out_mbuf_cur != NULL ?					\ 	(								\ 		(chan)->out_mbuf_cur_ptr = (src),			\ 		(chan)->out_mbuf_cur_len = (len)			\ 	)								\ 	:								\ 		0							\ )
end_define

begin_comment
comment|/*---------------------------------------------------------------------------*  *	B-channel interrupt service routines.  *---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  * Since the Tiger ASIC doesn't produce a XMIT underflow indication,  * we need to deduce it ourselves. This is somewhat tricky because we  * are dealing with modulo m arithmetic. The idea here is to have a  * "XDU zone" ahead of the writing pointer sized 1/3 of total ring  * length (a ring slot). If the hardware DMA pointer is found there we  * consider that a XDU has occurred. To complete the scheme, we never  * let the ring have more than 2 slots of (unsent) data and adjust the  * interrupt registers to cause an interrupt at every slot.  */
end_comment

begin_function
specifier|static
name|u_int8_t
name|itjc_xdu
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|l1_bchan_state_t
modifier|*
name|chan
parameter_list|,
name|dma_tx_context_t
modifier|*
name|ctx
parameter_list|,
name|u_int16_t
modifier|*
name|dst_p
parameter_list|,
name|u_int16_t
modifier|*
name|dst_end_p
parameter_list|,
name|u_int8_t
name|tx_restart
parameter_list|)
block|{
name|u_int8_t
name|xdu
decl_stmt|;
name|u_int16_t
name|dst_end
decl_stmt|,
name|dst
decl_stmt|,
name|dma
decl_stmt|,
name|dma_l
decl_stmt|,
name|dma_h
decl_stmt|,
name|xdu_l
decl_stmt|,
name|xdu_h
decl_stmt|;
name|itjc_bus_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Since the hardware is running, be conservative and assume 	 * the pointer location has a `fuzy' error factor. 	 */
name|dma
operator|=
name|itjc_get_dma_offset
argument_list|(
name|ctx
argument_list|,
name|TIGER_DMA_WR_CURR_ADDR
argument_list|)
expr_stmt|;
name|dma_l
operator|=
name|dma
expr_stmt|;
name|dma_h
operator|=
name|itjc_ring_add
argument_list|(
name|dma
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dst_end
operator|=
name|itjc_ring_sub
argument_list|(
name|dma_l
argument_list|,
name|ITJC_RING_SLOT_WORDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|state
operator|!=
name|ITJC_TS_ACTIVE
condition|)
block|{
name|xdu
operator|=
operator|(
name|ctx
operator|->
name|state
operator|==
name|ITJC_TS_AFTER_XDU
operator|)
expr_stmt|;
name|dst
operator|=
name|itjc_ring_add
argument_list|(
name|dma_h
argument_list|,
literal|4
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Check for xmit underruns. 	 */
name|xdu_l
operator|=
name|dst
operator|=
name|ctx
operator|->
name|next_write
expr_stmt|;
name|xdu_h
operator|=
name|itjc_ring_add
argument_list|(
name|dst
argument_list|,
name|ITJC_RING_SLOT_WORDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdu_l
operator|<
name|xdu_h
condition|)
name|xdu
operator|=
operator|(
name|xdu_l
operator|<=
name|dma_l
operator|&&
name|dma_l
operator|<
name|xdu_h
operator|)
operator|||
operator|(
name|xdu_l
operator|<=
name|dma_h
operator|&&
name|dma_h
operator|<
name|xdu_h
operator|)
expr_stmt|;
else|else
name|xdu
operator|=
operator|(
name|xdu_l
operator|<=
name|dma_l
operator|||
name|dma_l
operator|<
name|xdu_h
operator|)
operator|||
operator|(
name|xdu_l
operator|<=
name|dma_h
operator|||
name|dma_h
operator|<
name|xdu_h
operator|)
expr_stmt|;
if|if
condition|(
name|xdu
condition|)
block|{
name|ctx
operator|->
name|state
operator|=
name|ITJC_TS_AFTER_XDU
expr_stmt|;
name|dst
operator|=
name|itjc_ring_add
argument_list|(
name|dma_h
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tx_restart
condition|)
block|{
comment|/* 		 * See if we still can restart from immediately 		 * after the last frame sent. It's a XDU test but 		 * using the real data end on the comparsions. We 		 * don't consider XDU an error here because we were 		 * just trying to avoid send a filling gap between 		 * frames. If it's already sent no harm is done. 		 */
name|xdu_l
operator|=
name|dst
operator|=
name|ctx
operator|->
name|next_frame
expr_stmt|;
name|xdu_h
operator|=
name|itjc_ring_add
argument_list|(
name|dst
argument_list|,
name|ITJC_RING_SLOT_WORDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdu_l
operator|<
name|xdu_h
condition|)
name|xdu
operator|=
operator|(
name|xdu_l
operator|<=
name|dma_l
operator|&&
name|dma_l
operator|<
name|xdu_h
operator|)
operator|||
operator|(
name|xdu_l
operator|<=
name|dma_h
operator|&&
name|dma_h
operator|<
name|xdu_h
operator|)
expr_stmt|;
else|else
name|xdu
operator|=
operator|(
name|xdu_l
operator|<=
name|dma_l
operator|||
name|dma_l
operator|<
name|xdu_h
operator|)
operator|||
operator|(
name|xdu_l
operator|<=
name|dma_h
operator|||
name|dma_h
operator|<
name|xdu_h
operator|)
expr_stmt|;
if|if
condition|(
name|xdu
condition|)
name|dst
operator|=
name|itjc_ring_add
argument_list|(
name|dma_h
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|xdu
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|dst_p
operator|!=
name|NULL
condition|)
operator|*
name|dst_p
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|dst_end_p
operator|!=
name|NULL
condition|)
operator|*
name|dst_end_p
operator|=
name|dst_end
expr_stmt|;
name|ctx
operator|->
name|next_write
operator|=
name|dst_end
expr_stmt|;
return|return
name|xdu
return|;
block|}
end_function

begin_define
define|#
directive|define
name|itjc_rotate_hdlc_flag
parameter_list|(
name|blevel
parameter_list|)
define|\
value|((u_int8_t)(0x7E7E>> (8 - (u_int8_t)((blevel)>> 8))))
end_define

begin_function
specifier|static
name|void
name|itjc_dma_rx_intr
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|l1_bchan_state_t
modifier|*
name|chan
parameter_list|,
name|dma_rx_context_t
modifier|*
name|ctx
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|ring
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
name|dst_end
decl_stmt|,
name|flag
decl_stmt|,
name|blevel
decl_stmt|;
name|u_int16_t
name|dma
decl_stmt|,
name|src
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmp
decl_stmt|,
name|len
decl_stmt|,
name|crc
decl_stmt|,
name|ib
decl_stmt|;
name|itjc_bus_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|state
operator|==
name|ITJC_RS_IDLE
condition|)
return|return;
name|ring
operator|=
name|ctx
operator|->
name|ring
expr_stmt|;
name|dma
operator|=
name|itjc_get_dma_offset
argument_list|(
name|ctx
argument_list|,
name|TIGER_DMA_RD_CURR_ADDR
argument_list|)
expr_stmt|;
name|dma
operator|=
name|itjc_ring_sub
argument_list|(
name|dma
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|src
operator|=
name|ctx
operator|->
name|next_read
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_NONE
condition|)
block|{
name|dst
operator|=
name|itjc_get_rx_mbuf
argument_list|(
name|chan
argument_list|,
operator|&
name|dst_end
argument_list|,
name|ITJC_MB_CURR
argument_list|)
expr_stmt|;
while|while
condition|(
name|src
operator|!=
name|dma
condition|)
block|{
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
name|dst
operator|=
name|itjc_get_rx_mbuf
argument_list|(
name|chan
argument_list|,
operator|&
name|dst_end
argument_list|,
name|ITJC_MB_NEW
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|ring
index|[
name|src
index|]
expr_stmt|;
name|src
operator|=
name|itjc_ring_add
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|>=
name|dst_end
condition|)
block|{
name|itjc_put_rx_mbuf
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
name|BCH_MAX_DATALEN
argument_list|)
expr_stmt|;
name|dst
operator|=
name|dst_end
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|ctx
operator|->
name|next_read
operator|=
name|src
expr_stmt|;
name|itjc_save_rx_mbuf
argument_list|(
name|chan
argument_list|,
name|dst
argument_list|)
expr_stmt|;
return|return;
block|}
name|blevel
operator|=
name|ctx
operator|->
name|hdlc_blevel
expr_stmt|;
name|flag
operator|=
name|ctx
operator|->
name|hdlc_flag
expr_stmt|;
name|len
operator|=
name|ctx
operator|->
name|hdlc_len
expr_stmt|;
name|tmp
operator|=
name|ctx
operator|->
name|hdlc_tmp
expr_stmt|;
name|crc
operator|=
name|ctx
operator|->
name|hdlc_crc
expr_stmt|;
name|ib
operator|=
name|ctx
operator|->
name|hdlc_ib
expr_stmt|;
name|dst
operator|=
name|itjc_get_rx_mbuf
argument_list|(
name|chan
argument_list|,
name|NULL
argument_list|,
name|ITJC_MB_CURR
argument_list|)
expr_stmt|;
while|while
condition|(
name|src
operator|!=
name|dma
condition|)
block|{
name|HDLC_DECODE
argument_list|(
argument|*dst++
argument_list|,
argument|len
argument_list|,
argument|tmp
argument_list|,
argument|tmp2
argument_list|,
argument|blevel
argument_list|,
argument|ib
argument_list|,
argument|crc
argument_list|,
argument|flag
argument_list|,
argument|{
comment|/* rdd */
argument|tmp2 = ring[src]; 			src = itjc_ring_add(src,
literal|1
argument|); 		}
argument_list|,
argument|{
comment|/* nfr */
argument|if (dst != NULL) 				panic(
literal|"itjc_dma_rx_intr: nfrcmd with "
literal|"valid current frame"
argument|);  			dst = itjc_get_rx_mbuf(chan,&dst_end, ITJC_MB_NEW); 			len = dst_end - dst; 		}
argument_list|,
argument|{
comment|/* cfr */
argument|len = BCH_MAX_DATALEN - len;  			if ((!len) || (len> BCH_MAX_DATALEN)) 			{
comment|/* 				 * NOTE: frames without any data, only crc 				 * field, should be silently discared. 				 */
argument|NDBGL1(L1_S_MSG,
literal|"itjc_dma_rx_intr: "
literal|"bad frame (len=%d, unit=%d)"
argument|, 					len, sc->sc_unit);  				itjc_free_rx_mbuf(chan);  				goto s0; 			}  			if (crc) 			{ 				NDBGL1(L1_S_ERR,
literal|"CRC (crc=0x%04x, len=%d, unit=%d)"
argument|, 					crc, len, sc->sc_unit);  				itjc_free_rx_mbuf(chan);  				goto s0; 			}  			itjc_put_rx_mbuf(sc, chan, len);  		s0: 			dst = NULL; 			len =
literal|0
argument|; 		}
argument_list|,
argument|{
comment|/* rab */
argument|NDBGL1(L1_S_ERR,
literal|"Read Abort (unit=%d)"
argument|, sc->sc_unit);  			itjc_free_rx_mbuf(chan); 			dst = NULL; 			len =
literal|0
argument|; 		}
argument_list|,
argument|{
comment|/* rdo */
argument|NDBGL1(L1_S_ERR,
literal|"RDO (unit=%d) dma=%d src=%d"
argument|, 				sc->sc_unit, dma, src);  			itjc_free_rx_mbuf(chan); 			dst = NULL; 			len =
literal|0
argument|; 		}
argument_list|,
argument|continue
argument_list|,
argument|d
argument_list|)
empty_stmt|;
block|}
name|itjc_save_rx_mbuf
argument_list|(
name|chan
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|next_read
operator|=
name|src
expr_stmt|;
name|ctx
operator|->
name|hdlc_blevel
operator|=
name|blevel
expr_stmt|;
name|ctx
operator|->
name|hdlc_flag
operator|=
name|flag
expr_stmt|;
name|ctx
operator|->
name|hdlc_len
operator|=
name|len
expr_stmt|;
name|ctx
operator|->
name|hdlc_tmp
operator|=
name|tmp
expr_stmt|;
name|ctx
operator|->
name|hdlc_crc
operator|=
name|crc
expr_stmt|;
name|ctx
operator|->
name|hdlc_ib
operator|=
name|ib
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The HDLC side of itjc_dma_tx_intr. We made a separate function  * to improve readability and (perhaps) help the compiler with  * register allocation.  */
end_comment

begin_function
specifier|static
name|void
name|itjc_hdlc_encode
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|l1_bchan_state_t
modifier|*
name|chan
parameter_list|,
name|dma_tx_context_t
modifier|*
name|ctx
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|ring
decl_stmt|,
modifier|*
name|src
decl_stmt|,
name|xdu
decl_stmt|,
name|flag
decl_stmt|,
name|flag_byte
decl_stmt|,
name|tx_restart
decl_stmt|;
name|u_int16_t
name|saved_len
decl_stmt|,
name|dst_end
decl_stmt|,
name|dst_end1
decl_stmt|,
name|dst
decl_stmt|,
name|filled
decl_stmt|,
name|blevel
decl_stmt|,
name|tmp2
decl_stmt|,
name|len
decl_stmt|,
name|crc
decl_stmt|,
name|ib
decl_stmt|;
name|u_int32_t
name|tmp
decl_stmt|;
name|saved_len
operator|=
name|len
operator|=
name|itjc_get_tx_mbuf
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
operator|&
name|src
argument_list|,
name|ITJC_MB_CURR
argument_list|)
expr_stmt|;
name|filled
operator|=
name|ctx
operator|->
name|filled
expr_stmt|;
name|flag
operator|=
name|ctx
operator|->
name|hdlc_flag
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
operator|&&
name|flag
operator|==
literal|2
operator|&&
name|filled
operator|>=
name|ITJC_RING_WORDS
condition|)
return|return;
name|tx_restart
operator|=
operator|(
name|flag
operator|==
literal|2
operator|&&
name|src
operator|!=
name|NULL
operator|)
expr_stmt|;
name|xdu
operator|=
name|itjc_xdu
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
name|ctx
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|dst_end
argument_list|,
name|tx_restart
argument_list|)
expr_stmt|;
name|ring
operator|=
name|ctx
operator|->
name|ring
expr_stmt|;
name|ib
operator|=
name|ctx
operator|->
name|hdlc_ib
expr_stmt|;
name|crc
operator|=
name|ctx
operator|->
name|hdlc_crc
expr_stmt|;
name|tmp
operator|=
name|ctx
operator|->
name|hdlc_tmp
expr_stmt|;
name|blevel
operator|=
name|ctx
operator|->
name|hdlc_blevel
expr_stmt|;
if|if
condition|(
name|xdu
condition|)
block|{
if|if
condition|(
name|flag
operator|!=
literal|2
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"XDU"
argument_list|)
expr_stmt|;
operator|++
name|chan
operator|->
name|stat_XDU
expr_stmt|;
comment|/* 			 * Abort the current frame and  			 * prepare for a full restart. 			 */
name|itjc_free_tx_mbufs
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|saved_len
operator|=
name|len
operator|=
name|filled
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
operator|(
name|u_int8_t
operator|)
operator|-
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filled
operator|<
name|ITJC_RING_SLOT_WORDS
condition|)
block|{
comment|/* 			 * A little garbage may have been retransmitted. 			 * Send an abort before any new data. 			 */
name|filled
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
operator|(
name|u_int8_t
operator|)
operator|-
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag
operator|!=
literal|3
condition|)
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dst
operator|!=
name|dst_end
condition|)
block|{
name|HDLC_ENCODE
argument_list|(
argument|*src++
argument_list|,
argument|len
argument_list|,
argument|tmp
argument_list|,
argument|tmp2
argument_list|,
argument|blevel
argument_list|,
argument|ib
argument_list|,
argument|crc
argument_list|,
argument|flag
argument_list|,
argument|{
comment|/* gfr */
argument|if ((len = saved_len) ==
literal|0
argument|) 				len = itjc_get_tx_mbuf(sc, chan,&src, 					ITJC_MB_NEW);  			if (len ==
literal|0
argument|) 			{ 				ctx->next_frame = dst;  				flag_byte = itjc_rotate_hdlc_flag(blevel);  				for (dst_end1 = itjc_ring_sub(dst_end,
literal|1
argument|); 				dst != dst_end1; 				dst = itjc_ring_add(dst,
literal|1
argument|)) 				{ 					ring[dst] = flag_byte; 					++filled; 				} 			} 			else 				filled =
literal|0
argument|;  			ctx->state = ITJC_TS_ACTIVE; 		}
argument_list|,
argument|{
comment|/* nmb */
argument|saved_len =
literal|0
argument|; 			len = itjc_get_tx_mbuf(sc, chan,&src, ITJC_MB_NEXT); 		}
argument_list|,
argument|{
comment|/* wrd */
argument|ring[dst] = (u_int8_t)tmp; 			dst = itjc_ring_add(dst,
literal|1
argument|); 		}
argument_list|,
argument|d1
argument_list|)
empty_stmt|;
block|}
name|ctx
operator|->
name|hdlc_blevel
operator|=
name|blevel
expr_stmt|;
name|ctx
operator|->
name|hdlc_flag
operator|=
name|flag
expr_stmt|;
name|ctx
operator|->
name|hdlc_tmp
operator|=
name|tmp
expr_stmt|;
name|ctx
operator|->
name|hdlc_crc
operator|=
name|crc
expr_stmt|;
name|ctx
operator|->
name|hdlc_ib
operator|=
name|ib
expr_stmt|;
name|ctx
operator|->
name|filled
operator|=
name|filled
expr_stmt|;
name|ctx
operator|->
name|next_write
operator|=
name|dst
expr_stmt|;
name|itjc_save_tx_mbuf
argument_list|(
name|chan
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|itjc_dma_tx_intr
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|l1_bchan_state_t
modifier|*
name|chan
parameter_list|,
name|dma_tx_context_t
modifier|*
name|ctx
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|data_end
decl_stmt|,
modifier|*
name|ring
decl_stmt|,
modifier|*
name|src
decl_stmt|,
name|xdu
decl_stmt|;
name|u_int16_t
name|dst
decl_stmt|,
name|dst_end
decl_stmt|,
name|filled
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|state
operator|==
name|ITJC_TS_IDLE
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|chan
operator|->
name|bprot
operator|!=
name|BPROT_NONE
condition|)
block|{
name|itjc_hdlc_encode
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ring
operator|=
name|ctx
operator|->
name|ring
expr_stmt|;
name|filled
operator|=
name|ctx
operator|->
name|filled
expr_stmt|;
name|len
operator|=
name|itjc_get_tx_mbuf
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
operator|&
name|src
argument_list|,
name|ITJC_MB_CURR
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|filled
operator|>=
name|ITJC_RING_WORDS
condition|)
goto|goto
name|done
goto|;
name|xdu
operator|=
name|itjc_xdu
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
name|ctx
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|dst_end
argument_list|,
name|len
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdu
operator|&&
name|filled
operator|<
name|ITJC_RING_WORDS
condition|)
block|{
name|NDBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"XDU"
argument_list|)
expr_stmt|;
operator|++
name|chan
operator|->
name|stat_XDU
expr_stmt|;
name|filled
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|fill_ring
goto|;
name|ctx
operator|->
name|state
operator|=
name|ITJC_TS_ACTIVE
expr_stmt|;
name|data_end
operator|=
name|src
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|dst
operator|!=
name|dst_end
condition|)
block|{
name|ring
index|[
name|dst
index|]
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|--
name|len
expr_stmt|;
name|dst
operator|=
name|itjc_ring_add
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|>=
name|data_end
condition|)
block|{
name|len
operator|=
name|itjc_get_tx_mbuf
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
operator|&
name|src
argument_list|,
name|ITJC_MB_NEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|itjc_get_tx_mbuf
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
operator|&
name|src
argument_list|,
name|ITJC_MB_NEW
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|data_end
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|data_end
operator|=
name|src
operator|+
name|len
expr_stmt|;
block|}
block|}
name|itjc_save_tx_mbuf
argument_list|(
name|chan
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|filled
operator|=
literal|0
expr_stmt|;
name|fill_ring
label|:
name|ctx
operator|->
name|next_frame
operator|=
name|dst
expr_stmt|;
for|for
control|(
init|;
name|dst
operator|!=
name|dst_end
condition|;
name|dst
operator|=
name|itjc_ring_add
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|ring
index|[
name|dst
index|]
operator|=
name|ITJC_TEL_SILENCE_BYTE
expr_stmt|;
operator|++
name|filled
expr_stmt|;
block|}
name|ctx
operator|->
name|next_write
operator|=
name|dst
expr_stmt|;
name|ctx
operator|->
name|filled
operator|=
name|filled
expr_stmt|;
name|done
label|:
return|return;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	NetJet fifo read/write routines.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|itjc_read_fifo
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|itjc_bus_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|!=
name|ISIC_WHAT_ISAC
condition|)
name|panic
argument_list|(
literal|"itjc_write_fifo: Trying to read from HSCX fifo.\n"
argument_list|)
expr_stmt|;
name|itjc_set_pib_addr_msb
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|itjc_read_multi_1
argument_list|(
name|PIB_OFFSET
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|itjc_write_fifo
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|itjc_bus_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|!=
name|ISIC_WHAT_ISAC
condition|)
name|panic
argument_list|(
literal|"itjc_write_fifo: Trying to write to HSCX fifo.\n"
argument_list|)
expr_stmt|;
name|itjc_set_pib_addr_msb
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|itjc_write_multi_1
argument_list|(
name|PIB_OFFSET
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Read an ISAC register.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|u_int8_t
name|itjc_read_reg
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|)
block|{
name|itjc_bus_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|!=
name|ISIC_WHAT_ISAC
condition|)
block|{
name|panic
argument_list|(
literal|"itjc_read_reg: what(%d) != ISIC_WHAT_ISAC\n"
argument_list|,
name|what
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|itjc_set_pib_addr_msb
argument_list|(
name|offs
argument_list|)
expr_stmt|;
return|return
name|itjc_read_1
argument_list|(
name|itjc_pib_2_pci
argument_list|(
name|offs
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Write an ISAC register.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|itjc_write_reg
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|itjc_bus_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|!=
name|ISIC_WHAT_ISAC
condition|)
block|{
name|panic
argument_list|(
literal|"itjc_write_reg: what(%d) != ISIC_WHAT_ISAC\n"
argument_list|,
name|what
argument_list|)
expr_stmt|;
return|return;
block|}
name|itjc_set_pib_addr_msb
argument_list|(
name|offs
argument_list|)
expr_stmt|;
name|itjc_write_1
argument_list|(
name|itjc_pib_2_pci
argument_list|(
name|offs
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	itjc_probe - probe for a card.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|itjc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int16_t
name|vid
init|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|did
init|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|vid
operator|==
name|PCI_TJNET_VID
operator|)
operator|&&
operator|(
name|did
operator|==
name|PCI_TJ300_DID
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"NetJet-S"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	itjc_attach - attach a (previously probed) card.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|itjc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|bus_space_handle_t
name|h
decl_stmt|;
name|bus_space_tag_t
name|t
decl_stmt|;
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int16_t
name|vid
init|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|did
init|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|res_init_level
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|ih
init|=
literal|0
decl_stmt|;
name|dma_context_t
modifier|*
name|ctx
init|=
operator|&
name|dma_context
index|[
name|unit
index|]
decl_stmt|;
name|l1_bchan_state_t
modifier|*
name|chan
decl_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|l1_softc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Probably not really required. */
if|if
condition|(
name|unit
operator|>
name|ITJC_MAXUNIT
condition|)
block|{
name|printf
argument_list|(
literal|"itjc%d: Error, unit> ITJC_MAXUNIT!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|vid
operator|==
name|PCI_TJNET_VID
operator|&&
name|did
operator|==
name|PCI_TJ300_DID
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"itjc%d: unknown device (%04X,%04X)!\n"
argument_list|,
name|unit
argument_list|,
name|vid
argument_list|,
name|did
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|itjc_scp
index|[
name|unit
index|]
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_resources
operator|.
name|io_rid
index|[
literal|0
index|]
operator|=
name|PCIR_MAPS
operator|+
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|sc_resources
operator|.
name|io_rid
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"itjc%d: couldn't map IO port\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|h
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|t
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|++
name|res_init_level
expr_stmt|;
comment|/* Allocate interrupt. */
name|sc
operator|->
name|sc_resources
operator|.
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_resources
operator|.
name|irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|sc_resources
operator|.
name|irq_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_resources
operator|.
name|irq
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"itjc%d: couldn't map interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
operator|++
name|res_init_level
expr_stmt|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_resources
operator|.
name|irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|itjc_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"itjc%d: couldn't set up irq handler\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Reset the ASIC& the ISAC. 	 */
name|itjc_write_1
argument_list|(
name|TIGER_RESET_PIB_CL_TIME
argument_list|,
name|TIGER_RESET_ALL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* Give it 10 ms to reset ...*/
name|itjc_write_1
argument_list|(
name|TIGER_RESET_PIB_CL_TIME
argument_list|,
name|TIGER_SELF_ADDR_DMA
operator||
name|TIGER_PIB_3_CYCLES
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* ... and more 10 to recover. */
comment|/* 	 * First part of DMA initialization. Create& map the memory 	 * pool that will be used to bear the rx& tx ring buffers. 	 */
name|ctx
operator|->
name|state
operator|=
name|ITJC_DS_LOADING
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|4
argument_list|,
comment|/* alignment*/
literal|0
argument_list|,
comment|/* boundary*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr*/
name|NULL
argument_list|,
comment|/* filter*/
name|NULL
argument_list|,
comment|/* filterarg*/
name|ITJC_DMA_POOL_BYTES
argument_list|,
comment|/* maxsize*/
literal|1
argument_list|,
comment|/* nsegments*/
name|ITJC_DMA_POOL_BYTES
argument_list|,
comment|/* maxsegsz*/
name|BUS_DMA_ALLOCNOW
operator||
name|BUS_DMA_COHERENT
argument_list|,
comment|/* flags*/
operator|&
name|ctx
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"itjc%d: couldn't create bus DMA tag.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
operator|++
name|res_init_level
expr_stmt|;
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|ctx
operator|->
name|tag
argument_list|,
comment|/* DMA tag */
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ctx
operator|->
name|pool
argument_list|,
comment|/* KV addr of the allocated memory */
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|,
comment|/* flags */
operator|&
name|ctx
operator|->
name|map
argument_list|)
expr_stmt|;
comment|/* KV<-> PCI map */
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Load the KV<-> PCI map so the device sees the same 	 * memory segment as pointed by pool. Note: since the 	 * load may happen assyncronously (completion indicated by 	 * the execution of the callback function) we have to 	 * delay the initialization of the DMA engine to a moment we 	 * actually have the proper bus addresses to feed the Tiger 	 * and our DMA control blocks. This will be done in 	 * itjc_bchannel_setup via a call to itjc_dma_start. 	 */
name|bus_dmamap_load
argument_list|(
name|ctx
operator|->
name|tag
argument_list|,
comment|/* DMA tag */
name|ctx
operator|->
name|map
argument_list|,
comment|/* DMA map */
name|ctx
operator|->
name|pool
argument_list|,
comment|/* KV addr of buffer */
name|ITJC_DMA_POOL_BYTES
argument_list|,
comment|/* buffer size */
name|itjc_map_callback
argument_list|,
comment|/* this receive the bus addr/error */
name|ctx
argument_list|,
comment|/* callback aux arg */
literal|0
argument_list|)
expr_stmt|;
comment|/* flags */
operator|++
name|res_init_level
expr_stmt|;
comment|/* 	 * Setup the AUX port so we can talk to the ISAC. 	 */
name|itjc_write_1
argument_list|(
name|TIGER_AUX_PORT_CNTL
argument_list|,
name|TIGER_AUX_NJ_DEFAULT
argument_list|)
expr_stmt|;
name|itjc_write_1
argument_list|(
name|TIGER_INT1_MASK
argument_list|,
name|TIGER_ISAC_INT
argument_list|)
expr_stmt|;
comment|/* 	 * From now on, almost like a `normal' ISIC driver. 	 */
name|sc
operator|->
name|sc_unit
operator|=
name|unit
expr_stmt|;
name|ISAC_BASE
operator|=
operator|(
name|caddr_t
operator|)
name|ISIC_WHAT_ISAC
expr_stmt|;
name|HSCX_A_BASE
operator|=
operator|(
name|caddr_t
operator|)
name|ISIC_WHAT_HSCXA
expr_stmt|;
name|HSCX_B_BASE
operator|=
operator|(
name|caddr_t
operator|)
name|ISIC_WHAT_HSCXB
expr_stmt|;
comment|/* setup access routines */
name|sc
operator|->
name|clearirq
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|readreg
operator|=
name|itjc_read_reg
expr_stmt|;
name|sc
operator|->
name|writereg
operator|=
name|itjc_write_reg
expr_stmt|;
name|sc
operator|->
name|readfifo
operator|=
name|itjc_read_fifo
expr_stmt|;
name|sc
operator|->
name|writefifo
operator|=
name|itjc_write_fifo
expr_stmt|;
comment|/* setup card type */
name|sc
operator|->
name|sc_cardtyp
operator|=
name|CARD_TYPEP_NETJET_S
expr_stmt|;
comment|/* setup IOM bus type */
name|sc
operator|->
name|sc_bustyp
operator|=
name|BUS_TYPE_IOM2
expr_stmt|;
comment|/* set up some other miscellaneous things */
name|sc
operator|->
name|sc_ipac
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bfifolen
operator|=
literal|2
operator|*
name|ITJC_RING_SLOT_WORDS
expr_stmt|;
name|printf
argument_list|(
literal|"itjc%d: ISAC 2186 Version 1.1 (IOM-2)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* init the ISAC */
name|itjc_isac_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|chan
operator|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_A
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
operator|.
name|ifq_mtx
argument_list|)
condition|)
name|mtx_init
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"i4b_avma1pp_rx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
operator|.
name|ifq_mtx
argument_list|)
condition|)
name|mtx_init
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"i4b_avma1pp_tx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|chan
operator|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_B
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
operator|.
name|ifq_mtx
argument_list|)
condition|)
name|mtx_init
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"i4b_avma1pp_rx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
operator|.
name|ifq_mtx
argument_list|)
condition|)
name|mtx_init
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"i4b_avma1pp_tx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* init the "HSCX" */
name|itjc_bchannel_setup
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
name|HSCX_CH_A
argument_list|,
name|BPROT_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|itjc_bchannel_setup
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
name|HSCX_CH_B
argument_list|,
name|BPROT_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* can't use the normal B-Channel stuff */
name|itjc_init_linktab
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set trace level */
name|sc
operator|->
name|sc_trace
operator|=
name|TRACE_OFF
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ISAC_IDLE
expr_stmt|;
name|sc
operator|->
name|sc_ibuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ib
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_obuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_op
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ol
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_freeflag
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_obuf2
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_freeflag2
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_T3_callout
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_T4_callout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* init higher protocol layers */
name|i4b_l1_mph_status_ind
argument_list|(
name|L0ITJCUNIT
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
argument_list|,
name|STI_ATTACH
argument_list|,
name|sc
operator|->
name|sc_cardtyp
argument_list|,
operator|&
name|itjc_l1mux_func
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
switch|switch
condition|(
name|res_init_level
condition|)
block|{
case|case
literal|5
case|:
name|bus_dmamap_unload
argument_list|(
name|ctx
operator|->
name|tag
argument_list|,
name|ctx
operator|->
name|map
argument_list|)
expr_stmt|;
comment|/* FALL TRHU */
case|case
literal|4
case|:
name|bus_dmamem_free
argument_list|(
name|ctx
operator|->
name|tag
argument_list|,
name|ctx
operator|->
name|pool
argument_list|,
name|ctx
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|ctx
operator|->
name|tag
argument_list|,
name|ctx
operator|->
name|map
argument_list|)
expr_stmt|;
comment|/* FALL TRHU */
case|case
literal|3
case|:
name|bus_dma_tag_destroy
argument_list|(
name|ctx
operator|->
name|tag
argument_list|)
expr_stmt|;
comment|/* FALL TRHU */
case|case
literal|2
case|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_resources
operator|.
name|irq
argument_list|)
expr_stmt|;
comment|/* FALL TRHU */
case|case
literal|1
case|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|PCIR_MAPS
operator|+
literal|0
argument_list|,
name|sc
operator|->
name|sc_resources
operator|.
name|io_base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* FALL TRHU */
case|case
literal|0
case|:
break|break;
block|}
name|itjc_scp
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	itjc_intr - main interrupt service routine.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|itjc_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
literal|0
index|]
decl_stmt|;
name|dma_context_t
modifier|*
name|dma
init|=
operator|&
name|dma_context
index|[
name|sc
operator|->
name|sc_unit
index|]
decl_stmt|;
name|dma_rx_context_t
modifier|*
name|rxc
init|=
operator|&
name|dma_rx_context
index|[
name|sc
operator|->
name|sc_unit
index|]
index|[
literal|0
index|]
decl_stmt|;
name|dma_tx_context_t
modifier|*
name|txc
init|=
operator|&
name|dma_tx_context
index|[
name|sc
operator|->
name|sc_unit
index|]
index|[
literal|0
index|]
decl_stmt|;
name|itjc_bus_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Honor interrupts from successfully configured cards only. */
if|if
condition|(
name|dma
operator|->
name|state
operator|<
name|ITJC_DS_STOPPED
condition|)
return|return;
comment|/* First, we check the ISAC... */
if|if
condition|(
operator|!
operator|(
name|itjc_read_1
argument_list|(
name|TIGER_AUX_PORT_DATA
argument_list|)
operator|&
name|TIGER_ISAC_INT_MASK
operator|)
condition|)
block|{
name|itjc_write_1
argument_list|(
name|TIGER_INT1_STATUS
argument_list|,
name|TIGER_ISAC_INT
argument_list|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"ISAC"
argument_list|)
expr_stmt|;
name|itjc_isac_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* ... after what we always have a look at the DMA rings. */
name|NDBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"Tiger"
argument_list|)
expr_stmt|;
name|itjc_read_1
argument_list|(
name|TIGER_INT0_STATUS
argument_list|)
expr_stmt|;
name|itjc_write_1
argument_list|(
name|TIGER_INT0_STATUS
argument_list|,
name|TIGER_TARGET_ABORT_INT
operator||
name|TIGER_MASTER_ABORT_INT
operator||
name|TIGER_RD_END_INT
operator||
name|TIGER_RD_INT_INT
operator||
name|TIGER_WR_END_INT
operator||
name|TIGER_WR_INT_INT
argument_list|)
expr_stmt|;
name|itjc_dma_rx_intr
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
name|rxc
argument_list|)
expr_stmt|;
name|itjc_dma_tx_intr
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
name|txc
argument_list|)
expr_stmt|;
operator|++
name|chan
expr_stmt|;
operator|++
name|rxc
expr_stmt|;
operator|++
name|txc
expr_stmt|;
name|itjc_dma_rx_intr
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
name|rxc
argument_list|)
expr_stmt|;
name|itjc_dma_tx_intr
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
name|txc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	itjc_bchannel_setup - (Re)initialize and start/stop a Bchannel.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|itjc_bchannel_setup
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|int
name|bprot
parameter_list|,
name|int
name|activate
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|itjc_scp
index|[
name|unit
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|isic_find_sc
argument_list|(
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|int
name|s
init|=
name|SPLI4B
argument_list|()
decl_stmt|;
name|NDBGL1
argument_list|(
name|L1_BCHAN
argument_list|,
literal|"unit=%d, channel=%d, %s"
argument_list|,
name|unit
argument_list|,
name|h_chan
argument_list|,
name|activate
condition|?
literal|"activate"
else|:
literal|"deactivate"
argument_list|)
expr_stmt|;
comment|/* 	 * If we are deactivating the channel, we have to stop 	 * the DMA before we reset the channel control structures. 	 */
if|if
condition|(
operator|!
name|activate
condition|)
name|itjc_bchannel_dma_setup
argument_list|(
name|sc
argument_list|,
name|h_chan
argument_list|,
name|activate
argument_list|)
expr_stmt|;
comment|/* general part */
name|chan
operator|->
name|state
operator|=
name|HSCX_IDLE
expr_stmt|;
name|chan
operator|->
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
comment|/* unit number */
name|chan
operator|->
name|channel
operator|=
name|h_chan
expr_stmt|;
comment|/* B channel */
name|chan
operator|->
name|bprot
operator|=
name|bprot
expr_stmt|;
comment|/* B channel protocol */
comment|/* receiver part */
name|i4b_Bcleanifq
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
argument_list|)
expr_stmt|;
comment|/* clean rx queue */
name|chan
operator|->
name|rx_queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|chan
operator|->
name|rxcount
operator|=
literal|0
expr_stmt|;
comment|/* reset rx counter */
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|in_mbuf
argument_list|)
expr_stmt|;
comment|/* clean rx mbuf */
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
comment|/* reset mbuf ptr */
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
comment|/* reset mbuf curr ptr */
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
comment|/* reset mbuf data len */
comment|/* transmitter part */
name|i4b_Bcleanifq
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
argument_list|)
expr_stmt|;
comment|/* clean tx queue */
name|chan
operator|->
name|tx_queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|chan
operator|->
name|txcount
operator|=
literal|0
expr_stmt|;
comment|/* reset tx counter */
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
comment|/* clean tx mbuf */
name|chan
operator|->
name|out_mbuf_head
operator|=
name|NULL
expr_stmt|;
comment|/* reset head mbuf ptr */
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|NULL
expr_stmt|;
comment|/* reset current mbuf ptr */
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* reset current mbuf data ptr */
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
literal|0
expr_stmt|;
comment|/* reset current mbuf data cnt */
comment|/* 	 * Only setup& start the DMA after all other channel 	 * control structures are in place. 	 */
if|if
condition|(
name|activate
condition|)
name|itjc_bchannel_dma_setup
argument_list|(
name|sc
argument_list|,
name|h_chan
argument_list|,
name|activate
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	itjc_bchannel_start - Signal us we have more data to send.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|itjc_bchannel_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|)
block|{
if|#
directive|if
name|Buggy_code
comment|/* 	 * I disabled this routine because it was causing crashes when 	 * this driver was used with the ISP (kernel SPPP) protocol driver. 	 * The scenario is reproductible: 	 *	Use the -link1 (dial on demand) ifconfig option. 	 *	Start an interactive  TCP connection to somewhere. 	 *	Wait until the PPP connection times out and is dropped. 	 *	Try to send something on the TCP connection. 	 *	The machine will print some garbage and halt or reboot 	 *	(no panic messages). 	 * 	 * I've nailed down the problem to the fact that this routine 	 * was being called before the B channel had been setup again. 	 * 	 * For now, I don't have a good solution other than this one. 	 * But, don't despair. The impact of it is unnoticeable. 	 */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|itjc_scp
index|[
name|unit
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|isic_find_sc
argument_list|(
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|int
name|s
init|=
name|SPLI4B
argument_list|()
decl_stmt|;
name|dma_tx_context_t
modifier|*
name|txc
init|=
operator|&
name|dma_tx_context
index|[
name|unit
index|]
index|[
name|h_chan
index|]
decl_stmt|;
if|if
condition|(
name|chan
operator|->
name|state
operator|&
name|HSCX_TX_ACTIVE
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|itjc_dma_tx_intr
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|,
name|txc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	itjc_shutdown - Stop the driver and reset the card.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|itjc_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|itjc_bus_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Stop the DMA the nice and easy way. 	 */
name|itjc_bchannel_setup
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
literal|0
argument_list|,
name|BPROT_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|itjc_bchannel_setup
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
literal|1
argument_list|,
name|BPROT_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the card. 	 */
name|itjc_write_1
argument_list|(
name|TIGER_RESET_PIB_CL_TIME
argument_list|,
name|TIGER_RESET_ALL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* Give it 10 ms to reset ...*/
name|itjc_write_1
argument_list|(
name|TIGER_RESET_PIB_CL_TIME
argument_list|,
name|TIGER_SELF_ADDR_DMA
operator||
name|TIGER_LATCH_DMA_INT
operator||
name|TIGER_PIB_3_CYCLES
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* ... and more 10 to recover */
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	itjc_ret_linktab - Return the address of itjc drivers linktab.  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|isdn_link_t
modifier|*
name|itjc_ret_linktab
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|itjc_scp
index|[
name|unit
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|isic_find_sc
argument_list|(
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|channel
index|]
decl_stmt|;
return|return
operator|(
operator|&
name|chan
operator|->
name|isic_isdn_linktab
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	itjc_set_linktab - Set the driver linktab in the b channel softc.  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|itjc_set_linktab
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|channel
parameter_list|,
name|drvr_link_t
modifier|*
name|dlt
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|itjc_scp
index|[
name|unit
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|isic_find_sc
argument_list|(
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|channel
index|]
decl_stmt|;
name|chan
operator|->
name|isic_drvr_linktab
operator|=
name|dlt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	itjc_init_linktab - Initialize our local linktab.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|itjc_init_linktab
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_A
index|]
decl_stmt|;
name|isdn_link_t
modifier|*
name|lt
init|=
operator|&
name|chan
operator|->
name|isic_isdn_linktab
decl_stmt|;
comment|/* make sure the hardware driver is known to layer 4 */
comment|/* avoid overwriting if already set */
if|if
condition|(
name|ctrl_types
index|[
name|CTRL_PASSIVE
index|]
operator|.
name|set_linktab
operator|==
name|NULL
condition|)
block|{
name|ctrl_types
index|[
name|CTRL_PASSIVE
index|]
operator|.
name|set_linktab
operator|=
name|itjc_set_linktab
expr_stmt|;
name|ctrl_types
index|[
name|CTRL_PASSIVE
index|]
operator|.
name|get_linktab
operator|=
name|itjc_ret_linktab
expr_stmt|;
block|}
comment|/* local setup */
name|lt
operator|->
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|lt
operator|->
name|channel
operator|=
name|HSCX_CH_A
expr_stmt|;
name|lt
operator|->
name|bch_config
operator|=
name|itjc_bchannel_setup
expr_stmt|;
name|lt
operator|->
name|bch_tx_start
operator|=
name|itjc_bchannel_start
expr_stmt|;
name|lt
operator|->
name|bch_stat
operator|=
name|itjc_bchannel_stat
expr_stmt|;
name|lt
operator|->
name|tx_queue
operator|=
operator|&
name|chan
operator|->
name|tx_queue
expr_stmt|;
comment|/* used by non-HDLC data transfers, i.e. telephony drivers */
name|lt
operator|->
name|rx_queue
operator|=
operator|&
name|chan
operator|->
name|rx_queue
expr_stmt|;
comment|/* used by HDLC data transfers, i.e. ipr and isp drivers */
name|lt
operator|->
name|rx_mbuf
operator|=
operator|&
name|chan
operator|->
name|in_mbuf
expr_stmt|;
name|chan
operator|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_B
index|]
expr_stmt|;
name|lt
operator|=
operator|&
name|chan
operator|->
name|isic_isdn_linktab
expr_stmt|;
name|lt
operator|->
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|lt
operator|->
name|channel
operator|=
name|HSCX_CH_B
expr_stmt|;
name|lt
operator|->
name|bch_config
operator|=
name|itjc_bchannel_setup
expr_stmt|;
name|lt
operator|->
name|bch_tx_start
operator|=
name|itjc_bchannel_start
expr_stmt|;
name|lt
operator|->
name|bch_stat
operator|=
name|itjc_bchannel_stat
expr_stmt|;
name|lt
operator|->
name|tx_queue
operator|=
operator|&
name|chan
operator|->
name|tx_queue
expr_stmt|;
comment|/* used by non-HDLC data transfers, i.e. telephony drivers */
name|lt
operator|->
name|rx_queue
operator|=
operator|&
name|chan
operator|->
name|rx_queue
expr_stmt|;
comment|/* used by HDLC data transfers, i.e. ipr and isp drivers */
name|lt
operator|->
name|rx_mbuf
operator|=
operator|&
name|chan
operator|->
name|in_mbuf
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	itjc_bchannel_stat - Collect link statistics for a given B channel.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|itjc_bchannel_stat
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|bchan_statistics_t
modifier|*
name|bsp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|itjc_scp
index|[
name|unit
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|l1_softc
modifier|*
name|sc
init|=
name|isic_find_sc
argument_list|(
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|l1_bchan_state_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|SPLI4B
argument_list|()
expr_stmt|;
name|bsp
operator|->
name|outbytes
operator|=
name|chan
operator|->
name|txcount
expr_stmt|;
name|bsp
operator|->
name|inbytes
operator|=
name|chan
operator|->
name|rxcount
expr_stmt|;
name|chan
operator|->
name|txcount
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|rxcount
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Netjet - ISAC interrupt routine.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|itjc_isac_intr
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|register
name|u_char
name|irq_stat
decl_stmt|;
do|do
block|{
comment|/* get isac irq status */
name|irq_stat
operator|=
name|ISAC_READ
argument_list|(
name|I_ISTA
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq_stat
condition|)
name|itjc_isac_irq
argument_list|(
name|sc
argument_list|,
name|irq_stat
argument_list|)
expr_stmt|;
comment|/* isac handler */
block|}
do|while
condition|(
name|irq_stat
condition|)
do|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
name|ISAC_IMASK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	itjc_recover - Try to recover from ISAC irq lockup.  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|itjc_recover
parameter_list|(
name|struct
name|l1_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|byte
decl_stmt|;
comment|/* get isac irq status */
name|byte
operator|=
name|ISAC_READ
argument_list|(
name|I_ISTA
argument_list|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_ERROR
argument_list|,
literal|"  ISAC: ISTA = 0x%x"
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte
operator|&
name|ISAC_ISTA_EXI
condition|)
name|NDBGL1
argument_list|(
name|L1_ERROR
argument_list|,
literal|"  ISAC: EXIR = 0x%x"
argument_list|,
operator|(
name|u_char
operator|)
name|ISAC_READ
argument_list|(
name|I_EXIR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte
operator|&
name|ISAC_ISTA_CISQ
condition|)
block|{
name|byte
operator|=
name|ISAC_READ
argument_list|(
name|I_CIRR
argument_list|)
expr_stmt|;
name|NDBGL1
argument_list|(
name|L1_ERROR
argument_list|,
literal|"  ISAC: CISQ = 0x%x"
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte
operator|&
name|ISAC_CIRR_SQC
condition|)
name|NDBGL1
argument_list|(
name|L1_ERROR
argument_list|,
literal|"  ISAC: SQRR = 0x%x"
argument_list|,
operator|(
name|u_char
operator|)
name|ISAC_READ
argument_list|(
name|I_SQRR
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|NDBGL1
argument_list|(
name|L1_ERROR
argument_list|,
literal|"  ISAC: IMASK = 0x%x"
argument_list|,
name|ISAC_IMASK
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
name|ISAC_IMASK
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

