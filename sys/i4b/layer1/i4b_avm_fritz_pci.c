begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   Copyright (c) 1999 Gary Jennejohn. All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *   3. Neither the name of the author nor the names of any co-contributors  *      may be used to endorse or promote products derived from this software  *      without specific prior written permission.  *   4. Altered versions must be plainly marked as such, and must not be  *      misrepresented as being the original software and/or documentation.  *     *   THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  *   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  *   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  *   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  *   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  *   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  *   SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *   a lot of code was borrowed from i4b_bchan.c and i4b_hscx.c  *---------------------------------------------------------------------------  *  *	Fritz!Card PCI specific routines for isic driver  *	------------------------------------------------  *  *	$Id: i4b_avm_fritz_pci.c,v 1.5 1999/05/05 11:50:21 hm Exp $  *  *      last edit-date: [Tue Mar 16 16:18:35 1999]  *  *---------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"isic.h"
end_include

begin_include
include|#
directive|include
file|"opt_i4b.h"
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NISIC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NISIC
operator|>
literal|0
operator|&&
name|defined
argument_list|(
name|AVM_A1_PCI
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
end_if

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_comment
comment|/* for pcici_t */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD__
operator|<
literal|3
end_if

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcibus.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__< 3 */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<machine/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_ioctl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcidevs.h>
end_include

begin_include
include|#
directive|include
file|<i4b/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<i4b/i4b_ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i4b/include/i4b_global.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_l1l2.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_l1.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_isac.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_hscx.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_include
include|#
directive|include
file|<i4b/layer1/pci_isic.h>
end_include

begin_comment
comment|/* PCI config map to use (only one in this driver) */
end_comment

begin_define
define|#
directive|define
name|FRITZPCI_PORT0_MAPOFF
value|PCI_MAPREG_START+4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|avma1pp_disable
parameter_list|(
name|struct
name|isic_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function_decl
specifier|static
name|void
name|avma1pp_intr
parameter_list|(
name|struct
name|isic_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_disable
parameter_list|(
name|struct
name|isic_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|avma1pp_map_int
parameter_list|(
name|pcici_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|unsigned
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hscx_write_reg
parameter_list|(
name|int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|struct
name|isic_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
name|hscx_read_reg
parameter_list|(
name|int
parameter_list|,
name|u_int
parameter_list|,
name|struct
name|isic_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|hscx_read_reg_int
parameter_list|(
name|int
parameter_list|,
name|u_int
parameter_list|,
name|struct
name|isic_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hscx_read_fifo
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|isic_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hscx_write_fifo
parameter_list|(
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|isic_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_hscx_int_handler
parameter_list|(
name|struct
name|isic_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_hscx_intr
parameter_list|(
name|int
parameter_list|,
name|u_int
parameter_list|,
name|struct
name|isic_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_init_linktab
parameter_list|(
name|struct
name|isic_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_bchannel_setup
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_bchannel_start
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_hscx_init
parameter_list|(
name|struct
name|isic_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_bchannel_stat
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|bchan_statistics_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_set_linktab
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|drvr_link_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isdn_link_t
modifier|*
name|avma1pp_ret_linktab
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|isic_attach_avma1pp
parameter_list|(
name|int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|isicintr_sc
parameter_list|(
name|struct
name|isic_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|avma1pp_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_read_fifo
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_write_fifo
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_write_reg
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|avma1pp_read_reg
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hscx_write_fifo
parameter_list|(
name|int
name|chan
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hscx_read_fifo
parameter_list|(
name|int
name|chan
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hscx_write_reg
parameter_list|(
name|int
name|chan
parameter_list|,
name|u_int
name|off
parameter_list|,
name|u_int
name|val
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
name|hscx_read_reg
parameter_list|(
name|int
name|chan
parameter_list|,
name|u_int
name|off
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|hscx_read_reg_int
parameter_list|(
name|int
name|chan
parameter_list|,
name|u_int
name|off
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_fifo
parameter_list|(
name|isic_Bchan_t
modifier|*
name|chan
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_bchannel_stat
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|bchan_statistics_t
modifier|*
name|bsp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_map_int
parameter_list|(
name|struct
name|pci_isic_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|pci_attach_args
modifier|*
name|pa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_bchannel_setup
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|int
name|bprot
parameter_list|,
name|int
name|activate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|avma1pp_init_linktab
parameter_list|(
name|struct
name|isic_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------------------------*  *	AVM PCI Fritz!Card special registers  *---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  *	register offsets from i/o base  */
end_comment

begin_define
define|#
directive|define
name|STAT0_OFFSET
value|0x02
end_define

begin_define
define|#
directive|define
name|STAT1_OFFSET
value|0x03
end_define

begin_define
define|#
directive|define
name|ADDR_REG_OFFSET
value|0x04
end_define

begin_comment
comment|/*#define MODREG_OFFSET		0x06 #define VERREG_OFFSET           0x07*/
end_comment

begin_comment
comment|/* these 2 are used to select an ISAC register set */
end_comment

begin_define
define|#
directive|define
name|ISAC_LO_REG_OFFSET
value|0x04
end_define

begin_define
define|#
directive|define
name|ISAC_HI_REG_OFFSET
value|0x06
end_define

begin_comment
comment|/* offset higher than this goes to the HI register set */
end_comment

begin_define
define|#
directive|define
name|MAX_LO_REG_OFFSET
value|0x2f
end_define

begin_comment
comment|/* mask for the offset */
end_comment

begin_define
define|#
directive|define
name|ISAC_REGSET_MASK
value|0x0f
end_define

begin_comment
comment|/* the offset from the base to the ISAC registers */
end_comment

begin_define
define|#
directive|define
name|ISAC_REG_OFFSET
value|0x10
end_define

begin_comment
comment|/* the offset from the base to the ISAC FIFO */
end_comment

begin_define
define|#
directive|define
name|ISAC_FIFO
value|0x02
end_define

begin_comment
comment|/* not really the HSCX, but sort of */
end_comment

begin_define
define|#
directive|define
name|HSCX_FIFO
value|0x00
end_define

begin_define
define|#
directive|define
name|HSCX_STAT
value|0x04
end_define

begin_comment
comment|/*  *	AVM PCI Status Latch 0 read only bits  */
end_comment

begin_define
define|#
directive|define
name|ASL_IRQ_ISAC
value|0x01
end_define

begin_comment
comment|/* ISAC  interrupt, active low */
end_comment

begin_define
define|#
directive|define
name|ASL_IRQ_HSCX
value|0x02
end_define

begin_comment
comment|/* HSX   interrupt, active low */
end_comment

begin_define
define|#
directive|define
name|ASL_IRQ_TIMER
value|0x04
end_define

begin_comment
comment|/* Timer interrupt, active low */
end_comment

begin_define
define|#
directive|define
name|ASL_IRQ_BCHAN
value|ASL_IRQ_HSCX
end_define

begin_comment
comment|/* actually active LOW */
end_comment

begin_define
define|#
directive|define
name|ASL_IRQ_Pending
value|(ASL_IRQ_ISAC | ASL_IRQ_HSCX | ASL_IRQ_TIMER)
end_define

begin_comment
comment|/*  *	AVM Status Latch 0 write only bits  */
end_comment

begin_define
define|#
directive|define
name|ASL_RESET_ALL
value|0x01
end_define

begin_comment
comment|/* reset siemens IC's, active 1 */
end_comment

begin_define
define|#
directive|define
name|ASL_TIMERDISABLE
value|0x02
end_define

begin_comment
comment|/* active high */
end_comment

begin_define
define|#
directive|define
name|ASL_TIMERRESET
value|0x04
end_define

begin_comment
comment|/* active high */
end_comment

begin_define
define|#
directive|define
name|ASL_ENABLE_INT
value|0x08
end_define

begin_comment
comment|/* active high */
end_comment

begin_define
define|#
directive|define
name|ASL_TESTBIT
value|0x10
end_define

begin_comment
comment|/* active high */
end_comment

begin_comment
comment|/*  *	AVM Status Latch 1 write only bits  */
end_comment

begin_define
define|#
directive|define
name|ASL1_INTSEL
value|0x0f
end_define

begin_comment
comment|/* active high */
end_comment

begin_define
define|#
directive|define
name|ASL1_ENABLE_IOM
value|0x80
end_define

begin_comment
comment|/* active high */
end_comment

begin_comment
comment|/*  * "HSCX" mode bits  */
end_comment

begin_define
define|#
directive|define
name|HSCX_MODE_ITF_FLG
value|0x01
end_define

begin_define
define|#
directive|define
name|HSCX_MODE_TRANS
value|0x02
end_define

begin_define
define|#
directive|define
name|HSCX_MODE_CCR_7
value|0x04
end_define

begin_define
define|#
directive|define
name|HSCX_MODE_CCR_16
value|0x08
end_define

begin_define
define|#
directive|define
name|HSCX_MODE_TESTLOOP
value|0x80
end_define

begin_comment
comment|/*  * "HSCX" status bits  */
end_comment

begin_define
define|#
directive|define
name|HSCX_STAT_RME
value|0x01
end_define

begin_define
define|#
directive|define
name|HSCX_STAT_RDO
value|0x10
end_define

begin_define
define|#
directive|define
name|HSCX_STAT_CRCVFRRAB
value|0x0E
end_define

begin_define
define|#
directive|define
name|HSCX_STAT_CRCVFR
value|0x06
end_define

begin_define
define|#
directive|define
name|HSCX_STAT_RML_MASK
value|0x3f00
end_define

begin_comment
comment|/*  * "HSCX" interrupt bits  */
end_comment

begin_define
define|#
directive|define
name|HSCX_INT_XPR
value|0x80
end_define

begin_define
define|#
directive|define
name|HSCX_INT_XDU
value|0x40
end_define

begin_define
define|#
directive|define
name|HSCX_INT_RPR
value|0x20
end_define

begin_define
define|#
directive|define
name|HSCX_INT_MASK
value|0xE0
end_define

begin_comment
comment|/*  * "HSCX" command bits  */
end_comment

begin_define
define|#
directive|define
name|HSCX_CMD_XRS
value|0x80
end_define

begin_define
define|#
directive|define
name|HSCX_CMD_XME
value|0x01
end_define

begin_define
define|#
directive|define
name|HSCX_CMD_RRS
value|0x20
end_define

begin_define
define|#
directive|define
name|HSCX_CMD_XML_MASK
value|0x3f00
end_define

begin_comment
comment|/*  * Commands and parameters are sent to the "HSCX" as a long, but the  * fields are handled as bytes.  *  * The long contains:  *	(prot<< 16)|(txl<< 8)|cmd  *  * where:  *	prot = protocol to use  *	txl = transmit length  *	cmd = the command to be executed  *  * The fields are defined as u_char in struct isic_softc.  *  * Macro to coalesce the byte fields into a u_int  */
end_comment

begin_define
define|#
directive|define
name|AVMA1PPSETCMDLONG
parameter_list|(
name|f
parameter_list|)
value|(f) = ((sc->avma1pp_cmd) | (sc->avma1pp_txl<< 8) \  					| (sc->avma1pp_prot<< 16))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_comment
comment|/* "fake" addresses for the non-existent HSCX */
end_comment

begin_comment
comment|/* note: the unit number is in the lower byte for both the ISAC and "HSCX" */
end_comment

begin_define
define|#
directive|define
name|HSCX0FAKE
value|0xfa000
end_define

begin_comment
comment|/* read: fake0 */
end_comment

begin_define
define|#
directive|define
name|HSCX1FAKE
value|0xfa100
end_define

begin_comment
comment|/* read: fake1 */
end_comment

begin_define
define|#
directive|define
name|IS_HSCX_MASK
value|0xfff00
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/*  * to prevent deactivating the "HSCX" when both channels are active we  * define an HSCX_ACTIVE flag which is or'd into the channel's state  * flag in avma1pp_bchannel_setup upon active and cleared upon deactivation.  * It is set high to allow room for new flags.  */
end_comment

begin_define
define|#
directive|define
name|HSCX_AVMA1PP_ACTIVE
value|0x1000
end_define

begin_comment
comment|/*---------------------------------------------------------------------------*  *	AVM read fifo routines  *---------------------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
specifier|static
name|void
name|avma1pp_read_fifo
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
specifier|const
name|void
modifier|*
name|base
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|struct
name|isic_softc
modifier|*
name|sc
decl_stmt|;
name|unit
operator|=
operator|(
name|int
operator|)
name|base
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|=
operator|&
name|isic_sc
index|[
name|unit
index|]
expr_stmt|;
comment|/* check whether the target is an HSCX */
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|base
operator|&
name|IS_HSCX_MASK
operator|)
operator|==
name|HSCX0FAKE
condition|)
block|{
name|hscx_read_fifo
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|base
operator|&
name|IS_HSCX_MASK
operator|)
operator|==
name|HSCX1FAKE
condition|)
block|{
name|hscx_read_fifo
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* tell the board to access the ISAC fifo */
name|outb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|ADDR_REG_OFFSET
argument_list|,
name|ISAC_FIFO
argument_list|)
expr_stmt|;
name|insb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|ISAC_REG_OFFSET
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hscx_read_fifo
parameter_list|(
name|int
name|chan
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
modifier|*
name|ip
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|outl
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|ADDR_REG_OFFSET
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
name|u_int
operator|*
operator|)
name|buf
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
comment|/* what if len isn't a multiple of sizeof(int) and buf is */
comment|/* too small ???? */
while|while
condition|(
name|cnt
operator|<
name|len
condition|)
block|{
operator|*
name|ip
operator|++
operator|=
name|inl
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|ISAC_REG_OFFSET
argument_list|)
expr_stmt|;
name|cnt
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|avma1pp_read_fifo
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ADDR_REG_OFFSET
argument_list|,
name|ISAC_FIFO
argument_list|)
expr_stmt|;
name|bus_space_read_multi_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ISAC_REG_OFFSET
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|hscx_read_fifo
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|hscx_read_fifo
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hscx_read_fifo
parameter_list|(
name|int
name|chan
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|ip
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ADDR_REG_OFFSET
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|buf
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
comment|/* what if len isn't a multiple of sizeof(int) and buf is */
comment|/* too small ???? */
while|while
condition|(
name|cnt
operator|<
name|len
condition|)
block|{
operator|*
name|ip
operator|++
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ISAC_REG_OFFSET
argument_list|)
expr_stmt|;
name|cnt
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------------------------*  *	AVM write fifo routines  *---------------------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
specifier|static
name|void
name|avma1pp_write_fifo
parameter_list|(
name|void
modifier|*
name|base
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|struct
name|isic_softc
modifier|*
name|sc
decl_stmt|;
name|unit
operator|=
operator|(
name|int
operator|)
name|base
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|=
operator|&
name|isic_sc
index|[
name|unit
index|]
expr_stmt|;
comment|/* check whether the target is an HSCX */
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|base
operator|&
name|IS_HSCX_MASK
operator|)
operator|==
name|HSCX0FAKE
condition|)
block|{
name|hscx_write_fifo
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|base
operator|&
name|IS_HSCX_MASK
operator|)
operator|==
name|HSCX1FAKE
condition|)
block|{
name|hscx_write_fifo
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* tell the board to use the ISAC fifo */
name|outb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|ADDR_REG_OFFSET
argument_list|,
name|ISAC_FIFO
argument_list|)
expr_stmt|;
name|outsb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|ISAC_REG_OFFSET
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hscx_write_fifo
parameter_list|(
name|int
name|chan
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|register
name|u_int
modifier|*
name|ip
decl_stmt|;
specifier|register
name|size_t
name|cnt
decl_stmt|;
name|isic_Bchan_t
modifier|*
name|Bchan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|chan
index|]
decl_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|&=
operator|~
name|HSCX_CMD_XME
expr_stmt|;
name|sc
operator|->
name|avma1pp_txl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|sc
operator|->
name|sc_bfifolen
condition|)
block|{
if|if
condition|(
name|Bchan
operator|->
name|bprot
operator|!=
name|BPROT_NONE
condition|)
name|sc
operator|->
name|avma1pp_cmd
operator||=
name|HSCX_CMD_XME
expr_stmt|;
name|sc
operator|->
name|avma1pp_txl
operator|=
name|len
expr_stmt|;
block|}
name|cnt
operator|=
literal|0
expr_stmt|;
comment|/* borrow cnt */
name|AVMA1PPSETCMDLONG
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|cnt
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
name|u_int
operator|*
operator|)
name|buf
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cnt
operator|<
name|len
condition|)
block|{
name|outl
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|ISAC_REG_OFFSET
argument_list|,
operator|*
name|ip
operator|++
argument_list|)
expr_stmt|;
name|cnt
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|avma1pp_write_fifo
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ADDR_REG_OFFSET
argument_list|,
name|ISAC_FIFO
argument_list|)
expr_stmt|;
name|bus_space_write_multi_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ISAC_REG_OFFSET
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|hscx_write_fifo
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|hscx_write_fifo
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hscx_write_fifo
parameter_list|(
name|int
name|chan
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|ip
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|isic_Bchan_t
modifier|*
name|Bchan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|chan
index|]
decl_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|&=
operator|~
name|HSCX_CMD_XME
expr_stmt|;
name|sc
operator|->
name|avma1pp_txl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|sc
operator|->
name|sc_bfifolen
condition|)
block|{
if|if
condition|(
name|Bchan
operator|->
name|bprot
operator|!=
name|BPROT_NONE
condition|)
name|sc
operator|->
name|avma1pp_cmd
operator||=
name|HSCX_CMD_XME
expr_stmt|;
name|sc
operator|->
name|avma1pp_txl
operator|=
name|len
expr_stmt|;
block|}
name|cnt
operator|=
literal|0
expr_stmt|;
comment|/* borrow cnt */
name|AVMA1PPSETCMDLONG
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|cnt
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|buf
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cnt
operator|<
name|len
condition|)
block|{
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ISAC_REG_OFFSET
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|++
expr_stmt|;
name|cnt
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------------------------*  *	AVM write register routines  *---------------------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
specifier|static
name|void
name|avma1pp_write_reg
parameter_list|(
name|u_char
modifier|*
name|base
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|u_int
name|v
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|struct
name|isic_softc
modifier|*
name|sc
decl_stmt|;
name|u_char
name|reg_bank
decl_stmt|;
name|unit
operator|=
operator|(
name|int
operator|)
name|base
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|=
operator|&
name|isic_sc
index|[
name|unit
index|]
expr_stmt|;
comment|/* check whether the target is an HSCX */
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|base
operator|&
name|IS_HSCX_MASK
operator|)
operator|==
name|HSCX0FAKE
condition|)
block|{
name|hscx_write_reg
argument_list|(
literal|0
argument_list|,
name|offset
argument_list|,
name|v
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|base
operator|&
name|IS_HSCX_MASK
operator|)
operator|==
name|HSCX0FAKE
condition|)
block|{
name|hscx_write_reg
argument_list|(
literal|1
argument_list|,
name|offset
argument_list|,
name|v
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* must be the ISAC */
name|reg_bank
operator|=
operator|(
name|offset
operator|>
name|MAX_LO_REG_OFFSET
operator|)
condition|?
name|ISAC_HI_REG_OFFSET
else|:
name|ISAC_LO_REG_OFFSET
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"write_reg bank %d  off %d.. "
argument_list|,
name|reg_bank
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* set the register bank */
name|outb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|ADDR_REG_OFFSET
argument_list|,
name|reg_bank
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|ISAC_REG_OFFSET
operator|+
operator|(
name|offset
operator|&
name|ISAC_REGSET_MASK
operator|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hscx_write_reg
parameter_list|(
name|int
name|chan
parameter_list|,
name|u_int
name|off
parameter_list|,
name|u_int
name|val
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* HACK */
if|if
condition|(
name|off
operator|==
name|H_MASK
condition|)
return|return;
comment|/* point at the correct channel */
name|outl
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|ADDR_REG_OFFSET
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|ISAC_REG_OFFSET
operator|+
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|avma1pp_write_reg
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|u_char
name|reg_bank
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|reg_bank
operator|=
operator|(
name|offs
operator|>
name|MAX_LO_REG_OFFSET
operator|)
condition|?
name|ISAC_HI_REG_OFFSET
else|:
name|ISAC_LO_REG_OFFSET
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"write_reg bank %d  off %ld.. "
argument_list|,
operator|(
name|int
operator|)
name|reg_bank
argument_list|,
operator|(
name|long
operator|)
name|offs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* set the register bank */
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ADDR_REG_OFFSET
argument_list|,
name|reg_bank
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ISAC_REG_OFFSET
operator|+
operator|(
name|offs
operator|&
name|ISAC_REGSET_MASK
operator|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|hscx_write_reg
argument_list|(
literal|0
argument_list|,
name|offs
argument_list|,
name|data
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|hscx_write_reg
argument_list|(
literal|1
argument_list|,
name|offs
argument_list|,
name|data
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hscx_write_reg
parameter_list|(
name|int
name|chan
parameter_list|,
name|u_int
name|off
parameter_list|,
name|u_int
name|val
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* HACK */
if|if
condition|(
name|off
operator|==
name|H_MASK
condition|)
return|return;
comment|/* point at the correct channel */
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ADDR_REG_OFFSET
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ISAC_REG_OFFSET
operator|+
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------------------------*  *	AVM read register routines  *---------------------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
specifier|static
name|u_char
name|avma1pp_read_reg
parameter_list|(
name|u_char
modifier|*
name|base
parameter_list|,
name|u_int
name|offset
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|struct
name|isic_softc
modifier|*
name|sc
decl_stmt|;
name|u_char
name|reg_bank
decl_stmt|;
name|unit
operator|=
operator|(
name|int
operator|)
name|base
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|=
operator|&
name|isic_sc
index|[
name|unit
index|]
expr_stmt|;
comment|/* check whether the target is an HSCX */
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|base
operator|&
name|IS_HSCX_MASK
operator|)
operator|==
name|HSCX0FAKE
condition|)
return|return
operator|(
name|hscx_read_reg
argument_list|(
literal|0
argument_list|,
name|offset
argument_list|,
name|sc
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|base
operator|&
name|IS_HSCX_MASK
operator|)
operator|==
name|HSCX1FAKE
condition|)
return|return
operator|(
name|hscx_read_reg
argument_list|(
literal|1
argument_list|,
name|offset
argument_list|,
name|sc
argument_list|)
operator|)
return|;
comment|/* must be the ISAC */
name|reg_bank
operator|=
operator|(
name|offset
operator|>
name|MAX_LO_REG_OFFSET
operator|)
condition|?
name|ISAC_HI_REG_OFFSET
else|:
name|ISAC_LO_REG_OFFSET
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"read_reg bank %d  off %d.. "
argument_list|,
name|reg_bank
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* set the register bank */
name|outb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|ADDR_REG_OFFSET
argument_list|,
name|reg_bank
argument_list|)
expr_stmt|;
return|return
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|ISAC_REG_OFFSET
operator|+
operator|(
name|offset
operator|&
name|ISAC_REGSET_MASK
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|u_int8_t
name|avma1pp_read_reg
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|)
block|{
name|u_char
name|reg_bank
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|reg_bank
operator|=
operator|(
name|offs
operator|>
name|MAX_LO_REG_OFFSET
operator|)
condition|?
name|ISAC_HI_REG_OFFSET
else|:
name|ISAC_LO_REG_OFFSET
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"read_reg bank %d  off %ld.. "
argument_list|,
operator|(
name|int
operator|)
name|reg_bank
argument_list|,
operator|(
name|long
operator|)
name|offs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* set the register bank */
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ADDR_REG_OFFSET
argument_list|,
name|reg_bank
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ISAC_REG_OFFSET
operator|+
operator|(
name|offs
operator|&
name|ISAC_REGSET_MASK
operator|)
argument_list|)
operator|)
return|;
case|case
name|ISIC_WHAT_HSCXA
case|:
return|return
name|hscx_read_reg
argument_list|(
literal|0
argument_list|,
name|offs
argument_list|,
name|sc
argument_list|)
return|;
case|case
name|ISIC_WHAT_HSCXB
case|:
return|return
name|hscx_read_reg
argument_list|(
literal|1
argument_list|,
name|offs
argument_list|,
name|sc
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|u_char
name|hscx_read_reg
parameter_list|(
name|int
name|chan
parameter_list|,
name|u_int
name|off
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|hscx_read_reg_int
argument_list|(
name|chan
argument_list|,
name|off
argument_list|,
name|sc
argument_list|)
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * need to be able to return an int because the RBCH is in the 2nd  * byte.  */
end_comment

begin_function
specifier|static
name|u_int
name|hscx_read_reg_int
parameter_list|(
name|int
name|chan
parameter_list|,
name|u_int
name|off
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* HACK */
if|if
condition|(
name|off
operator|==
name|H_ISTA
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* point at the correct channel */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|outl
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|ADDR_REG_OFFSET
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|inl
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|ISAC_REG_OFFSET
operator|+
name|off
argument_list|)
operator|)
return|;
else|#
directive|else
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ADDR_REG_OFFSET
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ISAC_REG_OFFSET
operator|+
name|off
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	isic_attach_avma1pp - attach Fritz!Card PCI  *---------------------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
name|int
name|isic_attach_avma1pp
parameter_list|(
name|int
name|unit
parameter_list|,
name|u_int
name|iobase1
parameter_list|,
name|u_int
name|iobase2
parameter_list|)
block|{
name|struct
name|isic_softc
modifier|*
name|sc
init|=
operator|&
name|isic_sc
index|[
name|unit
index|]
decl_stmt|;
name|u_int
name|v
decl_stmt|;
comment|/* check max unit range */
if|if
condition|(
name|unit
operator|>=
name|ISIC_MAXUNIT
condition|)
block|{
name|printf
argument_list|(
literal|"isic%d: Error, unit %d>= ISIC_MAXUNIT for AVM FRITZ/PCI!\n"
argument_list|,
name|unit
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|sc_unit
operator|=
name|unit
expr_stmt|;
comment|/* setup iobase */
if|if
condition|(
operator|(
name|iobase1
operator|<=
literal|0
operator|)
operator|||
operator|(
name|iobase1
operator|>
literal|0xffff
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"isic%d: Error, invalid iobase 0x%x specified for AVM FRITZ/PCI!\n"
argument_list|,
name|unit
argument_list|,
name|iobase1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|sc_port
operator|=
name|iobase1
expr_stmt|;
comment|/* the ISAC lives at offset 0x10, but we can't use that. */
comment|/* instead, put the unit number into the lower byte - HACK */
name|sc
operator|->
name|sc_isac
operator|=
call|(
name|caddr_t
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|iobase1
operator|&
operator|~
literal|0xff
argument_list|)
operator|+
name|unit
argument_list|)
expr_stmt|;
comment|/* this thing doesn't have an HSCX, so fake the base addresses */
comment|/* put the unit number into the lower byte - HACK */
name|HSCX_A_BASE
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|HSCX0FAKE
operator|+
name|unit
argument_list|)
expr_stmt|;
name|HSCX_B_BASE
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|HSCX1FAKE
operator|+
name|unit
argument_list|)
expr_stmt|;
comment|/* setup access routines */
name|sc
operator|->
name|clearirq
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|readreg
operator|=
name|avma1pp_read_reg
expr_stmt|;
name|sc
operator|->
name|writereg
operator|=
name|avma1pp_write_reg
expr_stmt|;
name|sc
operator|->
name|readfifo
operator|=
name|avma1pp_read_fifo
expr_stmt|;
name|sc
operator|->
name|writefifo
operator|=
name|avma1pp_write_fifo
expr_stmt|;
comment|/* setup card type */
name|sc
operator|->
name|sc_cardtyp
operator|=
name|CARD_TYPEP_AVMA1PCI
expr_stmt|;
comment|/* setup IOM bus type */
name|sc
operator|->
name|sc_bustyp
operator|=
name|BUS_TYPE_IOM2
expr_stmt|;
comment|/* set up some other miscellaneous things */
name|sc
operator|->
name|sc_ipac
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bfifolen
operator|=
name|HSCX_FIFO_LEN
expr_stmt|;
comment|/* reset the card */
comment|/* the Linux driver does this to clear any pending ISAC interrupts */
name|v
operator|=
literal|0
expr_stmt|;
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_STAR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: I_STAR %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_MODE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: I_MODE %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_ADF2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: I_ADF2 %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_ISTA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: I_ISTA %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|v
operator|&
name|ISAC_ISTA_EXI
condition|)
block|{
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_EXIR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: I_EXIR %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_CIRR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: I_CIRR %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* the Linux driver does this to clear any pending HSCX interrupts */
name|v
operator|=
name|hscx_read_reg_int
argument_list|(
literal|0
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: 0 HSCX_STAT %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|hscx_read_reg_int
argument_list|(
literal|1
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: 1 HSCX_STAT %x\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|STAT0_OFFSET
argument_list|,
name|ASL_RESET_ALL
operator||
name|ASL_TIMERDISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* 10 ms */
name|outb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|STAT0_OFFSET
argument_list|,
name|ASL_TIMERRESET
operator||
name|ASL_ENABLE_INT
operator||
name|ASL_TIMERDISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* 10 ms */
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|outb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|STAT1_OFFSET
argument_list|,
name|ASL1_ENABLE_IOM
operator||
name|sc
operator|->
name|sc_irq
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* 10 ms */
name|printf
argument_list|(
literal|"after reset: S1 %#x\n"
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|STAT1_OFFSET
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|inl
argument_list|(
name|sc
operator|->
name|sc_port
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"isic_attach_avma1pp: v %#x\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* from here to the end would normally be done in isic_pciattach */
name|printf
argument_list|(
literal|"isic%d: ISAC %s (IOM-%c)\n"
argument_list|,
name|unit
argument_list|,
literal|"2085 Version A1/A2 or 2086/2186 Version 1.1"
argument_list|,
name|sc
operator|->
name|sc_bustyp
operator|==
name|BUS_TYPE_IOM1
condition|?
literal|'1'
else|:
literal|'2'
argument_list|)
expr_stmt|;
comment|/* init the ISAC */
name|isic_isac_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* init the "HSCX" */
name|avma1pp_bchannel_setup
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
name|HSCX_CH_A
argument_list|,
name|BPROT_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|avma1pp_bchannel_setup
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
name|HSCX_CH_B
argument_list|,
name|BPROT_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* can't use the normal B-Channel stuff */
name|avma1pp_init_linktab
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set trace level */
name|sc
operator|->
name|sc_trace
operator|=
name|TRACE_OFF
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ISAC_IDLE
expr_stmt|;
name|sc
operator|->
name|sc_ibuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ib
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_obuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_op
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ol
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_freeflag
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_obuf2
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_freeflag2
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_T3_callout
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_T4_callout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* init higher protocol layers */
name|MPH_Status_Ind
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
name|STI_ATTACH
argument_list|,
name|sc
operator|->
name|sc_cardtyp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|isic_attach_fritzPci
parameter_list|(
name|struct
name|pci_isic_softc
modifier|*
name|psc
parameter_list|,
name|struct
name|pci_attach_args
modifier|*
name|pa
parameter_list|)
block|{
name|struct
name|isic_softc
modifier|*
name|sc
init|=
operator|&
name|psc
operator|->
name|sc_isic
decl_stmt|;
name|u_int
name|v
decl_stmt|;
name|isic_sc
index|[
name|sc
operator|->
name|sc_unit
index|]
operator|=
name|sc
expr_stmt|;
comment|/* XXX - hack! */
comment|/* setup io mappings */
name|sc
operator|->
name|sc_num_mappings
operator|=
literal|1
expr_stmt|;
name|MALLOC_MAPS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pci_mapreg_map
argument_list|(
name|pa
argument_list|,
name|FRITZPCI_PORT0_MAPOFF
argument_list|,
name|PCI_MAPREG_TYPE_IO
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
operator|&
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't map i/o space\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* setup access routines */
name|sc
operator|->
name|clearirq
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|readreg
operator|=
name|avma1pp_read_reg
expr_stmt|;
name|sc
operator|->
name|writereg
operator|=
name|avma1pp_write_reg
expr_stmt|;
name|sc
operator|->
name|readfifo
operator|=
name|avma1pp_read_fifo
expr_stmt|;
name|sc
operator|->
name|writefifo
operator|=
name|avma1pp_write_fifo
expr_stmt|;
comment|/* setup card type */
name|sc
operator|->
name|sc_cardtyp
operator|=
name|CARD_TYPEP_AVMA1PCI
expr_stmt|;
comment|/* setup IOM bus type */
name|sc
operator|->
name|sc_bustyp
operator|=
name|BUS_TYPE_IOM2
expr_stmt|;
comment|/* this is no IPAC based card */
name|sc
operator|->
name|sc_ipac
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bfifolen
operator|=
name|HSCX_FIFO_LEN
expr_stmt|;
comment|/* init the card */
comment|/* the Linux driver does this to clear any pending ISAC interrupts */
comment|/* see if it helps any - XXXX */
name|v
operator|=
literal|0
expr_stmt|;
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_STAR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: I_STAR %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_MODE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: I_MODE %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_ADF2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: I_ADF2 %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_ISTA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: I_ISTA %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|v
operator|&
name|ISAC_ISTA_EXI
condition|)
block|{
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_EXIR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: I_EXIR %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|v
operator|=
name|ISAC_READ
argument_list|(
name|I_CIRR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: I_CIRR %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ISAC_WRITE
argument_list|(
name|I_MASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* the Linux driver does this to clear any pending HSCX interrupts */
name|v
operator|=
name|hscx_read_reg_int
argument_list|(
literal|0
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: 0 HSCX_STAT %x..."
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|hscx_read_reg_int
argument_list|(
literal|1
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|printf
argument_list|(
literal|"avma1pp_attach: 1 HSCX_STAT %x\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|STAT0_OFFSET
argument_list|,
name|ASL_RESET_ALL
operator||
name|ASL_TIMERDISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* 10 ms */
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|STAT0_OFFSET
argument_list|,
name|ASL_TIMERRESET
operator||
name|ASL_ENABLE_INT
operator||
name|ASL_TIMERDISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* 10 ms */
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|STAT1_OFFSET
argument_list|,
name|ASL1_ENABLE_IOM
operator||
name|sc
operator|->
name|sc_irq
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* 10 ms */
name|v
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|STAT1_OFFSET
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"after reset: S1 %#x\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"isic_attach_avma1pp: v %#x\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* setup i4b infrastructure (have to roll our own here) */
comment|/* sc->sc_isac_version = ((ISAC_READ(I_RBCH))>> 5)& 0x03; */
name|printf
argument_list|(
literal|"%s: ISAC %s (IOM-%c)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
literal|"2085 Version A1/A2 or 2086/2186 Version 1.1"
argument_list|,
name|sc
operator|->
name|sc_bustyp
operator|==
name|BUS_TYPE_IOM1
condition|?
literal|'1'
else|:
literal|'2'
argument_list|)
expr_stmt|;
comment|/* init the ISAC */
name|isic_isac_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* init the "HSCX" */
name|avma1pp_bchannel_setup
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
name|HSCX_CH_A
argument_list|,
name|BPROT_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|avma1pp_bchannel_setup
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
name|HSCX_CH_B
argument_list|,
name|BPROT_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* can't use the normal B-Channel stuff */
name|avma1pp_init_linktab
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set trace level */
name|sc
operator|->
name|sc_trace
operator|=
name|TRACE_OFF
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ISAC_IDLE
expr_stmt|;
name|sc
operator|->
name|sc_ibuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ib
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_obuf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_op
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_ol
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_freeflag
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_obuf2
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_freeflag2
operator|=
literal|0
expr_stmt|;
comment|/* init higher protocol layers */
name|MPH_Status_Ind
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
name|STI_ATTACH
argument_list|,
name|sc
operator|->
name|sc_cardtyp
argument_list|)
expr_stmt|;
comment|/* setup interrupt mapping */
name|avma1pp_map_int
argument_list|(
name|psc
argument_list|,
name|pa
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * this is the real interrupt routine  */
end_comment

begin_function
specifier|static
name|void
name|avma1pp_hscx_intr
parameter_list|(
name|int
name|h_chan
parameter_list|,
name|u_int
name|stat
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|register
name|isic_Bchan_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|int
name|activity
init|=
operator|-
literal|1
decl_stmt|;
name|u_int
name|param
init|=
literal|0
decl_stmt|;
name|DBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"avma1pp_hscx_intr"
argument_list|,
operator|(
literal|"%#x\n"
operator|,
name|stat
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|HSCX_INT_XDU
operator|)
operator|&&
operator|(
name|chan
operator|->
name|bprot
operator|!=
name|BPROT_NONE
operator|)
condition|)
comment|/* xmit data underrun */
block|{
name|chan
operator|->
name|stat_XDU
operator|++
expr_stmt|;
name|DBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"avma1pp_hscx_intr"
argument_list|,
operator|(
literal|"xmit data underrun\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* abort the transmission */
name|sc
operator|->
name|avma1pp_txl
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator||=
name|HSCX_CMD_XRS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|&=
operator|~
name|HSCX_CMD_XRS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_head
operator|!=
name|NULL
condition|)
comment|/* don't continue to transmit this buffer */
block|{
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * The following is based on examination of the Linux driver. 	 * 	 * The logic here is different than with a "real" HSCX; all kinds 	 * of information (interrupt/status bits) are in stat. 	 *		HSCX_INT_RPR indicates a receive interrupt 	 *			HSCX_STAT_RDO indicates an overrun condition, abort - 	 *			otherwise read the bytes ((stat& HSCX_STZT_RML_MASK)>> 8) 	 *			HSCX_STAT_RME indicates end-of-frame and apparently any 	 *			CRC/framing errors are only reported in this state. 	 *				if ((stat& HSCX_STAT_CRCVFRRAB) != HSCX_STAT_CRCVFR) 	 *					CRC/framing error 	 */
if|if
condition|(
name|stat
operator|&
name|HSCX_INT_RPR
condition|)
block|{
specifier|register
name|int
name|fifo_data_len
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* always have to read the FIFO, so use a scratch buffer */
name|u_char
name|scrbuf
index|[
name|HSCX_FIFO_LEN
index|]
decl_stmt|;
if|if
condition|(
name|stat
operator|&
name|HSCX_STAT_RDO
condition|)
block|{
name|chan
operator|->
name|stat_RDO
operator|++
expr_stmt|;
name|DBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"avma1pp_hscx_intr"
argument_list|,
operator|(
literal|"receive data overflow\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
name|fifo_data_len
operator|=
operator|(
operator|(
name|stat
operator|&
name|HSCX_STAT_RML_MASK
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|fifo_data_len
operator|==
literal|0
condition|)
name|fifo_data_len
operator|=
name|sc
operator|->
name|sc_bfifolen
expr_stmt|;
comment|/* ALWAYS read data from HSCX fifo */
name|HSCX_RDFIFO
argument_list|(
name|h_chan
argument_list|,
name|scrbuf
argument_list|,
name|fifo_data_len
argument_list|)
expr_stmt|;
name|chan
operator|->
name|rxcount
operator|+=
name|fifo_data_len
expr_stmt|;
comment|/* all error conditions checked, now decide and take action */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chan
operator|->
name|in_mbuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|chan
operator|->
name|in_mbuf
operator|=
name|i4b_Bgetmbuf
argument_list|(
name|BCH_MAX_DATALEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"L1 avma1pp_hscx_intr: RME, cannot allocate mbuf!\n"
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|chan
operator|->
name|in_len
operator|+
name|fifo_data_len
operator|)
operator|<=
name|BCH_MAX_DATALEN
condition|)
block|{
comment|/* OK to copy the data */
name|bcopy
argument_list|(
name|scrbuf
argument_list|,
name|chan
operator|->
name|in_cbptr
argument_list|,
name|fifo_data_len
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|+=
name|fifo_data_len
expr_stmt|;
name|chan
operator|->
name|in_len
operator|+=
name|fifo_data_len
expr_stmt|;
comment|/* setup mbuf data length */
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_RX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_NT
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|MPH_Trace_Ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|HSCX_STAT_RME
condition|)
block|{
if|if
condition|(
operator|(
name|stat
operator|&
name|HSCX_STAT_CRCVFRRAB
operator|)
operator|==
name|HSCX_STAT_CRCVFR
condition|)
block|{
call|(
modifier|*
name|chan
operator|->
name|drvr_linktab
operator|->
name|bch_rx_data_ready
call|)
argument_list|(
name|chan
operator|->
name|drvr_linktab
operator|->
name|unit
argument_list|)
expr_stmt|;
name|activity
operator|=
name|ACT_RX
expr_stmt|;
comment|/* mark buffer ptr as unused */
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|->
name|stat_CRC
operator|++
expr_stmt|;
name|DBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"avma1pp_hscx_intr"
argument_list|,
operator|(
literal|"CRC/RAB\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|in_mbuf
operator|!=
name|NULL
condition|)
block|{
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|in_mbuf
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* END enough space in mbuf */
else|else
block|{
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_NONE
condition|)
block|{
comment|/* setup mbuf data length */
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|chan
operator|->
name|in_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_RX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_NT
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|MPH_Trace_Ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
comment|/* move rx'd data to rx queue */
name|IF_ENQUEUE
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
argument_list|,
name|chan
operator|->
name|in_mbuf
argument_list|)
expr_stmt|;
call|(
modifier|*
name|chan
operator|->
name|drvr_linktab
operator|->
name|bch_rx_data_ready
call|)
argument_list|(
name|chan
operator|->
name|drvr_linktab
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|isic_hscx_silence
argument_list|(
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
argument_list|,
name|chan
operator|->
name|in_mbuf
operator|->
name|m_len
argument_list|)
operator|)
condition|)
name|activity
operator|=
name|ACT_RX
expr_stmt|;
comment|/* alloc new buffer */
if|if
condition|(
operator|(
name|chan
operator|->
name|in_mbuf
operator|=
name|i4b_Bgetmbuf
argument_list|(
name|BCH_MAX_DATALEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"L1 avma1pp_hscx_intr: RPF, cannot allocate new mbuf!\n"
argument_list|)
expr_stmt|;
comment|/* setup new data ptr */
name|chan
operator|->
name|in_cbptr
operator|=
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
expr_stmt|;
comment|/* OK to copy the data */
name|bcopy
argument_list|(
name|scrbuf
argument_list|,
name|chan
operator|->
name|in_cbptr
argument_list|,
name|fifo_data_len
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|+=
name|fifo_data_len
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
name|fifo_data_len
expr_stmt|;
name|chan
operator|->
name|rxcount
operator|+=
name|fifo_data_len
expr_stmt|;
block|}
else|else
block|{
name|DBGL1
argument_list|(
name|L1_H_XFRERR
argument_list|,
literal|"avma1pp_hscx_intr"
argument_list|,
operator|(
literal|"RAWHDLC rx buffer overflow in RPF, in_len=%d\n"
operator|,
name|chan
operator|->
name|in_len
operator|)
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|chan
operator|->
name|in_mbuf
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* if(error == 0) */
else|else
block|{
comment|/* land here for RDO */
if|if
condition|(
name|chan
operator|->
name|in_mbuf
operator|!=
name|NULL
condition|)
block|{
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|in_mbuf
argument_list|)
expr_stmt|;
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|avma1pp_txl
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator||=
name|HSCX_CMD_RRS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|&=
operator|~
name|HSCX_CMD_RRS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* transmit fifo empty, new data can be written to fifo */
if|if
condition|(
name|stat
operator|&
name|HSCX_INT_XPR
condition|)
block|{
comment|/* 		 * for a description what is going on here, please have 		 * a look at isic_bchannel_start() in i4b_bchan.c ! 		 */
name|DBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"avma1pp_hscx_intr"
argument_list|,
operator|(
literal|"unit %d, chan %d - XPR, Tx Fifo Empty!\n"
operator|,
name|sc
operator|->
name|sc_unit
operator|,
name|h_chan
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_cur
operator|==
name|NULL
condition|)
comment|/* last frame is transmitted */
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
argument_list|,
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_head
operator|==
name|NULL
condition|)
block|{
name|chan
operator|->
name|state
operator|&=
operator|~
name|HSCX_TX_ACTIVE
expr_stmt|;
call|(
modifier|*
name|chan
operator|->
name|drvr_linktab
operator|->
name|bch_tx_queue_empty
call|)
argument_list|(
name|chan
operator|->
name|drvr_linktab
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|->
name|state
operator||=
name|HSCX_TX_ACTIVE
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_head
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_TX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_TE
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|MPH_Trace_Ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_NONE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|isic_hscx_silence
argument_list|(
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|)
operator|)
condition|)
name|activity
operator|=
name|ACT_TX
expr_stmt|;
block|}
else|else
block|{
name|activity
operator|=
name|ACT_TX
expr_stmt|;
block|}
block|}
block|}
name|isic_hscx_fifo
argument_list|(
name|chan
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* call timeout handling routine */
if|if
condition|(
name|activity
operator|==
name|ACT_RX
operator|||
name|activity
operator|==
name|ACT_TX
condition|)
call|(
modifier|*
name|chan
operator|->
name|drvr_linktab
operator|->
name|bch_activity
call|)
argument_list|(
name|chan
operator|->
name|drvr_linktab
operator|->
name|unit
argument_list|,
name|activity
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this is the main routine which checks each channel and then calls  * the real interrupt routine as appropriate  */
end_comment

begin_function
specifier|static
name|void
name|avma1pp_hscx_int_handler
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|stat
decl_stmt|;
comment|/* has to be a u_int because the byte count is in the 2nd byte */
name|stat
operator|=
name|hscx_read_reg_int
argument_list|(
literal|0
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|HSCX_INT_MASK
condition|)
name|avma1pp_hscx_intr
argument_list|(
literal|0
argument_list|,
name|stat
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|stat
operator|=
name|hscx_read_reg_int
argument_list|(
literal|1
argument_list|,
name|HSCX_STAT
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|HSCX_INT_MASK
condition|)
name|avma1pp_hscx_intr
argument_list|(
literal|1
argument_list|,
name|stat
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|avma1pp_disable
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|outb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|STAT0_OFFSET
argument_list|,
name|ASL_RESET_ALL
operator||
name|ASL_TIMERDISABLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|STAT0_OFFSET
argument_list|,
name|ASL_RESET_ALL
operator||
name|ASL_TIMERDISABLE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
specifier|static
name|void
name|avma1pp_intr
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|OURS
comment|/* no return value accumulated */
define|#
directive|define
name|ISICINTR
parameter_list|(
name|sc
parameter_list|)
value|isicintr_sc(sc)
else|#
directive|else
specifier|static
name|int
name|avma1pp_intr
parameter_list|(
name|void
modifier|*
name|parm
parameter_list|)
block|{
name|struct
name|isic_softc
modifier|*
name|sc
init|=
name|parm
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|OURS
value|ret = 1
define|#
directive|define
name|ISICINTR
parameter_list|(
name|sc
parameter_list|)
value|isicintr(sc)
endif|#
directive|endif
name|u_char
name|stat
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|stat
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|STAT0_OFFSET
argument_list|)
expr_stmt|;
else|#
directive|else
name|stat
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|STAT0_OFFSET
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"avma1pp_intr"
argument_list|,
operator|(
literal|"stat %x\n"
operator|,
name|stat
operator|)
argument_list|)
expr_stmt|;
comment|/* was there an interrupt from this card ? */
if|if
condition|(
operator|(
name|stat
operator|&
name|ASL_IRQ_Pending
operator|)
operator|==
name|ASL_IRQ_Pending
condition|)
ifdef|#
directive|ifdef
name|__FreeBSD__
return|return;
comment|/* no */
else|#
directive|else
return|return
literal|0
return|;
comment|/* no */
endif|#
directive|endif
comment|/* interrupts are low active */
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|ASL_IRQ_TIMER
operator|)
condition|)
name|DBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"avma1pp_intr"
argument_list|,
operator|(
literal|"timer interrupt ???\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|ASL_IRQ_HSCX
operator|)
condition|)
block|{
name|DBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"avma1pp_intr"
argument_list|,
operator|(
literal|"HSCX\n"
operator|)
argument_list|)
expr_stmt|;
name|avma1pp_hscx_int_handler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|OURS
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|ASL_IRQ_ISAC
operator|)
condition|)
block|{
name|DBGL1
argument_list|(
name|L1_H_IRQ
argument_list|,
literal|"avma1pp_intr"
argument_list|,
operator|(
literal|"ISAC\n"
operator|)
argument_list|)
expr_stmt|;
name|ISICINTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|OURS
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|__FreeBSD__
return|return
name|ret
return|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|void
name|avma1pp_map_int
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|void
modifier|*
name|pisc
parameter_list|,
name|unsigned
modifier|*
name|net_imask
parameter_list|)
block|{
name|struct
name|isic_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|isic_softc
operator|*
operator|)
name|pisc
decl_stmt|;
ifdef|#
directive|ifdef
name|AVMA1PCI_DEBUG
comment|/* may need the irq later */
if|#
directive|if
name|__FreeBSD__
operator|<
literal|3
comment|/* I'd like to call getirq here, but it is static */
name|sc
operator|->
name|sc_irq
operator|=
name|PCI_INTERRUPT_LINE_EXTRACT
argument_list|(
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_irq
operator|==
literal|0xff
condition|)
name|printf
argument_list|(
literal|"avma1pp_map_int:int line register not set by bios\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq
operator|>=
name|PCI_MAX_IRQ
condition|)
name|printf
argument_list|(
literal|"avma1pp_map_int:irq %d out of bounds (must be< %d)\n"
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|PCI_MAX_IRQ
argument_list|)
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|sc_irq
operator|=
name|config_id
operator|->
name|intline
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* AVMA1PCI_DEBUG */
if|if
condition|(
operator|!
operator|(
name|pci_map_int
argument_list|(
name|config_id
argument_list|,
operator|(
name|void
operator|*
operator|)
name|avma1pp_intr
argument_list|,
name|sc
argument_list|,
name|net_imask
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to map interrupt for AVM Fritz!Card PCI\n"
argument_list|)
expr_stmt|;
comment|/* disable the card */
name|avma1pp_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
specifier|static
name|void
name|avma1pp_map_int
parameter_list|(
name|struct
name|pci_isic_softc
modifier|*
name|psc
parameter_list|,
name|struct
name|pci_attach_args
modifier|*
name|pa
parameter_list|)
block|{
name|struct
name|isic_softc
modifier|*
name|sc
init|=
operator|&
name|psc
operator|->
name|sc_isic
decl_stmt|;
name|pci_chipset_tag_t
name|pc
init|=
name|pa
operator|->
name|pa_pc
decl_stmt|;
name|pci_intr_handle_t
name|ih
decl_stmt|;
specifier|const
name|char
modifier|*
name|intrstr
decl_stmt|;
comment|/* Map and establish the interrupt. */
if|if
condition|(
name|pci_intr_map
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_intrtag
argument_list|,
name|pa
operator|->
name|pa_intrpin
argument_list|,
name|pa
operator|->
name|pa_intrline
argument_list|,
operator|&
name|ih
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: couldn't map interrupt\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|avma1pp_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|intrstr
operator|=
name|pci_intr_string
argument_list|(
name|pc
argument_list|,
name|ih
argument_list|)
expr_stmt|;
name|psc
operator|->
name|sc_ih
operator|=
name|pci_intr_establish
argument_list|(
name|pc
argument_list|,
name|ih
argument_list|,
name|IPL_NET
argument_list|,
name|avma1pp_intr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|psc
operator|->
name|sc_ih
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: couldn't establish interrupt"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|intrstr
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|" at %s"
argument_list|,
name|intrstr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|avma1pp_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%s: interrupting at %s\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|intrstr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
specifier|static
name|void
name|avma1pp_hscx_init
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|int
name|activate
parameter_list|)
block|{
name|isic_Bchan_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|u_int
name|param
init|=
literal|0
decl_stmt|;
name|DBGL1
argument_list|(
name|L1_BCHAN
argument_list|,
literal|"avma1pp_hscx_init"
argument_list|,
operator|(
literal|"unit=%d, channel=%d, %s\n"
operator|,
name|sc
operator|->
name|sc_unit
operator|,
name|h_chan
operator|,
name|activate
condition|?
literal|"activate"
else|:
literal|"deactivate"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|activate
operator|==
literal|0
condition|)
block|{
comment|/* only deactivate if both channels are idle */
if|if
condition|(
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_A
index|]
operator|.
name|state
operator|!=
name|HSCX_IDLE
operator|||
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_B
index|]
operator|.
name|state
operator|!=
name|HSCX_IDLE
condition|)
block|{
return|return;
block|}
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|HSCX_CMD_XRS
operator||
name|HSCX_CMD_RRS
expr_stmt|;
name|sc
operator|->
name|avma1pp_prot
operator|=
name|HSCX_MODE_TRANS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_RHDLC
condition|)
block|{
name|DBGL1
argument_list|(
name|L1_BCHAN
argument_list|,
literal|"avma1pp_hscx_init"
argument_list|,
operator|(
literal|"BPROT_RHDLC\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* HDLC Frames, transparent mode 0 */
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|HSCX_CMD_XRS
operator||
name|HSCX_CMD_RRS
expr_stmt|;
name|sc
operator|->
name|avma1pp_prot
operator|=
name|HSCX_MODE_ITF_FLG
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|HSCX_CMD_XRS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|DBGL1
argument_list|(
name|L1_BCHAN
argument_list|,
literal|"avma1pp_hscx_init"
argument_list|,
operator|(
literal|"BPROT_NONE??\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Raw Telephony, extended transparent mode 1 */
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|HSCX_CMD_XRS
operator||
name|HSCX_CMD_RRS
expr_stmt|;
name|sc
operator|->
name|avma1pp_prot
operator|=
name|HSCX_MODE_TRANS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|=
name|HSCX_CMD_XRS
expr_stmt|;
name|AVMA1PPSETCMDLONG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|hscx_write_reg
argument_list|(
name|h_chan
argument_list|,
name|HSCX_STAT
argument_list|,
name|param
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|avma1pp_cmd
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|avma1pp_bchannel_setup
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|int
name|bprot
parameter_list|,
name|int
name|activate
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|isic_softc
modifier|*
name|sc
init|=
operator|&
name|isic_sc
index|[
name|unit
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|isic_softc
modifier|*
name|sc
init|=
name|isic_find_sc
argument_list|(
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|isic_Bchan_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|int
name|s
init|=
name|SPLI4B
argument_list|()
decl_stmt|;
if|if
condition|(
name|activate
operator|==
literal|0
condition|)
block|{
comment|/* deactivation */
name|chan
operator|->
name|state
operator|&=
operator|~
name|HSCX_AVMA1PP_ACTIVE
expr_stmt|;
name|avma1pp_hscx_init
argument_list|(
name|sc
argument_list|,
name|h_chan
argument_list|,
name|activate
argument_list|)
expr_stmt|;
block|}
name|DBGL1
argument_list|(
name|L1_BCHAN
argument_list|,
literal|"avma1pp_bchannel_setup"
argument_list|,
operator|(
literal|"unit=%d, channel=%d, %s\n"
operator|,
name|sc
operator|->
name|sc_unit
operator|,
name|h_chan
operator|,
name|activate
condition|?
literal|"activate"
else|:
literal|"deactivate"
operator|)
argument_list|)
expr_stmt|;
comment|/* general part */
name|chan
operator|->
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
comment|/* unit number */
name|chan
operator|->
name|channel
operator|=
name|h_chan
expr_stmt|;
comment|/* B channel */
name|chan
operator|->
name|bprot
operator|=
name|bprot
expr_stmt|;
comment|/* B channel protocol */
name|chan
operator|->
name|state
operator|=
name|HSCX_IDLE
expr_stmt|;
comment|/* B channel state */
comment|/* receiver part */
name|i4b_Bcleanifq
argument_list|(
operator|&
name|chan
operator|->
name|rx_queue
argument_list|)
expr_stmt|;
comment|/* clean rx queue */
name|chan
operator|->
name|rx_queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|chan
operator|->
name|rxcount
operator|=
literal|0
expr_stmt|;
comment|/* reset rx counter */
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|in_mbuf
argument_list|)
expr_stmt|;
comment|/* clean rx mbuf */
name|chan
operator|->
name|in_mbuf
operator|=
name|NULL
expr_stmt|;
comment|/* reset mbuf ptr */
name|chan
operator|->
name|in_cbptr
operator|=
name|NULL
expr_stmt|;
comment|/* reset mbuf curr ptr */
name|chan
operator|->
name|in_len
operator|=
literal|0
expr_stmt|;
comment|/* reset mbuf data len */
comment|/* transmitter part */
name|i4b_Bcleanifq
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
argument_list|)
expr_stmt|;
comment|/* clean tx queue */
name|chan
operator|->
name|tx_queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|chan
operator|->
name|txcount
operator|=
literal|0
expr_stmt|;
comment|/* reset tx counter */
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
comment|/* clean tx mbuf */
name|chan
operator|->
name|out_mbuf_head
operator|=
name|NULL
expr_stmt|;
comment|/* reset head mbuf ptr */
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|NULL
expr_stmt|;
comment|/* reset current mbuf ptr */
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* reset current mbuf data ptr */
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
literal|0
expr_stmt|;
comment|/* reset current mbuf data cnt */
if|if
condition|(
name|activate
operator|!=
literal|0
condition|)
block|{
comment|/* activation */
name|avma1pp_hscx_init
argument_list|(
name|sc
argument_list|,
name|h_chan
argument_list|,
name|activate
argument_list|)
expr_stmt|;
name|chan
operator|->
name|state
operator||=
name|HSCX_AVMA1PP_ACTIVE
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|avma1pp_bchannel_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|isic_softc
modifier|*
name|sc
init|=
operator|&
name|isic_sc
index|[
name|unit
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|isic_softc
modifier|*
name|sc
init|=
name|isic_find_sc
argument_list|(
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|register
name|isic_Bchan_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|activity
init|=
operator|-
literal|1
decl_stmt|;
name|s
operator|=
name|SPLI4B
argument_list|()
expr_stmt|;
comment|/* enter critical section */
if|if
condition|(
name|chan
operator|->
name|state
operator|&
name|HSCX_TX_ACTIVE
condition|)
comment|/* already running ? */
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
comment|/* yes, leave */
block|}
comment|/* get next mbuf from queue */
name|IF_DEQUEUE
argument_list|(
operator|&
name|chan
operator|->
name|tx_queue
argument_list|,
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_head
operator|==
name|NULL
condition|)
comment|/* queue empty ? */
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* leave critical section */
return|return;
comment|/* yes, exit */
block|}
comment|/* init current mbuf values */
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_head
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
expr_stmt|;
comment|/* activity indicator for timeout handling */
if|if
condition|(
name|chan
operator|->
name|bprot
operator|==
name|BPROT_NONE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|isic_hscx_silence
argument_list|(
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|)
operator|)
condition|)
name|activity
operator|=
name|ACT_TX
expr_stmt|;
block|}
else|else
block|{
name|activity
operator|=
name|ACT_TX
expr_stmt|;
block|}
name|chan
operator|->
name|state
operator||=
name|HSCX_TX_ACTIVE
expr_stmt|;
comment|/* we start transmitting */
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_TX
condition|)
comment|/* if trace, send mbuf to trace dev */
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|unit
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|h_chan
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_TE
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|MPH_Trace_Ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
name|isic_hscx_fifo
argument_list|(
name|chan
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* call timeout handling routine */
if|if
condition|(
name|activity
operator|==
name|ACT_RX
operator|||
name|activity
operator|==
name|ACT_TX
condition|)
call|(
modifier|*
name|chan
operator|->
name|drvr_linktab
operator|->
name|bch_activity
call|)
argument_list|(
name|chan
operator|->
name|drvr_linktab
operator|->
name|unit
argument_list|,
name|activity
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	return the address of isic drivers linktab	  *---------------------------------------------------------------------------*/
specifier|static
name|isdn_link_t
modifier|*
name|avma1pp_ret_linktab
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|isic_softc
modifier|*
name|sc
init|=
operator|&
name|isic_sc
index|[
name|unit
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|isic_softc
modifier|*
name|sc
init|=
name|isic_find_sc
argument_list|(
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|isic_Bchan_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|channel
index|]
decl_stmt|;
return|return
operator|(
operator|&
name|chan
operator|->
name|isdn_linktab
operator|)
return|;
block|}
comment|/*---------------------------------------------------------------------------*  *	set the driver linktab in the b channel softc  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|avma1pp_set_linktab
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|channel
parameter_list|,
name|drvr_link_t
modifier|*
name|dlt
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|isic_softc
modifier|*
name|sc
init|=
operator|&
name|isic_sc
index|[
name|unit
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|isic_softc
modifier|*
name|sc
init|=
name|isic_find_sc
argument_list|(
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|isic_Bchan_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|channel
index|]
decl_stmt|;
name|chan
operator|->
name|drvr_linktab
operator|=
name|dlt
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	initialize our local linktab  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|avma1pp_init_linktab
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
block|{
name|isic_Bchan_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_A
index|]
decl_stmt|;
name|isdn_link_t
modifier|*
name|lt
init|=
operator|&
name|chan
operator|->
name|isdn_linktab
decl_stmt|;
comment|/* make sure the hardware driver is known to layer 4 */
comment|/* avoid overwriting if already set */
if|if
condition|(
name|ctrl_types
index|[
name|CTRL_PASSIVE
index|]
operator|.
name|set_linktab
operator|==
name|NULL
condition|)
block|{
name|ctrl_types
index|[
name|CTRL_PASSIVE
index|]
operator|.
name|set_linktab
operator|=
name|avma1pp_set_linktab
expr_stmt|;
name|ctrl_types
index|[
name|CTRL_PASSIVE
index|]
operator|.
name|get_linktab
operator|=
name|avma1pp_ret_linktab
expr_stmt|;
block|}
comment|/* local setup */
name|lt
operator|->
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|lt
operator|->
name|channel
operator|=
name|HSCX_CH_A
expr_stmt|;
name|lt
operator|->
name|bch_config
operator|=
name|avma1pp_bchannel_setup
expr_stmt|;
name|lt
operator|->
name|bch_tx_start
operator|=
name|avma1pp_bchannel_start
expr_stmt|;
name|lt
operator|->
name|bch_stat
operator|=
name|avma1pp_bchannel_stat
expr_stmt|;
name|lt
operator|->
name|tx_queue
operator|=
operator|&
name|chan
operator|->
name|tx_queue
expr_stmt|;
comment|/* used by non-HDLC data transfers, i.e. telephony drivers */
name|lt
operator|->
name|rx_queue
operator|=
operator|&
name|chan
operator|->
name|rx_queue
expr_stmt|;
comment|/* used by HDLC data transfers, i.e. ipr and isp drivers */
name|lt
operator|->
name|rx_mbuf
operator|=
operator|&
name|chan
operator|->
name|in_mbuf
expr_stmt|;
name|chan
operator|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|HSCX_CH_B
index|]
expr_stmt|;
name|lt
operator|=
operator|&
name|chan
operator|->
name|isdn_linktab
expr_stmt|;
name|lt
operator|->
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|lt
operator|->
name|channel
operator|=
name|HSCX_CH_B
expr_stmt|;
name|lt
operator|->
name|bch_config
operator|=
name|avma1pp_bchannel_setup
expr_stmt|;
name|lt
operator|->
name|bch_tx_start
operator|=
name|avma1pp_bchannel_start
expr_stmt|;
name|lt
operator|->
name|bch_stat
operator|=
name|avma1pp_bchannel_stat
expr_stmt|;
name|lt
operator|->
name|tx_queue
operator|=
operator|&
name|chan
operator|->
name|tx_queue
expr_stmt|;
comment|/* used by non-HDLC data transfers, i.e. telephony drivers */
name|lt
operator|->
name|rx_queue
operator|=
operator|&
name|chan
operator|->
name|rx_queue
expr_stmt|;
comment|/* used by HDLC data transfers, i.e. ipr and isp drivers */
name|lt
operator|->
name|rx_mbuf
operator|=
operator|&
name|chan
operator|->
name|in_mbuf
expr_stmt|;
block|}
comment|/*  * use this instead of isic_bchannel_stat in i4b_bchan.c because it's static  */
specifier|static
name|void
name|avma1pp_bchannel_stat
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|h_chan
parameter_list|,
name|bchan_statistics_t
modifier|*
name|bsp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|isic_softc
modifier|*
name|sc
init|=
operator|&
name|isic_sc
index|[
name|unit
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|isic_softc
modifier|*
name|sc
init|=
name|isic_find_sc
argument_list|(
name|unit
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|isic_Bchan_t
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_chan
index|[
name|h_chan
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|SPLI4B
argument_list|()
expr_stmt|;
name|bsp
operator|->
name|outbytes
operator|=
name|chan
operator|->
name|txcount
expr_stmt|;
name|bsp
operator|->
name|inbytes
operator|=
name|chan
operator|->
name|rxcount
expr_stmt|;
name|chan
operator|->
name|txcount
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|rxcount
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	fill HSCX fifo with data from the current mbuf  *	Put this here until it can go into i4b_hscx.c  *---------------------------------------------------------------------------*/
name|int
name|isic_hscx_fifo
parameter_list|(
name|isic_Bchan_t
modifier|*
name|chan
parameter_list|,
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|nextlen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|cmd
decl_stmt|;
comment|/* using a scratch buffer simplifies writing to the FIFO */
name|u_char
name|scrbuf
index|[
name|HSCX_FIFO_LEN
index|]
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * fill the HSCX tx fifo with data from the current mbuf. if 	 * current mbuf holds less data than HSCX fifo length, try to 	 * get the next mbuf from (a possible) mbuf chain. if there is 	 * not enough data in a single mbuf or in a chain, then this 	 * is the last mbuf and we tell the HSCX that it has to send 	 * CRC and closing flag 	 */
while|while
condition|(
name|chan
operator|->
name|out_mbuf_cur
operator|&&
name|len
operator|!=
name|sc
operator|->
name|sc_bfifolen
condition|)
block|{
name|nextlen
operator|=
name|min
argument_list|(
name|chan
operator|->
name|out_mbuf_cur_len
argument_list|,
name|sc
operator|->
name|sc_bfifolen
operator|-
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTDEF
name|printf
argument_list|(
literal|"i:mh=%p, mc=%p, mcp=%p, mcl=%d l=%d nl=%d # "
argument_list|,
name|chan
operator|->
name|out_mbuf_head
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
argument_list|,
name|chan
operator|->
name|out_mbuf_cur_ptr
argument_list|,
name|chan
operator|->
name|out_mbuf_cur_len
argument_list|,
name|len
argument_list|,
name|nextlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cmd
operator||=
name|HSCX_CMDR_XTF
expr_stmt|;
comment|/* collect the data in the scratch buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nextlen
condition|;
name|i
operator|++
control|)
name|scrbuf
index|[
name|i
operator|+
name|len
index|]
operator|=
name|chan
operator|->
name|out_mbuf_cur_ptr
index|[
name|i
index|]
expr_stmt|;
name|len
operator|+=
name|nextlen
expr_stmt|;
name|chan
operator|->
name|txcount
operator|+=
name|nextlen
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|+=
name|nextlen
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|-=
name|nextlen
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out_mbuf_cur_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|chan
operator|->
name|out_mbuf_cur
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_next
operator|)
operator|!=
name|NULL
condition|)
block|{
name|chan
operator|->
name|out_mbuf_cur_ptr
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
expr_stmt|;
name|chan
operator|->
name|out_mbuf_cur_len
operator|=
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_trace
operator|&
name|TRACE_B_TX
condition|)
block|{
name|i4b_trace_hdr_t
name|hdr
decl_stmt|;
name|hdr
operator|.
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|hdr
operator|.
name|type
operator|=
operator|(
name|chan
operator|->
name|channel
operator|==
name|HSCX_CH_A
condition|?
name|TRC_CH_B1
else|:
name|TRC_CH_B2
operator|)
expr_stmt|;
name|hdr
operator|.
name|dir
operator|=
name|FROM_TE
expr_stmt|;
name|hdr
operator|.
name|count
operator|=
operator|++
name|sc
operator|->
name|sc_trace_bcount
expr_stmt|;
name|MICROTIME
argument_list|(
name|hdr
operator|.
name|time
argument_list|)
expr_stmt|;
name|MPH_Trace_Ind
argument_list|(
operator|&
name|hdr
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_len
argument_list|,
name|chan
operator|->
name|out_mbuf_cur
operator|->
name|m_data
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|chan
operator|->
name|bprot
operator|!=
name|BPROT_NONE
condition|)
name|cmd
operator||=
name|HSCX_CMDR_XME
expr_stmt|;
name|i4b_Bfreembuf
argument_list|(
name|chan
operator|->
name|out_mbuf_head
argument_list|)
expr_stmt|;
name|chan
operator|->
name|out_mbuf_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* write what we have from the scratch buf to the HSCX fifo */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|HSCX_WRFIFO
argument_list|(
name|chan
operator|->
name|channel
argument_list|,
name|scrbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmd
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NISIC> 0&& defined(AVM_A1_PCI) */
end_comment

end_unit

