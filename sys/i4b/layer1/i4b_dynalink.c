begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   Copyright (c) 1998 Martijn Plak. All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *   3. Neither the name of the author nor the names of any co-contributors  *      may be used to endorse or promote products derived from this software  *      without specific prior written permission.  *   4. Altered versions must be plainly marked as such, and must not be  *      misrepresented as being the original software and/or documentation.  *     *   THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  *   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  *   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  *   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  *   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  *   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  *   SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	isdn4bsd layer1 driver for Dynalink IS64PH isdn TA  *	==================================================  *  * $FreeBSD$  *  *      last edit-date: [Sun Feb 14 10:26:21 1999]  *  *	written by Martijn Plak<tigrfhur@xs4all.nl>  *  *	-mp 11 jun 1998 first try, code borrowed from Creatix driver  *	-mp 18 jun 1998 cleaned up code  *	-hm FreeBSD PnP  *	-mp 17 dec 1998 made it compile again  *  *---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*	NOTES: 	 	This driver was written for the Dynalink IS64PH ISDN TA, based on two  	Siemens chips (HSCX 21525 and ISAC 2186). It is sold in the Netherlands. 	 	model numbers found on (my) card: 		IS64PH, TAS100H-N, P/N:89590555, TA200S100045521 	 	chips: 	 		Siemens PSB 21525N, HSCX TE V2.1 		Siemens PSB 2186N, ISAC-S TE V1.1 		95MS14, PNP 	 	plug-and-play info:  		device id 	"ASU1688"  		vendor id 	0x88167506  		serial 		0x00000044 		i/o port	4 byte alignment, 4 bytes requested,  				10 bit i/o decoding, 0x100-0x3f8 (?) 		irq		3,4,5,9,10,11,12,15, high true, edge sensitive 			 	At the moment I'm writing this Dynalink is replacing this card with  	one based on a single Siemens chip (IPAC). It will apparently be sold  	under the same model name.  	This driver might also work for Asuscom cards. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|"isic.h"
end_include

begin_include
include|#
directive|include
file|"opt_i4b.h"
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NISIC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NPNP
value|1
end_define

begin_if
if|#
directive|if
operator|(
name|NISIC
operator|>
literal|0
operator|)
operator|&&
operator|(
name|NPNP
operator|>
literal|0
operator|)
operator|&&
name|defined
argument_list|(
name|DYNALINK
argument_list|)
end_if

begin_comment
comment|/* HEADERS */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_if
if|#
directive|if
name|__FreeBSD__
operator|>=
literal|3
end_if

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_comment
comment|/* #include<i386/isa/pnp.h> */
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<i386/isa/pnp.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<machine/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_ioctl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i4b/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<i4b/i4b_ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i4b/include/i4b_global.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_l1l2.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_l1.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_isac.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer1/i4b_hscx.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|dynalink_read_fifo
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
specifier|const
name|void
modifier|*
name|base
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dynalink_write_fifo
parameter_list|(
name|void
modifier|*
name|base
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dynalink_write_reg
parameter_list|(
name|u_char
modifier|*
name|base
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|u_int
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
name|dynalink_read_reg
parameter_list|(
name|u_char
modifier|*
name|base
parameter_list|,
name|u_int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|isa_driver
name|isicdriver
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__bsdi__
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|cfdriver
name|isiccd
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|dynalink_read_fifo
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dynalink_write_fifo
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dynalink_write_reg
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|dynalink_read_reg
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|isic_attach_Dyn
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* io address mapping */
end_comment

begin_define
define|#
directive|define
name|ISAC
value|0
end_define

begin_define
define|#
directive|define
name|HSCX
value|1
end_define

begin_define
define|#
directive|define
name|ADDR
value|2
end_define

begin_comment
comment|/* ADDR bits */
end_comment

begin_define
define|#
directive|define
name|ADDRMASK
value|0x7F
end_define

begin_define
define|#
directive|define
name|RESET
value|0x80
end_define

begin_comment
comment|/* HSCX register offsets */
end_comment

begin_define
define|#
directive|define
name|HSCXA
value|0x00
end_define

begin_define
define|#
directive|define
name|HSCXB
value|0x40
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_comment
comment|/* base address juggling */
end_comment

begin_define
define|#
directive|define
name|HSCXB_HACK
value|0x400
end_define

begin_define
define|#
directive|define
name|IOBASE
parameter_list|(
name|addr
parameter_list|)
value|(((int)addr)&0x3FC)
end_define

begin_define
define|#
directive|define
name|IOADDR
parameter_list|(
name|addr
parameter_list|)
value|(((int)addr)&0x3FF)
end_define

begin_define
define|#
directive|define
name|IS_HSCXB_HACK
parameter_list|(
name|addr
parameter_list|)
value|((((int)addr)&HSCXB_HACK)?HSCXB:HSCXA)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_comment
comment|/* ISIC probe and attach */
end_comment

begin_function
name|int
name|isic_probe_Dyn
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|int
name|iobase2
parameter_list|)
block|{
name|struct
name|isic_softc
modifier|*
name|sc
init|=
operator|&
name|isic_sc
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_unit
operator|>=
name|ISIC_MAXUNIT
condition|)
block|{
name|printf
argument_list|(
literal|"isic%d: Error, unit %d>= ISIC_MAXUNIT for Dynalink IS64PH.\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|sc_unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
comment|/* check IRQ validity */
switch|switch
condition|(
name|ffs
argument_list|(
name|dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
condition|)
block|{
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|9
case|:
case|case
literal|10
case|:
case|case
literal|11
case|:
case|case
literal|12
case|:
case|case
literal|15
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"isic%d: Error, invalid IRQ [%d] specified for Dynalink IS64PH.\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|ffs
argument_list|(
name|dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
name|sc
operator|->
name|sc_irq
operator|=
name|dev
operator|->
name|id_irq
expr_stmt|;
comment|/* check if memory addr specified */
if|if
condition|(
name|dev
operator|->
name|id_maddr
condition|)
block|{
name|printf
argument_list|(
literal|"isic%d: Error, mem addr 0x%lx specified for Dynalink IS64PH.\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
operator|(
name|u_long
operator|)
name|dev
operator|->
name|id_maddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dev
operator|->
name|id_msize
operator|=
literal|0
expr_stmt|;
comment|/* check if we got an iobase */
if|if
condition|(
operator|(
name|dev
operator|->
name|id_iobase
operator|<
literal|0x100
operator|)
operator|||
operator|(
name|dev
operator|->
name|id_iobase
operator|>
literal|0x3f8
operator|)
operator|||
operator|(
name|dev
operator|->
name|id_iobase
operator|&
literal|3
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"isic%d: Error, invalid iobase 0x%x specified for Dynalink!\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|dev
operator|->
name|id_iobase
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|sc_port
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
comment|/* setup access routines */
name|sc
operator|->
name|clearirq
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|readreg
operator|=
name|dynalink_read_reg
expr_stmt|;
name|sc
operator|->
name|writereg
operator|=
name|dynalink_write_reg
expr_stmt|;
name|sc
operator|->
name|readfifo
operator|=
name|dynalink_read_fifo
expr_stmt|;
name|sc
operator|->
name|writefifo
operator|=
name|dynalink_write_fifo
expr_stmt|;
comment|/* setup card type */
name|sc
operator|->
name|sc_cardtyp
operator|=
name|CARD_TYPEP_DYNALINK
expr_stmt|;
comment|/* setup IOM bus type */
name|sc
operator|->
name|sc_bustyp
operator|=
name|BUS_TYPE_IOM2
expr_stmt|;
name|sc
operator|->
name|sc_ipac
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bfifolen
operator|=
name|HSCX_FIFO_LEN
expr_stmt|;
comment|/* setup ISAC and HSCX base addr */
name|ISAC_BASE
operator|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_port
expr_stmt|;
name|HSCX_A_BASE
operator|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_port
operator|+
literal|1
expr_stmt|;
name|HSCX_B_BASE
operator|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_port
operator|+
literal|1
operator|+
name|HSCXB_HACK
expr_stmt|;
comment|/* Read HSCX A/B VSTR.  Expected value is 0x05 (V2.1). */
if|if
condition|(
operator|(
operator|(
name|HSCX_READ
argument_list|(
literal|0
argument_list|,
name|H_VSTR
argument_list|)
operator|&
literal|0xf
operator|)
operator|!=
literal|0x5
operator|)
operator|||
operator|(
operator|(
name|HSCX_READ
argument_list|(
literal|1
argument_list|,
name|H_VSTR
argument_list|)
operator|&
literal|0xf
operator|)
operator|!=
literal|0x5
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"isic%d: HSCX VSTR test failed for Dynalink\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"isic%d: HSC0: VSTR: %#x\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|HSCX_READ
argument_list|(
literal|0
argument_list|,
name|H_VSTR
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"isic%d: HSC1: VSTR: %#x\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|HSCX_READ
argument_list|(
literal|1
argument_list|,
name|H_VSTR
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|isic_attach_Dyn
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|int
name|iobase2
parameter_list|)
block|{
name|outb
argument_list|(
operator|(
name|dev
operator|->
name|id_iobase
operator|)
operator|+
name|ADDR
argument_list|,
name|RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|dev
operator|->
name|id_iobase
operator|)
operator|+
name|ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_elif

begin_comment
comment|/* ISIC probe and attach */
end_comment

begin_function
specifier|static
name|int
name|set_softc
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|isa_attach_args
modifier|*
name|ia
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
if|if
condition|(
name|unit
operator|>=
name|NISIC
condition|)
return|return
literal|0
return|;
name|sc
operator|->
name|sc_unit
operator|=
name|unit
expr_stmt|;
switch|switch
condition|(
name|ffs
argument_list|(
name|ia
operator|->
name|ia_irq
argument_list|)
operator|-
literal|1
condition|)
block|{
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|9
case|:
case|case
literal|10
case|:
case|case
literal|11
case|:
case|case
literal|12
case|:
case|case
literal|15
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"isic%d: Error, invalid IRQ [%d] specified for Dynalink IS64PH.\n"
argument_list|,
name|unit
argument_list|,
name|ffs
argument_list|(
name|ia
operator|->
name|ia_irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
name|sc
operator|->
name|sc_irq
operator|=
name|ia
operator|->
name|ia_irq
expr_stmt|;
comment|/* check if memory addr specified */
if|if
condition|(
name|ia
operator|->
name|ia_maddr
condition|)
block|{
name|printf
argument_list|(
literal|"isic%d: Error, mem addr 0x%lx specified for Dynalink IS64PH.\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|u_long
operator|)
name|ia
operator|->
name|ia_maddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* check if we got an iobase */
if|if
condition|(
operator|(
name|ia
operator|->
name|ia_iobase
operator|<
literal|0x100
operator|)
operator|||
operator|(
name|ia
operator|->
name|ia_iobase
operator|>
literal|0x3f8
operator|)
operator|||
operator|(
name|ia
operator|->
name|ia_iobase
operator|&
literal|3
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"isic%d: Error, invalid iobase 0x%x specified for Dynalink!\n"
argument_list|,
name|unit
argument_list|,
name|ia
operator|->
name|ia_iobase
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|sc_port
operator|=
name|ia
operator|->
name|ia_iobase
expr_stmt|;
comment|/* setup access routines */
name|sc
operator|->
name|clearirq
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|readreg
operator|=
name|dynalink_read_reg
expr_stmt|;
name|sc
operator|->
name|writereg
operator|=
name|dynalink_write_reg
expr_stmt|;
name|sc
operator|->
name|readfifo
operator|=
name|dynalink_read_fifo
expr_stmt|;
name|sc
operator|->
name|writefifo
operator|=
name|dynalink_write_fifo
expr_stmt|;
comment|/* setup card type */
name|sc
operator|->
name|sc_cardtyp
operator|=
name|CARD_TYPEP_DYNALINK
expr_stmt|;
comment|/* setup IOM bus type */
name|sc
operator|->
name|sc_bustyp
operator|=
name|BUS_TYPE_IOM2
expr_stmt|;
name|sc
operator|->
name|sc_ipac
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bfifolen
operator|=
name|HSCX_FIFO_LEN
expr_stmt|;
comment|/* setup ISAC and HSCX base addr */
name|ISAC_BASE
operator|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_port
expr_stmt|;
name|HSCX_A_BASE
operator|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_port
operator|+
literal|1
expr_stmt|;
name|HSCX_B_BASE
operator|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_port
operator|+
literal|1
operator|+
name|HSCXB_HACK
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|isapnp_match_dynalink
parameter_list|(
name|struct
name|device
modifier|*
name|parent
parameter_list|,
name|struct
name|cfdata
modifier|*
name|cf
parameter_list|,
name|struct
name|isa_attach_args
modifier|*
name|ia
parameter_list|)
block|{
name|struct
name|isic_softc
name|dummysc
decl_stmt|,
modifier|*
name|sc
init|=
operator|&
name|dummysc
decl_stmt|;
name|pnp_resource_t
name|res
decl_stmt|;
name|char
modifier|*
name|ids
index|[]
init|=
block|{
literal|"ASU1688"
block|,
name|NULL
block|}
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|res
argument_list|,
sizeof|sizeof
name|res
argument_list|)
expr_stmt|;
name|res
operator|.
name|res_irq
index|[
literal|0
index|]
operator|.
name|irq_level
operator|=
name|ia
operator|->
name|ia_irq
expr_stmt|;
name|res
operator|.
name|res_port
index|[
literal|0
index|]
operator|.
name|prt_base
operator|=
name|ia
operator|->
name|ia_iobase
expr_stmt|;
name|res
operator|.
name|res_port
index|[
literal|0
index|]
operator|.
name|prt_length
operator|=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|pnp_assigndev
argument_list|(
name|ids
argument_list|,
name|isiccd
operator|.
name|cd_name
argument_list|,
operator|&
name|res
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ia
operator|->
name|ia_irq
operator|=
name|res
operator|.
name|res_irq
index|[
literal|0
index|]
operator|.
name|irq_level
expr_stmt|;
name|ia
operator|->
name|ia_iobase
operator|=
name|res
operator|.
name|res_port
index|[
literal|0
index|]
operator|.
name|prt_base
expr_stmt|;
name|ia
operator|->
name|ia_iosize
operator|=
name|res
operator|.
name|res_port
index|[
literal|0
index|]
operator|.
name|prt_length
expr_stmt|;
if|if
condition|(
name|set_softc
argument_list|(
name|sc
argument_list|,
name|ia
argument_list|,
name|cf
operator|->
name|cf_unit
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Read HSCX A/B VSTR.  Expected value is 0x05 (V2.1). */
if|if
condition|(
operator|(
operator|(
name|HSCX_READ
argument_list|(
literal|0
argument_list|,
name|H_VSTR
argument_list|)
operator|&
literal|0xf
operator|)
operator|!=
literal|0x5
operator|)
operator|||
operator|(
operator|(
name|HSCX_READ
argument_list|(
literal|1
argument_list|,
name|H_VSTR
argument_list|)
operator|&
literal|0xf
operator|)
operator|!=
literal|0x5
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"isic%d: HSCX VSTR test failed for Dynalink\n"
argument_list|,
name|cf
operator|->
name|cf_unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"isic%d: HSC0: VSTR: %#x\n"
argument_list|,
name|cf
operator|->
name|cf_unit
argument_list|,
name|HSCX_READ
argument_list|(
literal|0
argument_list|,
name|H_VSTR
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"isic%d: HSC1: VSTR: %#x\n"
argument_list|,
name|cf
operator|->
name|cf_unit
argument_list|,
name|HSCX_READ
argument_list|(
literal|1
argument_list|,
name|H_VSTR
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cf
operator|->
name|cf_flags
operator|=
name|FLAG_DYNALINK
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|isic_attach_Dyn
parameter_list|(
name|struct
name|device
modifier|*
name|parent
parameter_list|,
name|struct
name|device
modifier|*
name|self
parameter_list|,
name|struct
name|isa_attach_args
modifier|*
name|ia
parameter_list|)
block|{
name|struct
name|isic_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|isic_softc
operator|*
operator|)
name|self
decl_stmt|;
name|int
name|unit
init|=
name|sc
operator|->
name|sc_dev
operator|.
name|dv_unit
decl_stmt|;
comment|/* Commit the probed attachment values */
if|if
condition|(
name|set_softc
argument_list|(
name|sc
argument_list|,
name|ia
argument_list|,
name|unit
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"isic_attach_Dyn: set_softc"
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ia
operator|->
name|ia_iobase
operator|)
operator|+
name|ADDR
argument_list|,
name|RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ia
operator|->
name|ia_iobase
operator|)
operator|+
name|ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|isic_attach_Dyn
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* setup access routines */
name|sc
operator|->
name|clearirq
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|readreg
operator|=
name|dynalink_read_reg
expr_stmt|;
name|sc
operator|->
name|writereg
operator|=
name|dynalink_write_reg
expr_stmt|;
name|sc
operator|->
name|readfifo
operator|=
name|dynalink_read_fifo
expr_stmt|;
name|sc
operator|->
name|writefifo
operator|=
name|dynalink_write_fifo
expr_stmt|;
comment|/* setup card type */
name|sc
operator|->
name|sc_cardtyp
operator|=
name|CARD_TYPEP_DYNALINK
expr_stmt|;
comment|/* setup IOM bus type */
name|sc
operator|->
name|sc_bustyp
operator|=
name|BUS_TYPE_IOM2
expr_stmt|;
name|sc
operator|->
name|sc_ipac
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bfifolen
operator|=
name|HSCX_FIFO_LEN
expr_stmt|;
comment|/* Read HSCX A/B VSTR.  Expected value is 0x05 (V2.1). */
if|if
condition|(
operator|(
operator|(
name|HSCX_READ
argument_list|(
literal|0
argument_list|,
name|H_VSTR
argument_list|)
operator|&
literal|0xf
operator|)
operator|!=
literal|0x5
operator|)
operator|||
operator|(
operator|(
name|HSCX_READ
argument_list|(
literal|1
argument_list|,
name|H_VSTR
argument_list|)
operator|&
literal|0xf
operator|)
operator|!=
literal|0x5
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: HSCX VSTR test failed for Dynalink PnP\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: HSC0: VSTR: %#x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|HSCX_READ
argument_list|(
literal|0
argument_list|,
name|H_VSTR
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: HSC1: VSTR: %#x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|HSCX_READ
argument_list|(
literal|1
argument_list|,
name|H_VSTR
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ADDR
argument_list|,
name|RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|10
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
argument_list|,
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
argument_list|,
name|ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEC_DELAY
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISIC>0&& NPNP>0&& defined(DYNALINK) */
end_comment

begin_comment
comment|/*	LOW-LEVEL DEVICE ACCESS  	NOTE:	The isdn4bsd code expects the two HSCX channels at different  	base addresses. I'm faking this, and remap them to the same address  	in the low-level routines. Search for HSCXB_HACK and IS_HSCXB_HACK.  	REM: this is only true for the FreeBSD version of I4B! */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_function
specifier|static
name|void
name|dynalink_read_fifo
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
specifier|const
name|void
modifier|*
name|base
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|outb
argument_list|(
name|IOBASE
argument_list|(
name|base
argument_list|)
operator|+
name|ADDR
argument_list|,
literal|0
operator|+
name|IS_HSCXB_HACK
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|insb
argument_list|(
name|IOADDR
argument_list|(
name|base
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|u_int
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|dynalink_read_fifo
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_read_multi_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ISAC
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXA
argument_list|)
expr_stmt|;
name|bus_space_read_multi_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXB
argument_list|)
expr_stmt|;
name|bus_space_read_multi_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_function
specifier|static
name|void
name|dynalink_write_fifo
parameter_list|(
name|void
modifier|*
name|base
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|outb
argument_list|(
name|IOBASE
argument_list|(
name|base
argument_list|)
operator|+
name|ADDR
argument_list|,
literal|0
operator|+
name|IS_HSCXB_HACK
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|outsb
argument_list|(
name|IOADDR
argument_list|(
name|base
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|u_int
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|dynalink_write_fifo
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_write_multi_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ISAC
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXA
argument_list|)
expr_stmt|;
name|bus_space_write_multi_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXB
argument_list|)
expr_stmt|;
name|bus_space_write_multi_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_function
specifier|static
name|void
name|dynalink_write_reg
parameter_list|(
name|u_char
modifier|*
name|base
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|u_int
name|v
parameter_list|)
block|{
name|outb
argument_list|(
name|IOBASE
argument_list|(
name|base
argument_list|)
operator|+
name|ADDR
argument_list|,
operator|(
name|offset
operator|+
name|IS_HSCXB_HACK
argument_list|(
name|base
argument_list|)
operator|)
operator|&
name|ADDRMASK
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IOADDR
argument_list|(
name|base
argument_list|)
argument_list|,
operator|(
name|u_char
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|dynalink_write_reg
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ISAC
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXA
operator|+
name|offs
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXB
operator|+
name|offs
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_function
specifier|static
name|u_char
name|dynalink_read_reg
parameter_list|(
name|u_char
modifier|*
name|base
parameter_list|,
name|u_int
name|offset
parameter_list|)
block|{
name|outb
argument_list|(
name|IOBASE
argument_list|(
name|base
argument_list|)
operator|+
name|ADDR
argument_list|,
operator|(
name|offset
operator|+
name|IS_HSCXB_HACK
argument_list|(
name|base
argument_list|)
operator|)
operator|&
name|ADDRMASK
argument_list|)
expr_stmt|;
return|return
operator|(
name|inb
argument_list|(
name|IOADDR
argument_list|(
name|base
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|u_int8_t
name|dynalink_read_reg
parameter_list|(
name|struct
name|isic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|,
name|bus_size_t
name|offs
parameter_list|)
block|{
name|bus_space_tag_t
name|t
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|t
decl_stmt|;
name|bus_space_handle_t
name|h
init|=
name|sc
operator|->
name|sc_maps
index|[
literal|0
index|]
operator|.
name|h
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ISIC_WHAT_ISAC
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|offs
argument_list|)
expr_stmt|;
return|return
name|bus_space_read_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ISAC
argument_list|)
return|;
case|case
name|ISIC_WHAT_HSCXA
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXA
operator|+
name|offs
argument_list|)
expr_stmt|;
return|return
name|bus_space_read_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|)
return|;
case|case
name|ISIC_WHAT_HSCXB
case|:
name|bus_space_write_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|ADDR
argument_list|,
name|HSCXB
operator|+
name|offs
argument_list|)
expr_stmt|;
return|return
name|bus_space_read_1
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|HSCX
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (NISIC> 0)&& (NPNP> 0)&& defined(DYNALINK) */
end_comment

end_unit

