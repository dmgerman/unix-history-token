begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001 Cubical Solutions Ltd. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * capi/iavc/iavc_lli.c  *		The AVM ISDN controllers' Low Level Interface.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"iavc.h"
end_include

begin_include
include|#
directive|include
file|"i4bcapi.h"
end_include

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
operator|(
name|NIAVC
operator|>
literal|0
operator|)
operator|&&
operator|(
name|NI4BCAPI
operator|>
literal|0
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_trace.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_global.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_l3l4.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<i4b/capi/capi.h>
end_include

begin_include
include|#
directive|include
file|<i4b/capi/capi_msgs.h>
end_include

begin_include
include|#
directive|include
file|<i4b/capi/iavc/iavc.h>
end_include

begin_comment
comment|/* Forward declarations of local subroutines... */
end_comment

begin_function_decl
specifier|static
name|int
name|iavc_send_init
parameter_list|(
name|iavc_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iavc_handle_rx
parameter_list|(
name|iavc_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iavc_start_tx
parameter_list|(
name|iavc_softc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* //  Callbacks from the upper (capi) layer: //  -------------------------------------- // //  iavc_load //      Resets the board and loads the firmware, then initiates //      board startup. // //  iavc_register //      Registers a CAPI application id. // //  iavc_release //      Releases a CAPI application id. // //  iavc_send //      Sends a capi message. */
end_comment

begin_function
name|int
name|iavc_load
parameter_list|(
name|capi_softc_t
modifier|*
name|capi_sc
parameter_list|,
name|int
name|len
parameter_list|,
name|u_int8_t
modifier|*
name|cp
parameter_list|)
block|{
name|iavc_softc_t
modifier|*
name|sc
init|=
operator|(
name|iavc_softc_t
operator|*
operator|)
name|capi_sc
operator|->
name|ctx
decl_stmt|;
name|u_int8_t
name|val
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"iavc%d: reset card ....\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dma
condition|)
name|b1dma_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* PCI cards */
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_t1
condition|)
name|t1_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* ISA attachment T1 */
else|else
name|b1_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* ISA attachment B1 */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"iavc%d: start loading %d bytes firmware ....\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|&&
name|b1io_save_put_byte
argument_list|(
name|sc
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
operator|==
literal|0
condition|)
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"iavc%d: loading failed, can't write to card, len = %d\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"iavc%d: firmware loaded, wait for ACK ....\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_capi
operator|.
name|card_type
operator|==
name|CARD_TYPEC_AVM_B1_ISA
condition|)
name|iavc_put_byte
argument_list|(
name|sc
argument_list|,
name|SEND_POLL
argument_list|)
expr_stmt|;
else|else
name|iavc_put_byte
argument_list|(
name|sc
argument_list|,
name|SEND_POLLACK
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
literal|1000
operator|&&
operator|!
name|iavc_rx_full
argument_list|(
name|sc
argument_list|)
condition|;
name|len
operator|++
control|)
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iavc_rx_full
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"iavc%d: loading failed, no ack\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|val
operator|=
name|iavc_get_byte
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_dma
operator|&&
name|val
operator|!=
name|RECEIVE_POLLDWORD
operator|)
operator|||
operator|(
operator|!
name|sc
operator|->
name|sc_dma
operator|&&
name|val
operator|!=
name|RECEIVE_POLL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"iavc%d: loading failed, bad ack = %02x\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"iavc%d: got ACK = 0x%02x\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dma
condition|)
block|{
comment|/* Start the DMA engine */
name|int
name|s
init|=
name|SPLI4B
argument_list|()
decl_stmt|;
name|sc
operator|->
name|sc_csr
operator|=
name|AVM_FLAG
expr_stmt|;
name|AMCC_WRITE
argument_list|(
name|sc
argument_list|,
name|AMCC_INTCSR
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|)
expr_stmt|;
name|AMCC_WRITE
argument_list|(
name|sc
argument_list|,
name|AMCC_MCSR
argument_list|,
operator|(
name|EN_A2P_TRANSFERS
operator||
name|EN_P2A_TRANSFERS
operator||
name|A2P_HI_PRIORITY
operator||
name|P2A_HI_PRIORITY
operator||
name|RESET_A2P_FLAGS
operator||
name|RESET_P2A_FLAGS
operator|)
argument_list|)
expr_stmt|;
name|iavc_write_port
argument_list|(
name|sc
argument_list|,
literal|0x07
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
comment|/* XXX magic numbers from */
name|iavc_write_port
argument_list|(
name|sc
argument_list|,
literal|0x10
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
comment|/* XXX the linux driver */
name|sc
operator|->
name|sc_recvlen
operator|=
literal|0
expr_stmt|;
name|AMCC_WRITE
argument_list|(
name|sc
argument_list|,
name|AMCC_RXPTR
argument_list|,
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|sc_recvbuf
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|AMCC_WRITE
argument_list|(
name|sc
argument_list|,
name|AMCC_RXLEN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_csr
operator||=
name|EN_RX_TC_INT
operator||
name|EN_TX_TC_INT
expr_stmt|;
name|AMCC_WRITE
argument_list|(
name|sc
argument_list|,
name|AMCC_INTCSR
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_capi
operator|.
name|card_type
operator|==
name|CARD_TYPEC_AVM_B1_ISA
condition|)
name|b1isa_setup_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iavc_send_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iavc_register
parameter_list|(
name|capi_softc_t
modifier|*
name|capi_sc
parameter_list|,
name|int
name|applid
parameter_list|,
name|int
name|nchan
parameter_list|)
block|{
name|iavc_softc_t
modifier|*
name|sc
init|=
operator|(
name|iavc_softc_t
operator|*
operator|)
name|capi_sc
operator|->
name|ctx
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|i4b_Dgetmbuf
argument_list|(
literal|23
argument_list|)
decl_stmt|;
name|u_int8_t
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|printf
argument_list|(
literal|"iavc%d: can't get memory\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*      * byte  0x12 = SEND_REGISTER      * dword ApplId      * dword NumMessages      * dword NumB3Connections 0..nbch      * dword NumB3Blocks      * dword B3Size      */
name|p
operator|=
name|amcc_put_byte
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|amcc_put_byte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|amcc_put_byte
argument_list|(
name|p
argument_list|,
name|SEND_REGISTER
argument_list|)
expr_stmt|;
name|p
operator|=
name|amcc_put_word
argument_list|(
name|p
argument_list|,
name|applid
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|p = amcc_put_word(p, 1024 + (nchan + 1));
else|#
directive|else
name|p
operator|=
name|amcc_put_word
argument_list|(
name|p
argument_list|,
literal|1024
operator|*
operator|(
name|nchan
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|amcc_put_word
argument_list|(
name|p
argument_list|,
name|nchan
argument_list|)
expr_stmt|;
name|p
operator|=
name|amcc_put_word
argument_list|(
name|p
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|p
operator|=
name|amcc_put_word
argument_list|(
name|p
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|iavc_start_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iavc_release
parameter_list|(
name|capi_softc_t
modifier|*
name|capi_sc
parameter_list|,
name|int
name|applid
parameter_list|)
block|{
name|iavc_softc_t
modifier|*
name|sc
init|=
operator|(
name|iavc_softc_t
operator|*
operator|)
name|capi_sc
operator|->
name|ctx
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|i4b_Dgetmbuf
argument_list|(
literal|7
argument_list|)
decl_stmt|;
name|u_int8_t
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|printf
argument_list|(
literal|"iavc%d: can't get memory\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*      * byte  0x14 = SEND_RELEASE      * dword ApplId      */
name|p
operator|=
name|amcc_put_byte
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|amcc_put_byte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|amcc_put_byte
argument_list|(
name|p
argument_list|,
name|SEND_RELEASE
argument_list|)
expr_stmt|;
name|p
operator|=
name|amcc_put_word
argument_list|(
name|p
argument_list|,
name|applid
argument_list|)
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|iavc_start_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iavc_send
parameter_list|(
name|capi_softc_t
modifier|*
name|capi_sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|iavc_softc_t
modifier|*
name|sc
init|=
operator|(
name|iavc_softc_t
operator|*
operator|)
name|capi_sc
operator|->
name|ctx
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|IAVC_UP
condition|)
block|{
name|printf
argument_list|(
literal|"iavc%d: attempt to send before device up\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
name|i4b_Bfreembuf
argument_list|(
name|m
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|i4b_Dfreembuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|_IF_QFULL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
argument_list|)
condition|)
block|{
name|_IF_DROP
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iavc%d: tx overflow, message dropped\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
name|i4b_Bfreembuf
argument_list|(
name|m
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|i4b_Dfreembuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|iavc_start_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* //  Functions called by ourself during the initialization sequence: //  --------------------------------------------------------------- // //  iavc_send_init //      Sends the system initialization message to a newly loaded //      board, and sets state to INIT. */
end_comment

begin_function
specifier|static
name|int
name|iavc_send_init
parameter_list|(
name|iavc_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|i4b_Dgetmbuf
argument_list|(
literal|15
argument_list|)
decl_stmt|;
name|u_int8_t
modifier|*
name|p
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|printf
argument_list|(
literal|"iavc%d: can't get memory\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*      * byte  0x11 = SEND_INIT      * dword NumApplications      * dword NumNCCIs      * dword BoardNumber      */
name|p
operator|=
name|amcc_put_byte
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|amcc_put_byte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|amcc_put_byte
argument_list|(
name|p
argument_list|,
name|SEND_INIT
argument_list|)
expr_stmt|;
name|p
operator|=
name|amcc_put_word
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX MaxAppl XXX */
name|p
operator|=
name|amcc_put_word
argument_list|(
name|p
argument_list|,
name|sc
operator|->
name|sc_capi
operator|.
name|sc_nbch
argument_list|)
expr_stmt|;
name|p
operator|=
name|amcc_put_word
argument_list|(
name|p
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|s
operator|=
name|SPLI4B
argument_list|()
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|iavc_start_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|IAVC_INIT
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* //  Functions called during normal operation: //  ----------------------------------------- // //  iavc_receive_init //      Reads the initialization reply and calls capi_ll_control(). // //  iavc_receive_new_ncci //      Reads a new NCCI notification and calls capi_ll_control(). // //  iavc_receive_free_ncci //      Reads a freed NCCI notification and calls capi_ll_control(). // //  iavc_receive_task_ready //      Reads a task ready message -- which should not occur XXX. // //  iavc_receive_debugmsg //      Reads a debug message -- which should not occur XXX. // //  iavc_receive_start //      Reads a START TRANSMIT message and unblocks device. // //  iavc_receive_stop //      Reads a STOP TRANSMIT message and blocks device. // //  iavc_receive //      Reads an incoming message and calls capi_ll_receive(). */
end_comment

begin_function
specifier|static
name|int
name|iavc_receive_init
parameter_list|(
name|iavc_softc_t
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|dmabuf
parameter_list|)
block|{
name|u_int32_t
name|Length
decl_stmt|;
name|u_int8_t
modifier|*
name|p
decl_stmt|;
name|u_int8_t
modifier|*
name|cardtype
decl_stmt|,
modifier|*
name|serial
decl_stmt|,
modifier|*
name|profile
decl_stmt|,
modifier|*
name|version
decl_stmt|,
modifier|*
name|caps
decl_stmt|,
modifier|*
name|prot
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dma
condition|)
block|{
name|p
operator|=
name|amcc_get_word
argument_list|(
name|dmabuf
argument_list|,
operator|&
name|Length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Length
operator|=
name|iavc_get_slice
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_recvbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|sc
operator|->
name|sc_recvbuf
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|{ 	int len = 0; 	printf("iavc%d: rx_init: ", sc->sc_unit); 	    while (len< Length) { 		printf(" %02x", p[len]); 		if (len&& (len % 16) == 0) printf("\n"); 		len++; 	    } 	    if (len % 16) printf("\n");     }
endif|#
directive|endif
name|version
operator|=
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|p
operator|+=
operator|(
operator|*
name|p
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* driver version */
name|cardtype
operator|=
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|p
operator|+=
operator|(
operator|*
name|p
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* card type */
name|p
operator|+=
operator|(
operator|*
name|p
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* hardware ID */
name|serial
operator|=
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|p
operator|+=
operator|(
operator|*
name|p
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* serial number */
name|caps
operator|=
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|p
operator|+=
operator|(
operator|*
name|p
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* supported options */
name|prot
operator|=
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|p
operator|+=
operator|(
operator|*
name|p
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* supported protocols */
name|profile
operator|=
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|cardtype
operator|&&
name|serial
operator|&&
name|profile
condition|)
block|{
name|int
name|nbch
init|=
operator|(
operator|(
name|profile
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|profile
index|[
literal|2
index|]
operator|)
decl_stmt|;
name|printf
argument_list|(
literal|"iavc%d: AVM %s, s/n %s, %d chans, f/w rev %s, prot %s\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|cardtype
argument_list|,
name|serial
argument_list|,
name|nbch
argument_list|,
name|version
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"iavc%d: %s\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|caps
argument_list|)
expr_stmt|;
name|capi_ll_control
argument_list|(
operator|&
name|sc
operator|->
name|sc_capi
argument_list|,
name|CAPI_CTRL_PROFILE
argument_list|,
operator|(
name|int
operator|)
name|profile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"iavc%d: no profile data in info response?\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_blocked
operator|=
name|TRUE
expr_stmt|;
comment|/* controller will send START when ready */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iavc_receive_start
parameter_list|(
name|iavc_softc_t
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|dmabuf
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|i4b_Dgetmbuf
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|u_int8_t
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_blocked
operator|&&
name|sc
operator|->
name|sc_state
operator|==
name|IAVC_UP
condition|)
name|printf
argument_list|(
literal|"iavc%d: receive_start\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|printf
argument_list|(
literal|"iavc%d: can't get memory\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*      * byte  0x73 = SEND_POLLACK      */
name|p
operator|=
name|amcc_put_byte
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|amcc_put_byte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|amcc_put_byte
argument_list|(
name|p
argument_list|,
name|SEND_POLLACK
argument_list|)
expr_stmt|;
name|_IF_PREPEND
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_IAVCDBG
argument_list|,
literal|"iavc%d: blocked = %d, state = %d"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|sc_blocked
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_blocked
operator|=
name|FALSE
expr_stmt|;
name|iavc_start_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If this was our first START, register our readiness */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|IAVC_UP
condition|)
block|{
name|sc
operator|->
name|sc_state
operator|=
name|IAVC_UP
expr_stmt|;
name|capi_ll_control
argument_list|(
operator|&
name|sc
operator|->
name|sc_capi
argument_list|,
name|CAPI_CTRL_READY
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iavc_receive_stop
parameter_list|(
name|iavc_softc_t
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|dmabuf
parameter_list|)
block|{
name|printf
argument_list|(
literal|"iavc%d: receive_stop\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_blocked
operator|=
name|TRUE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iavc_receive_new_ncci
parameter_list|(
name|iavc_softc_t
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|dmabuf
parameter_list|)
block|{
name|u_int32_t
name|ApplId
decl_stmt|,
name|NCCI
decl_stmt|,
name|WindowSize
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dma
condition|)
block|{
name|dmabuf
operator|=
name|amcc_get_word
argument_list|(
name|dmabuf
argument_list|,
operator|&
name|ApplId
argument_list|)
expr_stmt|;
name|dmabuf
operator|=
name|amcc_get_word
argument_list|(
name|dmabuf
argument_list|,
operator|&
name|NCCI
argument_list|)
expr_stmt|;
name|dmabuf
operator|=
name|amcc_get_word
argument_list|(
name|dmabuf
argument_list|,
operator|&
name|WindowSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ApplId
operator|=
name|iavc_get_word
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NCCI
operator|=
name|iavc_get_word
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WindowSize
operator|=
name|iavc_get_word
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|capi_ll_control
argument_list|(
operator|&
name|sc
operator|->
name|sc_capi
argument_list|,
name|CAPI_CTRL_NEW_NCCI
argument_list|,
name|NCCI
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iavc_receive_free_ncci
parameter_list|(
name|iavc_softc_t
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|dmabuf
parameter_list|)
block|{
name|u_int32_t
name|ApplId
decl_stmt|,
name|NCCI
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dma
condition|)
block|{
name|dmabuf
operator|=
name|amcc_get_word
argument_list|(
name|dmabuf
argument_list|,
operator|&
name|ApplId
argument_list|)
expr_stmt|;
name|dmabuf
operator|=
name|amcc_get_word
argument_list|(
name|dmabuf
argument_list|,
operator|&
name|NCCI
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ApplId
operator|=
name|iavc_get_word
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NCCI
operator|=
name|iavc_get_word
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|capi_ll_control
argument_list|(
operator|&
name|sc
operator|->
name|sc_capi
argument_list|,
name|CAPI_CTRL_FREE_NCCI
argument_list|,
name|NCCI
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iavc_receive_task_ready
parameter_list|(
name|iavc_softc_t
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|dmabuf
parameter_list|)
block|{
name|u_int32_t
name|TaskId
decl_stmt|,
name|Length
decl_stmt|;
name|u_int8_t
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"iavc%d: receive_task_ready\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dma
condition|)
block|{
name|p
operator|=
name|amcc_get_word
argument_list|(
name|dmabuf
argument_list|,
operator|&
name|TaskId
argument_list|)
expr_stmt|;
name|p
operator|=
name|amcc_get_word
argument_list|(
name|p
argument_list|,
operator|&
name|Length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TaskId
operator|=
name|iavc_get_word
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|Length
operator|=
name|iavc_get_slice
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_recvbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|sc
operator|->
name|sc_recvbuf
expr_stmt|;
block|}
comment|/* XXX could show the message if trace enabled? XXX */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iavc_receive_debugmsg
parameter_list|(
name|iavc_softc_t
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|dmabuf
parameter_list|)
block|{
name|u_int32_t
name|Length
decl_stmt|;
name|u_int8_t
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"iavc%d: receive_debugmsg\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dma
condition|)
block|{
name|p
operator|=
name|amcc_get_word
argument_list|(
name|dmabuf
argument_list|,
operator|&
name|Length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Length
operator|=
name|iavc_get_slice
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_recvbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|sc
operator|->
name|sc_recvbuf
expr_stmt|;
block|}
comment|/* XXX could show the message if trace enabled? XXX */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iavc_receive
parameter_list|(
name|iavc_softc_t
modifier|*
name|sc
parameter_list|,
name|u_int8_t
modifier|*
name|dmabuf
parameter_list|,
name|int
name|b3data
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int32_t
name|ApplId
decl_stmt|,
name|Length
decl_stmt|;
comment|/*      * byte  0x21 = RECEIVE_MESSAGE      * dword ApplId      * dword length      * ...   CAPI msg      *      * --or--      *      * byte  0x22 = RECEIVE_DATA_B3_IND      * dword ApplId      * dword length      * ...   CAPI msg      * dword datalen      * ...   B3 data      */
if|if
condition|(
name|sc
operator|->
name|sc_dma
condition|)
block|{
name|dmabuf
operator|=
name|amcc_get_word
argument_list|(
name|dmabuf
argument_list|,
operator|&
name|ApplId
argument_list|)
expr_stmt|;
name|dmabuf
operator|=
name|amcc_get_word
argument_list|(
name|dmabuf
argument_list|,
operator|&
name|Length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ApplId
operator|=
name|iavc_get_word
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|Length
operator|=
name|iavc_get_slice
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_recvbuf
argument_list|)
expr_stmt|;
name|dmabuf
operator|=
name|sc
operator|->
name|sc_recvbuf
expr_stmt|;
block|}
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
name|Length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|printf
argument_list|(
literal|"iavc%d: can't get memory for receive\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|dmabuf
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
argument_list|,
name|Length
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|{ 	    u_int8_t *p = mtod(m, u_int8_t*); 	    int len = 0; 	    printf("iavc%d: applid=%d, len=%d\n", sc->sc_unit, ApplId, Length); 	    while (len< m->m_len) { 		printf(" %02x", p[len]); 		if (len&& (len % 16) == 0) printf("\n"); 		len++; 	    } 	    if (len % 16) printf("\n"); 	}
endif|#
directive|endif
if|if
condition|(
name|b3data
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_dma
condition|)
block|{
name|dmabuf
operator|=
name|amcc_get_word
argument_list|(
name|dmabuf
operator|+
name|Length
argument_list|,
operator|&
name|Length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Length
operator|=
name|iavc_get_slice
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_recvbuf
argument_list|)
expr_stmt|;
name|dmabuf
operator|=
name|sc
operator|->
name|sc_recvbuf
expr_stmt|;
block|}
name|m
operator|->
name|m_next
operator|=
name|i4b_Bgetmbuf
argument_list|(
name|Length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|m_next
condition|)
block|{
name|printf
argument_list|(
literal|"iavc%d: can't get memory for receive\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|i4b_Dfreembuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|dmabuf
argument_list|,
name|mtod
argument_list|(
name|m
operator|->
name|m_next
argument_list|,
name|u_int8_t
operator|*
argument_list|)
argument_list|,
name|Length
argument_list|)
expr_stmt|;
block|}
name|capi_ll_receive
argument_list|(
operator|&
name|sc
operator|->
name|sc_capi
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* //  iavc_handle_intr //      Checks device interrupt status and calls iavc_handle_{rx,tx}() //      as necessary. // //  iavc_handle_rx //      Reads in the command byte and calls the subroutines above. // //  iavc_start_tx //      Initiates DMA on the next queued message if possible. */
end_comment

begin_function
name|void
name|iavc_handle_intr
parameter_list|(
name|iavc_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|status
decl_stmt|;
name|u_int32_t
name|newcsr
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_dma
condition|)
block|{
while|while
condition|(
name|iavc_rx_full
argument_list|(
name|sc
argument_list|)
condition|)
name|iavc_handle_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|status
operator|=
name|AMCC_READ
argument_list|(
name|sc
argument_list|,
name|AMCC_INTCSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|ANY_S5933_INT
operator|)
operator|==
literal|0
condition|)
return|return;
name|newcsr
operator|=
name|sc
operator|->
name|sc_csr
operator||
operator|(
name|status
operator|&
name|ALL_INT
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|TX_TC_INT
condition|)
name|newcsr
operator|&=
operator|~
name|EN_TX_TC_INT
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|RX_TC_INT
condition|)
name|newcsr
operator|&=
operator|~
name|EN_RX_TC_INT
expr_stmt|;
name|AMCC_WRITE
argument_list|(
name|sc
argument_list|,
name|AMCC_INTCSR
argument_list|,
name|newcsr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intr
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|RX_TC_INT
condition|)
block|{
name|u_int32_t
name|rxlen
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_recvlen
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_recvlen
operator|=
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
operator|&
name|sc
operator|->
name|sc_recvbuf
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
name|rxlen
operator|=
operator|(
name|sc
operator|->
name|sc_recvlen
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|AMCC_WRITE
argument_list|(
name|sc
argument_list|,
name|AMCC_RXPTR
argument_list|,
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|sc_recvbuf
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|AMCC_WRITE
argument_list|(
name|sc
argument_list|,
name|AMCC_RXLEN
argument_list|,
name|rxlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iavc_handle_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_recvlen
operator|=
literal|0
expr_stmt|;
name|AMCC_WRITE
argument_list|(
name|sc
argument_list|,
name|AMCC_RXPTR
argument_list|,
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|sc_recvbuf
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|AMCC_WRITE
argument_list|(
name|sc
argument_list|,
name|AMCC_RXLEN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|&
name|TX_TC_INT
condition|)
block|{
name|sc
operator|->
name|sc_csr
operator|&=
operator|~
name|EN_TX_TC_INT
expr_stmt|;
name|iavc_start_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|AMCC_WRITE
argument_list|(
name|sc
argument_list|,
name|AMCC_INTCSR
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intr
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iavc_handle_rx
parameter_list|(
name|iavc_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|dmabuf
init|=
literal|0
decl_stmt|,
name|cmd
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dma
condition|)
block|{
name|dmabuf
operator|=
name|amcc_get_byte
argument_list|(
operator|&
name|sc
operator|->
name|sc_recvbuf
index|[
literal|4
index|]
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
name|iavc_get_byte
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|NDBGL4
argument_list|(
name|L4_IAVCDBG
argument_list|,
literal|"iavc%d: command = 0x%02x"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RECEIVE_DATA_B3_IND
case|:
name|iavc_receive
argument_list|(
name|sc
argument_list|,
name|dmabuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECEIVE_MESSAGE
case|:
name|iavc_receive
argument_list|(
name|sc
argument_list|,
name|dmabuf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECEIVE_NEW_NCCI
case|:
name|iavc_receive_new_ncci
argument_list|(
name|sc
argument_list|,
name|dmabuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECEIVE_FREE_NCCI
case|:
name|iavc_receive_free_ncci
argument_list|(
name|sc
argument_list|,
name|dmabuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECEIVE_START
case|:
name|iavc_receive_start
argument_list|(
name|sc
argument_list|,
name|dmabuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECEIVE_STOP
case|:
name|iavc_receive_stop
argument_list|(
name|sc
argument_list|,
name|dmabuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECEIVE_INIT
case|:
name|iavc_receive_init
argument_list|(
name|sc
argument_list|,
name|dmabuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECEIVE_TASK_READY
case|:
name|iavc_receive_task_ready
argument_list|(
name|sc
argument_list|,
name|dmabuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECEIVE_DEBUGMSG
case|:
name|iavc_receive_debugmsg
argument_list|(
name|sc
argument_list|,
name|dmabuf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"iavc%d: unknown msg %02x\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iavc_start_tx
parameter_list|(
name|iavc_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int8_t
modifier|*
name|dmabuf
decl_stmt|;
name|u_int32_t
name|txlen
init|=
literal|0
decl_stmt|;
comment|/* If device has put us on hold, punt. */
if|if
condition|(
name|sc
operator|->
name|sc_blocked
condition|)
block|{
return|return;
block|}
comment|/* If using DMA and transmitter busy, punt. */
if|if
condition|(
name|sc
operator|->
name|sc_dma
operator|&&
operator|(
name|sc
operator|->
name|sc_csr
operator|&
name|EN_TX_TC_INT
operator|)
condition|)
block|{
return|return;
block|}
comment|/* Else, see if we have messages to send. */
name|_IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
return|return;
block|}
comment|/* Have message, will send. */
if|if
condition|(
name|CAPIMSG_LEN
argument_list|(
name|m
operator|->
name|m_data
argument_list|)
condition|)
block|{
comment|/* A proper CAPI message, possibly with B3 data */
if|if
condition|(
name|sc
operator|->
name|sc_dma
condition|)
block|{
comment|/* Copy message to DMA buffer. */
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
name|dmabuf
operator|=
name|amcc_put_byte
argument_list|(
operator|&
name|sc
operator|->
name|sc_sendbuf
index|[
literal|0
index|]
argument_list|,
name|SEND_DATA_B3_REQ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmabuf
operator|=
name|amcc_put_byte
argument_list|(
operator|&
name|sc
operator|->
name|sc_sendbuf
index|[
literal|0
index|]
argument_list|,
name|SEND_MESSAGE
argument_list|)
expr_stmt|;
block|}
name|dmabuf
operator|=
name|amcc_put_word
argument_list|(
name|dmabuf
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|dmabuf
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|dmabuf
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|txlen
operator|=
literal|5
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
name|dmabuf
operator|=
name|amcc_put_word
argument_list|(
name|dmabuf
argument_list|,
name|m
operator|->
name|m_next
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|m
operator|->
name|m_next
operator|->
name|m_data
argument_list|,
name|dmabuf
argument_list|,
name|m
operator|->
name|m_next
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|txlen
operator|+=
literal|4
operator|+
name|m
operator|->
name|m_next
operator|->
name|m_len
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Use PIO. */
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
name|iavc_put_byte
argument_list|(
name|sc
argument_list|,
name|SEND_DATA_B3_REQ
argument_list|)
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_IAVCDBG
argument_list|,
literal|"iavc%d: tx SDB3R msg, len = %d"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iavc_put_byte
argument_list|(
name|sc
argument_list|,
name|SEND_MESSAGE
argument_list|)
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_IAVCDBG
argument_list|,
literal|"iavc%d: tx SM msg, len = %d"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|{ 	u_int8_t *p = mtod(m, u_int8_t*); 	int len; 	for (len = 0; len< m->m_len; len++) { 	    printf(" %02x", *p++); 	    if (len&& (len % 16) == 0) printf("\n"); 	} 	if (len % 16) printf("\n");     }
endif|#
directive|endif
name|iavc_put_slice
argument_list|(
name|sc
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
name|iavc_put_slice
argument_list|(
name|sc
argument_list|,
name|m
operator|->
name|m_next
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_next
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* A board control message to be sent as is */
if|if
condition|(
name|sc
operator|->
name|sc_dma
condition|)
block|{
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
operator|+
literal|2
argument_list|,
operator|&
name|sc
operator|->
name|sc_sendbuf
index|[
literal|0
index|]
argument_list|,
name|m
operator|->
name|m_len
operator|-
literal|2
argument_list|)
expr_stmt|;
name|txlen
operator|=
name|m
operator|->
name|m_len
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
block|{ 	u_int8_t *p = mtod(m, u_int8_t*) + 2; 	int len; 	printf("iavc%d: tx BDC msg, len = %d, msg =", sc->sc_unit, m->m_len-2); 	for (len = 0; len< m->m_len-2; len++) { 	    printf(" %02x", *p++); 	    if (len&& (len % 16) == 0) printf("\n"); 	} 	if (len % 16) printf("\n");     }
endif|#
directive|endif
name|txlen
operator|=
name|m
operator|->
name|m_len
operator|-
literal|2
expr_stmt|;
name|dmabuf
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
literal|2
expr_stmt|;
while|while
condition|(
name|txlen
operator|--
condition|)
name|b1io_put_byte
argument_list|(
name|sc
argument_list|,
operator|*
name|dmabuf
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
name|i4b_Bfreembuf
argument_list|(
name|m
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
name|i4b_Dfreembuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dma
condition|)
block|{
comment|/* Start transmitter */
name|txlen
operator|=
operator|(
name|txlen
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|AMCC_WRITE
argument_list|(
name|sc
argument_list|,
name|AMCC_TXPTR
argument_list|,
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|sc_sendbuf
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|AMCC_WRITE
argument_list|(
name|sc
argument_list|,
name|AMCC_TXLEN
argument_list|,
name|txlen
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_csr
operator||=
name|EN_TX_TC_INT
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_intr
condition|)
name|AMCC_WRITE
argument_list|(
name|sc
argument_list|,
name|AMCC_INTCSR
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

