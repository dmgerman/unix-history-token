begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 2001 Hellmuth Michaelis. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	i4b_l4.c - kernel interface to userland  *	-----------------------------------------  *  *	$Id: i4b_l4.c,v 1.54 2000/08/28 07:24:59 hm Exp $   *  * $FreeBSD$  *  *      last edit-date: [Sun Aug 27 14:53:42 2000]  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"i4b.h"
end_include

begin_include
include|#
directive|include
file|"i4bipr.h"
end_include

begin_if
if|#
directive|if
name|NI4B
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|&&
name|__NetBSD_Version__
operator|>=
literal|104230000
end_if

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"i4bing.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__bsdi__
end_ifdef

begin_define
define|#
directive|define
name|NI4BISPPP
value|0
end_define

begin_include
include|#
directive|include
file|"ibc.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"i4bisppp.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"i4brbch.h"
end_include

begin_include
include|#
directive|include
file|"i4btel.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<machine/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_cause.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i4b/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<i4b/i4b_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<i4b/i4b_cause.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i4b/include/i4b_global.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_l3l4.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer4/i4b_l4.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|memcpy
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|)
value|bcopy((src), (dst), (len))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|unsigned
name|int
name|i4b_l4_debug
init|=
name|L4_DEBUG_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ctrl_type_desc
name|ctrl_types
index|[
name|CTRL_NUMTYPES
index|]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|i4b_link_bchandrvr
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i4b_unlink_bchandrvr
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i4b_l4_setup_timeout
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i4b_idle_check_fix_unit
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i4b_idle_check_var_unit
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i4b_l4_setup_timeout_fix_unit
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i4b_l4_setup_timeout_var_unit
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|i4b_get_idletime
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|NI4BISPPP
operator|>
literal|0
end_if

begin_function_decl
specifier|extern
name|time_t
name|i4bisppp_idletime
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_PDEACT_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_pdeact
parameter_list|(
name|int
name|controller
parameter_list|,
name|int
name|numactive
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|call_desc_t
modifier|*
name|cd
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_CALL_DESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|call_desc
index|[
name|i
index|]
operator|.
name|cdid
operator|!=
name|CDID_UNUSED
operator|)
operator|&&
operator|(
name|ctrl_desc
index|[
name|call_desc
index|[
name|i
index|]
operator|.
name|controller
index|]
operator|.
name|ctrl_type
operator|==
name|CTRL_PASSIVE
operator|)
operator|&&
operator|(
name|ctrl_desc
index|[
name|call_desc
index|[
name|i
index|]
operator|.
name|controller
index|]
operator|.
name|unit
operator|==
name|controller
operator|)
condition|)
block|{
name|cd
operator|=
operator|&
name|call_desc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|timeout_active
condition|)
block|{
name|STOP_TIMER
argument_list|(
name|cd
operator|->
name|idle_timeout_handle
argument_list|,
name|i4b_idle_check
argument_list|,
name|cd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cd
operator|->
name|dlt
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|cd
operator|->
name|dlt
operator|->
name|line_disconnected
call|)
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cd
argument_list|)
expr_stmt|;
name|i4b_unlink_bchandrvr
argument_list|(
name|cd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cd
operator|->
name|channelid
operator|>=
literal|0
operator|)
operator|&
operator|(
name|cd
operator|->
name|channelid
operator|<
name|ctrl_desc
index|[
name|cd
operator|->
name|controller
index|]
operator|.
name|nbch
operator|)
condition|)
block|{
name|ctrl_desc
index|[
name|cd
operator|->
name|controller
index|]
operator|.
name|bch_state
index|[
name|cd
operator|->
name|channelid
index|]
operator|=
name|BCH_ST_FREE
expr_stmt|;
block|}
name|cd
operator|->
name|cdid
operator|=
name|CDID_UNUSED
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_pdeact_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_pdeact_ind_t
modifier|*
name|md
init|=
operator|(
name|msg_pdeact_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|md
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_PDEACT_IND
expr_stmt|;
name|md
operator|->
name|header
operator|.
name|cdid
operator|=
operator|-
literal|1
expr_stmt|;
name|md
operator|->
name|controller
operator|=
name|controller
expr_stmt|;
name|md
operator|->
name|numactive
operator|=
name|numactive
expr_stmt|;
name|i4bputqueue_hipri
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* URGENT !!! */
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_L12STAT_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_l12stat
parameter_list|(
name|int
name|controller
parameter_list|,
name|int
name|layer
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_l12stat_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_l12stat_ind_t
modifier|*
name|md
init|=
operator|(
name|msg_l12stat_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|md
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_L12STAT_IND
expr_stmt|;
name|md
operator|->
name|header
operator|.
name|cdid
operator|=
operator|-
literal|1
expr_stmt|;
name|md
operator|->
name|controller
operator|=
name|controller
expr_stmt|;
name|md
operator|->
name|layer
operator|=
name|layer
expr_stmt|;
name|md
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_TEIASG_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_teiasg
parameter_list|(
name|int
name|controller
parameter_list|,
name|int
name|tei
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_teiasg_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_teiasg_ind_t
modifier|*
name|md
init|=
operator|(
name|msg_teiasg_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|md
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_TEIASG_IND
expr_stmt|;
name|md
operator|->
name|header
operator|.
name|cdid
operator|=
operator|-
literal|1
expr_stmt|;
name|md
operator|->
name|controller
operator|=
name|controller
expr_stmt|;
name|md
operator|->
name|tei
operator|=
name|ctrl_desc
index|[
name|controller
index|]
operator|.
name|tei
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_DIALOUT_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_dialout
parameter_list|(
name|int
name|driver
parameter_list|,
name|int
name|driver_unit
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_dialout_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_dialout_ind_t
modifier|*
name|md
init|=
operator|(
name|msg_dialout_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|md
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_DIALOUT_IND
expr_stmt|;
name|md
operator|->
name|header
operator|.
name|cdid
operator|=
operator|-
literal|1
expr_stmt|;
name|md
operator|->
name|driver
operator|=
name|driver
expr_stmt|;
name|md
operator|->
name|driver_unit
operator|=
name|driver_unit
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_DIALOUTNUMBER_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_dialoutnumber
parameter_list|(
name|int
name|driver
parameter_list|,
name|int
name|driver_unit
parameter_list|,
name|int
name|cmdlen
parameter_list|,
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_dialoutnumber_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_dialoutnumber_ind_t
modifier|*
name|md
init|=
operator|(
name|msg_dialoutnumber_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|md
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_DIALOUTNUMBER_IND
expr_stmt|;
name|md
operator|->
name|header
operator|.
name|cdid
operator|=
operator|-
literal|1
expr_stmt|;
name|md
operator|->
name|driver
operator|=
name|driver
expr_stmt|;
name|md
operator|->
name|driver_unit
operator|=
name|driver_unit
expr_stmt|;
if|if
condition|(
name|cmdlen
operator|>
name|TELNO_MAX
condition|)
name|cmdlen
operator|=
name|TELNO_MAX
expr_stmt|;
name|md
operator|->
name|cmdlen
operator|=
name|cmdlen
expr_stmt|;
name|bcopy
argument_list|(
name|cmd
argument_list|,
name|md
operator|->
name|cmd
argument_list|,
name|cmdlen
argument_list|)
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_KEYPAD_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_keypad
parameter_list|(
name|int
name|driver
parameter_list|,
name|int
name|driver_unit
parameter_list|,
name|int
name|cmdlen
parameter_list|,
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_keypad_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_keypad_ind_t
modifier|*
name|md
init|=
operator|(
name|msg_keypad_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|md
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_KEYPAD_IND
expr_stmt|;
name|md
operator|->
name|header
operator|.
name|cdid
operator|=
operator|-
literal|1
expr_stmt|;
name|md
operator|->
name|driver
operator|=
name|driver
expr_stmt|;
name|md
operator|->
name|driver_unit
operator|=
name|driver_unit
expr_stmt|;
if|if
condition|(
name|cmdlen
operator|>
name|KEYPAD_MAX
condition|)
name|cmdlen
operator|=
name|KEYPAD_MAX
expr_stmt|;
name|md
operator|->
name|cmdlen
operator|=
name|cmdlen
expr_stmt|;
name|bcopy
argument_list|(
name|cmd
argument_list|,
name|md
operator|->
name|cmd
argument_list|,
name|cmdlen
argument_list|)
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_NEGOTIATION_COMPL message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_negcomplete
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_negcomplete_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_negcomplete_ind_t
modifier|*
name|md
init|=
operator|(
name|msg_negcomplete_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|md
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_NEGCOMP_IND
expr_stmt|;
name|md
operator|->
name|header
operator|.
name|cdid
operator|=
name|cd
operator|->
name|cdid
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_IFSTATE_CHANGED_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_ifstate_changed
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|,
name|int
name|new_state
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_ifstatechg_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_ifstatechg_ind_t
modifier|*
name|md
init|=
operator|(
name|msg_ifstatechg_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|md
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_IFSTATE_CHANGED_IND
expr_stmt|;
name|md
operator|->
name|header
operator|.
name|cdid
operator|=
name|cd
operator|->
name|cdid
expr_stmt|;
name|md
operator|->
name|state
operator|=
name|new_state
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_DRVRDISC_REQ message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_drvrdisc
parameter_list|(
name|int
name|driver
parameter_list|,
name|int
name|driver_unit
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_drvrdisc_req_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_drvrdisc_req_t
modifier|*
name|md
init|=
operator|(
name|msg_drvrdisc_req_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|md
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_DRVRDISC_REQ
expr_stmt|;
name|md
operator|->
name|header
operator|.
name|cdid
operator|=
operator|-
literal|1
expr_stmt|;
name|md
operator|->
name|driver
operator|=
name|driver
expr_stmt|;
name|md
operator|->
name|driver_unit
operator|=
name|driver_unit
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_ACCT_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_accounting
parameter_list|(
name|int
name|driver
parameter_list|,
name|int
name|driver_unit
parameter_list|,
name|int
name|accttype
parameter_list|,
name|int
name|ioutbytes
parameter_list|,
name|int
name|iinbytes
parameter_list|,
name|int
name|ro
parameter_list|,
name|int
name|ri
parameter_list|,
name|int
name|outbytes
parameter_list|,
name|int
name|inbytes
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_accounting_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_accounting_ind_t
modifier|*
name|md
init|=
operator|(
name|msg_accounting_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|md
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_ACCT_IND
expr_stmt|;
name|md
operator|->
name|header
operator|.
name|cdid
operator|=
operator|-
literal|1
expr_stmt|;
name|md
operator|->
name|driver
operator|=
name|driver
expr_stmt|;
name|md
operator|->
name|driver_unit
operator|=
name|driver_unit
expr_stmt|;
name|md
operator|->
name|accttype
operator|=
name|accttype
expr_stmt|;
name|md
operator|->
name|ioutbytes
operator|=
name|ioutbytes
expr_stmt|;
name|md
operator|->
name|iinbytes
operator|=
name|iinbytes
expr_stmt|;
name|md
operator|->
name|outbps
operator|=
name|ro
expr_stmt|;
name|md
operator|->
name|inbps
operator|=
name|ri
expr_stmt|;
name|md
operator|->
name|outbytes
operator|=
name|outbytes
expr_stmt|;
name|md
operator|->
name|inbytes
operator|=
name|inbytes
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_CONNECT_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_connect_ind
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_connect_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_connect_ind_t
modifier|*
name|mp
init|=
operator|(
name|msg_connect_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|mp
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_CONNECT_IND
expr_stmt|;
name|mp
operator|->
name|header
operator|.
name|cdid
operator|=
name|cd
operator|->
name|cdid
expr_stmt|;
name|mp
operator|->
name|controller
operator|=
name|cd
operator|->
name|controller
expr_stmt|;
name|mp
operator|->
name|channel
operator|=
name|cd
operator|->
name|channelid
expr_stmt|;
name|mp
operator|->
name|bprot
operator|=
name|cd
operator|->
name|bprot
expr_stmt|;
name|cd
operator|->
name|dir
operator|=
name|DIR_INCOMING
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|cd
operator|->
name|dst_telno
argument_list|)
operator|>
literal|0
condition|)
name|strcpy
argument_list|(
name|mp
operator|->
name|dst_telno
argument_list|,
name|cd
operator|->
name|dst_telno
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|mp
operator|->
name|dst_telno
argument_list|,
name|TELNO_EMPTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|cd
operator|->
name|src_telno
argument_list|)
operator|>
literal|0
condition|)
name|strcpy
argument_list|(
name|mp
operator|->
name|src_telno
argument_list|,
name|cd
operator|->
name|src_telno
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|mp
operator|->
name|src_telno
argument_list|,
name|TELNO_EMPTY
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mp
operator|->
name|display
argument_list|,
name|cd
operator|->
name|display
argument_list|)
expr_stmt|;
name|mp
operator|->
name|scr_ind
operator|=
name|cd
operator|->
name|scr_ind
expr_stmt|;
name|mp
operator|->
name|prs_ind
operator|=
name|cd
operator|->
name|prs_ind
expr_stmt|;
name|T400_start
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_CONNECT_ACTIVE_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_connect_active_ind
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|s
operator|=
name|SPLI4B
argument_list|()
expr_stmt|;
name|cd
operator|->
name|last_active_time
operator|=
name|cd
operator|->
name|connect_time
operator|=
name|SECOND
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"last_active/connect_time=%ld"
argument_list|,
operator|(
name|long
operator|)
name|cd
operator|->
name|connect_time
argument_list|)
expr_stmt|;
name|i4b_link_bchandrvr
argument_list|(
name|cd
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cd
operator|->
name|dlt
operator|->
name|line_connected
call|)
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cd
argument_list|)
expr_stmt|;
name|i4b_l4_setup_timeout
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_connect_active_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_connect_active_ind_t
modifier|*
name|mp
init|=
operator|(
name|msg_connect_active_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|mp
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_CONNECT_ACTIVE_IND
expr_stmt|;
name|mp
operator|->
name|header
operator|.
name|cdid
operator|=
name|cd
operator|->
name|cdid
expr_stmt|;
name|mp
operator|->
name|controller
operator|=
name|cd
operator|->
name|controller
expr_stmt|;
name|mp
operator|->
name|channel
operator|=
name|cd
operator|->
name|channelid
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|datetime
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|mp
operator|->
name|datetime
argument_list|,
name|cd
operator|->
name|datetime
argument_list|)
expr_stmt|;
else|else
name|mp
operator|->
name|datetime
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_DISCONNECT_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_disconnect_ind
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|cd
operator|->
name|timeout_active
condition|)
name|STOP_TIMER
argument_list|(
name|cd
operator|->
name|idle_timeout_handle
argument_list|,
name|i4b_idle_check
argument_list|,
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlt
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|cd
operator|->
name|dlt
operator|->
name|line_disconnected
call|)
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cd
argument_list|)
expr_stmt|;
name|i4b_unlink_bchandrvr
argument_list|(
name|cd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cd
operator|->
name|channelid
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|cd
operator|->
name|channelid
operator|<
name|ctrl_desc
index|[
name|cd
operator|->
name|controller
index|]
operator|.
name|nbch
operator|)
condition|)
block|{
name|ctrl_desc
index|[
name|cd
operator|->
name|controller
index|]
operator|.
name|bch_state
index|[
name|cd
operator|->
name|channelid
index|]
operator|=
name|BCH_ST_FREE
expr_stmt|;
block|}
else|else
block|{
comment|/* no error, might be hunting call for callback */
name|NDBGL4
argument_list|(
name|L4_MSG
argument_list|,
literal|"channel free not valid but %d!"
argument_list|,
name|cd
operator|->
name|channelid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_disconnect_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_disconnect_ind_t
modifier|*
name|mp
init|=
operator|(
name|msg_disconnect_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|mp
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_DISCONNECT_IND
expr_stmt|;
name|mp
operator|->
name|header
operator|.
name|cdid
operator|=
name|cd
operator|->
name|cdid
expr_stmt|;
name|mp
operator|->
name|cause
operator|=
name|cd
operator|->
name|cause_in
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_IDLE_TIMEOUT_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_idle_timeout_ind
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_idle_timeout_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_idle_timeout_ind_t
modifier|*
name|mp
init|=
operator|(
name|msg_idle_timeout_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|mp
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_IDLE_TIMEOUT_IND
expr_stmt|;
name|mp
operator|->
name|header
operator|.
name|cdid
operator|=
name|cd
operator|->
name|cdid
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_CHARGING_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_charging_ind
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_charging_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_charging_ind_t
modifier|*
name|mp
init|=
operator|(
name|msg_charging_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|mp
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_CHARGING_IND
expr_stmt|;
name|mp
operator|->
name|header
operator|.
name|cdid
operator|=
name|cd
operator|->
name|cdid
expr_stmt|;
name|mp
operator|->
name|units_type
operator|=
name|cd
operator|->
name|units_type
expr_stmt|;
comment|/*XXX*/
if|if
condition|(
name|mp
operator|->
name|units_type
operator|==
name|CHARGE_CALC
condition|)
name|mp
operator|->
name|units
operator|=
name|cd
operator|->
name|cunits
expr_stmt|;
else|else
name|mp
operator|->
name|units
operator|=
name|cd
operator|->
name|units
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_STATUS_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_status_ind
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_ALERT_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_alert_ind
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_alert_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_alert_ind_t
modifier|*
name|mp
init|=
operator|(
name|msg_alert_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|mp
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_ALERT_IND
expr_stmt|;
name|mp
operator|->
name|header
operator|.
name|cdid
operator|=
name|cd
operator|->
name|cdid
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_INFO_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_info_ind
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	send MSG_INFO_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_proceeding_ind
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_proceeding_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_proceeding_ind_t
modifier|*
name|mp
init|=
operator|(
name|msg_proceeding_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|mp
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_PROCEEDING_IND
expr_stmt|;
name|mp
operator|->
name|header
operator|.
name|cdid
operator|=
name|cd
operator|->
name|cdid
expr_stmt|;
name|mp
operator|->
name|controller
operator|=
name|cd
operator|->
name|controller
expr_stmt|;
name|mp
operator|->
name|channel
operator|=
name|cd
operator|->
name|channelid
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *    send MSG_PACKET_IND message to userland  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_l4_packet_ind
parameter_list|(
name|int
name|driver
parameter_list|,
name|int
name|driver_unit
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|mbuf
modifier|*
name|pkt
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
init|=
name|pkt
operator|->
name|m_pkthdr
operator|.
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ip
init|=
name|pkt
operator|->
name|m_data
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|i4b_Dgetmbuf
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_packet_ind_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg_packet_ind_t
modifier|*
name|mp
init|=
operator|(
name|msg_packet_ind_t
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
name|mp
operator|->
name|header
operator|.
name|type
operator|=
name|MSG_PACKET_IND
expr_stmt|;
name|mp
operator|->
name|header
operator|.
name|cdid
operator|=
operator|-
literal|1
expr_stmt|;
name|mp
operator|->
name|driver
operator|=
name|driver
expr_stmt|;
name|mp
operator|->
name|driver_unit
operator|=
name|driver_unit
expr_stmt|;
name|mp
operator|->
name|direction
operator|=
name|dir
expr_stmt|;
name|memcpy
argument_list|(
name|mp
operator|->
name|pktdata
argument_list|,
name|ip
argument_list|,
name|len
operator|<
name|MAX_PACKET_LOG
condition|?
name|len
else|:
name|MAX_PACKET_LOG
argument_list|)
expr_stmt|;
name|i4bputqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	link a driver(unit) to a B-channel(controller,unit,channel)  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|i4b_link_bchandrvr
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
name|int
name|t
init|=
name|ctrl_desc
index|[
name|cd
operator|->
name|controller
index|]
operator|.
name|ctrl_type
decl_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
operator|||
name|t
operator|>=
name|CTRL_NUMTYPES
operator|||
name|ctrl_types
index|[
name|t
index|]
operator|.
name|get_linktab
operator|==
name|NULL
condition|)
block|{
name|cd
operator|->
name|ilt
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|cd
operator|->
name|ilt
operator|=
name|ctrl_types
index|[
name|t
index|]
operator|.
name|get_linktab
argument_list|(
name|ctrl_desc
index|[
name|cd
operator|->
name|controller
index|]
operator|.
name|unit
argument_list|,
name|cd
operator|->
name|channelid
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|cd
operator|->
name|driver
condition|)
block|{
if|#
directive|if
name|NI4BRBCH
operator|>
literal|0
case|case
name|BDRV_RBCH
case|:
name|cd
operator|->
name|dlt
operator|=
name|rbch_ret_linktab
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NI4BTEL
operator|>
literal|0
case|case
name|BDRV_TEL
case|:
name|cd
operator|->
name|dlt
operator|=
name|tel_ret_linktab
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NI4BIPR
operator|>
literal|0
case|case
name|BDRV_IPR
case|:
name|cd
operator|->
name|dlt
operator|=
name|ipr_ret_linktab
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NI4BISPPP
operator|>
literal|0
case|case
name|BDRV_ISPPP
case|:
name|cd
operator|->
name|dlt
operator|=
name|i4bisppp_ret_linktab
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
operator|&&
name|NIBC
operator|>
literal|0
case|case
name|BDRV_IBC
case|:
name|cd
operator|->
name|dlt
operator|=
name|ibc_ret_linktab
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NI4BING
operator|>
literal|0
case|case
name|BDRV_ING
case|:
name|cd
operator|->
name|dlt
operator|=
name|ing_ret_linktab
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|cd
operator|->
name|dlt
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cd
operator|->
name|dlt
operator|==
name|NULL
operator|||
name|cd
operator|->
name|ilt
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|t
operator|>=
literal|0
operator|&&
name|t
operator|<
name|CTRL_NUMTYPES
operator|&&
name|ctrl_types
index|[
name|t
index|]
operator|.
name|set_linktab
operator|!=
name|NULL
condition|)
block|{
name|ctrl_types
index|[
name|t
index|]
operator|.
name|set_linktab
argument_list|(
name|ctrl_desc
index|[
name|cd
operator|->
name|controller
index|]
operator|.
name|unit
argument_list|,
name|cd
operator|->
name|channelid
argument_list|,
name|cd
operator|->
name|dlt
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|cd
operator|->
name|driver
condition|)
block|{
if|#
directive|if
name|NI4BRBCH
operator|>
literal|0
case|case
name|BDRV_RBCH
case|:
name|rbch_set_linktab
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|,
name|cd
operator|->
name|ilt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NI4BTEL
operator|>
literal|0
case|case
name|BDRV_TEL
case|:
name|tel_set_linktab
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|,
name|cd
operator|->
name|ilt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NI4BIPR
operator|>
literal|0
case|case
name|BDRV_IPR
case|:
name|ipr_set_linktab
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|,
name|cd
operator|->
name|ilt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NI4BISPPP
operator|>
literal|0
case|case
name|BDRV_ISPPP
case|:
name|i4bisppp_set_linktab
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|,
name|cd
operator|->
name|ilt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
operator|&&
name|NIBC
operator|>
literal|0
case|case
name|BDRV_IBC
case|:
name|ibc_set_linktab
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|,
name|cd
operator|->
name|ilt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NI4BING
operator|>
literal|0
case|case
name|BDRV_ING
case|:
name|ing_set_linktab
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|,
name|cd
operator|->
name|ilt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
comment|/* activate B channel */
call|(
modifier|*
name|cd
operator|->
name|ilt
operator|->
name|bch_config
call|)
argument_list|(
name|cd
operator|->
name|ilt
operator|->
name|unit
argument_list|,
name|cd
operator|->
name|ilt
operator|->
name|channel
argument_list|,
name|cd
operator|->
name|bprot
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	unlink a driver(unit) from a B-channel(controller,unit,channel)  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|i4b_unlink_bchandrvr
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
name|int
name|t
init|=
name|ctrl_desc
index|[
name|cd
operator|->
name|controller
index|]
operator|.
name|ctrl_type
decl_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
operator|||
name|t
operator|>=
name|CTRL_NUMTYPES
operator|||
name|ctrl_types
index|[
name|t
index|]
operator|.
name|get_linktab
operator|==
name|NULL
condition|)
block|{
name|cd
operator|->
name|ilt
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
else|else
block|{
name|cd
operator|->
name|ilt
operator|=
name|ctrl_types
index|[
name|t
index|]
operator|.
name|get_linktab
argument_list|(
name|ctrl_desc
index|[
name|cd
operator|->
name|controller
index|]
operator|.
name|unit
argument_list|,
name|cd
operator|->
name|channelid
argument_list|)
expr_stmt|;
block|}
comment|/* deactivate B channel */
call|(
modifier|*
name|cd
operator|->
name|ilt
operator|->
name|bch_config
call|)
argument_list|(
name|cd
operator|->
name|ilt
operator|->
name|unit
argument_list|,
name|cd
operator|->
name|ilt
operator|->
name|channel
argument_list|,
name|cd
operator|->
name|bprot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------  	How shorthold mode works for OUTGOING connections 	=================================================  	|<---- unchecked-window ------->|<-checkwindow->|<-safetywindow>|  idletime_state:      IST_NONCHK             IST_CHECK       IST_SAFE	 	 	|				|		|		|   time>>+-------------------------------+---------------+---------------+-... 	|				|		|		| 	|				|<--idle_time-->|<--earlyhup--->| 	|<-----------------------unitlen------------------------------->|  	 	  unitlen - specifies the time a charging unit lasts 	idle_time - specifies the thime the line must be idle at the 		    end of the unit to be elected for hangup 	 earlyhup - is the beginning of a timing safety zone before the 		    next charging unit starts  	The algorithm works as follows: lets assume the unitlen is 100 	secons, idle_time is 40 seconds and earlyhup is 10 seconds. 	The line then must be idle 50 seconds after the begin of the 	current unit and it must then be quiet for 40 seconds. if it 	has been quiet for this 40 seconds, the line is closed 10 	seconds before the next charging unit starts. In case there was 	any traffic within the idle_time, the line is not closed. 	It does not matter whether there was any traffic between second 	0 and second 50 or not.   	How shorthold mode works for INCOMING connections 	=================================================  	it is just possible to specify a maximum idle time for incoming 	connections, after this time of no activity on the line the line 	is closed. 	 ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|time_t
name|i4b_get_idletime
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
switch|switch
condition|(
name|cd
operator|->
name|driver
condition|)
block|{
if|#
directive|if
name|NI4BISPPP
operator|>
literal|0
case|case
name|BDRV_ISPPP
case|:
return|return
name|i4bisppp_idletime
argument_list|(
name|cd
operator|->
name|driver_unit
argument_list|)
return|;
break|break;
endif|#
directive|endif
default|default:
return|return
name|cd
operator|->
name|last_active_time
return|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	B channel idle check timeout setup  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|i4b_l4_setup_timeout
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: direction %d, shorthold algorithm %d"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|,
name|cd
operator|->
name|dir
argument_list|,
name|cd
operator|->
name|shorthold_data
operator|.
name|shorthold_algorithm
argument_list|)
expr_stmt|;
name|cd
operator|->
name|timeout_active
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|idletime_state
operator|=
name|IST_IDLE
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|dir
operator|==
name|DIR_INCOMING
operator|)
operator|&&
operator|(
name|cd
operator|->
name|max_idle_time
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* incoming call: simple max idletime check */
name|START_TIMER
argument_list|(
name|cd
operator|->
name|idle_timeout_handle
argument_list|,
name|i4b_idle_check
argument_list|,
name|cd
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
name|cd
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: incoming-call, setup max_idle_time to %ld"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|,
operator|(
name|long
operator|)
name|cd
operator|->
name|max_idle_time
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cd
operator|->
name|dir
operator|==
name|DIR_OUTGOING
operator|)
operator|&&
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|idle_time
operator|>
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|cd
operator|->
name|shorthold_data
operator|.
name|shorthold_algorithm
condition|)
block|{
default|default:
comment|/* fall into the old fix algorithm */
case|case
name|SHA_FIXU
case|:
name|i4b_l4_setup_timeout_fix_unit
argument_list|(
name|cd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHA_VARU
case|:
name|i4b_l4_setup_timeout_var_unit
argument_list|(
name|cd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"no idle_timeout configured"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	fixed unit algorithm B channel idle check timeout setup  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|i4b_l4_setup_timeout_fix_unit
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
comment|/* outgoing call */
if|if
condition|(
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|idle_time
operator|>
literal|0
operator|)
operator|&&
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|unitlen_time
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* outgoing call: simple max idletime check */
name|START_TIMER
argument_list|(
name|cd
operator|->
name|idle_timeout_handle
argument_list|,
name|i4b_idle_check
argument_list|,
name|cd
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
name|cd
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: outgoing-call, setup idle_time to %ld"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|,
operator|(
name|long
operator|)
name|cd
operator|->
name|shorthold_data
operator|.
name|idle_time
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|unitlen_time
operator|>
literal|0
operator|)
operator|&&
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|unitlen_time
operator|>
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|idle_time
operator|+
name|cd
operator|->
name|shorthold_data
operator|.
name|earlyhup_time
operator|)
operator|)
condition|)
block|{
comment|/* outgoing call: full shorthold mode check */
name|START_TIMER
argument_list|(
name|cd
operator|->
name|idle_timeout_handle
argument_list|,
name|i4b_idle_check
argument_list|,
name|cd
argument_list|,
name|hz
operator|*
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|unitlen_time
operator|-
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|idle_time
operator|+
name|cd
operator|->
name|shorthold_data
operator|.
name|earlyhup_time
operator|)
operator|)
argument_list|)
expr_stmt|;
name|cd
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
name|cd
operator|->
name|idletime_state
operator|=
name|IST_NONCHK
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: outgoing-call, start %ld sec nocheck window"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|,
call|(
name|long
call|)
argument_list|(
name|cd
operator|->
name|shorthold_data
operator|.
name|unitlen_time
operator|-
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|idle_time
operator|+
name|cd
operator|->
name|shorthold_data
operator|.
name|earlyhup_time
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|aocd_flag
operator|==
literal|0
condition|)
block|{
name|cd
operator|->
name|units_type
operator|=
name|CHARGE_CALC
expr_stmt|;
name|cd
operator|->
name|cunits
operator|++
expr_stmt|;
name|i4b_l4_charging_ind
argument_list|(
name|cd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* parms somehow got wrong .. */
name|NDBGL4
argument_list|(
name|L4_ERR
argument_list|,
literal|"%ld: ERROR: idletime[%ld]+earlyhup[%ld]> unitlength[%ld]!"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|,
operator|(
name|long
operator|)
name|cd
operator|->
name|shorthold_data
operator|.
name|idle_time
argument_list|,
operator|(
name|long
operator|)
name|cd
operator|->
name|shorthold_data
operator|.
name|earlyhup_time
argument_list|,
operator|(
name|long
operator|)
name|cd
operator|->
name|shorthold_data
operator|.
name|unitlen_time
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	variable unit algorithm B channel idle check timeout setup  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|i4b_l4_setup_timeout_var_unit
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
comment|/* outgoing call: variable unit idletime check */
comment|/* 	 * start checking for an idle connect one second before the end of the unit. 	 * The one second takes into account of rounding due to the driver only 	 * using the seconds and not the uSeconds of the current time 	 */
name|cd
operator|->
name|idletime_state
operator|=
name|IST_CHECK
expr_stmt|;
comment|/* move directly to the checking state */
name|START_TIMER
argument_list|(
name|cd
operator|->
name|idle_timeout_handle
argument_list|,
name|i4b_idle_check
argument_list|,
name|cd
argument_list|,
name|hz
operator|*
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|unitlen_time
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cd
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: outgoing-call, var idle time - setup to %ld"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|,
operator|(
name|long
operator|)
name|cd
operator|->
name|shorthold_data
operator|.
name|unitlen_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	B channel idle check timeout function  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_idle_check
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|cd
operator|->
name|cdid
operator|==
name|CDID_UNUSED
condition|)
return|return;
name|s
operator|=
name|SPLI4B
argument_list|()
expr_stmt|;
comment|/* failsafe */
if|if
condition|(
name|cd
operator|->
name|timeout_active
operator|==
literal|0
condition|)
block|{
name|NDBGL4
argument_list|(
name|L4_ERR
argument_list|,
literal|"ERROR: timeout_active == 0 !!!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cd
operator|->
name|timeout_active
operator|=
literal|0
expr_stmt|;
block|}
comment|/* incoming connections, simple idletime check */
if|if
condition|(
name|cd
operator|->
name|dir
operator|==
name|DIR_INCOMING
condition|)
block|{
if|if
condition|(
operator|(
name|i4b_get_idletime
argument_list|(
name|cd
argument_list|)
operator|+
name|cd
operator|->
name|max_idle_time
operator|)
operator|<=
name|SECOND
condition|)
block|{
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: incoming-call, line idle timeout, disconnecting!"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ctrl_desc
index|[
name|cd
operator|->
name|controller
index|]
operator|.
name|N_DISCONNECT_REQUEST
operator|)
operator|(
name|cd
operator|->
name|cdid
operator|,
operator|(
name|CAUSET_I4B
operator|<<
literal|8
operator|)
operator||
name|CAUSE_I4B_NORMAL
operator|)
expr_stmt|;
name|i4b_l4_idle_timeout_ind
argument_list|(
name|cd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: incoming-call, activity, last_active=%ld, max_idle=%ld"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|,
operator|(
name|long
operator|)
name|i4b_get_idletime
argument_list|(
name|cd
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|cd
operator|->
name|max_idle_time
argument_list|)
expr_stmt|;
name|START_TIMER
argument_list|(
name|cd
operator|->
name|idle_timeout_handle
argument_list|,
name|i4b_idle_check
argument_list|,
name|cd
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
name|cd
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* outgoing connections */
elseif|else
if|if
condition|(
name|cd
operator|->
name|dir
operator|==
name|DIR_OUTGOING
condition|)
block|{
switch|switch
condition|(
name|cd
operator|->
name|shorthold_data
operator|.
name|shorthold_algorithm
condition|)
block|{
case|case
name|SHA_FIXU
case|:
name|i4b_idle_check_fix_unit
argument_list|(
name|cd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHA_VARU
case|:
name|i4b_idle_check_var_unit
argument_list|(
name|cd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: bad value for shorthold_algorithm of %d"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|,
name|cd
operator|->
name|shorthold_data
operator|.
name|shorthold_algorithm
argument_list|)
expr_stmt|;
name|i4b_idle_check_fix_unit
argument_list|(
name|cd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	fixed unit algorithm B channel idle check timeout function  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|i4b_idle_check_fix_unit
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
comment|/* simple idletime calculation */
if|if
condition|(
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|idle_time
operator|>
literal|0
operator|)
operator|&&
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|unitlen_time
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|i4b_get_idletime
argument_list|(
name|cd
argument_list|)
operator|+
name|cd
operator|->
name|shorthold_data
operator|.
name|idle_time
operator|)
operator|<=
name|SECOND
condition|)
block|{
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: outgoing-call-st, idle timeout, disconnecting!"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ctrl_desc
index|[
name|cd
operator|->
name|controller
index|]
operator|.
name|N_DISCONNECT_REQUEST
operator|)
operator|(
name|cd
operator|->
name|cdid
operator|,
operator|(
name|CAUSET_I4B
operator|<<
literal|8
operator|)
operator||
name|CAUSE_I4B_NORMAL
operator|)
expr_stmt|;
name|i4b_l4_idle_timeout_ind
argument_list|(
name|cd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: outgoing-call-st, activity, last_active=%ld, max_idle=%ld"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|,
operator|(
name|long
operator|)
name|i4b_get_idletime
argument_list|(
name|cd
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|cd
operator|->
name|shorthold_data
operator|.
name|idle_time
argument_list|)
expr_stmt|;
name|START_TIMER
argument_list|(
name|cd
operator|->
name|idle_timeout_handle
argument_list|,
name|i4b_idle_check
argument_list|,
name|cd
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
name|cd
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* full shorthold mode calculation */
elseif|else
if|if
condition|(
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|unitlen_time
operator|>
literal|0
operator|)
operator|&&
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|unitlen_time
operator|>
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|idle_time
operator|+
name|cd
operator|->
name|shorthold_data
operator|.
name|earlyhup_time
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|cd
operator|->
name|idletime_state
condition|)
block|{
case|case
name|IST_NONCHK
case|:
comment|/* end of non-check time */
name|START_TIMER
argument_list|(
name|cd
operator|->
name|idle_timeout_handle
argument_list|,
name|i4b_idle_check
argument_list|,
name|cd
argument_list|,
name|hz
operator|*
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|idle_time
operator|)
argument_list|)
expr_stmt|;
name|cd
operator|->
name|idletimechk_start
operator|=
name|SECOND
expr_stmt|;
name|cd
operator|->
name|idletime_state
operator|=
name|IST_CHECK
expr_stmt|;
name|cd
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: outgoing-call, idletime check window reached!"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|)
expr_stmt|;
break|break;
case|case
name|IST_CHECK
case|:
comment|/* end of idletime chk */
if|if
condition|(
operator|(
name|i4b_get_idletime
argument_list|(
name|cd
argument_list|)
operator|>
name|cd
operator|->
name|idletimechk_start
operator|)
operator|&&
operator|(
name|i4b_get_idletime
argument_list|(
name|cd
argument_list|)
operator|<=
name|SECOND
operator|)
condition|)
block|{
comment|/* activity detected */
name|START_TIMER
argument_list|(
name|cd
operator|->
name|idle_timeout_handle
argument_list|,
name|i4b_idle_check
argument_list|,
name|cd
argument_list|,
name|hz
operator|*
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|earlyhup_time
operator|)
argument_list|)
expr_stmt|;
name|cd
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
name|cd
operator|->
name|idletime_state
operator|=
name|IST_SAFE
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: outgoing-call, activity at %ld, wait earlyhup-end"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|,
operator|(
name|long
operator|)
name|i4b_get_idletime
argument_list|(
name|cd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* no activity, hangup */
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: outgoing-call, idle timeout, last activity at %ld"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|,
operator|(
name|long
operator|)
name|i4b_get_idletime
argument_list|(
name|cd
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ctrl_desc
index|[
name|cd
operator|->
name|controller
index|]
operator|.
name|N_DISCONNECT_REQUEST
operator|)
operator|(
name|cd
operator|->
name|cdid
operator|,
operator|(
name|CAUSET_I4B
operator|<<
literal|8
operator|)
operator||
name|CAUSE_I4B_NORMAL
operator|)
expr_stmt|;
name|i4b_l4_idle_timeout_ind
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|cd
operator|->
name|idletime_state
operator|=
name|IST_IDLE
expr_stmt|;
block|}
break|break;
case|case
name|IST_SAFE
case|:
comment|/* end of earlyhup time */
name|START_TIMER
argument_list|(
name|cd
operator|->
name|idle_timeout_handle
argument_list|,
name|i4b_idle_check
argument_list|,
name|cd
argument_list|,
name|hz
operator|*
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|unitlen_time
operator|-
operator|(
name|cd
operator|->
name|shorthold_data
operator|.
name|idle_time
operator|+
name|cd
operator|->
name|shorthold_data
operator|.
name|earlyhup_time
operator|)
operator|)
argument_list|)
expr_stmt|;
name|cd
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
name|cd
operator|->
name|idletime_state
operator|=
name|IST_NONCHK
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|aocd_flag
operator|==
literal|0
condition|)
block|{
name|cd
operator|->
name|units_type
operator|=
name|CHARGE_CALC
expr_stmt|;
name|cd
operator|->
name|cunits
operator|++
expr_stmt|;
name|i4b_l4_charging_ind
argument_list|(
name|cd
argument_list|)
expr_stmt|;
block|}
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: outgoing-call, earlyhup end, wait for idletime start"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|)
expr_stmt|;
break|break;
default|default:
name|NDBGL4
argument_list|(
name|L4_ERR
argument_list|,
literal|"outgoing-call: invalid idletime_state value!"
argument_list|)
expr_stmt|;
name|cd
operator|->
name|idletime_state
operator|=
name|IST_IDLE
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	variable unit algorithm B channel idle check timeout function  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|i4b_idle_check_var_unit
parameter_list|(
name|call_desc_t
modifier|*
name|cd
parameter_list|)
block|{
switch|switch
condition|(
name|cd
operator|->
name|idletime_state
condition|)
block|{
comment|/* see if there has been any activity within the last idle_time seconds */
case|case
name|IST_CHECK
case|:
if|if
condition|(
name|i4b_get_idletime
argument_list|(
name|cd
argument_list|)
operator|>
operator|(
name|SECOND
operator|-
name|cd
operator|->
name|shorthold_data
operator|.
name|idle_time
operator|)
condition|)
block|{
comment|/* activity detected */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|300001
name|cd
operator|->
name|idle_timeout_handle
operator|=
endif|#
directive|endif
comment|/* check again in one second */
name|START_TIMER
argument_list|(
name|cd
operator|->
name|idle_timeout_handle
argument_list|,
name|i4b_idle_check
argument_list|,
name|cd
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|cd
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
name|cd
operator|->
name|idletime_state
operator|=
name|IST_CHECK
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: outgoing-call, var idle timeout - activity at %ld, continuing"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|,
operator|(
name|long
operator|)
name|i4b_get_idletime
argument_list|(
name|cd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* no activity, hangup */
name|NDBGL4
argument_list|(
name|L4_TIMO
argument_list|,
literal|"%ld: outgoing-call, var idle timeout - last activity at %ld"
argument_list|,
operator|(
name|long
operator|)
name|SECOND
argument_list|,
operator|(
name|long
operator|)
name|i4b_get_idletime
argument_list|(
name|cd
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ctrl_desc
index|[
name|cd
operator|->
name|controller
index|]
operator|.
name|N_DISCONNECT_REQUEST
operator|)
operator|(
name|cd
operator|->
name|cdid
operator|,
operator|(
name|CAUSET_I4B
operator|<<
literal|8
operator|)
operator||
name|CAUSE_I4B_NORMAL
operator|)
expr_stmt|;
name|i4b_l4_idle_timeout_ind
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|cd
operator|->
name|idletime_state
operator|=
name|IST_IDLE
expr_stmt|;
block|}
break|break;
default|default:
name|NDBGL4
argument_list|(
name|L4_ERR
argument_list|,
literal|"outgoing-call: var idle timeout invalid idletime_state value!"
argument_list|)
expr_stmt|;
name|cd
operator|->
name|idletime_state
operator|=
name|IST_IDLE
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NI4B> 0 */
end_comment

end_unit

