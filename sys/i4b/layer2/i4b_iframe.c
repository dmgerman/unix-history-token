begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 2002 Hellmuth Michaelis. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	i4b_iframe.c - i frame handling routines  *	------------------------------------------  *      last edit-date: [Sat Mar  9 16:07:21 2002]  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_trace.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_global.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_l1l2.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_l2l3.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer2/i4b_l2.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer2/i4b_l2fsm.h>
end_include

begin_comment
comment|/*---------------------------------------------------------------------------*  *	process i frame  *	implements the routine "I COMMAND" Q.921 03/93 pp 68 and pp 77  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_rxd_i_frame
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|l2_softc_t
modifier|*
name|l2sc
init|=
operator|&
name|l2_softc
index|[
name|unit
index|]
decl_stmt|;
name|u_char
modifier|*
name|ptr
init|=
name|m
operator|->
name|m_data
decl_stmt|;
name|int
name|nr
decl_stmt|;
name|int
name|ns
decl_stmt|;
name|int
name|p
decl_stmt|;
name|CRIT_VAR
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|l2sc
operator|->
name|tei_valid
operator|==
name|TEI_VALID
operator|)
operator|&&
operator|(
name|l2sc
operator|->
name|tei
operator|==
name|GETTEI
argument_list|(
operator|*
operator|(
name|ptr
operator|+
name|OFF_TEI
operator|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|i4b_Dfreembuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|l2sc
operator|->
name|Q921_state
operator|!=
name|ST_MULTIFR
operator|)
operator|&&
operator|(
name|l2sc
operator|->
name|Q921_state
operator|!=
name|ST_TIMREC
operator|)
condition|)
block|{
name|i4b_Dfreembuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NDBGL2
argument_list|(
name|L2_I_ERR
argument_list|,
literal|"ERROR, state != (MF || TR)!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|CRIT_BEG
expr_stmt|;
name|l2sc
operator|->
name|stat
operator|.
name|rx_i
operator|++
expr_stmt|;
comment|/* update frame count */
name|nr
operator|=
name|GETINR
argument_list|(
operator|*
operator|(
name|ptr
operator|+
name|OFF_INR
operator|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|GETINS
argument_list|(
operator|*
operator|(
name|ptr
operator|+
name|OFF_INS
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|GETIP
argument_list|(
operator|*
operator|(
name|ptr
operator|+
name|OFF_INR
operator|)
argument_list|)
expr_stmt|;
name|i4b_rxd_ack
argument_list|(
name|l2sc
argument_list|,
name|nr
argument_list|)
expr_stmt|;
comment|/* last packet ack */
if|if
condition|(
name|l2sc
operator|->
name|own_busy
condition|)
comment|/* own receiver busy ? */
block|{
name|i4b_Dfreembuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* yes, discard information */
if|if
condition|(
name|p
operator|==
literal|1
condition|)
comment|/* P bit == 1 ? */
block|{
name|i4b_tx_rnr_response
argument_list|(
name|l2sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* yes, tx RNR */
name|l2sc
operator|->
name|ack_pend
operator|=
literal|0
expr_stmt|;
comment|/* clear ACK pending */
block|}
block|}
else|else
comment|/* own receiver ready */
block|{
if|if
condition|(
name|ns
operator|==
name|l2sc
operator|->
name|vr
condition|)
comment|/* expected sequence number ? */
block|{
name|M128INC
argument_list|(
name|l2sc
operator|->
name|vr
argument_list|)
expr_stmt|;
comment|/* yes, update */
name|l2sc
operator|->
name|rej_excpt
operator|=
literal|0
expr_stmt|;
comment|/* clr reject exception */
name|m_adj
argument_list|(
name|m
argument_list|,
name|I_HDR_LEN
argument_list|)
expr_stmt|;
comment|/* strip i frame header */
name|l2sc
operator|->
name|iframe_sent
operator|=
literal|0
expr_stmt|;
comment|/* reset i acked already */
name|DL_Data_Ind
argument_list|(
name|l2sc
operator|->
name|unit
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* pass data up */
if|if
condition|(
operator|!
name|l2sc
operator|->
name|iframe_sent
condition|)
block|{
name|i4b_tx_rr_response
argument_list|(
name|l2sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* yes, tx RR */
name|l2sc
operator|->
name|ack_pend
operator|=
literal|0
expr_stmt|;
comment|/* clr ACK pending */
block|}
block|}
else|else
comment|/* ERROR, sequence number NOT expected */
block|{
name|i4b_Dfreembuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* discard information */
if|if
condition|(
name|l2sc
operator|->
name|rej_excpt
operator|==
literal|1
condition|)
comment|/* already exception ? */
block|{
if|if
condition|(
name|p
operator|==
literal|1
condition|)
comment|/* immediate response ? */
block|{
name|i4b_tx_rr_response
argument_list|(
name|l2sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* yes, tx RR */
name|l2sc
operator|->
name|ack_pend
operator|=
literal|0
expr_stmt|;
comment|/* clr ack pend */
block|}
block|}
else|else
comment|/* not in exception cond */
block|{
name|l2sc
operator|->
name|rej_excpt
operator|=
literal|1
expr_stmt|;
comment|/* set exception */
name|i4b_tx_rej_response
argument_list|(
name|l2sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* tx REJ */
name|l2sc
operator|->
name|ack_pend
operator|=
literal|0
expr_stmt|;
comment|/* clr ack pending */
block|}
block|}
block|}
comment|/* sequence number ranges as expected ? */
if|if
condition|(
name|i4b_l2_nr_ok
argument_list|(
name|nr
argument_list|,
name|l2sc
operator|->
name|va
argument_list|,
name|l2sc
operator|->
name|vs
argument_list|)
condition|)
block|{
if|if
condition|(
name|l2sc
operator|->
name|Q921_state
operator|==
name|ST_TIMREC
condition|)
block|{
name|l2sc
operator|->
name|va
operator|=
name|nr
expr_stmt|;
name|CRIT_END
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|l2sc
operator|->
name|peer_busy
condition|)
comment|/* yes, other side busy ? */
block|{
name|l2sc
operator|->
name|va
operator|=
name|nr
expr_stmt|;
comment|/* yes, update ack count */
block|}
else|else
comment|/* other side ready */
block|{
if|if
condition|(
name|nr
operator|==
name|l2sc
operator|->
name|vs
condition|)
comment|/* count expected ? */
block|{
name|l2sc
operator|->
name|va
operator|=
name|nr
expr_stmt|;
comment|/* update ack */
name|i4b_T200_stop
argument_list|(
name|l2sc
argument_list|)
expr_stmt|;
name|i4b_T203_restart
argument_list|(
name|l2sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nr
operator|!=
name|l2sc
operator|->
name|va
condition|)
block|{
name|l2sc
operator|->
name|va
operator|=
name|nr
expr_stmt|;
name|i4b_T200_restart
argument_list|(
name|l2sc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|i4b_nr_error_recovery
argument_list|(
name|l2sc
argument_list|)
expr_stmt|;
comment|/* sequence error */
name|l2sc
operator|->
name|Q921_state
operator|=
name|ST_AW_EST
expr_stmt|;
block|}
name|CRIT_END
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	internal I FRAME QUEUED UP routine (Q.921 03/93 p 61)  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|i4b_i_frame_queued_up
parameter_list|(
name|l2_softc_t
modifier|*
name|l2sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|CRIT_VAR
expr_stmt|;
name|CRIT_BEG
expr_stmt|;
if|if
condition|(
operator|(
name|l2sc
operator|->
name|peer_busy
operator|)
operator|||
operator|(
name|l2sc
operator|->
name|vs
operator|==
operator|(
operator|(
name|l2sc
operator|->
name|va
operator|+
name|MAX_K_VALUE
operator|)
operator|&
literal|127
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|l2sc
operator|->
name|peer_busy
condition|)
block|{
name|NDBGL2
argument_list|(
name|L2_I_MSG
argument_list|,
literal|"regen IFQUP, cause: peer busy!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l2sc
operator|->
name|vs
operator|==
operator|(
operator|(
name|l2sc
operator|->
name|va
operator|+
name|MAX_K_VALUE
operator|)
operator|&
literal|127
operator|)
condition|)
block|{
name|NDBGL2
argument_list|(
name|L2_I_MSG
argument_list|,
literal|"regen IFQUP, cause: vs=va+k!"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * XXX see: Q.921, page 36, 5.6.1 ".. may retransmit an I 		 * frame ...", shall we retransmit the last i frame ? 		 */
if|if
condition|(
operator|!
operator|(
name|IF_QEMPTY
argument_list|(
operator|&
name|l2sc
operator|->
name|i_queue
argument_list|)
operator|)
condition|)
block|{
name|NDBGL2
argument_list|(
name|L2_I_MSG
argument_list|,
literal|"re-scheduling IFQU call!"
argument_list|)
expr_stmt|;
name|START_TIMER
argument_list|(
name|l2sc
operator|->
name|IFQU_callout
argument_list|,
name|i4b_i_frame_queued_up
argument_list|,
name|l2sc
argument_list|,
name|IFQU_DLY
argument_list|)
expr_stmt|;
block|}
name|CRIT_END
expr_stmt|;
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|l2sc
operator|->
name|i_queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* fetch next frame to tx */
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|NDBGL2
argument_list|(
name|L2_I_ERR
argument_list|,
literal|"ERROR, mbuf NULL after IF_DEQUEUE"
argument_list|)
expr_stmt|;
name|CRIT_END
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
name|m
operator|->
name|m_data
expr_stmt|;
name|PUTSAPI
argument_list|(
name|SAPI_CCP
argument_list|,
name|CR_CMD_TO_NT
argument_list|,
operator|*
operator|(
name|ptr
operator|+
name|OFF_SAPI
operator|)
argument_list|)
expr_stmt|;
name|PUTTEI
argument_list|(
name|l2sc
operator|->
name|tei
argument_list|,
operator|*
operator|(
name|ptr
operator|+
name|OFF_TEI
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ptr
operator|+
name|OFF_INS
operator|)
operator|=
operator|(
name|l2sc
operator|->
name|vs
operator|<<
literal|1
operator|)
operator|&
literal|0xfe
expr_stmt|;
comment|/* bit 0 = 0 */
operator|*
operator|(
name|ptr
operator|+
name|OFF_INR
operator|)
operator|=
operator|(
name|l2sc
operator|->
name|vr
operator|<<
literal|1
operator|)
operator|&
literal|0xfe
expr_stmt|;
comment|/* P bit = 0 */
name|l2sc
operator|->
name|stat
operator|.
name|tx_i
operator|++
expr_stmt|;
comment|/* update frame counter */
name|PH_Data_Req
argument_list|(
name|l2sc
operator|->
name|unit
argument_list|,
name|m
argument_list|,
name|MBUF_DONTFREE
argument_list|)
expr_stmt|;
comment|/* free'd when ack'd ! */
name|l2sc
operator|->
name|iframe_sent
operator|=
literal|1
expr_stmt|;
comment|/* in case we ack an I frame with another I frame */
if|if
condition|(
name|l2sc
operator|->
name|ua_num
operator|!=
name|UA_EMPTY
condition|)
comment|/* failsafe */
block|{
name|NDBGL2
argument_list|(
name|L2_I_ERR
argument_list|,
literal|"ERROR, l2sc->ua_num: %d != UA_EMPTY"
argument_list|,
name|l2sc
operator|->
name|ua_num
argument_list|)
expr_stmt|;
name|i4b_print_l2var
argument_list|(
name|l2sc
argument_list|)
expr_stmt|;
name|i4b_Dfreembuf
argument_list|(
name|l2sc
operator|->
name|ua_frame
argument_list|)
expr_stmt|;
block|}
name|l2sc
operator|->
name|ua_frame
operator|=
name|m
expr_stmt|;
comment|/* save unacked frame */
name|l2sc
operator|->
name|ua_num
operator|=
name|l2sc
operator|->
name|vs
expr_stmt|;
comment|/* save frame number */
name|M128INC
argument_list|(
name|l2sc
operator|->
name|vs
argument_list|)
expr_stmt|;
name|l2sc
operator|->
name|ack_pend
operator|=
literal|0
expr_stmt|;
name|CRIT_END
expr_stmt|;
if|if
condition|(
name|l2sc
operator|->
name|T200
operator|==
name|TIMER_IDLE
condition|)
block|{
name|i4b_T203_stop
argument_list|(
name|l2sc
argument_list|)
expr_stmt|;
name|i4b_T200_start
argument_list|(
name|l2sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

