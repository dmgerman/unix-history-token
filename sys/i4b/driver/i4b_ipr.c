begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, 2002 Hellmuth Michaelis. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------  *  *	i4b_ipr.c - isdn4bsd IP over raw HDLC ISDN network driver  *	---------------------------------------------------------  *	last edit-date: [Sun Mar 17 09:32:58 2002]  *  *---------------------------------------------------------------------------*  *  *	statistics counter usage (interface lifetime):  *	----------------------------------------------  *	sc->sc_ifp->if_ipackets	# of received packets  *	sc->sc_ifp->if_ierrors	# of error packets not going to upper layers  *	sc->sc_ifp->if_opackets	# of transmitted packets  *	sc->sc_ifp->if_oerrors	# of error packets not being transmitted  *	sc->sc_ifp->if_collisions	# of invalid ip packets after VJ decompression  *	sc->sc_ifp->if_ibytes	# of bytes coming in from the line (before VJ)  *	sc->sc_ifp->if_obytes	# of bytes going out to the line (after VJ)  *	sc->sc_ifp->if_imcasts	  (currently unused)  *	sc->sc_ifp->if_omcasts	# of frames sent out of the fastqueue  *	sc->sc_ifp->if_iqdrops	# of frames dropped on input because queue full  *	sc->sc_ifp->if_noproto	# of frames dropped on output because !AF_INET  *  *	statistics counter usage (connection lifetime):  *	-----------------------------------------------  *	sc->sc_iinb		# of ISDN incoming bytes from HSCX  *	sc->sc_ioutb		# of ISDN outgoing bytes from HSCX  *	sc->sc_inb		# of incoming bytes after decompression  *	sc->sc_outb		# of outgoing bytes before compression  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_i4b.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPR_VJ
end_ifdef

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<net/slcompress.h>
end_include

begin_define
define|#
directive|define
name|IPR_COMPRESS
value|IFF_LINK0
end_define

begin_comment
comment|/* compress TCP traffic */
end_comment

begin_define
define|#
directive|define
name|IPR_AUTOCOMP
value|IFF_LINK1
end_define

begin_comment
comment|/* auto-enable TCP compression */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------  * NOTICE: using NO separate buffer relies on the assumption, that the HSCX  * IRQ handler _always_ allocates a single, continuous mbuf cluster large  * enough to hold the maximum MTU size if the ipr interface !  *  * CAUTION: i have re-defined IPR_VJ_USEBUFFER because it makes problems  *          with 2 i4b's back to back running cvs over ssh, cvs simply  *          aborts because it gets bad data. Everything else (telnet/ftp?etc)  *          functions fine.   *---------------------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|IPR_VJ_USEBUFFER
end_define

begin_comment
comment|/* define to use an allocated separate buffer*/
end_comment

begin_comment
comment|/* undef to uncompress in the mbuf itself    */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPR_VJ */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_global.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_l3l4.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer4/i4b_l4.h>
end_include

begin_error
error|#
directive|error
literal|"Cannot be used until I4B is locked."
end_error

begin_define
define|#
directive|define
name|I4BIPRMTU
value|1500
end_define

begin_comment
comment|/* regular MTU */
end_comment

begin_define
define|#
directive|define
name|I4BIPRMAXMTU
value|2000
end_define

begin_comment
comment|/* max MTU */
end_comment

begin_define
define|#
directive|define
name|I4BIPRMINMTU
value|500
end_define

begin_comment
comment|/* min MTU */
end_comment

begin_define
define|#
directive|define
name|I4BIPRMAXQLEN
value|50
end_define

begin_comment
comment|/* max queue length */
end_comment

begin_define
define|#
directive|define
name|I4BIPRACCT
value|1
end_define

begin_comment
comment|/* enable accounting messages */
end_comment

begin_define
define|#
directive|define
name|I4BIPRACCTINTVL
value|2
end_define

begin_comment
comment|/* accounting msg interval in secs */
end_comment

begin_define
define|#
directive|define
name|I4BIPRADJFRXP
value|1
end_define

begin_comment
comment|/* adjust 1st rxd packet */
end_comment

begin_comment
comment|/* initialized by L4 */
end_comment

begin_decl_stmt
specifier|static
name|drvr_link_t
name|ipr_drvr_linktab
index|[
name|NI4BIPR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isdn_link_t
modifier|*
name|isdn_linktab
index|[
name|NI4BIPR
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ipr_softc
block|{
name|struct
name|ifnet
modifier|*
name|sc_ifp
decl_stmt|;
comment|/* network-visible interface	*/
name|int
name|sc_state
decl_stmt|;
comment|/* state of the interface	*/
name|call_desc_t
modifier|*
name|sc_cdp
decl_stmt|;
comment|/* ptr to call descriptor	*/
name|int
name|sc_updown
decl_stmt|;
comment|/* soft state of interface	*/
name|struct
name|ifqueue
name|sc_fastq
decl_stmt|;
comment|/* interactive traffic		*/
name|int
name|sc_dialresp
decl_stmt|;
comment|/* dialresponse			*/
name|int
name|sc_lastdialresp
decl_stmt|;
comment|/* last dialresponse		*/
name|struct
name|callout_handle
name|sc_callout
decl_stmt|;
if|#
directive|if
name|I4BIPRACCT
name|int
name|sc_iinb
decl_stmt|;
comment|/* isdn driver # of inbytes	*/
name|int
name|sc_ioutb
decl_stmt|;
comment|/* isdn driver # of outbytes	*/
name|int
name|sc_inb
decl_stmt|;
comment|/* # of bytes rx'd		*/
name|int
name|sc_outb
decl_stmt|;
comment|/* # of bytes tx'd	 	*/
name|int
name|sc_linb
decl_stmt|;
comment|/* last # of bytes rx'd		*/
name|int
name|sc_loutb
decl_stmt|;
comment|/* last # of bytes tx'd 	*/
name|int
name|sc_fn
decl_stmt|;
comment|/* flag, first null acct	*/
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I4BIPRADJFRXP
name|int
name|sc_first_pkt
decl_stmt|;
comment|/* flag, first rxd packet	*/
endif|#
directive|endif
if|#
directive|if
name|IPR_LOG
name|int
name|sc_log_first
decl_stmt|;
comment|/* log first n packets          */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPR_VJ
name|struct
name|slcompress
name|sc_compr
decl_stmt|;
comment|/* tcp compression data		*/
ifdef|#
directive|ifdef
name|IPR_VJ_USEBUFFER
name|u_char
modifier|*
name|sc_cbuf
decl_stmt|;
comment|/* tcp decompression buffer	*/
endif|#
directive|endif
endif|#
directive|endif
block|}
name|ipr_softc
index|[
name|NI4BIPR
index|]
struct|;
end_struct

begin_enum
enum|enum
name|ipr_states
block|{
name|ST_IDLE
block|,
comment|/* initialized, ready, idle	*/
name|ST_DIALING
block|,
comment|/* dialling out to remote	*/
name|ST_CONNECTED_W
block|,
comment|/* connected to remote		*/
name|ST_CONNECTED_A
block|,
comment|/* connected to remote		*/
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|void
name|i4biprattach
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|PSEUDO_SET
argument_list|(
name|i4biprattach
argument_list|,
name|i4b_ipr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|i4biprioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iprwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipr_init_linktab
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipr_tx_queue_empty
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i4biproutput
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rtp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iprclearqueues
parameter_list|(
name|struct
name|ipr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*===========================================================================*  *			DEVICE DRIVER ROUTINES  *===========================================================================*/
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	interface attach routine at kernel boot time  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|i4biprattach
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|ipr_softc
modifier|*
name|sc
init|=
name|ipr_softc
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|IPR_VJ
name|printf
argument_list|(
literal|"i4bipr: %d IP over raw HDLC ISDN device(s) attached (VJ header compression)\n"
argument_list|,
name|NI4BIPR
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"i4bipr: %d IP over raw HDLC ISDN device(s) attached\n"
argument_list|,
name|NI4BIPR
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI4BIPR
condition|;
name|sc
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|ipr_init_linktab
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_DIALST
argument_list|,
literal|"setting dial state to ST_IDLE"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ISDNBASIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"i4b_ipr.c, i4biprattach: cannot if_alloc()"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ST_IDLE
expr_stmt|;
name|if_initname
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"ipr"
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPR_VJ
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|=
name|IFF_POINTOPOINT
operator||
name|IFF_SIMPLEX
operator||
name|IPR_AUTOCOMP
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|=
name|IFF_POINTOPOINT
operator||
name|IFF_SIMPLEX
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_ifp
operator|->
name|if_mtu
operator|=
name|I4BIPRMTU
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ioctl
operator|=
name|i4biprioctl
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_output
operator|=
name|i4biproutput
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|I4BIPRMAXQLEN
expr_stmt|;
name|sc
operator|->
name|sc_fastq
operator|.
name|ifq_maxlen
operator|=
name|I4BIPRMAXQLEN
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|sc_fastq
operator|.
name|ifq_mtx
argument_list|)
condition|)
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_fastq
operator|.
name|ifq_mtx
argument_list|,
literal|"i4b_ipr_fastq"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ipackets
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ierrors
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_opackets
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_oerrors
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_collisions
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ibytes
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_obytes
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_imcasts
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_omcasts
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_iqdrops
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_noproto
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|I4BIPRACCT
name|sc
operator|->
name|sc_ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_watchdog
operator|=
name|iprwatchdog
expr_stmt|;
name|sc
operator|->
name|sc_iinb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ioutb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_inb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_outb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_linb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_loutb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_fn
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|IPR_LOG
name|sc
operator|->
name|sc_log_first
operator|=
name|IPR_LOG
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPR_VJ
name|sl_compress_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_compr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPR_VJ_USEBUFFER
if|if
condition|(
operator|!
operator|(
operator|(
name|sc
operator|->
name|sc_cbuf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|I4BIPRMAXMTU
operator|+
literal|128
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"i4b_ipr.c, i4biprattach: VJ malloc failed"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|sc
operator|->
name|sc_updown
operator|=
name|SOFT_ENA
expr_stmt|;
comment|/* soft enabled */
name|sc
operator|->
name|sc_dialresp
operator|=
name|DSTAT_NONE
expr_stmt|;
comment|/* no response */
name|sc
operator|->
name|sc_lastdialresp
operator|=
name|DSTAT_NONE
expr_stmt|;
name|if_attach
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
expr_stmt|;
name|bpfattach
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
name|DLT_NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	output a packet to the ISDN B-channel  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|i4biproutput
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rtp
parameter_list|)
block|{
name|struct
name|ipr_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|ifq
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|u_int32_t
name|af
decl_stmt|;
name|s
operator|=
name|SPLI4B
argument_list|()
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|unit
operator|=
name|ifp
operator|->
name|if_dunit
expr_stmt|;
comment|/* BPF writes need to be handled specially. */
if|if
condition|(
name|dst
operator|->
name|sa_family
operator|==
name|AF_UNSPEC
condition|)
block|{
name|bcopy
argument_list|(
name|dst
operator|->
name|sa_data
argument_list|,
operator|&
name|af
argument_list|,
sizeof|sizeof
argument_list|(
name|af
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sa_family
operator|=
name|af
expr_stmt|;
block|}
comment|/* check for IP */
if|if
condition|(
name|dst
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"af%d not supported\n"
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_noproto
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
comment|/* check interface state = UP */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|NDBGL4
argument_list|(
name|L4_IPRDBG
argument_list|,
literal|"ipr%d: interface is DOWN!"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* dial if necessary */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ST_IDLE
operator|||
name|sc
operator|->
name|sc_state
operator|==
name|ST_DIALING
condition|)
block|{
ifdef|#
directive|ifdef
name|NOTDEF
switch|switch
condition|(
name|sc
operator|->
name|sc_dialresp
condition|)
block|{
case|case
name|DSTAT_TFAIL
case|:
comment|/* transient failure */
name|NDBGL4
argument_list|(
name|L4_IPRDBG
argument_list|,
literal|"ipr%d: transient dial failure!"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|iprclearqueues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dialresp
operator|=
name|DSTAT_NONE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
name|ENETUNREACH
operator|)
return|;
break|break;
case|case
name|DSTAT_PFAIL
case|:
comment|/* permanent failure */
name|NDBGL4
argument_list|(
name|L4_IPRDBG
argument_list|,
literal|"ipr%d: permanent dial failure!"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|iprclearqueues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dialresp
operator|=
name|DSTAT_NONE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
break|break;
case|case
name|DSTAT_INONLY
case|:
comment|/* no dialout allowed*/
name|NDBGL4
argument_list|(
name|L4_IPRDBG
argument_list|,
literal|"ipr%d: dialout not allowed failure!"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|iprclearqueues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dialresp
operator|=
name|DSTAT_NONE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
break|break;
block|}
endif|#
directive|endif
name|NDBGL4
argument_list|(
name|L4_IPRDBG
argument_list|,
literal|"ipr%d: send dial request message!"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_DIALST
argument_list|,
literal|"ipr%d: setting dial state to ST_DIALING"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|i4b_l4_dialout
argument_list|(
name|BDRV_IPR
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ST_DIALING
expr_stmt|;
block|}
if|#
directive|if
name|IPR_LOG
if|if
condition|(
name|sc
operator|->
name|sc_log_first
operator|>
literal|0
condition|)
block|{
operator|--
operator|(
name|sc
operator|->
name|sc_log_first
operator|)
expr_stmt|;
name|i4b_l4_packet_ind
argument_list|(
name|BDRV_IPR
argument_list|,
name|unit
argument_list|,
literal|1
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* update access time */
name|microtime
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifp
operator|->
name|if_lastchange
argument_list|)
expr_stmt|;
comment|/* 	 * check, if type of service indicates interactive, i.e. telnet, 	 * traffic. in case it is interactive, put it into the fast queue, 	 * else (i.e. ftp traffic) put it into the "normal" queue 	 */
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* get ptr to ip header */
if|if
condition|(
name|ip
operator|->
name|ip_tos
operator|&
name|IPTOS_LOWDELAY
condition|)
name|ifq
operator|=
operator|&
name|sc
operator|->
name|sc_fastq
expr_stmt|;
else|else
name|ifq
operator|=
operator|(
expr|struct
name|ifqueue
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_ifp
operator|->
name|if_snd
expr_stmt|;
comment|/* check for space in choosen send queue */
if|if
condition|(
operator|!
name|IF_HANDOFF
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|NDBGL4
argument_list|(
name|L4_IPRDBG
argument_list|,
literal|"ipr%d: send queue full!"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|NDBGL4
argument_list|(
name|L4_IPRDBG
argument_list|,
literal|"ipr%d: add packet to send queue!"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ipr_tx_queue_empty
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	process ioctl  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|i4biprioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ipr_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|SPLI4B
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCAIFADDR
case|:
comment|/* add interface address */
case|case
name|SIOCSIFADDR
case|:
comment|/* set interface address */
case|case
name|SIOCSIFDSTADDR
case|:
comment|/* set interface destination address */
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
else|else
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifp
operator|->
name|if_lastchange
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* set interface flags */
if|if
condition|(
operator|!
operator|(
name|ifr
operator|->
name|ifr_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* disconnect ISDN line */
name|i4b_l4_drvrdisc
argument_list|(
name|BDRV_IPR
argument_list|,
name|ifp
operator|->
name|if_dunit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
block|}
name|sc
operator|->
name|sc_state
operator|=
name|ST_IDLE
expr_stmt|;
comment|/* empty queues */
name|iprclearqueues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifr
operator|->
name|ifr_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
comment|/* enable debug messages */
block|}
name|microtime
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifp
operator|->
name|if_lastchange
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* set interface MTU */
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|I4BIPRMAXMTU
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|<
name|I4BIPRMINMTU
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifp
operator|->
name|if_lastchange
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
comment|/* not needed for FreeBSD, done in sl_compress_init() (-hm) */
comment|/* need to add an ioctl:	set VJ max slot ID 			 * #define IPRIOCSMAXCID	_IOW('I', XXX, int) 			 */
ifdef|#
directive|ifdef
name|IPR_VJ
block|case IPRIOCSMAXCID: 			{ 			struct thread *td = curthread;
comment|/* XXX */
block|if((error = priv_check(td, PRIV_DRIVER))) 				return (error); 		        sl_compress_setup(sc->sc_compr, *(int *)data); 			} 			break;
endif|#
directive|endif
endif|#
directive|endif
comment|/* #if 0 */
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	clear the interface's send queues  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|iprclearqueues
parameter_list|(
name|struct
name|ipr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|x
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DRAIN
argument_list|(
operator|&
name|sc
operator|->
name|sc_fastq
argument_list|)
expr_stmt|;
name|IF_DRAIN
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|I4BIPRACCT
end_if

begin_comment
comment|/*---------------------------------------------------------------------------*  *	watchdog routine  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|iprwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|unit
init|=
name|ifp
operator|->
name|if_dunit
decl_stmt|;
name|struct
name|ipr_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|bchan_statistics_t
name|bs
decl_stmt|;
comment|/* get # of bytes in and out from the HSCX driver */
operator|(
operator|*
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|bch_stat
operator|)
operator|(
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|unit
operator|,
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|channel
operator|,
operator|&
name|bs
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_ioutb
operator|+=
name|bs
operator|.
name|outbytes
expr_stmt|;
name|sc
operator|->
name|sc_iinb
operator|+=
name|bs
operator|.
name|inbytes
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_iinb
operator|!=
name|sc
operator|->
name|sc_linb
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_ioutb
operator|!=
name|sc
operator|->
name|sc_loutb
operator|)
operator|||
name|sc
operator|->
name|sc_fn
condition|)
block|{
name|int
name|ri
init|=
operator|(
name|sc
operator|->
name|sc_iinb
operator|-
name|sc
operator|->
name|sc_linb
operator|)
operator|/
name|I4BIPRACCTINTVL
decl_stmt|;
name|int
name|ro
init|=
operator|(
name|sc
operator|->
name|sc_ioutb
operator|-
name|sc
operator|->
name|sc_loutb
operator|)
operator|/
name|I4BIPRACCTINTVL
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_iinb
operator|==
name|sc
operator|->
name|sc_linb
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_ioutb
operator|==
name|sc
operator|->
name|sc_loutb
operator|)
condition|)
name|sc
operator|->
name|sc_fn
operator|=
literal|0
expr_stmt|;
else|else
name|sc
operator|->
name|sc_fn
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_linb
operator|=
name|sc
operator|->
name|sc_iinb
expr_stmt|;
name|sc
operator|->
name|sc_loutb
operator|=
name|sc
operator|->
name|sc_ioutb
expr_stmt|;
name|i4b_l4_accounting
argument_list|(
name|BDRV_IPR
argument_list|,
name|unit
argument_list|,
name|ACCT_DURING
argument_list|,
name|sc
operator|->
name|sc_ioutb
argument_list|,
name|sc
operator|->
name|sc_iinb
argument_list|,
name|ro
argument_list|,
name|ri
argument_list|,
name|sc
operator|->
name|sc_outb
argument_list|,
name|sc
operator|->
name|sc_inb
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_ifp
operator|->
name|if_timer
operator|=
name|I4BIPRACCTINTVL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I4BIPRACCT */
end_comment

begin_comment
comment|/*===========================================================================*  *			ISDN INTERFACE ROUTINES  *===========================================================================*/
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	start transmitting after connect  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|i4bipr_connect_startio
parameter_list|(
name|struct
name|ipr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|s
init|=
name|SPLI4B
argument_list|()
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ST_CONNECTED_W
condition|)
block|{
name|sc
operator|->
name|sc_state
operator|=
name|ST_CONNECTED_A
expr_stmt|;
name|ipr_tx_queue_empty
argument_list|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_dunit
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	this routine is called from L4 handler at connect time  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ipr_connect
parameter_list|(
name|int
name|unit
parameter_list|,
name|void
modifier|*
name|cdp
parameter_list|)
block|{
name|struct
name|ipr_softc
modifier|*
name|sc
init|=
operator|&
name|ipr_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sc
operator|->
name|sc_cdp
operator|=
operator|(
name|call_desc_t
operator|*
operator|)
name|cdp
expr_stmt|;
name|s
operator|=
name|SPLI4B
argument_list|()
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_DIALST
argument_list|,
literal|"ipr%d: setting dial state to ST_CONNECTED"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ST_CONNECTED_W
expr_stmt|;
name|sc
operator|->
name|sc_dialresp
operator|=
name|DSTAT_NONE
expr_stmt|;
name|sc
operator|->
name|sc_lastdialresp
operator|=
name|DSTAT_NONE
expr_stmt|;
if|#
directive|if
name|I4BIPRACCT
name|sc
operator|->
name|sc_iinb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ioutb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_inb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_outb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_linb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_loutb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_timer
operator|=
name|I4BIPRACCTINTVL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I4BIPRADJFRXP
name|sc
operator|->
name|sc_first_pkt
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Sometimes ISDN B-channels are switched thru asymmetic. This 	 * means that under such circumstances B-channel data (the first 	 * three packets of a TCP connection in my case) may get lost, 	 * causing a large delay until the connection is started. 	 * When the sending of the very first packet of a TCP connection 	 * is delayed for a to be empirically determined delay (close 	 * to a second in my case) those packets go thru and the TCP 	 * connection comes up "almost" immediately (-hm). 	 */
if|if
condition|(
name|sc
operator|->
name|sc_cdp
operator|->
name|isdntxdelay
operator|>
literal|0
condition|)
block|{
name|int
name|delay
decl_stmt|;
if|if
condition|(
name|hz
operator|==
literal|100
condition|)
block|{
name|delay
operator|=
name|sc
operator|->
name|sc_cdp
operator|->
name|isdntxdelay
expr_stmt|;
comment|/* avoid any rounding */
block|}
else|else
block|{
name|delay
operator|=
name|sc
operator|->
name|sc_cdp
operator|->
name|isdntxdelay
operator|*
name|hz
expr_stmt|;
name|delay
operator|/=
literal|100
expr_stmt|;
block|}
name|START_TIMER
argument_list|(
name|sc
operator|->
name|sc_callout
argument_list|,
operator|(
name|TIMEOUT_FUNC_T
operator|)
name|i4bipr_connect_startio
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
name|delay
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_state
operator|=
name|ST_CONNECTED_A
expr_stmt|;
name|ipr_tx_queue_empty
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* we don't need any negotiation - pass event back right now */
name|i4b_l4_negcomplete
argument_list|(
name|sc
operator|->
name|sc_cdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	this routine is called from L4 handler at disconnect time  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ipr_disconnect
parameter_list|(
name|int
name|unit
parameter_list|,
name|void
modifier|*
name|cdp
parameter_list|)
block|{
name|call_desc_t
modifier|*
name|cd
init|=
operator|(
name|call_desc_t
operator|*
operator|)
name|cdp
decl_stmt|;
name|struct
name|ipr_softc
modifier|*
name|sc
init|=
operator|&
name|ipr_softc
index|[
name|unit
index|]
decl_stmt|;
comment|/* new stuff to check that the active channel is being closed */
if|if
condition|(
name|cd
operator|!=
name|sc
operator|->
name|sc_cdp
condition|)
block|{
name|NDBGL4
argument_list|(
name|L4_IPRDBG
argument_list|,
literal|"ipr%d: channel %d not active"
argument_list|,
name|cd
operator|->
name|driver_unit
argument_list|,
name|cd
operator|->
name|channelid
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|I4BIPRACCT
name|sc
operator|->
name|sc_ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|IPR_LOG
comment|/* show next IPR_LOG packets again */
name|sc
operator|->
name|sc_log_first
operator|=
name|IPR_LOG
expr_stmt|;
endif|#
directive|endif
name|i4b_l4_accounting
argument_list|(
name|BDRV_IPR
argument_list|,
name|cd
operator|->
name|driver_unit
argument_list|,
name|ACCT_FINAL
argument_list|,
name|sc
operator|->
name|sc_ioutb
argument_list|,
name|sc
operator|->
name|sc_iinb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_outb
argument_list|,
name|sc
operator|->
name|sc_inb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cdp
operator|=
operator|(
name|call_desc_t
operator|*
operator|)
literal|0
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_DIALST
argument_list|,
literal|"setting dial state to ST_IDLE"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dialresp
operator|=
name|DSTAT_NONE
expr_stmt|;
name|sc
operator|->
name|sc_lastdialresp
operator|=
name|DSTAT_NONE
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ST_IDLE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	this routine is used to give a feedback from userland daemon  *	in case of dial problems  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ipr_dialresponse
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|status
parameter_list|,
name|cause_t
name|cause
parameter_list|)
block|{
name|struct
name|ipr_softc
modifier|*
name|sc
init|=
operator|&
name|ipr_softc
index|[
name|unit
index|]
decl_stmt|;
name|sc
operator|->
name|sc_dialresp
operator|=
name|status
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_IPRDBG
argument_list|,
literal|"ipr%d: last=%d, this=%d"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_lastdialresp
argument_list|,
name|sc
operator|->
name|sc_dialresp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DSTAT_NONE
condition|)
block|{
name|NDBGL4
argument_list|(
name|L4_IPRDBG
argument_list|,
literal|"ipr%d: clearing queues"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|iprclearqueues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	interface soft up/down  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ipr_updown
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|updown
parameter_list|)
block|{
name|struct
name|ipr_softc
modifier|*
name|sc
init|=
operator|&
name|ipr_softc
index|[
name|unit
index|]
decl_stmt|;
name|sc
operator|->
name|sc_updown
operator|=
name|updown
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	this routine is called from the HSCX interrupt handler  *	when a new frame (mbuf) has been received and was put on  *	the rx queue. It is assumed that this routines runs at  *	pri level splimp() ! Keep it short !  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ipr_rx_data_rdy
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|ipr_softc
modifier|*
name|sc
init|=
operator|&
name|ipr_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|IPR_VJ
ifdef|#
directive|ifdef
name|IPR_VJ_USEBUFFER
name|u_char
modifier|*
name|cp
init|=
name|sc
operator|->
name|sc_cbuf
decl_stmt|;
endif|#
directive|endif
name|int
name|len
decl_stmt|,
name|c
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|m
operator|=
operator|*
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|rx_mbuf
operator|)
operator|==
name|NULL
condition|)
return|return;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifp
operator|->
name|if_lastchange
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|I4BIPRADJFRXP
comment|/* 	 * The very first packet after the B channel is switched thru 	 * has very often several bytes of random data prepended. This 	 * routine looks where the IP header starts and removes the 	 * the bad data. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_first_pkt
condition|)
block|{
name|unsigned
name|char
modifier|*
name|mp
init|=
name|m
operator|->
name|m_data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|sc_first_pkt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
operator|->
name|m_len
condition|;
name|i
operator|++
operator|,
name|mp
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|mp
operator|&
literal|0xf0
operator|)
operator|==
literal|0x40
operator|)
operator|&&
operator|(
operator|(
operator|*
name|mp
operator|&
literal|0x0f
operator|)
operator|>=
literal|0x05
operator|)
condition|)
block|{
name|m
operator|->
name|m_data
operator|=
name|mp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|IPR_VJ
if|if
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|)
operator|&
literal|0xf0
operator|)
operator|)
operator|!=
operator|(
name|IPVERSION
operator|<<
literal|4
operator|)
condition|)
block|{
comment|/* copy data to buffer */
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
ifdef|#
directive|ifdef
name|IPR_VJ_USEBUFFER
comment|/* XXX */
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
block|{
name|c
operator|=
name|TYPE_COMPRESSED_TCP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|TYPE_UNCOMPRESSED_TCP
condition|)
block|{
ifdef|#
directive|ifdef
name|IPR_VJ_USEBUFFER
operator|*
name|cp
operator|&=
literal|0x4f
expr_stmt|;
comment|/* XXX */
else|#
directive|else
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|)
operator|&=
literal|0x4f
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 		 * We've got something that's not an IP packet. 		 * If compression is enabled, try to decompress it. 		 * Otherwise, if `auto-enable' compression is on and 		 * it's a reasonable packet, decompress it and then 		 * enable compression.  Otherwise, drop it. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IPR_COMPRESS
condition|)
block|{
ifdef|#
directive|ifdef
name|IPR_VJ_USEBUFFER
name|len
operator|=
name|sl_uncompress_tcp
argument_list|(
operator|&
name|cp
argument_list|,
name|len
argument_list|,
operator|(
name|u_int
operator|)
name|c
argument_list|,
operator|&
name|sc
operator|->
name|sc_compr
argument_list|)
expr_stmt|;
else|#
directive|else
name|len
operator|=
name|sl_uncompress_tcp
argument_list|(
operator|(
name|u_char
operator|*
operator|*
operator|)
operator|&
name|m
operator|->
name|m_data
argument_list|,
name|len
argument_list|,
operator|(
name|u_int
operator|)
name|c
argument_list|,
operator|&
name|sc
operator|->
name|sc_compr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_IPR_VJ
name|printf
argument_list|(
literal|"i4b_ipr, ipr_rx_data_rdy: len<= 0 IPR_COMPRESS!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IPR_AUTOCOMP
operator|)
operator|&&
operator|(
name|c
operator|==
name|TYPE_UNCOMPRESSED_TCP
operator|)
operator|&&
operator|(
name|len
operator|>=
literal|40
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|IPR_VJ_USEBUFFER
name|len
operator|=
name|sl_uncompress_tcp
argument_list|(
operator|&
name|cp
argument_list|,
name|len
argument_list|,
operator|(
name|u_int
operator|)
name|c
argument_list|,
operator|&
name|sc
operator|->
name|sc_compr
argument_list|)
expr_stmt|;
else|#
directive|else
name|len
operator|=
name|sl_uncompress_tcp
argument_list|(
operator|(
name|u_char
operator|*
operator|*
operator|)
operator|&
name|m
operator|->
name|m_data
argument_list|,
name|len
argument_list|,
operator|(
name|u_int
operator|)
name|c
argument_list|,
operator|&
name|sc
operator|->
name|sc_compr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_IPR_VJ
name|printf
argument_list|(
literal|"i4b_ipr, ipr_rx_data_rdy: len<= 0 IPR_AUTOCOMP!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|error
goto|;
block|}
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator||=
name|IPR_COMPRESS
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG_IPR_VJ
name|printf
argument_list|(
literal|"i4b_ipr, ipr_input: invalid ip packet!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
label|:
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_collisions
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|IPR_VJ_USEBUFFER
comment|/* XXX */
name|m_copyback
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|#
directive|else
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
if|#
directive|if
name|I4BIPRACCT
comment|/* NB. do the accounting after decompression!		*/
name|sc
operator|->
name|sc_inb
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|IPR_LOG
if|if
condition|(
name|sc
operator|->
name|sc_log_first
operator|>
literal|0
condition|)
block|{
operator|--
operator|(
name|sc
operator|->
name|sc_log_first
operator|)
expr_stmt|;
name|i4b_l4_packet_ind
argument_list|(
name|BDRV_IPR
argument_list|,
name|unit
argument_list|,
literal|0
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_bpf
argument_list|)
condition|)
block|{
comment|/* prepend the address family as a four byte field */
name|struct
name|mbuf
name|mm
decl_stmt|;
name|u_int
name|af
init|=
name|AF_INET
decl_stmt|;
name|mm
operator|.
name|m_next
operator|=
name|m
expr_stmt|;
name|mm
operator|.
name|m_len
operator|=
literal|4
expr_stmt|;
name|mm
operator|.
name|m_data
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|af
expr_stmt|;
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_bpf
argument_list|,
operator|&
name|mm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|netisr_queue
argument_list|(
name|NETISR_IP
argument_list|,
name|m
argument_list|)
condition|)
comment|/* (0) on success. */
block|{
name|NDBGL4
argument_list|(
name|L4_IPRDBG
argument_list|,
literal|"ipr%d: ipintrq full!"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	this routine is called from the HSCX interrupt handler  *	when the last frame has been sent out and there is no  *	further frame (mbuf) in the tx queue.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ipr_tx_queue_empty
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|ipr_softc
modifier|*
name|sc
init|=
operator|&
name|ipr_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|IPR_VJ
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
endif|#
directive|endif
name|int
name|x
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|ST_CONNECTED_A
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_fastq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_omcasts
operator|++
expr_stmt|;
block|}
else|else
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
block|}
name|microtime
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifp
operator|->
name|if_lastchange
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_bpf
argument_list|)
condition|)
block|{
comment|/* prepend the address family as a four byte field */
name|struct
name|mbuf
name|mm
decl_stmt|;
name|u_int
name|af
init|=
name|AF_INET
decl_stmt|;
name|mm
operator|.
name|m_next
operator|=
name|m
expr_stmt|;
name|mm
operator|.
name|m_len
operator|=
literal|4
expr_stmt|;
name|mm
operator|.
name|m_data
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|af
expr_stmt|;
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_bpf
argument_list|,
operator|&
name|mm
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|I4BIPRACCT
name|sc
operator|->
name|sc_outb
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* size before compression */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPR_VJ
if|if
condition|(
operator|(
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|)
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IPR_COMPRESS
condition|)
block|{
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator||=
name|sl_compress_tcp
argument_list|(
name|m
argument_list|,
name|ip
argument_list|,
operator|&
name|sc
operator|->
name|sc_compr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|x
operator|=
literal|1
expr_stmt|;
name|IF_LOCK
argument_list|(
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|tx_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IF_QFULL
argument_list|(
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|tx_queue
argument_list|)
condition|)
block|{
name|NDBGL4
argument_list|(
name|L4_IPRDBG
argument_list|,
literal|"ipr%d: tx queue full!"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_obytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|tx_queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|IF_UNLOCK
argument_list|(
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|tx_queue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
condition|)
operator|(
operator|*
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|bch_tx_start
operator|)
operator|(
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|unit
operator|,
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|channel
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	this routine is called from the HSCX interrupt handler  *	each time a packet is received or transmitted. It should  *	be used to implement an activity timeout mechanism.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ipr_activity
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|rxtx
parameter_list|)
block|{
name|ipr_softc
index|[
name|unit
index|]
operator|.
name|sc_cdp
operator|->
name|last_active_time
operator|=
name|SECOND
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	return this drivers linktab address  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|drvr_link_t
modifier|*
name|ipr_ret_linktab
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
operator|(
operator|&
name|ipr_drvr_linktab
index|[
name|unit
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	setup the isdn_linktab for this driver  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|ipr_set_linktab
parameter_list|(
name|int
name|unit
parameter_list|,
name|isdn_link_t
modifier|*
name|ilt
parameter_list|)
block|{
name|isdn_linktab
index|[
name|unit
index|]
operator|=
name|ilt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	initialize this drivers linktab  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ipr_init_linktab
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|ipr_drvr_linktab
index|[
name|unit
index|]
operator|.
name|unit
operator|=
name|unit
expr_stmt|;
name|ipr_drvr_linktab
index|[
name|unit
index|]
operator|.
name|bch_rx_data_ready
operator|=
name|ipr_rx_data_rdy
expr_stmt|;
name|ipr_drvr_linktab
index|[
name|unit
index|]
operator|.
name|bch_tx_queue_empty
operator|=
name|ipr_tx_queue_empty
expr_stmt|;
name|ipr_drvr_linktab
index|[
name|unit
index|]
operator|.
name|bch_activity
operator|=
name|ipr_activity
expr_stmt|;
name|ipr_drvr_linktab
index|[
name|unit
index|]
operator|.
name|line_connected
operator|=
name|ipr_connect
expr_stmt|;
name|ipr_drvr_linktab
index|[
name|unit
index|]
operator|.
name|line_disconnected
operator|=
name|ipr_disconnect
expr_stmt|;
name|ipr_drvr_linktab
index|[
name|unit
index|]
operator|.
name|dial_response
operator|=
name|ipr_dialresponse
expr_stmt|;
name|ipr_drvr_linktab
index|[
name|unit
index|]
operator|.
name|updown_ind
operator|=
name|ipr_updown
expr_stmt|;
block|}
end_function

begin_comment
comment|/*===========================================================================*/
end_comment

end_unit

