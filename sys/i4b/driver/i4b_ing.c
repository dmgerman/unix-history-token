begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999, 2002 Hellmuth Michaelis. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	i4b_ing.c - isdn4bsd B-channel to netgraph driver  *	-------------------------------------------------  *  * $FreeBSD$  *  *	last edit-date: [Sat Mar  9 14:09:53 2002]  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"i4bing.h"
end_include

begin_if
if|#
directive|if
name|NI4BING
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"opt_i4b.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_debug.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_global.h>
end_include

begin_include
include|#
directive|include
file|<i4b/include/i4b_l3l4.h>
end_include

begin_include
include|#
directive|include
file|<i4b/layer4/i4b_l4.h>
end_include

begin_define
define|#
directive|define
name|I4BINGACCT
value|1
end_define

begin_comment
comment|/* enable accounting messages */
end_comment

begin_define
define|#
directive|define
name|I4BINGACCTINTVL
value|2
end_define

begin_comment
comment|/* accounting msg interval in secs */
end_comment

begin_define
define|#
directive|define
name|I4BINGMAXQLEN
value|50
end_define

begin_comment
comment|/* max queue length */
end_comment

begin_comment
comment|/* initialized by L4 */
end_comment

begin_decl_stmt
specifier|static
name|drvr_link_t
name|ing_drvr_linktab
index|[
name|NI4BING
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isdn_link_t
modifier|*
name|isdn_linktab
index|[
name|NI4BING
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ing_softc
block|{
name|int
name|sc_unit
decl_stmt|;
comment|/* unit number			*/
name|int
name|sc_state
decl_stmt|;
comment|/* state of the interface	*/
name|call_desc_t
modifier|*
name|sc_cdp
decl_stmt|;
comment|/* ptr to call descriptor	*/
name|int
name|sc_updown
decl_stmt|;
comment|/* soft state of interface	*/
name|struct
name|ifqueue
name|sc_fastq
decl_stmt|;
comment|/* interactive traffic		*/
name|int
name|sc_dialresp
decl_stmt|;
comment|/* dialresponse			*/
name|int
name|sc_lastdialresp
decl_stmt|;
comment|/* last dialresponse		*/
if|#
directive|if
name|I4BINGACCT
name|struct
name|callout_handle
name|sc_callout
decl_stmt|;
name|int
name|sc_iinb
decl_stmt|;
comment|/* isdn driver # of inbytes	*/
name|int
name|sc_ioutb
decl_stmt|;
comment|/* isdn driver # of outbytes	*/
name|int
name|sc_inb
decl_stmt|;
comment|/* # of bytes rx'd		*/
name|int
name|sc_outb
decl_stmt|;
comment|/* # of bytes tx'd	 	*/
name|int
name|sc_linb
decl_stmt|;
comment|/* last # of bytes rx'd		*/
name|int
name|sc_loutb
decl_stmt|;
comment|/* last # of bytes tx'd 	*/
name|int
name|sc_fn
decl_stmt|;
comment|/* flag, first null acct	*/
endif|#
directive|endif
name|int
name|sc_inpkt
decl_stmt|;
comment|/* incoming packets		*/
name|int
name|sc_outpkt
decl_stmt|;
comment|/* outgoing packets		*/
name|struct
name|ifqueue
name|xmitq_hipri
decl_stmt|;
comment|/* hi-priority transmit queue */
name|struct
name|ifqueue
name|xmitq
decl_stmt|;
comment|/* transmit queue */
name|node_p
name|node
decl_stmt|;
comment|/* back pointer to node */
name|char
name|nodename
index|[
name|NG_NODELEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* store our node name */
name|hook_p
name|debughook
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|u_int
name|packets_in
decl_stmt|;
comment|/* packets in from downstream */
name|u_int
name|packets_out
decl_stmt|;
comment|/* packets out towards downstream */
name|u_int32_t
name|flags
decl_stmt|;
block|}
name|ing_softc
index|[
name|NI4BING
index|]
struct|;
end_struct

begin_enum
enum|enum
name|ing_states
block|{
name|ST_IDLE
block|,
comment|/* initialized, ready, idle	*/
name|ST_DIALING
block|,
comment|/* dialling out to remote	*/
name|ST_CONNECTED
comment|/* connected to remote		*/
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|void
name|i4bingattach
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|PSEUDO_SET
argument_list|(
name|i4bingattach
argument_list|,
name|i4b_ing
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|ing_init_linktab
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ing_tx_queue_empty
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ========= NETGRAPH ============= */
end_comment

begin_define
define|#
directive|define
name|NG_ING_NODE_TYPE
value|"i4bing"
end_define

begin_comment
comment|/* node type name */
end_comment

begin_define
define|#
directive|define
name|NGM_ING_COOKIE
value|947513046
end_define

begin_comment
comment|/* node type cookie */
end_comment

begin_comment
comment|/* Hook names */
end_comment

begin_define
define|#
directive|define
name|NG_ING_HOOK_DEBUG
value|"debug"
end_define

begin_define
define|#
directive|define
name|NG_ING_HOOK_RAW
value|"rawdata"
end_define

begin_comment
comment|/* Netgraph commands understood by this node type */
end_comment

begin_enum
enum|enum
block|{
name|NGM_ING_SET_FLAG
init|=
literal|1
block|,
name|NGM_ING_GET_STATUS
block|, }
enum|;
end_enum

begin_comment
comment|/* This structure is returned by the NGM_ING_GET_STATUS command */
end_comment

begin_struct
struct|struct
name|ngingstat
block|{
name|u_int
name|packets_in
decl_stmt|;
comment|/* packets in from downstream */
name|u_int
name|packets_out
decl_stmt|;
comment|/* packets out towards downstream */
block|}
struct|;
end_struct

begin_comment
comment|/*  * This is used to define the 'parse type' for a struct ngingstat, which  * is bascially a description of how to convert a binary struct ngingstat  * to an ASCII string and back.  See ng_parse.h for more info.  *  * This needs to be kept in sync with the above structure definition  */
end_comment

begin_define
define|#
directive|define
name|NG_ING_STATS_TYPE_INFO
value|{				\ 	{							\ 	  { "packets_in",&ng_parse_int32_type	},	\ 	  { "packets_out",&ng_parse_int32_type	},	\ 	  { NULL },						\ 	}							\ }
end_define

begin_comment
comment|/*  * This section contains the netgraph method declarations for the  * sample node. These methods define the netgraph 'type'.  */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_ing_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_ing_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_ing_shutdown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_ing_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_connect_t
name|ng_ing_connect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ing_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_ing_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ngingstat */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_info
name|ng_ing_stat_type_info
init|=
name|NG_ING_STATS_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ing_stat_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_ing_stat_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of commands and how to convert arguments to/from ASCII */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_cmdlist
name|ng_ing_cmdlist
index|[]
init|=
block|{
block|{
name|NGM_ING_COOKIE
block|,
name|NGM_ING_GET_STATUS
block|,
literal|"getstatus"
block|,
name|NULL
block|,
operator|&
name|ng_ing_stat_type
block|, 	}
block|,
block|{
name|NGM_ING_COOKIE
block|,
name|NGM_ING_SET_FLAG
block|,
literal|"setflag"
block|,
operator|&
name|ng_parse_int32_type
block|,
name|NULL
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Netgraph node type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
name|NG_ABI_VERSION
block|,
name|NG_ING_NODE_TYPE
block|,
name|NULL
block|,
name|ng_ing_constructor
block|,
name|ng_ing_rcvmsg
block|,
name|ng_ing_shutdown
block|,
name|ng_ing_newhook
block|,
name|NULL
block|,
name|ng_ing_connect
block|,
name|ng_ing_rcvdata
block|,
name|ng_ing_disconnect
block|,
name|ng_ing_cmdlist
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT_ORDERED
argument_list|(
name|ing
argument_list|,
operator|&
name|typestruct
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*===========================================================================*  *			DEVICE DRIVER ROUTINES  *===========================================================================*/
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	interface attach routine at kernel boot time  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|i4bingattach
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|ing_softc
modifier|*
name|sc
init|=
name|ing_softc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|printf
argument_list|(
literal|"i4bing: %d i4b NetGraph ISDN B-channel device(s) attached\n"
argument_list|,
name|NI4BING
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI4BING
condition|;
name|sc
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_unit
operator|=
name|i
expr_stmt|;
name|ing_init_linktab
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_DIALST
argument_list|,
literal|"setting dial state to ST_IDLE"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ST_IDLE
expr_stmt|;
name|sc
operator|->
name|sc_fastq
operator|.
name|ifq_maxlen
operator|=
name|I4BINGMAXQLEN
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|sc_fastq
operator|.
name|ifq_mtx
argument_list|)
condition|)
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_fastq
operator|.
name|ifq_mtx
argument_list|,
literal|"i4b_ing_fastq"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|#
directive|if
name|I4BINGACCT
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_iinb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ioutb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_inb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_outb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_linb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_loutb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_fn
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_inpkt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_outpkt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_updown
operator|=
name|SOFT_ENA
expr_stmt|;
comment|/* soft enabled */
name|sc
operator|->
name|sc_dialresp
operator|=
name|DSTAT_NONE
expr_stmt|;
comment|/* no response */
name|sc
operator|->
name|sc_lastdialresp
operator|=
name|DSTAT_NONE
expr_stmt|;
comment|/* setup a netgraph node */
if|if
condition|(
operator|(
name|ret
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
operator|&
name|sc
operator|->
name|node
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ing: ng_make_node_common, ret = %d\n!"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
comment|/* name the netgraph node */
name|sprintf
argument_list|(
name|sc
operator|->
name|nodename
argument_list|,
literal|"%s%d"
argument_list|,
name|NG_ING_NODE_TYPE
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|ng_name_node
argument_list|(
name|sc
operator|->
name|node
argument_list|,
name|sc
operator|->
name|nodename
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ing: ng_name node, ret = %d\n!"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
name|NG_NODE_SET_PRIVATE
argument_list|(
name|sc
operator|->
name|node
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|xmitq
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|sc
operator|->
name|xmitq_hipri
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|xmitq
operator|.
name|ifq_mtx
argument_list|)
condition|)
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|xmitq
operator|.
name|ifq_mtx
argument_list|,
literal|"i4b_ing_xmitq"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|xmitq_hipri
operator|.
name|ifq_mtx
argument_list|)
condition|)
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|xmitq_hipri
operator|.
name|ifq_mtx
argument_list|,
literal|"i4b_ing_hipri"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|I4BINGACCT
end_ifdef

begin_comment
comment|/*---------------------------------------------------------------------------*  *	accounting timeout routine  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ing_timeout
parameter_list|(
name|struct
name|ing_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bchan_statistics_t
name|bs
decl_stmt|;
name|int
name|unit
init|=
name|sc
operator|->
name|sc_unit
decl_stmt|;
comment|/* get # of bytes in and out from the HSCX driver */
operator|(
operator|*
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|bch_stat
operator|)
operator|(
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|unit
operator|,
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|channel
operator|,
operator|&
name|bs
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_ioutb
operator|+=
name|bs
operator|.
name|outbytes
expr_stmt|;
name|sc
operator|->
name|sc_iinb
operator|+=
name|bs
operator|.
name|inbytes
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_iinb
operator|!=
name|sc
operator|->
name|sc_linb
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_ioutb
operator|!=
name|sc
operator|->
name|sc_loutb
operator|)
operator|||
name|sc
operator|->
name|sc_fn
condition|)
block|{
name|int
name|ri
init|=
operator|(
name|sc
operator|->
name|sc_iinb
operator|-
name|sc
operator|->
name|sc_linb
operator|)
operator|/
name|I4BINGACCTINTVL
decl_stmt|;
name|int
name|ro
init|=
operator|(
name|sc
operator|->
name|sc_ioutb
operator|-
name|sc
operator|->
name|sc_loutb
operator|)
operator|/
name|I4BINGACCTINTVL
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_iinb
operator|==
name|sc
operator|->
name|sc_linb
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_ioutb
operator|==
name|sc
operator|->
name|sc_loutb
operator|)
condition|)
name|sc
operator|->
name|sc_fn
operator|=
literal|0
expr_stmt|;
else|else
name|sc
operator|->
name|sc_fn
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_linb
operator|=
name|sc
operator|->
name|sc_iinb
expr_stmt|;
name|sc
operator|->
name|sc_loutb
operator|=
name|sc
operator|->
name|sc_ioutb
expr_stmt|;
name|i4b_l4_accounting
argument_list|(
name|BDRV_ING
argument_list|,
name|unit
argument_list|,
name|ACCT_DURING
argument_list|,
name|sc
operator|->
name|sc_ioutb
argument_list|,
name|sc
operator|->
name|sc_iinb
argument_list|,
name|ro
argument_list|,
name|ri
argument_list|,
name|sc
operator|->
name|sc_ioutb
argument_list|,
name|sc
operator|->
name|sc_iinb
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_callout
operator|=
name|timeout
argument_list|(
operator|(
name|TIMEOUT_FUNC_T
operator|)
name|ing_timeout
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
name|I4BINGACCTINTVL
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I4BINGACCT */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*---------------------------------------------------------------------------*  *	clear the interface's send queues  *---------------------------------------------------------------------------*/
end_comment

begin_endif
unit|static void ingclearqueue(struct ifqueue *iq) { 	int x; 	 	x = splimp(); 	IF_DRAIN(iq); 	splx(x); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*===========================================================================*  *			ISDN INTERFACE ROUTINES  *===========================================================================*/
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	this routine is called from L4 handler at connect time  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ing_connect
parameter_list|(
name|int
name|unit
parameter_list|,
name|void
modifier|*
name|cdp
parameter_list|)
block|{
name|struct
name|ing_softc
modifier|*
name|sc
init|=
operator|&
name|ing_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sc
operator|->
name|sc_cdp
operator|=
operator|(
name|call_desc_t
operator|*
operator|)
name|cdp
expr_stmt|;
name|s
operator|=
name|SPLI4B
argument_list|()
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_DIALST
argument_list|,
literal|"ing%d: setting dial state to ST_CONNECTED"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dialresp
operator|=
name|DSTAT_NONE
expr_stmt|;
name|sc
operator|->
name|sc_lastdialresp
operator|=
name|DSTAT_NONE
expr_stmt|;
if|#
directive|if
name|I4BINGACCT
name|sc
operator|->
name|sc_iinb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ioutb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_inb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_outb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_linb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_loutb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_callout
operator|=
name|timeout
argument_list|(
operator|(
name|TIMEOUT_FUNC_T
operator|)
name|ing_timeout
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
name|I4BINGACCTINTVL
operator|*
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_state
operator|=
name|ST_CONNECTED
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	this routine is called from L4 handler at disconnect time  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ing_disconnect
parameter_list|(
name|int
name|unit
parameter_list|,
name|void
modifier|*
name|cdp
parameter_list|)
block|{
name|call_desc_t
modifier|*
name|cd
init|=
operator|(
name|call_desc_t
operator|*
operator|)
name|cdp
decl_stmt|;
name|struct
name|ing_softc
modifier|*
name|sc
init|=
operator|&
name|ing_softc
index|[
name|unit
index|]
decl_stmt|;
comment|/* new stuff to check that the active channel is being closed */
if|if
condition|(
name|cd
operator|!=
name|sc
operator|->
name|sc_cdp
condition|)
block|{
name|NDBGL4
argument_list|(
name|L4_INGDBG
argument_list|,
literal|"ing%d: channel %d not active"
argument_list|,
name|cd
operator|->
name|driver_unit
argument_list|,
name|cd
operator|->
name|channelid
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|I4BINGACCT
name|untimeout
argument_list|(
operator|(
name|TIMEOUT_FUNC_T
operator|)
name|ing_timeout
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i4b_l4_accounting
argument_list|(
name|BDRV_ING
argument_list|,
name|cd
operator|->
name|driver_unit
argument_list|,
name|ACCT_FINAL
argument_list|,
name|sc
operator|->
name|sc_ioutb
argument_list|,
name|sc
operator|->
name|sc_iinb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_outb
argument_list|,
name|sc
operator|->
name|sc_inb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cdp
operator|=
operator|(
name|call_desc_t
operator|*
operator|)
literal|0
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_DIALST
argument_list|,
literal|"setting dial state to ST_IDLE"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dialresp
operator|=
name|DSTAT_NONE
expr_stmt|;
name|sc
operator|->
name|sc_lastdialresp
operator|=
name|DSTAT_NONE
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ST_IDLE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	this routine is used to give a feedback from userland daemon  *	in case of dial problems  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ing_dialresponse
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|status
parameter_list|,
name|cause_t
name|cause
parameter_list|)
block|{
name|struct
name|ing_softc
modifier|*
name|sc
init|=
operator|&
name|ing_softc
index|[
name|unit
index|]
decl_stmt|;
name|sc
operator|->
name|sc_dialresp
operator|=
name|status
expr_stmt|;
name|NDBGL4
argument_list|(
name|L4_INGDBG
argument_list|,
literal|"ing%d: last=%d, this=%d"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_lastdialresp
argument_list|,
name|sc
operator|->
name|sc_dialresp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|DSTAT_NONE
condition|)
block|{
name|NDBGL4
argument_list|(
name|L4_INGDBG
argument_list|,
literal|"ing%d: clearing queues"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/*		ingclearqueues(sc); */
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	interface soft up/down  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ing_updown
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|updown
parameter_list|)
block|{
name|struct
name|ing_softc
modifier|*
name|sc
init|=
operator|&
name|ing_softc
index|[
name|unit
index|]
decl_stmt|;
name|sc
operator|->
name|sc_updown
operator|=
name|updown
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	this routine is called from the HSCX interrupt handler  *	when a new frame (mbuf) has been received and was put on  *	the rx queue. It is assumed that this routines runs at  *	pri level splimp() ! Keep it short !  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ing_rx_data_rdy
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|ing_softc
modifier|*
name|sc
init|=
operator|&
name|ing_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
operator|*
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|rx_mbuf
operator|)
operator|==
name|NULL
condition|)
return|return;
if|#
directive|if
name|I4BINGACCT
name|sc
operator|->
name|sc_inb
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
endif|#
directive|endif
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_inpkt
operator|++
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|sc
operator|->
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	this routine is called from the HSCX interrupt handler  *	when the last frame has been sent out and there is no  *	further frame (mbuf) in the tx queue.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ing_tx_queue_empty
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|ing_softc
modifier|*
name|sc
init|=
operator|&
name|ing_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|ST_CONNECTED
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|xmitq_hipri
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|xmitq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
block|}
if|#
directive|if
name|I4BINGACCT
name|sc
operator|->
name|sc_outb
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|IF_HANDOFF
argument_list|(
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|tx_queue
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|NDBGL4
argument_list|(
name|L4_INGDBG
argument_list|,
literal|"ing%d: tx queue full!"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|x
condition|)
operator|(
operator|*
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|bch_tx_start
operator|)
operator|(
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|unit
operator|,
name|isdn_linktab
index|[
name|unit
index|]
operator|->
name|channel
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	this routine is called from the HSCX interrupt handler  *	each time a packet is received or transmitted. It should  *	be used to implement an activity timeout mechanism.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ing_activity
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|rxtx
parameter_list|)
block|{
name|ing_softc
index|[
name|unit
index|]
operator|.
name|sc_cdp
operator|->
name|last_active_time
operator|=
name|SECOND
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	return this drivers linktab address  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|drvr_link_t
modifier|*
name|ing_ret_linktab
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
operator|(
operator|&
name|ing_drvr_linktab
index|[
name|unit
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	setup the isdn_linktab for this driver  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|ing_set_linktab
parameter_list|(
name|int
name|unit
parameter_list|,
name|isdn_link_t
modifier|*
name|ilt
parameter_list|)
block|{
name|isdn_linktab
index|[
name|unit
index|]
operator|=
name|ilt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	initialize this drivers linktab  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ing_init_linktab
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|ing_drvr_linktab
index|[
name|unit
index|]
operator|.
name|unit
operator|=
name|unit
expr_stmt|;
name|ing_drvr_linktab
index|[
name|unit
index|]
operator|.
name|bch_rx_data_ready
operator|=
name|ing_rx_data_rdy
expr_stmt|;
name|ing_drvr_linktab
index|[
name|unit
index|]
operator|.
name|bch_tx_queue_empty
operator|=
name|ing_tx_queue_empty
expr_stmt|;
name|ing_drvr_linktab
index|[
name|unit
index|]
operator|.
name|bch_activity
operator|=
name|ing_activity
expr_stmt|;
name|ing_drvr_linktab
index|[
name|unit
index|]
operator|.
name|line_connected
operator|=
name|ing_connect
expr_stmt|;
name|ing_drvr_linktab
index|[
name|unit
index|]
operator|.
name|line_disconnected
operator|=
name|ing_disconnect
expr_stmt|;
name|ing_drvr_linktab
index|[
name|unit
index|]
operator|.
name|dial_response
operator|=
name|ing_dialresponse
expr_stmt|;
name|ing_drvr_linktab
index|[
name|unit
index|]
operator|.
name|updown_ind
operator|=
name|ing_updown
expr_stmt|;
block|}
end_function

begin_comment
comment|/*===========================================================================*  *			NETGRAPH INTERFACE ROUTINES  *===========================================================================*/
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  * It is not possible or allowable to create a node of this type.  * If the hardware exists, it will already have created it.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|ng_ing_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  * Give our ok for a hook to be added...  * Add the hook's private info to the hook structure.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|ng_ing_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ing_softc
modifier|*
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|/* 	 * check if it's our friend the debug hook 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_ING_HOOK_DEBUG
argument_list|)
operator|==
literal|0
condition|)
block|{
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* paranoid */
name|sc
operator|->
name|debughook
operator|=
name|hook
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check for raw mode hook. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_ING_HOOK_RAW
argument_list|)
operator|==
literal|0
condition|)
block|{
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  * Get a netgraph control message.  * Check it is one we understand. If needed, send a response.  * We could save the address for an async action later, but don't here.  * Always free the message.  * The response should be in a malloc'd region that the caller can 'free'.  * A response is not required.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|ng_ing_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|struct
name|ing_softc
modifier|*
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
operator|==
name|NGM_GENERIC_COOKIE
condition|)
block|{
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_TEXT_STATUS
case|:
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|+
name|NG_TEXTRESPONSE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|arg
operator|=
operator|(
name|char
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
case|case
name|ST_IDLE
case|:
name|p
operator|=
literal|"idle"
expr_stmt|;
break|break;
case|case
name|ST_DIALING
case|:
name|p
operator|=
literal|"dialing"
expr_stmt|;
break|break;
case|case
name|ST_CONNECTED
case|:
name|p
operator|=
literal|"connected"
expr_stmt|;
break|break;
default|default:
name|p
operator|=
literal|"???"
expr_stmt|;
break|break;
block|}
name|pos
operator|=
name|sprintf
argument_list|(
name|arg
argument_list|,
literal|"state = %s (%d)\n"
argument_list|,
name|p
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
if|#
directive|if
name|I4BINGACCT
name|pos
operator|+=
name|sprintf
argument_list|(
name|arg
operator|+
name|pos
argument_list|,
literal|"%d bytes in, %d bytes out\n"
argument_list|,
name|sc
operator|->
name|sc_inb
argument_list|,
name|sc
operator|->
name|sc_outb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pos
operator|+=
name|sprintf
argument_list|(
name|arg
operator|+
name|pos
argument_list|,
literal|"%d pkts in, %d pkts out\n"
argument_list|,
name|sc
operator|->
name|sc_inpkt
argument_list|,
name|sc
operator|->
name|sc_outpkt
argument_list|)
expr_stmt|;
name|resp
operator|->
name|header
operator|.
name|arglen
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
operator|==
name|NGM_ING_COOKIE
condition|)
block|{
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_ING_GET_STATUS
case|:
block|{
name|struct
name|ngingstat
modifier|*
name|stats
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|stats
operator|=
operator|(
expr|struct
name|ngingstat
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|stats
operator|->
name|packets_in
operator|=
name|sc
operator|->
name|packets_in
expr_stmt|;
name|stats
operator|->
name|packets_out
operator|=
name|sc
operator|->
name|packets_out
expr_stmt|;
break|break;
block|}
case|case
name|NGM_ING_SET_FLAG
case|:
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|flags
operator|=
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|msg
operator|->
name|data
operator|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* unknown command */
break|break;
block|}
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* unknown cookie type */
block|}
comment|/* Take care of synchronous response, if any */
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
comment|/* Free the message and return */
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  * get data from another node and transmit it out on a B-channel  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|ng_ing_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|struct
name|ing_softc
modifier|*
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|xmitq_p
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|meta_p
name|meta
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NGI_GET_META
argument_list|(
name|item
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ST_IDLE
operator|||
name|sc
operator|->
name|sc_state
operator|==
name|ST_DIALING
condition|)
block|{
name|i4b_l4_dialout
argument_list|(
name|BDRV_ING
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ST_DIALING
expr_stmt|;
block|}
name|sc
operator|->
name|sc_outpkt
operator|++
expr_stmt|;
comment|/* 	* Now queue the data for when it can be sent 	*/
if|if
condition|(
name|meta
operator|&&
name|meta
operator|->
name|priority
operator|>
literal|0
condition|)
block|{
name|xmitq_p
operator|=
operator|(
operator|&
name|sc
operator|->
name|xmitq_hipri
operator|)
expr_stmt|;
block|}
else|else
block|{
name|xmitq_p
operator|=
operator|(
operator|&
name|sc
operator|->
name|xmitq
operator|)
expr_stmt|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_LOCK
argument_list|(
name|xmitq_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IF_QFULL
argument_list|(
name|xmitq_p
argument_list|)
condition|)
block|{
name|_IF_DROP
argument_list|(
name|xmitq_p
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|xmitq_p
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|_IF_ENQUEUE
argument_list|(
name|xmitq_p
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|xmitq_p
argument_list|)
expr_stmt|;
name|ing_tx_queue_empty
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  * Do local shutdown processing..  * If we are a persistant device, we might refuse to go away, and  * we'd only remove our links and reset ourself.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|ng_ing_shutdown
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|struct
name|ing_softc
modifier|*
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|sc
operator|->
name|packets_in
operator|=
literal|0
expr_stmt|;
comment|/* reset stats */
name|sc
operator|->
name|packets_out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
operator|&
name|sc
operator|->
name|node
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ing: ng_make_node_common, ret = %d\n!"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
comment|/* name the netgraph node */
name|sprintf
argument_list|(
name|sc
operator|->
name|nodename
argument_list|,
literal|"%s%d"
argument_list|,
name|NG_ING_NODE_TYPE
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|ng_name_node
argument_list|(
name|sc
operator|->
name|node
argument_list|,
name|sc
operator|->
name|nodename
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ing: ng_name node, ret = %d\n!"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|NG_NODE_SET_PRIVATE
argument_list|(
name|sc
operator|->
name|node
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  * This is called once we've already connected a new hook to the other node.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|ng_ing_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
comment|/* probably not at splnet, force outward queueing */
name|NG_HOOK_FORCE_QUEUE
argument_list|(
name|NG_HOOK_PEER
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dook disconnection  *  * For this type, removal of the last link destroys the node  */
end_comment

begin_function
specifier|static
name|int
name|ng_ing_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|struct
name|ing_softc
modifier|*
name|sc
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|debughook
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*===========================================================================*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NI4BING> 0 */
end_comment

end_unit

