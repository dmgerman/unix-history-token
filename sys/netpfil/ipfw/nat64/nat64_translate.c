begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Yandex LLC  * Copyright (c) 2015-2016 Andrey V. Elsukov<ae@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ipfw.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/counter.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rmlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_pflog.h>
end_include

begin_include
include|#
directive|include
file|<net/pfil.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/pf/pf.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/ip_fw_private.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/nat64/ip_fw_nat64.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/nat64/nat64_translate.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_function
specifier|static
name|void
name|nat64_log
parameter_list|(
name|struct
name|pfloghdr
modifier|*
name|logdata
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|sa_family_t
name|family
parameter_list|)
block|{
name|logdata
operator|->
name|dir
operator|=
name|PF_OUT
expr_stmt|;
name|logdata
operator|->
name|af
operator|=
name|family
expr_stmt|;
name|ipfw_bpf_mtap2
argument_list|(
name|logdata
argument_list|,
name|PFLOG_HDRLEN
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IPFIREWALL_NAT64_DIRECT_OUTPUT
end_ifdef

begin_expr_stmt
specifier|static
name|NAT64NOINLINE
expr|struct
name|sockaddr
operator|*
name|nat64_find_route4
argument_list|(
argument|struct route *ro
argument_list|,
argument|in_addr_t dest
argument_list|,
argument|struct mbuf *m
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|NAT64NOINLINE
expr|struct
name|sockaddr
operator|*
name|nat64_find_route6
argument_list|(
expr|struct
name|route_in6
operator|*
name|ro
argument_list|,
expr|struct
name|in6_addr
operator|*
name|dest
argument_list|,
expr|struct
name|mbuf
operator|*
name|m
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|nat64_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|,
name|nat64_stats_block
modifier|*
name|stats
parameter_list|,
name|void
modifier|*
name|logdata
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|logdata
operator|!=
name|NULL
condition|)
name|nat64_log
argument_list|(
name|logdata
argument_list|,
name|m
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|ro
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|oerrors
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|nat64_output_one
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|nat64_stats_block
modifier|*
name|stats
parameter_list|,
name|void
modifier|*
name|logdata
parameter_list|)
block|{
name|struct
name|route_in6
name|ro6
decl_stmt|;
name|struct
name|route
name|ro4
decl_stmt|,
modifier|*
name|ro
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip4
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ip4
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ip4
operator|->
name|ip_v
condition|)
block|{
case|case
name|IPVERSION
case|:
name|ro
operator|=
operator|&
name|ro4
expr_stmt|;
name|dst
operator|=
name|nat64_find_route4
argument_list|(
operator|&
name|ro4
argument_list|,
name|ip4
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|noroute4
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|IPV6_VERSION
operator|>>
literal|4
operator|)
case|:
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
name|ip4
expr_stmt|;
name|ro
operator|=
operator|(
expr|struct
name|route
operator|*
operator|)
operator|&
name|ro6
expr_stmt|;
name|dst
operator|=
name|nat64_find_route6
argument_list|(
operator|&
name|ro6
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|noroute6
argument_list|)
expr_stmt|;
break|break;
default|default:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"dropped due to unknown IP version"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
name|FREE_ROUTE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
block|}
if|if
condition|(
name|logdata
operator|!=
name|NULL
condition|)
name|nat64_log
argument_list|(
name|logdata
argument_list|,
name|m
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|ro
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|oerrors
argument_list|)
expr_stmt|;
name|FREE_ROUTE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !IPFIREWALL_NAT64_DIRECT_OUTPUT */
end_comment

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|nat64_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|,
name|nat64_stats_block
modifier|*
name|stats
parameter_list|,
name|void
modifier|*
name|logdata
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip4
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|af
decl_stmt|;
name|ip4
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ip4
operator|->
name|ip_v
condition|)
block|{
case|case
name|IPVERSION
case|:
name|af
operator|=
name|AF_INET
expr_stmt|;
name|ret
operator|=
name|NETISR_IP
expr_stmt|;
break|break;
case|case
operator|(
name|IPV6_VERSION
operator|>>
literal|4
operator|)
case|:
name|af
operator|=
name|AF_INET6
expr_stmt|;
name|ret
operator|=
name|NETISR_IPV6
expr_stmt|;
break|break;
default|default:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"unknown IP version"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
if|if
condition|(
name|logdata
operator|!=
name|NULL
condition|)
name|nat64_log
argument_list|(
name|logdata
argument_list|,
name|m
argument_list|,
name|af
argument_list|)
expr_stmt|;
name|ret
operator|=
name|netisr_queue
argument_list|(
name|ret
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|oerrors
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|nat64_output_one
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|nat64_stats_block
modifier|*
name|stats
parameter_list|,
name|void
modifier|*
name|logdata
parameter_list|)
block|{
return|return
operator|(
name|nat64_output
argument_list|(
name|NULL
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|stats
argument_list|,
name|logdata
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !IPFIREWALL_NAT64_DIRECT_OUTPUT */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|void print_ipv6_header(struct ip6_hdr *ip6, char *buf, size_t bufsize);  void print_ipv6_header(struct ip6_hdr *ip6, char *buf, size_t bufsize) { 	char sbuf[INET6_ADDRSTRLEN], dbuf[INET6_ADDRSTRLEN];  	inet_ntop(AF_INET6,&ip6->ip6_src, sbuf, sizeof(sbuf)); 	inet_ntop(AF_INET6,&ip6->ip6_dst, dbuf, sizeof(dbuf)); 	snprintf(buf, bufsize, "%s -> %s %d", sbuf, dbuf, ip6->ip6_nxt); }   static NAT64NOINLINE int nat64_embed_ip4(struct nat64_cfg *cfg, in_addr_t ia, struct in6_addr *ip6) {
comment|/* assume the prefix is properly filled with zeros */
end_comment

begin_if
unit|bcopy(&cfg->prefix, ip6, sizeof(*ip6)); 	switch (cfg->plen) { 	case 32: 	case 96: 		ip6->s6_addr32[cfg->plen / 32] = ia; 		break; 	case 40: 	case 48: 	case 56:
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
end_if

begin_elif
unit|ip6->s6_addr32[1] = cfg->prefix.s6_addr32[1] | 		    (ia>> (cfg->plen % 32)); 		ip6->s6_addr32[2] = ia<< (24 - cfg->plen % 32);
elif|#
directive|elif
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
end_elif

begin_endif
unit|ip6->s6_addr32[1] = cfg->prefix.s6_addr32[1] | 		    (ia<< (cfg->plen % 32)); 		ip6->s6_addr32[2] = ia>> (24 - cfg->plen % 32);
endif|#
directive|endif
end_endif

begin_if
unit|break; 	case 64:
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
end_if

begin_elif
unit|ip6->s6_addr32[2] = ia>> 8; 		ip6->s6_addr32[3] = ia<< 24;
elif|#
directive|elif
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
end_elif

begin_endif
unit|ip6->s6_addr32[2] = ia<< 8; 		ip6->s6_addr32[3] = ia>> 24;
endif|#
directive|endif
end_endif

begin_comment
unit|break; 	default: 		return (0); 	}; 	ip6->s6_addr8[8] = 0; 	return (1); }  static NAT64NOINLINE in_addr_t nat64_extract_ip4(struct in6_addr *ip6, int plen) { 	in_addr_t ia;
comment|/* 	 * According to RFC 6052 p2.2: 	 * IPv4-embedded IPv6 addresses are composed of a variable-length 	 * prefix, the embedded IPv4 address, and a variable length suffix. 	 * The suffix bits are reserved for future extensions and SHOULD 	 * be set to zero. 	 */
end_comment

begin_if
unit|switch (plen) { 	case 32: 		if (ip6->s6_addr32[3] != 0 || ip6->s6_addr32[2] != 0) 			goto badip6; 		break; 	case 40: 		if (ip6->s6_addr32[3] != 0 || 		    (ip6->s6_addr32[2]& htonl(0xff00ffff)) != 0) 			goto badip6; 		break; 	case 48: 		if (ip6->s6_addr32[3] != 0 || 		    (ip6->s6_addr32[2]& htonl(0xff0000ff)) != 0) 			goto badip6; 		break; 	case 56: 		if (ip6->s6_addr32[3] != 0 || ip6->s6_addr8[8] != 0) 			goto badip6; 		break; 	case 64: 		if (ip6->s6_addr8[8] != 0 || 		    (ip6->s6_addr32[3]& htonl(0x00ffffff)) != 0) 			goto badip6; 	}; 	switch (plen) { 	case 32: 	case 96: 		ia = ip6->s6_addr32[plen / 32]; 		break; 	case 40: 	case 48: 	case 56:
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
end_if

begin_elif
unit|ia = (ip6->s6_addr32[1]<< (plen % 32)) | 		    (ip6->s6_addr32[2]>> (24 - plen % 32));
elif|#
directive|elif
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
end_elif

begin_endif
unit|ia = (ip6->s6_addr32[1]>> (plen % 32)) | 		    (ip6->s6_addr32[2]<< (24 - plen % 32));
endif|#
directive|endif
end_endif

begin_if
unit|break; 	case 64:
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
end_if

begin_elif
unit|ia = (ip6->s6_addr32[2]<< 8) | (ip6->s6_addr32[3]>> 24);
elif|#
directive|elif
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
end_elif

begin_endif
unit|ia = (ip6->s6_addr32[2]>> 8) | (ip6->s6_addr32[3]<< 24);
endif|#
directive|endif
end_endif

begin_endif
unit|break; 	default: 		return (0); 	}; 	if (nat64_check_ip4(ia) != 0 || 	    nat64_check_private_ip4(ia) != 0) 		goto badip4;  	return (ia); badip4: 	DPRINTF(DP_GENERIC, "invalid destination address: %08x", ia); 	return (0); badip6: 	DPRINTF(DP_GENERIC, "invalid IPv4-embedded IPv6 address"); 	return (0); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * According to RFC 1624 the equation for incremental checksum update is:  *	HC' = ~(~HC + ~m + m')	--	[Eqn. 3]  *	HC' = HC - ~m - m'	--	[Eqn. 4]  * So, when we are replacing IPv4 addresses to IPv6, we  * can assume, that new bytes previously were zeros, and vise versa -  * when we replacing IPv6 addresses to IPv4, now unused bytes become  * zeros. The payload length in pseudo header has bigger size, but one  * half of it should be zero. Using the equation 4 we get:  *	HC' = HC - (~m0 + m0')	-- m0 is first changed word  *	HC' = (HC - (~m0 + m0')) - (~m1 + m1')	-- m1 is second changed word  *	HC' = HC - ~m0 - m0' - ~m1 - m1' - ... =  *	  = HC - sum(~m[i] + m'[i])  *  * The function result should be used as follows:  *	IPv6 to IPv4:	HC' = cksum_add(HC, result)  *	IPv4 to IPv6:	HC' = cksum_add(HC, ~result)  */
end_comment

begin_function
specifier|static
name|NAT64NOINLINE
name|uint16_t
name|nat64_cksum_convert
parameter_list|(
name|struct
name|ip6_hdr
modifier|*
name|ip6
parameter_list|,
name|struct
name|ip
modifier|*
name|ip
parameter_list|)
block|{
name|uint32_t
name|sum
decl_stmt|;
name|uint16_t
modifier|*
name|p
decl_stmt|;
name|sum
operator|=
operator|~
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|>>
literal|16
expr_stmt|;
name|sum
operator|+=
operator|~
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|&
literal|0xffff
expr_stmt|;
name|sum
operator|+=
operator|~
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|>>
literal|16
expr_stmt|;
name|sum
operator|+=
operator|~
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|&
literal|0xffff
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|ip6
operator|->
name|ip6_src
init|;
name|p
operator|<
operator|(
name|uint16_t
operator|*
operator|)
operator|(
operator|&
name|ip6
operator|->
name|ip6_src
operator|+
literal|2
operator|)
condition|;
name|p
operator|++
control|)
name|sum
operator|+=
operator|*
name|p
expr_stmt|;
while|while
condition|(
name|sum
operator|>>
literal|16
condition|)
name|sum
operator|=
operator|(
name|sum
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|sum
operator|>>
literal|16
operator|)
expr_stmt|;
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|1100000
end_if

begin_define
define|#
directive|define
name|ip_fillid
parameter_list|(
name|ip
parameter_list|)
value|(ip)->ip_id = ip_newid()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|NAT64NOINLINE
name|void
name|nat64_init_ip4hdr
parameter_list|(
specifier|const
name|struct
name|ip6_hdr
modifier|*
name|ip6
parameter_list|,
specifier|const
name|struct
name|ip6_frag
modifier|*
name|frag
parameter_list|,
name|uint16_t
name|plen
parameter_list|,
name|uint8_t
name|proto
parameter_list|,
name|struct
name|ip
modifier|*
name|ip
parameter_list|)
block|{
comment|/* assume addresses are already initialized */
name|ip
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
operator|(
name|ntohl
argument_list|(
name|ip6
operator|->
name|ip6_flow
argument_list|)
operator|>>
literal|20
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|+
name|plen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFIREWALL_NAT64_DIRECT_OUTPUT
name|ip
operator|->
name|ip_ttl
operator|=
name|ip6
operator|->
name|ip6_hlim
operator|-
name|IPV6_HLIMDEC
expr_stmt|;
else|#
directive|else
comment|/* Forwarding code will decrement TTL. */
name|ip
operator|->
name|ip_ttl
operator|=
name|ip6
operator|->
name|ip6_hlim
expr_stmt|;
endif|#
directive|endif
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
operator|(
name|proto
operator|==
name|IPPROTO_ICMPV6
operator|)
condition|?
name|IPPROTO_ICMP
else|:
name|proto
expr_stmt|;
name|ip_fillid
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|frag
operator|->
name|ip6f_offlg
argument_list|)
operator|>>
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|ip6f_offlg
operator|&
name|IP6F_MORE_FRAG
condition|)
name|ip
operator|->
name|ip_off
operator||=
name|htons
argument_list|(
name|IP_MF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|IP_DF
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum_hdr
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|FRAGSZ
parameter_list|(
name|mtu
parameter_list|)
value|((mtu) - sizeof(struct ip6_hdr) - sizeof(struct ip6_frag))
end_define

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|nat64_fragment6
parameter_list|(
name|nat64_stats_block
modifier|*
name|stats
parameter_list|,
name|struct
name|ip6_hdr
modifier|*
name|ip6
parameter_list|,
name|struct
name|mbufq
modifier|*
name|mq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|mtu
parameter_list|,
name|uint16_t
name|ip_id
parameter_list|,
name|uint16_t
name|ip_off
parameter_list|)
block|{
name|struct
name|ip6_frag
name|ip6f
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|uint16_t
name|hlen
decl_stmt|,
name|len
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|plen
decl_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
name|hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
comment|/* Fragmentation isn't needed */
if|if
condition|(
name|ip_off
operator|==
literal|0
operator|&&
name|plen
operator|<=
name|mtu
operator|-
name|hlen
condition|)
block|{
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|nomem
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|ip6
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbufq_enqueue
argument_list|(
name|mq
argument_list|,
name|m
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"dropped due to mbufq overflow"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
name|ip6f
operator|.
name|ip6f_reserved
operator|=
literal|0
expr_stmt|;
name|ip6f
operator|.
name|ip6f_nxt
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|ip6
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_FRAGMENT
expr_stmt|;
if|if
condition|(
name|ip_off
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We have got an IPv4 fragment. 		 * Use offset value and ip_id from original fragment. 		 */
name|ip6f
operator|.
name|ip6f_ident
operator|=
name|htonl
argument_list|(
name|ntohs
argument_list|(
name|ip_id
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|ntohs
argument_list|(
name|ip_off
argument_list|)
operator|&
name|IP_OFFMASK
operator|)
operator|<<
literal|3
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|ifrags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The packet size exceeds interface MTU */
name|ip6f
operator|.
name|ip6f_ident
operator|=
name|htonl
argument_list|(
name|ip6_randomid
argument_list|()
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* First fragment*/
block|}
while|while
condition|(
name|plen
operator|>
literal|0
operator|&&
name|m
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|FRAGSZ
argument_list|(
name|mtu
argument_list|)
operator|&
operator|~
literal|7
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|plen
condition|)
name|len
operator|=
name|plen
expr_stmt|;
name|ip6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|len
operator|+
sizeof|sizeof
argument_list|(
name|ip6f
argument_list|)
argument_list|)
expr_stmt|;
name|ip6f
operator|.
name|ip6f_offlg
operator|=
name|ntohs
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|plen
operator|||
operator|(
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_MF
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|ip6f
operator|.
name|ip6f_offlg
operator||=
name|IP6F_MORE_FRAG
expr_stmt|;
name|offset
operator|+=
name|len
expr_stmt|;
name|plen
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|plen
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
name|len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
block|}
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|bcopy
argument_list|(
name|ip6
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ip6f
argument_list|,
name|mtodo
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbufq_enqueue
argument_list|(
name|mq
argument_list|,
name|m
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|m
operator|=
name|n
expr_stmt|;
block|}
name|NAT64STAT_ADD
argument_list|(
name|stats
argument_list|,
name|ofrags
argument_list|,
name|mbufq_len
argument_list|(
name|mq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|mbufq_drain
argument_list|(
name|mq
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|nomem
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|1100000
end_if

begin_define
define|#
directive|define
name|rt_expire
value|rt_rmx.rmx_expire
end_define

begin_define
define|#
directive|define
name|rt_mtu
value|rt_rmx.rmx_mtu
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|NAT64NOINLINE
expr|struct
name|sockaddr
operator|*
name|nat64_find_route6
argument_list|(
argument|struct route_in6 *ro
argument_list|,
argument|struct in6_addr *dest
argument_list|,
argument|struct mbuf *m
argument_list|)
block|{ 	struct
name|sockaddr_in6
operator|*
name|dst
block|; 	struct
name|rtentry
operator|*
name|rt
block|;
name|bzero
argument_list|(
name|ro
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ro
argument_list|)
argument_list|)
block|;
name|dst
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
block|;
name|dst
operator|->
name|sin6_family
operator|=
name|AF_INET6
block|;
name|dst
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
block|;
name|dst
operator|->
name|sin6_addr
operator|=
operator|*
name|dest
block|;
name|IN6_LOOKUP_ROUTE
argument_list|(
name|ro
argument_list|,
name|M_GETFIB
argument_list|(
name|m
argument_list|)
argument_list|)
block|;
name|rt
operator|=
name|ro
operator|->
name|ro_rt
block|;
if|if
condition|(
name|rt
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
name|dst
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
return|return
operator|(
name|NULL
operator|)
return|;
end_else

begin_if
if|if
condition|(
operator|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_REJECT
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_expire
operator|==
literal|0
operator|||
name|time_uptime
operator|<
name|rt
operator|->
name|rt_expire
operator|)
operator|)
operator|||
name|rt
operator|->
name|rt_ifp
operator|->
name|if_link_state
operator|==
name|LINK_STATE_DOWN
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
end_if

begin_return
return|return
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
operator|)
return|;
end_return

begin_define
unit|}
define|#
directive|define
name|NAT64_ICMP6_PLEN
value|64
end_define

begin_function
unit|static
name|NAT64NOINLINE
name|void
name|nat64_icmp6_reflect
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint8_t
name|code
parameter_list|,
name|uint32_t
name|mtu
parameter_list|,
name|nat64_stats_block
modifier|*
name|stats
parameter_list|,
name|void
modifier|*
name|logdata
parameter_list|)
block|{
name|struct
name|icmp6_hdr
modifier|*
name|icmp6
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|,
modifier|*
name|oip6
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|int
name|len
decl_stmt|,
name|plen
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|plen
operator|=
name|nat64_getlasthdr
argument_list|(
name|m
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|<
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"mbuf isn't contigious"
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
comment|/* 	 * Do not send ICMPv6 in reply to ICMPv6 errors. 	 */
if|if
condition|(
name|plen
operator|==
name|IPPROTO_ICMPV6
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|len
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|icmp6
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"mbuf isn't contigious"
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
name|icmp6
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmp6
operator|->
name|icmp6_type
operator|<
name|ICMP6_ECHO_REQUEST
operator|||
name|icmp6
operator|->
name|icmp6_type
operator|==
name|ND_REDIRECT
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"do not send ICMPv6 in reply to "
literal|"ICMPv6 errors"
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
block|}
comment|/* 	if (icmp6_ratelimit(&ip6->ip6_src, type, code)) 		goto freeit; 		*/
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ICMP6_DST_UNREACH
case|:
case|case
name|ICMP6_PACKET_TOO_BIG
case|:
case|case
name|ICMP6_TIME_EXCEEDED
case|:
case|case
name|ICMP6_PARAM_PROB
case|:
break|break;
default|default:
goto|goto
name|freeit
goto|;
block|}
comment|/* Calculate length of ICMPv6 payload */
name|len
operator|=
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|NAT64_ICMP6_PLEN
operator|)
condition|?
name|NAT64_ICMP6_PLEN
else|:
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Create new ICMPv6 datagram */
name|plen
operator|=
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
expr_stmt|;
name|n
operator|=
name|m_get2
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
operator|+
name|max_hdr
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_HEADER
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|nomem
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Move pkthdr from original mbuf. We should have initialized some 	 * fields, because we can reinject this mbuf to netisr and it will 	 * go trough input path (it requires at least rcvif should be set). 	 * Also do M_ALIGN() to reduce chances of need to allocate new mbuf 	 * in the chain, when we will do M_PREPEND() or make some type of 	 * tunneling. 	 */
name|m_move_pkthdr
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|M_ALIGN
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
operator|+
name|max_hdr
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
expr_stmt|;
name|oip6
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|oip6
operator|->
name|ip6_src
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|oip6
operator|->
name|ip6_dst
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|oip6
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_ICMPV6
expr_stmt|;
name|oip6
operator|->
name|ip6_flow
operator|=
literal|0
expr_stmt|;
name|oip6
operator|->
name|ip6_vfc
operator||=
name|IPV6_VERSION
expr_stmt|;
name|oip6
operator|->
name|ip6_hlim
operator|=
name|V_ip6_defhlim
expr_stmt|;
name|oip6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
name|icmp6
operator|=
name|mtodo
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|icmp6
operator|->
name|icmp6_cksum
operator|=
literal|0
expr_stmt|;
name|icmp6
operator|->
name|icmp6_type
operator|=
name|type
expr_stmt|;
name|icmp6
operator|->
name|icmp6_code
operator|=
name|code
expr_stmt|;
name|icmp6
operator|->
name|icmp6_mtu
operator|=
name|htonl
argument_list|(
name|mtu
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|mtodo
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|icmp6
operator|->
name|icmp6_cksum
operator|=
name|in6_cksum
argument_list|(
name|n
argument_list|,
name|IPPROTO_ICMPV6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|nat64_output_one
argument_list|(
name|n
argument_list|,
name|stats
argument_list|,
name|logdata
argument_list|)
expr_stmt|;
return|return;
name|freeit
label|:
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|NAT64NOINLINE
expr|struct
name|sockaddr
operator|*
name|nat64_find_route4
argument_list|(
argument|struct route *ro
argument_list|,
argument|in_addr_t dest
argument_list|,
argument|struct mbuf *m
argument_list|)
block|{ 	struct
name|sockaddr_in
operator|*
name|dst
block|; 	struct
name|rtentry
operator|*
name|rt
block|;
name|bzero
argument_list|(
name|ro
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ro
argument_list|)
argument_list|)
block|;
name|dst
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
block|;
name|dst
operator|->
name|sin_family
operator|=
name|AF_INET
block|;
name|dst
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
block|;
name|dst
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|dest
block|;
name|IN_LOOKUP_ROUTE
argument_list|(
name|ro
argument_list|,
name|M_GETFIB
argument_list|(
name|m
argument_list|)
argument_list|)
block|;
name|rt
operator|=
name|ro
operator|->
name|ro_rt
block|;
if|if
condition|(
name|rt
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
name|dst
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
return|return
operator|(
name|NULL
operator|)
return|;
end_else

begin_if
if|if
condition|(
operator|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_REJECT
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_expire
operator|==
literal|0
operator|||
name|time_uptime
operator|<
name|rt
operator|->
name|rt_expire
operator|)
operator|)
operator|||
name|rt
operator|->
name|rt_ifp
operator|->
name|if_link_state
operator|==
name|LINK_STATE_DOWN
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
end_if

begin_return
return|return
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
operator|)
return|;
end_return

begin_define
unit|}
define|#
directive|define
name|NAT64_ICMP_PLEN
value|64
end_define

begin_function
unit|static
name|NAT64NOINLINE
name|void
name|nat64_icmp_reflect
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint8_t
name|code
parameter_list|,
name|uint16_t
name|mtu
parameter_list|,
name|nat64_stats_block
modifier|*
name|stats
parameter_list|,
name|void
modifier|*
name|logdata
parameter_list|)
block|{
name|struct
name|icmp
modifier|*
name|icmp
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|,
modifier|*
name|oip
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|int
name|len
decl_stmt|,
name|plen
decl_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* Do not send ICMP error if packet is not the first fragment */
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|&
operator|~
name|ntohs
argument_list|(
name|IP_MF
operator||
name|IP_DF
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"not first fragment"
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
comment|/* Do not send ICMP in reply to ICMP errors */
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_ICMP
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"mbuf isn't contigious"
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
name|icmp
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ICMP_INFOTYPE
argument_list|(
name|icmp
operator|->
name|icmp_type
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"do not send ICMP in reply to "
literal|"ICMP errors"
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ICMP_UNREACH
case|:
case|case
name|ICMP_TIMXCEED
case|:
case|case
name|ICMP_PARAMPROB
case|:
break|break;
default|default:
goto|goto
name|freeit
goto|;
block|}
comment|/* Calculate length of ICMP payload */
name|len
operator|=
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|NAT64_ICMP_PLEN
operator|)
condition|?
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
literal|8
else|:
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Create new ICMPv4 datagram */
name|plen
operator|=
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|icmphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|n
operator|=
name|m_get2
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|plen
operator|+
name|max_hdr
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_HEADER
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|nomem
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_move_pkthdr
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|M_ALIGN
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|plen
operator|+
name|max_hdr
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|plen
expr_stmt|;
name|oip
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|oip
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|oip
operator|->
name|ip_hl
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|oip
operator|->
name|ip_tos
operator|=
literal|0
expr_stmt|;
name|oip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|oip
operator|->
name|ip_ttl
operator|=
name|V_ip_defttl
expr_stmt|;
name|oip
operator|->
name|ip_p
operator|=
name|IPPROTO_ICMP
expr_stmt|;
name|ip_fillid
argument_list|(
name|oip
argument_list|)
expr_stmt|;
name|oip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|IP_DF
argument_list|)
expr_stmt|;
name|oip
operator|->
name|ip_src
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|oip
operator|->
name|ip_dst
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|oip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|oip
operator|->
name|ip_sum
operator|=
name|in_cksum_hdr
argument_list|(
name|oip
argument_list|)
expr_stmt|;
name|icmp
operator|=
name|mtodo
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|icmp
operator|->
name|icmp_type
operator|=
name|type
expr_stmt|;
name|icmp
operator|->
name|icmp_code
operator|=
name|code
expr_stmt|;
name|icmp
operator|->
name|icmp_cksum
operator|=
literal|0
expr_stmt|;
name|icmp
operator|->
name|icmp_pmvoid
operator|=
literal|0
expr_stmt|;
name|icmp
operator|->
name|icmp_nextmtu
operator|=
name|htons
argument_list|(
name|mtu
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|mtodo
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|icmphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|icmp
operator|->
name|icmp_cksum
operator|=
name|in_cksum_skip
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|nat64_output_one
argument_list|(
name|n
argument_list|,
name|stats
argument_list|,
name|logdata
argument_list|)
expr_stmt|;
return|return;
name|freeit
label|:
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate ICMP echo request/reply into ICMPv6 */
end_comment

begin_function
specifier|static
name|void
name|nat64_icmp_handle_echo
parameter_list|(
name|struct
name|ip6_hdr
modifier|*
name|ip6
parameter_list|,
name|struct
name|icmp6_hdr
modifier|*
name|icmp6
parameter_list|,
name|uint16_t
name|id
parameter_list|,
name|uint8_t
name|type
parameter_list|)
block|{
name|uint16_t
name|old
decl_stmt|;
name|old
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|icmp6
expr_stmt|;
comment|/* save type+code in one word */
name|icmp6
operator|->
name|icmp6_type
operator|=
name|type
expr_stmt|;
comment|/* Reflect ICMPv6 -> ICMPv4 type translation in the cksum */
name|icmp6
operator|->
name|icmp6_cksum
operator|=
name|cksum_adjust
argument_list|(
name|icmp6
operator|->
name|icmp6_cksum
argument_list|,
name|old
argument_list|,
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|icmp6
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
literal|0
condition|)
block|{
name|old
operator|=
name|icmp6
operator|->
name|icmp6_id
expr_stmt|;
name|icmp6
operator|->
name|icmp6_id
operator|=
name|id
expr_stmt|;
comment|/* Reflect ICMP id translation in the cksum */
name|icmp6
operator|->
name|icmp6_cksum
operator|=
name|cksum_adjust
argument_list|(
name|icmp6
operator|->
name|icmp6_cksum
argument_list|,
name|old
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
comment|/* Reflect IPv6 pseudo header in the cksum */
name|icmp6
operator|->
name|icmp6_cksum
operator|=
operator|~
name|in6_cksum_pseudo
argument_list|(
name|ip6
argument_list|,
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
argument_list|,
name|IPPROTO_ICMPV6
argument_list|,
operator|~
name|icmp6
operator|->
name|icmp6_cksum
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|NAT64NOINLINE
expr|struct
name|mbuf
operator|*
name|nat64_icmp_translate
argument_list|(
argument|struct mbuf *m
argument_list|,
argument|struct ip6_hdr *ip6
argument_list|,
argument|uint16_t icmpid
argument_list|,
argument|int offset
argument_list|,
argument|nat64_stats_block *stats
argument_list|)
block|{ 	struct
name|ip
name|ip
block|; 	struct
name|icmp
operator|*
name|icmp
block|; 	struct
name|tcphdr
operator|*
name|tcp
block|; 	struct
name|udphdr
operator|*
name|udp
block|; 	struct
name|ip6_hdr
operator|*
name|eip6
block|; 	struct
name|mbuf
operator|*
name|n
block|;
name|uint32_t
name|mtu
block|;
name|int
name|len
block|,
name|hlen
block|,
name|plen
block|;
name|uint8_t
name|type
block|,
name|code
block|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|offset
operator|+
name|ICMP_MINLEN
condition|)
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|offset
operator|+
name|ICMP_MINLEN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|nomem
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|mtu
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|icmp
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|offset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* RFC 7915 p4.2 */
end_comment

begin_switch
switch|switch
condition|(
name|icmp
operator|->
name|icmp_type
condition|)
block|{
case|case
name|ICMP_ECHOREPLY
case|:
name|type
operator|=
name|ICMP6_ECHO_REPLY
expr_stmt|;
name|code
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH
case|:
name|type
operator|=
name|ICMP6_DST_UNREACH
expr_stmt|;
switch|switch
condition|(
name|icmp
operator|->
name|icmp_code
condition|)
block|{
case|case
name|ICMP_UNREACH_NET
case|:
case|case
name|ICMP_UNREACH_HOST
case|:
case|case
name|ICMP_UNREACH_SRCFAIL
case|:
case|case
name|ICMP_UNREACH_NET_UNKNOWN
case|:
case|case
name|ICMP_UNREACH_HOST_UNKNOWN
case|:
case|case
name|ICMP_UNREACH_TOSNET
case|:
case|case
name|ICMP_UNREACH_TOSHOST
case|:
name|code
operator|=
name|ICMP6_DST_UNREACH_NOROUTE
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_PROTOCOL
case|:
name|type
operator|=
name|ICMP6_PARAM_PROB
expr_stmt|;
name|code
operator|=
name|ICMP6_PARAMPROB_NEXTHEADER
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_PORT
case|:
name|code
operator|=
name|ICMP6_DST_UNREACH_NOPORT
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_NEEDFRAG
case|:
name|type
operator|=
name|ICMP6_PACKET_TOO_BIG
expr_stmt|;
name|code
operator|=
literal|0
expr_stmt|;
comment|/* XXX: needs an additional look */
name|mtu
operator|=
name|max
argument_list|(
name|IPV6_MMTU
argument_list|,
name|ntohs
argument_list|(
name|icmp
operator|->
name|icmp_nextmtu
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_NET_PROHIB
case|:
case|case
name|ICMP_UNREACH_HOST_PROHIB
case|:
case|case
name|ICMP_UNREACH_FILTER_PROHIB
case|:
case|case
name|ICMP_UNREACH_PRECEDENCE_CUTOFF
case|:
name|code
operator|=
name|ICMP6_DST_UNREACH_ADMIN
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Unsupported ICMP type %d, code %d"
argument_list|,
name|icmp
operator|->
name|icmp_type
argument_list|,
name|icmp
operator|->
name|icmp_code
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
break|break;
case|case
name|ICMP_TIMXCEED
case|:
name|type
operator|=
name|ICMP6_TIME_EXCEEDED
expr_stmt|;
name|code
operator|=
name|icmp
operator|->
name|icmp_code
expr_stmt|;
break|break;
case|case
name|ICMP_ECHO
case|:
name|type
operator|=
name|ICMP6_ECHO_REQUEST
expr_stmt|;
name|code
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ICMP_PARAMPROB
case|:
name|type
operator|=
name|ICMP6_PARAM_PROB
expr_stmt|;
switch|switch
condition|(
name|icmp
operator|->
name|icmp_code
condition|)
block|{
case|case
name|ICMP_PARAMPROB_ERRATPTR
case|:
case|case
name|ICMP_PARAMPROB_LENGTH
case|:
name|code
operator|=
name|ICMP6_PARAMPROB_HEADER
expr_stmt|;
switch|switch
condition|(
name|icmp
operator|->
name|icmp_pptr
condition|)
block|{
case|case
literal|0
case|:
comment|/* Version/IHL */
case|case
literal|1
case|:
comment|/* Type Of Service */
name|mtu
operator|=
name|icmp
operator|->
name|icmp_pptr
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Total Length */
case|case
literal|3
case|:
name|mtu
operator|=
literal|4
expr_stmt|;
comment|/* Payload Length */
break|break;
case|case
literal|8
case|:
comment|/* Time to Live */
name|mtu
operator|=
literal|7
expr_stmt|;
comment|/* Hop Limit */
break|break;
case|case
literal|9
case|:
comment|/* Protocol */
name|mtu
operator|=
literal|6
expr_stmt|;
comment|/* Next Header */
break|break;
case|case
literal|12
case|:
comment|/* Source address */
case|case
literal|13
case|:
case|case
literal|14
case|:
case|case
literal|15
case|:
name|mtu
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|16
case|:
comment|/* Destination address */
case|case
literal|17
case|:
case|case
literal|18
case|:
case|case
literal|19
case|:
name|mtu
operator|=
literal|24
expr_stmt|;
break|break;
default|default:
comment|/* Silently drop */
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Unsupported ICMP type %d,"
literal|" code %d, pptr %d"
argument_list|,
name|icmp
operator|->
name|icmp_type
argument_list|,
name|icmp
operator|->
name|icmp_code
argument_list|,
name|icmp
operator|->
name|icmp_pptr
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
break|break;
default|default:
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Unsupported ICMP type %d,"
literal|" code %d, pptr %d"
argument_list|,
name|icmp
operator|->
name|icmp_type
argument_list|,
name|icmp
operator|->
name|icmp_code
argument_list|,
name|icmp
operator|->
name|icmp_pptr
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
break|break;
default|default:
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Unsupported ICMP type %d, code %d"
argument_list|,
name|icmp
operator|->
name|icmp_type
argument_list|,
name|icmp
operator|->
name|icmp_code
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
end_switch

begin_comment
comment|/* 	 * For echo request/reply we can use original payload, 	 * but we need adjust icmp_cksum, because ICMPv6 cksum covers 	 * IPv6 pseudo header and ICMPv6 types differs from ICMPv4. 	 */
end_comment

begin_if
if|if
condition|(
name|type
operator|==
name|ICMP6_ECHO_REQUEST
operator|||
name|type
operator|==
name|ICMP6_ECHO_REPLY
condition|)
block|{
name|nat64_icmp_handle_echo
argument_list|(
name|ip6
argument_list|,
name|ICMP6
argument_list|(
name|icmp
argument_list|)
argument_list|,
name|icmpid
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_if

begin_comment
comment|/* 	 * For other types of ICMP messages we need to translate inner 	 * IPv4 header to IPv6 header. 	 * Assume ICMP src is the same as payload dst 	 * E.g. we have ( GWsrc1 , NATIP1 ) in outer header 	 * and          ( NATIP1, Hostdst1 ) in ICMP copy header. 	 * In that case, we already have map for NATIP1 and GWsrc1. 	 * The only thing we need is to copy IPv6 map prefix to 	 * Hostdst1. 	 */
end_comment

begin_expr_stmt
name|hlen
operator|=
name|offset
operator|+
name|ICMP_MINLEN
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|ICMP_MINLEN
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Message is too short %d"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
end_if

begin_expr_stmt
name|m_copydata
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ip
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ip
operator|.
name|ip_v
operator|!=
name|IPVERSION
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Wrong IP version %d"
argument_list|,
name|ip
operator|.
name|ip_v
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
end_if

begin_expr_stmt
name|hlen
operator|+=
name|ip
operator|.
name|ip_hl
operator|<<
literal|2
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Skip inner IP header */
end_comment

begin_if
if|if
condition|(
name|nat64_check_ip4
argument_list|(
name|ip
operator|.
name|ip_src
operator|.
name|s_addr
argument_list|)
operator|!=
literal|0
operator|||
name|nat64_check_ip4
argument_list|(
name|ip
operator|.
name|ip_dst
operator|.
name|s_addr
argument_list|)
operator|!=
literal|0
operator|||
name|nat64_check_private_ip4
argument_list|(
name|ip
operator|.
name|ip_src
operator|.
name|s_addr
argument_list|)
operator|!=
literal|0
operator|||
name|nat64_check_private_ip4
argument_list|(
name|ip
operator|.
name|ip_dst
operator|.
name|s_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"IP addresses checks failed %04x -> %04x"
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|.
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|.
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
end_if

begin_if
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|hlen
operator|+
name|ICMP_MINLEN
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Message is too short %d"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
end_if

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* 	 * Check that inner source matches the outer destination. 	 * XXX: We need some method to convert IPv4 into IPv6 address here, 	 *	and compare IPv6 addresses. 	 */
end_comment

begin_endif
unit|if (ip.ip_src.s_addr != nat64_get_ip4(&ip6->ip6_dst)) { 		DPRINTF(DP_GENERIC, "Inner source doesn't match destination ", 		    "%04x vs %04x", ip.ip_src.s_addr, 		    nat64_get_ip4(&ip6->ip6_dst)); 		goto freeit; 	}
endif|#
directive|endif
end_endif

begin_comment
comment|/* 	 * Create new mbuf for ICMPv6 datagram. 	 * NOTE: len is data length just after inner IP header. 	 */
end_comment

begin_expr_stmt
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|hlen
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
operator|+
name|len
operator|>
name|NAT64_ICMP6_PLEN
condition|)
name|len
operator|=
name|NAT64_ICMP6_PLEN
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|plen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|len
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|n
operator|=
name|m_get2
argument_list|(
name|offset
operator|+
name|plen
operator|+
name|max_hdr
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_HEADER
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|nomem
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|m_move_pkthdr
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|M_ALIGN
argument_list|(
name|n
argument_list|,
name|offset
operator|+
name|plen
operator|+
name|max_hdr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|n
operator|->
name|m_len
operator|=
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|offset
operator|+
name|plen
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Adjust ip6_plen in outer header */
end_comment

begin_expr_stmt
name|ip6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Construct new inner IPv6 header */
end_comment

begin_expr_stmt
name|eip6
operator|=
name|mtodo
argument_list|(
name|n
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|eip6
operator|->
name|ip6_src
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Use the fact that we have single /96 prefix for IPv4 map */
end_comment

begin_expr_stmt
name|eip6
operator|->
name|ip6_dst
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nat64_set_ip4
argument_list|(
operator|&
name|eip6
operator|->
name|ip6_dst
argument_list|,
name|ip
operator|.
name|ip_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|eip6
operator|->
name|ip6_flow
operator|=
name|htonl
argument_list|(
name|ip
operator|.
name|ip_tos
operator|<<
literal|20
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|eip6
operator|->
name|ip6_vfc
operator||=
name|IPV6_VERSION
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|eip6
operator|->
name|ip6_hlim
operator|=
name|ip
operator|.
name|ip_ttl
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|eip6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|ip
operator|.
name|ip_len
argument_list|)
operator|-
operator|(
name|ip
operator|.
name|ip_hl
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|eip6
operator|->
name|ip6_nxt
operator|=
operator|(
name|ip
operator|.
name|ip_p
operator|==
name|IPPROTO_ICMP
operator|)
condition|?
name|IPPROTO_ICMPV6
else|:
name|ip
operator|.
name|ip_p
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|m_copydata
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|,
name|len
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|eip6
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * We need to translate source port in the inner ULP header, 	 * and adjust ULP checksum. 	 */
end_comment

begin_switch
switch|switch
condition|(
name|ip
operator|.
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|len
operator|<
name|offsetof
argument_list|(
expr|struct
name|tcphdr
argument_list|,
name|th_sum
argument_list|)
condition|)
break|break;
name|tcp
operator|=
name|TCP
argument_list|(
name|eip6
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmpid
operator|!=
literal|0
condition|)
block|{
name|tcp
operator|->
name|th_sum
operator|=
name|cksum_adjust
argument_list|(
name|tcp
operator|->
name|th_sum
argument_list|,
name|tcp
operator|->
name|th_sport
argument_list|,
name|icmpid
argument_list|)
expr_stmt|;
name|tcp
operator|->
name|th_sport
operator|=
name|icmpid
expr_stmt|;
block|}
name|tcp
operator|->
name|th_sum
operator|=
name|cksum_add
argument_list|(
name|tcp
operator|->
name|th_sum
argument_list|,
operator|~
name|nat64_cksum_convert
argument_list|(
name|eip6
argument_list|,
operator|&
name|ip
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|len
operator|<
name|offsetof
argument_list|(
expr|struct
name|udphdr
argument_list|,
name|uh_sum
argument_list|)
condition|)
break|break;
name|udp
operator|=
name|UDP
argument_list|(
name|eip6
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmpid
operator|!=
literal|0
condition|)
block|{
name|udp
operator|->
name|uh_sum
operator|=
name|cksum_adjust
argument_list|(
name|udp
operator|->
name|uh_sum
argument_list|,
name|udp
operator|->
name|uh_sport
argument_list|,
name|icmpid
argument_list|)
expr_stmt|;
name|udp
operator|->
name|uh_sport
operator|=
name|icmpid
expr_stmt|;
block|}
name|udp
operator|->
name|uh_sum
operator|=
name|cksum_add
argument_list|(
name|udp
operator|->
name|uh_sum
argument_list|,
operator|~
name|nat64_cksum_convert
argument_list|(
name|eip6
argument_list|,
operator|&
name|ip
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
comment|/* 		 * Check if this is an ICMP error message for echo request 		 * that we sent. I.e. ULP in the data containing invoking 		 * packet is IPPROTO_ICMP and its type is ICMP_ECHO. 		 */
name|icmp
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
operator|(
name|eip6
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|icmp
operator|->
name|icmp_type
operator|!=
name|ICMP_ECHO
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
comment|/* 		 * For our client this original datagram should looks 		 * like it was ICMPv6 datagram with type ICMP6_ECHO_REQUEST. 		 * Thus we need adjust icmp_cksum and convert type from 		 * ICMP_ECHO to ICMP6_ECHO_REQUEST. 		 */
name|nat64_icmp_handle_echo
argument_list|(
name|eip6
argument_list|,
name|ICMP6
argument_list|(
name|icmp
argument_list|)
argument_list|,
name|icmpid
argument_list|,
name|ICMP6_ECHO_REQUEST
argument_list|)
expr_stmt|;
block|}
end_switch

begin_expr_stmt
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Convert ICMPv4 into ICMPv6 header */
end_comment

begin_expr_stmt
name|icmp
operator|=
name|mtodo
argument_list|(
name|n
argument_list|,
name|offset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ICMP6
argument_list|(
name|icmp
argument_list|)
operator|->
name|icmp6_type
operator|=
name|type
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ICMP6
argument_list|(
name|icmp
argument_list|)
operator|->
name|icmp6_code
operator|=
name|code
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ICMP6
argument_list|(
name|icmp
argument_list|)
operator|->
name|icmp6_mtu
operator|=
name|htonl
argument_list|(
name|mtu
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ICMP6
argument_list|(
name|icmp
argument_list|)
operator|->
name|icmp6_cksum
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ICMP6
argument_list|(
name|icmp
argument_list|)
operator|->
name|icmp6_cksum
operator|=
name|cksum_add
argument_list|(
operator|~
name|in6_cksum_pseudo
argument_list|(
name|ip6
argument_list|,
name|plen
argument_list|,
name|IPPROTO_ICMPV6
argument_list|,
literal|0
argument_list|)
argument_list|,
name|in_cksum_skip
argument_list|(
name|n
argument_list|,
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|n
operator|)
return|;
end_return

begin_label
name|freeit
label|:
end_label

begin_expr_stmt
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|NULL
operator|)
return|;
end_return

begin_macro
unit|}  int
name|nat64_getlasthdr
argument_list|(
argument|struct mbuf *m
argument_list|,
argument|int *offset
argument_list|)
end_macro

begin_block
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|ip6_hbh
modifier|*
name|hbh
decl_stmt|;
name|int
name|proto
decl_stmt|,
name|hlen
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
name|NULL
condition|)
name|hlen
operator|=
operator|*
name|offset
expr_stmt|;
else|else
name|hlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ip6
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
expr_stmt|;
name|proto
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
comment|/* Skip extension headers */
while|while
condition|(
name|proto
operator|==
name|IPPROTO_HOPOPTS
operator|||
name|proto
operator|==
name|IPPROTO_ROUTING
operator|||
name|proto
operator|==
name|IPPROTO_DSTOPTS
condition|)
block|{
name|hbh
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
comment|/* 		 * We expect mbuf has contigious data up to 		 * upper level header. 		 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hlen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * We doesn't support Jumbo payload option, 		 * so return error. 		 */
if|if
condition|(
name|proto
operator|==
name|IPPROTO_HOPOPTS
operator|&&
name|ip6
operator|->
name|ip6_plen
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|proto
operator|=
name|hbh
operator|->
name|ip6h_nxt
expr_stmt|;
name|hlen
operator|+=
name|hbh
operator|->
name|ip6h_len
operator|<<
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
name|NULL
condition|)
operator|*
name|offset
operator|=
name|hlen
expr_stmt|;
return|return
operator|(
name|proto
operator|)
return|;
block|}
end_block

begin_function
name|int
name|nat64_do_handle_ip4
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|saddr
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|daddr
parameter_list|,
name|uint16_t
name|lport
parameter_list|,
name|nat64_stats_block
modifier|*
name|stats
parameter_list|,
name|void
modifier|*
name|logdata
parameter_list|)
block|{
name|struct
name|route_in6
name|ro
decl_stmt|;
name|struct
name|ip6_hdr
name|ip6
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|mbufq
name|mq
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|uint32_t
name|mtu
decl_stmt|;
name|uint16_t
name|ip_id
decl_stmt|,
name|ip_off
decl_stmt|;
name|uint16_t
modifier|*
name|csum
decl_stmt|;
name|int
name|plen
decl_stmt|,
name|hlen
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|<=
name|IPTTLDEC
condition|)
block|{
name|nat64_icmp_reflect
argument_list|(
name|m
argument_list|,
name|ICMP_TIMXCEED
argument_list|,
name|ICMP_TIMXCEED_INTRANS
argument_list|,
literal|0
argument_list|,
name|stats
argument_list|,
name|logdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64RETURN
operator|)
return|;
block|}
name|ip6
operator|.
name|ip6_dst
operator|=
operator|*
name|daddr
expr_stmt|;
name|ip6
operator|.
name|ip6_src
operator|=
operator|*
name|saddr
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|-
name|hlen
expr_stmt|;
name|proto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
comment|/* Save ip_id and ip_off, both are in network byte order */
name|ip_id
operator|=
name|ip
operator|->
name|ip_id
expr_stmt|;
name|ip_off
operator|=
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_OFFMASK
operator||
name|IP_MF
argument_list|)
expr_stmt|;
comment|/* Fragment length must be multiple of 8 octets */
if|if
condition|(
operator|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_MF
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|plen
operator|&
literal|0x7
operator|)
operator|!=
literal|0
condition|)
block|{
name|nat64_icmp_reflect
argument_list|(
name|m
argument_list|,
name|ICMP_PARAMPROB
argument_list|,
name|ICMP_PARAMPROB_LENGTH
argument_list|,
literal|0
argument_list|,
name|stats
argument_list|,
name|logdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64RETURN
operator|)
return|;
block|}
comment|/* Fragmented ICMP is unsupported */
if|if
condition|(
name|proto
operator|==
name|IPPROTO_ICMP
operator|&&
name|ip_off
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"dropped due to fragmented ICMP"
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64MFREE
operator|)
return|;
block|}
name|dst
operator|=
name|nat64_find_route6
argument_list|(
operator|&
name|ro
argument_list|,
operator|&
name|ip6
operator|.
name|ip6_dst
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
name|FREE_ROUTE
argument_list|(
operator|&
name|ro
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|noroute6
argument_list|)
expr_stmt|;
name|nat64_icmp_reflect
argument_list|(
name|m
argument_list|,
name|ICMP_UNREACH
argument_list|,
name|ICMP_UNREACH_HOST
argument_list|,
literal|0
argument_list|,
name|stats
argument_list|,
name|logdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64RETURN
operator|)
return|;
block|}
name|ifp
operator|=
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
if|if
condition|(
name|ro
operator|.
name|ro_rt
operator|->
name|rt_mtu
operator|!=
literal|0
condition|)
name|mtu
operator|=
name|min
argument_list|(
name|ro
operator|.
name|ro_rt
operator|->
name|rt_mtu
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
else|else
name|mtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
if|if
condition|(
name|mtu
operator|<
name|plen
operator|+
sizeof|sizeof
argument_list|(
name|ip6
argument_list|)
operator|&&
operator|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_DF
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|FREE_ROUTE
argument_list|(
operator|&
name|ro
argument_list|)
expr_stmt|;
name|nat64_icmp_reflect
argument_list|(
name|m
argument_list|,
name|ICMP_UNREACH
argument_list|,
name|ICMP_UNREACH_NEEDFRAG
argument_list|,
name|FRAGSZ
argument_list|(
name|mtu
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|,
name|stats
argument_list|,
name|logdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64RETURN
operator|)
return|;
block|}
name|ip6
operator|.
name|ip6_flow
operator|=
name|htonl
argument_list|(
name|ip
operator|->
name|ip_tos
operator|<<
literal|20
argument_list|)
expr_stmt|;
name|ip6
operator|.
name|ip6_vfc
operator||=
name|IPV6_VERSION
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFIREWALL_NAT64_DIRECT_OUTPUT
name|ip6
operator|.
name|ip6_hlim
operator|=
name|ip
operator|->
name|ip_ttl
operator|-
name|IPTTLDEC
expr_stmt|;
else|#
directive|else
comment|/* Forwarding code will decrement HLIM. */
name|ip6
operator|.
name|ip6_hlim
operator|=
name|ip
operator|->
name|ip_ttl
expr_stmt|;
endif|#
directive|endif
name|ip6
operator|.
name|ip6_plen
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
name|ip6
operator|.
name|ip6_nxt
operator|=
operator|(
name|proto
operator|==
name|IPPROTO_ICMP
operator|)
condition|?
name|IPPROTO_ICMPV6
else|:
name|proto
expr_stmt|;
comment|/* Convert checksums. */
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|csum
operator|=
operator|&
name|TCP
argument_list|(
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
argument_list|)
operator|->
name|th_sum
expr_stmt|;
if|if
condition|(
name|lport
operator|!=
literal|0
condition|)
block|{
name|struct
name|tcphdr
modifier|*
name|tcp
init|=
name|TCP
argument_list|(
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|csum
operator|=
name|cksum_adjust
argument_list|(
operator|*
name|csum
argument_list|,
name|tcp
operator|->
name|th_dport
argument_list|,
name|lport
argument_list|)
expr_stmt|;
name|tcp
operator|->
name|th_dport
operator|=
name|lport
expr_stmt|;
block|}
operator|*
name|csum
operator|=
name|cksum_add
argument_list|(
operator|*
name|csum
argument_list|,
operator|~
name|nat64_cksum_convert
argument_list|(
operator|&
name|ip6
argument_list|,
name|ip
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|csum
operator|=
operator|&
name|UDP
argument_list|(
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
argument_list|)
operator|->
name|uh_sum
expr_stmt|;
if|if
condition|(
name|lport
operator|!=
literal|0
condition|)
block|{
name|struct
name|udphdr
modifier|*
name|udp
init|=
name|UDP
argument_list|(
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|csum
operator|=
name|cksum_adjust
argument_list|(
operator|*
name|csum
argument_list|,
name|udp
operator|->
name|uh_dport
argument_list|,
name|lport
argument_list|)
expr_stmt|;
name|udp
operator|->
name|uh_dport
operator|=
name|lport
expr_stmt|;
block|}
operator|*
name|csum
operator|=
name|cksum_add
argument_list|(
operator|*
name|csum
argument_list|,
operator|~
name|nat64_cksum_convert
argument_list|(
operator|&
name|ip6
argument_list|,
name|ip
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|m
operator|=
name|nat64_icmp_translate
argument_list|(
name|m
argument_list|,
operator|&
name|ip6
argument_list|,
name|lport
argument_list|,
name|hlen
argument_list|,
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|FREE_ROUTE
argument_list|(
operator|&
name|ro
argument_list|)
expr_stmt|;
comment|/* stats already accounted */
return|return
operator|(
name|NAT64RETURN
operator|)
return|;
block|}
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|mq
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|nat64_fragment6
argument_list|(
name|stats
argument_list|,
operator|&
name|ip6
argument_list|,
operator|&
name|mq
argument_list|,
name|m
argument_list|,
name|mtu
argument_list|,
name|ip_id
argument_list|,
name|ip_off
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|mq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nat64_output
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
operator|(
expr|struct
name|route
operator|*
operator|)
operator|&
name|ro
argument_list|,
name|stats
argument_list|,
name|logdata
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|opcnt46
argument_list|)
expr_stmt|;
block|}
name|mbufq_drain
argument_list|(
operator|&
name|mq
argument_list|)
expr_stmt|;
name|FREE_ROUTE
argument_list|(
operator|&
name|ro
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64RETURN
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nat64_handle_icmp6
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|hlen
parameter_list|,
name|uint32_t
name|aaddr
parameter_list|,
name|uint16_t
name|aport
parameter_list|,
name|nat64_stats_block
modifier|*
name|stats
parameter_list|,
name|void
modifier|*
name|logdata
parameter_list|)
block|{
name|struct
name|ip
name|ip
decl_stmt|;
name|struct
name|icmp6_hdr
modifier|*
name|icmp6
decl_stmt|;
name|struct
name|ip6_frag
modifier|*
name|ip6f
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|,
modifier|*
name|ip6i
decl_stmt|;
name|uint32_t
name|mtu
decl_stmt|;
name|int
name|plen
decl_stmt|,
name|proto
decl_stmt|;
name|uint8_t
name|type
decl_stmt|,
name|code
decl_stmt|;
if|if
condition|(
name|hlen
operator|==
literal|0
condition|)
block|{
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|nat64_check_ip6
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|!=
literal|0
operator|||
name|nat64_check_ip6
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NAT64SKIP
operator|)
return|;
name|proto
operator|=
name|nat64_getlasthdr
argument_list|(
name|m
argument_list|,
operator|&
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|!=
name|IPPROTO_ICMPV6
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"dropped due to mbuf isn't contigious"
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64MFREE
operator|)
return|;
block|}
block|}
comment|/* 	 * Translate ICMPv6 type and code to ICMPv4 (RFC7915). 	 * NOTE: ICMPv6 echo handled by nat64_do_handle_ip6(). 	 */
name|icmp6
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|mtu
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|icmp6
operator|->
name|icmp6_type
condition|)
block|{
case|case
name|ICMP6_DST_UNREACH
case|:
name|type
operator|=
name|ICMP_UNREACH
expr_stmt|;
switch|switch
condition|(
name|icmp6
operator|->
name|icmp6_code
condition|)
block|{
case|case
name|ICMP6_DST_UNREACH_NOROUTE
case|:
case|case
name|ICMP6_DST_UNREACH_BEYONDSCOPE
case|:
case|case
name|ICMP6_DST_UNREACH_ADDR
case|:
name|code
operator|=
name|ICMP_UNREACH_HOST
expr_stmt|;
break|break;
case|case
name|ICMP6_DST_UNREACH_ADMIN
case|:
name|code
operator|=
name|ICMP_UNREACH_HOST_PROHIB
expr_stmt|;
break|break;
case|case
name|ICMP6_DST_UNREACH_NOPORT
case|:
name|code
operator|=
name|ICMP_UNREACH_PORT
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Unsupported ICMPv6 type %d,"
literal|" code %d"
argument_list|,
name|icmp6
operator|->
name|icmp6_type
argument_list|,
name|icmp6
operator|->
name|icmp6_code
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64MFREE
operator|)
return|;
block|}
break|break;
case|case
name|ICMP6_PACKET_TOO_BIG
case|:
name|type
operator|=
name|ICMP_UNREACH
expr_stmt|;
name|code
operator|=
name|ICMP_UNREACH_NEEDFRAG
expr_stmt|;
name|mtu
operator|=
name|ntohl
argument_list|(
name|icmp6
operator|->
name|icmp6_mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu
operator|<
name|IPV6_MMTU
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Wrong MTU %d in ICMPv6 type %d,"
literal|" code %d"
argument_list|,
name|mtu
argument_list|,
name|icmp6
operator|->
name|icmp6_type
argument_list|,
name|icmp6
operator|->
name|icmp6_code
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64MFREE
operator|)
return|;
block|}
comment|/* 		 * Adjust MTU to reflect difference between 		 * IPv6 an IPv4 headers. 		 */
name|mtu
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP6_TIME_EXCEEDED
case|:
name|type
operator|=
name|ICMP_TIMXCEED
expr_stmt|;
name|code
operator|=
name|icmp6
operator|->
name|icmp6_code
expr_stmt|;
break|break;
case|case
name|ICMP6_PARAM_PROB
case|:
switch|switch
condition|(
name|icmp6
operator|->
name|icmp6_code
condition|)
block|{
case|case
name|ICMP6_PARAMPROB_HEADER
case|:
name|type
operator|=
name|ICMP_PARAMPROB
expr_stmt|;
name|code
operator|=
name|ICMP_PARAMPROB_ERRATPTR
expr_stmt|;
name|mtu
operator|=
name|ntohl
argument_list|(
name|icmp6
operator|->
name|icmp6_pptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mtu
condition|)
block|{
case|case
literal|0
case|:
comment|/* Version/Traffic Class */
case|case
literal|1
case|:
comment|/* Traffic Class/Flow Label */
break|break;
case|case
literal|4
case|:
comment|/* Payload Length */
case|case
literal|5
case|:
name|mtu
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* Next Header */
name|mtu
operator|=
literal|9
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* Hop Limit */
name|mtu
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|mtu
operator|>=
literal|8
operator|&&
name|mtu
operator|<=
literal|23
condition|)
block|{
name|mtu
operator|=
literal|12
expr_stmt|;
comment|/* Source address */
break|break;
block|}
if|if
condition|(
name|mtu
operator|>=
literal|24
operator|&&
name|mtu
operator|<=
literal|39
condition|)
block|{
name|mtu
operator|=
literal|16
expr_stmt|;
comment|/* Destination address */
break|break;
block|}
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Unsupported ICMPv6 type %d,"
literal|" code %d, pptr %d"
argument_list|,
name|icmp6
operator|->
name|icmp6_type
argument_list|,
name|icmp6
operator|->
name|icmp6_code
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64MFREE
operator|)
return|;
block|}
case|case
name|ICMP6_PARAMPROB_NEXTHEADER
case|:
name|type
operator|=
name|ICMP_UNREACH
expr_stmt|;
name|code
operator|=
name|ICMP_UNREACH_PROTOCOL
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Unsupported ICMPv6 type %d,"
literal|" code %d, pptr %d"
argument_list|,
name|icmp6
operator|->
name|icmp6_type
argument_list|,
name|icmp6
operator|->
name|icmp6_code
argument_list|,
name|ntohl
argument_list|(
name|icmp6
operator|->
name|icmp6_pptr
argument_list|)
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64MFREE
operator|)
return|;
block|}
break|break;
default|default:
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Unsupported ICMPv6 type %d, code %d"
argument_list|,
name|icmp6
operator|->
name|icmp6_type
argument_list|,
name|icmp6
operator|->
name|icmp6_code
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64MFREE
operator|)
return|;
block|}
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|ICMP_MINLEN
condition|)
block|{
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Message is too short %d"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64MFREE
operator|)
return|;
block|}
comment|/* 	 * We need at least ICMP_MINLEN bytes of original datagram payload 	 * to generate ICMP message. It is nice that ICMP_MINLEN is equal 	 * to sizeof(struct ip6_frag). So, if embedded datagram had a fragment 	 * header we will not have to do m_pullup() again. 	 * 	 * What we have here: 	 * Outer header: (IPv6iGW, v4mapPRefix+v4exthost) 	 * Inner header: (v4mapPRefix+v4host, IPv6iHost) [sport, dport] 	 * We need to translate it to: 	 * 	 * Outer header: (alias_host, v4exthost) 	 * Inner header: (v4exthost, alias_host) [sport, alias_port] 	 * 	 * Assume caller function has checked if v4mapPRefix+v4host 	 * matches configured prefix. 	 * The only two things we should be provided with are mapping between 	 * IPv6iHost<> alias_host and between dport and alias_port. 	 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|ICMP_MINLEN
condition|)
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|ICMP_MINLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|nomem
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64RETURN
operator|)
return|;
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|ip6i
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|ip6f
operator|=
name|NULL
expr_stmt|;
name|proto
operator|=
name|ip6i
operator|->
name|ip6_nxt
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|ip6i
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|==
name|IPPROTO_FRAGMENT
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
operator|+
name|ICMP_MINLEN
condition|)
goto|goto
name|fail
goto|;
name|ip6f
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|proto
operator|=
name|ip6f
operator|->
name|ip6f_nxt
expr_stmt|;
name|plen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
comment|/* Ajust MTU to reflect frag header size */
if|if
condition|(
name|type
operator|==
name|ICMP_UNREACH
operator|&&
name|code
operator|==
name|ICMP_UNREACH_NEEDFRAG
condition|)
name|mtu
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proto
operator|!=
name|IPPROTO_TCP
operator|&&
name|proto
operator|!=
name|IPPROTO_UDP
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Unsupported proto %d in the inner header"
argument_list|,
name|proto
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|nat64_check_ip6
argument_list|(
operator|&
name|ip6i
operator|->
name|ip6_src
argument_list|)
operator|!=
literal|0
operator|||
name|nat64_check_ip6
argument_list|(
operator|&
name|ip6i
operator|->
name|ip6_dst
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Inner addresses do not passes the check"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Check if outer dst is the same as inner src */
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
operator|&
name|ip6i
operator|->
name|ip6_src
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"Inner src doesn't match outer dst"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Now we need to make a fake IPv4 packet to generate ICMP message */
name|ip
operator|.
name|ip_dst
operator|.
name|s_addr
operator|=
name|aaddr
expr_stmt|;
name|ip
operator|.
name|ip_src
operator|.
name|s_addr
operator|=
name|nat64_get_ip4
argument_list|(
operator|&
name|ip6i
operator|->
name|ip6_src
argument_list|)
expr_stmt|;
comment|/* XXX: Make fake ulp header */
ifdef|#
directive|ifdef
name|IPFIREWALL_NAT64_DIRECT_OUTPUT
name|ip6i
operator|->
name|ip6_hlim
operator|+=
name|IPV6_HLIMDEC
expr_stmt|;
comment|/* init_ip4hdr will decrement it */
endif|#
directive|endif
name|nat64_init_ip4hdr
argument_list|(
name|ip6i
argument_list|,
name|ip6f
argument_list|,
name|plen
argument_list|,
name|proto
argument_list|,
operator|&
name|ip
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|hlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ip
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|nat64_icmp_reflect
argument_list|(
name|m
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
operator|(
name|uint16_t
operator|)
name|mtu
argument_list|,
name|stats
argument_list|,
name|logdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64RETURN
operator|)
return|;
name|fail
label|:
comment|/* 	 * We must call m_freem() because mbuf pointer could be 	 * changed with m_pullup(). 	 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64RETURN
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nat64_do_handle_ip6
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|aaddr
parameter_list|,
name|uint16_t
name|aport
parameter_list|,
name|nat64_stats_block
modifier|*
name|stats
parameter_list|,
name|void
modifier|*
name|logdata
parameter_list|)
block|{
name|struct
name|route
name|ro
decl_stmt|;
name|struct
name|ip
name|ip
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ip6_frag
modifier|*
name|frag
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|icmp6_hdr
modifier|*
name|icmp6
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|uint16_t
modifier|*
name|csum
decl_stmt|;
name|uint32_t
name|mtu
decl_stmt|;
name|int
name|plen
decl_stmt|,
name|hlen
decl_stmt|,
name|proto
decl_stmt|;
comment|/* 	 * XXX: we expect ipfw_chk() did m_pullup() up to upper level 	 * protocol's headers. Also we skip some checks, that ip6_input(), 	 * ip6_forward(), ip6_fastfwd() and ipfw_chk() already did. 	 */
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|nat64_check_ip6
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|!=
literal|0
operator|||
name|nat64_check_ip6
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|NAT64SKIP
operator|)
return|;
block|}
comment|/* Starting from this point we must not return zero */
name|ip
operator|.
name|ip_src
operator|.
name|s_addr
operator|=
name|aaddr
expr_stmt|;
if|if
condition|(
name|nat64_check_ip4
argument_list|(
name|ip
operator|.
name|ip_src
operator|.
name|s_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_GENERIC
argument_list|,
literal|"invalid source address: %08x"
argument_list|,
name|ip
operator|.
name|ip_src
operator|.
name|s_addr
argument_list|)
expr_stmt|;
comment|/* XXX: stats? */
return|return
operator|(
name|NAT64MFREE
operator|)
return|;
block|}
name|ip
operator|.
name|ip_dst
operator|.
name|s_addr
operator|=
name|nat64_get_ip4
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|.
name|ip_dst
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* XXX: stats? */
return|return
operator|(
name|NAT64MFREE
operator|)
return|;
block|}
if|if
condition|(
name|ip6
operator|->
name|ip6_hlim
operator|<=
name|IPV6_HLIMDEC
condition|)
block|{
name|nat64_icmp6_reflect
argument_list|(
name|m
argument_list|,
name|ICMP6_TIME_EXCEEDED
argument_list|,
name|ICMP6_TIME_EXCEED_TRANSIT
argument_list|,
literal|0
argument_list|,
name|stats
argument_list|,
name|logdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64RETURN
operator|)
return|;
block|}
name|hlen
operator|=
literal|0
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
name|proto
operator|=
name|nat64_getlasthdr
argument_list|(
name|m
argument_list|,
operator|&
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|<
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"dropped due to mbuf isn't contigious"
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64MFREE
operator|)
return|;
block|}
name|frag
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|proto
operator|==
name|IPPROTO_FRAGMENT
condition|)
block|{
comment|/* ipfw_chk should m_pullup up to frag header */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|frag
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"dropped due to mbuf isn't contigious"
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64MFREE
operator|)
return|;
block|}
name|frag
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|proto
operator|=
name|frag
operator|->
name|ip6f_nxt
expr_stmt|;
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|frag
argument_list|)
expr_stmt|;
comment|/* Fragmented ICMPv6 is unsupported */
if|if
condition|(
name|proto
operator|==
name|IPPROTO_ICMPV6
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"dropped due to fragmented ICMPv6"
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64MFREE
operator|)
return|;
block|}
comment|/* Fragment length must be multiple of 8 octets */
if|if
condition|(
operator|(
name|frag
operator|->
name|ip6f_offlg
operator|&
name|IP6F_MORE_FRAG
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|plen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|-
name|hlen
operator|)
operator|&
literal|0x7
operator|)
operator|!=
literal|0
condition|)
block|{
name|nat64_icmp6_reflect
argument_list|(
name|m
argument_list|,
name|ICMP6_PARAM_PROB
argument_list|,
name|ICMP6_PARAMPROB_HEADER
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|,
name|ip6_plen
argument_list|)
argument_list|,
name|stats
argument_list|,
name|logdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64RETURN
operator|)
return|;
block|}
block|}
name|plen
operator|-=
name|hlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|<
literal|0
operator|||
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|plen
operator|+
name|hlen
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"plen %d, pkthdr.len %d, hlen %d"
argument_list|,
name|plen
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64MFREE
operator|)
return|;
block|}
name|icmp6
operator|=
name|NULL
expr_stmt|;
comment|/* Make gcc happy */
if|if
condition|(
name|proto
operator|==
name|IPPROTO_ICMPV6
condition|)
block|{
name|icmp6
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmp6
operator|->
name|icmp6_type
operator|!=
name|ICMP6_ECHO_REQUEST
operator|&&
name|icmp6
operator|->
name|icmp6_type
operator|!=
name|ICMP6_ECHO_REPLY
condition|)
return|return
operator|(
name|nat64_handle_icmp6
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|,
name|aaddr
argument_list|,
name|aport
argument_list|,
name|stats
argument_list|,
name|logdata
argument_list|)
operator|)
return|;
block|}
name|dst
operator|=
name|nat64_find_route4
argument_list|(
operator|&
name|ro
argument_list|,
name|ip
operator|.
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
name|FREE_ROUTE
argument_list|(
operator|&
name|ro
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|noroute4
argument_list|)
expr_stmt|;
name|nat64_icmp6_reflect
argument_list|(
name|m
argument_list|,
name|ICMP6_DST_UNREACH
argument_list|,
name|ICMP6_DST_UNREACH_NOROUTE
argument_list|,
literal|0
argument_list|,
name|stats
argument_list|,
name|logdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64RETURN
operator|)
return|;
block|}
name|ifp
operator|=
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
if|if
condition|(
name|ro
operator|.
name|ro_rt
operator|->
name|rt_mtu
operator|!=
literal|0
condition|)
name|mtu
operator|=
name|min
argument_list|(
name|ro
operator|.
name|ro_rt
operator|->
name|rt_mtu
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
else|else
name|mtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
if|if
condition|(
name|mtu
operator|<
name|plen
operator|+
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|FREE_ROUTE
argument_list|(
operator|&
name|ro
argument_list|)
expr_stmt|;
name|nat64_icmp6_reflect
argument_list|(
name|m
argument_list|,
name|ICMP6_PACKET_TOO_BIG
argument_list|,
literal|0
argument_list|,
name|mtu
argument_list|,
name|stats
argument_list|,
name|logdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64RETURN
operator|)
return|;
block|}
name|nat64_init_ip4hdr
argument_list|(
name|ip6
argument_list|,
name|frag
argument_list|,
name|plen
argument_list|,
name|proto
argument_list|,
operator|&
name|ip
argument_list|)
expr_stmt|;
comment|/* Convert checksums. */
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|csum
operator|=
operator|&
name|TCP
argument_list|(
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
argument_list|)
operator|->
name|th_sum
expr_stmt|;
if|if
condition|(
name|aport
operator|!=
literal|0
condition|)
block|{
name|struct
name|tcphdr
modifier|*
name|tcp
init|=
name|TCP
argument_list|(
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|csum
operator|=
name|cksum_adjust
argument_list|(
operator|*
name|csum
argument_list|,
name|tcp
operator|->
name|th_sport
argument_list|,
name|aport
argument_list|)
expr_stmt|;
name|tcp
operator|->
name|th_sport
operator|=
name|aport
expr_stmt|;
block|}
operator|*
name|csum
operator|=
name|cksum_add
argument_list|(
operator|*
name|csum
argument_list|,
name|nat64_cksum_convert
argument_list|(
name|ip6
argument_list|,
operator|&
name|ip
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|csum
operator|=
operator|&
name|UDP
argument_list|(
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
argument_list|)
operator|->
name|uh_sum
expr_stmt|;
if|if
condition|(
name|aport
operator|!=
literal|0
condition|)
block|{
name|struct
name|udphdr
modifier|*
name|udp
init|=
name|UDP
argument_list|(
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|csum
operator|=
name|cksum_adjust
argument_list|(
operator|*
name|csum
argument_list|,
name|udp
operator|->
name|uh_sport
argument_list|,
name|aport
argument_list|)
expr_stmt|;
name|udp
operator|->
name|uh_sport
operator|=
name|aport
expr_stmt|;
block|}
operator|*
name|csum
operator|=
name|cksum_add
argument_list|(
operator|*
name|csum
argument_list|,
name|nat64_cksum_convert
argument_list|(
name|ip6
argument_list|,
operator|&
name|ip
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMPV6
case|:
comment|/* Checksum in ICMPv6 covers pseudo header */
name|csum
operator|=
operator|&
name|icmp6
operator|->
name|icmp6_cksum
expr_stmt|;
operator|*
name|csum
operator|=
name|cksum_add
argument_list|(
operator|*
name|csum
argument_list|,
name|in6_cksum_pseudo
argument_list|(
name|ip6
argument_list|,
name|plen
argument_list|,
name|IPPROTO_ICMPV6
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert ICMPv6 types to ICMP */
name|mtu
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|icmp6
expr_stmt|;
comment|/* save old word for cksum_adjust */
if|if
condition|(
name|icmp6
operator|->
name|icmp6_type
operator|==
name|ICMP6_ECHO_REQUEST
condition|)
name|icmp6
operator|->
name|icmp6_type
operator|=
name|ICMP_ECHO
expr_stmt|;
else|else
comment|/* ICMP6_ECHO_REPLY */
name|icmp6
operator|->
name|icmp6_type
operator|=
name|ICMP_ECHOREPLY
expr_stmt|;
operator|*
name|csum
operator|=
name|cksum_adjust
argument_list|(
operator|*
name|csum
argument_list|,
operator|(
name|uint16_t
operator|)
name|mtu
argument_list|,
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|icmp6
argument_list|)
expr_stmt|;
if|if
condition|(
name|aport
operator|!=
literal|0
condition|)
block|{
name|uint16_t
name|old_id
init|=
name|icmp6
operator|->
name|icmp6_id
decl_stmt|;
name|icmp6
operator|->
name|icmp6_id
operator|=
name|aport
expr_stmt|;
operator|*
name|csum
operator|=
name|cksum_adjust
argument_list|(
operator|*
name|csum
argument_list|,
name|old_id
argument_list|,
name|aport
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
empty_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|hlen
operator|-
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ip
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nat64_output
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
operator|&
name|ro
argument_list|,
name|stats
argument_list|,
name|logdata
argument_list|)
operator|==
literal|0
condition|)
name|NAT64STAT_INC
argument_list|(
name|stats
argument_list|,
name|opcnt64
argument_list|)
expr_stmt|;
name|FREE_ROUTE
argument_list|(
operator|&
name|ro
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAT64RETURN
operator|)
return|;
block|}
end_function

end_unit

