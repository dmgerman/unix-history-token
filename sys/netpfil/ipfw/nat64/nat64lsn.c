begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Yandex LLC  * Copyright (c) 2015 Alexander V. Chernikov<melifaro@FreeBSD.org>  * Copyright (c) 2016 Andrey V. Elsukov<ae@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/counter.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rmlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_pflog.h>
end_include

begin_include
include|#
directive|include
file|<net/pfil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip_fw_nat64.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/ip_fw_private.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/nat64/ip_fw_nat64.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/nat64/nat64lsn.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/nat64/nat64_translate.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/pf/pf.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NAT64LSN
argument_list|,
literal|"NAT64LSN"
argument_list|,
literal|"NAT64LSN"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|nat64lsn_periodic
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|PERIODIC_DELAY
value|4
end_define

begin_decl_stmt
specifier|static
name|uint8_t
name|nat64lsn_proto_map
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint8_t
name|nat64lsn_rproto_map
index|[
name|NAT_MAX_PROTO
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NAT64_FLAG_FIN
value|0x01
end_define

begin_comment
comment|/* FIN was seen */
end_comment

begin_define
define|#
directive|define
name|NAT64_FLAG_SYN
value|0x02
end_define

begin_comment
comment|/* First syn in->out */
end_comment

begin_define
define|#
directive|define
name|NAT64_FLAG_ESTAB
value|0x04
end_define

begin_comment
comment|/* Packet with Ack */
end_comment

begin_define
define|#
directive|define
name|NAT64_FLAGS_TCP
value|(NAT64_FLAG_SYN|NAT64_FLAG_ESTAB|NAT64_FLAG_FIN)
end_define

begin_define
define|#
directive|define
name|NAT64_FLAG_RDR
value|0x80
end_define

begin_comment
comment|/* Port redirect */
end_comment

begin_define
define|#
directive|define
name|NAT64_LOOKUP
parameter_list|(
name|chain
parameter_list|,
name|cmd
parameter_list|)
define|\
value|(struct nat64lsn_cfg *)SRV_OBJECT((chain), (cmd)->arg1)
end_define

begin_comment
comment|/*  * Delayed job queue, used to create new hosts  * and new portgroups  */
end_comment

begin_enum
enum|enum
name|nat64lsn_jtype
block|{
name|JTYPE_NEWHOST
init|=
literal|1
block|,
name|JTYPE_NEWPORTGROUP
block|,
name|JTYPE_DELPORTGROUP
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|nat64lsn_job_item
block|{
name|TAILQ_ENTRY
argument_list|(
argument|nat64lsn_job_item
argument_list|)
name|next
expr_stmt|;
name|enum
name|nat64lsn_jtype
name|jtype
decl_stmt|;
name|struct
name|nat64lsn_host
modifier|*
name|nh
decl_stmt|;
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
decl_stmt|;
name|void
modifier|*
name|spare_idx
decl_stmt|;
name|struct
name|in6_addr
name|haddr
decl_stmt|;
name|uint8_t
name|nat_proto
decl_stmt|;
name|uint8_t
name|done
decl_stmt|;
name|int
name|needs_idx
decl_stmt|;
name|int
name|delcount
decl_stmt|;
name|unsigned
name|int
name|fhash
decl_stmt|;
comment|/* Flow hash */
name|uint32_t
name|aaddr
decl_stmt|;
comment|/* Last used address (net) */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ipfw_flow_id
name|f_id
decl_stmt|;
name|uint64_t
name|delmask
index|[
name|NAT64LSN_PGPTRNMASK
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|jmtx
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|JQUEUE_LOCK_INIT
parameter_list|()
value|mtx_init(&jmtx, "qlock", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|JQUEUE_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&jmtx)
end_define

begin_define
define|#
directive|define
name|JQUEUE_LOCK
parameter_list|()
value|mtx_lock(&jmtx)
end_define

begin_define
define|#
directive|define
name|JQUEUE_UNLOCK
parameter_list|()
value|mtx_unlock(&jmtx)
end_define

begin_function_decl
specifier|static
name|void
name|nat64lsn_enqueue_job
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nat64lsn_enqueue_jobs
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_job_head
modifier|*
name|jhead
parameter_list|,
name|int
name|jlen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|nat64lsn_job_item
modifier|*
name|nat64lsn_create_job
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|ipfw_flow_id
modifier|*
name|f_id
parameter_list|,
name|int
name|jtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nat64lsn_request_portgroup
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|ipfw_flow_id
modifier|*
name|f_id
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|,
name|uint32_t
name|aaddr
parameter_list|,
name|int
name|needs_idx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nat64lsn_request_host
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|ipfw_flow_id
modifier|*
name|f_id
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nat64lsn_translate4
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|ipfw_flow_id
modifier|*
name|f_id
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nat64lsn_translate6
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|ipfw_flow_id
modifier|*
name|f_id
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_portgroup
parameter_list|(
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_portgroup
parameter_list|(
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_host6
parameter_list|(
name|struct
name|nat64lsn_host
modifier|*
name|nh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_host6
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|attach_portgroup
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|attach_host6
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* XXX tmp */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|nat64lsn_host_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|nat64lsn_pg_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|nat64lsn_pgidx_zone
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|unsigned
name|int
name|nat64lsn_periodic_chkstates
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_host
modifier|*
name|nh
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|I6_hash
parameter_list|(
name|x
parameter_list|)
value|(djb_hash((const unsigned char *)(x), 16))
end_define

begin_define
define|#
directive|define
name|I6_first
parameter_list|(
name|_ph
parameter_list|,
name|h
parameter_list|)
value|(_ph)[h]
end_define

begin_define
define|#
directive|define
name|I6_next
parameter_list|(
name|x
parameter_list|)
value|(x)->next
end_define

begin_define
define|#
directive|define
name|I6_val
parameter_list|(
name|x
parameter_list|)
value|(&(x)->addr)
end_define

begin_define
define|#
directive|define
name|I6_cmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|IN6_ARE_ADDR_EQUAL(a, b)
end_define

begin_define
define|#
directive|define
name|I6_lock
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_define
define|#
directive|define
name|I6_unlock
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_define
define|#
directive|define
name|I6HASH_FIND
parameter_list|(
name|_cfg
parameter_list|,
name|_res
parameter_list|,
name|_a
parameter_list|)
define|\
value|CHT_FIND(_cfg->ih, _cfg->ihsize, I6_, _res, _a)
end_define

begin_define
define|#
directive|define
name|I6HASH_INSERT
parameter_list|(
name|_cfg
parameter_list|,
name|_i
parameter_list|)
define|\
value|CHT_INSERT_HEAD(_cfg->ih, _cfg->ihsize, I6_, _i)
end_define

begin_define
define|#
directive|define
name|I6HASH_REMOVE
parameter_list|(
name|_cfg
parameter_list|,
name|_res
parameter_list|,
name|_tmp
parameter_list|,
name|_a
parameter_list|)
define|\
value|CHT_REMOVE(_cfg->ih, _cfg->ihsize, I6_, _res, _tmp, _a)
end_define

begin_define
define|#
directive|define
name|I6HASH_FOREACH_SAFE
parameter_list|(
name|_cfg
parameter_list|,
name|_x
parameter_list|,
name|_tmp
parameter_list|,
name|_cb
parameter_list|,
name|_arg
parameter_list|)
define|\
value|CHT_FOREACH_SAFE(_cfg->ih, _cfg->ihsize, I6_, _x, _tmp, _cb, _arg)
end_define

begin_define
define|#
directive|define
name|HASH_IN4
parameter_list|(
name|x
parameter_list|)
value|djb_hash((const unsigned char *)(x), 8)
end_define

begin_function
specifier|static
name|unsigned
name|djb_hash
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|h
parameter_list|,
specifier|const
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|result
operator|=
literal|33
operator|*
name|result
operator|^
name|h
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* static size_t  bitmask_size(size_t num, int *level) { 	size_t x; 	int c;  	for (c = 0, x = num; num> 1; num /= 64, c++) 		;  	return (x); }  static void bitmask_prepare(uint64_t *pmask, size_t bufsize, int level) { 	size_t x, z;  	memset(pmask, 0xFF, bufsize); 	for (x = 0, z = 1; level> 1; x += z, z *= 64, level--) 		; 	pmask[x] ~= 0x01; } */
end_comment

begin_function
specifier|static
name|void
name|nat64lsn_log
parameter_list|(
name|struct
name|pfloghdr
modifier|*
name|plog
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|sa_family_t
name|family
parameter_list|,
name|uint32_t
name|n
parameter_list|,
name|uint32_t
name|sn
parameter_list|)
block|{
name|memset
argument_list|(
name|plog
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|plog
argument_list|)
argument_list|)
expr_stmt|;
name|plog
operator|->
name|length
operator|=
name|PFLOG_REAL_HDRLEN
expr_stmt|;
name|plog
operator|->
name|af
operator|=
name|family
expr_stmt|;
name|plog
operator|->
name|action
operator|=
name|PF_NAT
expr_stmt|;
name|plog
operator|->
name|dir
operator|=
name|PF_IN
expr_stmt|;
name|plog
operator|->
name|rulenr
operator|=
name|htonl
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|plog
operator|->
name|subrulenr
operator|=
name|htonl
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|plog
operator|->
name|ruleset
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strlcpy
argument_list|(
name|plog
operator|->
name|ifname
argument_list|,
literal|"NAT64LSN"
argument_list|,
sizeof|sizeof
argument_list|(
name|plog
operator|->
name|ifname
argument_list|)
argument_list|)
expr_stmt|;
name|ipfw_bpf_mtap2
argument_list|(
name|plog
argument_list|,
name|PFLOG_HDRLEN
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Inspects icmp packets to see if the message contains different  * packet header so we need to alter @addr and @port.  */
end_comment

begin_function
specifier|static
name|int
name|inspect_icmp_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|uint8_t
modifier|*
name|nat_proto
parameter_list|,
name|uint32_t
modifier|*
name|addr
parameter_list|,
name|uint16_t
modifier|*
name|port
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|udp
decl_stmt|;
name|struct
name|icmphdr
modifier|*
name|icmp
decl_stmt|;
name|int
name|off
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
operator|*
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* Outer IP header */
name|off
operator|=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
name|ICMP_MINLEN
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_len
operator|<
name|off
condition|)
operator|*
name|m
operator|=
name|m_pullup
argument_list|(
operator|*
name|m
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ip
operator|=
name|mtod
argument_list|(
operator|*
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* Outer IP header */
name|icmp
operator|=
name|L3HDR
argument_list|(
name|ip
argument_list|,
expr|struct
name|icmphdr
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|icmp
operator|->
name|icmp_type
condition|)
block|{
case|case
name|ICMP_ECHO
case|:
case|case
name|ICMP_ECHOREPLY
case|:
comment|/* Use icmp ID as distinguisher */
operator|*
name|port
operator|=
name|ntohs
argument_list|(
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|icmp
operator|+
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ICMP_UNREACH
case|:
case|case
name|ICMP_TIMXCEED
case|:
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
comment|/* 	 * ICMP_UNREACH and ICMP_TIMXCEED contains IP header + 64 bits 	 * of ULP header. 	 */
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|ICMP_MINLEN
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_len
operator|<
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|ICMP_MINLEN
condition|)
operator|*
name|m
operator|=
name|m_pullup
argument_list|(
operator|*
name|m
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|ICMP_MINLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ip
operator|=
name|mtodo
argument_list|(
operator|*
name|m
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* Inner IP header */
name|proto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|off
operator|+=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
comment|/* Skip inner IP header */
operator|*
name|addr
operator|=
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_len
operator|<
name|off
operator|+
name|ICMP_MINLEN
condition|)
operator|*
name|m
operator|=
name|m_pullup
argument_list|(
operator|*
name|m
argument_list|,
name|off
operator|+
name|ICMP_MINLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|tcp
operator|=
name|mtodo
argument_list|(
operator|*
name|m
argument_list|,
name|off
argument_list|)
expr_stmt|;
operator|*
name|nat_proto
operator|=
name|NAT_PROTO_TCP
expr_stmt|;
operator|*
name|port
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_sport
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|IPPROTO_UDP
case|:
name|udp
operator|=
name|mtodo
argument_list|(
operator|*
name|m
argument_list|,
name|off
argument_list|)
expr_stmt|;
operator|*
name|nat_proto
operator|=
name|NAT_PROTO_UDP
expr_stmt|;
operator|*
name|port
operator|=
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_sport
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|IPPROTO_ICMP
case|:
comment|/* 		 * We will translate only ICMP errors for our ICMP 		 * echo requests. 		 */
name|icmp
operator|=
name|mtodo
argument_list|(
operator|*
name|m
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmp
operator|->
name|icmp_type
operator|!=
name|ICMP_ECHO
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
operator|*
name|port
operator|=
name|ntohs
argument_list|(
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|icmp
operator|+
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint8_t
name|convert_tcp_flags
parameter_list|(
name|uint8_t
name|flags
parameter_list|)
block|{
name|uint8_t
name|result
decl_stmt|;
name|result
operator|=
name|flags
operator|&
operator|(
name|TH_FIN
operator||
name|TH_SYN
operator|)
expr_stmt|;
name|result
operator||=
operator|(
name|flags
operator|&
name|TH_RST
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* Treat RST as FIN */
name|result
operator||=
operator|(
name|flags
operator|&
name|TH_ACK
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* Treat ACK as estab */
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|nat64lsn_translate4
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|ipfw_flow_id
modifier|*
name|f_id
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|)
block|{
name|struct
name|pfloghdr
name|loghdr
decl_stmt|,
modifier|*
name|logdata
decl_stmt|;
name|struct
name|in6_addr
name|src6
decl_stmt|;
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
decl_stmt|;
name|struct
name|nat64lsn_host
modifier|*
name|nh
decl_stmt|;
name|struct
name|nat64lsn_state
modifier|*
name|st
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
name|uint16_t
name|state_flags
decl_stmt|,
name|state_ts
decl_stmt|;
name|uint16_t
name|port
decl_stmt|,
name|lport
decl_stmt|;
name|uint8_t
name|nat_proto
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|addr
operator|=
name|f_id
operator|->
name|dst_ip
expr_stmt|;
name|port
operator|=
name|f_id
operator|->
name|dst_port
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|cfg
operator|->
name|prefix4
operator|||
name|addr
operator|>
name|cfg
operator|->
name|pmask4
condition|)
block|{
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|nomatch4
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfg
operator|->
name|nomatch_verdict
operator|)
return|;
block|}
comment|/* Check if protocol is supported and get its short id */
name|nat_proto
operator|=
name|nat64lsn_proto_map
index|[
name|f_id
operator|->
name|proto
index|]
expr_stmt|;
if|if
condition|(
name|nat_proto
operator|==
literal|0
condition|)
block|{
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|noproto
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfg
operator|->
name|nomatch_verdict
operator|)
return|;
block|}
comment|/* We might need to handle icmp differently */
if|if
condition|(
name|nat_proto
operator|==
name|NAT_PROTO_ICMP
condition|)
block|{
name|ret
operator|=
name|inspect_icmp_mbuf
argument_list|(
name|pm
argument_list|,
operator|&
name|nat_proto
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|ENOMEM
condition|)
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|nomem
argument_list|)
expr_stmt|;
else|else
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|noproto
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfg
operator|->
name|nomatch_verdict
operator|)
return|;
block|}
comment|/* XXX: Check addr for validity */
if|if
condition|(
name|addr
operator|<
name|cfg
operator|->
name|prefix4
operator|||
name|addr
operator|>
name|cfg
operator|->
name|pmask4
condition|)
block|{
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|nomatch4
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfg
operator|->
name|nomatch_verdict
operator|)
return|;
block|}
block|}
comment|/* Calc portgroup offset w.r.t protocol */
name|pg
operator|=
name|GET_PORTGROUP
argument_list|(
name|cfg
argument_list|,
name|addr
argument_list|,
name|nat_proto
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* Check if this port is occupied by any portgroup */
if|if
condition|(
name|pg
operator|==
name|NULL
condition|)
block|{
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|nomatch4
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|DPRINTF(DP_STATE, "NOMATCH %u %d %d (%d)", addr, nat_proto, port, 		    _GET_PORTGROUP_IDX(cfg, addr, nat_proto, port));
endif|#
directive|endif
return|return
operator|(
name|cfg
operator|->
name|nomatch_verdict
operator|)
return|;
block|}
comment|/* TODO: Check flags to see if we need to do some static mapping */
name|nh
operator|=
name|pg
operator|->
name|host
expr_stmt|;
comment|/* Prepare some fields we might need to update */
name|SET_AGE
argument_list|(
name|state_ts
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
operator|*
name|pm
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
name|state_flags
operator|=
name|convert_tcp_flags
argument_list|(
name|L3HDR
argument_list|(
name|ip
argument_list|,
expr|struct
name|tcphdr
operator|*
argument_list|)
operator|->
name|th_flags
argument_list|)
expr_stmt|;
else|else
name|state_flags
operator|=
literal|0
expr_stmt|;
comment|/* Lock host and get port mapping */
name|NAT64_LOCK
argument_list|(
name|nh
argument_list|)
expr_stmt|;
name|st
operator|=
operator|&
name|pg
operator|->
name|states
index|[
name|port
operator|&
operator|(
name|NAT64_CHUNK_SIZE
operator|-
literal|1
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|timestamp
operator|!=
name|state_ts
condition|)
name|st
operator|->
name|timestamp
operator|=
name|state_ts
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|->
name|flags
operator|&
name|state_flags
operator|)
operator|!=
name|state_flags
condition|)
name|st
operator|->
name|flags
operator||=
name|state_flags
expr_stmt|;
name|lport
operator|=
name|htons
argument_list|(
name|st
operator|->
name|u
operator|.
name|s
operator|.
name|lport
argument_list|)
expr_stmt|;
name|NAT64_UNLOCK
argument_list|(
name|nh
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|flags
operator|&
name|NAT64_LOG
condition|)
block|{
name|logdata
operator|=
operator|&
name|loghdr
expr_stmt|;
name|nat64lsn_log
argument_list|(
name|logdata
argument_list|,
operator|*
name|pm
argument_list|,
name|AF_INET
argument_list|,
name|pg
operator|->
name|idx
argument_list|,
name|st
operator|->
name|cur
operator|.
name|off
argument_list|)
expr_stmt|;
block|}
else|else
name|logdata
operator|=
name|NULL
expr_stmt|;
name|src6
operator|.
name|s6_addr32
index|[
literal|0
index|]
operator|=
name|cfg
operator|->
name|prefix6
operator|.
name|s6_addr32
index|[
literal|0
index|]
expr_stmt|;
name|src6
operator|.
name|s6_addr32
index|[
literal|1
index|]
operator|=
name|cfg
operator|->
name|prefix6
operator|.
name|s6_addr32
index|[
literal|1
index|]
expr_stmt|;
name|src6
operator|.
name|s6_addr32
index|[
literal|2
index|]
operator|=
name|cfg
operator|->
name|prefix6
operator|.
name|s6_addr32
index|[
literal|2
index|]
expr_stmt|;
name|src6
operator|.
name|s6_addr32
index|[
literal|3
index|]
operator|=
name|htonl
argument_list|(
name|f_id
operator|->
name|src_ip
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nat64_do_handle_ip4
argument_list|(
operator|*
name|pm
argument_list|,
operator|&
name|src6
argument_list|,
operator|&
name|nh
operator|->
name|addr
argument_list|,
name|lport
argument_list|,
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|logdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NAT64SKIP
condition|)
return|return
operator|(
name|IP_FW_PASS
operator|)
return|;
if|if
condition|(
name|ret
operator|==
name|NAT64MFREE
condition|)
name|m_freem
argument_list|(
operator|*
name|pm
argument_list|)
expr_stmt|;
operator|*
name|pm
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|IP_FW_DENY
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nat64lsn_dump_state
parameter_list|(
specifier|const
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
parameter_list|,
specifier|const
name|struct
name|nat64lsn_state
modifier|*
name|st
parameter_list|,
specifier|const
name|char
modifier|*
name|px
parameter_list|,
name|int
name|off
parameter_list|)
block|{
name|char
name|s
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|,
name|a
index|[
name|INET_ADDRSTRLEN
index|]
decl_stmt|,
name|d
index|[
name|INET_ADDRSTRLEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|nat64_debug
operator|&
name|DP_STATE
operator|)
operator|==
literal|0
condition|)
return|return;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|pg
operator|->
name|host
operator|->
name|addr
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
name|pg
operator|->
name|aaddr
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
name|st
operator|->
name|u
operator|.
name|s
operator|.
name|faddr
argument_list|,
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_STATE
argument_list|,
literal|"%s: PG %d ST [%p|%d]: %s:%d/%d<%s:%d> "
literal|"%s:%d AGE %d"
argument_list|,
name|px
argument_list|,
name|pg
operator|->
name|idx
argument_list|,
name|st
argument_list|,
name|off
argument_list|,
name|s
argument_list|,
name|st
operator|->
name|u
operator|.
name|s
operator|.
name|lport
argument_list|,
name|pg
operator|->
name|nat_proto
argument_list|,
name|a
argument_list|,
name|pg
operator|->
name|aport
operator|+
name|off
argument_list|,
name|d
argument_list|,
name|st
operator|->
name|u
operator|.
name|s
operator|.
name|fport
argument_list|,
name|GET_AGE
argument_list|(
name|st
operator|->
name|timestamp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if particular TCP state is stale and should be deleted.  * Return 1 if true, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|nat64lsn_periodic_check_tcp
parameter_list|(
specifier|const
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|nat64lsn_state
modifier|*
name|st
parameter_list|,
name|int
name|age
parameter_list|)
block|{
name|int
name|ttl
decl_stmt|;
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|NAT64_FLAG_FIN
condition|)
name|ttl
operator|=
name|cfg
operator|->
name|st_close_ttl
expr_stmt|;
elseif|else
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|NAT64_FLAG_ESTAB
condition|)
name|ttl
operator|=
name|cfg
operator|->
name|st_estab_ttl
expr_stmt|;
elseif|else
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|NAT64_FLAG_SYN
condition|)
name|ttl
operator|=
name|cfg
operator|->
name|st_syn_ttl
expr_stmt|;
else|else
name|ttl
operator|=
name|cfg
operator|->
name|st_syn_ttl
expr_stmt|;
if|if
condition|(
name|age
operator|>
name|ttl
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if nat state @st is stale and should be deleted.  * Return 1 if true, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|nat64lsn_periodic_chkstate
parameter_list|(
specifier|const
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
parameter_list|,
specifier|const
name|struct
name|nat64lsn_state
modifier|*
name|st
parameter_list|)
block|{
name|int
name|age
decl_stmt|,
name|delete
decl_stmt|;
name|age
operator|=
name|GET_AGE
argument_list|(
name|st
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|delete
operator|=
literal|0
expr_stmt|;
comment|/* Skip immutable records */
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|NAT64_FLAG_RDR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|pg
operator|->
name|nat_proto
condition|)
block|{
case|case
name|NAT_PROTO_TCP
case|:
name|delete
operator|=
name|nat64lsn_periodic_check_tcp
argument_list|(
name|cfg
argument_list|,
name|st
argument_list|,
name|age
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAT_PROTO_UDP
case|:
if|if
condition|(
name|age
operator|>
name|cfg
operator|->
name|st_udp_ttl
condition|)
name|delete
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NAT_PROTO_ICMP
case|:
if|if
condition|(
name|age
operator|>
name|cfg
operator|->
name|st_icmp_ttl
condition|)
name|delete
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|delete
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The following structures and functions  * are used to perform SLIST_FOREACH_SAFE()  * analog for states identified by struct st_ptr.  */
end_comment

begin_struct
struct|struct
name|st_idx
block|{
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
decl_stmt|;
name|struct
name|nat64lsn_state
modifier|*
name|st
decl_stmt|;
name|struct
name|st_ptr
name|sidx_next
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|st_idx
modifier|*
name|st_first
parameter_list|(
specifier|const
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|nat64lsn_host
modifier|*
name|nh
parameter_list|,
name|struct
name|st_ptr
modifier|*
name|sidx
parameter_list|,
name|struct
name|st_idx
modifier|*
name|si
parameter_list|)
block|{
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
decl_stmt|;
name|struct
name|nat64lsn_state
modifier|*
name|st
decl_stmt|;
if|if
condition|(
name|sidx
operator|->
name|idx
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
name|si
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|si
operator|)
return|;
block|}
name|pg
operator|=
name|PORTGROUP_BYSIDX
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
name|sidx
operator|->
name|idx
argument_list|)
expr_stmt|;
name|st
operator|=
operator|&
name|pg
operator|->
name|states
index|[
name|sidx
operator|->
name|off
index|]
expr_stmt|;
name|si
operator|->
name|pg
operator|=
name|pg
expr_stmt|;
name|si
operator|->
name|st
operator|=
name|st
expr_stmt|;
name|si
operator|->
name|sidx_next
operator|=
name|st
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|si
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|st_idx
modifier|*
name|st_next
parameter_list|(
specifier|const
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|nat64lsn_host
modifier|*
name|nh
parameter_list|,
name|struct
name|st_idx
modifier|*
name|si
parameter_list|)
block|{
name|struct
name|st_ptr
name|sidx
decl_stmt|;
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
decl_stmt|;
name|struct
name|nat64lsn_state
modifier|*
name|st
decl_stmt|;
name|sidx
operator|=
name|si
operator|->
name|sidx_next
expr_stmt|;
if|if
condition|(
name|sidx
operator|.
name|idx
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
name|si
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|si
operator|->
name|st
operator|=
name|NULL
expr_stmt|;
name|si
operator|->
name|pg
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|si
operator|)
return|;
block|}
name|pg
operator|=
name|PORTGROUP_BYSIDX
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
name|sidx
operator|.
name|idx
argument_list|)
expr_stmt|;
name|st
operator|=
operator|&
name|pg
operator|->
name|states
index|[
name|sidx
operator|.
name|off
index|]
expr_stmt|;
name|si
operator|->
name|pg
operator|=
name|pg
expr_stmt|;
name|si
operator|->
name|st
operator|=
name|st
expr_stmt|;
name|si
operator|->
name|sidx_next
operator|=
name|st
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|si
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|st_idx
modifier|*
name|st_save_cond
parameter_list|(
name|struct
name|st_idx
modifier|*
name|si_dst
parameter_list|,
name|struct
name|st_idx
modifier|*
name|si
parameter_list|)
block|{
if|if
condition|(
name|si
operator|->
name|st
operator|!=
name|NULL
condition|)
operator|*
name|si_dst
operator|=
operator|*
name|si
expr_stmt|;
return|return
operator|(
name|si_dst
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|nat64lsn_periodic_chkstates
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_host
modifier|*
name|nh
parameter_list|)
block|{
name|struct
name|st_idx
name|si
decl_stmt|,
name|si_prev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|delcount
decl_stmt|;
name|delcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nh
operator|->
name|hsize
condition|;
name|i
operator|++
control|)
block|{
name|memset
argument_list|(
operator|&
name|si_prev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|si_prev
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|st_first
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
operator|&
name|nh
operator|->
name|phash
index|[
name|i
index|]
argument_list|,
operator|&
name|si
argument_list|)
init|;
name|si
operator|.
name|st
operator|!=
name|NULL
condition|;
name|st_save_cond
argument_list|(
operator|&
name|si_prev
argument_list|,
operator|&
name|si
argument_list|)
operator|,
name|st_next
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
operator|&
name|si
argument_list|)
control|)
block|{
if|if
condition|(
name|nat64lsn_periodic_chkstate
argument_list|(
name|cfg
argument_list|,
name|si
operator|.
name|pg
argument_list|,
name|si
operator|.
name|st
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|nat64lsn_dump_state
argument_list|(
name|cfg
argument_list|,
name|si
operator|.
name|pg
argument_list|,
name|si
operator|.
name|st
argument_list|,
literal|"DELETE STATE"
argument_list|,
name|si
operator|.
name|st
operator|->
name|cur
operator|.
name|off
argument_list|)
expr_stmt|;
comment|/* Unlink from hash */
if|if
condition|(
name|si_prev
operator|.
name|st
operator|!=
name|NULL
condition|)
name|si_prev
operator|.
name|st
operator|->
name|next
operator|=
name|si
operator|.
name|st
operator|->
name|next
expr_stmt|;
else|else
name|nh
operator|->
name|phash
index|[
name|i
index|]
operator|=
name|si
operator|.
name|st
operator|->
name|next
expr_stmt|;
comment|/* Delete state and free its data */
name|PG_MARK_FREE_IDX
argument_list|(
name|si
operator|.
name|pg
argument_list|,
name|si
operator|.
name|st
operator|->
name|cur
operator|.
name|off
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|si
operator|.
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nat64lsn_state
argument_list|)
argument_list|)
expr_stmt|;
name|si
operator|.
name|st
operator|=
name|NULL
expr_stmt|;
name|delcount
operator|++
expr_stmt|;
comment|/* Update portgroup timestamp */
name|SET_AGE
argument_list|(
name|si
operator|.
name|pg
operator|->
name|timestamp
argument_list|)
expr_stmt|;
block|}
block|}
name|NAT64STAT_ADD
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|sdeleted
argument_list|,
name|delcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|delcount
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks if portgroup is not used and can be deleted,  * Returns 1 if stale, 0 otherwise  */
end_comment

begin_function
specifier|static
name|int
name|stale_pg
parameter_list|(
specifier|const
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|PG_IS_EMPTY
argument_list|(
name|pg
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|GET_AGE
argument_list|(
name|pg
operator|->
name|timestamp
argument_list|)
operator|<
name|cfg
operator|->
name|pg_delete_delay
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks if host record is not used and can be deleted,  * Returns 1 if stale, 0 otherwise  */
end_comment

begin_function
specifier|static
name|int
name|stale_nh
parameter_list|(
specifier|const
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|nat64lsn_host
modifier|*
name|nh
parameter_list|)
block|{
if|if
condition|(
name|nh
operator|->
name|pg_used
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|GET_AGE
argument_list|(
name|nh
operator|->
name|timestamp
argument_list|)
operator|<
name|cfg
operator|->
name|nh_delete_delay
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|nat64lsn_periodic_data
block|{
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
decl_stmt|;
name|struct
name|nat64lsn_job_head
name|jhead
decl_stmt|;
name|int
name|jlen
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|nat64lsn_periodic_chkhost
parameter_list|(
name|struct
name|nat64lsn_host
modifier|*
name|nh
parameter_list|,
name|struct
name|nat64lsn_periodic_data
modifier|*
name|d
parameter_list|)
block|{
name|char
name|a
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
decl_stmt|;
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
decl_stmt|;
name|uint64_t
name|delmask
index|[
name|NAT64LSN_PGPTRNMASK
index|]
decl_stmt|;
name|int
name|delcount
decl_stmt|,
name|i
decl_stmt|;
name|delcount
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|delmask
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|delmask
argument_list|)
argument_list|)
expr_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|nh
operator|->
name|addr
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_JQUEUE
argument_list|,
literal|"Checking %s host %s on cpu %d"
argument_list|,
name|stale_nh
argument_list|(
name|d
operator|->
name|cfg
argument_list|,
name|nh
argument_list|)
condition|?
literal|"stale"
else|:
literal|"non-stale"
argument_list|,
name|a
argument_list|,
name|curcpu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stale_nh
argument_list|(
name|d
operator|->
name|cfg
argument_list|,
name|nh
argument_list|)
condition|)
block|{
comment|/* Non-stale host. Inspect internals */
name|NAT64_LOCK
argument_list|(
name|nh
argument_list|)
expr_stmt|;
comment|/* Stage 1: Check&expire states */
if|if
condition|(
name|nat64lsn_periodic_chkstates
argument_list|(
name|d
operator|->
name|cfg
argument_list|,
name|nh
argument_list|)
operator|!=
literal|0
condition|)
name|SET_AGE
argument_list|(
name|nh
operator|->
name|timestamp
argument_list|)
expr_stmt|;
comment|/* Stage 2: Check if we need to expire */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nh
operator|->
name|pg_used
condition|;
name|i
operator|++
control|)
block|{
name|pg
operator|=
name|PORTGROUP_BYSIDX
argument_list|(
name|d
operator|->
name|cfg
argument_list|,
name|nh
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Check if we can delete portgroup */
if|if
condition|(
name|stale_pg
argument_list|(
name|d
operator|->
name|cfg
argument_list|,
name|pg
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|DPRINTF
argument_list|(
name|DP_JQUEUE
argument_list|,
literal|"Check PG %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|delmask
index|[
name|i
operator|/
literal|64
index|]
operator||=
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
operator|(
name|i
operator|%
literal|64
operator|)
operator|)
expr_stmt|;
name|delcount
operator|++
expr_stmt|;
block|}
name|NAT64_UNLOCK
argument_list|(
name|nh
argument_list|)
expr_stmt|;
if|if
condition|(
name|delcount
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
name|DP_JQUEUE
argument_list|,
literal|"Queueing %d portgroups for deleting"
argument_list|,
name|delcount
argument_list|)
expr_stmt|;
comment|/* We have something to delete - add it to queue */
name|ji
operator|=
name|nat64lsn_create_job
argument_list|(
name|d
operator|->
name|cfg
argument_list|,
name|NULL
argument_list|,
name|JTYPE_DELPORTGROUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ji
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ji
operator|->
name|haddr
operator|=
name|nh
operator|->
name|addr
expr_stmt|;
name|ji
operator|->
name|delcount
operator|=
name|delcount
expr_stmt|;
name|memcpy
argument_list|(
name|ji
operator|->
name|delmask
argument_list|,
name|delmask
argument_list|,
sizeof|sizeof
argument_list|(
name|ji
operator|->
name|delmask
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|d
operator|->
name|jhead
argument_list|,
name|ji
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|d
operator|->
name|jlen
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This procedure is used to perform various maintance  * on dynamic hash list. Currently it is called every second.  */
end_comment

begin_function
specifier|static
name|void
name|nat64lsn_periodic
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ip_fw_chain
modifier|*
name|ch
decl_stmt|;
name|IPFW_RLOCK_TRACKER
expr_stmt|;
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
decl_stmt|;
name|struct
name|nat64lsn_periodic_data
name|d
decl_stmt|;
name|struct
name|nat64lsn_host
modifier|*
name|nh
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|cfg
operator|=
operator|(
expr|struct
name|nat64lsn_cfg
operator|*
operator|)
name|data
expr_stmt|;
name|ch
operator|=
name|cfg
operator|->
name|ch
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|cfg
operator|->
name|vp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|.
name|cfg
operator|=
name|cfg
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|d
operator|.
name|jhead
argument_list|)
expr_stmt|;
name|IPFW_RLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* Stage 1: foreach host, check all its portgroups */
name|I6HASH_FOREACH_SAFE
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
name|tmp
argument_list|,
name|nat64lsn_periodic_chkhost
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
comment|/* Enqueue everything we have requested */
name|nat64lsn_enqueue_jobs
argument_list|(
name|cfg
argument_list|,
operator|&
name|d
operator|.
name|jhead
argument_list|,
name|d
operator|.
name|jlen
argument_list|)
expr_stmt|;
name|callout_schedule
argument_list|(
operator|&
name|cfg
operator|->
name|periodic
argument_list|,
name|hz
operator|*
name|PERIODIC_DELAY
argument_list|)
expr_stmt|;
name|IPFW_RUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|NAT64NOINLINE
name|void
name|reinject_mbuf
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
parameter_list|)
block|{
if|if
condition|(
name|ji
operator|->
name|m
operator|==
name|NULL
condition|)
return|return;
comment|/* Request has failed or packet type is wrong */
if|if
condition|(
name|ji
operator|->
name|f_id
operator|.
name|addr_type
operator|!=
literal|6
operator|||
name|ji
operator|->
name|done
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|ji
operator|->
name|m
argument_list|)
expr_stmt|;
name|ji
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"mbuf dropped: type %d, done %d"
argument_list|,
name|ji
operator|->
name|jtype
argument_list|,
name|ji
operator|->
name|done
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * XXX: Limit recursion level 	 */
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|jreinjected
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_JQUEUE
argument_list|,
literal|"Reinject mbuf"
argument_list|)
expr_stmt|;
name|nat64lsn_translate6
argument_list|(
name|cfg
argument_list|,
operator|&
name|ji
operator|->
name|f_id
argument_list|,
operator|&
name|ji
operator|->
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_portgroup
parameter_list|(
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|DP_OBJ
argument_list|,
literal|"DESTROY PORTGROUP %d %p"
argument_list|,
name|pg
operator|->
name|idx
argument_list|,
name|pg
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|nat64lsn_pg_zone
argument_list|,
name|pg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|alloc_portgroup
parameter_list|(
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
parameter_list|)
block|{
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
decl_stmt|;
name|pg
operator|=
name|uma_zalloc
argument_list|(
name|nat64lsn_pg_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ji
operator|->
name|needs_idx
operator|!=
literal|0
condition|)
block|{
name|ji
operator|->
name|spare_idx
operator|=
name|uma_zalloc
argument_list|(
name|nat64lsn_pgidx_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
comment|/* Failed alloc isn't always fatal, so don't check */
block|}
name|memset
argument_list|(
operator|&
name|pg
operator|->
name|freemask
argument_list|,
literal|0xFF
argument_list|,
sizeof|sizeof
argument_list|(
name|pg
operator|->
name|freemask
argument_list|)
argument_list|)
expr_stmt|;
name|pg
operator|->
name|nat_proto
operator|=
name|ji
operator|->
name|nat_proto
expr_stmt|;
name|ji
operator|->
name|pg
operator|=
name|pg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_host6
parameter_list|(
name|struct
name|nat64lsn_host
modifier|*
name|nh
parameter_list|)
block|{
name|char
name|a
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|nh
operator|->
name|addr
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_OBJ
argument_list|,
literal|"DESTROY HOST %s %p (pg used %d)"
argument_list|,
name|a
argument_list|,
name|nh
argument_list|,
name|nh
operator|->
name|pg_used
argument_list|)
expr_stmt|;
name|NAT64_LOCK_DESTROY
argument_list|(
name|nh
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nh
operator|->
name|pg_allocated
operator|/
name|NAT64LSN_PGIDX_CHUNK
condition|;
name|i
operator|++
control|)
name|uma_zfree
argument_list|(
name|nat64lsn_pgidx_zone
argument_list|,
name|PORTGROUP_CHUNK
argument_list|(
name|nh
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|nat64lsn_host_zone
argument_list|,
name|nh
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|alloc_host6
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
parameter_list|)
block|{
name|struct
name|nat64lsn_host
modifier|*
name|nh
decl_stmt|;
name|char
name|a
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|nh
operator|=
name|uma_zalloc
argument_list|(
name|nat64lsn_host_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nh
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|PORTGROUP_CHUNK
argument_list|(
name|nh
argument_list|,
literal|0
argument_list|)
operator|=
name|uma_zalloc
argument_list|(
name|nat64lsn_pgidx_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|PORTGROUP_CHUNK
argument_list|(
name|nh
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|uma_zfree
argument_list|(
name|nat64lsn_host_zone
argument_list|,
name|nh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|alloc_portgroup
argument_list|(
name|ji
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|jportfails
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|nat64lsn_pgidx_zone
argument_list|,
name|PORTGROUP_CHUNK
argument_list|(
name|nh
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|nat64lsn_host_zone
argument_list|,
name|nh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|3
operator|)
return|;
block|}
name|NAT64_LOCK_INIT
argument_list|(
name|nh
argument_list|)
expr_stmt|;
name|nh
operator|->
name|addr
operator|=
name|ji
operator|->
name|haddr
expr_stmt|;
name|nh
operator|->
name|hsize
operator|=
name|NAT64LSN_HSIZE
expr_stmt|;
comment|/* XXX: hardcoded size */
name|nh
operator|->
name|pg_allocated
operator|=
name|NAT64LSN_PGIDX_CHUNK
expr_stmt|;
name|nh
operator|->
name|pg_used
operator|=
literal|0
expr_stmt|;
name|ji
operator|->
name|nh
operator|=
name|nh
expr_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|nh
operator|->
name|addr
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_OBJ
argument_list|,
literal|"ALLOC HOST %s %p"
argument_list|,
name|a
argument_list|,
name|ji
operator|->
name|nh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finds free @pg index inside @nh  */
end_comment

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|find_nh_pg_idx
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_host
modifier|*
name|nh
parameter_list|,
name|int
modifier|*
name|idx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nh
operator|->
name|pg_allocated
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|PORTGROUP_BYSIDX
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|idx
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|attach_host6
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
parameter_list|)
block|{
name|char
name|a
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|struct
name|nat64lsn_host
modifier|*
name|nh
decl_stmt|;
name|I6HASH_FIND
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
operator|&
name|ji
operator|->
name|haddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|nh
operator|==
name|NULL
condition|)
block|{
comment|/* Add new host to list */
name|nh
operator|=
name|ji
operator|->
name|nh
expr_stmt|;
name|I6HASH_INSERT
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|ihcount
operator|++
expr_stmt|;
name|ji
operator|->
name|nh
operator|=
name|NULL
expr_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|nh
operator|->
name|addr
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_OBJ
argument_list|,
literal|"ATTACH HOST %s %p"
argument_list|,
name|a
argument_list|,
name|nh
argument_list|)
expr_stmt|;
comment|/* 		 * Try to add portgroup. 		 * Note it will automatically set 		 * 'done' on ji if successful. 		 */
if|if
condition|(
name|attach_portgroup
argument_list|(
name|cfg
argument_list|,
name|ji
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"%s %p failed to attach PG"
argument_list|,
name|a
argument_list|,
name|nh
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|jportfails
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * nh isn't NULL. This probably means we had several simultaneous 	 * host requests. The previous one request has already attached 	 * this host. Requeue attached mbuf and mark job as done, but 	 * leave nh and pg pointers not changed, so nat64lsn_do_request() 	 * will release all allocated resources. 	 */
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|nh
operator|->
name|addr
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_OBJ
argument_list|,
literal|"%s %p is already attached as %p"
argument_list|,
name|a
argument_list|,
name|ji
operator|->
name|nh
argument_list|,
name|nh
argument_list|)
expr_stmt|;
name|ji
operator|->
name|done
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|find_pg_place_addr
parameter_list|(
specifier|const
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|int
name|addr_off
parameter_list|,
name|int
name|nat_proto
parameter_list|,
name|uint16_t
modifier|*
name|aport
parameter_list|,
name|int
modifier|*
name|ppg_idx
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|pg_idx
decl_stmt|;
name|pg_idx
operator|=
name|addr_off
operator|*
name|_ADDR_PG_COUNT
operator|+
operator|(
name|nat_proto
operator|-
literal|1
operator|)
operator|*
name|_ADDR_PG_PROTO_COUNT
expr_stmt|;
for|for
control|(
name|j
operator|=
name|NAT64_MIN_CHUNK
init|;
name|j
operator|<
name|_ADDR_PG_PROTO_COUNT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cfg
operator|->
name|pg
index|[
name|pg_idx
operator|+
name|j
index|]
operator|!=
name|NULL
condition|)
continue|continue;
operator|*
name|aport
operator|=
name|j
operator|*
name|NAT64_CHUNK_SIZE
expr_stmt|;
operator|*
name|ppg_idx
operator|=
name|pg_idx
operator|+
name|j
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX: This function needs to be rewritten to  * use free bitmask for faster pg finding,  * additionally, it should take into consideration  * a) randomization and  * b) previous addresses allocated to given nat instance  *  */
end_comment

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|find_portgroup_place
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
parameter_list|,
name|uint32_t
modifier|*
name|aaddr
parameter_list|,
name|uint16_t
modifier|*
name|aport
parameter_list|,
name|int
modifier|*
name|ppg_idx
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nat_proto
decl_stmt|;
comment|/* 	 * XXX: Use bitmask index to be able to find/check if IP address 	 * has some spare pg's 	 */
name|nat_proto
operator|=
name|ji
operator|->
name|nat_proto
expr_stmt|;
comment|/* First, try to use same address */
if|if
condition|(
name|ji
operator|->
name|aaddr
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|ntohl
argument_list|(
name|ji
operator|->
name|aaddr
argument_list|)
operator|-
name|cfg
operator|->
name|prefix4
expr_stmt|;
if|if
condition|(
name|find_pg_place_addr
argument_list|(
name|cfg
argument_list|,
name|i
argument_list|,
name|nat_proto
argument_list|,
name|aport
argument_list|,
name|ppg_idx
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Found! */
operator|*
name|aaddr
operator|=
name|htonl
argument_list|(
name|cfg
operator|->
name|prefix4
operator|+
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* Next, try to use random address based on flow hash */
name|i
operator|=
name|ji
operator|->
name|fhash
operator|%
operator|(
literal|1
operator|<<
operator|(
literal|32
operator|-
name|cfg
operator|->
name|plen4
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|find_pg_place_addr
argument_list|(
name|cfg
argument_list|,
name|i
argument_list|,
name|nat_proto
argument_list|,
name|aport
argument_list|,
name|ppg_idx
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Found! */
operator|*
name|aaddr
operator|=
name|htonl
argument_list|(
name|cfg
operator|->
name|prefix4
operator|+
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Last one: simply find ANY available */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|32
operator|-
name|cfg
operator|->
name|plen4
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|find_pg_place_addr
argument_list|(
name|cfg
argument_list|,
name|i
argument_list|,
name|nat_proto
argument_list|,
name|aport
argument_list|,
name|ppg_idx
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Found! */
operator|*
name|aaddr
operator|=
name|htonl
argument_list|(
name|cfg
operator|->
name|prefix4
operator|+
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|attach_portgroup
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
parameter_list|)
block|{
name|char
name|a
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
decl_stmt|;
name|struct
name|nat64lsn_host
modifier|*
name|nh
decl_stmt|;
name|uint32_t
name|aaddr
decl_stmt|;
name|uint16_t
name|aport
decl_stmt|;
name|int
name|nh_pg_idx
decl_stmt|,
name|pg_idx
decl_stmt|;
name|pg
operator|=
name|ji
operator|->
name|pg
expr_stmt|;
comment|/* 	 * Find source host and bind: we can't rely on 	 * pg->host 	 */
name|I6HASH_FIND
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
operator|&
name|ji
operator|->
name|haddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|nh
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Find spare port chunk */
if|if
condition|(
name|find_portgroup_place
argument_list|(
name|cfg
argument_list|,
name|ji
argument_list|,
operator|&
name|aaddr
argument_list|,
operator|&
name|aport
argument_list|,
operator|&
name|pg_idx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|nh
operator|->
name|addr
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_OBJ
operator||
name|DP_DROPS
argument_list|,
literal|"empty PG not found for %s"
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
comment|/* Expand PG indexes if needed */
if|if
condition|(
name|nh
operator|->
name|pg_allocated
operator|<
name|cfg
operator|->
name|max_chunks
operator|&&
name|ji
operator|->
name|spare_idx
operator|!=
name|NULL
condition|)
block|{
name|PORTGROUP_CHUNK
argument_list|(
name|nh
argument_list|,
name|nh
operator|->
name|pg_allocated
operator|/
name|NAT64LSN_PGIDX_CHUNK
argument_list|)
operator|=
name|ji
operator|->
name|spare_idx
expr_stmt|;
name|nh
operator|->
name|pg_allocated
operator|+=
name|NAT64LSN_PGIDX_CHUNK
expr_stmt|;
name|ji
operator|->
name|spare_idx
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Find empty index to store PG in the @nh */
if|if
condition|(
name|find_nh_pg_idx
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
operator|&
name|nh_pg_idx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|nh
operator|->
name|addr
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_OBJ
operator||
name|DP_DROPS
argument_list|,
literal|"free PG index not found for %s"
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
literal|3
operator|)
return|;
block|}
name|cfg
operator|->
name|pg
index|[
name|pg_idx
index|]
operator|=
name|pg
expr_stmt|;
name|cfg
operator|->
name|protochunks
index|[
name|pg
operator|->
name|nat_proto
index|]
operator|++
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|spgcreated
argument_list|)
expr_stmt|;
name|pg
operator|->
name|aaddr
operator|=
name|aaddr
expr_stmt|;
name|pg
operator|->
name|aport
operator|=
name|aport
expr_stmt|;
name|pg
operator|->
name|host
operator|=
name|nh
expr_stmt|;
name|pg
operator|->
name|idx
operator|=
name|pg_idx
expr_stmt|;
name|SET_AGE
argument_list|(
name|pg
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|PORTGROUP_BYSIDX
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
name|nh_pg_idx
operator|+
literal|1
argument_list|)
operator|=
name|pg
expr_stmt|;
if|if
condition|(
name|nh
operator|->
name|pg_used
operator|==
name|nh_pg_idx
condition|)
name|nh
operator|->
name|pg_used
operator|++
expr_stmt|;
name|SET_AGE
argument_list|(
name|nh
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|ji
operator|->
name|pg
operator|=
name|NULL
expr_stmt|;
name|ji
operator|->
name|done
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|NAT64NOINLINE
name|void
name|consider_del_portgroup
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
parameter_list|)
block|{
name|struct
name|nat64lsn_host
modifier|*
name|nh
decl_stmt|,
modifier|*
name|nh_tmp
decl_stmt|;
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
decl_stmt|,
modifier|*
name|pg_list
index|[
literal|256
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pg_lidx
decl_stmt|,
name|idx
decl_stmt|;
comment|/* Find source host */
name|I6HASH_FIND
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
operator|&
name|ji
operator|->
name|haddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|nh
operator|==
name|NULL
operator|||
name|nh
operator|->
name|pg_used
operator|==
literal|0
condition|)
return|return;
name|memset
argument_list|(
name|pg_list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pg_list
argument_list|)
argument_list|)
expr_stmt|;
name|pg_lidx
operator|=
literal|0
expr_stmt|;
name|NAT64_LOCK
argument_list|(
name|nh
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nh
operator|->
name|pg_used
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|ji
operator|->
name|delmask
index|[
name|i
operator|/
literal|64
index|]
operator|&
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
operator|(
name|i
operator|%
literal|64
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|pg
operator|=
name|PORTGROUP_BYSIDX
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Check that PG isn't busy. */
if|if
condition|(
name|stale_pg
argument_list|(
name|cfg
argument_list|,
name|pg
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* DO delete */
name|pg_list
index|[
name|pg_lidx
operator|++
index|]
operator|=
name|pg
expr_stmt|;
name|PORTGROUP_BYSIDX
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|idx
operator|=
name|_GET_PORTGROUP_IDX
argument_list|(
name|cfg
argument_list|,
name|ntohl
argument_list|(
name|pg
operator|->
name|aaddr
argument_list|)
argument_list|,
name|pg
operator|->
name|nat_proto
argument_list|,
name|pg
operator|->
name|aport
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cfg
operator|->
name|pg
index|[
name|idx
index|]
operator|==
name|pg
argument_list|,
operator|(
literal|"Non matched pg"
operator|)
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|pg
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
name|cfg
operator|->
name|protochunks
index|[
name|pg
operator|->
name|nat_proto
index|]
operator|--
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|spgdeleted
argument_list|)
expr_stmt|;
comment|/* Decrease pg_used */
while|while
condition|(
name|nh
operator|->
name|pg_used
operator|>
literal|0
operator|&&
name|PORTGROUP_BYSIDX
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
name|nh
operator|->
name|pg_used
argument_list|)
operator|==
name|NULL
condition|)
name|nh
operator|->
name|pg_used
operator|--
expr_stmt|;
comment|/* Check if on-stack buffer has ended */
if|if
condition|(
name|pg_lidx
operator|==
name|nitems
argument_list|(
name|pg_list
argument_list|)
condition|)
break|break;
block|}
name|NAT64_UNLOCK
argument_list|(
name|nh
argument_list|)
expr_stmt|;
if|if
condition|(
name|stale_nh
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|)
condition|)
block|{
name|I6HASH_REMOVE
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
name|nh_tmp
argument_list|,
operator|&
name|ji
operator|->
name|haddr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nh
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Unable to find address"
operator|)
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|ihcount
operator|--
expr_stmt|;
name|ji
operator|->
name|nh
operator|=
name|nh
expr_stmt|;
name|I6HASH_FIND
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
operator|&
name|ji
operator|->
name|haddr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nh
operator|==
name|NULL
argument_list|,
operator|(
literal|"Failed to delete address"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* TODO: Delay freeing portgroups */
while|while
condition|(
name|pg_lidx
operator|>
literal|0
condition|)
block|{
name|pg_lidx
operator|--
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|spgdeleted
argument_list|)
expr_stmt|;
name|destroy_portgroup
argument_list|(
name|pg_list
index|[
name|pg_lidx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Main request handler.  * Responsible for handling jqueue, e.g.  * creating new hosts, addind/deleting portgroups.  */
end_comment

begin_function
specifier|static
name|NAT64NOINLINE
name|void
name|nat64lsn_do_request
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|IPFW_RLOCK_TRACKER
expr_stmt|;
name|struct
name|nat64lsn_job_head
name|jhead
decl_stmt|;
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
decl_stmt|;
name|int
name|jcount
decl_stmt|,
name|nhsize
decl_stmt|;
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
init|=
operator|(
expr|struct
name|nat64lsn_cfg
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ip_fw_chain
modifier|*
name|ch
decl_stmt|;
name|int
name|delcount
decl_stmt|;
name|CURVNET_SET
argument_list|(
name|cfg
operator|->
name|vp
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|jhead
argument_list|)
expr_stmt|;
comment|/* XXX: We're running unlocked here */
name|ch
operator|=
name|cfg
operator|->
name|ch
expr_stmt|;
name|delcount
operator|=
literal|0
expr_stmt|;
name|IPFW_RLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* Grab queue */
name|JQUEUE_LOCK
argument_list|()
expr_stmt|;
name|TAILQ_SWAP
argument_list|(
operator|&
name|jhead
argument_list|,
operator|&
name|cfg
operator|->
name|jhead
argument_list|,
name|nat64lsn_job_item
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|jcount
operator|=
name|cfg
operator|->
name|jlen
expr_stmt|;
name|cfg
operator|->
name|jlen
operator|=
literal|0
expr_stmt|;
name|JQUEUE_UNLOCK
argument_list|()
expr_stmt|;
comment|/* check if we need to resize hash */
name|nhsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|ihcount
operator|>
name|cfg
operator|->
name|ihsize
operator|&&
name|cfg
operator|->
name|ihsize
operator|<
literal|65536
condition|)
block|{
name|nhsize
operator|=
name|cfg
operator|->
name|ihsize
expr_stmt|;
for|for
control|(
init|;
name|cfg
operator|->
name|ihcount
operator|>
name|nhsize
operator|&&
name|nhsize
operator|<
literal|65536
condition|;
name|nhsize
operator|*=
literal|2
control|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|cfg
operator|->
name|ihcount
operator|<
name|cfg
operator|->
name|ihsize
operator|*
literal|4
condition|)
block|{
name|nhsize
operator|=
name|cfg
operator|->
name|ihsize
expr_stmt|;
for|for
control|(
init|;
name|cfg
operator|->
name|ihcount
operator|<
name|nhsize
operator|*
literal|4
operator|&&
name|nhsize
operator|>
literal|32
condition|;
name|nhsize
operator|/=
literal|2
control|)
empty_stmt|;
block|}
name|IPFW_RUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|jhead
argument_list|)
condition|)
block|{
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|jcalls
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_JQUEUE
argument_list|,
literal|"count=%d"
argument_list|,
name|jcount
argument_list|)
expr_stmt|;
comment|/* 	 * TODO: 	 * What we should do here is to build a hash 	 * to ensure we don't have lots of duplicate requests. 	 * Skip this for now. 	 * 	 * TODO: Limit per-call number of items 	 */
comment|/* Pre-allocate everything for entire chain */
name|TAILQ_FOREACH
argument_list|(
argument|ji
argument_list|,
argument|&jhead
argument_list|,
argument|next
argument_list|)
block|{
switch|switch
condition|(
name|ji
operator|->
name|jtype
condition|)
block|{
case|case
name|JTYPE_NEWHOST
case|:
if|if
condition|(
name|alloc_host6
argument_list|(
name|cfg
argument_list|,
name|ji
argument_list|)
operator|!=
literal|0
condition|)
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|jhostfails
argument_list|)
expr_stmt|;
break|break;
case|case
name|JTYPE_NEWPORTGROUP
case|:
if|if
condition|(
name|alloc_portgroup
argument_list|(
name|ji
argument_list|)
operator|!=
literal|0
condition|)
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|jportfails
argument_list|)
expr_stmt|;
break|break;
case|case
name|JTYPE_DELPORTGROUP
case|:
name|delcount
operator|+=
name|ji
operator|->
name|delcount
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * TODO: Alloc hew hash 	 */
name|nhsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nhsize
operator|>
literal|0
condition|)
block|{
comment|/* XXX: */
block|}
comment|/* Apply all changes in batch */
name|IPFW_UH_WLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|IPFW_WLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ji
argument_list|,
argument|&jhead
argument_list|,
argument|next
argument_list|)
block|{
switch|switch
condition|(
name|ji
operator|->
name|jtype
condition|)
block|{
case|case
name|JTYPE_NEWHOST
case|:
if|if
condition|(
name|ji
operator|->
name|nh
operator|!=
name|NULL
condition|)
name|attach_host6
argument_list|(
name|cfg
argument_list|,
name|ji
argument_list|)
expr_stmt|;
break|break;
case|case
name|JTYPE_NEWPORTGROUP
case|:
if|if
condition|(
name|ji
operator|->
name|pg
operator|!=
name|NULL
operator|&&
name|attach_portgroup
argument_list|(
name|cfg
argument_list|,
name|ji
argument_list|)
operator|!=
literal|0
condition|)
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|jportfails
argument_list|)
expr_stmt|;
break|break;
case|case
name|JTYPE_DELPORTGROUP
case|:
name|consider_del_portgroup
argument_list|(
name|cfg
argument_list|,
name|ji
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nhsize
operator|>
literal|0
condition|)
block|{
comment|/* XXX: Move everything to new hash */
block|}
name|IPFW_WUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|IPFW_UH_WUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* Flush unused entries */
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|jhead
argument_list|)
condition|)
block|{
name|ji
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|jhead
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|jhead
argument_list|,
name|ji
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|ji
operator|->
name|nh
operator|!=
name|NULL
condition|)
name|destroy_host6
argument_list|(
name|ji
operator|->
name|nh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ji
operator|->
name|pg
operator|!=
name|NULL
condition|)
name|destroy_portgroup
argument_list|(
name|ji
operator|->
name|pg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ji
operator|->
name|m
operator|!=
name|NULL
condition|)
name|reinject_mbuf
argument_list|(
name|cfg
argument_list|,
name|ji
argument_list|)
expr_stmt|;
if|if
condition|(
name|ji
operator|->
name|spare_idx
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|nat64lsn_pgidx_zone
argument_list|,
name|ji
operator|->
name|spare_idx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ji
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|NAT64NOINLINE
expr|struct
name|nat64lsn_job_item
operator|*
name|nat64lsn_create_job
argument_list|(
argument|struct nat64lsn_cfg *cfg
argument_list|,
argument|const struct ipfw_flow_id *f_id
argument_list|,
argument|int jtype
argument_list|)
block|{ 	struct
name|nat64lsn_job_item
operator|*
name|ji
block|; 	struct
name|in6_addr
name|haddr
block|;
name|uint8_t
name|nat_proto
block|;
comment|/* 	 * Do not try to lock possibly contested mutex if we're near the limit. 	 * Drop packet instead. 	 */
if|if
condition|(
name|cfg
operator|->
name|jlen
operator|>=
name|cfg
operator|->
name|jmaxlen
condition|)
block|{
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|jmaxlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|haddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|haddr
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nat_proto
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|f_id
operator|!=
name|NULL
condition|)
block|{
name|haddr
operator|=
name|f_id
operator|->
name|src_ip6
expr_stmt|;
name|nat_proto
operator|=
name|nat64lsn_proto_map
index|[
name|f_id
operator|->
name|proto
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_JQUEUE
argument_list|,
literal|"REQUEST pg nat_proto %d on proto %d"
argument_list|,
name|nat_proto
argument_list|,
name|f_id
operator|->
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|nat_proto
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|ji
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nat64lsn_job_item
argument_list|)
argument_list|,
name|M_IPFW
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ji
operator|==
name|NULL
condition|)
block|{
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|jnomem
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|ji
operator|->
name|jtype
operator|=
name|jtype
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|f_id
operator|!=
name|NULL
condition|)
block|{
name|ji
operator|->
name|f_id
operator|=
operator|*
name|f_id
expr_stmt|;
name|ji
operator|->
name|haddr
operator|=
name|haddr
expr_stmt|;
name|ji
operator|->
name|nat_proto
operator|=
name|nat_proto
expr_stmt|;
block|}
end_if

begin_return
return|return
operator|(
name|ji
operator|)
return|;
end_return

begin_function
unit|}  static
name|NAT64NOINLINE
name|void
name|nat64lsn_enqueue_job
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
parameter_list|)
block|{
if|if
condition|(
name|ji
operator|==
name|NULL
condition|)
return|return;
name|JQUEUE_LOCK
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cfg
operator|->
name|jhead
argument_list|,
name|ji
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|jlen
operator|++
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|jrequests
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|cfg
operator|->
name|jcallout
argument_list|)
operator|==
literal|0
condition|)
name|callout_reset
argument_list|(
operator|&
name|cfg
operator|->
name|jcallout
argument_list|,
literal|1
argument_list|,
name|nat64lsn_do_request
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
name|JQUEUE_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|NAT64NOINLINE
name|void
name|nat64lsn_enqueue_jobs
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|nat64lsn_job_head
modifier|*
name|jhead
parameter_list|,
name|int
name|jlen
parameter_list|)
block|{
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
name|jhead
argument_list|)
condition|)
return|return;
comment|/* Attach current queue to execution one */
name|JQUEUE_LOCK
argument_list|()
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|cfg
operator|->
name|jhead
argument_list|,
name|jhead
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|jlen
operator|+=
name|jlen
expr_stmt|;
name|NAT64STAT_ADD
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|jrequests
argument_list|,
name|jlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|cfg
operator|->
name|jcallout
argument_list|)
operator|==
literal|0
condition|)
name|callout_reset
argument_list|(
operator|&
name|cfg
operator|->
name|jcallout
argument_list|,
literal|1
argument_list|,
name|nat64lsn_do_request
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
name|JQUEUE_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|flow6_hash
parameter_list|(
specifier|const
name|struct
name|ipfw_flow_id
modifier|*
name|f_id
parameter_list|)
block|{
name|unsigned
name|char
name|hbuf
index|[
literal|36
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|hbuf
argument_list|,
operator|&
name|f_id
operator|->
name|dst_ip6
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|hbuf
index|[
literal|16
index|]
argument_list|,
operator|&
name|f_id
operator|->
name|src_ip6
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|hbuf
index|[
literal|32
index|]
argument_list|,
operator|&
name|f_id
operator|->
name|dst_port
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|hbuf
index|[
literal|32
index|]
argument_list|,
operator|&
name|f_id
operator|->
name|src_port
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|djb_hash
argument_list|(
name|hbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|nat64lsn_request_host
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|ipfw_flow_id
modifier|*
name|f_id
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|)
block|{
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
operator|*
name|pm
expr_stmt|;
operator|*
name|pm
operator|=
name|NULL
expr_stmt|;
name|ji
operator|=
name|nat64lsn_create_job
argument_list|(
name|cfg
argument_list|,
name|f_id
argument_list|,
name|JTYPE_NEWHOST
argument_list|)
expr_stmt|;
if|if
condition|(
name|ji
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"failed to create job"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ji
operator|->
name|m
operator|=
name|m
expr_stmt|;
comment|/* Provide pseudo-random value based on flow */
name|ji
operator|->
name|fhash
operator|=
name|flow6_hash
argument_list|(
name|f_id
argument_list|)
expr_stmt|;
name|nat64lsn_enqueue_job
argument_list|(
name|cfg
argument_list|,
name|ji
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|jhostsreq
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|IP_FW_PASS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|nat64lsn_request_portgroup
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|ipfw_flow_id
modifier|*
name|f_id
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|,
name|uint32_t
name|aaddr
parameter_list|,
name|int
name|needs_idx
parameter_list|)
block|{
name|struct
name|nat64lsn_job_item
modifier|*
name|ji
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
operator|*
name|pm
expr_stmt|;
operator|*
name|pm
operator|=
name|NULL
expr_stmt|;
name|ji
operator|=
name|nat64lsn_create_job
argument_list|(
name|cfg
argument_list|,
name|f_id
argument_list|,
name|JTYPE_NEWPORTGROUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ji
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"failed to create job"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ji
operator|->
name|m
operator|=
name|m
expr_stmt|;
comment|/* Provide pseudo-random value based on flow */
name|ji
operator|->
name|fhash
operator|=
name|flow6_hash
argument_list|(
name|f_id
argument_list|)
expr_stmt|;
name|ji
operator|->
name|aaddr
operator|=
name|aaddr
expr_stmt|;
name|ji
operator|->
name|needs_idx
operator|=
name|needs_idx
expr_stmt|;
name|nat64lsn_enqueue_job
argument_list|(
name|cfg
argument_list|,
name|ji
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|jportreq
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|IP_FW_PASS
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|NAT64NOINLINE
expr|struct
name|nat64lsn_state
operator|*
name|nat64lsn_create_state
argument_list|(
argument|struct nat64lsn_cfg *cfg
argument_list|,
argument|struct nat64lsn_host *nh
argument_list|,
argument|int nat_proto
argument_list|,
argument|struct nat64lsn_state *kst
argument_list|,
argument|uint32_t *aaddr
argument_list|)
block|{ 	struct
name|nat64lsn_portgroup
operator|*
name|pg
block|; 	struct
name|nat64lsn_state
operator|*
name|st
block|;
name|int
name|i
block|,
name|hval
block|,
name|off
block|;
comment|/* XXX: create additional bitmask for selecting proper portgroup */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nh
operator|->
name|pg_used
condition|;
name|i
operator|++
control|)
block|{
name|pg
operator|=
name|PORTGROUP_BYSIDX
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|*
name|aaddr
operator|==
literal|0
condition|)
operator|*
name|aaddr
operator|=
name|pg
operator|->
name|aaddr
expr_stmt|;
if|if
condition|(
name|pg
operator|->
name|nat_proto
operator|!=
name|nat_proto
condition|)
continue|continue;
name|off
operator|=
name|PG_GET_FREE_IDX
argument_list|(
name|pg
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|!=
literal|0
condition|)
block|{
comment|/* We have found spare state. Use it */
name|off
operator|--
expr_stmt|;
name|PG_MARK_BUSY_IDX
argument_list|(
name|pg
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|st
operator|=
operator|&
name|pg
operator|->
name|states
index|[
name|off
index|]
expr_stmt|;
comment|/* 			 * Fill in new info. Assume state was zeroed. 			 * Timestamp and flags will be filled by caller. 			 */
name|st
operator|->
name|u
operator|.
name|s
operator|=
name|kst
operator|->
name|u
operator|.
name|s
expr_stmt|;
name|st
operator|->
name|cur
operator|.
name|idx
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|st
operator|->
name|cur
operator|.
name|off
operator|=
name|off
expr_stmt|;
comment|/* Insert into host hash table */
name|hval
operator|=
name|HASH_IN4
argument_list|(
operator|&
name|st
operator|->
name|u
operator|.
name|hkey
argument_list|)
operator|&
operator|(
name|nh
operator|->
name|hsize
operator|-
literal|1
operator|)
expr_stmt|;
name|st
operator|->
name|next
operator|=
name|nh
operator|->
name|phash
index|[
name|hval
index|]
expr_stmt|;
name|nh
operator|->
name|phash
index|[
name|hval
index|]
operator|=
name|st
operator|->
name|cur
expr_stmt|;
name|nat64lsn_dump_state
argument_list|(
name|cfg
argument_list|,
name|pg
argument_list|,
name|st
argument_list|,
literal|"ALLOC STATE"
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|screated
argument_list|)
expr_stmt|;
return|return
operator|(
name|st
operator|)
return|;
block|}
comment|/* Saev last used alias affress */
operator|*
name|aaddr
operator|=
name|pg
operator|->
name|aaddr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  	return
operator|(
name|NULL
operator|)
expr_stmt|;
end_expr_stmt

begin_function
unit|}  static
name|NAT64NOINLINE
name|int
name|nat64lsn_translate6
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|ipfw_flow_id
modifier|*
name|f_id
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|)
block|{
name|struct
name|pfloghdr
name|loghdr
decl_stmt|,
modifier|*
name|logdata
decl_stmt|;
name|char
name|a
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|struct
name|nat64lsn_host
modifier|*
name|nh
decl_stmt|;
name|struct
name|st_ptr
name|sidx
decl_stmt|;
name|struct
name|nat64lsn_state
modifier|*
name|st
decl_stmt|,
name|kst
decl_stmt|;
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
decl_stmt|;
name|struct
name|icmp6_hdr
modifier|*
name|icmp6
decl_stmt|;
name|uint32_t
name|aaddr
decl_stmt|;
name|int
name|action
decl_stmt|,
name|hval
decl_stmt|,
name|nat_proto
decl_stmt|,
name|proto
decl_stmt|;
name|uint16_t
name|aport
decl_stmt|,
name|state_ts
decl_stmt|,
name|state_flags
decl_stmt|;
comment|/* Check if af/protocol is supported and get it short id */
name|nat_proto
operator|=
name|nat64lsn_proto_map
index|[
name|f_id
operator|->
name|proto
index|]
expr_stmt|;
if|if
condition|(
name|nat_proto
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Since we can be called from jobs handler, we need 		 * to free mbuf by self, do not leave this task to 		 * ipfw_check_packet(). 		 */
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|noproto
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|pm
argument_list|)
expr_stmt|;
operator|*
name|pm
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|IP_FW_DENY
operator|)
return|;
block|}
comment|/* Try to find host first */
name|I6HASH_FIND
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
operator|&
name|f_id
operator|->
name|src_ip6
argument_list|)
expr_stmt|;
if|if
condition|(
name|nh
operator|==
name|NULL
condition|)
return|return
operator|(
name|nat64lsn_request_host
argument_list|(
name|cfg
argument_list|,
name|f_id
argument_list|,
name|pm
argument_list|)
operator|)
return|;
comment|/* Fill-in on-stack state structure */
name|kst
operator|.
name|u
operator|.
name|s
operator|.
name|faddr
operator|=
name|f_id
operator|->
name|dst_ip6
operator|.
name|s6_addr32
index|[
literal|3
index|]
expr_stmt|;
name|kst
operator|.
name|u
operator|.
name|s
operator|.
name|fport
operator|=
name|f_id
operator|->
name|dst_port
expr_stmt|;
name|kst
operator|.
name|u
operator|.
name|s
operator|.
name|lport
operator|=
name|f_id
operator|->
name|src_port
expr_stmt|;
comment|/* Prepare some fields we might need to update */
name|hval
operator|=
literal|0
expr_stmt|;
name|proto
operator|=
name|nat64_getlasthdr
argument_list|(
operator|*
name|pm
argument_list|,
operator|&
name|hval
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|<
literal|0
condition|)
block|{
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"dropped due to mbuf isn't contigious"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|pm
argument_list|)
expr_stmt|;
operator|*
name|pm
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|IP_FW_DENY
operator|)
return|;
block|}
name|SET_AGE
argument_list|(
name|state_ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|==
name|IPPROTO_TCP
condition|)
name|state_flags
operator|=
name|convert_tcp_flags
argument_list|(
name|TCP
argument_list|(
name|mtodo
argument_list|(
operator|*
name|pm
argument_list|,
name|hval
argument_list|)
argument_list|)
operator|->
name|th_flags
argument_list|)
expr_stmt|;
else|else
name|state_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|proto
operator|==
name|IPPROTO_ICMPV6
condition|)
block|{
comment|/* Alter local port data */
name|icmp6
operator|=
name|mtodo
argument_list|(
operator|*
name|pm
argument_list|,
name|hval
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmp6
operator|->
name|icmp6_type
operator|==
name|ICMP6_ECHO_REQUEST
operator|||
name|icmp6
operator|->
name|icmp6_type
operator|==
name|ICMP6_ECHO_REPLY
condition|)
name|kst
operator|.
name|u
operator|.
name|s
operator|.
name|lport
operator|=
name|ntohs
argument_list|(
name|icmp6
operator|->
name|icmp6_id
argument_list|)
expr_stmt|;
block|}
name|hval
operator|=
name|HASH_IN4
argument_list|(
operator|&
name|kst
operator|.
name|u
operator|.
name|hkey
argument_list|)
operator|&
operator|(
name|nh
operator|->
name|hsize
operator|-
literal|1
operator|)
expr_stmt|;
name|pg
operator|=
name|NULL
expr_stmt|;
name|st
operator|=
name|NULL
expr_stmt|;
comment|/* OK, let's find state in host hash */
name|NAT64_LOCK
argument_list|(
name|nh
argument_list|)
expr_stmt|;
name|sidx
operator|=
name|nh
operator|->
name|phash
index|[
name|hval
index|]
expr_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|sidx
operator|.
name|idx
operator|!=
literal|0
condition|)
block|{
name|pg
operator|=
name|PORTGROUP_BYSIDX
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
name|sidx
operator|.
name|idx
argument_list|)
expr_stmt|;
name|st
operator|=
operator|&
name|pg
operator|->
name|states
index|[
name|sidx
operator|.
name|off
index|]
expr_stmt|;
comment|//DPRINTF("SISX: %d/%d next: %d/%d", sidx.idx, sidx.off,
comment|//st->next.idx, st->next.off);
if|if
condition|(
name|st
operator|->
name|u
operator|.
name|hkey
operator|==
name|kst
operator|.
name|u
operator|.
name|hkey
operator|&&
name|pg
operator|->
name|nat_proto
operator|==
name|nat_proto
condition|)
break|break;
if|if
condition|(
name|k
operator|++
operator|>
literal|1000
condition|)
block|{
name|DPRINTF
argument_list|(
name|DP_ALL
argument_list|,
literal|"XXX: too long %d/%d %d/%d\n"
argument_list|,
name|sidx
operator|.
name|idx
argument_list|,
name|sidx
operator|.
name|off
argument_list|,
name|st
operator|->
name|next
operator|.
name|idx
argument_list|,
name|st
operator|->
name|next
operator|.
name|off
argument_list|)
expr_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|nh
operator|->
name|addr
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_GENERIC
argument_list|,
literal|"TR host %s %p on cpu %d"
argument_list|,
name|a
argument_list|,
name|nh
argument_list|,
name|curcpu
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
block|}
name|sidx
operator|=
name|st
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sidx
operator|.
name|idx
operator|==
literal|0
condition|)
block|{
name|aaddr
operator|=
literal|0
expr_stmt|;
name|st
operator|=
name|nat64lsn_create_state
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
name|nat_proto
argument_list|,
operator|&
name|kst
argument_list|,
operator|&
name|aaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
block|{
comment|/* No free states. Request more if we can */
if|if
condition|(
name|nh
operator|->
name|pg_used
operator|>=
name|cfg
operator|->
name|max_chunks
condition|)
block|{
comment|/* Limit reached */
name|NAT64STAT_INC
argument_list|(
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|nh
operator|->
name|addr
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_DROPS
argument_list|,
literal|"PG limit reached "
literal|" for host %s (used %u, allocated %u, "
literal|"limit %u)"
argument_list|,
name|a
argument_list|,
name|nh
operator|->
name|pg_used
operator|*
name|NAT64_CHUNK_SIZE
argument_list|,
name|nh
operator|->
name|pg_allocated
operator|*
name|NAT64_CHUNK_SIZE
argument_list|,
name|cfg
operator|->
name|max_chunks
operator|*
name|NAT64_CHUNK_SIZE
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|pm
argument_list|)
expr_stmt|;
operator|*
name|pm
operator|=
name|NULL
expr_stmt|;
name|NAT64_UNLOCK
argument_list|(
name|nh
argument_list|)
expr_stmt|;
return|return
operator|(
name|IP_FW_DENY
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|nh
operator|->
name|pg_allocated
operator|<=
name|nh
operator|->
name|pg_used
operator|+
name|NAT64LSN_REMAININGPG
operator|)
operator|&&
name|nh
operator|->
name|pg_allocated
operator|<
name|cfg
operator|->
name|max_chunks
condition|)
name|action
operator|=
literal|1
expr_stmt|;
comment|/* Request new indexes */
else|else
name|action
operator|=
literal|0
expr_stmt|;
name|NAT64_UNLOCK
argument_list|(
name|nh
argument_list|)
expr_stmt|;
comment|//DPRINTF("No state, unlock for %p", nh);
return|return
operator|(
name|nat64lsn_request_portgroup
argument_list|(
name|cfg
argument_list|,
name|f_id
argument_list|,
name|pm
argument_list|,
name|aaddr
argument_list|,
name|action
argument_list|)
operator|)
return|;
block|}
comment|/* We've got new state. */
name|sidx
operator|=
name|st
operator|->
name|cur
expr_stmt|;
name|pg
operator|=
name|PORTGROUP_BYSIDX
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
name|sidx
operator|.
name|idx
argument_list|)
expr_stmt|;
block|}
comment|/* Okay, state found */
comment|/* Update necessary fileds */
if|if
condition|(
name|st
operator|->
name|timestamp
operator|!=
name|state_ts
condition|)
name|st
operator|->
name|timestamp
operator|=
name|state_ts
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|->
name|flags
operator|&
name|state_flags
operator|)
operator|!=
literal|0
condition|)
name|st
operator|->
name|flags
operator||=
name|state_flags
expr_stmt|;
comment|/* Copy needed state data */
name|aaddr
operator|=
name|pg
operator|->
name|aaddr
expr_stmt|;
name|aport
operator|=
name|htons
argument_list|(
name|pg
operator|->
name|aport
operator|+
name|sidx
operator|.
name|off
argument_list|)
expr_stmt|;
name|NAT64_UNLOCK
argument_list|(
name|nh
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|flags
operator|&
name|NAT64_LOG
condition|)
block|{
name|logdata
operator|=
operator|&
name|loghdr
expr_stmt|;
name|nat64lsn_log
argument_list|(
name|logdata
argument_list|,
operator|*
name|pm
argument_list|,
name|AF_INET6
argument_list|,
name|pg
operator|->
name|idx
argument_list|,
name|st
operator|->
name|cur
operator|.
name|off
argument_list|)
expr_stmt|;
block|}
else|else
name|logdata
operator|=
name|NULL
expr_stmt|;
name|action
operator|=
name|nat64_do_handle_ip6
argument_list|(
operator|*
name|pm
argument_list|,
name|aaddr
argument_list|,
name|aport
argument_list|,
operator|&
name|cfg
operator|->
name|stats
argument_list|,
name|logdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|NAT64SKIP
condition|)
return|return
operator|(
name|IP_FW_PASS
operator|)
return|;
if|if
condition|(
name|action
operator|==
name|NAT64MFREE
condition|)
name|m_freem
argument_list|(
operator|*
name|pm
argument_list|)
expr_stmt|;
operator|*
name|pm
operator|=
name|NULL
expr_stmt|;
comment|/* mark mbuf as consumed */
return|return
operator|(
name|IP_FW_DENY
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Main dataplane entry point.  */
end_comment

begin_function
name|int
name|ipfw_nat64lsn
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|struct
name|ip_fw_args
modifier|*
name|args
parameter_list|,
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|int
modifier|*
name|done
parameter_list|)
block|{
name|ipfw_insn
modifier|*
name|icmd
decl_stmt|;
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|IPFW_RLOCK_ASSERT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
operator|*
name|done
operator|=
literal|1
expr_stmt|;
comment|/* terminate the search */
name|icmd
operator|=
name|cmd
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|opcode
operator|!=
name|O_EXTERNAL_ACTION
operator|||
name|cmd
operator|->
name|arg1
operator|!=
name|V_nat64lsn_eid
operator|||
name|icmd
operator|->
name|opcode
operator|!=
name|O_EXTERNAL_INSTANCE
operator|||
operator|(
name|cfg
operator|=
name|NAT64_LOOKUP
argument_list|(
name|ch
argument_list|,
name|icmd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|args
operator|->
name|f_id
operator|.
name|addr_type
condition|)
block|{
case|case
literal|4
case|:
name|ret
operator|=
name|nat64lsn_translate4
argument_list|(
name|cfg
argument_list|,
operator|&
name|args
operator|->
name|f_id
argument_list|,
operator|&
name|args
operator|->
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|ret
operator|=
name|nat64lsn_translate6
argument_list|(
name|cfg
argument_list|,
operator|&
name|args
operator|->
name|f_id
argument_list|,
operator|&
name|args
operator|->
name|m
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nat64lsn_ctor_host
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|nat64lsn_host
modifier|*
name|nh
decl_stmt|;
name|nh
operator|=
operator|(
expr|struct
name|nat64lsn_host
operator|*
operator|)
name|mem
expr_stmt|;
name|memset
argument_list|(
name|nh
operator|->
name|pg_ptr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nh
operator|->
name|pg_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|nh
operator|->
name|phash
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nh
operator|->
name|phash
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nat64lsn_ctor_pgidx
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|memset
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nat64lsn_init_internal
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
name|nat64lsn_proto_map
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nat64lsn_proto_map
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up supported protocol map */
name|nat64lsn_proto_map
index|[
name|IPPROTO_TCP
index|]
operator|=
name|NAT_PROTO_TCP
expr_stmt|;
name|nat64lsn_proto_map
index|[
name|IPPROTO_UDP
index|]
operator|=
name|NAT_PROTO_UDP
expr_stmt|;
name|nat64lsn_proto_map
index|[
name|IPPROTO_ICMP
index|]
operator|=
name|NAT_PROTO_ICMP
expr_stmt|;
name|nat64lsn_proto_map
index|[
name|IPPROTO_ICMPV6
index|]
operator|=
name|NAT_PROTO_ICMP
expr_stmt|;
comment|/* Fill in reverse proto map */
name|memset
argument_list|(
name|nat64lsn_rproto_map
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nat64lsn_rproto_map
argument_list|)
argument_list|)
expr_stmt|;
name|nat64lsn_rproto_map
index|[
name|NAT_PROTO_TCP
index|]
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|nat64lsn_rproto_map
index|[
name|NAT_PROTO_UDP
index|]
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|nat64lsn_rproto_map
index|[
name|NAT_PROTO_ICMP
index|]
operator|=
name|IPPROTO_ICMPV6
expr_stmt|;
name|JQUEUE_LOCK_INIT
argument_list|()
expr_stmt|;
name|nat64lsn_host_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"NAT64 hosts zone"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nat64lsn_host
argument_list|)
argument_list|,
name|nat64lsn_ctor_host
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nat64lsn_pg_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"NAT64 portgroups zone"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nat64lsn_portgroup
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nat64lsn_pgidx_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"NAT64 portgroup indexes zone"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nat64lsn_portgroup
operator|*
argument_list|)
operator|*
name|NAT64LSN_PGIDX_CHUNK
argument_list|,
name|nat64lsn_ctor_pgidx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nat64lsn_uninit_internal
parameter_list|(
name|void
parameter_list|)
block|{
name|JQUEUE_LOCK_DESTROY
argument_list|()
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|nat64lsn_host_zone
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|nat64lsn_pg_zone
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|nat64lsn_pgidx_zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nat64lsn_start_instance
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|callout_reset
argument_list|(
operator|&
name|cfg
operator|->
name|periodic
argument_list|,
name|hz
operator|*
name|PERIODIC_DELAY
argument_list|,
name|nat64lsn_periodic
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|nat64lsn_cfg
modifier|*
name|nat64lsn_init_instance
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|size_t
name|numaddr
parameter_list|)
block|{
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
decl_stmt|;
name|cfg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nat64lsn_cfg
argument_list|)
argument_list|,
name|M_IPFW
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cfg
operator|->
name|jhead
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|vp
operator|=
name|curvnet
expr_stmt|;
name|cfg
operator|->
name|ch
operator|=
name|ch
expr_stmt|;
name|COUNTER_ARRAY_ALLOC
argument_list|(
name|cfg
operator|->
name|stats
operator|.
name|stats
argument_list|,
name|NAT64STATS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|ihsize
operator|=
name|NAT64LSN_HSIZE
expr_stmt|;
name|cfg
operator|->
name|ih
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|cfg
operator|->
name|ihsize
argument_list|,
name|M_IPFW
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|pg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|numaddr
operator|*
name|_ADDR_PG_COUNT
argument_list|,
name|M_IPFW
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|cfg
operator|->
name|periodic
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|cfg
operator|->
name|jcallout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy all hosts callback.  * Called on module unload when all activity already finished, so  * can work without any locks.  */
end_comment

begin_function
specifier|static
name|NAT64NOINLINE
name|int
name|nat64lsn_destroy_host
parameter_list|(
name|struct
name|nat64lsn_host
modifier|*
name|nh
parameter_list|,
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|nat64lsn_portgroup
modifier|*
name|pg
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|nh
operator|->
name|pg_used
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|pg
operator|=
name|PORTGROUP_BYSIDX
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
operator|==
name|NULL
condition|)
continue|continue;
name|cfg
operator|->
name|pg
index|[
name|pg
operator|->
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
name|destroy_portgroup
argument_list|(
name|pg
argument_list|)
expr_stmt|;
name|nh
operator|->
name|pg_used
operator|--
expr_stmt|;
block|}
name|destroy_host6
argument_list|(
name|nh
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|ihcount
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nat64lsn_destroy_instance
parameter_list|(
name|struct
name|nat64lsn_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|nat64lsn_host
modifier|*
name|nh
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|JQUEUE_LOCK
argument_list|()
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|cfg
operator|->
name|jcallout
argument_list|)
expr_stmt|;
name|JQUEUE_UNLOCK
argument_list|()
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|cfg
operator|->
name|periodic
argument_list|)
expr_stmt|;
name|I6HASH_FOREACH_SAFE
argument_list|(
name|cfg
argument_list|,
name|nh
argument_list|,
name|tmp
argument_list|,
name|nat64lsn_destroy_host
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|DP_OBJ
argument_list|,
literal|"instance %s: hosts %d"
argument_list|,
name|cfg
operator|->
name|name
argument_list|,
name|cfg
operator|->
name|ihcount
argument_list|)
expr_stmt|;
name|COUNTER_ARRAY_FREE
argument_list|(
name|cfg
operator|->
name|stats
operator|.
name|stats
argument_list|,
name|NAT64STATS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
operator|->
name|ih
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
operator|->
name|pg
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

