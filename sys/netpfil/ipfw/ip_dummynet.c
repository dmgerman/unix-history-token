begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998-2002,2010 Luigi Rizzo, Universita` di Pisa  * Portions Copyright (c) 2000 Akamba Corp.  * All rights reserved  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Configuration and internal object management for dummynet.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_comment
comment|/* IFNAMSIZ, struct ifaddr, ifq head, lock.h mutex.h */
end_comment

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_comment
comment|/* ip_output(), IP_FORWARDING */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_dummynet.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/ip_fw_private.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/dn_heap.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/ip_dn_private.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/dn_sched.h>
end_include

begin_comment
comment|/* which objects to copy */
end_comment

begin_define
define|#
directive|define
name|DN_C_LINK
value|0x01
end_define

begin_define
define|#
directive|define
name|DN_C_SCH
value|0x02
end_define

begin_define
define|#
directive|define
name|DN_C_FLOW
value|0x04
end_define

begin_define
define|#
directive|define
name|DN_C_FS
value|0x08
end_define

begin_define
define|#
directive|define
name|DN_C_QUEUE
value|0x10
end_define

begin_comment
comment|/* we use this argument in case of a schk_new */
end_comment

begin_struct
struct|struct
name|schk_new_arg
block|{
name|struct
name|dn_alg
modifier|*
name|fp
decl_stmt|;
name|struct
name|dn_sch
modifier|*
name|sch
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*---- callout hooks. ----*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|callout
name|dn_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|task
name|dn_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|taskqueue
modifier|*
name|dn_tq
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dummynet
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
operator|(
name|void
operator|)
name|arg
expr_stmt|;
comment|/* UNUSED */
name|taskqueue_enqueue
argument_list|(
name|dn_tq
argument_list|,
operator|&
name|dn_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dn_reschedule
parameter_list|(
name|void
parameter_list|)
block|{
name|callout_reset
argument_list|(
operator|&
name|dn_timeout
argument_list|,
literal|1
argument_list|,
name|dummynet
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----- end of callout hooks -----*/
end_comment

begin_comment
comment|/* Return a scheduler descriptor given the type or name. */
end_comment

begin_function
specifier|static
name|struct
name|dn_alg
modifier|*
name|find_sched_type
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|dn_alg
modifier|*
name|d
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|d
argument_list|,
argument|&dn_cfg.schedlist
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|type
operator|||
operator|(
name|name
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|)
condition|)
return|return
name|d
return|;
block|}
return|return
name|NULL
return|;
comment|/* not found */
block|}
end_function

begin_function
name|int
name|ipdn_bound_var
parameter_list|(
name|int
modifier|*
name|v
parameter_list|,
name|int
name|dflt
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|oldv
init|=
operator|*
name|v
decl_stmt|;
specifier|const
name|char
modifier|*
name|op
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dflt
operator|<
name|lo
condition|)
name|dflt
operator|=
name|lo
expr_stmt|;
if|if
condition|(
name|dflt
operator|>
name|hi
condition|)
name|dflt
operator|=
name|hi
expr_stmt|;
if|if
condition|(
name|oldv
operator|<
name|lo
condition|)
block|{
operator|*
name|v
operator|=
name|dflt
expr_stmt|;
name|op
operator|=
literal|"Bump"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldv
operator|>
name|hi
condition|)
block|{
operator|*
name|v
operator|=
name|hi
expr_stmt|;
name|op
operator|=
literal|"Clamp"
expr_stmt|;
block|}
else|else
return|return
operator|*
name|v
return|;
if|if
condition|(
name|op
operator|&&
name|msg
condition|)
name|printf
argument_list|(
literal|"%s %s to %d (was %d)\n"
argument_list|,
name|op
argument_list|,
name|msg
argument_list|,
operator|*
name|v
argument_list|,
name|oldv
argument_list|)
expr_stmt|;
return|return
operator|*
name|v
return|;
block|}
end_function

begin_comment
comment|/*---- flow_id mask, hash and compare functions ---*/
end_comment

begin_comment
comment|/*  * The flow_id includes the 5-tuple, the queue/pipe number  * which we store in the extra area in host order,  * and for ipv6 also the flow_id6.  * XXX see if we want the tos byte (can store in 'flags')  */
end_comment

begin_function
specifier|static
name|struct
name|ipfw_flow_id
modifier|*
name|flow_id_mask
parameter_list|(
name|struct
name|ipfw_flow_id
modifier|*
name|mask
parameter_list|,
name|struct
name|ipfw_flow_id
modifier|*
name|id
parameter_list|)
block|{
name|int
name|is_v6
init|=
name|IS_IP6_FLOW_ID
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|id
operator|->
name|dst_port
operator|&=
name|mask
operator|->
name|dst_port
expr_stmt|;
name|id
operator|->
name|src_port
operator|&=
name|mask
operator|->
name|src_port
expr_stmt|;
name|id
operator|->
name|proto
operator|&=
name|mask
operator|->
name|proto
expr_stmt|;
name|id
operator|->
name|extra
operator|&=
name|mask
operator|->
name|extra
expr_stmt|;
if|if
condition|(
name|is_v6
condition|)
block|{
name|APPLY_MASK
argument_list|(
operator|&
name|id
operator|->
name|dst_ip6
argument_list|,
operator|&
name|mask
operator|->
name|dst_ip6
argument_list|)
expr_stmt|;
name|APPLY_MASK
argument_list|(
operator|&
name|id
operator|->
name|src_ip6
argument_list|,
operator|&
name|mask
operator|->
name|src_ip6
argument_list|)
expr_stmt|;
name|id
operator|->
name|flow_id6
operator|&=
name|mask
operator|->
name|flow_id6
expr_stmt|;
block|}
else|else
block|{
name|id
operator|->
name|dst_ip
operator|&=
name|mask
operator|->
name|dst_ip
expr_stmt|;
name|id
operator|->
name|src_ip
operator|&=
name|mask
operator|->
name|src_ip
expr_stmt|;
block|}
return|return
name|id
return|;
block|}
end_function

begin_comment
comment|/* computes an OR of two masks, result in dst and also returned */
end_comment

begin_function
specifier|static
name|struct
name|ipfw_flow_id
modifier|*
name|flow_id_or
parameter_list|(
name|struct
name|ipfw_flow_id
modifier|*
name|src
parameter_list|,
name|struct
name|ipfw_flow_id
modifier|*
name|dst
parameter_list|)
block|{
name|int
name|is_v6
init|=
name|IS_IP6_FLOW_ID
argument_list|(
name|dst
argument_list|)
decl_stmt|;
name|dst
operator|->
name|dst_port
operator||=
name|src
operator|->
name|dst_port
expr_stmt|;
name|dst
operator|->
name|src_port
operator||=
name|src
operator|->
name|src_port
expr_stmt|;
name|dst
operator|->
name|proto
operator||=
name|src
operator|->
name|proto
expr_stmt|;
name|dst
operator|->
name|extra
operator||=
name|src
operator|->
name|extra
expr_stmt|;
if|if
condition|(
name|is_v6
condition|)
block|{
define|#
directive|define
name|OR_MASK
parameter_list|(
name|_d
parameter_list|,
name|_s
parameter_list|)
define|\
value|(_d)->__u6_addr.__u6_addr32[0] |= (_s)->__u6_addr.__u6_addr32[0]; \     (_d)->__u6_addr.__u6_addr32[1] |= (_s)->__u6_addr.__u6_addr32[1]; \     (_d)->__u6_addr.__u6_addr32[2] |= (_s)->__u6_addr.__u6_addr32[2]; \     (_d)->__u6_addr.__u6_addr32[3] |= (_s)->__u6_addr.__u6_addr32[3];
name|OR_MASK
argument_list|(
operator|&
name|dst
operator|->
name|dst_ip6
argument_list|,
operator|&
name|src
operator|->
name|dst_ip6
argument_list|)
expr_stmt|;
name|OR_MASK
argument_list|(
operator|&
name|dst
operator|->
name|src_ip6
argument_list|,
operator|&
name|src
operator|->
name|src_ip6
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|OR_MASK
name|dst
operator|->
name|flow_id6
operator||=
name|src
operator|->
name|flow_id6
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|dst_ip
operator||=
name|src
operator|->
name|dst_ip
expr_stmt|;
name|dst
operator|->
name|src_ip
operator||=
name|src
operator|->
name|src_ip
expr_stmt|;
block|}
return|return
name|dst
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nonzero_mask
parameter_list|(
name|struct
name|ipfw_flow_id
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|dst_port
operator|||
name|m
operator|->
name|src_port
operator|||
name|m
operator|->
name|proto
operator|||
name|m
operator|->
name|extra
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|IS_IP6_FLOW_ID
argument_list|(
name|m
argument_list|)
condition|)
block|{
return|return
name|m
operator|->
name|dst_ip6
operator|.
name|__u6_addr
operator|.
name|__u6_addr32
index|[
literal|0
index|]
operator|||
name|m
operator|->
name|dst_ip6
operator|.
name|__u6_addr
operator|.
name|__u6_addr32
index|[
literal|1
index|]
operator|||
name|m
operator|->
name|dst_ip6
operator|.
name|__u6_addr
operator|.
name|__u6_addr32
index|[
literal|2
index|]
operator|||
name|m
operator|->
name|dst_ip6
operator|.
name|__u6_addr
operator|.
name|__u6_addr32
index|[
literal|3
index|]
operator|||
name|m
operator|->
name|src_ip6
operator|.
name|__u6_addr
operator|.
name|__u6_addr32
index|[
literal|0
index|]
operator|||
name|m
operator|->
name|src_ip6
operator|.
name|__u6_addr
operator|.
name|__u6_addr32
index|[
literal|1
index|]
operator|||
name|m
operator|->
name|src_ip6
operator|.
name|__u6_addr
operator|.
name|__u6_addr32
index|[
literal|2
index|]
operator|||
name|m
operator|->
name|src_ip6
operator|.
name|__u6_addr
operator|.
name|__u6_addr32
index|[
literal|3
index|]
operator|||
name|m
operator|->
name|flow_id6
return|;
block|}
else|else
block|{
return|return
name|m
operator|->
name|dst_ip
operator|||
name|m
operator|->
name|src_ip
return|;
block|}
block|}
end_function

begin_comment
comment|/* XXX we may want a better hash function */
end_comment

begin_function
specifier|static
name|uint32_t
name|flow_id_hash
parameter_list|(
name|struct
name|ipfw_flow_id
modifier|*
name|id
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
name|IS_IP6_FLOW_ID
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|uint32_t
modifier|*
name|d
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|id
operator|->
name|dst_ip6
decl_stmt|;
name|uint32_t
modifier|*
name|s
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|id
operator|->
name|src_ip6
decl_stmt|;
name|i
operator|=
operator|(
name|d
index|[
literal|0
index|]
operator|)
operator|^
operator|(
name|d
index|[
literal|1
index|]
operator|)
operator|^
operator|(
name|d
index|[
literal|2
index|]
operator|)
operator|^
operator|(
name|d
index|[
literal|3
index|]
operator|)
operator|^
operator|(
name|d
index|[
literal|0
index|]
operator|>>
literal|15
operator|)
operator|^
operator|(
name|d
index|[
literal|1
index|]
operator|>>
literal|15
operator|)
operator|^
operator|(
name|d
index|[
literal|2
index|]
operator|>>
literal|15
operator|)
operator|^
operator|(
name|d
index|[
literal|3
index|]
operator|>>
literal|15
operator|)
operator|^
operator|(
name|s
index|[
literal|0
index|]
operator|<<
literal|1
operator|)
operator|^
operator|(
name|s
index|[
literal|1
index|]
operator|<<
literal|1
operator|)
operator|^
operator|(
name|s
index|[
literal|2
index|]
operator|<<
literal|1
operator|)
operator|^
operator|(
name|s
index|[
literal|3
index|]
operator|<<
literal|1
operator|)
operator|^
operator|(
name|s
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator|^
operator|(
name|s
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|^
operator|(
name|s
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|^
operator|(
name|s
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator|^
operator|(
name|id
operator|->
name|dst_port
operator|<<
literal|1
operator|)
operator|^
operator|(
name|id
operator|->
name|src_port
operator|)
operator|^
operator|(
name|id
operator|->
name|extra
operator|)
operator|^
operator|(
name|id
operator|->
name|proto
operator|)
operator|^
operator|(
name|id
operator|->
name|flow_id6
operator|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
operator|(
name|id
operator|->
name|dst_ip
operator|)
operator|^
operator|(
name|id
operator|->
name|dst_ip
operator|>>
literal|15
operator|)
operator|^
operator|(
name|id
operator|->
name|src_ip
operator|<<
literal|1
operator|)
operator|^
operator|(
name|id
operator|->
name|src_ip
operator|>>
literal|16
operator|)
operator|^
operator|(
name|id
operator|->
name|extra
operator|)
operator|^
operator|(
name|id
operator|->
name|dst_port
operator|<<
literal|1
operator|)
operator|^
operator|(
name|id
operator|->
name|src_port
operator|)
operator|^
operator|(
name|id
operator|->
name|proto
operator|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Like bcmp, returns 0 if ids match, 1 otherwise. */
end_comment

begin_function
specifier|static
name|int
name|flow_id_cmp
parameter_list|(
name|struct
name|ipfw_flow_id
modifier|*
name|id1
parameter_list|,
name|struct
name|ipfw_flow_id
modifier|*
name|id2
parameter_list|)
block|{
name|int
name|is_v6
init|=
name|IS_IP6_FLOW_ID
argument_list|(
name|id1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_v6
condition|)
block|{
if|if
condition|(
name|IS_IP6_FLOW_ID
argument_list|(
name|id2
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* different address families */
return|return
operator|(
name|id1
operator|->
name|dst_ip
operator|==
name|id2
operator|->
name|dst_ip
operator|&&
name|id1
operator|->
name|src_ip
operator|==
name|id2
operator|->
name|src_ip
operator|&&
name|id1
operator|->
name|dst_port
operator|==
name|id2
operator|->
name|dst_port
operator|&&
name|id1
operator|->
name|src_port
operator|==
name|id2
operator|->
name|src_port
operator|&&
name|id1
operator|->
name|proto
operator|==
name|id2
operator|->
name|proto
operator|&&
name|id1
operator|->
name|extra
operator|==
name|id2
operator|->
name|extra
operator|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
comment|/* the ipv6 case */
return|return
operator|(
operator|!
name|bcmp
argument_list|(
operator|&
name|id1
operator|->
name|dst_ip6
argument_list|,
operator|&
name|id2
operator|->
name|dst_ip6
argument_list|,
sizeof|sizeof
argument_list|(
name|id1
operator|->
name|dst_ip6
argument_list|)
argument_list|)
operator|&&
operator|!
name|bcmp
argument_list|(
operator|&
name|id1
operator|->
name|src_ip6
argument_list|,
operator|&
name|id2
operator|->
name|src_ip6
argument_list|,
sizeof|sizeof
argument_list|(
name|id1
operator|->
name|src_ip6
argument_list|)
argument_list|)
operator|&&
name|id1
operator|->
name|dst_port
operator|==
name|id2
operator|->
name|dst_port
operator|&&
name|id1
operator|->
name|src_port
operator|==
name|id2
operator|->
name|src_port
operator|&&
name|id1
operator|->
name|proto
operator|==
name|id2
operator|->
name|proto
operator|&&
name|id1
operator|->
name|extra
operator|==
name|id2
operator|->
name|extra
operator|&&
name|id1
operator|->
name|flow_id6
operator|==
name|id2
operator|->
name|flow_id6
operator|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------- end of flow-id mask, hash and compare ---------*/
end_comment

begin_comment
comment|/*--- support functions for the qht hashtable ----  * Entries are hashed by flow-id  */
end_comment

begin_function
specifier|static
name|uint32_t
name|q_hash
parameter_list|(
name|uintptr_t
name|key
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* compute the hash slot from the flow id */
name|struct
name|ipfw_flow_id
modifier|*
name|id
init|=
operator|(
name|flags
operator|&
name|DNHT_KEY_IS_OBJ
operator|)
condition|?
operator|&
operator|(
operator|(
expr|struct
name|dn_queue
operator|*
operator|)
name|key
operator|)
operator|->
name|ni
operator|.
name|fid
else|:
operator|(
expr|struct
name|ipfw_flow_id
operator|*
operator|)
name|key
decl_stmt|;
return|return
name|flow_id_hash
argument_list|(
name|id
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|q_match
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_queue
modifier|*
name|o
init|=
operator|(
expr|struct
name|dn_queue
operator|*
operator|)
name|obj
decl_stmt|;
name|struct
name|ipfw_flow_id
modifier|*
name|id2
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|DNHT_KEY_IS_OBJ
condition|)
block|{
comment|/* compare pointers */
name|id2
operator|=
operator|&
operator|(
operator|(
expr|struct
name|dn_queue
operator|*
operator|)
name|key
operator|)
operator|->
name|ni
operator|.
name|fid
expr_stmt|;
block|}
else|else
block|{
name|id2
operator|=
operator|(
expr|struct
name|ipfw_flow_id
operator|*
operator|)
name|key
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|==
name|flow_id_cmp
argument_list|(
operator|&
name|o
operator|->
name|ni
operator|.
name|fid
argument_list|,
name|id2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * create a new queue instance for the given 'key'.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|q_new
parameter_list|(
name|uintptr_t
name|key
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_queue
modifier|*
name|q
decl_stmt|,
modifier|*
name|template
init|=
name|arg
decl_stmt|;
name|struct
name|dn_fsk
modifier|*
name|fs
init|=
name|template
operator|->
name|fs
decl_stmt|;
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
operator|+
name|fs
operator|->
name|sched
operator|->
name|fp
operator|->
name|q_datalen
decl_stmt|;
name|q
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DUMMYNET
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"no memory for new queue"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|set_oid
argument_list|(
operator|&
name|q
operator|->
name|ni
operator|.
name|oid
argument_list|,
name|DN_QUEUE
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_QHT_HASH
condition|)
name|q
operator|->
name|ni
operator|.
name|fid
operator|=
operator|*
operator|(
expr|struct
name|ipfw_flow_id
operator|*
operator|)
name|key
expr_stmt|;
name|q
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|q
operator|->
name|_si
operator|=
name|template
operator|->
name|_si
expr_stmt|;
name|q
operator|->
name|_si
operator|->
name|q_count
operator|++
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|sched
operator|->
name|fp
operator|->
name|new_queue
condition|)
name|fs
operator|->
name|sched
operator|->
name|fp
operator|->
name|new_queue
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|dn_cfg
operator|.
name|queue_count
operator|++
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_comment
comment|/*  * Notify schedulers that a queue is going away.  * If (flags& DN_DESTROY), also free the packets.  * The version for callbacks is called q_delete_cb().  */
end_comment

begin_function
specifier|static
name|void
name|dn_delete_queue
parameter_list|(
name|struct
name|dn_queue
modifier|*
name|q
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|dn_fsk
modifier|*
name|fs
init|=
name|q
operator|->
name|fs
decl_stmt|;
comment|// D("fs %p si %p\n", fs, q->_si);
comment|/* notify the parent scheduler that the queue is going away */
if|if
condition|(
name|fs
operator|&&
name|fs
operator|->
name|sched
operator|->
name|fp
operator|->
name|free_queue
condition|)
name|fs
operator|->
name|sched
operator|->
name|fp
operator|->
name|free_queue
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|_si
operator|->
name|q_count
operator|--
expr_stmt|;
name|q
operator|->
name|_si
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DN_DESTROY
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|mq
operator|.
name|head
condition|)
name|dn_free_pkts
argument_list|(
name|q
operator|->
name|mq
operator|.
name|head
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|q
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
expr_stmt|;
comment|// safety
name|free
argument_list|(
name|q
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
name|dn_cfg
operator|.
name|queue_count
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|q_delete_cb
parameter_list|(
name|void
modifier|*
name|q
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|flags
init|=
operator|(
name|int
operator|)
operator|(
name|uintptr_t
operator|)
name|arg
decl_stmt|;
name|dn_delete_queue
argument_list|(
name|q
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|flags
operator|&
name|DN_DESTROY
operator|)
condition|?
name|DNHT_SCAN_DEL
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * calls dn_delete_queue/q_delete_cb on all queues,  * which notifies the parent scheduler and possibly drains packets.  * flags& DN_DESTROY: drains queues and destroy qht;  */
end_comment

begin_function
specifier|static
name|void
name|qht_delete
parameter_list|(
name|struct
name|dn_fsk
modifier|*
name|fs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ND
argument_list|(
literal|"fs %d start flags %d qht %p"
argument_list|,
name|fs
operator|->
name|fs
operator|.
name|fs_nr
argument_list|,
name|flags
argument_list|,
name|fs
operator|->
name|qht
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fs
operator|->
name|qht
condition|)
return|return;
if|if
condition|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_QHT_HASH
condition|)
block|{
name|dn_ht_scan
argument_list|(
name|fs
operator|->
name|qht
argument_list|,
name|q_delete_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DN_DESTROY
condition|)
block|{
name|dn_ht_free
argument_list|(
name|fs
operator|->
name|qht
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fs
operator|->
name|qht
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|dn_delete_queue
argument_list|(
operator|(
expr|struct
name|dn_queue
operator|*
operator|)
operator|(
name|fs
operator|->
name|qht
operator|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DN_DESTROY
condition|)
name|fs
operator|->
name|qht
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find and possibly create the queue for a MULTIQUEUE scheduler.  * We never call it for !MULTIQUEUE (the queue is in the sch_inst).  */
end_comment

begin_function
name|struct
name|dn_queue
modifier|*
name|ipdn_q_find
parameter_list|(
name|struct
name|dn_fsk
modifier|*
name|fs
parameter_list|,
name|struct
name|dn_sch_inst
modifier|*
name|si
parameter_list|,
name|struct
name|ipfw_flow_id
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|dn_queue
name|template
decl_stmt|;
name|template
operator|.
name|_si
operator|=
name|si
expr_stmt|;
name|template
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_QHT_HASH
condition|)
block|{
name|struct
name|ipfw_flow_id
name|masked_id
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|qht
operator|==
name|NULL
condition|)
block|{
name|fs
operator|->
name|qht
operator|=
name|dn_ht_init
argument_list|(
name|NULL
argument_list|,
name|fs
operator|->
name|fs
operator|.
name|buckets
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|dn_queue
argument_list|,
name|q_next
argument_list|)
argument_list|,
name|q_hash
argument_list|,
name|q_match
argument_list|,
name|q_new
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|qht
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|masked_id
operator|=
operator|*
name|id
expr_stmt|;
name|flow_id_mask
argument_list|(
operator|&
name|fs
operator|->
name|fsk_mask
argument_list|,
operator|&
name|masked_id
argument_list|)
expr_stmt|;
return|return
name|dn_ht_find
argument_list|(
name|fs
operator|->
name|qht
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|masked_id
argument_list|,
name|DNHT_INSERT
argument_list|,
operator|&
name|template
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|fs
operator|->
name|qht
operator|==
name|NULL
condition|)
name|fs
operator|->
name|qht
operator|=
name|q_new
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|template
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|dn_queue
operator|*
operator|)
name|fs
operator|->
name|qht
return|;
block|}
block|}
end_function

begin_comment
comment|/*--- end of queue hash table ---*/
end_comment

begin_comment
comment|/*--- support functions for the sch_inst hashtable ----  *  * These are hashed by flow-id  */
end_comment

begin_function
specifier|static
name|uint32_t
name|si_hash
parameter_list|(
name|uintptr_t
name|key
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* compute the hash slot from the flow id */
name|struct
name|ipfw_flow_id
modifier|*
name|id
init|=
operator|(
name|flags
operator|&
name|DNHT_KEY_IS_OBJ
operator|)
condition|?
operator|&
operator|(
operator|(
expr|struct
name|dn_sch_inst
operator|*
operator|)
name|key
operator|)
operator|->
name|ni
operator|.
name|fid
else|:
operator|(
expr|struct
name|ipfw_flow_id
operator|*
operator|)
name|key
decl_stmt|;
return|return
name|flow_id_hash
argument_list|(
name|id
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|si_match
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_sch_inst
modifier|*
name|o
init|=
name|obj
decl_stmt|;
name|struct
name|ipfw_flow_id
modifier|*
name|id2
decl_stmt|;
name|id2
operator|=
operator|(
name|flags
operator|&
name|DNHT_KEY_IS_OBJ
operator|)
condition|?
operator|&
operator|(
operator|(
expr|struct
name|dn_sch_inst
operator|*
operator|)
name|key
operator|)
operator|->
name|ni
operator|.
name|fid
else|:
operator|(
expr|struct
name|ipfw_flow_id
operator|*
operator|)
name|key
expr_stmt|;
return|return
name|flow_id_cmp
argument_list|(
operator|&
name|o
operator|->
name|ni
operator|.
name|fid
argument_list|,
name|id2
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * create a new instance for the given 'key'  * Allocate memory for instance, delay line and scheduler private data.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|si_new
parameter_list|(
name|uintptr_t
name|key
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_schk
modifier|*
name|s
init|=
name|arg
decl_stmt|;
name|struct
name|dn_sch_inst
modifier|*
name|si
decl_stmt|;
name|int
name|l
init|=
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
operator|+
name|s
operator|->
name|fp
operator|->
name|si_datalen
decl_stmt|;
name|si
operator|=
name|malloc
argument_list|(
name|l
argument_list|,
name|M_DUMMYNET
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
comment|/* Set length only for the part passed up to userland. */
name|set_oid
argument_list|(
operator|&
name|si
operator|->
name|ni
operator|.
name|oid
argument_list|,
name|DN_SCH_I
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow
argument_list|)
argument_list|)
expr_stmt|;
name|set_oid
argument_list|(
operator|&
operator|(
name|si
operator|->
name|dline
operator|.
name|oid
operator|)
argument_list|,
name|DN_DELAY_LINE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|delay_line
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mark si and dline as outside the event queue */
name|si
operator|->
name|ni
operator|.
name|oid
operator|.
name|id
operator|=
name|si
operator|->
name|dline
operator|.
name|oid
operator|.
name|id
operator|=
operator|-
literal|1
expr_stmt|;
name|si
operator|->
name|sched
operator|=
name|s
expr_stmt|;
name|si
operator|->
name|dline
operator|.
name|si
operator|=
name|si
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fp
operator|->
name|new_sched
operator|&&
name|s
operator|->
name|fp
operator|->
name|new_sched
argument_list|(
name|si
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"new_sched error"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|s
operator|->
name|sch
operator|.
name|flags
operator|&
name|DN_HAVE_MASK
condition|)
name|si
operator|->
name|ni
operator|.
name|fid
operator|=
operator|*
operator|(
expr|struct
name|ipfw_flow_id
operator|*
operator|)
name|key
expr_stmt|;
name|dn_cfg
operator|.
name|si_count
operator|++
expr_stmt|;
return|return
name|si
return|;
name|error
label|:
if|if
condition|(
name|si
condition|)
block|{
name|bzero
argument_list|(
name|si
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
argument_list|)
expr_stmt|;
comment|// safety
name|free
argument_list|(
name|si
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Callback from siht to delete all scheduler instances. Remove  * si and delay line from the system heap, destroy all queues.  * We assume that all flowset have been notified and do not  * point to us anymore.  */
end_comment

begin_function
specifier|static
name|int
name|si_destroy
parameter_list|(
name|void
modifier|*
name|_si
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_sch_inst
modifier|*
name|si
init|=
name|_si
decl_stmt|;
name|struct
name|dn_schk
modifier|*
name|s
init|=
name|si
operator|->
name|sched
decl_stmt|;
name|struct
name|delay_line
modifier|*
name|dl
init|=
operator|&
name|si
operator|->
name|dline
decl_stmt|;
if|if
condition|(
name|dl
operator|->
name|oid
operator|.
name|subtype
condition|)
comment|/* remove delay line from event heap */
name|heap_extract
argument_list|(
operator|&
name|dn_cfg
operator|.
name|evheap
argument_list|,
name|dl
argument_list|)
expr_stmt|;
name|dn_free_pkts
argument_list|(
name|dl
operator|->
name|mq
operator|.
name|head
argument_list|)
expr_stmt|;
comment|/* drain delay line */
if|if
condition|(
name|si
operator|->
name|kflags
operator|&
name|DN_ACTIVE
condition|)
comment|/* remove si from event heap */
name|heap_extract
argument_list|(
operator|&
name|dn_cfg
operator|.
name|evheap
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fp
operator|->
name|free_sched
condition|)
name|s
operator|->
name|fp
operator|->
name|free_sched
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|si
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
argument_list|)
expr_stmt|;
comment|/* safety */
name|free
argument_list|(
name|si
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
name|dn_cfg
operator|.
name|si_count
operator|--
expr_stmt|;
return|return
name|DNHT_SCAN_DEL
return|;
block|}
end_function

begin_comment
comment|/*  * Find the scheduler instance for this packet. If we need to apply  * a mask, do on a local copy of the flow_id to preserve the original.  * Assume siht is always initialized if we have a mask.  */
end_comment

begin_function
name|struct
name|dn_sch_inst
modifier|*
name|ipdn_si_find
parameter_list|(
name|struct
name|dn_schk
modifier|*
name|s
parameter_list|,
name|struct
name|ipfw_flow_id
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|sch
operator|.
name|flags
operator|&
name|DN_HAVE_MASK
condition|)
block|{
name|struct
name|ipfw_flow_id
name|id_t
init|=
operator|*
name|id
decl_stmt|;
name|flow_id_mask
argument_list|(
operator|&
name|s
operator|->
name|sch
operator|.
name|sched_mask
argument_list|,
operator|&
name|id_t
argument_list|)
expr_stmt|;
return|return
name|dn_ht_find
argument_list|(
name|s
operator|->
name|siht
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|id_t
argument_list|,
name|DNHT_INSERT
argument_list|,
name|s
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|siht
condition|)
name|s
operator|->
name|siht
operator|=
name|si_new
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|dn_sch_inst
operator|*
operator|)
name|s
operator|->
name|siht
return|;
block|}
end_function

begin_comment
comment|/* callback to flush credit for the scheduler instance */
end_comment

begin_function
specifier|static
name|int
name|si_reset_credit
parameter_list|(
name|void
modifier|*
name|_si
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_sch_inst
modifier|*
name|si
init|=
name|_si
decl_stmt|;
name|struct
name|dn_link
modifier|*
name|p
init|=
operator|&
name|si
operator|->
name|sched
operator|->
name|link
decl_stmt|;
name|si
operator|->
name|credit
operator|=
name|p
operator|->
name|burst
operator|+
operator|(
name|dn_cfg
operator|.
name|io_fast
condition|?
name|p
operator|->
name|bandwidth
else|:
literal|0
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|schk_reset_credit
parameter_list|(
name|struct
name|dn_schk
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|sch
operator|.
name|flags
operator|&
name|DN_HAVE_MASK
condition|)
name|dn_ht_scan
argument_list|(
name|s
operator|->
name|siht
argument_list|,
name|si_reset_credit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|siht
condition|)
name|si_reset_credit
argument_list|(
name|s
operator|->
name|siht
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---- end of sch_inst hashtable ---------------------*/
end_comment

begin_comment
comment|/*-------------------------------------------------------  * flowset hash (fshash) support. Entries are hashed by fs_nr.  * New allocations are put in the fsunlinked list, from which  * they are removed when they point to a specific scheduler.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|fsk_hash
parameter_list|(
name|uintptr_t
name|key
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|uint32_t
name|i
init|=
operator|!
operator|(
name|flags
operator|&
name|DNHT_KEY_IS_OBJ
operator|)
condition|?
name|key
else|:
operator|(
operator|(
expr|struct
name|dn_fsk
operator|*
operator|)
name|key
operator|)
operator|->
name|fs
operator|.
name|fs_nr
decl_stmt|;
return|return
operator|(
operator|(
name|i
operator|>>
literal|8
operator|)
operator|^
operator|(
name|i
operator|>>
literal|4
operator|)
operator|^
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fsk_match
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_fsk
modifier|*
name|fs
init|=
name|obj
decl_stmt|;
name|int
name|i
init|=
operator|!
operator|(
name|flags
operator|&
name|DNHT_KEY_IS_OBJ
operator|)
condition|?
name|key
else|:
operator|(
operator|(
expr|struct
name|dn_fsk
operator|*
operator|)
name|key
operator|)
operator|->
name|fs
operator|.
name|fs_nr
decl_stmt|;
return|return
operator|(
name|fs
operator|->
name|fs
operator|.
name|fs_nr
operator|==
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|fsk_new
parameter_list|(
name|uintptr_t
name|key
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_fsk
modifier|*
name|fs
decl_stmt|;
name|fs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fs
argument_list|)
argument_list|,
name|M_DUMMYNET
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
condition|)
block|{
name|set_oid
argument_list|(
operator|&
name|fs
operator|->
name|fs
operator|.
name|oid
argument_list|,
name|DN_FS
argument_list|,
sizeof|sizeof
argument_list|(
name|fs
operator|->
name|fs
argument_list|)
argument_list|)
expr_stmt|;
name|dn_cfg
operator|.
name|fsk_count
operator|++
expr_stmt|;
name|fs
operator|->
name|drain_bucket
operator|=
literal|0
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|dn_cfg
operator|.
name|fsu
argument_list|,
name|fs
argument_list|,
name|sch_chain
argument_list|)
expr_stmt|;
block|}
return|return
name|fs
return|;
block|}
end_function

begin_comment
comment|/*  * detach flowset from its current scheduler. Flags as follows:  * DN_DETACH removes from the fsk_list  * DN_DESTROY deletes individual queues  * DN_DELETE_FS destroys the flowset (otherwise goes in unlinked).  */
end_comment

begin_function
specifier|static
name|void
name|fsk_detach
parameter_list|(
name|struct
name|dn_fsk
modifier|*
name|fs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|DN_DELETE_FS
condition|)
name|flags
operator||=
name|DN_DESTROY
expr_stmt|;
name|ND
argument_list|(
literal|"fs %d from sched %d flags %s %s %s"
argument_list|,
name|fs
operator|->
name|fs
operator|.
name|fs_nr
argument_list|,
name|fs
operator|->
name|fs
operator|.
name|sched_nr
argument_list|,
operator|(
name|flags
operator|&
name|DN_DELETE_FS
operator|)
condition|?
literal|"DEL_FS"
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|DN_DESTROY
operator|)
condition|?
literal|"DEL"
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|DN_DETACH
operator|)
condition|?
literal|"DET"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DN_DETACH
condition|)
block|{
comment|/* detach from the list */
name|struct
name|dn_fsk_head
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|fs
operator|->
name|sched
condition|?
operator|&
name|fs
operator|->
name|sched
operator|->
name|fsk_list
else|:
operator|&
name|dn_cfg
operator|.
name|fsu
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
name|h
argument_list|,
name|fs
argument_list|,
name|dn_fsk
argument_list|,
name|sch_chain
argument_list|)
expr_stmt|;
block|}
comment|/* Free the RED parameters, they will be recomputed on 	 * subsequent attach if needed. 	 */
if|if
condition|(
name|fs
operator|->
name|w_q_lookup
condition|)
name|free
argument_list|(
name|fs
operator|->
name|w_q_lookup
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
name|fs
operator|->
name|w_q_lookup
operator|=
name|NULL
expr_stmt|;
name|qht_delete
argument_list|(
name|fs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|sched
operator|&&
name|fs
operator|->
name|sched
operator|->
name|fp
operator|->
name|free_fsk
condition|)
name|fs
operator|->
name|sched
operator|->
name|fp
operator|->
name|free_fsk
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|fs
operator|->
name|sched
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DN_DELETE_FS
condition|)
block|{
name|bzero
argument_list|(
name|fs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* safety */
name|free
argument_list|(
name|fs
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
name|dn_cfg
operator|.
name|fsk_count
operator|--
expr_stmt|;
block|}
else|else
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|dn_cfg
operator|.
name|fsu
argument_list|,
name|fs
argument_list|,
name|sch_chain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Detach or destroy all flowsets in a list.  * flags specifies what to do:  * DN_DESTROY:	flush all queues  * DN_DELETE_FS:	DN_DESTROY + destroy flowset  *	DN_DELETE_FS implies DN_DESTROY  */
end_comment

begin_function
specifier|static
name|void
name|fsk_detach_list
parameter_list|(
name|struct
name|dn_fsk_head
modifier|*
name|h
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|dn_fsk
modifier|*
name|fs
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/* only for stats */
name|ND
argument_list|(
literal|"head %p flags %x"
argument_list|,
name|h
argument_list|,
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fs
operator|=
name|SLIST_FIRST
argument_list|(
name|h
argument_list|)
operator|)
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
name|h
argument_list|,
name|sch_chain
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|fsk_detach
argument_list|(
name|fs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|ND
argument_list|(
literal|"done %d flowsets"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * called on 'queue X delete' -- removes the flowset from fshash,  * deletes all queues for the flowset, and removes the flowset.  */
end_comment

begin_function
specifier|static
name|int
name|delete_fs
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|locked
parameter_list|)
block|{
name|struct
name|dn_fsk
modifier|*
name|fs
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|DN_BH_WLOCK
argument_list|()
expr_stmt|;
name|fs
operator|=
name|dn_ht_find
argument_list|(
name|dn_cfg
operator|.
name|fshash
argument_list|,
name|i
argument_list|,
name|DNHT_REMOVE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"fs %d found %p"
argument_list|,
name|i
argument_list|,
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
condition|)
block|{
name|fsk_detach
argument_list|(
name|fs
argument_list|,
name|DN_DETACH
operator||
name|DN_DELETE_FS
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|err
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*----- end of flowset hashtable support -------------*/
end_comment

begin_comment
comment|/*------------------------------------------------------------  * Scheduler hash. When searching by index we pass sched_nr,  * otherwise we pass struct dn_sch * which is the first field in  * struct dn_schk so we can cast between the two. We use this trick  * because in the create phase (but it should be fixed).  */
end_comment

begin_function
specifier|static
name|uint32_t
name|schk_hash
parameter_list|(
name|uintptr_t
name|key
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|_arg
parameter_list|)
block|{
name|uint32_t
name|i
init|=
operator|!
operator|(
name|flags
operator|&
name|DNHT_KEY_IS_OBJ
operator|)
condition|?
name|key
else|:
operator|(
operator|(
expr|struct
name|dn_schk
operator|*
operator|)
name|key
operator|)
operator|->
name|sch
operator|.
name|sched_nr
decl_stmt|;
return|return
operator|(
operator|(
name|i
operator|>>
literal|8
operator|)
operator|^
operator|(
name|i
operator|>>
literal|4
operator|)
operator|^
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|schk_match
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|_arg
parameter_list|)
block|{
name|struct
name|dn_schk
modifier|*
name|s
init|=
operator|(
expr|struct
name|dn_schk
operator|*
operator|)
name|obj
decl_stmt|;
name|int
name|i
init|=
operator|!
operator|(
name|flags
operator|&
name|DNHT_KEY_IS_OBJ
operator|)
condition|?
name|key
else|:
operator|(
operator|(
expr|struct
name|dn_schk
operator|*
operator|)
name|key
operator|)
operator|->
name|sch
operator|.
name|sched_nr
decl_stmt|;
return|return
operator|(
name|s
operator|->
name|sch
operator|.
name|sched_nr
operator|==
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the entry and intialize with the sched hash if needed.  * Leave s->fp unset so we can tell whether a dn_ht_find() returns  * a new object or a previously existing one.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|schk_new
parameter_list|(
name|uintptr_t
name|key
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|schk_new_arg
modifier|*
name|a
init|=
name|arg
decl_stmt|;
name|struct
name|dn_schk
modifier|*
name|s
decl_stmt|;
name|int
name|l
init|=
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
operator|+
name|a
operator|->
name|fp
operator|->
name|schk_datalen
decl_stmt|;
name|s
operator|=
name|malloc
argument_list|(
name|l
argument_list|,
name|M_DUMMYNET
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|set_oid
argument_list|(
operator|&
name|s
operator|->
name|link
operator|.
name|oid
argument_list|,
name|DN_LINK
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|sch
operator|=
operator|*
name|a
operator|->
name|sch
expr_stmt|;
comment|// copy initial values
name|s
operator|->
name|link
operator|.
name|link_nr
operator|=
name|s
operator|->
name|sch
operator|.
name|sched_nr
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|s
operator|->
name|fsk_list
argument_list|)
expr_stmt|;
comment|/* initialize the hash table or create the single instance */
name|s
operator|->
name|fp
operator|=
name|a
operator|->
name|fp
expr_stmt|;
comment|/* si_new needs this */
name|s
operator|->
name|drain_bucket
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|sch
operator|.
name|flags
operator|&
name|DN_HAVE_MASK
condition|)
block|{
name|s
operator|->
name|siht
operator|=
name|dn_ht_init
argument_list|(
name|NULL
argument_list|,
name|s
operator|->
name|sch
operator|.
name|buckets
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|dn_sch_inst
argument_list|,
name|si_next
argument_list|)
argument_list|,
name|si_hash
argument_list|,
name|si_match
argument_list|,
name|si_new
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|siht
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|s
operator|->
name|fp
operator|=
name|NULL
expr_stmt|;
comment|/* mark as a new scheduler */
name|dn_cfg
operator|.
name|schk_count
operator|++
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Callback for sched delete. Notify all attached flowsets to  * detach from the scheduler, destroy the internal flowset, and  * all instances. The scheduler goes away too.  * arg is 0 (only detach flowsets and destroy instances)  * DN_DESTROY (detach& delete queues, delete schk)  * or DN_DELETE_FS (delete queues and flowsets, delete schk)  */
end_comment

begin_function
specifier|static
name|int
name|schk_delete_cb
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_schk
modifier|*
name|s
init|=
name|obj
decl_stmt|;
if|#
directive|if
literal|0
block|int a = (int)arg; 	ND("sched %d arg %s%s", 		s->sch.sched_nr, 		a&DN_DESTROY ? "DEL ":"", 		a&DN_DELETE_FS ? "DEL_FS":"");
endif|#
directive|endif
name|fsk_detach_list
argument_list|(
operator|&
name|s
operator|->
name|fsk_list
argument_list|,
name|arg
condition|?
name|DN_DESTROY
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* no more flowset pointing to us now */
if|if
condition|(
name|s
operator|->
name|sch
operator|.
name|flags
operator|&
name|DN_HAVE_MASK
condition|)
block|{
name|dn_ht_scan
argument_list|(
name|s
operator|->
name|siht
argument_list|,
name|si_destroy
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dn_ht_free
argument_list|(
name|s
operator|->
name|siht
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|siht
condition|)
name|si_destroy
argument_list|(
name|s
operator|->
name|siht
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|profile
condition|)
block|{
name|free
argument_list|(
name|s
operator|->
name|profile
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
name|s
operator|->
name|profile
operator|=
name|NULL
expr_stmt|;
block|}
name|s
operator|->
name|siht
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fp
operator|->
name|destroy
condition|)
name|s
operator|->
name|fp
operator|->
name|destroy
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|// safety
name|free
argument_list|(
name|obj
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
name|dn_cfg
operator|.
name|schk_count
operator|--
expr_stmt|;
return|return
name|DNHT_SCAN_DEL
return|;
block|}
end_function

begin_comment
comment|/*  * called on a 'sched X delete' command. Deletes a single scheduler.  * This is done by removing from the schedhash, unlinking all  * flowsets and deleting their traffic.  */
end_comment

begin_function
specifier|static
name|int
name|delete_schk
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|struct
name|dn_schk
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|dn_ht_find
argument_list|(
name|dn_cfg
operator|.
name|schedhash
argument_list|,
name|i
argument_list|,
name|DNHT_REMOVE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"%d %p"
argument_list|,
name|i
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|EINVAL
return|;
name|delete_fs
argument_list|(
name|i
operator|+
name|DN_MAX_ID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* first delete internal fs */
comment|/* then detach flowsets, delete traffic */
name|schk_delete_cb
argument_list|(
name|s
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|DN_DESTROY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*--- end of schk hashtable support ---*/
end_comment

begin_function
specifier|static
name|int
name|copy_obj
parameter_list|(
name|char
modifier|*
modifier|*
name|start
parameter_list|,
name|char
modifier|*
name|end
parameter_list|,
name|void
modifier|*
name|_o
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|dn_id
modifier|*
name|o
init|=
name|_o
decl_stmt|;
name|int
name|have
init|=
name|end
operator|-
operator|*
name|start
decl_stmt|;
if|if
condition|(
name|have
operator|<
name|o
operator|->
name|len
operator|||
name|o
operator|->
name|len
operator|==
literal|0
operator|||
name|o
operator|->
name|type
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"(WARN) type %d %s %d have %d need %d"
argument_list|,
name|o
operator|->
name|type
argument_list|,
name|msg
argument_list|,
name|i
argument_list|,
name|have
argument_list|,
name|o
operator|->
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ND
argument_list|(
literal|"type %d %s %d len %d"
argument_list|,
name|o
operator|->
name|type
argument_list|,
name|msg
argument_list|,
name|i
argument_list|,
name|o
operator|->
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|_o
argument_list|,
operator|*
name|start
argument_list|,
name|o
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|type
operator|==
name|DN_LINK
condition|)
block|{
comment|/* Adjust burst parameter for link */
name|struct
name|dn_link
modifier|*
name|l
init|=
operator|(
expr|struct
name|dn_link
operator|*
operator|)
operator|*
name|start
decl_stmt|;
name|l
operator|->
name|burst
operator|=
name|div64
argument_list|(
name|l
operator|->
name|burst
argument_list|,
literal|8
operator|*
name|hz
argument_list|)
expr_stmt|;
name|l
operator|->
name|delay
operator|=
name|l
operator|->
name|delay
operator|*
literal|1000
operator|/
name|hz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|->
name|type
operator|==
name|DN_SCH
condition|)
block|{
comment|/* Set id->id to the number of instances */
name|struct
name|dn_schk
modifier|*
name|s
init|=
name|_o
decl_stmt|;
name|struct
name|dn_id
modifier|*
name|id
init|=
operator|(
expr|struct
name|dn_id
operator|*
operator|)
operator|(
operator|*
name|start
operator|)
decl_stmt|;
name|id
operator|->
name|id
operator|=
operator|(
name|s
operator|->
name|sch
operator|.
name|flags
operator|&
name|DN_HAVE_MASK
operator|)
condition|?
name|dn_ht_entries
argument_list|(
name|s
operator|->
name|siht
argument_list|)
else|:
operator|(
name|s
operator|->
name|siht
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
operator|*
name|start
operator|+=
name|o
operator|->
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Specific function to copy a queue.  * Copies only the user-visible part of a queue (which is in  * a struct dn_flow), and sets len accordingly.  */
end_comment

begin_function
specifier|static
name|int
name|copy_obj_q
parameter_list|(
name|char
modifier|*
modifier|*
name|start
parameter_list|,
name|char
modifier|*
name|end
parameter_list|,
name|void
modifier|*
name|_o
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|dn_id
modifier|*
name|o
init|=
name|_o
decl_stmt|;
name|int
name|have
init|=
name|end
operator|-
operator|*
name|start
decl_stmt|;
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow
argument_list|)
decl_stmt|;
comment|/* see above comment */
if|if
condition|(
name|have
operator|<
name|len
operator|||
name|o
operator|->
name|len
operator|==
literal|0
operator|||
name|o
operator|->
name|type
operator|!=
name|DN_QUEUE
condition|)
block|{
name|D
argument_list|(
literal|"ERROR type %d %s %d have %d need %d"
argument_list|,
name|o
operator|->
name|type
argument_list|,
name|msg
argument_list|,
name|i
argument_list|,
name|have
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ND
argument_list|(
literal|"type %d %s %d len %d"
argument_list|,
name|o
operator|->
name|type
argument_list|,
name|msg
argument_list|,
name|i
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|_o
argument_list|,
operator|*
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|dn_id
operator|*
operator|)
operator|(
operator|*
name|start
operator|)
operator|)
operator|->
name|len
operator|=
name|len
expr_stmt|;
operator|*
name|start
operator|+=
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_q_cb
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_queue
modifier|*
name|q
init|=
name|obj
decl_stmt|;
name|struct
name|copy_args
modifier|*
name|a
init|=
name|arg
decl_stmt|;
name|struct
name|dn_flow
modifier|*
name|ni
init|=
operator|(
expr|struct
name|dn_flow
operator|*
operator|)
operator|(
operator|*
name|a
operator|->
name|start
operator|)
decl_stmt|;
if|if
condition|(
name|copy_obj_q
argument_list|(
name|a
operator|->
name|start
argument_list|,
name|a
operator|->
name|end
argument_list|,
operator|&
name|q
operator|->
name|ni
argument_list|,
literal|"queue"
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
name|DNHT_SCAN_END
return|;
name|ni
operator|->
name|oid
operator|.
name|type
operator|=
name|DN_FLOW
expr_stmt|;
comment|/* override the DN_QUEUE */
name|ni
operator|->
name|oid
operator|.
name|id
operator|=
name|si_hash
argument_list|(
operator|(
name|uintptr_t
operator|)
operator|&
name|ni
operator|->
name|fid
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_q
parameter_list|(
name|struct
name|copy_args
modifier|*
name|a
parameter_list|,
name|struct
name|dn_fsk
modifier|*
name|fs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fs
operator|->
name|qht
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_QHT_HASH
condition|)
name|dn_ht_scan
argument_list|(
name|fs
operator|->
name|qht
argument_list|,
name|copy_q_cb
argument_list|,
name|a
argument_list|)
expr_stmt|;
else|else
name|copy_q_cb
argument_list|(
name|fs
operator|->
name|qht
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This routine only copies the initial part of a profile ? XXX  */
end_comment

begin_function
specifier|static
name|int
name|copy_profile
parameter_list|(
name|struct
name|copy_args
modifier|*
name|a
parameter_list|,
name|struct
name|dn_profile
modifier|*
name|p
parameter_list|)
block|{
name|int
name|have
init|=
name|a
operator|->
name|end
operator|-
operator|*
name|a
operator|->
name|start
decl_stmt|;
comment|/* XXX here we check for max length */
name|int
name|profile_len
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_profile
argument_list|)
operator|-
name|ED_MAX_SAMPLES_NO
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|have
operator|<
name|profile_len
condition|)
block|{
name|D
argument_list|(
literal|"error have %d need %d"
argument_list|,
name|have
argument_list|,
name|profile_len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bcopy
argument_list|(
name|p
argument_list|,
operator|*
name|a
operator|->
name|start
argument_list|,
name|profile_len
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|dn_id
operator|*
operator|)
operator|(
operator|*
name|a
operator|->
name|start
operator|)
operator|)
operator|->
name|len
operator|=
name|profile_len
expr_stmt|;
operator|*
name|a
operator|->
name|start
operator|+=
name|profile_len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_flowset
parameter_list|(
name|struct
name|copy_args
modifier|*
name|a
parameter_list|,
name|struct
name|dn_fsk
modifier|*
name|fs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|dn_fs
modifier|*
name|ufs
init|=
operator|(
expr|struct
name|dn_fs
operator|*
operator|)
operator|(
operator|*
name|a
operator|->
name|start
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|fs
condition|)
return|return
literal|0
return|;
name|ND
argument_list|(
literal|"flowset %d"
argument_list|,
name|fs
operator|->
name|fs
operator|.
name|fs_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_obj
argument_list|(
name|a
operator|->
name|start
argument_list|,
name|a
operator|->
name|end
argument_list|,
operator|&
name|fs
operator|->
name|fs
argument_list|,
literal|"flowset"
argument_list|,
name|fs
operator|->
name|fs
operator|.
name|fs_nr
argument_list|)
condition|)
return|return
name|DNHT_SCAN_END
return|;
name|ufs
operator|->
name|oid
operator|.
name|id
operator|=
operator|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_QHT_HASH
operator|)
condition|?
name|dn_ht_entries
argument_list|(
name|fs
operator|->
name|qht
argument_list|)
else|:
operator|(
name|fs
operator|->
name|qht
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|flags
condition|)
block|{
comment|/* copy queues */
name|copy_q
argument_list|(
name|a
argument_list|,
name|fs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_si_cb
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_sch_inst
modifier|*
name|si
init|=
name|obj
decl_stmt|;
name|struct
name|copy_args
modifier|*
name|a
init|=
name|arg
decl_stmt|;
name|struct
name|dn_flow
modifier|*
name|ni
init|=
operator|(
expr|struct
name|dn_flow
operator|*
operator|)
operator|(
operator|*
name|a
operator|->
name|start
operator|)
decl_stmt|;
if|if
condition|(
name|copy_obj
argument_list|(
name|a
operator|->
name|start
argument_list|,
name|a
operator|->
name|end
argument_list|,
operator|&
name|si
operator|->
name|ni
argument_list|,
literal|"inst"
argument_list|,
name|si
operator|->
name|sched
operator|->
name|sch
operator|.
name|sched_nr
argument_list|)
condition|)
return|return
name|DNHT_SCAN_END
return|;
name|ni
operator|->
name|oid
operator|.
name|type
operator|=
name|DN_FLOW
expr_stmt|;
comment|/* override the DN_SCH_I */
name|ni
operator|->
name|oid
operator|.
name|id
operator|=
name|si_hash
argument_list|(
operator|(
name|uintptr_t
operator|)
name|si
argument_list|,
name|DNHT_KEY_IS_OBJ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_si
parameter_list|(
name|struct
name|copy_args
modifier|*
name|a
parameter_list|,
name|struct
name|dn_schk
modifier|*
name|s
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|sch
operator|.
name|flags
operator|&
name|DN_HAVE_MASK
condition|)
name|dn_ht_scan
argument_list|(
name|s
operator|->
name|siht
argument_list|,
name|copy_si_cb
argument_list|,
name|a
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|siht
condition|)
name|copy_si_cb
argument_list|(
name|s
operator|->
name|siht
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * compute a list of children of a scheduler and copy up  */
end_comment

begin_function
specifier|static
name|int
name|copy_fsk_list
parameter_list|(
name|struct
name|copy_args
modifier|*
name|a
parameter_list|,
name|struct
name|dn_schk
modifier|*
name|s
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|dn_fsk
modifier|*
name|fs
decl_stmt|;
name|struct
name|dn_id
modifier|*
name|o
decl_stmt|;
name|uint32_t
modifier|*
name|p
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|,
name|space
init|=
sizeof|sizeof
argument_list|(
operator|*
name|o
argument_list|)
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|fs
argument_list|,
argument|&s->fsk_list
argument_list|,
argument|sch_chain
argument_list|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs
operator|.
name|fs_nr
operator|<
name|DN_MAX_ID
condition|)
name|n
operator|++
expr_stmt|;
block|}
name|space
operator|+=
name|n
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|DX
argument_list|(
literal|3
argument_list|,
literal|"sched %d has %d flowsets"
argument_list|,
name|s
operator|->
name|sch
operator|.
name|sched_nr
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|end
operator|-
operator|*
operator|(
name|a
operator|->
name|start
operator|)
operator|<
name|space
condition|)
return|return
name|DNHT_SCAN_END
return|;
name|o
operator|=
operator|(
expr|struct
name|dn_id
operator|*
operator|)
operator|(
operator|*
operator|(
name|a
operator|->
name|start
operator|)
operator|)
expr_stmt|;
name|o
operator|->
name|len
operator|=
name|space
expr_stmt|;
operator|*
name|a
operator|->
name|start
operator|+=
name|o
operator|->
name|len
expr_stmt|;
name|o
operator|->
name|type
operator|=
name|DN_TEXT
expr_stmt|;
name|p
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|o
operator|+
literal|1
operator|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|fs
argument_list|,
argument|&s->fsk_list
argument_list|,
argument|sch_chain
argument_list|)
if|if
condition|(
name|fs
operator|->
name|fs
operator|.
name|fs_nr
operator|<
name|DN_MAX_ID
condition|)
operator|*
name|p
operator|++
operator|=
name|fs
operator|->
name|fs
operator|.
name|fs_nr
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_data_helper
parameter_list|(
name|void
modifier|*
name|_o
parameter_list|,
name|void
modifier|*
name|_arg
parameter_list|)
block|{
name|struct
name|copy_args
modifier|*
name|a
init|=
name|_arg
decl_stmt|;
name|uint32_t
modifier|*
name|r
init|=
name|a
operator|->
name|extra
operator|->
name|r
decl_stmt|;
comment|/* start of first range */
name|uint32_t
modifier|*
name|lim
decl_stmt|;
comment|/* first invalid pointer */
name|int
name|n
decl_stmt|;
name|lim
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|a
operator|->
name|extra
operator|)
operator|+
name|a
operator|->
name|extra
operator|->
name|o
operator|.
name|len
operator|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|type
operator|==
name|DN_LINK
operator|||
name|a
operator|->
name|type
operator|==
name|DN_SCH
condition|)
block|{
comment|/* pipe|sched show, we receive a dn_schk */
name|struct
name|dn_schk
modifier|*
name|s
init|=
name|_o
decl_stmt|;
name|n
operator|=
name|s
operator|->
name|sch
operator|.
name|sched_nr
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|type
operator|==
name|DN_SCH
operator|&&
name|n
operator|>=
name|DN_MAX_ID
condition|)
return|return
literal|0
return|;
comment|/* not a scheduler */
if|if
condition|(
name|a
operator|->
name|type
operator|==
name|DN_LINK
operator|&&
name|n
operator|<=
name|DN_MAX_ID
condition|)
return|return
literal|0
return|;
comment|/* not a pipe */
comment|/* see if the object is within one of our ranges */
for|for
control|(
init|;
name|r
operator|<
name|lim
condition|;
name|r
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|n
operator|<
name|r
index|[
literal|0
index|]
operator|||
name|n
operator|>
name|r
index|[
literal|1
index|]
condition|)
continue|continue;
comment|/* Found a valid entry, copy and we are done */
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|DN_C_LINK
condition|)
block|{
if|if
condition|(
name|copy_obj
argument_list|(
name|a
operator|->
name|start
argument_list|,
name|a
operator|->
name|end
argument_list|,
operator|&
name|s
operator|->
name|link
argument_list|,
literal|"link"
argument_list|,
name|n
argument_list|)
condition|)
return|return
name|DNHT_SCAN_END
return|;
if|if
condition|(
name|copy_profile
argument_list|(
name|a
argument_list|,
name|s
operator|->
name|profile
argument_list|)
condition|)
return|return
name|DNHT_SCAN_END
return|;
if|if
condition|(
name|copy_flowset
argument_list|(
name|a
argument_list|,
name|s
operator|->
name|fs
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|DNHT_SCAN_END
return|;
block|}
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|DN_C_SCH
condition|)
block|{
if|if
condition|(
name|copy_obj
argument_list|(
name|a
operator|->
name|start
argument_list|,
name|a
operator|->
name|end
argument_list|,
operator|&
name|s
operator|->
name|sch
argument_list|,
literal|"sched"
argument_list|,
name|n
argument_list|)
condition|)
return|return
name|DNHT_SCAN_END
return|;
comment|/* list all attached flowsets */
if|if
condition|(
name|copy_fsk_list
argument_list|(
name|a
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|DNHT_SCAN_END
return|;
block|}
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|DN_C_FLOW
condition|)
name|copy_si
argument_list|(
name|a
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|type
operator|==
name|DN_FS
condition|)
block|{
comment|/* queue show, skip internal flowsets */
name|struct
name|dn_fsk
modifier|*
name|fs
init|=
name|_o
decl_stmt|;
name|n
operator|=
name|fs
operator|->
name|fs
operator|.
name|fs_nr
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|DN_MAX_ID
condition|)
return|return
literal|0
return|;
comment|/* see if the object is within one of our ranges */
for|for
control|(
init|;
name|r
operator|<
name|lim
condition|;
name|r
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|n
operator|<
name|r
index|[
literal|0
index|]
operator|||
name|n
operator|>
name|r
index|[
literal|1
index|]
condition|)
continue|continue;
if|if
condition|(
name|copy_flowset
argument_list|(
name|a
argument_list|,
name|fs
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|DNHT_SCAN_END
return|;
name|copy_q
argument_list|(
name|a
argument_list|,
name|fs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* we are done */
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|dn_schk
modifier|*
name|locate_scheduler
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|dn_ht_find
argument_list|(
name|dn_cfg
operator|.
name|schedhash
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * red parameters are in fixed point arithmetic.  */
end_comment

begin_function
specifier|static
name|int
name|config_red
parameter_list|(
name|struct
name|dn_fsk
modifier|*
name|fs
parameter_list|)
block|{
name|int64_t
name|s
decl_stmt|,
name|idle
decl_stmt|,
name|weight
decl_stmt|,
name|w0
decl_stmt|;
name|int
name|t
decl_stmt|,
name|i
decl_stmt|;
name|fs
operator|->
name|w_q
operator|=
name|fs
operator|->
name|fs
operator|.
name|w_q
expr_stmt|;
name|fs
operator|->
name|max_p
operator|=
name|fs
operator|->
name|fs
operator|.
name|max_p
expr_stmt|;
name|ND
argument_list|(
literal|"called"
argument_list|)
expr_stmt|;
comment|/* Doing stuff that was in userland */
name|i
operator|=
name|fs
operator|->
name|sched
operator|->
name|link
operator|.
name|bandwidth
expr_stmt|;
name|s
operator|=
operator|(
name|i
operator|<=
literal|0
operator|)
condition|?
literal|0
else|:
name|hz
operator|*
name|dn_cfg
operator|.
name|red_avg_pkt_size
operator|*
literal|8
operator|*
name|SCALE
argument_list|(
literal|1
argument_list|)
operator|/
name|i
expr_stmt|;
name|idle
operator|=
name|div64
argument_list|(
operator|(
name|s
operator|*
literal|3
operator|)
argument_list|,
name|fs
operator|->
name|w_q
argument_list|)
expr_stmt|;
comment|/* s, fs->w_q scaled; idle not scaled */
name|fs
operator|->
name|lookup_step
operator|=
name|div64
argument_list|(
name|idle
argument_list|,
name|dn_cfg
operator|.
name|red_lookup_depth
argument_list|)
expr_stmt|;
comment|/* fs->lookup_step not scaled, */
if|if
condition|(
operator|!
name|fs
operator|->
name|lookup_step
condition|)
name|fs
operator|->
name|lookup_step
operator|=
literal|1
expr_stmt|;
name|w0
operator|=
name|weight
operator|=
name|SCALE
argument_list|(
literal|1
argument_list|)
operator|-
name|fs
operator|->
name|w_q
expr_stmt|;
comment|//fs->w_q scaled
for|for
control|(
name|t
operator|=
name|fs
operator|->
name|lookup_step
init|;
name|t
operator|>
literal|1
condition|;
operator|--
name|t
control|)
name|weight
operator|=
name|SCALE_MUL
argument_list|(
name|weight
argument_list|,
name|w0
argument_list|)
expr_stmt|;
name|fs
operator|->
name|lookup_weight
operator|=
call|(
name|int
call|)
argument_list|(
name|weight
argument_list|)
expr_stmt|;
comment|// scaled
comment|/* Now doing stuff that was in kerneland */
name|fs
operator|->
name|min_th
operator|=
name|SCALE
argument_list|(
name|fs
operator|->
name|fs
operator|.
name|min_th
argument_list|)
expr_stmt|;
name|fs
operator|->
name|max_th
operator|=
name|SCALE
argument_list|(
name|fs
operator|->
name|fs
operator|.
name|max_th
argument_list|)
expr_stmt|;
name|fs
operator|->
name|c_1
operator|=
name|fs
operator|->
name|max_p
operator|/
operator|(
name|fs
operator|->
name|fs
operator|.
name|max_th
operator|-
name|fs
operator|->
name|fs
operator|.
name|min_th
operator|)
expr_stmt|;
name|fs
operator|->
name|c_2
operator|=
name|SCALE_MUL
argument_list|(
name|fs
operator|->
name|c_1
argument_list|,
name|SCALE
argument_list|(
name|fs
operator|->
name|fs
operator|.
name|min_th
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_IS_GENTLE_RED
condition|)
block|{
name|fs
operator|->
name|c_3
operator|=
operator|(
name|SCALE
argument_list|(
literal|1
argument_list|)
operator|-
name|fs
operator|->
name|max_p
operator|)
operator|/
name|fs
operator|->
name|fs
operator|.
name|max_th
expr_stmt|;
name|fs
operator|->
name|c_4
operator|=
name|SCALE
argument_list|(
literal|1
argument_list|)
operator|-
literal|2
operator|*
name|fs
operator|->
name|max_p
expr_stmt|;
block|}
comment|/* If the lookup table already exist, free and create it again. */
if|if
condition|(
name|fs
operator|->
name|w_q_lookup
condition|)
block|{
name|free
argument_list|(
name|fs
operator|->
name|w_q_lookup
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
name|fs
operator|->
name|w_q_lookup
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dn_cfg
operator|.
name|red_lookup_depth
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\ndummynet: net.inet.ip.dummynet.red_lookup_depth"
literal|"must be> 0\n"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&=
operator|~
name|DN_IS_RED
expr_stmt|;
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&=
operator|~
name|DN_IS_GENTLE_RED
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|fs
operator|->
name|lookup_depth
operator|=
name|dn_cfg
operator|.
name|red_lookup_depth
expr_stmt|;
name|fs
operator|->
name|w_q_lookup
operator|=
operator|(
name|u_int
operator|*
operator|)
name|malloc
argument_list|(
name|fs
operator|->
name|lookup_depth
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|M_DUMMYNET
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|w_q_lookup
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"dummynet: sorry, cannot allocate red lookup table\n"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&=
operator|~
name|DN_IS_RED
expr_stmt|;
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&=
operator|~
name|DN_IS_GENTLE_RED
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
comment|/* Fill the lookup table with (1 - w_q)^x */
name|fs
operator|->
name|w_q_lookup
index|[
literal|0
index|]
operator|=
name|SCALE
argument_list|(
literal|1
argument_list|)
operator|-
name|fs
operator|->
name|w_q
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|fs
operator|->
name|lookup_depth
condition|;
name|i
operator|++
control|)
name|fs
operator|->
name|w_q_lookup
index|[
name|i
index|]
operator|=
name|SCALE_MUL
argument_list|(
name|fs
operator|->
name|w_q_lookup
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|fs
operator|->
name|lookup_weight
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_cfg
operator|.
name|red_avg_pkt_size
operator|<
literal|1
condition|)
name|dn_cfg
operator|.
name|red_avg_pkt_size
operator|=
literal|512
expr_stmt|;
name|fs
operator|->
name|avg_pkt_size
operator|=
name|dn_cfg
operator|.
name|red_avg_pkt_size
expr_stmt|;
if|if
condition|(
name|dn_cfg
operator|.
name|red_max_pkt_size
operator|<
literal|1
condition|)
name|dn_cfg
operator|.
name|red_max_pkt_size
operator|=
literal|1500
expr_stmt|;
name|fs
operator|->
name|max_pkt_size
operator|=
name|dn_cfg
operator|.
name|red_max_pkt_size
expr_stmt|;
name|ND
argument_list|(
literal|"exit"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Scan all flowset attached to this scheduler and update red */
end_comment

begin_function
specifier|static
name|void
name|update_red
parameter_list|(
name|struct
name|dn_schk
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|dn_fsk
modifier|*
name|fs
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|fs
argument_list|,
argument|&s->fsk_list
argument_list|,
argument|sch_chain
argument_list|)
block|{
if|if
condition|(
name|fs
operator|&&
operator|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_IS_RED
operator|)
condition|)
name|config_red
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* attach flowset to scheduler s, possibly requeue */
end_comment

begin_function
specifier|static
name|void
name|fsk_attach
parameter_list|(
name|struct
name|dn_fsk
modifier|*
name|fs
parameter_list|,
name|struct
name|dn_schk
modifier|*
name|s
parameter_list|)
block|{
name|ND
argument_list|(
literal|"remove fs %d from fsunlinked, link to sched %d"
argument_list|,
name|fs
operator|->
name|fs
operator|.
name|fs_nr
argument_list|,
name|s
operator|->
name|sch
operator|.
name|sched_nr
argument_list|)
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|dn_cfg
operator|.
name|fsu
argument_list|,
name|fs
argument_list|,
name|dn_fsk
argument_list|,
name|sch_chain
argument_list|)
expr_stmt|;
name|fs
operator|->
name|sched
operator|=
name|s
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|s
operator|->
name|fsk_list
argument_list|,
name|fs
argument_list|,
name|sch_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fp
operator|->
name|new_fsk
condition|)
name|s
operator|->
name|fp
operator|->
name|new_fsk
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* XXX compute fsk_mask */
name|fs
operator|->
name|fsk_mask
operator|=
name|fs
operator|->
name|fs
operator|.
name|flow_mask
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|sched
operator|->
name|sch
operator|.
name|flags
operator|&
name|DN_HAVE_MASK
condition|)
name|flow_id_or
argument_list|(
operator|&
name|fs
operator|->
name|sched
operator|->
name|sch
operator|.
name|sched_mask
argument_list|,
operator|&
name|fs
operator|->
name|fsk_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|qht
condition|)
block|{
comment|/* 		 * we must drain qht according to the old 		 * type, and reinsert according to the new one. 		 * The requeue is complex -- in general we need to 		 * reclassify every single packet. 		 * For the time being, let's hope qht is never set 		 * when we reach this point. 		 */
name|D
argument_list|(
literal|"XXX TODO requeue from fs %d to sch %d"
argument_list|,
name|fs
operator|->
name|fs
operator|.
name|fs_nr
argument_list|,
name|s
operator|->
name|sch
operator|.
name|sched_nr
argument_list|)
expr_stmt|;
name|fs
operator|->
name|qht
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* set the new type for qht */
if|if
condition|(
name|nonzero_mask
argument_list|(
operator|&
name|fs
operator|->
name|fsk_mask
argument_list|)
condition|)
name|fs
operator|->
name|fs
operator|.
name|flags
operator||=
name|DN_QHT_HASH
expr_stmt|;
else|else
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&=
operator|~
name|DN_QHT_HASH
expr_stmt|;
comment|/* XXX config_red() can fail... */
if|if
condition|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_IS_RED
condition|)
name|config_red
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* update all flowsets which may refer to this scheduler */
end_comment

begin_function
specifier|static
name|void
name|update_fs
parameter_list|(
name|struct
name|dn_schk
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|dn_fsk
modifier|*
name|fs
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|SLIST_FOREACH_SAFE
argument_list|(
argument|fs
argument_list|,
argument|&dn_cfg.fsu
argument_list|,
argument|sch_chain
argument_list|,
argument|tmp
argument_list|)
block|{
if|if
condition|(
name|s
operator|->
name|sch
operator|.
name|sched_nr
operator|!=
name|fs
operator|->
name|fs
operator|.
name|sched_nr
condition|)
block|{
name|D
argument_list|(
literal|"fs %d for sch %d not %d still unlinked"
argument_list|,
name|fs
operator|->
name|fs
operator|.
name|fs_nr
argument_list|,
name|fs
operator|->
name|fs
operator|.
name|sched_nr
argument_list|,
name|s
operator|->
name|sch
operator|.
name|sched_nr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fsk_attach
argument_list|(
name|fs
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Configuration -- to preserve backward compatibility we use  * the following scheme (N is 65536)  *	NUMBER		SCHED	LINK	FLOWSET  *	   1 ..  N-1	(1)WFQ	(2)WFQ	(3)queue  *	 N+1 .. 2N-1	(4)FIFO (5)FIFO	(6)FIFO for sched 1..N-1  *	2N+1 .. 3N-1	--	--	(7)FIFO for sched N+1..2N-1  *  * "pipe i config" configures #1, #2 and #3  * "sched i config" configures #1 and possibly #6  * "queue i config" configures #3  * #1 is configured with 'pipe i config' or 'sched i config'  * #2 is configured with 'pipe i config', and created if not  *	existing with 'sched i config'  * #3 is configured with 'queue i config'  * #4 is automatically configured after #1, can only be FIFO  * #5 is automatically configured after #2  * #6 is automatically created when #1 is !MULTIQUEUE,  *	and can be updated.  * #7 is automatically configured after #2  */
end_comment

begin_comment
comment|/*  * configure a link (and its FIFO instance)  */
end_comment

begin_function
specifier|static
name|int
name|config_link
parameter_list|(
name|struct
name|dn_link
modifier|*
name|p
parameter_list|,
name|struct
name|dn_id
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|oid
operator|.
name|len
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"invalid pipe len %d"
argument_list|,
name|p
operator|->
name|oid
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|i
operator|=
name|p
operator|->
name|link_nr
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>=
name|DN_MAX_ID
condition|)
return|return
name|EINVAL
return|;
comment|/* 	 * The config program passes parameters as follows: 	 * bw = bits/second (0 means no limits), 	 * delay = ms, must be translated into ticks. 	 * qsize = slots/bytes 	 * burst ??? 	 */
name|p
operator|->
name|delay
operator|=
operator|(
name|p
operator|->
name|delay
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
comment|/* Scale burst size: bytes -> bits * hz */
name|p
operator|->
name|burst
operator|*=
literal|8
operator|*
name|hz
expr_stmt|;
name|DN_BH_WLOCK
argument_list|()
expr_stmt|;
comment|/* do it twice, base link and FIFO link */
for|for
control|(
init|;
name|i
operator|<
literal|2
operator|*
name|DN_MAX_ID
condition|;
name|i
operator|+=
name|DN_MAX_ID
control|)
block|{
name|struct
name|dn_schk
modifier|*
name|s
init|=
name|locate_scheduler
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
name|D
argument_list|(
literal|"sched %d not found"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* remove profile if exists */
if|if
condition|(
name|s
operator|->
name|profile
condition|)
block|{
name|free
argument_list|(
name|s
operator|->
name|profile
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
name|s
operator|->
name|profile
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* copy all parameters */
name|s
operator|->
name|link
operator|.
name|oid
operator|=
name|p
operator|->
name|oid
expr_stmt|;
name|s
operator|->
name|link
operator|.
name|link_nr
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|link
operator|.
name|delay
operator|=
name|p
operator|->
name|delay
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|link
operator|.
name|bandwidth
operator|!=
name|p
operator|->
name|bandwidth
condition|)
block|{
comment|/* XXX bandwidth changes, need to update red params */
name|s
operator|->
name|link
operator|.
name|bandwidth
operator|=
name|p
operator|->
name|bandwidth
expr_stmt|;
name|update_red
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|link
operator|.
name|burst
operator|=
name|p
operator|->
name|burst
expr_stmt|;
name|schk_reset_credit
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|dn_cfg
operator|.
name|id
operator|++
expr_stmt|;
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * configure a flowset. Can be called from inside with locked=1,  */
end_comment

begin_function
specifier|static
name|struct
name|dn_fsk
modifier|*
name|config_fs
parameter_list|(
name|struct
name|dn_fs
modifier|*
name|nfs
parameter_list|,
name|struct
name|dn_id
modifier|*
name|arg
parameter_list|,
name|int
name|locked
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|dn_fsk
modifier|*
name|fs
decl_stmt|;
if|if
condition|(
name|nfs
operator|->
name|oid
operator|.
name|len
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|nfs
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"invalid flowset len %d"
argument_list|,
name|nfs
operator|->
name|oid
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|i
operator|=
name|nfs
operator|->
name|fs_nr
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>=
literal|3
operator|*
name|DN_MAX_ID
condition|)
return|return
name|NULL
return|;
name|ND
argument_list|(
literal|"flowset %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* XXX other sanity checks */
if|if
condition|(
name|nfs
operator|->
name|flags
operator|&
name|DN_QSIZE_BYTES
condition|)
block|{
name|ipdn_bound_var
argument_list|(
operator|&
name|nfs
operator|->
name|qsize
argument_list|,
literal|16384
argument_list|,
literal|1500
argument_list|,
name|dn_cfg
operator|.
name|byte_limit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|// "queue byte size");
block|}
else|else
block|{
name|ipdn_bound_var
argument_list|(
operator|&
name|nfs
operator|->
name|qsize
argument_list|,
literal|50
argument_list|,
literal|1
argument_list|,
name|dn_cfg
operator|.
name|slot_limit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|// "queue slot size");
block|}
if|if
condition|(
name|nfs
operator|->
name|flags
operator|&
name|DN_HAVE_MASK
condition|)
block|{
comment|/* make sure we have some buckets */
name|ipdn_bound_var
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|&
name|nfs
operator|->
name|buckets
argument_list|,
name|dn_cfg
operator|.
name|hash_size
argument_list|,
literal|1
argument_list|,
name|dn_cfg
operator|.
name|max_hash_size
argument_list|,
literal|"flowset buckets"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfs
operator|->
name|buckets
operator|=
literal|1
expr_stmt|;
comment|/* we only need 1 */
block|}
if|if
condition|(
operator|!
name|locked
condition|)
name|DN_BH_WLOCK
argument_list|()
expr_stmt|;
do|do
block|{
comment|/* exit with break when done */
name|struct
name|dn_schk
modifier|*
name|s
decl_stmt|;
name|int
name|flags
init|=
name|nfs
operator|->
name|sched_nr
condition|?
name|DNHT_INSERT
else|:
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|oldc
init|=
name|dn_cfg
operator|.
name|fsk_count
decl_stmt|;
name|fs
operator|=
name|dn_ht_find
argument_list|(
name|dn_cfg
operator|.
name|fshash
argument_list|,
name|i
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"missing sched for flowset %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* grab some defaults from the existing one */
if|if
condition|(
name|nfs
operator|->
name|sched_nr
operator|==
literal|0
condition|)
comment|/* reuse */
name|nfs
operator|->
name|sched_nr
operator|=
name|fs
operator|->
name|fs
operator|.
name|sched_nr
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|nfs
operator|->
name|par
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|nfs
operator|->
name|par
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|nfs
operator|->
name|par
index|[
name|j
index|]
operator|==
operator|-
literal|1
condition|)
comment|/* reuse */
name|nfs
operator|->
name|par
index|[
name|j
index|]
operator|=
name|fs
operator|->
name|fs
operator|.
name|par
index|[
name|j
index|]
expr_stmt|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|fs
operator|->
name|fs
argument_list|,
name|nfs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nfs
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ND
argument_list|(
literal|"flowset %d unchanged"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
comment|/* no change, nothing to do */
block|}
if|if
condition|(
name|oldc
operator|!=
name|dn_cfg
operator|.
name|fsk_count
condition|)
comment|/* new item */
name|dn_cfg
operator|.
name|id
operator|++
expr_stmt|;
name|s
operator|=
name|locate_scheduler
argument_list|(
name|nfs
operator|->
name|sched_nr
argument_list|)
expr_stmt|;
comment|/* detach from old scheduler if needed, preserving 	     * queues if we need to reattach. Then update the 	     * configuration, and possibly attach to the new sched. 	     */
name|DX
argument_list|(
literal|2
argument_list|,
literal|"fs %d changed sched %d@%p to %d@%p"
argument_list|,
name|fs
operator|->
name|fs
operator|.
name|fs_nr
argument_list|,
name|fs
operator|->
name|fs
operator|.
name|sched_nr
argument_list|,
name|fs
operator|->
name|sched
argument_list|,
name|nfs
operator|->
name|sched_nr
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|sched
condition|)
block|{
name|int
name|flags
init|=
name|s
condition|?
name|DN_DETACH
else|:
operator|(
name|DN_DETACH
operator||
name|DN_DESTROY
operator|)
decl_stmt|;
name|flags
operator||=
name|DN_DESTROY
expr_stmt|;
comment|/* XXX temporary */
name|fsk_detach
argument_list|(
name|fs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|fs
operator|->
name|fs
operator|=
operator|*
name|nfs
expr_stmt|;
comment|/* copy configuration */
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|fsk_attach
argument_list|(
name|fs
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
operator|!
name|locked
condition|)
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
return|return
name|fs
return|;
block|}
end_function

begin_comment
comment|/*  * config/reconfig a scheduler and its FIFO variant.  * For !MULTIQUEUE schedulers, also set up the flowset.  *  * On reconfigurations (detected because s->fp is set),  * detach existing flowsets preserving traffic, preserve link,  * and delete the old scheduler creating a new one.  */
end_comment

begin_function
specifier|static
name|int
name|config_sched
parameter_list|(
name|struct
name|dn_sch
modifier|*
name|_nsch
parameter_list|,
name|struct
name|dn_id
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_schk
modifier|*
name|s
decl_stmt|;
name|struct
name|schk_new_arg
name|a
decl_stmt|;
comment|/* argument for schk_new */
name|int
name|i
decl_stmt|;
name|struct
name|dn_link
name|p
decl_stmt|;
comment|/* copy of oldlink */
name|struct
name|dn_profile
modifier|*
name|pf
init|=
name|NULL
decl_stmt|;
comment|/* copy of old link profile */
comment|/* Used to preserv mask parameter */
name|struct
name|ipfw_flow_id
name|new_mask
decl_stmt|;
name|int
name|new_buckets
init|=
literal|0
decl_stmt|;
name|int
name|new_flags
init|=
literal|0
decl_stmt|;
name|int
name|pipe_cmd
decl_stmt|;
name|int
name|err
init|=
name|ENOMEM
decl_stmt|;
name|a
operator|.
name|sch
operator|=
name|_nsch
expr_stmt|;
if|if
condition|(
name|a
operator|.
name|sch
operator|->
name|oid
operator|.
name|len
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|a
operator|.
name|sch
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"bad sched len %d"
argument_list|,
name|a
operator|.
name|sch
operator|->
name|oid
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|i
operator|=
name|a
operator|.
name|sch
operator|->
name|sched_nr
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>=
name|DN_MAX_ID
condition|)
return|return
name|EINVAL
return|;
comment|/* make sure we have some buckets */
if|if
condition|(
name|a
operator|.
name|sch
operator|->
name|flags
operator|&
name|DN_HAVE_MASK
condition|)
name|ipdn_bound_var
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|&
name|a
operator|.
name|sch
operator|->
name|buckets
argument_list|,
name|dn_cfg
operator|.
name|hash_size
argument_list|,
literal|1
argument_list|,
name|dn_cfg
operator|.
name|max_hash_size
argument_list|,
literal|"sched buckets"
argument_list|)
expr_stmt|;
comment|/* XXX other sanity checks */
name|bzero
argument_list|(
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|pipe_cmd
operator|=
name|a
operator|.
name|sch
operator|->
name|flags
operator|&
name|DN_PIPE_CMD
expr_stmt|;
name|a
operator|.
name|sch
operator|->
name|flags
operator|&=
operator|~
name|DN_PIPE_CMD
expr_stmt|;
comment|//XXX do it even if is not set?
if|if
condition|(
name|pipe_cmd
condition|)
block|{
comment|/* Copy mask parameter */
name|new_mask
operator|=
name|a
operator|.
name|sch
operator|->
name|sched_mask
expr_stmt|;
name|new_buckets
operator|=
name|a
operator|.
name|sch
operator|->
name|buckets
expr_stmt|;
name|new_flags
operator|=
name|a
operator|.
name|sch
operator|->
name|flags
expr_stmt|;
block|}
name|DN_BH_WLOCK
argument_list|()
expr_stmt|;
name|again
label|:
comment|/* run twice, for wfq and fifo */
comment|/* 	 * lookup the type. If not supplied, use the previous one 	 * or default to WF2Q+. Otherwise, return an error. 	 */
name|dn_cfg
operator|.
name|id
operator|++
expr_stmt|;
name|a
operator|.
name|fp
operator|=
name|find_sched_type
argument_list|(
name|a
operator|.
name|sch
operator|->
name|oid
operator|.
name|subtype
argument_list|,
name|a
operator|.
name|sch
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
comment|/* found. Lookup or create entry */
name|s
operator|=
name|dn_ht_find
argument_list|(
name|dn_cfg
operator|.
name|schedhash
argument_list|,
name|i
argument_list|,
name|DNHT_INSERT
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|.
name|sch
operator|->
name|oid
operator|.
name|subtype
operator|==
literal|0
operator|&&
operator|!
name|a
operator|.
name|sch
operator|->
name|name
index|[
literal|0
index|]
condition|)
block|{
comment|/* No type. search existing s* or retry with WF2Q+ */
name|s
operator|=
name|dn_ht_find
argument_list|(
name|dn_cfg
operator|.
name|schedhash
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|a
operator|.
name|fp
operator|=
name|s
operator|->
name|fp
expr_stmt|;
comment|/* Scheduler exists, skip to FIFO scheduler  			 * if command was pipe config... 			 */
if|if
condition|(
name|pipe_cmd
condition|)
goto|goto
name|next
goto|;
block|}
else|else
block|{
comment|/* New scheduler, create a wf2q+ with no mask 			 * if command was pipe config... 			 */
if|if
condition|(
name|pipe_cmd
condition|)
block|{
comment|/* clear mask parameter */
name|bzero
argument_list|(
operator|&
name|a
operator|.
name|sch
operator|->
name|sched_mask
argument_list|,
sizeof|sizeof
argument_list|(
name|new_mask
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|.
name|sch
operator|->
name|buckets
operator|=
literal|0
expr_stmt|;
name|a
operator|.
name|sch
operator|->
name|flags
operator|&=
operator|~
name|DN_HAVE_MASK
expr_stmt|;
block|}
name|a
operator|.
name|sch
operator|->
name|oid
operator|.
name|subtype
operator|=
name|DN_SCHED_WF2QP
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
else|else
block|{
name|D
argument_list|(
literal|"invalid scheduler type %d %s"
argument_list|,
name|a
operator|.
name|sch
operator|->
name|oid
operator|.
name|subtype
argument_list|,
name|a
operator|.
name|sch
operator|->
name|name
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* normalize name and subtype */
name|a
operator|.
name|sch
operator|->
name|oid
operator|.
name|subtype
operator|=
name|a
operator|.
name|fp
operator|->
name|type
expr_stmt|;
name|bzero
argument_list|(
name|a
operator|.
name|sch
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|a
operator|.
name|sch
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|a
operator|.
name|sch
operator|->
name|name
argument_list|,
name|a
operator|.
name|fp
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|a
operator|.
name|sch
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"cannot allocate scheduler %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* restore existing link if any */
if|if
condition|(
name|p
operator|.
name|link_nr
condition|)
block|{
name|s
operator|->
name|link
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|pf
operator|||
name|pf
operator|->
name|link_nr
operator|!=
name|p
operator|.
name|link_nr
condition|)
block|{
comment|/* no saved value */
name|s
operator|->
name|profile
operator|=
name|NULL
expr_stmt|;
comment|/* XXX maybe not needed */
block|}
else|else
block|{
name|s
operator|->
name|profile
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dn_profile
argument_list|)
argument_list|,
name|M_DUMMYNET
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|profile
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"cannot allocate profile"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
comment|//XXX
block|}
name|bcopy
argument_list|(
name|pf
argument_list|,
name|s
operator|->
name|profile
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|.
name|link_nr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fp
operator|==
name|NULL
condition|)
block|{
name|DX
argument_list|(
literal|2
argument_list|,
literal|"sched %d new type %s"
argument_list|,
name|i
argument_list|,
name|a
operator|.
name|fp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|fp
operator|!=
name|a
operator|.
name|fp
operator|||
name|bcmp
argument_list|(
name|a
operator|.
name|sch
argument_list|,
operator|&
name|s
operator|->
name|sch
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
operator|.
name|sch
argument_list|)
argument_list|)
condition|)
block|{
comment|/* already existing. */
name|DX
argument_list|(
literal|2
argument_list|,
literal|"sched %d type changed from %s to %s"
argument_list|,
name|i
argument_list|,
name|s
operator|->
name|fp
operator|->
name|name
argument_list|,
name|a
operator|.
name|fp
operator|->
name|name
argument_list|)
expr_stmt|;
name|DX
argument_list|(
literal|4
argument_list|,
literal|"   type/sub %d/%d -> %d/%d"
argument_list|,
name|s
operator|->
name|sch
operator|.
name|oid
operator|.
name|type
argument_list|,
name|s
operator|->
name|sch
operator|.
name|oid
operator|.
name|subtype
argument_list|,
name|a
operator|.
name|sch
operator|->
name|oid
operator|.
name|type
argument_list|,
name|a
operator|.
name|sch
operator|->
name|oid
operator|.
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|link
operator|.
name|link_nr
operator|==
literal|0
condition|)
name|D
argument_list|(
literal|"XXX WARNING link 0 for sched %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
name|s
operator|->
name|link
expr_stmt|;
comment|/* preserve link */
if|if
condition|(
name|s
operator|->
name|profile
condition|)
block|{
comment|/* preserve profile */
if|if
condition|(
operator|!
name|pf
condition|)
name|pf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pf
argument_list|)
argument_list|,
name|M_DUMMYNET
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
condition|)
comment|/* XXX should issue a warning otherwise */
name|bcopy
argument_list|(
name|s
operator|->
name|profile
argument_list|,
name|pf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* remove from the hash */
name|dn_ht_find
argument_list|(
name|dn_cfg
operator|.
name|schedhash
argument_list|,
name|i
argument_list|,
name|DNHT_REMOVE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Detach flowsets, preserve queues. */
comment|// schk_delete_cb(s, NULL);
comment|// XXX temporarily, kill queues
name|schk_delete_cb
argument_list|(
name|s
argument_list|,
operator|(
name|void
operator|*
operator|)
name|DN_DESTROY
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
else|else
block|{
name|DX
argument_list|(
literal|4
argument_list|,
literal|"sched %d unchanged type %s"
argument_list|,
name|i
argument_list|,
name|a
operator|.
name|fp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* complete initialization */
name|s
operator|->
name|sch
operator|=
operator|*
name|a
operator|.
name|sch
expr_stmt|;
name|s
operator|->
name|fp
operator|=
name|a
operator|.
name|fp
expr_stmt|;
name|s
operator|->
name|cfg
operator|=
name|arg
expr_stmt|;
comment|// XXX schk_reset_credit(s);
comment|/* create the internal flowset if needed, 	 * trying to reuse existing ones if available 	 */
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|fp
operator|->
name|flags
operator|&
name|DN_MULTIQUEUE
operator|)
operator|&&
operator|!
name|s
operator|->
name|fs
condition|)
block|{
name|s
operator|->
name|fs
operator|=
name|dn_ht_find
argument_list|(
name|dn_cfg
operator|.
name|fshash
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|fs
condition|)
block|{
name|struct
name|dn_fs
name|fs
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|fs
argument_list|,
sizeof|sizeof
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
name|set_oid
argument_list|(
operator|&
name|fs
operator|.
name|oid
argument_list|,
name|DN_FS
argument_list|,
sizeof|sizeof
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|fs_nr
operator|=
name|i
operator|+
name|DN_MAX_ID
expr_stmt|;
name|fs
operator|.
name|sched_nr
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|fs
operator|=
name|config_fs
argument_list|(
operator|&
name|fs
argument_list|,
name|NULL
argument_list|,
literal|1
comment|/* locked */
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|fs
condition|)
block|{
name|schk_delete_cb
argument_list|(
name|s
argument_list|,
operator|(
name|void
operator|*
operator|)
name|DN_DESTROY
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"error creating internal fs for %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|/* call init function after the flowset is created */
if|if
condition|(
name|s
operator|->
name|fp
operator|->
name|config
condition|)
name|s
operator|->
name|fp
operator|->
name|config
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|update_fs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|next
label|:
if|if
condition|(
name|i
operator|<
name|DN_MAX_ID
condition|)
block|{
comment|/* now configure the FIFO instance */
name|i
operator|+=
name|DN_MAX_ID
expr_stmt|;
if|if
condition|(
name|pipe_cmd
condition|)
block|{
comment|/* Restore mask parameter for FIFO */
name|a
operator|.
name|sch
operator|->
name|sched_mask
operator|=
name|new_mask
expr_stmt|;
name|a
operator|.
name|sch
operator|->
name|buckets
operator|=
name|new_buckets
expr_stmt|;
name|a
operator|.
name|sch
operator|->
name|flags
operator|=
name|new_flags
expr_stmt|;
block|}
else|else
block|{
comment|/* sched config shouldn't modify the FIFO scheduler */
if|if
condition|(
name|dn_ht_find
argument_list|(
name|dn_cfg
operator|.
name|schedhash
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
operator|&
name|a
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* FIFO already exist, don't touch it */
name|err
operator|=
literal|0
expr_stmt|;
comment|/* and this is not an error */
goto|goto
name|error
goto|;
block|}
block|}
name|a
operator|.
name|sch
operator|->
name|sched_nr
operator|=
name|i
expr_stmt|;
name|a
operator|.
name|sch
operator|->
name|oid
operator|.
name|subtype
operator|=
name|DN_SCHED_FIFO
expr_stmt|;
name|bzero
argument_list|(
name|a
operator|.
name|sch
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|a
operator|.
name|sch
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|err
operator|=
literal|0
expr_stmt|;
name|error
label|:
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|pf
condition|)
name|free
argument_list|(
name|pf
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * attach a profile to a link  */
end_comment

begin_function
specifier|static
name|int
name|config_profile
parameter_list|(
name|struct
name|dn_profile
modifier|*
name|pf
parameter_list|,
name|struct
name|dn_id
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_schk
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|olen
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pf
operator|->
name|oid
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|pf
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"short profile len %d"
argument_list|,
name|pf
operator|->
name|oid
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|i
operator|=
name|pf
operator|->
name|link_nr
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>=
name|DN_MAX_ID
condition|)
return|return
name|EINVAL
return|;
comment|/* XXX other sanity checks */
name|DN_BH_WLOCK
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|2
operator|*
name|DN_MAX_ID
condition|;
name|i
operator|+=
name|DN_MAX_ID
control|)
block|{
name|s
operator|=
name|locate_scheduler
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|dn_cfg
operator|.
name|id
operator|++
expr_stmt|;
comment|/* 		 * If we had a profile and the new one does not fit, 		 * or it is deleted, then we need to free memory. 		 */
if|if
condition|(
name|s
operator|->
name|profile
operator|&&
operator|(
name|pf
operator|->
name|samples_no
operator|==
literal|0
operator|||
name|s
operator|->
name|profile
operator|->
name|oid
operator|.
name|len
operator|<
name|pf
operator|->
name|oid
operator|.
name|len
operator|)
condition|)
block|{
name|free
argument_list|(
name|s
operator|->
name|profile
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
name|s
operator|->
name|profile
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|->
name|samples_no
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * new profile, possibly allocate memory 		 * and copy data. 		 */
if|if
condition|(
name|s
operator|->
name|profile
operator|==
name|NULL
condition|)
name|s
operator|->
name|profile
operator|=
name|malloc
argument_list|(
name|pf
operator|->
name|oid
operator|.
name|len
argument_list|,
name|M_DUMMYNET
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|profile
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"no memory for profile %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
comment|/* preserve larger length XXX double check */
name|olen
operator|=
name|s
operator|->
name|profile
operator|->
name|oid
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|olen
operator|<
name|pf
operator|->
name|oid
operator|.
name|len
condition|)
name|olen
operator|=
name|pf
operator|->
name|oid
operator|.
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|pf
argument_list|,
name|s
operator|->
name|profile
argument_list|,
name|pf
operator|->
name|oid
operator|.
name|len
argument_list|)
expr_stmt|;
name|s
operator|->
name|profile
operator|->
name|oid
operator|.
name|len
operator|=
name|olen
expr_stmt|;
block|}
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * Delete all objects:  */
end_comment

begin_function
specifier|static
name|void
name|dummynet_flush
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* delete all schedulers and related links/queues/flowsets */
name|dn_ht_scan
argument_list|(
name|dn_cfg
operator|.
name|schedhash
argument_list|,
name|schk_delete_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|DN_DELETE_FS
argument_list|)
expr_stmt|;
comment|/* delete all remaining (unlinked) flowsets */
name|DX
argument_list|(
literal|4
argument_list|,
literal|"still %d unlinked fs"
argument_list|,
name|dn_cfg
operator|.
name|fsk_count
argument_list|)
expr_stmt|;
name|dn_ht_free
argument_list|(
name|dn_cfg
operator|.
name|fshash
argument_list|,
name|DNHT_REMOVE
argument_list|)
expr_stmt|;
name|fsk_detach_list
argument_list|(
operator|&
name|dn_cfg
operator|.
name|fsu
argument_list|,
name|DN_DELETE_FS
argument_list|)
expr_stmt|;
comment|/* Reinitialize system heap... */
name|heap_init
argument_list|(
operator|&
name|dn_cfg
operator|.
name|evheap
argument_list|,
literal|16
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|dn_id
argument_list|,
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Main handler for configuration. We are guaranteed to be called  * with an oid which is at least a dn_id.  * - the first object is the command (config, delete, flush, ...)  * - config_link must be issued after the corresponding config_sched  * - parameters (DN_TXT) for an object must preceed the object  *   processed on a config_sched.  */
end_comment

begin_function
name|int
name|do_config
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|struct
name|dn_id
modifier|*
name|next
decl_stmt|,
modifier|*
name|o
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|err2
init|=
literal|0
decl_stmt|;
name|struct
name|dn_id
modifier|*
name|arg
init|=
name|NULL
decl_stmt|;
name|uintptr_t
modifier|*
name|a
decl_stmt|;
name|o
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|id
operator|!=
name|DN_API_VERSION
condition|)
block|{
name|D
argument_list|(
literal|"invalid api version got %d need %d"
argument_list|,
name|o
operator|->
name|id
argument_list|,
name|DN_API_VERSION
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
for|for
control|(
init|;
name|l
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|o
argument_list|)
condition|;
name|o
operator|=
name|next
control|)
block|{
name|struct
name|dn_id
modifier|*
name|prev
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|o
argument_list|)
operator|||
name|l
operator|<
name|o
operator|->
name|len
condition|)
block|{
name|D
argument_list|(
literal|"bad len o->len %d len %d"
argument_list|,
name|o
operator|->
name|len
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|l
operator|-=
name|o
operator|->
name|len
expr_stmt|;
name|next
operator|=
operator|(
expr|struct
name|dn_id
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|o
operator|+
name|o
operator|->
name|len
operator|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|o
operator|->
name|type
condition|)
block|{
default|default:
name|D
argument_list|(
literal|"cmd %d not implemented"
argument_list|,
name|o
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|EMULATE_SYSCTL
comment|/* sysctl emulation. 		 * if we recognize the command, jump to the correct 		 * handler and return 		 */
case|case
name|DN_SYSCTL_SET
case|:
name|err
operator|=
name|kesysctl_emu_set
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|err
return|;
endif|#
directive|endif
case|case
name|DN_CMD_CONFIG
case|:
comment|/* simply a header */
break|break;
case|case
name|DN_CMD_DELETE
case|:
comment|/* the argument is in the first uintptr_t after o */
name|a
operator|=
operator|(
name|uintptr_t
operator|*
operator|)
operator|(
name|o
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|o
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|o
operator|->
name|subtype
condition|)
block|{
case|case
name|DN_LINK
case|:
comment|/* delete base and derived schedulers */
name|DN_BH_WLOCK
argument_list|()
expr_stmt|;
name|err
operator|=
name|delete_schk
argument_list|(
operator|*
name|a
argument_list|)
expr_stmt|;
name|err2
operator|=
name|delete_schk
argument_list|(
operator|*
name|a
operator|+
name|DN_MAX_ID
argument_list|)
expr_stmt|;
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|err2
expr_stmt|;
break|break;
default|default:
name|D
argument_list|(
literal|"invalid delete type %d"
argument_list|,
name|o
operator|->
name|subtype
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|DN_FS
case|:
name|err
operator|=
operator|(
operator|*
name|a
operator|<
literal|1
operator|||
operator|*
name|a
operator|>=
name|DN_MAX_ID
operator|)
condition|?
name|EINVAL
else|:
name|delete_fs
argument_list|(
operator|*
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DN_CMD_FLUSH
case|:
name|DN_BH_WLOCK
argument_list|()
expr_stmt|;
name|dummynet_flush
argument_list|()
expr_stmt|;
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|DN_TEXT
case|:
comment|/* store argument the next block */
name|prev
operator|=
name|NULL
expr_stmt|;
name|arg
operator|=
name|o
expr_stmt|;
break|break;
case|case
name|DN_LINK
case|:
name|err
operator|=
name|config_link
argument_list|(
operator|(
expr|struct
name|dn_link
operator|*
operator|)
name|o
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DN_PROFILE
case|:
name|err
operator|=
name|config_profile
argument_list|(
operator|(
expr|struct
name|dn_profile
operator|*
operator|)
name|o
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DN_SCH
case|:
name|err
operator|=
name|config_sched
argument_list|(
operator|(
expr|struct
name|dn_sch
operator|*
operator|)
name|o
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DN_FS
case|:
name|err
operator|=
operator|(
name|NULL
operator|==
name|config_fs
argument_list|(
operator|(
expr|struct
name|dn_fs
operator|*
operator|)
name|o
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|prev
condition|)
name|arg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compute_space
parameter_list|(
name|struct
name|dn_id
modifier|*
name|cmd
parameter_list|,
name|struct
name|copy_args
modifier|*
name|a
parameter_list|)
block|{
name|int
name|x
init|=
literal|0
decl_stmt|,
name|need
init|=
literal|0
decl_stmt|;
name|int
name|profile_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_profile
argument_list|)
operator|-
name|ED_MAX_SAMPLES_NO
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* NOTE about compute space: 	 * NP 	= dn_cfg.schk_count 	 * NSI 	= dn_cfg.si_count 	 * NF 	= dn_cfg.fsk_count 	 * NQ 	= dn_cfg.queue_count 	 * - ipfw pipe show 	 *   (NP/2)*(dn_link + dn_sch + dn_id + dn_fs) only half scheduler 	 *                             link, scheduler template, flowset 	 *                             integrated in scheduler and header 	 *                             for flowset list 	 *   (NSI)*(dn_flow) all scheduler instance (includes 	 *                              the queue instance) 	 * - ipfw sched show 	 *   (NP/2)*(dn_link + dn_sch + dn_id + dn_fs) only half scheduler 	 *                             link, scheduler template, flowset 	 *                             integrated in scheduler and header 	 *                             for flowset list 	 *   (NSI * dn_flow) all scheduler instances 	 *   (NF * sizeof(uint_32)) space for flowset list linked to scheduler 	 *   (NQ * dn_queue) all queue [XXXfor now not listed] 	 * - ipfw queue show 	 *   (NF * dn_fs) all flowset 	 *   (NQ * dn_queue) all queues 	 */
switch|switch
condition|(
name|cmd
operator|->
name|subtype
condition|)
block|{
default|default:
return|return
operator|-
literal|1
return|;
comment|/* XXX where do LINK and SCH differ ? */
comment|/* 'ipfw sched show' could list all queues associated to 	 * a scheduler. This feature for now is disabled 	 */
case|case
name|DN_LINK
case|:
comment|/* pipe show */
name|x
operator|=
name|DN_C_LINK
operator||
name|DN_C_SCH
operator||
name|DN_C_FLOW
expr_stmt|;
name|need
operator|+=
name|dn_cfg
operator|.
name|schk_count
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|dn_fs
argument_list|)
operator|+
name|profile_size
operator|)
operator|/
literal|2
expr_stmt|;
name|need
operator|+=
name|dn_cfg
operator|.
name|fsk_count
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DN_SCH
case|:
comment|/* sched show */
name|need
operator|+=
name|dn_cfg
operator|.
name|schk_count
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|dn_fs
argument_list|)
operator|+
name|profile_size
operator|)
operator|/
literal|2
expr_stmt|;
name|need
operator|+=
name|dn_cfg
operator|.
name|fsk_count
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|x
operator|=
name|DN_C_SCH
operator||
name|DN_C_LINK
operator||
name|DN_C_FLOW
expr_stmt|;
break|break;
case|case
name|DN_FS
case|:
comment|/* queue show */
name|x
operator|=
name|DN_C_FS
operator||
name|DN_C_QUEUE
expr_stmt|;
break|break;
case|case
name|DN_GET_COMPAT
case|:
comment|/* compatibility mode */
name|need
operator|=
name|dn_compat_calc_size
argument_list|()
expr_stmt|;
break|break;
block|}
name|a
operator|->
name|flags
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|DN_C_SCH
condition|)
block|{
name|need
operator|+=
name|dn_cfg
operator|.
name|schk_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dn_sch
argument_list|)
operator|/
literal|2
expr_stmt|;
comment|/* NOT also, each fs might be attached to a sched */
name|need
operator|+=
name|dn_cfg
operator|.
name|schk_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dn_id
argument_list|)
operator|/
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|&
name|DN_C_FS
condition|)
name|need
operator|+=
name|dn_cfg
operator|.
name|fsk_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dn_fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|DN_C_LINK
condition|)
block|{
name|need
operator|+=
name|dn_cfg
operator|.
name|schk_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dn_link
argument_list|)
operator|/
literal|2
expr_stmt|;
block|}
comment|/* 	 * When exporting a queue to userland, only pass up the 	 * struct dn_flow, which is the only visible part. 	 */
if|if
condition|(
name|x
operator|&
name|DN_C_QUEUE
condition|)
name|need
operator|+=
name|dn_cfg
operator|.
name|queue_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|DN_C_FLOW
condition|)
name|need
operator|+=
name|dn_cfg
operator|.
name|si_count
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow
argument_list|)
operator|)
expr_stmt|;
return|return
name|need
return|;
block|}
end_function

begin_comment
comment|/*  * If compat != NULL dummynet_get is called in compatibility mode.  * *compat will be the pointer to the buffer to pass to ipfw  */
end_comment

begin_function
name|int
name|dummynet_get
parameter_list|(
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|,
name|void
modifier|*
modifier|*
name|compat
parameter_list|)
block|{
name|int
name|have
decl_stmt|,
name|i
decl_stmt|,
name|need
decl_stmt|,
name|error
decl_stmt|;
name|char
modifier|*
name|start
init|=
name|NULL
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|size_t
name|sopt_valsize
decl_stmt|;
name|struct
name|dn_id
modifier|*
name|cmd
decl_stmt|;
name|struct
name|copy_args
name|a
decl_stmt|;
name|struct
name|copy_range
name|r
decl_stmt|;
name|int
name|l
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_id
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save and restore original sopt_valsize around copyin */
name|sopt_valsize
operator|=
name|sopt
operator|->
name|sopt_valsize
expr_stmt|;
name|cmd
operator|=
operator|&
name|r
operator|.
name|o
expr_stmt|;
if|if
condition|(
operator|!
name|compat
condition|)
block|{
comment|/* copy at least an oid, and possibly a full object */
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|sopt
operator|->
name|sopt_valsize
operator|=
name|sopt_valsize
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|l
operator|=
name|cmd
operator|->
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|EMULATE_SYSCTL
comment|/* sysctl emulation. */
if|if
condition|(
name|cmd
operator|->
name|type
operator|==
name|DN_SYSCTL_GET
condition|)
return|return
name|kesysctl_emu_get
argument_list|(
name|sopt
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* request larger than default, allocate buffer */
name|cmd
operator|=
name|malloc
argument_list|(
name|l
argument_list|,
name|M_DUMMYNET
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
name|cmd
argument_list|,
name|l
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|sopt
operator|->
name|sopt_valsize
operator|=
name|sopt_valsize
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
comment|/* compatibility */
name|error
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|type
operator|=
name|DN_CMD_GET
expr_stmt|;
name|cmd
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_id
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|subtype
operator|=
name|DN_GET_COMPAT
expr_stmt|;
comment|// cmd->id = sopt_valsize;
name|D
argument_list|(
literal|"compatibility mode"
argument_list|)
expr_stmt|;
block|}
name|a
operator|.
name|extra
operator|=
operator|(
expr|struct
name|copy_range
operator|*
operator|)
name|cmd
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|len
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
condition|)
block|{
comment|/* no range, create a default */
name|uint32_t
modifier|*
name|rp
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|cmd
operator|+
literal|1
operator|)
decl_stmt|;
name|cmd
operator|->
name|len
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|rp
index|[
literal|1
index|]
operator|=
name|DN_MAX_ID
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|subtype
operator|==
name|DN_LINK
condition|)
block|{
name|rp
index|[
literal|0
index|]
operator|+=
name|DN_MAX_ID
expr_stmt|;
name|rp
index|[
literal|1
index|]
operator|+=
name|DN_MAX_ID
expr_stmt|;
block|}
block|}
comment|/* Count space (under lock) and allocate (outside lock). 	 * Exit with lock held if we manage to get enough buffer. 	 * Try a few times then give up. 	 */
for|for
control|(
name|have
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|DN_BH_WLOCK
argument_list|()
expr_stmt|;
name|need
operator|=
name|compute_space
argument_list|(
name|cmd
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
comment|/* if there is a range, ignore value from compute_space() */
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
condition|)
name|need
operator|=
name|sopt_valsize
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|need
operator|<
literal|0
condition|)
block|{
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|need
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|id
operator|=
name|need
expr_stmt|;
if|if
condition|(
name|have
operator|>=
name|need
condition|)
break|break;
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|start
condition|)
name|free
argument_list|(
name|start
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
name|start
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|need
operator|>
name|sopt_valsize
condition|)
break|break;
name|have
operator|=
name|need
expr_stmt|;
name|start
operator|=
name|malloc
argument_list|(
name|have
argument_list|,
name|M_DUMMYNET
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|compat
condition|)
block|{
operator|*
name|compat
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
comment|// XXX
block|}
else|else
block|{
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|ND
argument_list|(
literal|"have %d:%d sched %d, %d:%d links %d, %d:%d flowsets %d, "
literal|"%d:%d si %d, %d:%d queues %d"
argument_list|,
name|dn_cfg
operator|.
name|schk_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dn_sch
argument_list|)
argument_list|,
name|DN_SCH
argument_list|,
name|dn_cfg
operator|.
name|schk_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dn_link
argument_list|)
argument_list|,
name|DN_LINK
argument_list|,
name|dn_cfg
operator|.
name|fsk_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dn_fs
argument_list|)
argument_list|,
name|DN_FS
argument_list|,
name|dn_cfg
operator|.
name|si_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow
argument_list|)
argument_list|,
name|DN_SCH_I
argument_list|,
name|dn_cfg
operator|.
name|queue_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dn_queue
argument_list|)
argument_list|,
name|DN_QUEUE
argument_list|)
expr_stmt|;
name|sopt
operator|->
name|sopt_valsize
operator|=
name|sopt_valsize
expr_stmt|;
name|a
operator|.
name|type
operator|=
name|cmd
operator|->
name|subtype
expr_stmt|;
if|if
condition|(
name|compat
operator|==
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|cmd
argument_list|,
name|start
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|dn_id
operator|*
operator|)
operator|(
name|start
operator|)
operator|)
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_id
argument_list|)
expr_stmt|;
name|buf
operator|=
name|start
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
name|buf
operator|=
name|start
expr_stmt|;
name|a
operator|.
name|start
operator|=
operator|&
name|buf
expr_stmt|;
name|a
operator|.
name|end
operator|=
name|start
operator|+
name|have
expr_stmt|;
comment|/* start copying other objects */
if|if
condition|(
name|compat
condition|)
block|{
name|a
operator|.
name|type
operator|=
name|DN_COMPAT_PIPE
expr_stmt|;
name|dn_ht_scan
argument_list|(
name|dn_cfg
operator|.
name|schedhash
argument_list|,
name|copy_data_helper_compat
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|a
operator|.
name|type
operator|=
name|DN_COMPAT_QUEUE
expr_stmt|;
name|dn_ht_scan
argument_list|(
name|dn_cfg
operator|.
name|fshash
argument_list|,
name|copy_data_helper_compat
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|.
name|type
operator|==
name|DN_FS
condition|)
block|{
name|dn_ht_scan
argument_list|(
name|dn_cfg
operator|.
name|fshash
argument_list|,
name|copy_data_helper
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dn_ht_scan
argument_list|(
name|dn_cfg
operator|.
name|schedhash
argument_list|,
name|copy_data_helper
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
block|}
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|compat
condition|)
block|{
operator|*
name|compat
operator|=
name|start
expr_stmt|;
name|sopt
operator|->
name|sopt_valsize
operator|=
name|buf
operator|-
name|start
expr_stmt|;
comment|/* free() is done by ip_dummynet_compat() */
name|start
operator|=
name|NULL
expr_stmt|;
comment|//XXX hack
block|}
else|else
block|{
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
name|start
argument_list|,
name|buf
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|cmd
operator|&&
name|cmd
operator|!=
operator|&
name|r
operator|.
name|o
condition|)
name|free
argument_list|(
name|cmd
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
condition|)
name|free
argument_list|(
name|start
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Callback called on scheduler instance to delete it if idle */
end_comment

begin_function
specifier|static
name|int
name|drain_scheduler_cb
parameter_list|(
name|void
modifier|*
name|_si
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_sch_inst
modifier|*
name|si
init|=
name|_si
decl_stmt|;
if|if
condition|(
operator|(
name|si
operator|->
name|kflags
operator|&
name|DN_ACTIVE
operator|)
operator|||
name|si
operator|->
name|dline
operator|.
name|mq
operator|.
name|head
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|si
operator|->
name|sched
operator|->
name|fp
operator|->
name|flags
operator|&
name|DN_MULTIQUEUE
condition|)
block|{
if|if
condition|(
name|si
operator|->
name|q_count
operator|==
literal|0
condition|)
return|return
name|si_destroy
argument_list|(
name|si
argument_list|,
name|NULL
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* !DN_MULTIQUEUE */
if|if
condition|(
operator|(
name|si
operator|+
literal|1
operator|)
operator|->
name|ni
operator|.
name|length
operator|==
literal|0
condition|)
return|return
name|si_destroy
argument_list|(
name|si
argument_list|,
name|NULL
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
comment|/* unreachable */
block|}
end_function

begin_comment
comment|/* Callback called on scheduler to check if it has instances */
end_comment

begin_function
specifier|static
name|int
name|drain_scheduler_sch_cb
parameter_list|(
name|void
modifier|*
name|_s
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_schk
modifier|*
name|s
init|=
name|_s
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|sch
operator|.
name|flags
operator|&
name|DN_HAVE_MASK
condition|)
block|{
name|dn_ht_scan_bucket
argument_list|(
name|s
operator|->
name|siht
argument_list|,
operator|&
name|s
operator|->
name|drain_bucket
argument_list|,
name|drain_scheduler_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|drain_bucket
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|s
operator|->
name|siht
condition|)
block|{
if|if
condition|(
name|drain_scheduler_cb
argument_list|(
name|s
operator|->
name|siht
argument_list|,
name|NULL
argument_list|)
operator|==
name|DNHT_SCAN_DEL
condition|)
name|s
operator|->
name|siht
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called every tick, try to delete a 'bucket' of scheduler */
end_comment

begin_function
name|void
name|dn_drain_scheduler
parameter_list|(
name|void
parameter_list|)
block|{
name|dn_ht_scan_bucket
argument_list|(
name|dn_cfg
operator|.
name|schedhash
argument_list|,
operator|&
name|dn_cfg
operator|.
name|drain_sch
argument_list|,
name|drain_scheduler_sch_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dn_cfg
operator|.
name|drain_sch
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callback called on queue to delete if it is idle */
end_comment

begin_function
specifier|static
name|int
name|drain_queue_cb
parameter_list|(
name|void
modifier|*
name|_q
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_queue
modifier|*
name|q
init|=
name|_q
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|ni
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|dn_delete_queue
argument_list|(
name|q
argument_list|,
name|DN_DESTROY
argument_list|)
expr_stmt|;
return|return
name|DNHT_SCAN_DEL
return|;
comment|/* queue is deleted */
block|}
return|return
literal|0
return|;
comment|/* queue isn't deleted */
block|}
end_function

begin_comment
comment|/* Callback called on flowset used to check if it has queues */
end_comment

begin_function
specifier|static
name|int
name|drain_queue_fs_cb
parameter_list|(
name|void
modifier|*
name|_fs
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_fsk
modifier|*
name|fs
init|=
name|_fs
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_QHT_HASH
condition|)
block|{
comment|/* Flowset has a hash table for queues */
name|dn_ht_scan_bucket
argument_list|(
name|fs
operator|->
name|qht
argument_list|,
operator|&
name|fs
operator|->
name|drain_bucket
argument_list|,
name|drain_queue_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fs
operator|->
name|drain_bucket
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* No hash table for this flowset, null the pointer  		 * if the queue is deleted 		 */
if|if
condition|(
name|fs
operator|->
name|qht
condition|)
block|{
if|if
condition|(
name|drain_queue_cb
argument_list|(
name|fs
operator|->
name|qht
argument_list|,
name|NULL
argument_list|)
operator|==
name|DNHT_SCAN_DEL
condition|)
name|fs
operator|->
name|qht
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called every tick, try to delete a 'bucket' of queue */
end_comment

begin_function
name|void
name|dn_drain_queue
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* scan a bucket of flowset */
name|dn_ht_scan_bucket
argument_list|(
name|dn_cfg
operator|.
name|fshash
argument_list|,
operator|&
name|dn_cfg
operator|.
name|drain_fs
argument_list|,
name|drain_queue_fs_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dn_cfg
operator|.
name|drain_fs
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handler for the various dummynet socket options  */
end_comment

begin_function
specifier|static
name|int
name|ip_dn_ctl
parameter_list|(
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|,
name|l
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|sopt
operator|->
name|sopt_td
argument_list|,
name|PRIV_NETINET_DUMMYNET
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Disallow sets in really-really secure mode. */
if|if
condition|(
name|sopt
operator|->
name|sopt_dir
operator|==
name|SOPT_SET
condition|)
block|{
name|error
operator|=
name|securelevel_ge
argument_list|(
name|sopt
operator|->
name|sopt_td
operator|->
name|td_ucred
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
default|default :
name|D
argument_list|(
literal|"dummynet: unknown option %d"
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|IP_DUMMYNET_FLUSH
case|:
case|case
name|IP_DUMMYNET_CONFIGURE
case|:
case|case
name|IP_DUMMYNET_DEL
case|:
comment|/* remove a pipe or queue */
case|case
name|IP_DUMMYNET_GET
case|:
name|D
argument_list|(
literal|"dummynet: compat option %d"
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|ip_dummynet_compat
argument_list|(
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_DUMMYNET3
case|:
if|if
condition|(
name|sopt
operator|->
name|sopt_dir
operator|==
name|SOPT_GET
condition|)
block|{
name|error
operator|=
name|dummynet_get
argument_list|(
name|sopt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|l
operator|=
name|sopt
operator|->
name|sopt_valsize
expr_stmt|;
if|if
condition|(
name|l
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dn_id
argument_list|)
operator|||
name|l
operator|>
literal|12000
condition|)
block|{
name|D
argument_list|(
literal|"argument len %d invalid"
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|malloc
argument_list|(
name|l
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|// XXX can it fail ?
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
name|p
argument_list|,
name|l
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break ;
name|error
operator|=
name|do_config
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ip_dn_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dn_cfg
operator|.
name|init_done
condition|)
return|return;
name|printf
argument_list|(
literal|"DUMMYNET %p with IPv6 initialized (100409)\n"
argument_list|,
name|curvnet
argument_list|)
expr_stmt|;
name|dn_cfg
operator|.
name|init_done
operator|=
literal|1
expr_stmt|;
comment|/* Set defaults here. MSVC does not accept initializers, 	 * and this is also useful for vimages 	 */
comment|/* queue limits */
name|dn_cfg
operator|.
name|slot_limit
operator|=
literal|100
expr_stmt|;
comment|/* Foot shooting limit for queues. */
name|dn_cfg
operator|.
name|byte_limit
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
name|dn_cfg
operator|.
name|expire
operator|=
literal|1
expr_stmt|;
comment|/* RED parameters */
name|dn_cfg
operator|.
name|red_lookup_depth
operator|=
literal|256
expr_stmt|;
comment|/* default lookup table depth */
name|dn_cfg
operator|.
name|red_avg_pkt_size
operator|=
literal|512
expr_stmt|;
comment|/* default medium packet size */
name|dn_cfg
operator|.
name|red_max_pkt_size
operator|=
literal|1500
expr_stmt|;
comment|/* default max packet size */
comment|/* hash tables */
name|dn_cfg
operator|.
name|max_hash_size
operator|=
literal|65536
expr_stmt|;
comment|/* max in the hash tables */
name|dn_cfg
operator|.
name|hash_size
operator|=
literal|64
expr_stmt|;
comment|/* default hash size */
comment|/* create hash tables for schedulers and flowsets. 	 * In both we search by key and by pointer. 	 */
name|dn_cfg
operator|.
name|schedhash
operator|=
name|dn_ht_init
argument_list|(
name|NULL
argument_list|,
name|dn_cfg
operator|.
name|hash_size
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|dn_schk
argument_list|,
name|schk_next
argument_list|)
argument_list|,
name|schk_hash
argument_list|,
name|schk_match
argument_list|,
name|schk_new
argument_list|)
expr_stmt|;
name|dn_cfg
operator|.
name|fshash
operator|=
name|dn_ht_init
argument_list|(
name|NULL
argument_list|,
name|dn_cfg
operator|.
name|hash_size
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|dn_fsk
argument_list|,
name|fsk_next
argument_list|)
argument_list|,
name|fsk_hash
argument_list|,
name|fsk_match
argument_list|,
name|fsk_new
argument_list|)
expr_stmt|;
comment|/* bucket index to drain object */
name|dn_cfg
operator|.
name|drain_fs
operator|=
literal|0
expr_stmt|;
name|dn_cfg
operator|.
name|drain_sch
operator|=
literal|0
expr_stmt|;
name|heap_init
argument_list|(
operator|&
name|dn_cfg
operator|.
name|evheap
argument_list|,
literal|16
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|dn_id
argument_list|,
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|dn_cfg
operator|.
name|fsu
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|dn_cfg
operator|.
name|schedlist
argument_list|)
expr_stmt|;
name|DN_LOCK_INIT
argument_list|()
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|dn_task
argument_list|,
literal|0
argument_list|,
name|dummynet_task
argument_list|,
name|curvnet
argument_list|)
expr_stmt|;
name|dn_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"dummynet"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|dn_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|dn_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"dummynet"
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|dn_timeout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|dn_timeout
argument_list|,
literal|1
argument_list|,
name|dummynet
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Initialize curr_time adjustment mechanics. */
name|getmicrouptime
argument_list|(
operator|&
name|dn_cfg
operator|.
name|prev_t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ip_dn_destroy
parameter_list|(
name|int
name|last
parameter_list|)
block|{
name|callout_drain
argument_list|(
operator|&
name|dn_timeout
argument_list|)
expr_stmt|;
name|DN_BH_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|last
condition|)
block|{
name|ND
argument_list|(
literal|"removing last instance\n"
argument_list|)
expr_stmt|;
name|ip_dn_ctl_ptr
operator|=
name|NULL
expr_stmt|;
name|ip_dn_io_ptr
operator|=
name|NULL
expr_stmt|;
block|}
name|dummynet_flush
argument_list|()
expr_stmt|;
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|dn_tq
argument_list|,
operator|&
name|dn_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|dn_tq
argument_list|)
expr_stmt|;
name|dn_ht_free
argument_list|(
name|dn_cfg
operator|.
name|schedhash
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dn_ht_free
argument_list|(
name|dn_cfg
operator|.
name|fshash
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|heap_free
argument_list|(
operator|&
name|dn_cfg
operator|.
name|evheap
argument_list|)
expr_stmt|;
name|DN_LOCK_DESTROY
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dummynet_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|MOD_LOAD
condition|)
block|{
if|if
condition|(
name|ip_dn_io_ptr
condition|)
block|{
name|printf
argument_list|(
literal|"DUMMYNET already loaded\n"
argument_list|)
expr_stmt|;
return|return
name|EEXIST
return|;
block|}
name|ip_dn_init
argument_list|()
expr_stmt|;
name|ip_dn_ctl_ptr
operator|=
name|ip_dn_ctl
expr_stmt|;
name|ip_dn_io_ptr
operator|=
name|dummynet_io
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|MOD_UNLOAD
condition|)
block|{
name|ip_dn_destroy
argument_list|(
literal|1
comment|/* last */
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_comment
comment|/* modevent helpers for the modules */
end_comment

begin_function
specifier|static
name|int
name|load_dn_sched
parameter_list|(
name|struct
name|dn_alg
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|dn_alg
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* error */
name|ip_dn_init
argument_list|()
expr_stmt|;
comment|/* just in case, we need the lock */
comment|/* Check that mandatory funcs exists */
if|if
condition|(
name|d
operator|->
name|enqueue
operator|==
name|NULL
operator|||
name|d
operator|->
name|dequeue
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"missing enqueue or dequeue for %s"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Search if scheduler already exists */
name|DN_BH_WLOCK
argument_list|()
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&dn_cfg.schedlist
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|d
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"%s already loaded"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
comment|/* scheduler already exists */
block|}
block|}
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|dn_cfg
operator|.
name|schedlist
argument_list|,
name|d
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
name|D
argument_list|(
literal|"dn_sched %s %sloaded"
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|s
condition|?
literal|"not "
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
name|s
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unload_dn_sched
parameter_list|(
name|struct
name|dn_alg
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|dn_alg
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|int
name|err
init|=
name|EINVAL
decl_stmt|;
name|ND
argument_list|(
literal|"called for %s"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|DN_BH_WLOCK
argument_list|()
expr_stmt|;
name|SLIST_FOREACH_SAFE
argument_list|(
argument|r
argument_list|,
argument|&dn_cfg.schedlist
argument_list|,
argument|next
argument_list|,
argument|tmp
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|r
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|ND
argument_list|(
literal|"ref_count = %d"
argument_list|,
name|r
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
name|r
operator|->
name|ref_count
operator|!=
literal|0
operator|)
condition|?
name|EBUSY
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|SLIST_REMOVE
argument_list|(
operator|&
name|dn_cfg
operator|.
name|schedlist
argument_list|,
name|r
argument_list|,
name|dn_alg
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
name|D
argument_list|(
literal|"dn_sched %s %sunloaded"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|err
condition|?
literal|"not "
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|dn_sched_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dn_alg
modifier|*
name|sch
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|MOD_LOAD
condition|)
return|return
name|load_dn_sched
argument_list|(
name|sch
argument_list|)
return|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|MOD_UNLOAD
condition|)
return|return
name|unload_dn_sched
argument_list|(
name|sch
argument_list|)
return|;
else|else
return|return
name|EINVAL
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|dummynet_mod
init|=
block|{
literal|"dummynet"
block|,
name|dummynet_modevent
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DN_SI_SUB
value|SI_SUB_PROTO_IFATTACHDOMAIN
end_define

begin_define
define|#
directive|define
name|DN_MODEV_ORD
value|(SI_ORDER_ANY - 128)
end_define

begin_comment
comment|/* after ipfw */
end_comment

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|dummynet
argument_list|,
name|dummynet_mod
argument_list|,
name|DN_SI_SUB
argument_list|,
name|DN_MODEV_ORD
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|dummynet
argument_list|,
name|ipfw
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|dummynet
argument_list|,
literal|3
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Starting up. Done in order after dummynet_modevent() has been called.  * VNET_SYSINIT is also called for each existing vnet and each new vnet.  */
end_comment

begin_comment
comment|//VNET_SYSINIT(vnet_dn_init, DN_SI_SUB, DN_MODEV_ORD+2, ip_dn_init, NULL);
end_comment

begin_comment
comment|/*  * Shutdown handlers up shop. These are done in REVERSE ORDER, but still  * after dummynet_modevent() has been called. Not called on reboot.  * VNET_SYSUNINIT is also called for each exiting vnet as it exits.  * or when the module is unloaded.  */
end_comment

begin_comment
comment|//VNET_SYSUNINIT(vnet_dn_uninit, DN_SI_SUB, DN_MODEV_ORD+2, ip_dn_destroy, NULL);
end_comment

begin_comment
comment|/* end of file */
end_comment

end_unit

