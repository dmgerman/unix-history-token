begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Codel - The Controlled-Delay Active Queue Management algorithm.  *  * $FreeBSD$  *   * Copyright (C) 2016 Centre for Advanced Internet Architectures,  *  Swinburne University of Technology, Melbourne, Australia.  * Portions of this code were made possible in part by a gift from   *  The Comcast Innovation Fund.  * Implemented by Rasool Al-Saadi<ralsaadi@swin.edu.au>  *   * Copyright (C) 2011-2014 Kathleen Nichols<nichols@pollere.com>.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * o  Redistributions of source code must retain the above copyright  *  notice, this list of conditions, and the following disclaimer,  *  without modification.  *  * o  Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in  *  the documentation and/or other materials provided with the  *  distribution.  *   * o  The names of the authors may not be used to endorse or promote  *  products derived from this software without specific prior written  *  permission.  *  * Alternatively, provided that this notice is retained in full, this  * software may be distributed under the terms of the GNU General Public  * License ("GPL") version 2, in which case the provisions of the GPL  * apply INSTEAD OF those given above.   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_IP_DN_AQM_CODEL_H
end_ifndef

begin_define
define|#
directive|define
name|_IP_DN_AQM_CODEL_H
end_define

begin_comment
comment|// XXX How to choose MTAG?
end_comment

begin_define
define|#
directive|define
name|FIX_POINT_BITS
value|16
end_define

begin_enum
enum|enum
block|{
name|CODEL_ECN_ENABLED
init|=
literal|1
block|}
enum|;
end_enum

begin_comment
comment|/* Codel parameters */
end_comment

begin_struct
struct|struct
name|dn_aqm_codel_parms
block|{
name|aqm_time_t
name|target
decl_stmt|;
name|aqm_time_t
name|interval
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* codel status variables */
end_comment

begin_struct
struct|struct
name|codel_status
block|{
name|uint32_t
name|count
decl_stmt|;
comment|/* number of dropped pkts since entering drop state */
name|uint16_t
name|dropping
decl_stmt|;
comment|/* dropping state */
name|aqm_time_t
name|drop_next_time
decl_stmt|;
comment|/* time for next drop */
name|aqm_time_t
name|first_above_time
decl_stmt|;
comment|/* time for first ts over target we observed */
name|uint16_t
name|isqrt
decl_stmt|;
comment|/* last isqrt for control low */
name|uint16_t
name|maxpkt_size
decl_stmt|;
comment|/* max packet size seen so far */
block|}
struct|;
end_struct

begin_function_decl
name|struct
name|mbuf
modifier|*
name|codel_extract_head
parameter_list|(
name|struct
name|dn_queue
modifier|*
parameter_list|,
name|aqm_time_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|aqm_time_t
name|control_law
parameter_list|(
name|struct
name|codel_status
modifier|*
parameter_list|,
name|struct
name|dn_aqm_codel_parms
modifier|*
parameter_list|,
name|aqm_time_t
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|__inline
specifier|static
expr|struct
name|mbuf
operator|*
name|codel_dodequeue
argument_list|(
argument|struct dn_queue *q
argument_list|,
argument|aqm_time_t now
argument_list|,
argument|uint16_t *ok_to_drop
argument_list|)
block|{ 	struct
name|mbuf
operator|*
name|m
block|; 	struct
name|dn_aqm_codel_parms
operator|*
name|cprms
block|; 	struct
name|codel_status
operator|*
name|cst
block|;
name|aqm_time_t
name|pkt_ts
block|,
name|sojourn_time
block|;
operator|*
name|ok_to_drop
operator|=
literal|0
block|;
name|m
operator|=
name|codel_extract_head
argument_list|(
name|q
argument_list|,
operator|&
name|pkt_ts
argument_list|)
block|;
name|cst
operator|=
name|q
operator|->
name|aqm_status
block|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* queue is empty - we can't be above target */
name|cst
operator|->
name|first_above_time
operator|=
literal|0
expr_stmt|;
return|return
name|m
return|;
block|}
name|cprms
operator|=
name|q
operator|->
name|fs
operator|->
name|aqmcfg
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* To span a large range of bandwidths, CoDel runs two 	 * different AQMs in parallel. One is sojourn-time-based 	 * and takes effect when the time to send an MTU-sized 	 * packet is less than target.  The 1st term of the "if" 	 * below does this.  The other is backlog-based and takes 	 * effect when the time to send an MTU-sized packet is>= 	* target. The goal here is to keep the output link 	* utilization high by never allowing the queue to get 	* smaller than the amount that arrives in a typical 	 * interarrival time (MTU-sized packets arriving spaced 	 * by the amount of time it takes to send such a packet on 	 * the bottleneck). The 2nd term of the "if" does this. 	 */
end_comment

begin_expr_stmt
name|sojourn_time
operator|=
name|now
operator|-
name|pkt_ts
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|sojourn_time
operator|<
name|cprms
operator|->
name|target
operator|||
name|q
operator|->
name|ni
operator|.
name|len_bytes
operator|<=
name|cst
operator|->
name|maxpkt_size
condition|)
block|{
comment|/* went below - stay below for at least interval */
name|cst
operator|->
name|first_above_time
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cst
operator|->
name|first_above_time
operator|==
literal|0
condition|)
block|{
comment|/* just went above from below. if still above at 			 * first_above_time, will say it's ok to drop. */
name|cst
operator|->
name|first_above_time
operator|=
name|now
operator|+
name|cprms
operator|->
name|interval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|now
operator|>=
name|cst
operator|->
name|first_above_time
condition|)
block|{
operator|*
name|ok_to_drop
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_if

begin_return
return|return
name|m
return|;
end_return

begin_comment
unit|}
comment|/*   * Dequeue a packet from queue 'q'  */
end_comment

begin_function
unit|__inline
specifier|static
name|struct
name|mbuf
modifier|*
name|codel_dequeue
parameter_list|(
name|struct
name|dn_queue
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|dn_aqm_codel_parms
modifier|*
name|cprms
decl_stmt|;
name|struct
name|codel_status
modifier|*
name|cst
decl_stmt|;
name|aqm_time_t
name|now
decl_stmt|;
name|uint16_t
name|ok_to_drop
decl_stmt|;
name|cst
operator|=
name|q
operator|->
name|aqm_status
expr_stmt|;
empty_stmt|;
name|cprms
operator|=
name|q
operator|->
name|fs
operator|->
name|aqmcfg
expr_stmt|;
name|now
operator|=
name|AQM_UNOW
expr_stmt|;
name|m
operator|=
name|codel_dodequeue
argument_list|(
name|q
argument_list|,
name|now
argument_list|,
operator|&
name|ok_to_drop
argument_list|)
expr_stmt|;
if|if
condition|(
name|cst
operator|->
name|dropping
condition|)
block|{
if|if
condition|(
operator|!
name|ok_to_drop
condition|)
block|{
comment|/* sojourn time below target - leave dropping state */
name|cst
operator|->
name|dropping
operator|=
name|false
expr_stmt|;
block|}
comment|/* 		 * Time for the next drop. Drop current packet and dequeue 		 * next.  If the dequeue doesn't take us out of dropping 		 * state, schedule the next drop. A large backlog might 		 * result in drop rates so high that the next drop should 		 * happen now, hence the 'while' loop. 		 */
while|while
condition|(
name|now
operator|>=
name|cst
operator|->
name|drop_next_time
operator|&&
name|cst
operator|->
name|dropping
condition|)
block|{
comment|/* mark the packet */
if|if
condition|(
name|cprms
operator|->
name|flags
operator|&
name|CODEL_ECN_ENABLED
operator|&&
name|ecn_mark
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|cst
operator|->
name|count
operator|++
expr_stmt|;
comment|/* schedule the next mark. */
name|cst
operator|->
name|drop_next_time
operator|=
name|control_law
argument_list|(
name|cst
argument_list|,
name|cprms
argument_list|,
name|cst
operator|->
name|drop_next_time
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
comment|/* drop the packet */
name|update_stats
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FREE_PKT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|codel_dodequeue
argument_list|(
name|q
argument_list|,
name|now
argument_list|,
operator|&
name|ok_to_drop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok_to_drop
condition|)
block|{
comment|/* leave dropping state */
name|cst
operator|->
name|dropping
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|cst
operator|->
name|count
operator|++
expr_stmt|;
comment|/* schedule the next drop. */
name|cst
operator|->
name|drop_next_time
operator|=
name|control_law
argument_list|(
name|cst
argument_list|,
name|cprms
argument_list|,
name|cst
operator|->
name|drop_next_time
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we get here we're not in dropping state. The 'ok_to_drop' 	 * return from dodequeue means that the sojourn time has been 	 * above 'target' for 'interval' so enter dropping state. 	 */
block|}
elseif|else
if|if
condition|(
name|ok_to_drop
condition|)
block|{
comment|/* if ECN option is disabled or the packet cannot be marked, 		 * drop the packet and extract another. 		 */
if|if
condition|(
operator|!
operator|(
name|cprms
operator|->
name|flags
operator|&
name|CODEL_ECN_ENABLED
operator|)
operator|||
operator|!
name|ecn_mark
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|update_stats
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FREE_PKT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|codel_dodequeue
argument_list|(
name|q
argument_list|,
name|now
argument_list|,
operator|&
name|ok_to_drop
argument_list|)
expr_stmt|;
block|}
name|cst
operator|->
name|dropping
operator|=
name|true
expr_stmt|;
comment|/* If min went above target close to when it last went 		 * below, assume that the drop rate that controlled the 		 * queue on the last cycle is a good starting point to 		 * control it now. ('drop_next' will be at most 'interval' 		 * later than the time of the last drop so 'now - drop_next' 		 * is a good approximation of the time from the last drop 		 * until now.) 		 */
name|cst
operator|->
name|count
operator|=
operator|(
name|cst
operator|->
name|count
operator|>
literal|2
operator|&&
operator|(
operator|(
name|aqm_stime_t
operator|)
name|now
operator|-
operator|(
name|aqm_stime_t
operator|)
name|cst
operator|->
name|drop_next_time
operator|)
operator|<
literal|8
operator|*
name|cprms
operator|->
name|interval
operator|)
condition|?
name|cst
operator|->
name|count
operator|-
literal|2
else|:
literal|1
expr_stmt|;
comment|/* we don't have to set initial guess for Newton's method isqrt as 		 * we initilaize  isqrt in control_law function when count == 1 */
name|cst
operator|->
name|drop_next_time
operator|=
name|control_law
argument_list|(
name|cst
argument_list|,
name|cprms
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

