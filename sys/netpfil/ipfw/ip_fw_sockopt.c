begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2009 Luigi Rizzo, Universita` di Pisa  * Copyright (c) 2014 Yandex LLC  * Copyright (c) 2014 Alexander V. Chernikov  *  * Supported by: Valeria Paoli  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Control socket and rule management routines for ipfw.  * Control is currently implemented via IP_FW3 setsockopt() code.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ipfw.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|INET
end_ifndef

begin_error
error|#
directive|error
error|IPFIREWALL requires INET.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_comment
comment|/* struct m_tag used by nested headers */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rmlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/fnv_hash.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/pfil.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_comment
comment|/* hooks */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/ip_fw_private.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/ip_fw_table.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ipfw_ctl
parameter_list|(
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_ipfw_rule_body
parameter_list|(
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|int
name|cmd_len
parameter_list|,
name|struct
name|rule_check_info
modifier|*
name|ci
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_ipfw_rule1
parameter_list|(
name|struct
name|ip_fw_rule
modifier|*
name|rule
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|rule_check_info
modifier|*
name|ci
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_ipfw_rule0
parameter_list|(
name|struct
name|ip_fw_rule0
modifier|*
name|rule
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|rule_check_info
modifier|*
name|ci
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rewrite_rule_uidx
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|struct
name|rule_check_info
modifier|*
name|ci
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NAMEDOBJ_HASH_SIZE
value|32
end_define

begin_struct
struct|struct
name|namedobj_instance
block|{
name|struct
name|namedobjects_head
modifier|*
name|names
decl_stmt|;
name|struct
name|namedobjects_head
modifier|*
name|values
decl_stmt|;
name|uint32_t
name|nn_size
decl_stmt|;
comment|/* names hash size */
name|uint32_t
name|nv_size
decl_stmt|;
comment|/* number hash size */
name|u_long
modifier|*
name|idx_mask
decl_stmt|;
comment|/* used items bitmask */
name|uint32_t
name|max_blocks
decl_stmt|;
comment|/* number of "long" blocks in bitmask */
name|uint32_t
name|count
decl_stmt|;
comment|/* number of items */
name|uint16_t
name|free_off
index|[
name|IPFW_MAX_SETS
index|]
decl_stmt|;
comment|/* first possible free offset */
name|objhash_hash_f
modifier|*
name|hash_f
decl_stmt|;
name|objhash_cmp_f
modifier|*
name|cmp_f
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BLOCK_ITEMS
value|(8 * sizeof(u_long))
end_define

begin_comment
comment|/* Number of items for ffsl() */
end_comment

begin_function_decl
specifier|static
name|uint32_t
name|objhash_hash_name
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|uint32_t
name|kopt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|objhash_hash_idx
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|uint32_t
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|objhash_cmp_name
parameter_list|(
name|struct
name|named_object
modifier|*
name|no
parameter_list|,
specifier|const
name|void
modifier|*
name|name
parameter_list|,
name|uint32_t
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IPFW
argument_list|,
literal|"IpFw/IpAcct"
argument_list|,
literal|"IpFw/IpAcct chain's"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|dump_config
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_rules
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|del_rules
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|clear_rules
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|move_rules
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|manage_sets
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dump_soptcodes
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dump_srvobjects
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ctl3 handler data */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|ctl3_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CTL3_LOCK_INIT
parameter_list|()
value|mtx_init(&ctl3_lock, "ctl3_lock", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|CTL3_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&ctl3_lock)
end_define

begin_define
define|#
directive|define
name|CTL3_LOCK
parameter_list|()
value|mtx_lock(&ctl3_lock)
end_define

begin_define
define|#
directive|define
name|CTL3_UNLOCK
parameter_list|()
value|mtx_unlock(&ctl3_lock)
end_define

begin_decl_stmt
specifier|static
name|struct
name|ipfw_sopt_handler
modifier|*
name|ctl3_handlers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|ctl3_hsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|ctl3_refct
decl_stmt|,
name|ctl3_gencnt
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CTL3_SMALLBUF
value|4096
end_define

begin_comment
comment|/* small page-size write buffer */
end_comment

begin_define
define|#
directive|define
name|CTL3_LARGEBUF
value|16 * 1024 * 1024
end_define

begin_comment
comment|/* handle large rulesets */
end_comment

begin_function_decl
specifier|static
name|int
name|ipfw_flush_sopt_data
parameter_list|(
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ipfw_sopt_handler
name|scodes
index|[]
init|=
block|{
block|{
name|IP_FW_XGET
block|,
literal|0
block|,
name|HDIR_GET
block|,
name|dump_config
block|}
block|,
block|{
name|IP_FW_XADD
block|,
literal|0
block|,
name|HDIR_BOTH
block|,
name|add_rules
block|}
block|,
block|{
name|IP_FW_XDEL
block|,
literal|0
block|,
name|HDIR_BOTH
block|,
name|del_rules
block|}
block|,
block|{
name|IP_FW_XZERO
block|,
literal|0
block|,
name|HDIR_SET
block|,
name|clear_rules
block|}
block|,
block|{
name|IP_FW_XRESETLOG
block|,
literal|0
block|,
name|HDIR_SET
block|,
name|clear_rules
block|}
block|,
block|{
name|IP_FW_XMOVE
block|,
literal|0
block|,
name|HDIR_SET
block|,
name|move_rules
block|}
block|,
block|{
name|IP_FW_SET_SWAP
block|,
literal|0
block|,
name|HDIR_SET
block|,
name|manage_sets
block|}
block|,
block|{
name|IP_FW_SET_MOVE
block|,
literal|0
block|,
name|HDIR_SET
block|,
name|manage_sets
block|}
block|,
block|{
name|IP_FW_SET_ENABLE
block|,
literal|0
block|,
name|HDIR_SET
block|,
name|manage_sets
block|}
block|,
block|{
name|IP_FW_DUMP_SOPTCODES
block|,
literal|0
block|,
name|HDIR_GET
block|,
name|dump_soptcodes
block|}
block|,
block|{
name|IP_FW_DUMP_SRVOBJECTS
block|,
literal|0
block|,
name|HDIR_GET
block|,
name|dump_srvobjects
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|set_legacy_obj_kidx
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|struct
name|ip_fw_rule0
modifier|*
name|rule
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|opcode_obj_rewrite
modifier|*
name|find_op_rw
parameter_list|(
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|uint16_t
modifier|*
name|puidx
parameter_list|,
name|uint8_t
modifier|*
name|ptype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mark_object_kidx
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|struct
name|ip_fw
modifier|*
name|rule
parameter_list|,
name|uint32_t
modifier|*
name|bmask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ref_rule_objects
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|struct
name|ip_fw
modifier|*
name|rule
parameter_list|,
name|struct
name|rule_check_info
modifier|*
name|ci
parameter_list|,
name|struct
name|obj_idx
modifier|*
name|oib
parameter_list|,
name|struct
name|tid_info
modifier|*
name|ti
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ref_opcode_object
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|struct
name|tid_info
modifier|*
name|ti
parameter_list|,
name|struct
name|obj_idx
modifier|*
name|pidx
parameter_list|,
name|int
modifier|*
name|unresolved
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unref_rule_objects
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|struct
name|ip_fw
modifier|*
name|rule
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unref_oib_objects
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|struct
name|obj_idx
modifier|*
name|oib
parameter_list|,
name|struct
name|obj_idx
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|export_objhash_ntlv
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|uint16_t
name|kidx
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Opcode object rewriter variables  */
end_comment

begin_decl_stmt
name|struct
name|opcode_obj_rewrite
modifier|*
name|ctl3_rewriters
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|ctl3_rsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * static variables followed by global ones  */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|uma_zone_t
argument_list|,
name|ipfw_cntr_zone
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_ipfw_cntr_zone
value|VNET(ipfw_cntr_zone)
end_define

begin_function
name|void
name|ipfw_init_counters
parameter_list|()
block|{
name|V_ipfw_cntr_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"IPFW counters"
argument_list|,
name|IPFW_RULE_CNTR_SIZE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_PCPU
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipfw_destroy_counters
parameter_list|()
block|{
name|uma_zdestroy
argument_list|(
name|V_ipfw_cntr_zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ip_fw
modifier|*
name|ipfw_alloc_rule
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|size_t
name|rulesize
parameter_list|)
block|{
name|struct
name|ip_fw
modifier|*
name|rule
decl_stmt|;
name|rule
operator|=
name|malloc
argument_list|(
name|rulesize
argument_list|,
name|M_IPFW
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|rule
operator|->
name|cntr
operator|=
name|uma_zalloc
argument_list|(
name|V_ipfw_cntr_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
return|return
operator|(
name|rule
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_rule
parameter_list|(
name|struct
name|ip_fw
modifier|*
name|rule
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|V_ipfw_cntr_zone
argument_list|,
name|rule
operator|->
name|cntr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rule
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the smallest rule>= key, id.  * We could use bsearch but it is so simple that we code it directly  */
end_comment

begin_function
name|int
name|ipfw_find_rule
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|uint32_t
name|key
parameter_list|,
name|uint32_t
name|id
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|struct
name|ip_fw
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|lo
operator|=
literal|0
operator|,
name|hi
operator|=
name|chain
operator|->
name|n_rules
operator|-
literal|1
init|;
name|lo
operator|<
name|hi
condition|;
control|)
block|{
name|i
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
name|r
operator|=
name|chain
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|rulenum
operator|<
name|key
condition|)
name|lo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* continue from the next one */
elseif|else
if|if
condition|(
name|r
operator|->
name|rulenum
operator|>
name|key
condition|)
name|hi
operator|=
name|i
expr_stmt|;
comment|/* this might be good */
elseif|else
if|if
condition|(
name|r
operator|->
name|id
operator|<
name|id
condition|)
name|lo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* continue from the next one */
else|else
comment|/* r->id>= id */
name|hi
operator|=
name|i
expr_stmt|;
comment|/* this might be good */
block|}
return|return
name|hi
return|;
block|}
end_function

begin_comment
comment|/*  * Builds skipto cache on rule set @map.  */
end_comment

begin_function
specifier|static
name|void
name|update_skipto_cache
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|struct
name|ip_fw
modifier|*
modifier|*
name|map
parameter_list|)
block|{
name|int
modifier|*
name|smap
decl_stmt|,
name|rulenum
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mi
decl_stmt|;
name|IPFW_UH_WLOCK_ASSERT
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|mi
operator|=
literal|0
expr_stmt|;
name|rulenum
operator|=
name|map
index|[
name|mi
index|]
operator|->
name|rulenum
expr_stmt|;
name|smap
operator|=
name|chain
operator|->
name|idxmap_back
expr_stmt|;
if|if
condition|(
name|smap
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|65536
condition|;
name|i
operator|++
control|)
block|{
name|smap
index|[
name|i
index|]
operator|=
name|mi
expr_stmt|;
comment|/* Use the same rule index until i< rulenum */
if|if
condition|(
name|i
operator|!=
name|rulenum
operator|||
name|i
operator|==
literal|65535
condition|)
continue|continue;
comment|/* Find next rule with num> i */
name|rulenum
operator|=
name|map
index|[
operator|++
name|mi
index|]
operator|->
name|rulenum
expr_stmt|;
while|while
condition|(
name|rulenum
operator|==
name|i
condition|)
name|rulenum
operator|=
name|map
index|[
operator|++
name|mi
index|]
operator|->
name|rulenum
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Swaps prepared (backup) index with current one.  */
end_comment

begin_function
specifier|static
name|void
name|swap_skipto_cache
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|)
block|{
name|int
modifier|*
name|map
decl_stmt|;
name|IPFW_UH_WLOCK_ASSERT
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|IPFW_WLOCK_ASSERT
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|map
operator|=
name|chain
operator|->
name|idxmap
expr_stmt|;
name|chain
operator|->
name|idxmap
operator|=
name|chain
operator|->
name|idxmap_back
expr_stmt|;
name|chain
operator|->
name|idxmap_back
operator|=
name|map
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate and initialize skipto cache.  */
end_comment

begin_function
name|void
name|ipfw_init_skipto_cache
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|)
block|{
name|int
modifier|*
name|idxmap
decl_stmt|,
modifier|*
name|idxmap_back
decl_stmt|;
name|idxmap
operator|=
name|malloc
argument_list|(
literal|65536
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
operator|*
argument_list|)
argument_list|,
name|M_IPFW
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|idxmap_back
operator|=
name|malloc
argument_list|(
literal|65536
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
operator|*
argument_list|)
argument_list|,
name|M_IPFW
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* 	 * Note we may be called at any time after initialization, 	 * for example, on first skipto rule, so we need to 	 * provide valid chain->idxmap on return 	 */
name|IPFW_UH_WLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|idxmap
operator|!=
name|NULL
condition|)
block|{
name|IPFW_UH_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|idxmap
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|idxmap_back
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set backup pointer first to permit building cache */
name|chain
operator|->
name|idxmap_back
operator|=
name|idxmap_back
expr_stmt|;
name|update_skipto_cache
argument_list|(
name|chain
argument_list|,
name|chain
operator|->
name|map
argument_list|)
expr_stmt|;
name|IPFW_WLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* It is now safe to set chain->idxmap ptr */
name|chain
operator|->
name|idxmap
operator|=
name|idxmap
expr_stmt|;
name|swap_skipto_cache
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|IPFW_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|IPFW_UH_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Destroys skipto cache.  */
end_comment

begin_function
name|void
name|ipfw_destroy_skipto_cache
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|)
block|{
if|if
condition|(
name|chain
operator|->
name|idxmap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|chain
operator|->
name|idxmap
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|idxmap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|chain
operator|->
name|idxmap_back
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * allocate a new map, returns the chain locked. extra is the number  * of entries to add or delete.  */
end_comment

begin_function
specifier|static
name|struct
name|ip_fw
modifier|*
modifier|*
name|get_map
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|int
name|extra
parameter_list|,
name|int
name|locked
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|ip_fw
modifier|*
modifier|*
name|map
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mflags
decl_stmt|;
name|mflags
operator|=
name|M_ZERO
operator||
operator|(
operator|(
name|locked
operator|!=
literal|0
operator|)
condition|?
name|M_NOWAIT
else|:
name|M_WAITOK
operator|)
expr_stmt|;
name|i
operator|=
name|chain
operator|->
name|n_rules
operator|+
name|extra
expr_stmt|;
name|map
operator|=
name|malloc
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ip_fw
operator|*
argument_list|)
argument_list|,
name|M_IPFW
argument_list|,
name|mflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot allocate map\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|locked
condition|)
name|IPFW_UH_WLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|chain
operator|->
name|n_rules
operator|+
name|extra
condition|)
comment|/* good */
return|return
name|map
return|;
comment|/* otherwise we lost the race, free and retry */
if|if
condition|(
operator|!
name|locked
condition|)
name|IPFW_UH_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|map
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * swap the maps. It is supposed to be called with IPFW_UH_WLOCK  */
end_comment

begin_function
specifier|static
name|struct
name|ip_fw
modifier|*
modifier|*
name|swap_map
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|struct
name|ip_fw
modifier|*
modifier|*
name|new_map
parameter_list|,
name|int
name|new_len
parameter_list|)
block|{
name|struct
name|ip_fw
modifier|*
modifier|*
name|old_map
decl_stmt|;
name|IPFW_WLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|chain
operator|->
name|id
operator|++
expr_stmt|;
name|chain
operator|->
name|n_rules
operator|=
name|new_len
expr_stmt|;
name|old_map
operator|=
name|chain
operator|->
name|map
expr_stmt|;
name|chain
operator|->
name|map
operator|=
name|new_map
expr_stmt|;
name|swap_skipto_cache
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|IPFW_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
return|return
name|old_map
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|export_cntr1_base
parameter_list|(
name|struct
name|ip_fw
modifier|*
name|krule
parameter_list|,
name|struct
name|ip_fw_bcounter
modifier|*
name|cntr
parameter_list|)
block|{
name|struct
name|timeval
name|boottime
decl_stmt|;
name|cntr
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|cntr
argument_list|)
expr_stmt|;
if|if
condition|(
name|krule
operator|->
name|cntr
operator|!=
name|NULL
condition|)
block|{
name|cntr
operator|->
name|pcnt
operator|=
name|counter_u64_fetch
argument_list|(
name|krule
operator|->
name|cntr
argument_list|)
expr_stmt|;
name|cntr
operator|->
name|bcnt
operator|=
name|counter_u64_fetch
argument_list|(
name|krule
operator|->
name|cntr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cntr
operator|->
name|timestamp
operator|=
name|krule
operator|->
name|timestamp
expr_stmt|;
block|}
if|if
condition|(
name|cntr
operator|->
name|timestamp
operator|>
literal|0
condition|)
block|{
name|getboottime
argument_list|(
operator|&
name|boottime
argument_list|)
expr_stmt|;
name|cntr
operator|->
name|timestamp
operator|+=
name|boottime
operator|.
name|tv_sec
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|export_cntr0_base
parameter_list|(
name|struct
name|ip_fw
modifier|*
name|krule
parameter_list|,
name|struct
name|ip_fw_bcounter0
modifier|*
name|cntr
parameter_list|)
block|{
name|struct
name|timeval
name|boottime
decl_stmt|;
if|if
condition|(
name|krule
operator|->
name|cntr
operator|!=
name|NULL
condition|)
block|{
name|cntr
operator|->
name|pcnt
operator|=
name|counter_u64_fetch
argument_list|(
name|krule
operator|->
name|cntr
argument_list|)
expr_stmt|;
name|cntr
operator|->
name|bcnt
operator|=
name|counter_u64_fetch
argument_list|(
name|krule
operator|->
name|cntr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cntr
operator|->
name|timestamp
operator|=
name|krule
operator|->
name|timestamp
expr_stmt|;
block|}
if|if
condition|(
name|cntr
operator|->
name|timestamp
operator|>
literal|0
condition|)
block|{
name|getboottime
argument_list|(
operator|&
name|boottime
argument_list|)
expr_stmt|;
name|cntr
operator|->
name|timestamp
operator|+=
name|boottime
operator|.
name|tv_sec
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Copies rule @urule from v1 userland format (current).  * to kernel @krule.  * Assume @krule is zeroed.  */
end_comment

begin_function
specifier|static
name|void
name|import_rule1
parameter_list|(
name|struct
name|rule_check_info
modifier|*
name|ci
parameter_list|)
block|{
name|struct
name|ip_fw_rule
modifier|*
name|urule
decl_stmt|;
name|struct
name|ip_fw
modifier|*
name|krule
decl_stmt|;
name|urule
operator|=
operator|(
expr|struct
name|ip_fw_rule
operator|*
operator|)
name|ci
operator|->
name|urule
expr_stmt|;
name|krule
operator|=
operator|(
expr|struct
name|ip_fw
operator|*
operator|)
name|ci
operator|->
name|krule
expr_stmt|;
comment|/* copy header */
name|krule
operator|->
name|act_ofs
operator|=
name|urule
operator|->
name|act_ofs
expr_stmt|;
name|krule
operator|->
name|cmd_len
operator|=
name|urule
operator|->
name|cmd_len
expr_stmt|;
name|krule
operator|->
name|rulenum
operator|=
name|urule
operator|->
name|rulenum
expr_stmt|;
name|krule
operator|->
name|set
operator|=
name|urule
operator|->
name|set
expr_stmt|;
name|krule
operator|->
name|flags
operator|=
name|urule
operator|->
name|flags
expr_stmt|;
comment|/* Save rulenum offset */
name|ci
operator|->
name|urule_numoff
operator|=
name|offsetof
argument_list|(
expr|struct
name|ip_fw_rule
argument_list|,
name|rulenum
argument_list|)
expr_stmt|;
comment|/* Copy opcodes */
name|memcpy
argument_list|(
name|krule
operator|->
name|cmd
argument_list|,
name|urule
operator|->
name|cmd
argument_list|,
name|krule
operator|->
name|cmd_len
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Export rule into v1 format (Current).  * Layout:  * [ ipfw_obj_tlv(IPFW_TLV_RULE_ENT)  *     [ ip_fw_rule ] OR  *     [ ip_fw_bcounter ip_fw_rule] (depends on rcntrs).  * ]  * Assume @data is zeroed.  */
end_comment

begin_function
specifier|static
name|void
name|export_rule1
parameter_list|(
name|struct
name|ip_fw
modifier|*
name|krule
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|rcntrs
parameter_list|)
block|{
name|struct
name|ip_fw_bcounter
modifier|*
name|cntr
decl_stmt|;
name|struct
name|ip_fw_rule
modifier|*
name|urule
decl_stmt|;
name|ipfw_obj_tlv
modifier|*
name|tlv
decl_stmt|;
comment|/* Fill in TLV header */
name|tlv
operator|=
operator|(
name|ipfw_obj_tlv
operator|*
operator|)
name|data
expr_stmt|;
name|tlv
operator|->
name|type
operator|=
name|IPFW_TLV_RULE_ENT
expr_stmt|;
name|tlv
operator|->
name|length
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|rcntrs
operator|!=
literal|0
condition|)
block|{
comment|/* Copy counters */
name|cntr
operator|=
operator|(
expr|struct
name|ip_fw_bcounter
operator|*
operator|)
operator|(
name|tlv
operator|+
literal|1
operator|)
expr_stmt|;
name|urule
operator|=
operator|(
expr|struct
name|ip_fw_rule
operator|*
operator|)
operator|(
name|cntr
operator|+
literal|1
operator|)
expr_stmt|;
name|export_cntr1_base
argument_list|(
name|krule
argument_list|,
name|cntr
argument_list|)
expr_stmt|;
block|}
else|else
name|urule
operator|=
operator|(
expr|struct
name|ip_fw_rule
operator|*
operator|)
operator|(
name|tlv
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* copy header */
name|urule
operator|->
name|act_ofs
operator|=
name|krule
operator|->
name|act_ofs
expr_stmt|;
name|urule
operator|->
name|cmd_len
operator|=
name|krule
operator|->
name|cmd_len
expr_stmt|;
name|urule
operator|->
name|rulenum
operator|=
name|krule
operator|->
name|rulenum
expr_stmt|;
name|urule
operator|->
name|set
operator|=
name|krule
operator|->
name|set
expr_stmt|;
name|urule
operator|->
name|flags
operator|=
name|krule
operator|->
name|flags
expr_stmt|;
name|urule
operator|->
name|id
operator|=
name|krule
operator|->
name|id
expr_stmt|;
comment|/* Copy opcodes */
name|memcpy
argument_list|(
name|urule
operator|->
name|cmd
argument_list|,
name|krule
operator|->
name|cmd
argument_list|,
name|krule
operator|->
name|cmd_len
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copies rule @urule from FreeBSD8 userland format (v0)  * to kernel @krule.  * Assume @krule is zeroed.  */
end_comment

begin_function
specifier|static
name|void
name|import_rule0
parameter_list|(
name|struct
name|rule_check_info
modifier|*
name|ci
parameter_list|)
block|{
name|struct
name|ip_fw_rule0
modifier|*
name|urule
decl_stmt|;
name|struct
name|ip_fw
modifier|*
name|krule
decl_stmt|;
name|int
name|cmdlen
decl_stmt|,
name|l
decl_stmt|;
name|ipfw_insn
modifier|*
name|cmd
decl_stmt|;
name|ipfw_insn_limit
modifier|*
name|lcmd
decl_stmt|;
name|ipfw_insn_if
modifier|*
name|cmdif
decl_stmt|;
name|urule
operator|=
operator|(
expr|struct
name|ip_fw_rule0
operator|*
operator|)
name|ci
operator|->
name|urule
expr_stmt|;
name|krule
operator|=
operator|(
expr|struct
name|ip_fw
operator|*
operator|)
name|ci
operator|->
name|krule
expr_stmt|;
comment|/* copy header */
name|krule
operator|->
name|act_ofs
operator|=
name|urule
operator|->
name|act_ofs
expr_stmt|;
name|krule
operator|->
name|cmd_len
operator|=
name|urule
operator|->
name|cmd_len
expr_stmt|;
name|krule
operator|->
name|rulenum
operator|=
name|urule
operator|->
name|rulenum
expr_stmt|;
name|krule
operator|->
name|set
operator|=
name|urule
operator|->
name|set
expr_stmt|;
if|if
condition|(
operator|(
name|urule
operator|->
name|_pad
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|krule
operator|->
name|flags
operator||=
name|IPFW_RULE_NOOPT
expr_stmt|;
comment|/* Save rulenum offset */
name|ci
operator|->
name|urule_numoff
operator|=
name|offsetof
argument_list|(
expr|struct
name|ip_fw_rule0
argument_list|,
name|rulenum
argument_list|)
expr_stmt|;
comment|/* Copy opcodes */
name|memcpy
argument_list|(
name|krule
operator|->
name|cmd
argument_list|,
name|urule
operator|->
name|cmd
argument_list|,
name|krule
operator|->
name|cmd_len
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Alter opcodes: 	 * 1) convert tablearg value from 65535 to 0 	 * 2) Add high bit to O_SETFIB/O_SETDSCP values (to make room 	 *    for targ). 	 * 3) convert table number in iface opcodes to u16 	 * 4) convert old `nat global` into new 65535 	 */
name|l
operator|=
name|krule
operator|->
name|cmd_len
expr_stmt|;
name|cmd
operator|=
name|krule
operator|->
name|cmd
expr_stmt|;
name|cmdlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|l
operator|>
literal|0
condition|;
name|l
operator|-=
name|cmdlen
operator|,
name|cmd
operator|+=
name|cmdlen
control|)
block|{
name|cmdlen
operator|=
name|F_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
operator|->
name|opcode
condition|)
block|{
comment|/* Opcodes supporting tablearg */
case|case
name|O_TAG
case|:
case|case
name|O_TAGGED
case|:
case|case
name|O_PIPE
case|:
case|case
name|O_QUEUE
case|:
case|case
name|O_DIVERT
case|:
case|case
name|O_TEE
case|:
case|case
name|O_SKIPTO
case|:
case|case
name|O_CALLRETURN
case|:
case|case
name|O_NETGRAPH
case|:
case|case
name|O_NGTEE
case|:
case|case
name|O_NAT
case|:
if|if
condition|(
name|cmd
operator|->
name|arg1
operator|==
name|IP_FW_TABLEARG
condition|)
name|cmd
operator|->
name|arg1
operator|=
name|IP_FW_TARG
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|arg1
operator|==
literal|0
condition|)
name|cmd
operator|->
name|arg1
operator|=
name|IP_FW_NAT44_GLOBAL
expr_stmt|;
break|break;
case|case
name|O_SETFIB
case|:
case|case
name|O_SETDSCP
case|:
if|if
condition|(
name|cmd
operator|->
name|arg1
operator|==
name|IP_FW_TABLEARG
condition|)
name|cmd
operator|->
name|arg1
operator|=
name|IP_FW_TARG
expr_stmt|;
else|else
name|cmd
operator|->
name|arg1
operator||=
literal|0x8000
expr_stmt|;
break|break;
case|case
name|O_LIMIT
case|:
name|lcmd
operator|=
operator|(
name|ipfw_insn_limit
operator|*
operator|)
name|cmd
expr_stmt|;
if|if
condition|(
name|lcmd
operator|->
name|conn_limit
operator|==
name|IP_FW_TABLEARG
condition|)
name|lcmd
operator|->
name|conn_limit
operator|=
name|IP_FW_TARG
expr_stmt|;
break|break;
comment|/* Interface tables */
case|case
name|O_XMIT
case|:
case|case
name|O_RECV
case|:
case|case
name|O_VIA
case|:
comment|/* Interface table, possibly */
name|cmdif
operator|=
operator|(
name|ipfw_insn_if
operator|*
operator|)
name|cmd
expr_stmt|;
if|if
condition|(
name|cmdif
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\1'
condition|)
break|break;
name|cmdif
operator|->
name|p
operator|.
name|kidx
operator|=
operator|(
name|uint16_t
operator|)
name|cmdif
operator|->
name|p
operator|.
name|glob
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Copies rule @krule from kernel to FreeBSD8 userland format (v0)  */
end_comment

begin_function
specifier|static
name|void
name|export_rule0
parameter_list|(
name|struct
name|ip_fw
modifier|*
name|krule
parameter_list|,
name|struct
name|ip_fw_rule0
modifier|*
name|urule
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|cmdlen
decl_stmt|,
name|l
decl_stmt|;
name|ipfw_insn
modifier|*
name|cmd
decl_stmt|;
name|ipfw_insn_limit
modifier|*
name|lcmd
decl_stmt|;
name|ipfw_insn_if
modifier|*
name|cmdif
decl_stmt|;
comment|/* copy header */
name|memset
argument_list|(
name|urule
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|urule
operator|->
name|act_ofs
operator|=
name|krule
operator|->
name|act_ofs
expr_stmt|;
name|urule
operator|->
name|cmd_len
operator|=
name|krule
operator|->
name|cmd_len
expr_stmt|;
name|urule
operator|->
name|rulenum
operator|=
name|krule
operator|->
name|rulenum
expr_stmt|;
name|urule
operator|->
name|set
operator|=
name|krule
operator|->
name|set
expr_stmt|;
if|if
condition|(
operator|(
name|krule
operator|->
name|flags
operator|&
name|IPFW_RULE_NOOPT
operator|)
operator|!=
literal|0
condition|)
name|urule
operator|->
name|_pad
operator||=
literal|1
expr_stmt|;
comment|/* Copy opcodes */
name|memcpy
argument_list|(
name|urule
operator|->
name|cmd
argument_list|,
name|krule
operator|->
name|cmd
argument_list|,
name|krule
operator|->
name|cmd_len
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Export counters */
name|export_cntr0_base
argument_list|(
name|krule
argument_list|,
operator|(
expr|struct
name|ip_fw_bcounter0
operator|*
operator|)
operator|&
name|urule
operator|->
name|pcnt
argument_list|)
expr_stmt|;
comment|/* 	 * Alter opcodes: 	 * 1) convert tablearg value from 0 to 65535 	 * 2) Remove highest bit from O_SETFIB/O_SETDSCP values. 	 * 3) convert table number in iface opcodes to int 	 */
name|l
operator|=
name|urule
operator|->
name|cmd_len
expr_stmt|;
name|cmd
operator|=
name|urule
operator|->
name|cmd
expr_stmt|;
name|cmdlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|l
operator|>
literal|0
condition|;
name|l
operator|-=
name|cmdlen
operator|,
name|cmd
operator|+=
name|cmdlen
control|)
block|{
name|cmdlen
operator|=
name|F_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
operator|->
name|opcode
condition|)
block|{
comment|/* Opcodes supporting tablearg */
case|case
name|O_TAG
case|:
case|case
name|O_TAGGED
case|:
case|case
name|O_PIPE
case|:
case|case
name|O_QUEUE
case|:
case|case
name|O_DIVERT
case|:
case|case
name|O_TEE
case|:
case|case
name|O_SKIPTO
case|:
case|case
name|O_CALLRETURN
case|:
case|case
name|O_NETGRAPH
case|:
case|case
name|O_NGTEE
case|:
case|case
name|O_NAT
case|:
if|if
condition|(
name|cmd
operator|->
name|arg1
operator|==
name|IP_FW_TARG
condition|)
name|cmd
operator|->
name|arg1
operator|=
name|IP_FW_TABLEARG
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|arg1
operator|==
name|IP_FW_NAT44_GLOBAL
condition|)
name|cmd
operator|->
name|arg1
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|O_SETFIB
case|:
case|case
name|O_SETDSCP
case|:
if|if
condition|(
name|cmd
operator|->
name|arg1
operator|==
name|IP_FW_TARG
condition|)
name|cmd
operator|->
name|arg1
operator|=
name|IP_FW_TABLEARG
expr_stmt|;
else|else
name|cmd
operator|->
name|arg1
operator|&=
operator|~
literal|0x8000
expr_stmt|;
break|break;
case|case
name|O_LIMIT
case|:
name|lcmd
operator|=
operator|(
name|ipfw_insn_limit
operator|*
operator|)
name|cmd
expr_stmt|;
if|if
condition|(
name|lcmd
operator|->
name|conn_limit
operator|==
name|IP_FW_TARG
condition|)
name|lcmd
operator|->
name|conn_limit
operator|=
name|IP_FW_TABLEARG
expr_stmt|;
break|break;
comment|/* Interface tables */
case|case
name|O_XMIT
case|:
case|case
name|O_RECV
case|:
case|case
name|O_VIA
case|:
comment|/* Interface table, possibly */
name|cmdif
operator|=
operator|(
name|ipfw_insn_if
operator|*
operator|)
name|cmd
expr_stmt|;
if|if
condition|(
name|cmdif
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\1'
condition|)
break|break;
name|cmdif
operator|->
name|p
operator|.
name|glob
operator|=
name|cmdif
operator|->
name|p
operator|.
name|kidx
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Add new rule(s) to the list possibly creating rule number for each.  * Update the rule_number in the input struct so the caller knows it as well.  * Must be called without IPFW_UH held  */
end_comment

begin_function
specifier|static
name|int
name|commit_rules
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|struct
name|rule_check_info
modifier|*
name|rci
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|insert_before
decl_stmt|,
name|tcount
decl_stmt|;
name|uint16_t
name|rulenum
decl_stmt|,
modifier|*
name|pnum
decl_stmt|;
name|struct
name|rule_check_info
modifier|*
name|ci
decl_stmt|;
name|struct
name|ip_fw
modifier|*
name|krule
decl_stmt|;
name|struct
name|ip_fw
modifier|*
modifier|*
name|map
decl_stmt|;
comment|/* the new array of pointers */
comment|/* Check if we need to do table/obj index remap */
name|tcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ci
operator|=
name|rci
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|ci
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ci
operator|->
name|object_opcodes
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Rule has some object opcodes. 		 * We need to find (and create non-existing) 		 * kernel objects, and reference existing ones. 		 */
name|error
operator|=
name|rewrite_rule_uidx
argument_list|(
name|chain
argument_list|,
name|ci
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * rewrite failed, state for current rule 			 * has been reverted. Check if we need to 			 * revert more. 			 */
if|if
condition|(
name|tcount
operator|>
literal|0
condition|)
block|{
comment|/* 				 * We have some more table rules 				 * we need to rollback. 				 */
name|IPFW_UH_WLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
while|while
condition|(
name|ci
operator|!=
name|rci
condition|)
block|{
name|ci
operator|--
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|object_opcodes
operator|==
literal|0
condition|)
continue|continue;
name|unref_rule_objects
argument_list|(
name|chain
argument_list|,
name|ci
operator|->
name|krule
argument_list|)
expr_stmt|;
block|}
name|IPFW_UH_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tcount
operator|++
expr_stmt|;
block|}
comment|/* get_map returns with IPFW_UH_WLOCK if successful */
name|map
operator|=
name|get_map
argument_list|(
name|chain
argument_list|,
name|count
argument_list|,
literal|0
comment|/* not locked */
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tcount
operator|>
literal|0
condition|)
block|{
comment|/* Unbind tables */
name|IPFW_UH_WLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
for|for
control|(
name|ci
operator|=
name|rci
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|ci
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ci
operator|->
name|object_opcodes
operator|==
literal|0
condition|)
continue|continue;
name|unref_rule_objects
argument_list|(
name|chain
argument_list|,
name|ci
operator|->
name|krule
argument_list|)
expr_stmt|;
block|}
name|IPFW_UH_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
if|if
condition|(
name|V_autoinc_step
operator|<
literal|1
condition|)
name|V_autoinc_step
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|V_autoinc_step
operator|>
literal|1000
condition|)
name|V_autoinc_step
operator|=
literal|1000
expr_stmt|;
comment|/* FIXME: Handle count> 1 */
name|ci
operator|=
name|rci
expr_stmt|;
name|krule
operator|=
name|ci
operator|->
name|krule
expr_stmt|;
name|rulenum
operator|=
name|krule
operator|->
name|rulenum
expr_stmt|;
comment|/* find the insertion point, we will insert before */
name|insert_before
operator|=
name|rulenum
condition|?
name|rulenum
operator|+
literal|1
else|:
name|IPFW_DEFAULT_RULE
expr_stmt|;
name|i
operator|=
name|ipfw_find_rule
argument_list|(
name|chain
argument_list|,
name|insert_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* duplicate first part */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|chain
operator|->
name|map
argument_list|,
name|map
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ip_fw
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|map
index|[
name|i
index|]
operator|=
name|krule
expr_stmt|;
comment|/* duplicate remaining part, we always have the default rule */
name|bcopy
argument_list|(
name|chain
operator|->
name|map
operator|+
name|i
argument_list|,
name|map
operator|+
name|i
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_fw
operator|*
argument_list|)
operator|*
operator|(
name|chain
operator|->
name|n_rules
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rulenum
operator|==
literal|0
condition|)
block|{
comment|/* Compute rule number and write it back */
name|rulenum
operator|=
name|i
operator|>
literal|0
condition|?
name|map
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|rulenum
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|rulenum
operator|<
name|IPFW_DEFAULT_RULE
operator|-
name|V_autoinc_step
condition|)
name|rulenum
operator|+=
name|V_autoinc_step
expr_stmt|;
name|krule
operator|->
name|rulenum
operator|=
name|rulenum
expr_stmt|;
comment|/* Save number to userland rule */
name|pnum
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ci
operator|->
name|urule
operator|+
name|ci
operator|->
name|urule_numoff
operator|)
expr_stmt|;
operator|*
name|pnum
operator|=
name|rulenum
expr_stmt|;
block|}
name|krule
operator|->
name|id
operator|=
name|chain
operator|->
name|id
operator|+
literal|1
expr_stmt|;
name|update_skipto_cache
argument_list|(
name|chain
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|map
operator|=
name|swap_map
argument_list|(
name|chain
argument_list|,
name|map
argument_list|,
name|chain
operator|->
name|n_rules
operator|+
literal|1
argument_list|)
expr_stmt|;
name|chain
operator|->
name|static_len
operator|+=
name|RULEUSIZE0
argument_list|(
name|krule
argument_list|)
expr_stmt|;
name|IPFW_UH_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
condition|)
name|free
argument_list|(
name|map
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adds @rule to the list of rules to reap  */
end_comment

begin_function
name|void
name|ipfw_reap_add
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|struct
name|ip_fw
modifier|*
modifier|*
name|head
parameter_list|,
name|struct
name|ip_fw
modifier|*
name|rule
parameter_list|)
block|{
name|IPFW_UH_WLOCK_ASSERT
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* Unlink rule from everywhere */
name|unref_rule_objects
argument_list|(
name|chain
argument_list|,
name|rule
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
expr|struct
name|ip_fw
operator|*
operator|*
operator|)
name|rule
operator|)
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|rule
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim storage associated with a list of rules.  This is  * typically the list created using remove_rule.  * A NULL pointer on input is handled correctly.  */
end_comment

begin_function
name|void
name|ipfw_reap_rules
parameter_list|(
name|struct
name|ip_fw
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|ip_fw
modifier|*
name|rule
decl_stmt|;
while|while
condition|(
operator|(
name|rule
operator|=
name|head
operator|)
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
operator|*
operator|(
operator|(
expr|struct
name|ip_fw
operator|*
operator|*
operator|)
name|head
operator|)
expr_stmt|;
name|free_rule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Rules to keep are  *	(default || reserved || !match_set || !match_number)  * where  *   default ::= (rule->rulenum == IPFW_DEFAULT_RULE)  *	// the default rule is always protected  *  *   reserved ::= (cmd == 0&& n == 0&& rule->set == RESVD_SET)  *	// RESVD_SET is protected only if cmd == 0 and n == 0 ("ipfw flush")  *  *   match_set ::= (cmd == 0 || rule->set == set)  *	// set number is ignored for cmd == 0  *  *   match_number ::= (cmd == 1 || n == 0 || n == rule->rulenum)  *	// number is ignored for cmd == 1 or n == 0  *  */
end_comment

begin_function
name|int
name|ipfw_match_range
parameter_list|(
name|struct
name|ip_fw
modifier|*
name|rule
parameter_list|,
name|ipfw_range_tlv
modifier|*
name|rt
parameter_list|)
block|{
comment|/* Don't match default rule for modification queries */
if|if
condition|(
name|rule
operator|->
name|rulenum
operator|==
name|IPFW_DEFAULT_RULE
operator|&&
operator|(
name|rt
operator|->
name|flags
operator|&
name|IPFW_RCFLAG_DEFAULT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Don't match rules in reserved set for flush requests */
if|if
condition|(
operator|(
name|rt
operator|->
name|flags
operator|&
name|IPFW_RCFLAG_ALL
operator|)
operator|!=
literal|0
operator|&&
name|rule
operator|->
name|set
operator|==
name|RESVD_SET
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If we're filtering by set, don't match other sets */
if|if
condition|(
operator|(
name|rt
operator|->
name|flags
operator|&
name|IPFW_RCFLAG_SET
operator|)
operator|!=
literal|0
operator|&&
name|rule
operator|->
name|set
operator|!=
name|rt
operator|->
name|set
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|rt
operator|->
name|flags
operator|&
name|IPFW_RCFLAG_RANGE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|rule
operator|->
name|rulenum
operator|<
name|rt
operator|->
name|start_rule
operator|||
name|rule
operator|->
name|rulenum
operator|>
name|rt
operator|->
name|end_rule
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|manage_sets_args
block|{
name|uint16_t
name|set
decl_stmt|;
name|uint8_t
name|new_set
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|swap_sets_cb
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|struct
name|named_object
modifier|*
name|no
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|manage_sets_args
modifier|*
name|args
decl_stmt|;
name|args
operator|=
operator|(
expr|struct
name|manage_sets_args
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|no
operator|->
name|set
operator|==
operator|(
name|uint8_t
operator|)
name|args
operator|->
name|set
condition|)
name|no
operator|->
name|set
operator|=
name|args
operator|->
name|new_set
expr_stmt|;
elseif|else
if|if
condition|(
name|no
operator|->
name|set
operator|==
name|args
operator|->
name|new_set
condition|)
name|no
operator|->
name|set
operator|=
operator|(
name|uint8_t
operator|)
name|args
operator|->
name|set
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|move_sets_cb
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|struct
name|named_object
modifier|*
name|no
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|manage_sets_args
modifier|*
name|args
decl_stmt|;
name|args
operator|=
operator|(
expr|struct
name|manage_sets_args
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|no
operator|->
name|set
operator|==
operator|(
name|uint8_t
operator|)
name|args
operator|->
name|set
condition|)
name|no
operator|->
name|set
operator|=
name|args
operator|->
name|new_set
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|test_sets_cb
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|struct
name|named_object
modifier|*
name|no
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|manage_sets_args
modifier|*
name|args
decl_stmt|;
name|args
operator|=
operator|(
expr|struct
name|manage_sets_args
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|no
operator|->
name|set
operator|!=
operator|(
name|uint8_t
operator|)
name|args
operator|->
name|set
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ipfw_objhash_lookup_name_type
argument_list|(
name|ni
argument_list|,
name|args
operator|->
name|new_set
argument_list|,
name|no
operator|->
name|etlv
argument_list|,
name|no
operator|->
name|name
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic function to handler moving and swapping sets.  */
end_comment

begin_function
name|int
name|ipfw_obj_manage_sets
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|set
parameter_list|,
name|uint8_t
name|new_set
parameter_list|,
name|enum
name|ipfw_sets_cmd
name|cmd
parameter_list|)
block|{
name|struct
name|manage_sets_args
name|args
decl_stmt|;
name|struct
name|named_object
modifier|*
name|no
decl_stmt|;
name|args
operator|.
name|set
operator|=
name|set
expr_stmt|;
name|args
operator|.
name|new_set
operator|=
name|new_set
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SWAP_ALL
case|:
return|return
operator|(
name|ipfw_objhash_foreach_type
argument_list|(
name|ni
argument_list|,
name|swap_sets_cb
argument_list|,
operator|&
name|args
argument_list|,
name|type
argument_list|)
operator|)
return|;
case|case
name|TEST_ALL
case|:
return|return
operator|(
name|ipfw_objhash_foreach_type
argument_list|(
name|ni
argument_list|,
name|test_sets_cb
argument_list|,
operator|&
name|args
argument_list|,
name|type
argument_list|)
operator|)
return|;
case|case
name|MOVE_ALL
case|:
return|return
operator|(
name|ipfw_objhash_foreach_type
argument_list|(
name|ni
argument_list|,
name|move_sets_cb
argument_list|,
operator|&
name|args
argument_list|,
name|type
argument_list|)
operator|)
return|;
case|case
name|COUNT_ONE
case|:
comment|/* 		 * @set used to pass kidx. 		 * When @new_set is zero - reset object counter, 		 * otherwise increment it. 		 */
name|no
operator|=
name|ipfw_objhash_lookup_kidx
argument_list|(
name|ni
argument_list|,
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_set
operator|!=
literal|0
condition|)
name|no
operator|->
name|ocnt
operator|++
expr_stmt|;
else|else
name|no
operator|->
name|ocnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TEST_ONE
case|:
comment|/* @set used to pass kidx */
name|no
operator|=
name|ipfw_objhash_lookup_kidx
argument_list|(
name|ni
argument_list|,
name|set
argument_list|)
expr_stmt|;
comment|/* 		 * First check number of references: 		 * when it differs, this mean other rules are holding 		 * reference to given object, so it is not possible to 		 * change its set. Note that refcnt may account references 		 * to some going-to-be-added rules. Since we don't know 		 * their numbers (and even if they will be added) it is 		 * perfectly OK to return error here. 		 */
if|if
condition|(
name|no
operator|->
name|ocnt
operator|!=
name|no
operator|->
name|refcnt
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|ipfw_objhash_lookup_name_type
argument_list|(
name|ni
argument_list|,
name|new_set
argument_list|,
name|type
argument_list|,
name|no
operator|->
name|name
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MOVE_ONE
case|:
comment|/* @set used to pass kidx */
name|no
operator|=
name|ipfw_objhash_lookup_kidx
argument_list|(
name|ni
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|no
operator|->
name|set
operator|=
name|new_set
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete rules matching range @rt.  * Saves number of deleted rules in @ndel.  *  * Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|delete_range
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ipfw_range_tlv
modifier|*
name|rt
parameter_list|,
name|int
modifier|*
name|ndel
parameter_list|)
block|{
name|struct
name|ip_fw
modifier|*
name|reap
decl_stmt|,
modifier|*
name|rule
decl_stmt|,
modifier|*
modifier|*
name|map
decl_stmt|;
name|int
name|end
decl_stmt|,
name|start
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|ndyn
decl_stmt|,
name|ofs
decl_stmt|;
name|reap
operator|=
name|NULL
expr_stmt|;
name|IPFW_UH_WLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* arbitrate writers */
comment|/* 	 * Stage 1: Determine range to inspect. 	 * Range is half-inclusive, e.g [start, end). 	 */
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|chain
operator|->
name|n_rules
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|->
name|flags
operator|&
name|IPFW_RCFLAG_RANGE
operator|)
operator|!=
literal|0
condition|)
block|{
name|start
operator|=
name|ipfw_find_rule
argument_list|(
name|chain
argument_list|,
name|rt
operator|->
name|start_rule
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
operator|=
name|ipfw_find_rule
argument_list|(
name|chain
argument_list|,
name|rt
operator|->
name|end_rule
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|end_rule
operator|!=
name|IPFW_DEFAULT_RULE
condition|)
while|while
condition|(
name|chain
operator|->
name|map
index|[
name|end
index|]
operator|->
name|rulenum
operator|==
name|rt
operator|->
name|end_rule
condition|)
name|end
operator|++
expr_stmt|;
block|}
comment|/* Allocate new map of the same size */
name|map
operator|=
name|get_map
argument_list|(
name|chain
argument_list|,
literal|0
argument_list|,
literal|1
comment|/* locked */
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
name|IPFW_UH_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
name|ndyn
operator|=
literal|0
expr_stmt|;
name|ofs
operator|=
name|start
expr_stmt|;
comment|/* 1. bcopy the initial part of the map */
if|if
condition|(
name|start
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|chain
operator|->
name|map
argument_list|,
name|map
argument_list|,
name|start
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ip_fw
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 2. copy active rules between start and end */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|rule
operator|=
name|chain
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ipfw_match_range
argument_list|(
name|rule
argument_list|,
name|rt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|map
index|[
name|ofs
operator|++
index|]
operator|=
name|rule
expr_stmt|;
continue|continue;
block|}
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|ipfw_is_dyn_rule
argument_list|(
name|rule
argument_list|)
operator|!=
literal|0
condition|)
name|ndyn
operator|++
expr_stmt|;
block|}
comment|/* 3. copy the final part of the map */
name|bcopy
argument_list|(
name|chain
operator|->
name|map
operator|+
name|end
argument_list|,
name|map
operator|+
name|ofs
argument_list|,
operator|(
name|chain
operator|->
name|n_rules
operator|-
name|end
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ip_fw
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 4. recalculate skipto cache */
name|update_skipto_cache
argument_list|(
name|chain
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* 5. swap the maps (under UH_WLOCK + WHLOCK) */
name|map
operator|=
name|swap_map
argument_list|(
name|chain
argument_list|,
name|map
argument_list|,
name|chain
operator|->
name|n_rules
operator|-
name|n
argument_list|)
expr_stmt|;
comment|/* 6. Remove all dynamic states originated by deleted rules */
if|if
condition|(
name|ndyn
operator|>
literal|0
condition|)
name|ipfw_expire_dyn_rules
argument_list|(
name|chain
argument_list|,
name|rt
argument_list|)
expr_stmt|;
comment|/* 7. now remove the rules deleted from the old map */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|rule
operator|=
name|map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ipfw_match_range
argument_list|(
name|rule
argument_list|,
name|rt
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|chain
operator|->
name|static_len
operator|-=
name|RULEUSIZE0
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|ipfw_reap_add
argument_list|(
name|chain
argument_list|,
operator|&
name|reap
argument_list|,
name|rule
argument_list|)
expr_stmt|;
block|}
name|IPFW_UH_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|ipfw_reap_rules
argument_list|(
name|reap
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|map
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
operator|*
name|ndel
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|move_objects
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|ipfw_range_tlv
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|opcode_obj_rewrite
modifier|*
name|rw
decl_stmt|;
name|struct
name|ip_fw
modifier|*
name|rule
decl_stmt|;
name|ipfw_insn
modifier|*
name|cmd
decl_stmt|;
name|int
name|cmdlen
decl_stmt|,
name|i
decl_stmt|,
name|l
decl_stmt|,
name|c
decl_stmt|;
name|uint16_t
name|kidx
decl_stmt|;
name|IPFW_UH_WLOCK_ASSERT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* Stage 1: count number of references by given rules */
for|for
control|(
name|c
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|n_rules
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|rule
operator|=
name|ch
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ipfw_match_range
argument_list|(
name|rule
argument_list|,
name|rt
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|rule
operator|->
name|set
operator|==
name|rt
operator|->
name|new_set
condition|)
comment|/* nothing to do */
continue|continue;
comment|/* Search opcodes with named objects */
for|for
control|(
name|l
operator|=
name|rule
operator|->
name|cmd_len
operator|,
name|cmdlen
operator|=
literal|0
operator|,
name|cmd
operator|=
name|rule
operator|->
name|cmd
init|;
name|l
operator|>
literal|0
condition|;
name|l
operator|-=
name|cmdlen
operator|,
name|cmd
operator|+=
name|cmdlen
control|)
block|{
name|cmdlen
operator|=
name|F_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|rw
operator|=
name|find_op_rw
argument_list|(
name|cmd
argument_list|,
operator|&
name|kidx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|NULL
operator|||
name|rw
operator|->
name|manage_sets
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 			 * When manage_sets() returns non-zero value to 			 * COUNT_ONE command, consider this as an object 			 * doesn't support sets (e.g. disabled with sysctl). 			 * So, skip checks for this object. 			 */
if|if
condition|(
name|rw
operator|->
name|manage_sets
argument_list|(
name|ch
argument_list|,
name|kidx
argument_list|,
literal|1
argument_list|,
name|COUNT_ONE
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|c
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
comment|/* No objects found */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Stage 2: verify "ownership" */
for|for
control|(
name|c
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|ch
operator|->
name|n_rules
operator|-
literal|1
operator|)
operator|&&
name|c
operator|==
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|rule
operator|=
name|ch
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ipfw_match_range
argument_list|(
name|rule
argument_list|,
name|rt
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|rule
operator|->
name|set
operator|==
name|rt
operator|->
name|new_set
condition|)
comment|/* nothing to do */
continue|continue;
comment|/* Search opcodes with named objects */
for|for
control|(
name|l
operator|=
name|rule
operator|->
name|cmd_len
operator|,
name|cmdlen
operator|=
literal|0
operator|,
name|cmd
operator|=
name|rule
operator|->
name|cmd
init|;
name|l
operator|>
literal|0
operator|&&
name|c
operator|==
literal|0
condition|;
name|l
operator|-=
name|cmdlen
operator|,
name|cmd
operator|+=
name|cmdlen
control|)
block|{
name|cmdlen
operator|=
name|F_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|rw
operator|=
name|find_op_rw
argument_list|(
name|cmd
argument_list|,
operator|&
name|kidx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|NULL
operator|||
name|rw
operator|->
name|manage_sets
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Test for ownership and conflicting names */
name|c
operator|=
name|rw
operator|->
name|manage_sets
argument_list|(
name|ch
argument_list|,
name|kidx
argument_list|,
operator|(
name|uint8_t
operator|)
name|rt
operator|->
name|new_set
argument_list|,
name|TEST_ONE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Stage 3: change set and cleanup */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|n_rules
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|rule
operator|=
name|ch
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ipfw_match_range
argument_list|(
name|rule
argument_list|,
name|rt
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|rule
operator|->
name|set
operator|==
name|rt
operator|->
name|new_set
condition|)
comment|/* nothing to do */
continue|continue;
comment|/* Search opcodes with named objects */
for|for
control|(
name|l
operator|=
name|rule
operator|->
name|cmd_len
operator|,
name|cmdlen
operator|=
literal|0
operator|,
name|cmd
operator|=
name|rule
operator|->
name|cmd
init|;
name|l
operator|>
literal|0
condition|;
name|l
operator|-=
name|cmdlen
operator|,
name|cmd
operator|+=
name|cmdlen
control|)
block|{
name|cmdlen
operator|=
name|F_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|rw
operator|=
name|find_op_rw
argument_list|(
name|cmd
argument_list|,
operator|&
name|kidx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|NULL
operator|||
name|rw
operator|->
name|manage_sets
operator|==
name|NULL
condition|)
continue|continue;
comment|/* cleanup object counter */
name|rw
operator|->
name|manage_sets
argument_list|(
name|ch
argument_list|,
name|kidx
argument_list|,
literal|0
comment|/* reset counter */
argument_list|,
name|COUNT_ONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
continue|continue;
comment|/* change set */
name|rw
operator|->
name|manage_sets
argument_list|(
name|ch
argument_list|,
name|kidx
argument_list|,
operator|(
name|uint8_t
operator|)
name|rt
operator|->
name|new_set
argument_list|,
name|MOVE_ONE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Changes set of given rule rannge @rt  * with each other.  *  * Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|move_range
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ipfw_range_tlv
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|ip_fw
modifier|*
name|rule
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IPFW_UH_WLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* 	 * Move rules with matching paramenerts to a new set. 	 * This one is much more complex. We have to ensure 	 * that all referenced tables (if any) are referenced 	 * by given rule subset only. Otherwise, we can't move 	 * them to new set and have to return error. 	 */
if|if
condition|(
operator|(
name|i
operator|=
name|move_objects
argument_list|(
name|chain
argument_list|,
name|rt
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|IPFW_UH_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
comment|/* XXX: We have to do swap holding WLOCK */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chain
operator|->
name|n_rules
condition|;
name|i
operator|++
control|)
block|{
name|rule
operator|=
name|chain
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ipfw_match_range
argument_list|(
name|rule
argument_list|,
name|rt
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|rule
operator|->
name|set
operator|=
name|rt
operator|->
name|new_set
expr_stmt|;
block|}
name|IPFW_UH_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear counters for a specific rule.  * Normally run under IPFW_UH_RLOCK, but these are idempotent ops  * so we only care that rules do not disappear.  */
end_comment

begin_function
specifier|static
name|void
name|clear_counters
parameter_list|(
name|struct
name|ip_fw
modifier|*
name|rule
parameter_list|,
name|int
name|log_only
parameter_list|)
block|{
name|ipfw_insn_log
modifier|*
name|l
init|=
operator|(
name|ipfw_insn_log
operator|*
operator|)
name|ACTION_PTR
argument_list|(
name|rule
argument_list|)
decl_stmt|;
if|if
condition|(
name|log_only
operator|==
literal|0
condition|)
name|IPFW_ZERO_RULE_COUNTER
argument_list|(
name|rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|o
operator|.
name|opcode
operator|==
name|O_LOG
condition|)
name|l
operator|->
name|log_left
operator|=
name|l
operator|->
name|max_log
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flushes rules counters and/or log values on matching range.  *  * Returns number of items cleared.  */
end_comment

begin_function
specifier|static
name|int
name|clear_range
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ipfw_range_tlv
modifier|*
name|rt
parameter_list|,
name|int
name|log_only
parameter_list|)
block|{
name|struct
name|ip_fw
modifier|*
name|rule
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|flags
operator||=
name|IPFW_RCFLAG_DEFAULT
expr_stmt|;
name|IPFW_UH_WLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* arbitrate writers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chain
operator|->
name|n_rules
condition|;
name|i
operator|++
control|)
block|{
name|rule
operator|=
name|chain
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ipfw_match_range
argument_list|(
name|rule
argument_list|,
name|rt
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|clear_counters
argument_list|(
name|rule
argument_list|,
name|log_only
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
name|IPFW_UH_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|num
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_range_tlv
parameter_list|(
name|ipfw_range_tlv
modifier|*
name|rt
parameter_list|)
block|{
if|if
condition|(
name|rt
operator|->
name|head
operator|.
name|length
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|rt
operator|->
name|start_rule
operator|>
name|rt
operator|->
name|end_rule
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|rt
operator|->
name|set
operator|>=
name|IPFW_MAX_SETS
operator|||
name|rt
operator|->
name|new_set
operator|>=
name|IPFW_MAX_SETS
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|rt
operator|->
name|flags
operator|&
name|IPFW_RCFLAG_USER
operator|)
operator|!=
name|rt
operator|->
name|flags
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete rules matching specified parameters  * Data layout (v0)(current):  * Request: [ ipfw_obj_header ipfw_range_tlv ]  * Reply: [ ipfw_obj_header ipfw_range_tlv ]  *  * Saves number of deleted rules in ipfw_range_tlv->new_set.  *  * Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|del_rules
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|ipfw_range_header
modifier|*
name|rh
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ndel
decl_stmt|;
if|if
condition|(
name|sd
operator|->
name|valsize
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|rh
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rh
operator|=
operator|(
name|ipfw_range_header
operator|*
operator|)
name|ipfw_get_sopt_space
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|valsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_range_tlv
argument_list|(
operator|&
name|rh
operator|->
name|range
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ndel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|delete_range
argument_list|(
name|chain
argument_list|,
operator|&
name|rh
operator|->
name|range
argument_list|,
operator|&
name|ndel
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Save number of rules deleted */
name|rh
operator|->
name|range
operator|.
name|new_set
operator|=
name|ndel
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move rules/sets matching specified parameters  * Data layout (v0)(current):  * Request: [ ipfw_obj_header ipfw_range_tlv ]  *  * Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|move_rules
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|ipfw_range_header
modifier|*
name|rh
decl_stmt|;
if|if
condition|(
name|sd
operator|->
name|valsize
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|rh
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rh
operator|=
operator|(
name|ipfw_range_header
operator|*
operator|)
name|ipfw_get_sopt_space
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|valsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_range_tlv
argument_list|(
operator|&
name|rh
operator|->
name|range
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|move_range
argument_list|(
name|chain
argument_list|,
operator|&
name|rh
operator|->
name|range
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear rule accounting data matching specified parameters  * Data layout (v0)(current):  * Request: [ ipfw_obj_header ipfw_range_tlv ]  * Reply: [ ipfw_obj_header ipfw_range_tlv ]  *  * Saves number of cleared rules in ipfw_range_tlv->new_set.  *  * Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|clear_rules
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|ipfw_range_header
modifier|*
name|rh
decl_stmt|;
name|int
name|log_only
decl_stmt|,
name|num
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|sd
operator|->
name|valsize
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|rh
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rh
operator|=
operator|(
name|ipfw_range_header
operator|*
operator|)
name|ipfw_get_sopt_space
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|valsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_range_tlv
argument_list|(
operator|&
name|rh
operator|->
name|range
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|log_only
operator|=
operator|(
name|op3
operator|->
name|opcode
operator|==
name|IP_FW_XRESETLOG
operator|)
expr_stmt|;
name|num
operator|=
name|clear_range
argument_list|(
name|chain
argument_list|,
operator|&
name|rh
operator|->
name|range
argument_list|,
name|log_only
argument_list|)
expr_stmt|;
if|if
condition|(
name|rh
operator|->
name|range
operator|.
name|flags
operator|&
name|IPFW_RCFLAG_ALL
condition|)
name|msg
operator|=
name|log_only
condition|?
literal|"All logging counts reset"
else|:
literal|"Accounting cleared"
expr_stmt|;
else|else
name|msg
operator|=
name|log_only
condition|?
literal|"logging count reset"
else|:
literal|"cleared"
expr_stmt|;
if|if
condition|(
name|V_fw_verbose
condition|)
block|{
name|int
name|lev
init|=
name|LOG_SECURITY
operator||
name|LOG_NOTICE
decl_stmt|;
name|log
argument_list|(
name|lev
argument_list|,
literal|"ipfw: %s.\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/* Save number of rules cleared */
name|rh
operator|->
name|range
operator|.
name|new_set
operator|=
name|num
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_sets
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ipfw_range_tlv
modifier|*
name|rt
parameter_list|)
block|{
name|uint32_t
name|v_set
decl_stmt|;
name|IPFW_UH_WLOCK_ASSERT
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* Change enabled/disabled sets mask */
name|v_set
operator|=
operator|(
name|V_set_disable
operator||
name|rt
operator|->
name|set
operator|)
operator|&
operator|~
name|rt
operator|->
name|new_set
expr_stmt|;
name|v_set
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|RESVD_SET
operator|)
expr_stmt|;
comment|/* set RESVD_SET always enabled */
name|IPFW_WLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|V_set_disable
operator|=
name|v_set
expr_stmt|;
name|IPFW_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|swap_sets
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ipfw_range_tlv
modifier|*
name|rt
parameter_list|,
name|int
name|mv
parameter_list|)
block|{
name|struct
name|opcode_obj_rewrite
modifier|*
name|rw
decl_stmt|;
name|struct
name|ip_fw
modifier|*
name|rule
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IPFW_UH_WLOCK_ASSERT
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|set
operator|==
name|rt
operator|->
name|new_set
condition|)
comment|/* nothing to do */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|mv
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Berfore moving the rules we need to check that 		 * there aren't any conflicting named objects. 		 */
for|for
control|(
name|rw
operator|=
name|ctl3_rewriters
init|;
name|rw
operator|<
name|ctl3_rewriters
operator|+
name|ctl3_rsize
condition|;
name|rw
operator|++
control|)
block|{
if|if
condition|(
name|rw
operator|->
name|manage_sets
operator|==
name|NULL
condition|)
continue|continue;
name|i
operator|=
name|rw
operator|->
name|manage_sets
argument_list|(
name|chain
argument_list|,
operator|(
name|uint8_t
operator|)
name|rt
operator|->
name|set
argument_list|,
operator|(
name|uint8_t
operator|)
name|rt
operator|->
name|new_set
argument_list|,
name|TEST_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
block|}
comment|/* Swap or move two sets */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chain
operator|->
name|n_rules
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|rule
operator|=
name|chain
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|set
operator|==
operator|(
name|uint8_t
operator|)
name|rt
operator|->
name|set
condition|)
name|rule
operator|->
name|set
operator|=
operator|(
name|uint8_t
operator|)
name|rt
operator|->
name|new_set
expr_stmt|;
elseif|else
if|if
condition|(
name|rule
operator|->
name|set
operator|==
operator|(
name|uint8_t
operator|)
name|rt
operator|->
name|new_set
operator|&&
name|mv
operator|==
literal|0
condition|)
name|rule
operator|->
name|set
operator|=
operator|(
name|uint8_t
operator|)
name|rt
operator|->
name|set
expr_stmt|;
block|}
for|for
control|(
name|rw
operator|=
name|ctl3_rewriters
init|;
name|rw
operator|<
name|ctl3_rewriters
operator|+
name|ctl3_rsize
condition|;
name|rw
operator|++
control|)
block|{
if|if
condition|(
name|rw
operator|->
name|manage_sets
operator|==
name|NULL
condition|)
continue|continue;
name|rw
operator|->
name|manage_sets
argument_list|(
name|chain
argument_list|,
operator|(
name|uint8_t
operator|)
name|rt
operator|->
name|set
argument_list|,
operator|(
name|uint8_t
operator|)
name|rt
operator|->
name|new_set
argument_list|,
name|mv
operator|!=
literal|0
condition|?
name|MOVE_ALL
else|:
name|SWAP_ALL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Swaps or moves set  * Data layout (v0)(current):  * Request: [ ipfw_obj_header ipfw_range_tlv ]  *  * Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|manage_sets
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|ipfw_range_header
modifier|*
name|rh
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|sd
operator|->
name|valsize
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|rh
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rh
operator|=
operator|(
name|ipfw_range_header
operator|*
operator|)
name|ipfw_get_sopt_space
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|valsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rh
operator|->
name|range
operator|.
name|head
operator|.
name|length
operator|!=
sizeof|sizeof
argument_list|(
name|ipfw_range_tlv
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* enable_sets() expects bitmasks. */
if|if
condition|(
name|op3
operator|->
name|opcode
operator|!=
name|IP_FW_SET_ENABLE
operator|&&
operator|(
name|rh
operator|->
name|range
operator|.
name|set
operator|>=
name|IPFW_MAX_SETS
operator|||
name|rh
operator|->
name|range
operator|.
name|new_set
operator|>=
name|IPFW_MAX_SETS
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ret
operator|=
literal|0
expr_stmt|;
name|IPFW_UH_WLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op3
operator|->
name|opcode
condition|)
block|{
case|case
name|IP_FW_SET_SWAP
case|:
case|case
name|IP_FW_SET_MOVE
case|:
name|ret
operator|=
name|swap_sets
argument_list|(
name|chain
argument_list|,
operator|&
name|rh
operator|->
name|range
argument_list|,
name|op3
operator|->
name|opcode
operator|==
name|IP_FW_SET_MOVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_FW_SET_ENABLE
case|:
name|enable_sets
argument_list|(
name|chain
argument_list|,
operator|&
name|rh
operator|->
name|range
argument_list|)
expr_stmt|;
break|break;
block|}
name|IPFW_UH_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Remove all rules with given number, or do set manipulation.  * Assumes chain != NULL&& *chain != NULL.  *  * The argument is an uint32_t. The low 16 bit are the rule or set number;  * the next 8 bits are the new set; the top 8 bits indicate the command:  *  *	0	delete rules numbered "rulenum"  *	1	delete rules in set "rulenum"  *	2	move rules "rulenum" to set "new_set"  *	3	move rules from set "rulenum" to set "new_set"  *	4	swap sets "rulenum" and "new_set"  *	5	delete rules "rulenum" and set "new_set"  */
end_comment

begin_function
specifier|static
name|int
name|del_entry
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|uint32_t
name|arg
parameter_list|)
block|{
name|uint32_t
name|num
decl_stmt|;
comment|/* rule number or old_set */
name|uint8_t
name|cmd
decl_stmt|,
name|new_set
decl_stmt|;
name|int
name|do_del
decl_stmt|,
name|ndel
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ipfw_range_tlv
name|rt
decl_stmt|;
name|num
operator|=
name|arg
operator|&
literal|0xffff
expr_stmt|;
name|cmd
operator|=
operator|(
name|arg
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|new_set
operator|=
operator|(
name|arg
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|cmd
operator|>
literal|5
operator|||
name|new_set
operator|>
name|RESVD_SET
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|cmd
operator|==
literal|0
operator|||
name|cmd
operator|==
literal|2
operator|||
name|cmd
operator|==
literal|5
condition|)
block|{
if|if
condition|(
name|num
operator|>=
name|IPFW_DEFAULT_RULE
condition|)
return|return
name|EINVAL
return|;
block|}
else|else
block|{
if|if
condition|(
name|num
operator|>
name|RESVD_SET
condition|)
comment|/* old_set */
return|return
name|EINVAL
return|;
block|}
comment|/* Convert old requests into new representation */
name|memset
argument_list|(
operator|&
name|rt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rt
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|.
name|start_rule
operator|=
name|num
expr_stmt|;
name|rt
operator|.
name|end_rule
operator|=
name|num
expr_stmt|;
name|rt
operator|.
name|set
operator|=
name|num
expr_stmt|;
name|rt
operator|.
name|new_set
operator|=
name|new_set
expr_stmt|;
name|do_del
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|0
case|:
comment|/* delete rules numbered "rulenum" */
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|rt
operator|.
name|flags
operator||=
name|IPFW_RCFLAG_ALL
expr_stmt|;
else|else
name|rt
operator|.
name|flags
operator||=
name|IPFW_RCFLAG_RANGE
expr_stmt|;
name|do_del
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* delete rules in set "rulenum" */
name|rt
operator|.
name|flags
operator||=
name|IPFW_RCFLAG_SET
expr_stmt|;
name|do_del
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* delete rules "rulenum" and set "new_set" */
name|rt
operator|.
name|flags
operator||=
name|IPFW_RCFLAG_RANGE
operator||
name|IPFW_RCFLAG_SET
expr_stmt|;
name|rt
operator|.
name|set
operator|=
name|new_set
expr_stmt|;
name|rt
operator|.
name|new_set
operator|=
literal|0
expr_stmt|;
name|do_del
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* move rules "rulenum" to set "new_set" */
name|rt
operator|.
name|flags
operator||=
name|IPFW_RCFLAG_RANGE
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* move rules from set "rulenum" to set "new_set" */
name|IPFW_UH_WLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|error
operator|=
name|swap_sets
argument_list|(
name|chain
argument_list|,
operator|&
name|rt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IPFW_UH_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
case|case
literal|4
case|:
comment|/* swap sets "rulenum" and "new_set" */
name|IPFW_UH_WLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|error
operator|=
name|swap_sets
argument_list|(
name|chain
argument_list|,
operator|&
name|rt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IPFW_UH_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
default|default:
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
if|if
condition|(
name|do_del
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|delete_range
argument_list|(
name|chain
argument_list|,
operator|&
name|rt
argument_list|,
operator|&
name|ndel
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ndel
operator|==
literal|0
operator|&&
operator|(
name|cmd
operator|!=
literal|1
operator|&&
name|num
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|move_range
argument_list|(
name|chain
argument_list|,
operator|&
name|rt
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Reset some or all counters on firewall rules.  * The argument `arg' is an u_int32_t. The low 16 bit are the rule number,  * the next 8 bits are the set number, the top 8 bits are the command:  *	0	work with rules from all set's;  *	1	work with rules only from specified set.  * Specified rule number is zero if we want to clear all entries.  * log_only is 1 if we only want to reset logs, zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|zero_entry
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|u_int32_t
name|arg
parameter_list|,
name|int
name|log_only
parameter_list|)
block|{
name|struct
name|ip_fw
modifier|*
name|rule
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|rulenum
init|=
name|arg
operator|&
literal|0xffff
decl_stmt|;
name|uint8_t
name|set
init|=
operator|(
name|arg
operator|>>
literal|16
operator|)
operator|&
literal|0xff
decl_stmt|;
name|uint8_t
name|cmd
init|=
operator|(
name|arg
operator|>>
literal|24
operator|)
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|cmd
operator|>
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cmd
operator|==
literal|1
operator|&&
name|set
operator|>
name|RESVD_SET
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|IPFW_UH_RLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|rulenum
operator|==
literal|0
condition|)
block|{
name|V_norule_counter
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chain
operator|->
name|n_rules
condition|;
name|i
operator|++
control|)
block|{
name|rule
operator|=
name|chain
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
comment|/* Skip rules not in our set. */
if|if
condition|(
name|cmd
operator|==
literal|1
operator|&&
name|rule
operator|->
name|set
operator|!=
name|set
condition|)
continue|continue;
name|clear_counters
argument_list|(
name|rule
argument_list|,
name|log_only
argument_list|)
expr_stmt|;
block|}
name|msg
operator|=
name|log_only
condition|?
literal|"All logging counts reset"
else|:
literal|"Accounting cleared"
expr_stmt|;
block|}
else|else
block|{
name|int
name|cleared
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chain
operator|->
name|n_rules
condition|;
name|i
operator|++
control|)
block|{
name|rule
operator|=
name|chain
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|rulenum
operator|==
name|rulenum
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
literal|0
operator|||
name|rule
operator|->
name|set
operator|==
name|set
condition|)
name|clear_counters
argument_list|(
name|rule
argument_list|,
name|log_only
argument_list|)
expr_stmt|;
name|cleared
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|->
name|rulenum
operator|>
name|rulenum
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|cleared
condition|)
block|{
comment|/* we did not find any matching rules */
name|IPFW_UH_RUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|msg
operator|=
name|log_only
condition|?
literal|"logging count reset"
else|:
literal|"cleared"
expr_stmt|;
block|}
name|IPFW_UH_RUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_fw_verbose
condition|)
block|{
name|int
name|lev
init|=
name|LOG_SECURITY
operator||
name|LOG_NOTICE
decl_stmt|;
if|if
condition|(
name|rulenum
condition|)
name|log
argument_list|(
name|lev
argument_list|,
literal|"ipfw: Entry %d %s.\n"
argument_list|,
name|rulenum
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|lev
argument_list|,
literal|"ipfw: %s.\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check rule head in FreeBSD11 format  *  */
end_comment

begin_function
specifier|static
name|int
name|check_ipfw_rule1
parameter_list|(
name|struct
name|ip_fw_rule
modifier|*
name|rule
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|rule_check_info
modifier|*
name|ci
parameter_list|)
block|{
name|int
name|l
decl_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|rule
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: rule too short\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check for valid cmd_len */
name|l
operator|=
name|roundup2
argument_list|(
name|RULESIZE
argument_list|(
name|rule
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|!=
name|size
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: size mismatch (have %d want %d)\n"
argument_list|,
name|size
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|rule
operator|->
name|act_ofs
operator|>=
name|rule
operator|->
name|cmd_len
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: bogus action offset (%u> %u)\n"
argument_list|,
name|rule
operator|->
name|act_ofs
argument_list|,
name|rule
operator|->
name|cmd_len
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|rule
operator|->
name|rulenum
operator|>
name|IPFW_DEFAULT_RULE
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|check_ipfw_rule_body
argument_list|(
name|rule
operator|->
name|cmd
argument_list|,
name|rule
operator|->
name|cmd_len
argument_list|,
name|ci
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check rule head in FreeBSD8 format  *  */
end_comment

begin_function
specifier|static
name|int
name|check_ipfw_rule0
parameter_list|(
name|struct
name|ip_fw_rule0
modifier|*
name|rule
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|rule_check_info
modifier|*
name|ci
parameter_list|)
block|{
name|int
name|l
decl_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|rule
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: rule too short\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check for valid cmd_len */
name|l
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rule
argument_list|)
operator|+
name|rule
operator|->
name|cmd_len
operator|*
literal|4
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|l
operator|!=
name|size
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: size mismatch (have %d want %d)\n"
argument_list|,
name|size
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|rule
operator|->
name|act_ofs
operator|>=
name|rule
operator|->
name|cmd_len
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: bogus action offset (%u> %u)\n"
argument_list|,
name|rule
operator|->
name|act_ofs
argument_list|,
name|rule
operator|->
name|cmd_len
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|rule
operator|->
name|rulenum
operator|>
name|IPFW_DEFAULT_RULE
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|check_ipfw_rule_body
argument_list|(
name|rule
operator|->
name|cmd
argument_list|,
name|rule
operator|->
name|cmd_len
argument_list|,
name|ci
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_ipfw_rule_body
parameter_list|(
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|int
name|cmd_len
parameter_list|,
name|struct
name|rule_check_info
modifier|*
name|ci
parameter_list|)
block|{
name|int
name|cmdlen
decl_stmt|,
name|l
decl_stmt|;
name|int
name|have_action
decl_stmt|;
name|have_action
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Now go for the individual checks. Very simple ones, basically only 	 * instruction sizes. 	 */
for|for
control|(
name|l
operator|=
name|cmd_len
init|;
name|l
operator|>
literal|0
condition|;
name|l
operator|-=
name|cmdlen
operator|,
name|cmd
operator|+=
name|cmdlen
control|)
block|{
name|cmdlen
operator|=
name|F_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdlen
operator|>
name|l
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: opcode %d size truncated\n"
argument_list|,
name|cmd
operator|->
name|opcode
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|cmd
operator|->
name|opcode
condition|)
block|{
case|case
name|O_PROBE_STATE
case|:
case|case
name|O_KEEP_STATE
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
name|ci
operator|->
name|object_opcodes
operator|++
expr_stmt|;
break|break;
case|case
name|O_PROTO
case|:
case|case
name|O_IP_SRC_ME
case|:
case|case
name|O_IP_DST_ME
case|:
case|case
name|O_LAYER2
case|:
case|case
name|O_IN
case|:
case|case
name|O_FRAG
case|:
case|case
name|O_DIVERTED
case|:
case|case
name|O_IPOPT
case|:
case|case
name|O_IPTOS
case|:
case|case
name|O_IPPRECEDENCE
case|:
case|case
name|O_IPVER
case|:
case|case
name|O_SOCKARG
case|:
case|case
name|O_TCPFLAGS
case|:
case|case
name|O_TCPOPTS
case|:
case|case
name|O_ESTAB
case|:
case|case
name|O_VERREVPATH
case|:
case|case
name|O_VERSRCREACH
case|:
case|case
name|O_ANTISPOOF
case|:
case|case
name|O_IPSEC
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|O_IP6_SRC_ME
case|:
case|case
name|O_IP6_DST_ME
case|:
case|case
name|O_EXT_HDR
case|:
case|case
name|O_IP6
case|:
endif|#
directive|endif
case|case
name|O_IP4
case|:
case|case
name|O_TAG
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
break|break;
case|case
name|O_EXTERNAL_ACTION
case|:
if|if
condition|(
name|cmd
operator|->
name|arg1
operator|==
literal|0
operator|||
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: invalid external "
literal|"action opcode\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ci
operator|->
name|object_opcodes
operator|++
expr_stmt|;
comment|/* 			 * Do we have O_EXTERNAL_INSTANCE or O_EXTERNAL_DATA 			 * opcode? 			 */
if|if
condition|(
name|l
operator|!=
name|cmdlen
condition|)
block|{
name|l
operator|-=
name|cmdlen
expr_stmt|;
name|cmd
operator|+=
name|cmdlen
expr_stmt|;
name|cmdlen
operator|=
name|F_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|opcode
operator|==
name|O_EXTERNAL_DATA
condition|)
goto|goto
name|check_action
goto|;
if|if
condition|(
name|cmd
operator|->
name|opcode
operator|!=
name|O_EXTERNAL_INSTANCE
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: invalid opcode "
literal|"next to external action %u\n"
argument_list|,
name|cmd
operator|->
name|opcode
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|cmd
operator|->
name|arg1
operator|==
literal|0
operator|||
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: invalid external "
literal|"action instance opcode\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ci
operator|->
name|object_opcodes
operator|++
expr_stmt|;
block|}
goto|goto
name|check_action
goto|;
case|case
name|O_FIB
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
if|if
condition|(
name|cmd
operator|->
name|arg1
operator|>=
name|rt_numfibs
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: invalid fib number %d\n"
argument_list|,
name|cmd
operator|->
name|arg1
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
break|break;
case|case
name|O_SETFIB
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
if|if
condition|(
operator|(
name|cmd
operator|->
name|arg1
operator|!=
name|IP_FW_TARG
operator|)
operator|&&
operator|(
operator|(
name|cmd
operator|->
name|arg1
operator|&
literal|0x7FFF
operator|)
operator|>=
name|rt_numfibs
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: invalid fib number %d\n"
argument_list|,
name|cmd
operator|->
name|arg1
operator|&
literal|0x7FFF
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
goto|goto
name|check_action
goto|;
case|case
name|O_UID
case|:
case|case
name|O_GID
case|:
case|case
name|O_JAIL
case|:
case|case
name|O_IP_SRC
case|:
case|case
name|O_IP_DST
case|:
case|case
name|O_TCPSEQ
case|:
case|case
name|O_TCPACK
case|:
case|case
name|O_PROB
case|:
case|case
name|O_ICMPTYPE
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_u32
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
break|break;
case|case
name|O_LIMIT
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_limit
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
name|ci
operator|->
name|object_opcodes
operator|++
expr_stmt|;
break|break;
case|case
name|O_LOG
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_log
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
operator|(
operator|(
name|ipfw_insn_log
operator|*
operator|)
name|cmd
operator|)
operator|->
name|log_left
operator|=
operator|(
operator|(
name|ipfw_insn_log
operator|*
operator|)
name|cmd
operator|)
operator|->
name|max_log
expr_stmt|;
break|break;
case|case
name|O_IP_SRC_MASK
case|:
case|case
name|O_IP_DST_MASK
case|:
comment|/* only odd command lengths */
if|if
condition|(
operator|(
name|cmdlen
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
goto|goto
name|bad_size
goto|;
break|break;
case|case
name|O_IP_SRC_SET
case|:
case|case
name|O_IP_DST_SET
case|:
if|if
condition|(
name|cmd
operator|->
name|arg1
operator|==
literal|0
operator|||
name|cmd
operator|->
name|arg1
operator|>
literal|256
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: invalid set size %d\n"
argument_list|,
name|cmd
operator|->
name|arg1
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_u32
argument_list|)
operator|+
operator|(
name|cmd
operator|->
name|arg1
operator|+
literal|31
operator|)
operator|/
literal|32
condition|)
goto|goto
name|bad_size
goto|;
break|break;
case|case
name|O_IP_SRC_LOOKUP
case|:
if|if
condition|(
name|cmdlen
operator|>
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_u32
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
case|case
name|O_IP_DST_LOOKUP
case|:
if|if
condition|(
name|cmd
operator|->
name|arg1
operator|>=
name|V_fw_tables_max
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: invalid table number %d\n"
argument_list|,
name|cmd
operator|->
name|arg1
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn
argument_list|)
operator|&&
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_u32
argument_list|)
operator|+
literal|1
operator|&&
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_u32
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
name|ci
operator|->
name|object_opcodes
operator|++
expr_stmt|;
break|break;
case|case
name|O_IP_FLOW_LOOKUP
case|:
if|if
condition|(
name|cmd
operator|->
name|arg1
operator|>=
name|V_fw_tables_max
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: invalid table number %d\n"
argument_list|,
name|cmd
operator|->
name|arg1
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn
argument_list|)
operator|&&
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_u32
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
name|ci
operator|->
name|object_opcodes
operator|++
expr_stmt|;
break|break;
case|case
name|O_MACADDR2
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_mac
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
break|break;
case|case
name|O_NOP
case|:
case|case
name|O_IPID
case|:
case|case
name|O_IPTTL
case|:
case|case
name|O_IPLEN
case|:
case|case
name|O_TCPDATALEN
case|:
case|case
name|O_TCPWIN
case|:
case|case
name|O_TAGGED
case|:
if|if
condition|(
name|cmdlen
operator|<
literal|1
operator|||
name|cmdlen
operator|>
literal|31
condition|)
goto|goto
name|bad_size
goto|;
break|break;
case|case
name|O_DSCP
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_u32
argument_list|)
operator|+
literal|1
condition|)
goto|goto
name|bad_size
goto|;
break|break;
case|case
name|O_MAC_TYPE
case|:
case|case
name|O_IP_SRCPORT
case|:
case|case
name|O_IP_DSTPORT
case|:
comment|/* XXX artificial limit, 30 port pairs */
if|if
condition|(
name|cmdlen
operator|<
literal|2
operator|||
name|cmdlen
operator|>
literal|31
condition|)
goto|goto
name|bad_size
goto|;
break|break;
case|case
name|O_RECV
case|:
case|case
name|O_XMIT
case|:
case|case
name|O_VIA
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_if
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
name|ci
operator|->
name|object_opcodes
operator|++
expr_stmt|;
break|break;
case|case
name|O_ALTQ
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_altq
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
break|break;
case|case
name|O_PIPE
case|:
case|case
name|O_QUEUE
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
goto|goto
name|check_action
goto|;
case|case
name|O_FORWARD_IP
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_sa
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
goto|goto
name|check_action
goto|;
ifdef|#
directive|ifdef
name|INET6
case|case
name|O_FORWARD_IP6
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_sa6
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
goto|goto
name|check_action
goto|;
endif|#
directive|endif
comment|/* INET6 */
case|case
name|O_DIVERT
case|:
case|case
name|O_TEE
case|:
if|if
condition|(
name|ip_divert_ptr
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
else|else
goto|goto
name|check_size
goto|;
case|case
name|O_NETGRAPH
case|:
case|case
name|O_NGTEE
case|:
if|if
condition|(
name|ng_ipfw_input_p
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
else|else
goto|goto
name|check_size
goto|;
case|case
name|O_NAT
case|:
if|if
condition|(
operator|!
name|IPFW_NAT_LOADED
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_nat
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
goto|goto
name|check_action
goto|;
case|case
name|O_CHECK_STATE
case|:
name|ci
operator|->
name|object_opcodes
operator|++
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|O_FORWARD_MAC
case|:
comment|/* XXX not implemented yet */
case|case
name|O_COUNT
case|:
case|case
name|O_ACCEPT
case|:
case|case
name|O_DENY
case|:
case|case
name|O_REJECT
case|:
case|case
name|O_SETDSCP
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|O_UNREACH6
case|:
endif|#
directive|endif
case|case
name|O_SKIPTO
case|:
case|case
name|O_REASS
case|:
case|case
name|O_CALLRETURN
case|:
name|check_size
label|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
name|check_action
label|:
if|if
condition|(
name|have_action
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: opcode %d, multiple actions"
literal|" not allowed\n"
argument_list|,
name|cmd
operator|->
name|opcode
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|have_action
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|l
operator|!=
name|cmdlen
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: opcode %d, action must be"
literal|" last opcode\n"
argument_list|,
name|cmd
operator|->
name|opcode
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|O_IP6_SRC
case|:
case|case
name|O_IP6_DST
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|+
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
break|break;
case|case
name|O_FLOW6ID
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_u32
argument_list|)
operator|+
operator|(
operator|(
name|ipfw_insn_u32
operator|*
operator|)
name|cmd
operator|)
operator|->
name|o
operator|.
name|arg1
condition|)
goto|goto
name|bad_size
goto|;
break|break;
case|case
name|O_IP6_SRC_MASK
case|:
case|case
name|O_IP6_DST_MASK
case|:
if|if
condition|(
operator|!
operator|(
name|cmdlen
operator|&
literal|1
operator|)
operator|||
name|cmdlen
operator|>
literal|127
condition|)
goto|goto
name|bad_size
goto|;
break|break;
case|case
name|O_ICMP6TYPE
case|:
if|if
condition|(
name|cmdlen
operator|!=
name|F_INSN_SIZE
argument_list|(
name|ipfw_insn_icmp6
argument_list|)
condition|)
goto|goto
name|bad_size
goto|;
break|break;
endif|#
directive|endif
default|default:
switch|switch
condition|(
name|cmd
operator|->
name|opcode
condition|)
block|{
ifndef|#
directive|ifndef
name|INET6
case|case
name|O_IP6_SRC_ME
case|:
case|case
name|O_IP6_DST_ME
case|:
case|case
name|O_EXT_HDR
case|:
case|case
name|O_IP6
case|:
case|case
name|O_UNREACH6
case|:
case|case
name|O_IP6_SRC
case|:
case|case
name|O_IP6_DST
case|:
case|case
name|O_FLOW6ID
case|:
case|case
name|O_IP6_SRC_MASK
case|:
case|case
name|O_IP6_DST_MASK
case|:
case|case
name|O_ICMP6TYPE
case|:
name|printf
argument_list|(
literal|"ipfw: no IPv6 support in kernel\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"ipfw: opcode %d, unknown opcode\n"
argument_list|,
name|cmd
operator|->
name|opcode
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|have_action
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: missing action\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
literal|0
return|;
name|bad_size
label|:
name|printf
argument_list|(
literal|"ipfw: opcode %d size %d wrong\n"
argument_list|,
name|cmd
operator|->
name|opcode
argument_list|,
name|cmdlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Translation of requests for compatibility with FreeBSD 7.2/8.  * a static variable tells us if we have an old client from userland,  * and if necessary we translate requests and responses between the  * two formats.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|is7
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ip_fw7
block|{
name|struct
name|ip_fw7
modifier|*
name|next
decl_stmt|;
comment|/* linked list of rules     */
name|struct
name|ip_fw7
modifier|*
name|next_rule
decl_stmt|;
comment|/* ptr to next [skipto] rule    */
comment|/* 'next_rule' is used to pass up 'set_disable' status      */
name|uint16_t
name|act_ofs
decl_stmt|;
comment|/* offset of action in 32-bit units */
name|uint16_t
name|cmd_len
decl_stmt|;
comment|/* # of 32-bit words in cmd */
name|uint16_t
name|rulenum
decl_stmt|;
comment|/* rule number          */
name|uint8_t
name|set
decl_stmt|;
comment|/* rule set (0..31)     */
comment|// #define RESVD_SET   31  /* set for default and persistent rules */
name|uint8_t
name|_pad
decl_stmt|;
comment|/* padding          */
comment|// uint32_t        id;             /* rule id, only in v.8 */
comment|/* These fields are present in all rules.           */
name|uint64_t
name|pcnt
decl_stmt|;
comment|/* Packet counter       */
name|uint64_t
name|bcnt
decl_stmt|;
comment|/* Byte counter         */
name|uint32_t
name|timestamp
decl_stmt|;
comment|/* tv_sec of last match     */
name|ipfw_insn
name|cmd
index|[
literal|1
index|]
decl_stmt|;
comment|/* storage for commands     */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|convert_rule_to_7
parameter_list|(
name|struct
name|ip_fw_rule0
modifier|*
name|rule
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|convert_rule_to_8
parameter_list|(
name|struct
name|ip_fw_rule0
modifier|*
name|rule
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|RULESIZE7
end_ifndef

begin_define
define|#
directive|define
name|RULESIZE7
parameter_list|(
name|rule
parameter_list|)
value|(sizeof(struct ip_fw7) + \ 	((struct ip_fw7 *)(rule))->cmd_len * 4 - 4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Copy the static and dynamic rules to the supplied buffer  * and return the amount of space actually used.  * Must be run under IPFW_UH_RLOCK  */
end_comment

begin_function
specifier|static
name|size_t
name|ipfw_getrules
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|space
parameter_list|)
block|{
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|ep
init|=
name|bp
operator|+
name|space
decl_stmt|;
name|struct
name|ip_fw
modifier|*
name|rule
decl_stmt|;
name|struct
name|ip_fw_rule0
modifier|*
name|dst
decl_stmt|;
name|struct
name|timeval
name|boottime
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|l
decl_stmt|,
name|warnflag
decl_stmt|;
name|time_t
name|boot_seconds
decl_stmt|;
name|warnflag
operator|=
literal|0
expr_stmt|;
name|getboottime
argument_list|(
operator|&
name|boottime
argument_list|)
expr_stmt|;
name|boot_seconds
operator|=
name|boottime
operator|.
name|tv_sec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chain
operator|->
name|n_rules
condition|;
name|i
operator|++
control|)
block|{
name|rule
operator|=
name|chain
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|is7
condition|)
block|{
comment|/* Convert rule to FreeBSd 7.2 format */
name|l
operator|=
name|RULESIZE7
argument_list|(
name|rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|+
name|l
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|<=
name|ep
condition|)
block|{
name|bcopy
argument_list|(
name|rule
argument_list|,
name|bp
argument_list|,
name|l
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|set_legacy_obj_kidx
argument_list|(
name|chain
argument_list|,
operator|(
expr|struct
name|ip_fw_rule0
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|convert_rule_to_7
argument_list|(
operator|(
expr|struct
name|ip_fw_rule0
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
literal|0
return|;
comment|/*XXX correct? */
comment|/* 			 * XXX HACK. Store the disable mask in the "next" 			 * pointer in a wild attempt to keep the ABI the same. 			 * Why do we do this on EVERY rule? 			 */
name|bcopy
argument_list|(
operator|&
name|V_set_disable
argument_list|,
operator|&
operator|(
operator|(
operator|(
expr|struct
name|ip_fw7
operator|*
operator|)
name|bp
operator|)
operator|->
name|next_rule
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|V_set_disable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|ip_fw7
operator|*
operator|)
name|bp
operator|)
operator|->
name|timestamp
condition|)
operator|(
operator|(
expr|struct
name|ip_fw7
operator|*
operator|)
name|bp
operator|)
operator|->
name|timestamp
operator|+=
name|boot_seconds
expr_stmt|;
name|bp
operator|+=
name|l
expr_stmt|;
block|}
continue|continue;
comment|/* go to next rule */
block|}
name|l
operator|=
name|RULEUSIZE0
argument_list|(
name|rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|+
name|l
operator|>
name|ep
condition|)
block|{
comment|/* should not happen */
name|printf
argument_list|(
literal|"overflow dumping static rules\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|dst
operator|=
operator|(
expr|struct
name|ip_fw_rule0
operator|*
operator|)
name|bp
expr_stmt|;
name|export_rule0
argument_list|(
name|rule
argument_list|,
name|dst
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|error
operator|=
name|set_legacy_obj_kidx
argument_list|(
name|chain
argument_list|,
name|dst
argument_list|)
expr_stmt|;
comment|/* 		 * XXX HACK. Store the disable mask in the "next" 		 * pointer in a wild attempt to keep the ABI the same. 		 * Why do we do this on EVERY rule? 		 * 		 * XXX: "ipfw set show" (ab)uses IP_FW_GET to read disabled mask 		 * so we need to fail _after_ saving at least one mask. 		 */
name|bcopy
argument_list|(
operator|&
name|V_set_disable
argument_list|,
operator|&
name|dst
operator|->
name|next_rule
argument_list|,
sizeof|sizeof
argument_list|(
name|V_set_disable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|timestamp
condition|)
name|dst
operator|->
name|timestamp
operator|+=
name|boot_seconds
expr_stmt|;
name|bp
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|2
condition|)
block|{
comment|/* Non-fatal table rewrite error. */
name|warnflag
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"Stop on rule %d. Fail to convert table\n"
argument_list|,
name|rule
operator|->
name|rulenum
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|warnflag
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"ipfw: process %s is using legacy interfaces,"
literal|" consider rebuilding\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ipfw_get_dynamic
argument_list|(
name|chain
argument_list|,
operator|&
name|bp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* protected by the dynamic lock */
return|return
operator|(
name|bp
operator|-
operator|(
name|char
operator|*
operator|)
name|buf
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|dump_args
block|{
name|uint32_t
name|b
decl_stmt|;
comment|/* start rule */
name|uint32_t
name|e
decl_stmt|;
comment|/* end rule */
name|uint32_t
name|rcount
decl_stmt|;
comment|/* number of rules */
name|uint32_t
name|rsize
decl_stmt|;
comment|/* rules size */
name|uint32_t
name|tcount
decl_stmt|;
comment|/* number of tables */
name|int
name|rcounters
decl_stmt|;
comment|/* counters */
block|}
struct|;
end_struct

begin_function
name|void
name|ipfw_export_obj_ntlv
parameter_list|(
name|struct
name|named_object
modifier|*
name|no
parameter_list|,
name|ipfw_obj_ntlv
modifier|*
name|ntlv
parameter_list|)
block|{
name|ntlv
operator|->
name|head
operator|.
name|type
operator|=
name|no
operator|->
name|etlv
expr_stmt|;
name|ntlv
operator|->
name|head
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ntlv
argument_list|)
expr_stmt|;
name|ntlv
operator|->
name|idx
operator|=
name|no
operator|->
name|kidx
expr_stmt|;
name|strlcpy
argument_list|(
name|ntlv
operator|->
name|name
argument_list|,
name|no
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlv
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Export named object info in instance @ni, identified by @kidx  * to ipfw_obj_ntlv. TLV is allocated from @sd space.  *  * Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|export_objhash_ntlv
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|uint16_t
name|kidx
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|struct
name|named_object
modifier|*
name|no
decl_stmt|;
name|ipfw_obj_ntlv
modifier|*
name|ntlv
decl_stmt|;
name|no
operator|=
name|ipfw_objhash_lookup_kidx
argument_list|(
name|ni
argument_list|,
name|kidx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|no
operator|!=
name|NULL
argument_list|,
operator|(
literal|"invalid object kernel index passed"
operator|)
argument_list|)
expr_stmt|;
name|ntlv
operator|=
operator|(
name|ipfw_obj_ntlv
operator|*
operator|)
name|ipfw_get_sopt_space
argument_list|(
name|sd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ntlv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntlv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ipfw_export_obj_ntlv
argument_list|(
name|no
argument_list|,
name|ntlv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dumps static rules with table TLVs in buffer @sd.  *  * Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|dump_static_rules
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|struct
name|dump_args
modifier|*
name|da
parameter_list|,
name|uint32_t
modifier|*
name|bmask
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|uint32_t
name|tcount
decl_stmt|;
name|ipfw_obj_ctlv
modifier|*
name|ctlv
decl_stmt|;
name|struct
name|ip_fw
modifier|*
name|krule
decl_stmt|;
name|struct
name|namedobj_instance
modifier|*
name|ni
decl_stmt|;
name|caddr_t
name|dst
decl_stmt|;
comment|/* Dump table names first (if any) */
if|if
condition|(
name|da
operator|->
name|tcount
operator|>
literal|0
condition|)
block|{
comment|/* Header first */
name|ctlv
operator|=
operator|(
name|ipfw_obj_ctlv
operator|*
operator|)
name|ipfw_get_sopt_space
argument_list|(
name|sd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctlv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ctlv
operator|->
name|head
operator|.
name|type
operator|=
name|IPFW_TLV_TBLNAME_LIST
expr_stmt|;
name|ctlv
operator|->
name|head
operator|.
name|length
operator|=
name|da
operator|->
name|tcount
operator|*
sizeof|sizeof
argument_list|(
name|ipfw_obj_ntlv
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ctlv
argument_list|)
expr_stmt|;
name|ctlv
operator|->
name|count
operator|=
name|da
operator|->
name|tcount
expr_stmt|;
name|ctlv
operator|->
name|objsize
operator|=
sizeof|sizeof
argument_list|(
name|ipfw_obj_ntlv
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|tcount
operator|=
name|da
operator|->
name|tcount
expr_stmt|;
name|ni
operator|=
name|ipfw_get_table_objhash
argument_list|(
name|chain
argument_list|)
expr_stmt|;
while|while
condition|(
name|tcount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|bmask
index|[
name|i
operator|/
literal|32
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
literal|32
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Jump to shared named object bitmask */
if|if
condition|(
name|i
operator|>=
name|IPFW_TABLES_MAX
condition|)
block|{
name|ni
operator|=
name|CHAIN_TO_SRV
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|i
operator|-=
name|IPFW_TABLES_MAX
expr_stmt|;
name|bmask
operator|+=
name|IPFW_TABLES_MAX
operator|/
literal|32
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|export_objhash_ntlv
argument_list|(
name|ni
argument_list|,
name|i
argument_list|,
name|sd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|i
operator|++
expr_stmt|;
name|tcount
operator|--
expr_stmt|;
block|}
comment|/* Dump rules */
name|ctlv
operator|=
operator|(
name|ipfw_obj_ctlv
operator|*
operator|)
name|ipfw_get_sopt_space
argument_list|(
name|sd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctlv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ctlv
operator|->
name|head
operator|.
name|type
operator|=
name|IPFW_TLV_RULE_LIST
expr_stmt|;
name|ctlv
operator|->
name|head
operator|.
name|length
operator|=
name|da
operator|->
name|rsize
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ctlv
argument_list|)
expr_stmt|;
name|ctlv
operator|->
name|count
operator|=
name|da
operator|->
name|rcount
expr_stmt|;
for|for
control|(
name|i
operator|=
name|da
operator|->
name|b
init|;
name|i
operator|<
name|da
operator|->
name|e
condition|;
name|i
operator|++
control|)
block|{
name|krule
operator|=
name|chain
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
name|l
operator|=
name|RULEUSIZE1
argument_list|(
name|krule
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ipfw_obj_tlv
argument_list|)
expr_stmt|;
if|if
condition|(
name|da
operator|->
name|rcounters
operator|!=
literal|0
condition|)
name|l
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip_fw_bcounter
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|(
name|caddr_t
operator|)
name|ipfw_get_sopt_space
argument_list|(
name|sd
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|export_rule1
argument_list|(
name|krule
argument_list|,
name|dst
argument_list|,
name|l
argument_list|,
name|da
operator|->
name|rcounters
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Marks every object index used in @rule with bit in @bmask.  * Used to generate bitmask of referenced tables/objects for given ruleset  * or its part.  *  * Returns number of newly-referenced objects.  */
end_comment

begin_function
specifier|static
name|int
name|mark_object_kidx
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|struct
name|ip_fw
modifier|*
name|rule
parameter_list|,
name|uint32_t
modifier|*
name|bmask
parameter_list|)
block|{
name|struct
name|opcode_obj_rewrite
modifier|*
name|rw
decl_stmt|;
name|ipfw_insn
modifier|*
name|cmd
decl_stmt|;
name|int
name|bidx
decl_stmt|,
name|cmdlen
decl_stmt|,
name|l
decl_stmt|,
name|count
decl_stmt|;
name|uint16_t
name|kidx
decl_stmt|;
name|uint8_t
name|subtype
decl_stmt|;
name|l
operator|=
name|rule
operator|->
name|cmd_len
expr_stmt|;
name|cmd
operator|=
name|rule
operator|->
name|cmd
expr_stmt|;
name|cmdlen
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|l
operator|>
literal|0
condition|;
name|l
operator|-=
name|cmdlen
operator|,
name|cmd
operator|+=
name|cmdlen
control|)
block|{
name|cmdlen
operator|=
name|F_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|rw
operator|=
name|find_op_rw
argument_list|(
name|cmd
argument_list|,
operator|&
name|kidx
argument_list|,
operator|&
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|NULL
condition|)
continue|continue;
name|bidx
operator|=
name|kidx
operator|/
literal|32
expr_stmt|;
comment|/* 		 * Maintain separate bitmasks for table and 		 * non-table objects. 		 */
if|if
condition|(
name|rw
operator|->
name|etlv
operator|!=
name|IPFW_TLV_TBL_NAME
condition|)
name|bidx
operator|+=
name|IPFW_TABLES_MAX
operator|/
literal|32
expr_stmt|;
if|if
condition|(
operator|(
name|bmask
index|[
name|bidx
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|kidx
operator|%
literal|32
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
name|count
operator|++
expr_stmt|;
name|bmask
index|[
name|bidx
index|]
operator||=
literal|1
operator|<<
operator|(
name|kidx
operator|%
literal|32
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dumps requested objects data  * Data layout (version 0)(current):  * Request: [ ipfw_cfg_lheader ] + IPFW_CFG_GET_* flags  *   size = ipfw_cfg_lheader.size  * Reply: [ ipfw_cfg_lheader   *   [ ipfw_obj_ctlv(IPFW_TLV_TBL_LIST) ipfw_obj_ntlv x N ] (optional)  *   [ ipfw_obj_ctlv(IPFW_TLV_RULE_LIST)  *     ipfw_obj_tlv(IPFW_TLV_RULE_ENT) [ ip_fw_bcounter (optional) ip_fw_rule ]  *   ] (optional)  *   [ ipfw_obj_ctlv(IPFW_TLV_STATE_LIST) ipfw_obj_dyntlv x N ] (optional)  * ]  * * NOTE IPFW_TLV_STATE_LIST has the single valid field: objsize.  * The rest (size, count) are set to zero and needs to be ignored.  *  * Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|dump_config
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|ipfw_cfg_lheader
modifier|*
name|hdr
decl_stmt|;
name|struct
name|ip_fw
modifier|*
name|rule
decl_stmt|;
name|size_t
name|sz
decl_stmt|,
name|rnum
decl_stmt|;
name|uint32_t
name|hdr_flags
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|dump_args
name|da
decl_stmt|;
name|uint32_t
modifier|*
name|bmask
decl_stmt|;
name|hdr
operator|=
operator|(
name|ipfw_cfg_lheader
operator|*
operator|)
name|ipfw_get_sopt_header
argument_list|(
name|sd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|bmask
operator|=
name|NULL
expr_stmt|;
comment|/* Allocate needed state. Note we allocate 2xspace mask, for table&srv  */
if|if
condition|(
name|hdr
operator|->
name|flags
operator|&
name|IPFW_CFG_GET_STATIC
condition|)
name|bmask
operator|=
name|malloc
argument_list|(
name|IPFW_TABLES_MAX
operator|/
literal|4
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|IPFW_UH_RLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* 	 * STAGE 1: Determine size/count for objects in range. 	 * Prepare used tables bitmask. 	 */
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|ipfw_cfg_lheader
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|da
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|da
argument_list|)
argument_list|)
expr_stmt|;
name|da
operator|.
name|b
operator|=
literal|0
expr_stmt|;
name|da
operator|.
name|e
operator|=
name|chain
operator|->
name|n_rules
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|end_rule
operator|!=
literal|0
condition|)
block|{
comment|/* Handle custom range */
if|if
condition|(
operator|(
name|rnum
operator|=
name|hdr
operator|->
name|start_rule
operator|)
operator|>
name|IPFW_DEFAULT_RULE
condition|)
name|rnum
operator|=
name|IPFW_DEFAULT_RULE
expr_stmt|;
name|da
operator|.
name|b
operator|=
name|ipfw_find_rule
argument_list|(
name|chain
argument_list|,
name|rnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rnum
operator|=
name|hdr
operator|->
name|end_rule
expr_stmt|;
name|rnum
operator|=
operator|(
name|rnum
operator|<
name|IPFW_DEFAULT_RULE
operator|)
condition|?
name|rnum
operator|+
literal|1
else|:
name|IPFW_DEFAULT_RULE
expr_stmt|;
name|da
operator|.
name|e
operator|=
name|ipfw_find_rule
argument_list|(
name|chain
argument_list|,
name|rnum
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hdr
operator|->
name|flags
operator|&
name|IPFW_CFG_GET_STATIC
condition|)
block|{
for|for
control|(
name|i
operator|=
name|da
operator|.
name|b
init|;
name|i
operator|<
name|da
operator|.
name|e
condition|;
name|i
operator|++
control|)
block|{
name|rule
operator|=
name|chain
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
name|da
operator|.
name|rsize
operator|+=
name|RULEUSIZE1
argument_list|(
name|rule
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ipfw_obj_tlv
argument_list|)
expr_stmt|;
name|da
operator|.
name|rcount
operator|++
expr_stmt|;
comment|/* Update bitmask of used objects for given range */
name|da
operator|.
name|tcount
operator|+=
name|mark_object_kidx
argument_list|(
name|chain
argument_list|,
name|rule
argument_list|,
name|bmask
argument_list|)
expr_stmt|;
block|}
comment|/* Add counters if requested */
if|if
condition|(
name|hdr
operator|->
name|flags
operator|&
name|IPFW_CFG_GET_COUNTERS
condition|)
block|{
name|da
operator|.
name|rsize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip_fw_bcounter
argument_list|)
operator|*
name|da
operator|.
name|rcount
expr_stmt|;
name|da
operator|.
name|rcounters
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|da
operator|.
name|tcount
operator|>
literal|0
condition|)
name|sz
operator|+=
name|da
operator|.
name|tcount
operator|*
sizeof|sizeof
argument_list|(
name|ipfw_obj_ntlv
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ipfw_obj_ctlv
argument_list|)
expr_stmt|;
name|sz
operator|+=
name|da
operator|.
name|rsize
operator|+
sizeof|sizeof
argument_list|(
name|ipfw_obj_ctlv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hdr
operator|->
name|flags
operator|&
name|IPFW_CFG_GET_STATES
condition|)
name|sz
operator|+=
name|ipfw_dyn_get_count
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|ipfw_obj_dyntlv
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ipfw_obj_ctlv
argument_list|)
expr_stmt|;
comment|/* 	 * Fill header anyway. 	 * Note we have to save header fields to stable storage 	 * buffer inside @sd can be flushed after dumping rules 	 */
name|hdr
operator|->
name|size
operator|=
name|sz
expr_stmt|;
name|hdr
operator|->
name|set_mask
operator|=
operator|~
name|V_set_disable
expr_stmt|;
name|hdr_flags
operator|=
name|hdr
operator|->
name|flags
expr_stmt|;
name|hdr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|valsize
operator|<
name|sz
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* STAGE2: Store actual data */
if|if
condition|(
name|hdr_flags
operator|&
name|IPFW_CFG_GET_STATIC
condition|)
block|{
name|error
operator|=
name|dump_static_rules
argument_list|(
name|chain
argument_list|,
operator|&
name|da
argument_list|,
name|bmask
argument_list|,
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|hdr_flags
operator|&
name|IPFW_CFG_GET_STATES
condition|)
name|error
operator|=
name|ipfw_dump_states
argument_list|(
name|chain
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|IPFW_UH_RUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmask
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bmask
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ipfw_check_object_name_generic
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|nsize
decl_stmt|;
name|nsize
operator|=
sizeof|sizeof
argument_list|(
operator|(
operator|(
name|ipfw_obj_ntlv
operator|*
operator|)
literal|0
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strnlen
argument_list|(
name|name
argument_list|,
name|nsize
argument_list|)
operator|==
name|nsize
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Creates non-existent objects referenced by rule.  *  * Return 0 on success.  */
end_comment

begin_function
name|int
name|create_objects_compat
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|struct
name|obj_idx
modifier|*
name|oib
parameter_list|,
name|struct
name|obj_idx
modifier|*
name|pidx
parameter_list|,
name|struct
name|tid_info
modifier|*
name|ti
parameter_list|)
block|{
name|struct
name|opcode_obj_rewrite
modifier|*
name|rw
decl_stmt|;
name|struct
name|obj_idx
modifier|*
name|p
decl_stmt|;
name|uint16_t
name|kidx
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Compatibility stuff: do actual creation for non-existing, 	 * but referenced objects. 	 */
for|for
control|(
name|p
operator|=
name|oib
init|;
name|p
operator|<
name|pidx
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|kidx
operator|!=
literal|0
condition|)
continue|continue;
name|ti
operator|->
name|uidx
operator|=
name|p
operator|->
name|uidx
expr_stmt|;
name|ti
operator|->
name|type
operator|=
name|p
operator|->
name|type
expr_stmt|;
name|ti
operator|->
name|atype
operator|=
literal|0
expr_stmt|;
name|rw
operator|=
name|find_op_rw
argument_list|(
name|cmd
operator|+
name|p
operator|->
name|off
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rw
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Unable to find handler for op %d"
operator|,
operator|(
name|cmd
operator|+
name|p
operator|->
name|off
operator|)
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|->
name|create_object
operator|==
name|NULL
condition|)
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
else|else
name|error
operator|=
name|rw
operator|->
name|create_object
argument_list|(
name|ch
argument_list|,
name|ti
argument_list|,
operator|&
name|kidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|kidx
operator|=
name|kidx
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Error happened. We have to rollback everything. 		 * Drop all already acquired references. 		 */
name|IPFW_UH_WLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|unref_oib_objects
argument_list|(
name|ch
argument_list|,
name|cmd
argument_list|,
name|oib
argument_list|,
name|pidx
argument_list|)
expr_stmt|;
name|IPFW_UH_WUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compatibility function for old ipfw(8) binaries.  * Rewrites table/nat kernel indices with userland ones.  * Convert tables matching '/^\d+$/' to their atoi() value.  * Use number 65535 for other tables.  *  * Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|set_legacy_obj_kidx
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|struct
name|ip_fw_rule0
modifier|*
name|rule
parameter_list|)
block|{
name|struct
name|opcode_obj_rewrite
modifier|*
name|rw
decl_stmt|;
name|struct
name|named_object
modifier|*
name|no
decl_stmt|;
name|ipfw_insn
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|long
name|val
decl_stmt|;
name|int
name|cmdlen
decl_stmt|,
name|error
decl_stmt|,
name|l
decl_stmt|;
name|uint16_t
name|kidx
decl_stmt|,
name|uidx
decl_stmt|;
name|uint8_t
name|subtype
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|rule
operator|->
name|cmd_len
expr_stmt|;
name|cmd
operator|=
name|rule
operator|->
name|cmd
expr_stmt|;
name|cmdlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|l
operator|>
literal|0
condition|;
name|l
operator|-=
name|cmdlen
operator|,
name|cmd
operator|+=
name|cmdlen
control|)
block|{
name|cmdlen
operator|=
name|F_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/* Check if is index in given opcode */
name|rw
operator|=
name|find_op_rw
argument_list|(
name|cmd
argument_list|,
operator|&
name|kidx
argument_list|,
operator|&
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Try to find referenced kernel object */
name|no
operator|=
name|rw
operator|->
name|find_bykidx
argument_list|(
name|ch
argument_list|,
name|kidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|no
operator|==
name|NULL
condition|)
continue|continue;
name|val
operator|=
name|strtol
argument_list|(
name|no
operator|->
name|name
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
operator|&&
name|val
operator|<
literal|65535
condition|)
block|{
name|uidx
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We are called via legacy opcode. 			 * Save error and show table as fake number 			 * not to make ipfw(8) hang. 			 */
name|uidx
operator|=
literal|65535
expr_stmt|;
name|error
operator|=
literal|2
expr_stmt|;
block|}
name|rw
operator|->
name|update
argument_list|(
name|cmd
argument_list|,
name|uidx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unreferences all already-referenced objects in given @cmd rule,  * using information in @oib.  *  * Used to rollback partially converted rule on error.  */
end_comment

begin_function
specifier|static
name|void
name|unref_oib_objects
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|struct
name|obj_idx
modifier|*
name|oib
parameter_list|,
name|struct
name|obj_idx
modifier|*
name|end
parameter_list|)
block|{
name|struct
name|opcode_obj_rewrite
modifier|*
name|rw
decl_stmt|;
name|struct
name|named_object
modifier|*
name|no
decl_stmt|;
name|struct
name|obj_idx
modifier|*
name|p
decl_stmt|;
name|IPFW_UH_WLOCK_ASSERT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|oib
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|kidx
operator|==
literal|0
condition|)
continue|continue;
name|rw
operator|=
name|find_op_rw
argument_list|(
name|cmd
operator|+
name|p
operator|->
name|off
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rw
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Unable to find handler for op %d"
operator|,
operator|(
name|cmd
operator|+
name|p
operator|->
name|off
operator|)
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
comment|/* Find& unref by existing idx */
name|no
operator|=
name|rw
operator|->
name|find_bykidx
argument_list|(
name|ch
argument_list|,
name|p
operator|->
name|kidx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|no
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Ref'd object %d disappeared"
operator|,
name|p
operator|->
name|kidx
operator|)
argument_list|)
expr_stmt|;
name|no
operator|->
name|refcnt
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Remove references from every object used in @rule.  * Used at rule removal code.  */
end_comment

begin_function
specifier|static
name|void
name|unref_rule_objects
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|struct
name|ip_fw
modifier|*
name|rule
parameter_list|)
block|{
name|struct
name|opcode_obj_rewrite
modifier|*
name|rw
decl_stmt|;
name|struct
name|named_object
modifier|*
name|no
decl_stmt|;
name|ipfw_insn
modifier|*
name|cmd
decl_stmt|;
name|int
name|cmdlen
decl_stmt|,
name|l
decl_stmt|;
name|uint16_t
name|kidx
decl_stmt|;
name|uint8_t
name|subtype
decl_stmt|;
name|IPFW_UH_WLOCK_ASSERT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|l
operator|=
name|rule
operator|->
name|cmd_len
expr_stmt|;
name|cmd
operator|=
name|rule
operator|->
name|cmd
expr_stmt|;
name|cmdlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|l
operator|>
literal|0
condition|;
name|l
operator|-=
name|cmdlen
operator|,
name|cmd
operator|+=
name|cmdlen
control|)
block|{
name|cmdlen
operator|=
name|F_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|rw
operator|=
name|find_op_rw
argument_list|(
name|cmd
argument_list|,
operator|&
name|kidx
argument_list|,
operator|&
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|NULL
condition|)
continue|continue;
name|no
operator|=
name|rw
operator|->
name|find_bykidx
argument_list|(
name|ch
argument_list|,
name|kidx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|no
operator|!=
name|NULL
argument_list|,
operator|(
literal|"object id %d not found"
operator|,
name|kidx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|no
operator|->
name|subtype
operator|==
name|subtype
argument_list|,
operator|(
literal|"wrong type %d (%d) for object id %d"
operator|,
name|no
operator|->
name|subtype
operator|,
name|subtype
operator|,
name|kidx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|no
operator|->
name|refcnt
operator|>
literal|0
argument_list|,
operator|(
literal|"refcount for object %d is %d"
operator|,
name|kidx
operator|,
name|no
operator|->
name|refcnt
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|no
operator|->
name|refcnt
operator|==
literal|1
operator|&&
name|rw
operator|->
name|destroy_object
operator|!=
name|NULL
condition|)
name|rw
operator|->
name|destroy_object
argument_list|(
name|ch
argument_list|,
name|no
argument_list|)
expr_stmt|;
else|else
name|no
operator|->
name|refcnt
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find and reference object (if any) stored in instruction @cmd.  *  * Saves object info in @pidx, sets  *  - @unresolved to 1 if object should exists but not found  *  * Returns non-zero value in case of error.  */
end_comment

begin_function
specifier|static
name|int
name|ref_opcode_object
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|struct
name|tid_info
modifier|*
name|ti
parameter_list|,
name|struct
name|obj_idx
modifier|*
name|pidx
parameter_list|,
name|int
modifier|*
name|unresolved
parameter_list|)
block|{
name|struct
name|named_object
modifier|*
name|no
decl_stmt|;
name|struct
name|opcode_obj_rewrite
modifier|*
name|rw
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Check if this opcode is candidate for rewrite */
name|rw
operator|=
name|find_op_rw
argument_list|(
name|cmd
argument_list|,
operator|&
name|ti
operator|->
name|uidx
argument_list|,
operator|&
name|ti
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Need to rewrite. Save necessary fields */
name|pidx
operator|->
name|uidx
operator|=
name|ti
operator|->
name|uidx
expr_stmt|;
name|pidx
operator|->
name|type
operator|=
name|ti
operator|->
name|type
expr_stmt|;
comment|/* Try to find referenced kernel object */
name|error
operator|=
name|rw
operator|->
name|find_byname
argument_list|(
name|ch
argument_list|,
name|ti
argument_list|,
operator|&
name|no
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|no
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Report about unresolved object for automaic 		 * creation. 		 */
operator|*
name|unresolved
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Object is already exist. 	 * Its subtype should match with expected value. 	 */
if|if
condition|(
name|ti
operator|->
name|type
operator|!=
name|no
operator|->
name|subtype
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Bump refcount and update kidx. */
name|no
operator|->
name|refcnt
operator|++
expr_stmt|;
name|rw
operator|->
name|update
argument_list|(
name|cmd
argument_list|,
name|no
operator|->
name|kidx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finds and bumps refcount for objects referenced by given @rule.  * Auto-creates non-existing tables.  * Fills in @oib array with userland/kernel indexes.  *  * Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|ref_rule_objects
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|struct
name|ip_fw
modifier|*
name|rule
parameter_list|,
name|struct
name|rule_check_info
modifier|*
name|ci
parameter_list|,
name|struct
name|obj_idx
modifier|*
name|oib
parameter_list|,
name|struct
name|tid_info
modifier|*
name|ti
parameter_list|)
block|{
name|struct
name|obj_idx
modifier|*
name|pidx
decl_stmt|;
name|ipfw_insn
modifier|*
name|cmd
decl_stmt|;
name|int
name|cmdlen
decl_stmt|,
name|error
decl_stmt|,
name|l
decl_stmt|,
name|unresolved
decl_stmt|;
name|pidx
operator|=
name|oib
expr_stmt|;
name|l
operator|=
name|rule
operator|->
name|cmd_len
expr_stmt|;
name|cmd
operator|=
name|rule
operator|->
name|cmd
expr_stmt|;
name|cmdlen
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|IPFW_UH_WLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* Increase refcount on each existing referenced table. */
for|for
control|(
init|;
name|l
operator|>
literal|0
condition|;
name|l
operator|-=
name|cmdlen
operator|,
name|cmd
operator|+=
name|cmdlen
control|)
block|{
name|cmdlen
operator|=
name|F_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|unresolved
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ref_opcode_object
argument_list|(
name|ch
argument_list|,
name|cmd
argument_list|,
name|ti
argument_list|,
name|pidx
argument_list|,
operator|&
name|unresolved
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * Compatibility stuff for old clients: 		 * prepare to automaitcally create non-existing objects. 		 */
if|if
condition|(
name|unresolved
operator|!=
literal|0
condition|)
block|{
name|pidx
operator|->
name|off
operator|=
name|rule
operator|->
name|cmd_len
operator|-
name|l
expr_stmt|;
name|pidx
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* Unref everything we have already done */
name|unref_oib_objects
argument_list|(
name|ch
argument_list|,
name|rule
operator|->
name|cmd
argument_list|,
name|oib
argument_list|,
name|pidx
argument_list|)
expr_stmt|;
name|IPFW_UH_WUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|IPFW_UH_WUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* Perform auto-creation for non-existing objects */
if|if
condition|(
name|pidx
operator|!=
name|oib
condition|)
name|error
operator|=
name|create_objects_compat
argument_list|(
name|ch
argument_list|,
name|rule
operator|->
name|cmd
argument_list|,
name|oib
argument_list|,
name|pidx
argument_list|,
name|ti
argument_list|)
expr_stmt|;
comment|/* Calculate real number of dynamic objects */
name|ci
operator|->
name|object_opcodes
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|pidx
operator|-
name|oib
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks is opcode is referencing table of appropriate type.  * Adds reference count for found table if true.  * Rewrites user-supplied opcode values with kernel ones.  *  * Returns 0 on success and appropriate error code otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|rewrite_rule_uidx
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|struct
name|rule_check_info
modifier|*
name|ci
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|ipfw_insn
modifier|*
name|cmd
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|struct
name|obj_idx
modifier|*
name|p
decl_stmt|,
modifier|*
name|pidx_first
decl_stmt|,
modifier|*
name|pidx_last
decl_stmt|;
name|struct
name|tid_info
name|ti
decl_stmt|;
comment|/* 	 * Prepare an array for storing opcode indices. 	 * Use stack allocation by default. 	 */
if|if
condition|(
name|ci
operator|->
name|object_opcodes
operator|<=
operator|(
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|obuf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ci
operator|->
name|obuf
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* Stack */
name|pidx_first
operator|=
name|ci
operator|->
name|obuf
expr_stmt|;
block|}
else|else
name|pidx_first
operator|=
name|malloc
argument_list|(
name|ci
operator|->
name|object_opcodes
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|obj_idx
argument_list|)
argument_list|,
name|M_IPFW
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ti
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ti
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use set rule is assigned to. */
name|ti
operator|.
name|set
operator|=
name|ci
operator|->
name|krule
operator|->
name|set
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|ctlv
operator|!=
name|NULL
condition|)
block|{
name|ti
operator|.
name|tlvs
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ci
operator|->
name|ctlv
operator|+
literal|1
operator|)
expr_stmt|;
name|ti
operator|.
name|tlen
operator|=
name|ci
operator|->
name|ctlv
operator|->
name|head
operator|.
name|length
operator|-
sizeof|sizeof
argument_list|(
name|ipfw_obj_ctlv
argument_list|)
expr_stmt|;
block|}
comment|/* Reference all used tables and other objects */
name|error
operator|=
name|ref_rule_objects
argument_list|(
name|chain
argument_list|,
name|ci
operator|->
name|krule
argument_list|,
name|ci
argument_list|,
name|pidx_first
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|free
goto|;
comment|/* 	 * Note that ref_rule_objects() might have updated ci->object_opcodes 	 * to reflect actual number of object opcodes. 	 */
comment|/* Perform rewrite of remaining opcodes */
name|p
operator|=
name|pidx_first
expr_stmt|;
name|pidx_last
operator|=
name|pidx_first
operator|+
name|ci
operator|->
name|object_opcodes
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pidx_first
init|;
name|p
operator|<
name|pidx_last
condition|;
name|p
operator|++
control|)
block|{
name|cmd
operator|=
name|ci
operator|->
name|krule
operator|->
name|cmd
operator|+
name|p
operator|->
name|off
expr_stmt|;
name|update_opcode_kidx
argument_list|(
name|cmd
argument_list|,
name|p
operator|->
name|kidx
argument_list|)
expr_stmt|;
block|}
name|free
label|:
if|if
condition|(
name|pidx_first
operator|!=
name|ci
operator|->
name|obuf
condition|)
name|free
argument_list|(
name|pidx_first
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adds one or more rules to ipfw @chain.  * Data layout (version 0)(current):  * Request:  * [  *   ip_fw3_opheader  *   [ ipfw_obj_ctlv(IPFW_TLV_TBL_LIST) ipfw_obj_ntlv x N ] (optional *1)  *   [ ipfw_obj_ctlv(IPFW_TLV_RULE_LIST) ip_fw x N ] (*2) (*3)  * ]  * Reply:  * [  *   ip_fw3_opheader  *   [ ipfw_obj_ctlv(IPFW_TLV_TBL_LIST) ipfw_obj_ntlv x N ] (optional)  *   [ ipfw_obj_ctlv(IPFW_TLV_RULE_LIST) ip_fw x N ]  * ]  *  * Rules in reply are modified to store their actual ruleset number.  *  * (*1) TLVs inside IPFW_TLV_TBL_LIST needs to be sorted ascending  * according to their idx field and there has to be no duplicates.  * (*2) Numbered rules inside IPFW_TLV_RULE_LIST needs to be sorted ascending.  * (*3) Each ip_fw structure needs to be aligned to u64 boundary.  *  * Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|add_rules
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|ipfw_obj_ctlv
modifier|*
name|ctlv
decl_stmt|,
modifier|*
name|rtlv
decl_stmt|,
modifier|*
name|tstate
decl_stmt|;
name|ipfw_obj_ntlv
modifier|*
name|ntlv
decl_stmt|;
name|int
name|clen
decl_stmt|,
name|error
decl_stmt|,
name|idx
decl_stmt|;
name|uint32_t
name|count
decl_stmt|,
name|read
decl_stmt|;
name|struct
name|ip_fw_rule
modifier|*
name|r
decl_stmt|;
name|struct
name|rule_check_info
name|rci
decl_stmt|,
modifier|*
name|ci
decl_stmt|,
modifier|*
name|cbuf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rsize
decl_stmt|;
name|op3
operator|=
operator|(
name|ip_fw3_opheader
operator|*
operator|)
name|ipfw_get_sopt_space
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|valsize
argument_list|)
expr_stmt|;
name|ctlv
operator|=
operator|(
name|ipfw_obj_ctlv
operator|*
operator|)
operator|(
name|op3
operator|+
literal|1
operator|)
expr_stmt|;
name|read
operator|=
sizeof|sizeof
argument_list|(
name|ip_fw3_opheader
argument_list|)
expr_stmt|;
name|rtlv
operator|=
name|NULL
expr_stmt|;
name|tstate
operator|=
name|NULL
expr_stmt|;
name|cbuf
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rci
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rule_check_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ctlv
argument_list|)
operator|>
name|sd
operator|->
name|valsize
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ctlv
operator|->
name|head
operator|.
name|type
operator|==
name|IPFW_TLV_TBLNAME_LIST
condition|)
block|{
name|clen
operator|=
name|ctlv
operator|->
name|head
operator|.
name|length
expr_stmt|;
comment|/* Check size and alignment */
if|if
condition|(
name|clen
operator|>
name|sd
operator|->
name|valsize
operator|||
name|clen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ctlv
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|clen
operator|%
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 		 * Some table names or other named objects. 		 * Check for validness. 		 */
name|count
operator|=
operator|(
name|ctlv
operator|->
name|head
operator|.
name|length
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ctlv
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|ntlv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlv
operator|->
name|count
operator|!=
name|count
operator|||
name|ctlv
operator|->
name|objsize
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ntlv
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 		 * Check each TLV. 		 * Ensure TLVs are sorted ascending and 		 * there are no duplicates. 		 */
name|idx
operator|=
operator|-
literal|1
expr_stmt|;
name|ntlv
operator|=
operator|(
name|ipfw_obj_ntlv
operator|*
operator|)
operator|(
name|ctlv
operator|+
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ntlv
operator|->
name|head
operator|.
name|length
operator|!=
sizeof|sizeof
argument_list|(
name|ipfw_obj_ntlv
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|ipfw_check_object_name_generic
argument_list|(
name|ntlv
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ntlv
operator|->
name|idx
operator|<=
name|idx
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|idx
operator|=
name|ntlv
operator|->
name|idx
expr_stmt|;
name|count
operator|--
expr_stmt|;
name|ntlv
operator|++
expr_stmt|;
block|}
name|tstate
operator|=
name|ctlv
expr_stmt|;
name|read
operator|+=
name|ctlv
operator|->
name|head
operator|.
name|length
expr_stmt|;
name|ctlv
operator|=
operator|(
name|ipfw_obj_ctlv
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ctlv
operator|+
name|ctlv
operator|->
name|head
operator|.
name|length
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|read
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ctlv
argument_list|)
operator|>
name|sd
operator|->
name|valsize
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ctlv
operator|->
name|head
operator|.
name|type
operator|==
name|IPFW_TLV_RULE_LIST
condition|)
block|{
name|clen
operator|=
name|ctlv
operator|->
name|head
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|clen
operator|+
name|read
operator|>
name|sd
operator|->
name|valsize
operator|||
name|clen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ctlv
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|clen
operator|%
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 		 * TODO: Permit adding multiple rules at once 		 */
if|if
condition|(
name|ctlv
operator|->
name|count
operator|!=
literal|1
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|clen
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|ctlv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlv
operator|->
name|count
operator|>
name|clen
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ip_fw_rule
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Allocate state for each rule or use stack */
if|if
condition|(
name|ctlv
operator|->
name|count
operator|==
literal|1
condition|)
block|{
name|memset
argument_list|(
operator|&
name|rci
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rule_check_info
argument_list|)
argument_list|)
expr_stmt|;
name|cbuf
operator|=
operator|&
name|rci
expr_stmt|;
block|}
else|else
name|cbuf
operator|=
name|malloc
argument_list|(
name|ctlv
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ci
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ci
operator|=
name|cbuf
expr_stmt|;
comment|/* 		 * Check each rule for validness. 		 * Ensure numbered rules are sorted ascending 		 * and properly aligned 		 */
name|idx
operator|=
literal|0
expr_stmt|;
name|r
operator|=
operator|(
expr|struct
name|ip_fw_rule
operator|*
operator|)
operator|(
name|ctlv
operator|+
literal|1
operator|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|rsize
operator|=
name|roundup2
argument_list|(
name|RULESIZE
argument_list|(
name|r
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|>
name|clen
operator|||
name|ctlv
operator|->
name|count
operator|<=
name|count
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ci
operator|->
name|ctlv
operator|=
name|tstate
expr_stmt|;
name|error
operator|=
name|check_ipfw_rule1
argument_list|(
name|r
argument_list|,
name|rsize
argument_list|,
name|ci
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
comment|/* Check sorting */
if|if
condition|(
name|r
operator|->
name|rulenum
operator|!=
literal|0
operator|&&
name|r
operator|->
name|rulenum
operator|<
name|idx
condition|)
block|{
name|printf
argument_list|(
literal|"rulenum %d idx %d\n"
argument_list|,
name|r
operator|->
name|rulenum
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|idx
operator|=
name|r
operator|->
name|rulenum
expr_stmt|;
name|ci
operator|->
name|urule
operator|=
operator|(
name|caddr_t
operator|)
name|r
expr_stmt|;
name|rsize
operator|=
name|roundup2
argument_list|(
name|rsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|clen
operator|-=
name|rsize
expr_stmt|;
name|r
operator|=
operator|(
expr|struct
name|ip_fw_rule
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|r
operator|+
name|rsize
operator|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|ci
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ctlv
operator|->
name|count
operator|!=
name|count
operator|||
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cbuf
operator|!=
operator|&
name|rci
condition|)
name|free
argument_list|(
name|cbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|rtlv
operator|=
name|ctlv
expr_stmt|;
name|read
operator|+=
name|ctlv
operator|->
name|head
operator|.
name|length
expr_stmt|;
name|ctlv
operator|=
operator|(
name|ipfw_obj_ctlv
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ctlv
operator|+
name|ctlv
operator|->
name|head
operator|.
name|length
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|read
operator|!=
name|sd
operator|->
name|valsize
operator|||
name|rtlv
operator|==
name|NULL
operator|||
name|rtlv
operator|->
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cbuf
operator|!=
name|NULL
operator|&&
name|cbuf
operator|!=
operator|&
name|rci
condition|)
name|free
argument_list|(
name|cbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Passed rules seems to be valid. 	 * Allocate storage and try to add them to chain. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ci
operator|=
name|cbuf
init|;
name|i
operator|<
name|rtlv
operator|->
name|count
condition|;
name|i
operator|++
operator|,
name|ci
operator|++
control|)
block|{
name|clen
operator|=
name|RULEKSIZE1
argument_list|(
operator|(
expr|struct
name|ip_fw_rule
operator|*
operator|)
name|ci
operator|->
name|urule
argument_list|)
expr_stmt|;
name|ci
operator|->
name|krule
operator|=
name|ipfw_alloc_rule
argument_list|(
name|chain
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|import_rule1
argument_list|(
name|ci
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|commit_rules
argument_list|(
name|chain
argument_list|,
name|cbuf
argument_list|,
name|rtlv
operator|->
name|count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Free allocate krules */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ci
operator|=
name|cbuf
init|;
name|i
operator|<
name|rtlv
operator|->
name|count
condition|;
name|i
operator|++
operator|,
name|ci
operator|++
control|)
name|free_rule
argument_list|(
name|ci
operator|->
name|krule
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cbuf
operator|!=
name|NULL
operator|&&
name|cbuf
operator|!=
operator|&
name|rci
condition|)
name|free
argument_list|(
name|cbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lists all sopts currently registered.  * Data layout (v0)(current):  * Request: [ ipfw_obj_lheader ], size = ipfw_obj_lheader.size  * Reply: [ ipfw_obj_lheader ipfw_sopt_info x N ]  *  * Returns 0 on success  */
end_comment

begin_function
specifier|static
name|int
name|dump_soptcodes
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|struct
name|_ipfw_obj_lheader
modifier|*
name|olh
decl_stmt|;
name|ipfw_sopt_info
modifier|*
name|i
decl_stmt|;
name|struct
name|ipfw_sopt_handler
modifier|*
name|sh
decl_stmt|;
name|uint32_t
name|count
decl_stmt|,
name|n
decl_stmt|,
name|size
decl_stmt|;
name|olh
operator|=
operator|(
expr|struct
name|_ipfw_obj_lheader
operator|*
operator|)
name|ipfw_get_sopt_header
argument_list|(
name|sd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|olh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|olh
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sd
operator|->
name|valsize
operator|<
name|olh
operator|->
name|size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|CTL3_LOCK
argument_list|()
expr_stmt|;
name|count
operator|=
name|ctl3_hsize
expr_stmt|;
name|size
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|ipfw_sopt_info
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ipfw_obj_lheader
argument_list|)
expr_stmt|;
comment|/* Fill in header regadless of buffer size */
name|olh
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|olh
operator|->
name|objsize
operator|=
sizeof|sizeof
argument_list|(
name|ipfw_sopt_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|olh
operator|->
name|size
condition|)
block|{
name|olh
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|CTL3_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|olh
operator|->
name|size
operator|=
name|size
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<=
name|count
condition|;
name|n
operator|++
control|)
block|{
name|i
operator|=
operator|(
name|ipfw_sopt_info
operator|*
operator|)
name|ipfw_get_sopt_space
argument_list|(
name|sd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|i
operator|!=
name|NULL
argument_list|,
operator|(
literal|"previously checked buffer is not enough"
operator|)
argument_list|)
expr_stmt|;
name|sh
operator|=
operator|&
name|ctl3_handlers
index|[
name|n
index|]
expr_stmt|;
name|i
operator|->
name|opcode
operator|=
name|sh
operator|->
name|opcode
expr_stmt|;
name|i
operator|->
name|version
operator|=
name|sh
operator|->
name|version
expr_stmt|;
name|i
operator|->
name|refcnt
operator|=
name|sh
operator|->
name|refcnt
expr_stmt|;
block|}
name|CTL3_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compares two opcodes.  * Used both in qsort() and bsearch().  *  * Returns 0 if match is found.  */
end_comment

begin_function
specifier|static
name|int
name|compare_opcodes
parameter_list|(
specifier|const
name|void
modifier|*
name|_a
parameter_list|,
specifier|const
name|void
modifier|*
name|_b
parameter_list|)
block|{
specifier|const
name|struct
name|opcode_obj_rewrite
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|a
operator|=
operator|(
specifier|const
expr|struct
name|opcode_obj_rewrite
operator|*
operator|)
name|_a
expr_stmt|;
name|b
operator|=
operator|(
specifier|const
expr|struct
name|opcode_obj_rewrite
operator|*
operator|)
name|_b
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|opcode
operator|<
name|b
operator|->
name|opcode
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|opcode
operator|>
name|b
operator|->
name|opcode
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX: Rewrite bsearch()  */
end_comment

begin_function
specifier|static
name|int
name|find_op_rw_range
parameter_list|(
name|uint16_t
name|op
parameter_list|,
name|struct
name|opcode_obj_rewrite
modifier|*
modifier|*
name|plo
parameter_list|,
name|struct
name|opcode_obj_rewrite
modifier|*
modifier|*
name|phi
parameter_list|)
block|{
name|struct
name|opcode_obj_rewrite
modifier|*
name|ctl3_max
decl_stmt|,
modifier|*
name|lo
decl_stmt|,
modifier|*
name|hi
decl_stmt|,
name|h
decl_stmt|,
modifier|*
name|rw
decl_stmt|;
name|memset
argument_list|(
operator|&
name|h
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|opcode
operator|=
name|op
expr_stmt|;
name|rw
operator|=
operator|(
expr|struct
name|opcode_obj_rewrite
operator|*
operator|)
name|bsearch
argument_list|(
operator|&
name|h
argument_list|,
name|ctl3_rewriters
argument_list|,
name|ctl3_rsize
argument_list|,
sizeof|sizeof
argument_list|(
name|h
argument_list|)
argument_list|,
name|compare_opcodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Find the first element matching the same opcode */
name|lo
operator|=
name|rw
expr_stmt|;
for|for
control|(
init|;
name|lo
operator|>
name|ctl3_rewriters
operator|&&
operator|(
name|lo
operator|-
literal|1
operator|)
operator|->
name|opcode
operator|==
name|op
condition|;
name|lo
operator|--
control|)
empty_stmt|;
comment|/* Find the last element matching the same opcode */
name|hi
operator|=
name|rw
expr_stmt|;
name|ctl3_max
operator|=
name|ctl3_rewriters
operator|+
name|ctl3_rsize
expr_stmt|;
for|for
control|(
init|;
operator|(
name|hi
operator|+
literal|1
operator|)
operator|<
name|ctl3_max
operator|&&
operator|(
name|hi
operator|+
literal|1
operator|)
operator|->
name|opcode
operator|==
name|op
condition|;
name|hi
operator|++
control|)
empty_stmt|;
operator|*
name|plo
operator|=
name|lo
expr_stmt|;
operator|*
name|phi
operator|=
name|hi
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finds opcode object rewriter based on @code.  *  * Returns pointer to handler or NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|opcode_obj_rewrite
modifier|*
name|find_op_rw
parameter_list|(
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|uint16_t
modifier|*
name|puidx
parameter_list|,
name|uint8_t
modifier|*
name|ptype
parameter_list|)
block|{
name|struct
name|opcode_obj_rewrite
modifier|*
name|rw
decl_stmt|,
modifier|*
name|lo
decl_stmt|,
modifier|*
name|hi
decl_stmt|;
name|uint16_t
name|uidx
decl_stmt|;
name|uint8_t
name|subtype
decl_stmt|;
if|if
condition|(
name|find_op_rw_range
argument_list|(
name|cmd
operator|->
name|opcode
argument_list|,
operator|&
name|lo
argument_list|,
operator|&
name|hi
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|rw
operator|=
name|lo
init|;
name|rw
operator|<=
name|hi
condition|;
name|rw
operator|++
control|)
block|{
if|if
condition|(
name|rw
operator|->
name|classifier
argument_list|(
name|cmd
argument_list|,
operator|&
name|uidx
argument_list|,
operator|&
name|subtype
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|puidx
operator|!=
name|NULL
condition|)
operator|*
name|puidx
operator|=
name|uidx
expr_stmt|;
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
operator|*
name|ptype
operator|=
name|subtype
expr_stmt|;
return|return
operator|(
name|rw
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|classify_opcode_kidx
parameter_list|(
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|uint16_t
modifier|*
name|puidx
parameter_list|)
block|{
if|if
condition|(
name|find_op_rw
argument_list|(
name|cmd
argument_list|,
name|puidx
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|update_opcode_kidx
parameter_list|(
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|uint16_t
name|idx
parameter_list|)
block|{
name|struct
name|opcode_obj_rewrite
modifier|*
name|rw
decl_stmt|;
name|rw
operator|=
name|find_op_rw
argument_list|(
name|cmd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rw
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No handler to update opcode %d"
operator|,
name|cmd
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|rw
operator|->
name|update
argument_list|(
name|cmd
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipfw_init_obj_rewriter
parameter_list|()
block|{
name|ctl3_rewriters
operator|=
name|NULL
expr_stmt|;
name|ctl3_rsize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipfw_destroy_obj_rewriter
parameter_list|()
block|{
if|if
condition|(
name|ctl3_rewriters
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ctl3_rewriters
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
name|ctl3_rewriters
operator|=
name|NULL
expr_stmt|;
name|ctl3_rsize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adds one or more opcode object rewrite handlers to the global array.  * Function may sleep.  */
end_comment

begin_function
name|void
name|ipfw_add_obj_rewriter
parameter_list|(
name|struct
name|opcode_obj_rewrite
modifier|*
name|rw
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
name|struct
name|opcode_obj_rewrite
modifier|*
name|tmp
decl_stmt|;
name|CTL3_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|sz
operator|=
name|ctl3_rsize
operator|+
name|count
expr_stmt|;
name|CTL3_UNLOCK
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rw
argument_list|)
operator|*
name|sz
argument_list|,
name|M_IPFW
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|CTL3_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctl3_rsize
operator|+
name|count
operator|<=
name|sz
condition|)
break|break;
comment|/* Retry */
name|free
argument_list|(
name|tmp
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
block|}
comment|/* Merge old& new arrays */
name|sz
operator|=
name|ctl3_rsize
operator|+
name|count
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|ctl3_rewriters
argument_list|,
name|ctl3_rsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rw
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp
index|[
name|ctl3_rsize
index|]
argument_list|,
name|rw
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rw
argument_list|)
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|tmp
argument_list|,
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rw
argument_list|)
argument_list|,
name|compare_opcodes
argument_list|)
expr_stmt|;
comment|/* Switch new and free old */
if|if
condition|(
name|ctl3_rewriters
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ctl3_rewriters
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
name|ctl3_rewriters
operator|=
name|tmp
expr_stmt|;
name|ctl3_rsize
operator|=
name|sz
expr_stmt|;
name|CTL3_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Removes one or more object rewrite handlers from the global array.  */
end_comment

begin_function
name|int
name|ipfw_del_obj_rewriter
parameter_list|(
name|struct
name|opcode_obj_rewrite
modifier|*
name|rw
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
name|struct
name|opcode_obj_rewrite
modifier|*
name|ctl3_max
decl_stmt|,
modifier|*
name|ktmp
decl_stmt|,
modifier|*
name|lo
decl_stmt|,
modifier|*
name|hi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CTL3_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|find_op_rw_range
argument_list|(
name|rw
index|[
name|i
index|]
operator|.
name|opcode
argument_list|,
operator|&
name|lo
argument_list|,
operator|&
name|hi
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
for|for
control|(
name|ktmp
operator|=
name|lo
init|;
name|ktmp
operator|<=
name|hi
condition|;
name|ktmp
operator|++
control|)
block|{
if|if
condition|(
name|ktmp
operator|->
name|classifier
operator|!=
name|rw
index|[
name|i
index|]
operator|.
name|classifier
condition|)
continue|continue;
name|ctl3_max
operator|=
name|ctl3_rewriters
operator|+
name|ctl3_rsize
expr_stmt|;
name|sz
operator|=
operator|(
name|ctl3_max
operator|-
operator|(
name|ktmp
operator|+
literal|1
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ktmp
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|ktmp
argument_list|,
name|ktmp
operator|+
literal|1
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ctl3_rsize
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ctl3_rsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ctl3_rewriters
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ctl3_rewriters
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
name|ctl3_rewriters
operator|=
name|NULL
expr_stmt|;
block|}
name|CTL3_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|export_objhash_ntlv_internal
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|struct
name|named_object
modifier|*
name|no
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sockopt_data
modifier|*
name|sd
decl_stmt|;
name|ipfw_obj_ntlv
modifier|*
name|ntlv
decl_stmt|;
name|sd
operator|=
operator|(
expr|struct
name|sockopt_data
operator|*
operator|)
name|arg
expr_stmt|;
name|ntlv
operator|=
operator|(
name|ipfw_obj_ntlv
operator|*
operator|)
name|ipfw_get_sopt_space
argument_list|(
name|sd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ntlv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntlv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ipfw_export_obj_ntlv
argument_list|(
name|no
argument_list|,
name|ntlv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lists all service objects.  * Data layout (v0)(current):  * Request: [ ipfw_obj_lheader ] size = ipfw_obj_lheader.size  * Reply: [ ipfw_obj_lheader [ ipfw_obj_ntlv x N ] (optional) ]  * Returns 0 on success  */
end_comment

begin_function
specifier|static
name|int
name|dump_srvobjects
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|ipfw_obj_lheader
modifier|*
name|hdr
decl_stmt|;
name|int
name|count
decl_stmt|;
name|hdr
operator|=
operator|(
name|ipfw_obj_lheader
operator|*
operator|)
name|ipfw_get_sopt_header
argument_list|(
name|sd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|IPFW_UH_RLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|count
operator|=
name|ipfw_objhash_count
argument_list|(
name|CHAIN_TO_SRV
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|ipfw_obj_lheader
argument_list|)
operator|+
name|count
operator|*
sizeof|sizeof
argument_list|(
name|ipfw_obj_ntlv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|valsize
operator|<
name|hdr
operator|->
name|size
condition|)
block|{
name|IPFW_UH_RUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|hdr
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|hdr
operator|->
name|objsize
operator|=
sizeof|sizeof
argument_list|(
name|ipfw_obj_ntlv
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|ipfw_objhash_foreach
argument_list|(
name|CHAIN_TO_SRV
argument_list|(
name|chain
argument_list|)
argument_list|,
name|export_objhash_ntlv_internal
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|IPFW_UH_RUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compares two sopt handlers (code, version and handler ptr).  * Used both as qsort() and bsearch().  * Does not compare handler for latter case.  *  * Returns 0 if match is found.  */
end_comment

begin_function
specifier|static
name|int
name|compare_sh
parameter_list|(
specifier|const
name|void
modifier|*
name|_a
parameter_list|,
specifier|const
name|void
modifier|*
name|_b
parameter_list|)
block|{
specifier|const
name|struct
name|ipfw_sopt_handler
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|a
operator|=
operator|(
specifier|const
expr|struct
name|ipfw_sopt_handler
operator|*
operator|)
name|_a
expr_stmt|;
name|b
operator|=
operator|(
specifier|const
expr|struct
name|ipfw_sopt_handler
operator|*
operator|)
name|_b
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|opcode
operator|<
name|b
operator|->
name|opcode
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|opcode
operator|>
name|b
operator|->
name|opcode
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|version
operator|<
name|b
operator|->
name|version
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|version
operator|>
name|b
operator|->
name|version
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* bsearch helper */
if|if
condition|(
name|a
operator|->
name|handler
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|a
operator|->
name|handler
operator|<
operator|(
name|uintptr_t
operator|)
name|b
operator|->
name|handler
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|a
operator|->
name|handler
operator|>
operator|(
name|uintptr_t
operator|)
name|b
operator|->
name|handler
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finds sopt handler based on @code and @version.  *  * Returns pointer to handler or NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|ipfw_sopt_handler
modifier|*
name|find_sh
parameter_list|(
name|uint16_t
name|code
parameter_list|,
name|uint8_t
name|version
parameter_list|,
name|sopt_handler_f
modifier|*
name|handler
parameter_list|)
block|{
name|struct
name|ipfw_sopt_handler
modifier|*
name|sh
decl_stmt|,
name|h
decl_stmt|;
name|memset
argument_list|(
operator|&
name|h
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|opcode
operator|=
name|code
expr_stmt|;
name|h
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|h
operator|.
name|handler
operator|=
name|handler
expr_stmt|;
name|sh
operator|=
operator|(
expr|struct
name|ipfw_sopt_handler
operator|*
operator|)
name|bsearch
argument_list|(
operator|&
name|h
argument_list|,
name|ctl3_handlers
argument_list|,
name|ctl3_hsize
argument_list|,
sizeof|sizeof
argument_list|(
name|h
argument_list|)
argument_list|,
name|compare_sh
argument_list|)
expr_stmt|;
return|return
operator|(
name|sh
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_ref_sh
parameter_list|(
name|uint16_t
name|opcode
parameter_list|,
name|uint8_t
name|version
parameter_list|,
name|struct
name|ipfw_sopt_handler
modifier|*
name|psh
parameter_list|)
block|{
name|struct
name|ipfw_sopt_handler
modifier|*
name|sh
decl_stmt|;
name|CTL3_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sh
operator|=
name|find_sh
argument_list|(
name|opcode
argument_list|,
name|version
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|CTL3_UNLOCK
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"ipfw: ipfw_ctl3 invalid option %d"
literal|"v"
literal|"%d\n"
argument_list|,
name|opcode
argument_list|,
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sh
operator|->
name|refcnt
operator|++
expr_stmt|;
name|ctl3_refct
operator|++
expr_stmt|;
comment|/* Copy handler data to requested buffer */
operator|*
name|psh
operator|=
operator|*
name|sh
expr_stmt|;
name|CTL3_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|find_unref_sh
parameter_list|(
name|struct
name|ipfw_sopt_handler
modifier|*
name|psh
parameter_list|)
block|{
name|struct
name|ipfw_sopt_handler
modifier|*
name|sh
decl_stmt|;
name|CTL3_LOCK
argument_list|()
expr_stmt|;
name|sh
operator|=
name|find_sh
argument_list|(
name|psh
operator|->
name|opcode
argument_list|,
name|psh
operator|->
name|version
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sh
operator|!=
name|NULL
argument_list|,
operator|(
literal|"ctl3 handler disappeared"
operator|)
argument_list|)
expr_stmt|;
name|sh
operator|->
name|refcnt
operator|--
expr_stmt|;
name|ctl3_refct
operator|--
expr_stmt|;
name|CTL3_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipfw_init_sopt_handler
parameter_list|()
block|{
name|CTL3_LOCK_INIT
argument_list|()
expr_stmt|;
name|IPFW_ADD_SOPT_HANDLER
argument_list|(
literal|1
argument_list|,
name|scodes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipfw_destroy_sopt_handler
parameter_list|()
block|{
name|IPFW_DEL_SOPT_HANDLER
argument_list|(
literal|1
argument_list|,
name|scodes
argument_list|)
expr_stmt|;
name|CTL3_LOCK_DESTROY
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adds one or more sockopt handlers to the global array.  * Function may sleep.  */
end_comment

begin_function
name|void
name|ipfw_add_sopt_handler
parameter_list|(
name|struct
name|ipfw_sopt_handler
modifier|*
name|sh
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
name|struct
name|ipfw_sopt_handler
modifier|*
name|tmp
decl_stmt|;
name|CTL3_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|sz
operator|=
name|ctl3_hsize
operator|+
name|count
expr_stmt|;
name|CTL3_UNLOCK
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
operator|*
name|sz
argument_list|,
name|M_IPFW
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|CTL3_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctl3_hsize
operator|+
name|count
operator|<=
name|sz
condition|)
break|break;
comment|/* Retry */
name|free
argument_list|(
name|tmp
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
block|}
comment|/* Merge old& new arrays */
name|sz
operator|=
name|ctl3_hsize
operator|+
name|count
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|ctl3_handlers
argument_list|,
name|ctl3_hsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp
index|[
name|ctl3_hsize
index|]
argument_list|,
name|sh
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|tmp
argument_list|,
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
argument_list|,
name|compare_sh
argument_list|)
expr_stmt|;
comment|/* Switch new and free old */
if|if
condition|(
name|ctl3_handlers
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ctl3_handlers
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
name|ctl3_handlers
operator|=
name|tmp
expr_stmt|;
name|ctl3_hsize
operator|=
name|sz
expr_stmt|;
name|ctl3_gencnt
operator|++
expr_stmt|;
name|CTL3_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Removes one or more sockopt handlers from the global array.  */
end_comment

begin_function
name|int
name|ipfw_del_sopt_handler
parameter_list|(
name|struct
name|ipfw_sopt_handler
modifier|*
name|sh
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
name|struct
name|ipfw_sopt_handler
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|h
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CTL3_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
operator|&
name|sh
index|[
name|i
index|]
expr_stmt|;
name|h
operator|=
name|find_sh
argument_list|(
name|tmp
operator|->
name|opcode
argument_list|,
name|tmp
operator|->
name|version
argument_list|,
name|tmp
operator|->
name|handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
continue|continue;
name|sz
operator|=
operator|(
name|ctl3_handlers
operator|+
name|ctl3_hsize
operator|-
operator|(
name|h
operator|+
literal|1
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|h
argument_list|,
name|h
operator|+
literal|1
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ctl3_hsize
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ctl3_hsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ctl3_handlers
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ctl3_handlers
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
name|ctl3_handlers
operator|=
name|NULL
expr_stmt|;
block|}
name|ctl3_gencnt
operator|++
expr_stmt|;
name|CTL3_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Writes data accumulated in @sd to sockopt buffer.  * Zeroes internal @sd buffer.  */
end_comment

begin_function
specifier|static
name|int
name|ipfw_flush_sopt_data
parameter_list|(
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|sz
operator|=
name|sd
operator|->
name|koff
expr_stmt|;
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sopt
operator|=
name|sd
operator|->
name|sopt
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_dir
operator|==
name|SOPT_GET
condition|)
block|{
name|error
operator|=
name|copyout
argument_list|(
name|sd
operator|->
name|kbuf
argument_list|,
name|sopt
operator|->
name|sopt_val
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|memset
argument_list|(
name|sd
operator|->
name|kbuf
argument_list|,
literal|0
argument_list|,
name|sd
operator|->
name|ksize
argument_list|)
expr_stmt|;
name|sd
operator|->
name|ktotal
operator|+=
name|sz
expr_stmt|;
name|sd
operator|->
name|koff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|ktotal
operator|+
name|sd
operator|->
name|ksize
operator|<
name|sd
operator|->
name|valsize
condition|)
name|sd
operator|->
name|kavail
operator|=
name|sd
operator|->
name|ksize
expr_stmt|;
else|else
name|sd
operator|->
name|kavail
operator|=
name|sd
operator|->
name|valsize
operator|-
name|sd
operator|->
name|ktotal
expr_stmt|;
comment|/* Update sopt buffer data */
name|sopt
operator|->
name|sopt_valsize
operator|=
name|sd
operator|->
name|ktotal
expr_stmt|;
name|sopt
operator|->
name|sopt_val
operator|=
name|sd
operator|->
name|sopt_val
operator|+
name|sd
operator|->
name|ktotal
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ensures that @sd buffer has contiguous @neeeded number of  * bytes.  *  * Returns pointer to requested space or NULL.  */
end_comment

begin_function
name|caddr_t
name|ipfw_get_sopt_space
parameter_list|(
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|,
name|size_t
name|needed
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
if|if
condition|(
name|sd
operator|->
name|kavail
operator|<
name|needed
condition|)
block|{
comment|/* 		 * Flush data and try another time. 		 */
name|error
operator|=
name|ipfw_flush_sopt_data
argument_list|(
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|kavail
operator|<
name|needed
operator|||
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|addr
operator|=
name|sd
operator|->
name|kbuf
operator|+
name|sd
operator|->
name|koff
expr_stmt|;
name|sd
operator|->
name|koff
operator|+=
name|needed
expr_stmt|;
name|sd
operator|->
name|kavail
operator|-=
name|needed
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Requests @needed contiguous bytes from @sd buffer.  * Function is used to notify subsystem that we are  * interesed in first @needed bytes (request header)  * and the rest buffer can be safely zeroed.  *  * Returns pointer to requested space or NULL.  */
end_comment

begin_function
name|caddr_t
name|ipfw_get_sopt_header
parameter_list|(
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|,
name|size_t
name|needed
parameter_list|)
block|{
name|caddr_t
name|addr
decl_stmt|;
if|if
condition|(
operator|(
name|addr
operator|=
name|ipfw_get_sopt_space
argument_list|(
name|sd
argument_list|,
name|needed
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|sd
operator|->
name|kavail
operator|>
literal|0
condition|)
name|memset
argument_list|(
name|sd
operator|->
name|kbuf
operator|+
name|sd
operator|->
name|koff
argument_list|,
literal|0
argument_list|,
name|sd
operator|->
name|kavail
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * New sockopt handler.  */
end_comment

begin_function
name|int
name|ipfw_ctl3
parameter_list|(
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|locked
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|valsize
decl_stmt|;
name|struct
name|ip_fw_chain
modifier|*
name|chain
decl_stmt|;
name|char
name|xbuf
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|sockopt_data
name|sdata
decl_stmt|;
name|struct
name|ipfw_sopt_handler
name|h
decl_stmt|;
name|ip_fw3_opheader
modifier|*
name|op3
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|sopt
operator|->
name|sopt_td
argument_list|,
name|PRIV_NETINET_IPFW
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|!=
name|IP_FW3
condition|)
return|return
operator|(
name|ipfw_ctl
argument_list|(
name|sopt
argument_list|)
operator|)
return|;
name|chain
operator|=
operator|&
name|V_layer3_chain
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Save original valsize before it is altered via sooptcopyin() */
name|valsize
operator|=
name|sopt
operator|->
name|sopt_valsize
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read op3 header first to determine actual operation */
name|op3
operator|=
operator|(
name|ip_fw3_opheader
operator|*
operator|)
name|xbuf
expr_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
name|op3
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|op3
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|op3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sopt
operator|->
name|sopt_valsize
operator|=
name|valsize
expr_stmt|;
comment|/* 	 * Find and reference command. 	 */
name|error
operator|=
name|find_ref_sh
argument_list|(
name|op3
operator|->
name|opcode
argument_list|,
name|op3
operator|->
name|version
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Disallow modifications in really-really secure mode, but still allow 	 * the logging counters to be reset. 	 */
if|if
condition|(
operator|(
name|h
operator|.
name|dir
operator|&
name|HDIR_SET
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|.
name|opcode
operator|!=
name|IP_FW_XRESETLOG
condition|)
block|{
name|error
operator|=
name|securelevel_ge
argument_list|(
name|sopt
operator|->
name|sopt_td
operator|->
name|td_ucred
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|find_unref_sh
argument_list|(
operator|&
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Fill in sockopt_data structure that may be useful for 	 * IP_FW3 get requests. 	 */
name|locked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|valsize
operator|<=
sizeof|sizeof
argument_list|(
name|xbuf
argument_list|)
condition|)
block|{
comment|/* use on-stack buffer */
name|sdata
operator|.
name|kbuf
operator|=
name|xbuf
expr_stmt|;
name|sdata
operator|.
name|ksize
operator|=
sizeof|sizeof
argument_list|(
name|xbuf
argument_list|)
expr_stmt|;
name|sdata
operator|.
name|kavail
operator|=
name|valsize
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Determine opcode type/buffer size: 		 * allocate sliding-window buf for data export or 		 * contiguous buffer for special ops. 		 */
if|if
condition|(
operator|(
name|h
operator|.
name|dir
operator|&
name|HDIR_SET
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Set request. Allocate contigous buffer. */
if|if
condition|(
name|valsize
operator|>
name|CTL3_LARGEBUF
condition|)
block|{
name|find_unref_sh
argument_list|(
operator|&
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFBIG
operator|)
return|;
block|}
name|size
operator|=
name|valsize
expr_stmt|;
block|}
else|else
block|{
comment|/* Get request. Allocate sliding window buffer */
name|size
operator|=
operator|(
name|valsize
operator|<
name|CTL3_SMALLBUF
operator|)
condition|?
name|valsize
else|:
name|CTL3_SMALLBUF
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|valsize
condition|)
block|{
comment|/* We have to wire user buffer */
name|error
operator|=
name|vslock
argument_list|(
name|sopt
operator|->
name|sopt_val
argument_list|,
name|valsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|locked
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|sdata
operator|.
name|kbuf
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sdata
operator|.
name|ksize
operator|=
name|size
expr_stmt|;
name|sdata
operator|.
name|kavail
operator|=
name|size
expr_stmt|;
block|}
name|sdata
operator|.
name|sopt
operator|=
name|sopt
expr_stmt|;
name|sdata
operator|.
name|sopt_val
operator|=
name|sopt
operator|->
name|sopt_val
expr_stmt|;
name|sdata
operator|.
name|valsize
operator|=
name|valsize
expr_stmt|;
comment|/* 	 * Copy either all request (if valsize< bsize_max) 	 * or first bsize_max bytes to guarantee most consumers 	 * that all necessary data has been copied). 	 * Anyway, copy not less than sizeof(ip_fw3_opheader). 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
name|sdata
operator|.
name|kbuf
argument_list|,
name|sdata
operator|.
name|ksize
argument_list|,
sizeof|sizeof
argument_list|(
name|ip_fw3_opheader
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|op3
operator|=
operator|(
name|ip_fw3_opheader
operator|*
operator|)
name|sdata
operator|.
name|kbuf
expr_stmt|;
comment|/* Finally, run handler */
name|error
operator|=
name|h
operator|.
name|handler
argument_list|(
name|chain
argument_list|,
name|op3
argument_list|,
operator|&
name|sdata
argument_list|)
expr_stmt|;
name|find_unref_sh
argument_list|(
operator|&
name|h
argument_list|)
expr_stmt|;
comment|/* Flush state and free buffers */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|ipfw_flush_sopt_data
argument_list|(
operator|&
name|sdata
argument_list|)
expr_stmt|;
else|else
name|ipfw_flush_sopt_data
argument_list|(
operator|&
name|sdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
operator|!=
literal|0
condition|)
name|vsunlock
argument_list|(
name|sdata
operator|.
name|sopt_val
argument_list|,
name|valsize
argument_list|)
expr_stmt|;
comment|/* Restore original pointer and set number of bytes written */
name|sopt
operator|->
name|sopt_val
operator|=
name|sdata
operator|.
name|sopt_val
expr_stmt|;
name|sopt
operator|->
name|sopt_valsize
operator|=
name|sdata
operator|.
name|ktotal
expr_stmt|;
if|if
condition|(
name|sdata
operator|.
name|kbuf
operator|!=
name|xbuf
condition|)
name|free
argument_list|(
name|sdata
operator|.
name|kbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * {set|get}sockopt parser.  */
end_comment

begin_function
name|int
name|ipfw_ctl
parameter_list|(
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
define|#
directive|define
name|RULE_MAXSIZE
value|(512*sizeof(u_int32_t))
name|int
name|error
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|valsize
decl_stmt|;
name|struct
name|ip_fw
modifier|*
name|buf
decl_stmt|;
name|struct
name|ip_fw_rule0
modifier|*
name|rule
decl_stmt|;
name|struct
name|ip_fw_chain
modifier|*
name|chain
decl_stmt|;
name|u_int32_t
name|rulenum
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|opt
decl_stmt|;
name|struct
name|rule_check_info
name|ci
decl_stmt|;
name|IPFW_RLOCK_TRACKER
expr_stmt|;
name|chain
operator|=
operator|&
name|V_layer3_chain
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Save original valsize before it is altered via sooptcopyin() */
name|valsize
operator|=
name|sopt
operator|->
name|sopt_valsize
expr_stmt|;
name|opt
operator|=
name|sopt
operator|->
name|sopt_name
expr_stmt|;
comment|/* 	 * Disallow modifications in really-really secure mode, but still allow 	 * the logging counters to be reset. 	 */
if|if
condition|(
name|opt
operator|==
name|IP_FW_ADD
operator|||
operator|(
name|sopt
operator|->
name|sopt_dir
operator|==
name|SOPT_SET
operator|&&
name|opt
operator|!=
name|IP_FW_RESETLOG
operator|)
condition|)
block|{
name|error
operator|=
name|securelevel_ge
argument_list|(
name|sopt
operator|->
name|sopt_td
operator|->
name|td_ucred
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|IP_FW_GET
case|:
comment|/* 		 * pass up a copy of the current rules. Static rules 		 * come first (the last of which has number IPFW_DEFAULT_RULE), 		 * followed by a possibly empty list of dynamic rule. 		 * The last dynamic rule has NULL in the "next" field. 		 * 		 * Note that the calculated size is used to bound the 		 * amount of data returned to the user.  The rule set may 		 * change between calculating the size and returning the 		 * data in which case we'll just return what fits. 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|,
name|want
decl_stmt|;
name|size
operator|=
name|chain
operator|->
name|static_len
expr_stmt|;
name|size
operator|+=
name|ipfw_dyn_len
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|sopt
operator|->
name|sopt_valsize
condition|)
break|break;
name|buf
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|IPFW_UH_RLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* check again how much space we need */
name|want
operator|=
name|chain
operator|->
name|static_len
operator|+
name|ipfw_dyn_len
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|want
condition|)
name|len
operator|=
name|ipfw_getrules
argument_list|(
name|chain
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|IPFW_UH_RUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|want
condition|)
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|want
condition|)
break|break;
block|}
break|break;
case|case
name|IP_FW_FLUSH
case|:
comment|/* locking is done within del_entry() */
name|error
operator|=
name|del_entry
argument_list|(
name|chain
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* special case, rule=0, cmd=0 means all */
break|break;
case|case
name|IP_FW_ADD
case|:
name|rule
operator|=
name|malloc
argument_list|(
name|RULE_MAXSIZE
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
name|rule
argument_list|,
name|RULE_MAXSIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_fw7
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ci
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rule_check_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If the size of commands equals RULESIZE7 then we assume 		 * a FreeBSD7.2 binary is talking to us (set is7=1). 		 * is7 is persistent so the next 'ipfw list' command 		 * will use this format. 		 * NOTE: If wrong version is guessed (this can happen if 		 *       the first ipfw command is 'ipfw [pipe] list') 		 *       the ipfw binary may crash or loop infinitly... 		 */
name|size
operator|=
name|sopt
operator|->
name|sopt_valsize
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|RULESIZE7
argument_list|(
name|rule
argument_list|)
condition|)
block|{
name|is7
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|convert_rule_to_8
argument_list|(
name|rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|rule
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|size
operator|=
name|RULESIZE
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
else|else
name|is7
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|check_ipfw_rule0
argument_list|(
name|rule
argument_list|,
name|size
argument_list|,
operator|&
name|ci
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* locking is done within add_rule() */
name|struct
name|ip_fw
modifier|*
name|krule
decl_stmt|;
name|krule
operator|=
name|ipfw_alloc_rule
argument_list|(
name|chain
argument_list|,
name|RULEKSIZE0
argument_list|(
name|rule
argument_list|)
argument_list|)
expr_stmt|;
name|ci
operator|.
name|urule
operator|=
operator|(
name|caddr_t
operator|)
name|rule
expr_stmt|;
name|ci
operator|.
name|krule
operator|=
name|krule
expr_stmt|;
name|import_rule0
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
name|error
operator|=
name|commit_rules
argument_list|(
name|chain
argument_list|,
operator|&
name|ci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|free_rule
argument_list|(
name|ci
operator|.
name|krule
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sopt
operator|->
name|sopt_dir
operator|==
name|SOPT_GET
condition|)
block|{
if|if
condition|(
name|is7
condition|)
block|{
name|error
operator|=
name|convert_rule_to_7
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|size
operator|=
name|RULESIZE7
argument_list|(
name|rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|rule
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
name|rule
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|rule
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_FW_DEL
case|:
comment|/* 		 * IP_FW_DEL is used for deleting single rules or sets, 		 * and (ab)used to atomically manipulate sets. Argument size 		 * is used to distinguish between the two: 		 *    sizeof(u_int32_t) 		 *	delete single rule or set of rules, 		 *	or reassign rules (or sets) to a different set. 		 *    2*sizeof(u_int32_t) 		 *	atomic disable/enable sets. 		 *	first u_int32_t contains sets to be disabled, 		 *	second u_int32_t contains sets to be enabled. 		 */
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
name|rulenum
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|size
operator|=
name|sopt
operator|->
name|sopt_valsize
expr_stmt|;
if|if
condition|(
name|size
operator|==
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|&&
name|rulenum
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* delete or reassign, locking done in del_entry() */
name|error
operator|=
name|del_entry
argument_list|(
name|chain
argument_list|,
name|rulenum
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
condition|)
block|{
comment|/* set enable/disable */
name|IPFW_UH_WLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|V_set_disable
operator|=
operator|(
name|V_set_disable
operator||
name|rulenum
index|[
literal|0
index|]
operator|)
operator|&
operator|~
name|rulenum
index|[
literal|1
index|]
operator|&
operator|~
operator|(
literal|1
operator|<<
name|RESVD_SET
operator|)
expr_stmt|;
comment|/* set RESVD_SET always enabled */
name|IPFW_UH_WUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|IP_FW_ZERO
case|:
case|case
name|IP_FW_RESETLOG
case|:
comment|/* argument is an u_int_32, the rule number */
name|rulenum
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_val
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
name|rulenum
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|error
operator|=
name|zero_entry
argument_list|(
name|chain
argument_list|,
name|rulenum
index|[
literal|0
index|]
argument_list|,
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_FW_RESETLOG
argument_list|)
expr_stmt|;
break|break;
comment|/*--- TABLE opcodes ---*/
case|case
name|IP_FW_TABLE_ADD
case|:
case|case
name|IP_FW_TABLE_DEL
case|:
block|{
name|ipfw_table_entry
name|ent
decl_stmt|;
name|struct
name|tentry_info
name|tei
decl_stmt|;
name|struct
name|tid_info
name|ti
decl_stmt|;
name|struct
name|table_value
name|v
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|ent
argument_list|,
sizeof|sizeof
argument_list|(
name|ent
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|memset
argument_list|(
operator|&
name|tei
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tei
argument_list|)
argument_list|)
expr_stmt|;
name|tei
operator|.
name|paddr
operator|=
operator|&
name|ent
operator|.
name|addr
expr_stmt|;
name|tei
operator|.
name|subtype
operator|=
name|AF_INET
expr_stmt|;
name|tei
operator|.
name|masklen
operator|=
name|ent
operator|.
name|masklen
expr_stmt|;
name|ipfw_import_table_value_legacy
argument_list|(
name|ent
operator|.
name|value
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|tei
operator|.
name|pvalue
operator|=
operator|&
name|v
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ti
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ti
argument_list|)
argument_list|)
expr_stmt|;
name|ti
operator|.
name|uidx
operator|=
name|ent
operator|.
name|tbl
expr_stmt|;
name|ti
operator|.
name|type
operator|=
name|IPFW_TABLE_CIDR
expr_stmt|;
name|error
operator|=
operator|(
name|opt
operator|==
name|IP_FW_TABLE_ADD
operator|)
condition|?
name|add_table_entry
argument_list|(
name|chain
argument_list|,
operator|&
name|ti
argument_list|,
operator|&
name|tei
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
else|:
name|del_table_entry
argument_list|(
name|chain
argument_list|,
operator|&
name|ti
argument_list|,
operator|&
name|tei
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IP_FW_TABLE_FLUSH
case|:
block|{
name|u_int16_t
name|tbl
decl_stmt|;
name|struct
name|tid_info
name|ti
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|tbl
argument_list|,
sizeof|sizeof
argument_list|(
name|tbl
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tbl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|memset
argument_list|(
operator|&
name|ti
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ti
argument_list|)
argument_list|)
expr_stmt|;
name|ti
operator|.
name|uidx
operator|=
name|tbl
expr_stmt|;
name|error
operator|=
name|flush_table
argument_list|(
name|chain
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IP_FW_TABLE_GETSIZE
case|:
block|{
name|u_int32_t
name|tbl
decl_stmt|,
name|cnt
decl_stmt|;
name|struct
name|tid_info
name|ti
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|tbl
argument_list|,
sizeof|sizeof
argument_list|(
name|tbl
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tbl
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
name|memset
argument_list|(
operator|&
name|ti
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ti
argument_list|)
argument_list|)
expr_stmt|;
name|ti
operator|.
name|uidx
operator|=
name|tbl
expr_stmt|;
name|IPFW_RLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|error
operator|=
name|ipfw_count_table
argument_list|(
name|chain
argument_list|,
operator|&
name|ti
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
name|IPFW_RUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|cnt
argument_list|,
sizeof|sizeof
argument_list|(
name|cnt
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IP_FW_TABLE_LIST
case|:
block|{
name|ipfw_table
modifier|*
name|tbl
decl_stmt|;
name|struct
name|tid_info
name|ti
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|tbl
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|size
operator|=
name|sopt
operator|->
name|sopt_valsize
expr_stmt|;
name|tbl
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
name|tbl
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tbl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|tbl
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|tbl
operator|->
name|size
operator|=
operator|(
name|size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|tbl
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|ipfw_table_entry
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ti
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ti
argument_list|)
argument_list|)
expr_stmt|;
name|ti
operator|.
name|uidx
operator|=
name|tbl
operator|->
name|tbl
expr_stmt|;
name|IPFW_RLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|error
operator|=
name|ipfw_dump_table_legacy
argument_list|(
name|chain
argument_list|,
operator|&
name|ti
argument_list|,
name|tbl
argument_list|)
expr_stmt|;
name|IPFW_RUNLOCK
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|tbl
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
name|tbl
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tbl
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*--- NAT operations are protected by the IPFW_LOCK ---*/
case|case
name|IP_FW_NAT_CFG
case|:
if|if
condition|(
name|IPFW_NAT_LOADED
condition|)
name|error
operator|=
name|ipfw_nat_cfg_ptr
argument_list|(
name|sopt
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"IP_FW_NAT_CFG: %s\n"
argument_list|,
literal|"ipfw_nat not present, please load it"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|IP_FW_NAT_DEL
case|:
if|if
condition|(
name|IPFW_NAT_LOADED
condition|)
name|error
operator|=
name|ipfw_nat_del_ptr
argument_list|(
name|sopt
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"IP_FW_NAT_DEL: %s\n"
argument_list|,
literal|"ipfw_nat not present, please load it"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|IP_FW_NAT_GET_CONFIG
case|:
if|if
condition|(
name|IPFW_NAT_LOADED
condition|)
name|error
operator|=
name|ipfw_nat_get_cfg_ptr
argument_list|(
name|sopt
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"IP_FW_NAT_GET_CFG: %s\n"
argument_list|,
literal|"ipfw_nat not present, please load it"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|IP_FW_NAT_GET_LOG
case|:
if|if
condition|(
name|IPFW_NAT_LOADED
condition|)
name|error
operator|=
name|ipfw_nat_get_log_ptr
argument_list|(
name|sopt
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"IP_FW_NAT_GET_LOG: %s\n"
argument_list|,
literal|"ipfw_nat not present, please load it"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"ipfw: ipfw_ctl invalid option %d\n"
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
undef|#
directive|undef
name|RULE_MAXSIZE
block|}
end_function

begin_define
define|#
directive|define
name|RULE_MAXSIZE
value|(256*sizeof(u_int32_t))
end_define

begin_comment
comment|/* Functions to convert rules 7.2<==> 8.0 */
end_comment

begin_function
specifier|static
name|int
name|convert_rule_to_7
parameter_list|(
name|struct
name|ip_fw_rule0
modifier|*
name|rule
parameter_list|)
block|{
comment|/* Used to modify original rule */
name|struct
name|ip_fw7
modifier|*
name|rule7
init|=
operator|(
expr|struct
name|ip_fw7
operator|*
operator|)
name|rule
decl_stmt|;
comment|/* copy of original rule, version 8 */
name|struct
name|ip_fw_rule0
modifier|*
name|tmp
decl_stmt|;
comment|/* Used to copy commands */
name|ipfw_insn
modifier|*
name|ccmd
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|int
name|ll
init|=
literal|0
decl_stmt|,
name|ccmdlen
init|=
literal|0
decl_stmt|;
name|tmp
operator|=
name|malloc
argument_list|(
name|RULE_MAXSIZE
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
return|return
literal|1
return|;
comment|//XXX error
block|}
name|bcopy
argument_list|(
name|rule
argument_list|,
name|tmp
argument_list|,
name|RULE_MAXSIZE
argument_list|)
expr_stmt|;
comment|/* Copy fields */
comment|//rule7->_pad = tmp->_pad;
name|rule7
operator|->
name|set
operator|=
name|tmp
operator|->
name|set
expr_stmt|;
name|rule7
operator|->
name|rulenum
operator|=
name|tmp
operator|->
name|rulenum
expr_stmt|;
name|rule7
operator|->
name|cmd_len
operator|=
name|tmp
operator|->
name|cmd_len
expr_stmt|;
name|rule7
operator|->
name|act_ofs
operator|=
name|tmp
operator|->
name|act_ofs
expr_stmt|;
name|rule7
operator|->
name|next_rule
operator|=
operator|(
expr|struct
name|ip_fw7
operator|*
operator|)
name|tmp
operator|->
name|next_rule
expr_stmt|;
name|rule7
operator|->
name|cmd_len
operator|=
name|tmp
operator|->
name|cmd_len
expr_stmt|;
name|rule7
operator|->
name|pcnt
operator|=
name|tmp
operator|->
name|pcnt
expr_stmt|;
name|rule7
operator|->
name|bcnt
operator|=
name|tmp
operator|->
name|bcnt
expr_stmt|;
name|rule7
operator|->
name|timestamp
operator|=
name|tmp
operator|->
name|timestamp
expr_stmt|;
comment|/* Copy commands */
for|for
control|(
name|ll
operator|=
name|tmp
operator|->
name|cmd_len
operator|,
name|ccmd
operator|=
name|tmp
operator|->
name|cmd
operator|,
name|dst
operator|=
name|rule7
operator|->
name|cmd
init|;
name|ll
operator|>
literal|0
condition|;
name|ll
operator|-=
name|ccmdlen
operator|,
name|ccmd
operator|+=
name|ccmdlen
operator|,
name|dst
operator|+=
name|ccmdlen
control|)
block|{
name|ccmdlen
operator|=
name|F_LEN
argument_list|(
name|ccmd
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ccmd
argument_list|,
name|dst
argument_list|,
name|F_LEN
argument_list|(
name|ccmd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|opcode
operator|>
name|O_NAT
condition|)
comment|/* O_REASS doesn't exists in 7.2 version, so 			 * decrement opcode if it is after O_REASS 			 */
name|dst
operator|->
name|opcode
operator|--
expr_stmt|;
if|if
condition|(
name|ccmdlen
operator|>
name|ll
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: opcode %d size truncated\n"
argument_list|,
name|ccmd
operator|->
name|opcode
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
name|free
argument_list|(
name|tmp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|convert_rule_to_8
parameter_list|(
name|struct
name|ip_fw_rule0
modifier|*
name|rule
parameter_list|)
block|{
comment|/* Used to modify original rule */
name|struct
name|ip_fw7
modifier|*
name|rule7
init|=
operator|(
expr|struct
name|ip_fw7
operator|*
operator|)
name|rule
decl_stmt|;
comment|/* Used to copy commands */
name|ipfw_insn
modifier|*
name|ccmd
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|int
name|ll
init|=
literal|0
decl_stmt|,
name|ccmdlen
init|=
literal|0
decl_stmt|;
comment|/* Copy of original rule */
name|struct
name|ip_fw7
modifier|*
name|tmp
init|=
name|malloc
argument_list|(
name|RULE_MAXSIZE
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
return|return
literal|1
return|;
comment|//XXX error
block|}
name|bcopy
argument_list|(
name|rule7
argument_list|,
name|tmp
argument_list|,
name|RULE_MAXSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|ll
operator|=
name|tmp
operator|->
name|cmd_len
operator|,
name|ccmd
operator|=
name|tmp
operator|->
name|cmd
operator|,
name|dst
operator|=
name|rule
operator|->
name|cmd
init|;
name|ll
operator|>
literal|0
condition|;
name|ll
operator|-=
name|ccmdlen
operator|,
name|ccmd
operator|+=
name|ccmdlen
operator|,
name|dst
operator|+=
name|ccmdlen
control|)
block|{
name|ccmdlen
operator|=
name|F_LEN
argument_list|(
name|ccmd
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ccmd
argument_list|,
name|dst
argument_list|,
name|F_LEN
argument_list|(
name|ccmd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|opcode
operator|>
name|O_NAT
condition|)
comment|/* O_REASS doesn't exists in 7.2 version, so 			 * increment opcode if it is after O_REASS 			 */
name|dst
operator|->
name|opcode
operator|++
expr_stmt|;
if|if
condition|(
name|ccmdlen
operator|>
name|ll
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw: opcode %d size truncated\n"
argument_list|,
name|ccmd
operator|->
name|opcode
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
name|rule
operator|->
name|_pad
operator|=
name|tmp
operator|->
name|_pad
expr_stmt|;
name|rule
operator|->
name|set
operator|=
name|tmp
operator|->
name|set
expr_stmt|;
name|rule
operator|->
name|rulenum
operator|=
name|tmp
operator|->
name|rulenum
expr_stmt|;
name|rule
operator|->
name|cmd_len
operator|=
name|tmp
operator|->
name|cmd_len
expr_stmt|;
name|rule
operator|->
name|act_ofs
operator|=
name|tmp
operator|->
name|act_ofs
expr_stmt|;
name|rule
operator|->
name|next_rule
operator|=
operator|(
expr|struct
name|ip_fw
operator|*
operator|)
name|tmp
operator|->
name|next_rule
expr_stmt|;
name|rule
operator|->
name|cmd_len
operator|=
name|tmp
operator|->
name|cmd_len
expr_stmt|;
name|rule
operator|->
name|id
operator|=
literal|0
expr_stmt|;
comment|/* XXX see if is ok = 0 */
name|rule
operator|->
name|pcnt
operator|=
name|tmp
operator|->
name|pcnt
expr_stmt|;
name|rule
operator|->
name|bcnt
operator|=
name|tmp
operator|->
name|bcnt
expr_stmt|;
name|rule
operator|->
name|timestamp
operator|=
name|tmp
operator|->
name|timestamp
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Named object api  *  */
end_comment

begin_function
name|void
name|ipfw_init_srv
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|)
block|{
name|ch
operator|->
name|srvmap
operator|=
name|ipfw_objhash_create
argument_list|(
name|IPFW_OBJECTS_DEFAULT
argument_list|)
expr_stmt|;
name|ch
operator|->
name|srvstate
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|IPFW_OBJECTS_DEFAULT
argument_list|,
name|M_IPFW
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipfw_destroy_srv
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|)
block|{
name|free
argument_list|(
name|ch
operator|->
name|srvstate
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
name|ipfw_objhash_destroy
argument_list|(
name|ch
operator|->
name|srvmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate new bitmask which can be used to enlarge/shrink  * named instance index.  */
end_comment

begin_function
name|void
name|ipfw_objhash_bitmap_alloc
parameter_list|(
name|uint32_t
name|items
parameter_list|,
name|void
modifier|*
modifier|*
name|idx
parameter_list|,
name|int
modifier|*
name|pblocks
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|int
name|max_blocks
decl_stmt|;
name|u_long
modifier|*
name|idx_mask
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|items
operator|%
name|BLOCK_ITEMS
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"bitmask size needs to power of 2 and greater or equal to %zu"
operator|,
name|BLOCK_ITEMS
operator|)
argument_list|)
expr_stmt|;
name|max_blocks
operator|=
name|items
operator|/
name|BLOCK_ITEMS
expr_stmt|;
name|size
operator|=
name|items
operator|/
literal|8
expr_stmt|;
name|idx_mask
operator|=
name|malloc
argument_list|(
name|size
operator|*
name|IPFW_MAX_SETS
argument_list|,
name|M_IPFW
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* Mark all as free */
name|memset
argument_list|(
name|idx_mask
argument_list|,
literal|0xFF
argument_list|,
name|size
operator|*
name|IPFW_MAX_SETS
argument_list|)
expr_stmt|;
operator|*
name|idx_mask
operator|&=
operator|~
operator|(
name|u_long
operator|)
literal|1
expr_stmt|;
comment|/* Skip index 0 */
operator|*
name|idx
operator|=
name|idx_mask
expr_stmt|;
operator|*
name|pblocks
operator|=
name|max_blocks
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy current bitmask index to new one.  */
end_comment

begin_function
name|void
name|ipfw_objhash_bitmap_merge
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|void
modifier|*
modifier|*
name|idx
parameter_list|,
name|int
modifier|*
name|blocks
parameter_list|)
block|{
name|int
name|old_blocks
decl_stmt|,
name|new_blocks
decl_stmt|;
name|u_long
modifier|*
name|old_idx
decl_stmt|,
modifier|*
name|new_idx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|old_idx
operator|=
name|ni
operator|->
name|idx_mask
expr_stmt|;
name|old_blocks
operator|=
name|ni
operator|->
name|max_blocks
expr_stmt|;
name|new_idx
operator|=
operator|*
name|idx
expr_stmt|;
name|new_blocks
operator|=
operator|*
name|blocks
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPFW_MAX_SETS
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|new_idx
index|[
name|new_blocks
operator|*
name|i
index|]
argument_list|,
operator|&
name|old_idx
index|[
name|old_blocks
operator|*
name|i
index|]
argument_list|,
name|old_blocks
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Swaps current @ni index with new one.  */
end_comment

begin_function
name|void
name|ipfw_objhash_bitmap_swap
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|void
modifier|*
modifier|*
name|idx
parameter_list|,
name|int
modifier|*
name|blocks
parameter_list|)
block|{
name|int
name|old_blocks
decl_stmt|;
name|u_long
modifier|*
name|old_idx
decl_stmt|;
name|old_idx
operator|=
name|ni
operator|->
name|idx_mask
expr_stmt|;
name|old_blocks
operator|=
name|ni
operator|->
name|max_blocks
expr_stmt|;
name|ni
operator|->
name|idx_mask
operator|=
operator|*
name|idx
expr_stmt|;
name|ni
operator|->
name|max_blocks
operator|=
operator|*
name|blocks
expr_stmt|;
comment|/* Save old values */
operator|*
name|idx
operator|=
name|old_idx
expr_stmt|;
operator|*
name|blocks
operator|=
name|old_blocks
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipfw_objhash_bitmap_free
parameter_list|(
name|void
modifier|*
name|idx
parameter_list|,
name|int
name|blocks
parameter_list|)
block|{
name|free
argument_list|(
name|idx
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Creates named hash instance.  * Must be called without holding any locks.  * Return pointer to new instance.  */
end_comment

begin_function
name|struct
name|namedobj_instance
modifier|*
name|ipfw_objhash_create
parameter_list|(
name|uint32_t
name|items
parameter_list|)
block|{
name|struct
name|namedobj_instance
modifier|*
name|ni
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|namedobj_instance
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|namedobjects_head
argument_list|)
operator|*
name|NAMEDOBJ_HASH_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|namedobjects_head
argument_list|)
operator|*
name|NAMEDOBJ_HASH_SIZE
expr_stmt|;
name|ni
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_IPFW
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ni
operator|->
name|nn_size
operator|=
name|NAMEDOBJ_HASH_SIZE
expr_stmt|;
name|ni
operator|->
name|nv_size
operator|=
name|NAMEDOBJ_HASH_SIZE
expr_stmt|;
name|ni
operator|->
name|names
operator|=
operator|(
expr|struct
name|namedobjects_head
operator|*
operator|)
operator|(
name|ni
operator|+
literal|1
operator|)
expr_stmt|;
name|ni
operator|->
name|values
operator|=
operator|&
name|ni
operator|->
name|names
index|[
name|ni
operator|->
name|nn_size
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ni
operator|->
name|nn_size
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|ni
operator|->
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ni
operator|->
name|nv_size
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|ni
operator|->
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Set default hashing/comparison functions */
name|ni
operator|->
name|hash_f
operator|=
name|objhash_hash_name
expr_stmt|;
name|ni
operator|->
name|cmp_f
operator|=
name|objhash_cmp_name
expr_stmt|;
comment|/* Allocate bitmask separately due to possible resize */
name|ipfw_objhash_bitmap_alloc
argument_list|(
name|items
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ni
operator|->
name|idx_mask
argument_list|,
operator|&
name|ni
operator|->
name|max_blocks
argument_list|)
expr_stmt|;
return|return
operator|(
name|ni
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ipfw_objhash_destroy
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|)
block|{
name|free
argument_list|(
name|ni
operator|->
name|idx_mask
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ni
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipfw_objhash_set_funcs
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|objhash_hash_f
modifier|*
name|hash_f
parameter_list|,
name|objhash_cmp_f
modifier|*
name|cmp_f
parameter_list|)
block|{
name|ni
operator|->
name|hash_f
operator|=
name|hash_f
expr_stmt|;
name|ni
operator|->
name|cmp_f
operator|=
name|cmp_f
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|objhash_hash_name
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
specifier|const
name|void
modifier|*
name|name
parameter_list|,
name|uint32_t
name|set
parameter_list|)
block|{
return|return
operator|(
name|fnv_32_str
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|,
name|FNV1_32_INIT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|objhash_cmp_name
parameter_list|(
name|struct
name|named_object
modifier|*
name|no
parameter_list|,
specifier|const
name|void
modifier|*
name|name
parameter_list|,
name|uint32_t
name|set
parameter_list|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|no
operator|->
name|name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|no
operator|->
name|set
operator|==
name|set
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|objhash_hash_idx
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|v
operator|=
name|val
operator|%
operator|(
name|ni
operator|->
name|nv_size
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|named_object
modifier|*
name|ipfw_objhash_lookup_name
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|uint32_t
name|set
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|named_object
modifier|*
name|no
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|hash
operator|=
name|ni
operator|->
name|hash_f
argument_list|(
name|ni
argument_list|,
name|name
argument_list|,
name|set
argument_list|)
operator|%
name|ni
operator|->
name|nn_size
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|no
argument_list|,
argument|&ni->names[hash]
argument_list|,
argument|nn_next
argument_list|)
block|{
if|if
condition|(
name|ni
operator|->
name|cmp_f
argument_list|(
name|no
argument_list|,
name|name
argument_list|,
name|set
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|no
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find named object by @uid.  * Check @tlvs for valid data inside.  *  * Returns pointer to found TLV or NULL.  */
end_comment

begin_function
name|ipfw_obj_ntlv
modifier|*
name|ipfw_find_name_tlv_type
parameter_list|(
name|void
modifier|*
name|tlvs
parameter_list|,
name|int
name|len
parameter_list|,
name|uint16_t
name|uidx
parameter_list|,
name|uint32_t
name|etlv
parameter_list|)
block|{
name|ipfw_obj_ntlv
modifier|*
name|ntlv
decl_stmt|;
name|uintptr_t
name|pa
decl_stmt|,
name|pe
decl_stmt|;
name|int
name|l
decl_stmt|;
name|pa
operator|=
operator|(
name|uintptr_t
operator|)
name|tlvs
expr_stmt|;
name|pe
operator|=
name|pa
operator|+
name|len
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|pa
operator|<
name|pe
condition|;
name|pa
operator|+=
name|l
control|)
block|{
name|ntlv
operator|=
operator|(
name|ipfw_obj_ntlv
operator|*
operator|)
name|pa
expr_stmt|;
name|l
operator|=
name|ntlv
operator|->
name|head
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|l
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ntlv
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ntlv
operator|->
name|idx
operator|!=
name|uidx
condition|)
continue|continue;
comment|/* 		 * When userland has specified zero TLV type, do 		 * not compare it with eltv. In some cases userland 		 * doesn't know what type should it have. Use only 		 * uidx and name for search named_object. 		 */
if|if
condition|(
name|ntlv
operator|->
name|head
operator|.
name|type
operator|!=
literal|0
operator|&&
name|ntlv
operator|->
name|head
operator|.
name|type
operator|!=
operator|(
name|uint16_t
operator|)
name|etlv
condition|)
continue|continue;
if|if
condition|(
name|ipfw_check_object_name_generic
argument_list|(
name|ntlv
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|ntlv
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finds object config based on either legacy index  * or name in ntlv.  * Note @ti structure contains unchecked data from userland.  *  * Returns 0 in success and fills in @pno with found config  */
end_comment

begin_function
name|int
name|ipfw_objhash_find_type
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|struct
name|tid_info
modifier|*
name|ti
parameter_list|,
name|uint32_t
name|etlv
parameter_list|,
name|struct
name|named_object
modifier|*
modifier|*
name|pno
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|ipfw_obj_ntlv
modifier|*
name|ntlv
decl_stmt|;
name|uint32_t
name|set
decl_stmt|;
if|if
condition|(
name|ti
operator|->
name|tlvs
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ntlv
operator|=
name|ipfw_find_name_tlv_type
argument_list|(
name|ti
operator|->
name|tlvs
argument_list|,
name|ti
operator|->
name|tlen
argument_list|,
name|ti
operator|->
name|uidx
argument_list|,
name|etlv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntlv
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|name
operator|=
name|ntlv
operator|->
name|name
expr_stmt|;
comment|/* 	 * Use set provided by @ti instead of @ntlv one. 	 * This is needed due to different sets behavior 	 * controlled by V_fw_tables_sets. 	 */
name|set
operator|=
name|ti
operator|->
name|set
expr_stmt|;
operator|*
name|pno
operator|=
name|ipfw_objhash_lookup_name
argument_list|(
name|ni
argument_list|,
name|set
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pno
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find named object by name, considering also its TLV type.  */
end_comment

begin_function
name|struct
name|named_object
modifier|*
name|ipfw_objhash_lookup_name_type
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|uint32_t
name|set
parameter_list|,
name|uint32_t
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|named_object
modifier|*
name|no
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|hash
operator|=
name|ni
operator|->
name|hash_f
argument_list|(
name|ni
argument_list|,
name|name
argument_list|,
name|set
argument_list|)
operator|%
name|ni
operator|->
name|nn_size
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|no
argument_list|,
argument|&ni->names[hash]
argument_list|,
argument|nn_next
argument_list|)
block|{
if|if
condition|(
name|ni
operator|->
name|cmp_f
argument_list|(
name|no
argument_list|,
name|name
argument_list|,
name|set
argument_list|)
operator|==
literal|0
operator|&&
name|no
operator|->
name|etlv
operator|==
operator|(
name|uint16_t
operator|)
name|type
condition|)
return|return
operator|(
name|no
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|named_object
modifier|*
name|ipfw_objhash_lookup_kidx
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|uint16_t
name|kidx
parameter_list|)
block|{
name|struct
name|named_object
modifier|*
name|no
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|hash
operator|=
name|objhash_hash_idx
argument_list|(
name|ni
argument_list|,
name|kidx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|no
argument_list|,
argument|&ni->values[hash]
argument_list|,
argument|nv_next
argument_list|)
block|{
if|if
condition|(
name|no
operator|->
name|kidx
operator|==
name|kidx
condition|)
return|return
operator|(
name|no
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ipfw_objhash_same_name
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|struct
name|named_object
modifier|*
name|a
parameter_list|,
name|struct
name|named_object
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|a
operator|->
name|set
operator|==
name|b
operator|->
name|set
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ipfw_objhash_add
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|struct
name|named_object
modifier|*
name|no
parameter_list|)
block|{
name|uint32_t
name|hash
decl_stmt|;
name|hash
operator|=
name|ni
operator|->
name|hash_f
argument_list|(
name|ni
argument_list|,
name|no
operator|->
name|name
argument_list|,
name|no
operator|->
name|set
argument_list|)
operator|%
name|ni
operator|->
name|nn_size
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ni
operator|->
name|names
index|[
name|hash
index|]
argument_list|,
name|no
argument_list|,
name|nn_next
argument_list|)
expr_stmt|;
name|hash
operator|=
name|objhash_hash_idx
argument_list|(
name|ni
argument_list|,
name|no
operator|->
name|kidx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ni
operator|->
name|values
index|[
name|hash
index|]
argument_list|,
name|no
argument_list|,
name|nv_next
argument_list|)
expr_stmt|;
name|ni
operator|->
name|count
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipfw_objhash_del
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|struct
name|named_object
modifier|*
name|no
parameter_list|)
block|{
name|uint32_t
name|hash
decl_stmt|;
name|hash
operator|=
name|ni
operator|->
name|hash_f
argument_list|(
name|ni
argument_list|,
name|no
operator|->
name|name
argument_list|,
name|no
operator|->
name|set
argument_list|)
operator|%
name|ni
operator|->
name|nn_size
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ni
operator|->
name|names
index|[
name|hash
index|]
argument_list|,
name|no
argument_list|,
name|nn_next
argument_list|)
expr_stmt|;
name|hash
operator|=
name|objhash_hash_idx
argument_list|(
name|ni
argument_list|,
name|no
operator|->
name|kidx
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ni
operator|->
name|values
index|[
name|hash
index|]
argument_list|,
name|no
argument_list|,
name|nv_next
argument_list|)
expr_stmt|;
name|ni
operator|->
name|count
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|ipfw_objhash_count
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|)
block|{
return|return
operator|(
name|ni
operator|->
name|count
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|ipfw_objhash_count_type
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|named_object
modifier|*
name|no
decl_stmt|;
name|uint32_t
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ni
operator|->
name|nn_size
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|no
argument_list|,
argument|&ni->names[i]
argument_list|,
argument|nn_next
argument_list|)
block|{
if|if
condition|(
name|no
operator|->
name|etlv
operator|==
name|type
condition|)
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Runs @func for each found named object.  * It is safe to delete objects from callback  */
end_comment

begin_function
name|int
name|ipfw_objhash_foreach
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|objhash_cb_t
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|named_object
modifier|*
name|no
decl_stmt|,
modifier|*
name|no_tmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ni
operator|->
name|nn_size
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|no
argument_list|,
argument|&ni->names[i]
argument_list|,
argument|nn_next
argument_list|,
argument|no_tmp
argument_list|)
block|{
name|ret
operator|=
name|f
argument_list|(
name|ni
argument_list|,
name|no
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Runs @f for each found named object with type @type.  * It is safe to delete objects from callback  */
end_comment

begin_function
name|int
name|ipfw_objhash_foreach_type
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|objhash_cb_t
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|named_object
modifier|*
name|no
decl_stmt|,
modifier|*
name|no_tmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ni
operator|->
name|nn_size
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|no
argument_list|,
argument|&ni->names[i]
argument_list|,
argument|nn_next
argument_list|,
argument|no_tmp
argument_list|)
block|{
if|if
condition|(
name|no
operator|->
name|etlv
operator|!=
name|type
condition|)
continue|continue;
name|ret
operator|=
name|f
argument_list|(
name|ni
argument_list|,
name|no
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Removes index from given set.  * Returns 0 on success.  */
end_comment

begin_function
name|int
name|ipfw_objhash_free_idx
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|uint16_t
name|idx
parameter_list|)
block|{
name|u_long
modifier|*
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|,
name|v
decl_stmt|;
name|i
operator|=
name|idx
operator|/
name|BLOCK_ITEMS
expr_stmt|;
name|v
operator|=
name|idx
operator|%
name|BLOCK_ITEMS
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|ni
operator|->
name|max_blocks
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|mask
operator|=
operator|&
name|ni
operator|->
name|idx_mask
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|mask
operator|&
operator|(
operator|(
name|u_long
operator|)
literal|1
operator|<<
name|v
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Mark as free */
operator|*
name|mask
operator||=
operator|(
name|u_long
operator|)
literal|1
operator|<<
name|v
expr_stmt|;
comment|/* Update free offset */
if|if
condition|(
name|ni
operator|->
name|free_off
index|[
literal|0
index|]
operator|>
name|i
condition|)
name|ni
operator|->
name|free_off
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate new index in given instance and stores in in @pidx.  * Returns 0 on success.  */
end_comment

begin_function
name|int
name|ipfw_objhash_alloc_idx
parameter_list|(
name|void
modifier|*
name|n
parameter_list|,
name|uint16_t
modifier|*
name|pidx
parameter_list|)
block|{
name|struct
name|namedobj_instance
modifier|*
name|ni
decl_stmt|;
name|u_long
modifier|*
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|,
name|off
decl_stmt|,
name|v
decl_stmt|;
name|ni
operator|=
operator|(
expr|struct
name|namedobj_instance
operator|*
operator|)
name|n
expr_stmt|;
name|off
operator|=
name|ni
operator|->
name|free_off
index|[
literal|0
index|]
expr_stmt|;
name|mask
operator|=
operator|&
name|ni
operator|->
name|idx_mask
index|[
name|off
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|off
init|;
name|i
operator|<
name|ni
operator|->
name|max_blocks
condition|;
name|i
operator|++
operator|,
name|mask
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|v
operator|=
name|ffsl
argument_list|(
operator|*
name|mask
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Mark as busy */
operator|*
name|mask
operator|&=
operator|~
operator|(
operator|(
name|u_long
operator|)
literal|1
operator|<<
operator|(
name|v
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|ni
operator|->
name|free_off
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|v
operator|=
name|BLOCK_ITEMS
operator|*
name|i
operator|+
name|v
operator|-
literal|1
expr_stmt|;
operator|*
name|pidx
operator|=
name|v
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end of file */
end_comment

end_unit

