begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * FQ_PIE - The FlowQueue-PIE scheduler/AQM  *  * $FreeBSD$  *   * Copyright (C) 2016 Centre for Advanced Internet Architectures,  *  Swinburne University of Technology, Melbourne, Australia.  * Portions of this code were made possible in part by a gift from   *  The Comcast Innovation Fund.  * Implemented by Rasool Al-Saadi<ralsaadi@swin.edu.au>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* Important note:  * As there is no an office document for FQ-PIE specification, we used  * FQ-CoDel algorithm with some modifications to implement FQ-PIE.  * This FQ-PIE implementation is a beta version and have not been tested   * extensively. Our FQ-PIE uses stand-alone PIE AQM per sub-queue. By  * default, timestamp is used to calculate queue delay instead of departure  * rate estimation method. Although departure rate estimation is available   * as testing option, the results could be incorrect. Moreover, turning PIE on   * and off option is available but it does not work properly in this version.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_comment
comment|/* IFNAMSIZ */
end_comment

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_comment
comment|/* ipfw_rule_ref */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_comment
comment|/* flow_id */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip_dummynet.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/ip_fw_private.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/dn_heap.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/ip_dn_private.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/dn_aqm.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/dn_aqm_pie.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/dn_sched.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dn_test.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DN_SCHED_FQ_PIE
value|7
end_define

begin_comment
comment|/* list of queues */
end_comment

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|fq_pie_list
argument_list|,
name|fq_pie_flow
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* FQ_PIE parameters including PIE */
end_comment

begin_struct
struct|struct
name|dn_sch_fq_pie_parms
block|{
name|struct
name|dn_aqm_pie_parms
name|pcfg
decl_stmt|;
comment|/* PIE configuration Parameters */
comment|/* FQ_PIE Parameters */
name|uint32_t
name|flows_cnt
decl_stmt|;
comment|/* number of flows */
name|uint32_t
name|limit
decl_stmt|;
comment|/* hard limit of FQ_PIE queue size*/
name|uint32_t
name|quantum
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* flow (sub-queue) stats */
end_comment

begin_struct
struct|struct
name|flow_stats
block|{
name|uint64_t
name|tot_pkts
decl_stmt|;
comment|/* statistics counters  */
name|uint64_t
name|tot_bytes
decl_stmt|;
name|uint32_t
name|length
decl_stmt|;
comment|/* Queue length, in packets */
name|uint32_t
name|len_bytes
decl_stmt|;
comment|/* Queue length, in bytes */
name|uint32_t
name|drops
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A flow of packets (sub-queue)*/
end_comment

begin_struct
struct|struct
name|fq_pie_flow
block|{
name|struct
name|mq
name|mq
decl_stmt|;
comment|/* list of packets */
name|struct
name|flow_stats
name|stats
decl_stmt|;
comment|/* statistics */
name|int
name|deficit
decl_stmt|;
name|int
name|active
decl_stmt|;
comment|/* 1: flow is active (in a list) */
name|struct
name|pie_status
name|pst
decl_stmt|;
comment|/* pie status variables */
name|struct
name|fq_pie_si_extra
modifier|*
name|psi_extra
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|fq_pie_flow
argument_list|)
name|flowchain
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* extra fq_pie scheduler configurations */
end_comment

begin_struct
struct|struct
name|fq_pie_schk
block|{
name|struct
name|dn_sch_fq_pie_parms
name|cfg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* fq_pie scheduler instance extra state vars.  * The purpose of separation this structure is to preserve number of active  * sub-queues and the flows array pointer even after the scheduler instance  * is destroyed.  * Preserving these varaiables allows freeing the allocated memory by  * fqpie_callout_cleanup() independently from fq_pie_free_sched().  */
end_comment

begin_struct
struct|struct
name|fq_pie_si_extra
block|{
name|uint32_t
name|nr_active_q
decl_stmt|;
comment|/* number of active queues */
name|struct
name|fq_pie_flow
modifier|*
name|flows
decl_stmt|;
comment|/* array of flows (queues) */
block|}
struct|;
end_struct

begin_comment
comment|/* fq_pie scheduler instance */
end_comment

begin_struct
struct|struct
name|fq_pie_si
block|{
name|struct
name|dn_sch_inst
name|_si
decl_stmt|;
comment|/* standard scheduler instance. SHOULD BE FIRST */
name|struct
name|dn_queue
name|main_q
decl_stmt|;
comment|/* main queue is after si directly */
name|uint32_t
name|perturbation
decl_stmt|;
comment|/* random value */
name|struct
name|fq_pie_list
name|newflows
decl_stmt|;
comment|/* list of new queues */
name|struct
name|fq_pie_list
name|oldflows
decl_stmt|;
comment|/* list of old queues */
name|struct
name|fq_pie_si_extra
modifier|*
name|si_extra
decl_stmt|;
comment|/* extra state vars*/
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|dn_alg
name|fq_pie_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Default FQ-PIE parameters including PIE */
end_comment

begin_comment
comment|/*  PIE defaults  * target=15ms, max_burst=150ms, max_ecnth=0.1,   * alpha=0.125, beta=1.25, tupdate=15ms  * FQ-  * flows=1024, limit=10240, quantum =1514  */
end_comment

begin_decl_stmt
name|struct
name|dn_sch_fq_pie_parms
name|fq_pie_sysctl
init|=
block|{
block|{
literal|15000
operator|*
name|AQM_TIME_1US
block|,
literal|15000
operator|*
name|AQM_TIME_1US
block|,
literal|150000
operator|*
name|AQM_TIME_1US
block|,
name|PIE_SCALE
operator|*
literal|0.1
block|,
name|PIE_SCALE
operator|*
literal|0.125
block|,
name|PIE_SCALE
operator|*
literal|1.25
block|,
name|PIE_CAPDROP_ENABLED
operator||
name|PIE_DERAND_ENABLED
block|}
block|,
literal|1024
block|,
literal|10240
block|,
literal|1514
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|fqpie_sysctl_alpha_beta_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|long
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|oidp
operator|->
name|oid_name
argument_list|,
literal|"alpha"
argument_list|)
condition|)
name|value
operator|=
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|alpha
expr_stmt|;
else|else
name|value
operator|=
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|beta
expr_stmt|;
name|value
operator|=
name|value
operator|*
literal|1000
operator|/
name|PIE_SCALE
expr_stmt|;
name|error
operator|=
name|sysctl_handle_long
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|value
operator|<
literal|1
operator|||
name|value
operator|>
literal|7
operator|*
name|PIE_SCALE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|value
operator|=
operator|(
name|value
operator|*
name|PIE_SCALE
operator|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|oidp
operator|->
name|oid_name
argument_list|,
literal|"alpha"
argument_list|)
condition|)
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|alpha
operator|=
name|value
expr_stmt|;
else|else
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|beta
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fqpie_sysctl_target_tupdate_maxb_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|long
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|oidp
operator|->
name|oid_name
argument_list|,
literal|"target"
argument_list|)
condition|)
name|value
operator|=
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|qdelay_ref
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|oidp
operator|->
name|oid_name
argument_list|,
literal|"tupdate"
argument_list|)
condition|)
name|value
operator|=
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|tupdate
expr_stmt|;
else|else
name|value
operator|=
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|max_burst
expr_stmt|;
name|value
operator|=
name|value
operator|/
name|AQM_TIME_1US
expr_stmt|;
name|error
operator|=
name|sysctl_handle_long
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|value
operator|<
literal|1
operator|||
name|value
operator|>
literal|10
operator|*
name|AQM_TIME_1S
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|value
operator|=
name|value
operator|*
name|AQM_TIME_1US
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|oidp
operator|->
name|oid_name
argument_list|,
literal|"target"
argument_list|)
condition|)
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|qdelay_ref
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|oidp
operator|->
name|oid_name
argument_list|,
literal|"tupdate"
argument_list|)
condition|)
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|tupdate
operator|=
name|value
expr_stmt|;
else|else
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|max_burst
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fqpie_sysctl_max_ecnth_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|long
name|value
decl_stmt|;
name|value
operator|=
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|max_ecnth
expr_stmt|;
name|value
operator|=
name|value
operator|*
literal|1000
operator|/
name|PIE_SCALE
expr_stmt|;
name|error
operator|=
name|sysctl_handle_long
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|value
operator|<
literal|1
operator|||
name|value
operator|>
name|PIE_SCALE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|value
operator|=
operator|(
name|value
operator|*
name|PIE_SCALE
operator|)
operator|/
literal|1000
expr_stmt|;
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|max_ecnth
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* define FQ- PIE sysctl variables */
end_comment

begin_macro
name|SYSBEGIN
argument_list|(
argument|f4
argument_list|)
end_macro

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet_ip
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet_ip_dummynet
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|fqpie
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"FQ_PIE"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SYSCTL_NODE
end_ifdef

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_dummynet_fqpie
argument_list|,
name|OID_AUTO
argument_list|,
name|target
argument_list|,
name|CTLTYPE_LONG
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|fqpie_sysctl_target_tupdate_maxb_handler
argument_list|,
literal|"L"
argument_list|,
literal|"queue target in microsecond"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_dummynet_fqpie
argument_list|,
name|OID_AUTO
argument_list|,
name|tupdate
argument_list|,
name|CTLTYPE_LONG
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|fqpie_sysctl_target_tupdate_maxb_handler
argument_list|,
literal|"L"
argument_list|,
literal|"the frequency of drop probability calculation in microsecond"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_dummynet_fqpie
argument_list|,
name|OID_AUTO
argument_list|,
name|max_burst
argument_list|,
name|CTLTYPE_LONG
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|fqpie_sysctl_target_tupdate_maxb_handler
argument_list|,
literal|"L"
argument_list|,
literal|"Burst allowance interval in microsecond"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_dummynet_fqpie
argument_list|,
name|OID_AUTO
argument_list|,
name|max_ecnth
argument_list|,
name|CTLTYPE_LONG
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|fqpie_sysctl_max_ecnth_handler
argument_list|,
literal|"L"
argument_list|,
literal|"ECN safeguard threshold scaled by 1000"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_dummynet_fqpie
argument_list|,
name|OID_AUTO
argument_list|,
name|alpha
argument_list|,
name|CTLTYPE_LONG
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|fqpie_sysctl_alpha_beta_handler
argument_list|,
literal|"L"
argument_list|,
literal|"PIE alpha scaled by 1000"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_dummynet_fqpie
argument_list|,
name|OID_AUTO
argument_list|,
name|beta
argument_list|,
name|CTLTYPE_LONG
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|fqpie_sysctl_alpha_beta_handler
argument_list|,
literal|"L"
argument_list|,
literal|"beta scaled by 1000"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_net_inet_ip_dummynet_fqpie
argument_list|,
name|OID_AUTO
argument_list|,
name|quantum
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fq_pie_sysctl
operator|.
name|quantum
argument_list|,
literal|1514
argument_list|,
literal|"quantum for FQ_PIE"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_net_inet_ip_dummynet_fqpie
argument_list|,
name|OID_AUTO
argument_list|,
name|flows
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fq_pie_sysctl
operator|.
name|flows_cnt
argument_list|,
literal|1024
argument_list|,
literal|"Number of queues for FQ_PIE"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_net_inet_ip_dummynet_fqpie
argument_list|,
name|OID_AUTO
argument_list|,
name|limit
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fq_pie_sysctl
operator|.
name|limit
argument_list|,
literal|10240
argument_list|,
literal|"limit for FQ_PIE"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Helper function to update queue&main-queue and scheduler statistics.  * negative len& drop -> drop  * negative len -> dequeue  * positive len -> enqueue  * positive len + drop -> drop during enqueue  */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|fq_update_stats
parameter_list|(
name|struct
name|fq_pie_flow
modifier|*
name|q
parameter_list|,
name|struct
name|fq_pie_si
modifier|*
name|si
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|drop
parameter_list|)
block|{
name|int
name|inc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|inc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|drop
condition|)
block|{
name|si
operator|->
name|main_q
operator|.
name|ni
operator|.
name|drops
operator|++
expr_stmt|;
name|q
operator|->
name|stats
operator|.
name|drops
operator|++
expr_stmt|;
name|si
operator|->
name|_si
operator|.
name|ni
operator|.
name|drops
operator|++
expr_stmt|;
name|io_pkt_drop
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|drop
operator|||
operator|(
name|drop
operator|&&
name|len
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* Update stats for the main queue */
name|si
operator|->
name|main_q
operator|.
name|ni
operator|.
name|length
operator|+=
name|inc
expr_stmt|;
name|si
operator|->
name|main_q
operator|.
name|ni
operator|.
name|len_bytes
operator|+=
name|len
expr_stmt|;
comment|/*update sub-queue stats */
name|q
operator|->
name|stats
operator|.
name|length
operator|+=
name|inc
expr_stmt|;
name|q
operator|->
name|stats
operator|.
name|len_bytes
operator|+=
name|len
expr_stmt|;
comment|/*update scheduler instance stats */
name|si
operator|->
name|_si
operator|.
name|ni
operator|.
name|length
operator|+=
name|inc
expr_stmt|;
name|si
operator|->
name|_si
operator|.
name|ni
operator|.
name|len_bytes
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|inc
operator|>
literal|0
condition|)
block|{
name|si
operator|->
name|main_q
operator|.
name|ni
operator|.
name|tot_bytes
operator|+=
name|len
expr_stmt|;
name|si
operator|->
name|main_q
operator|.
name|ni
operator|.
name|tot_pkts
operator|++
expr_stmt|;
name|q
operator|->
name|stats
operator|.
name|tot_bytes
operator|+=
name|len
expr_stmt|;
name|q
operator|->
name|stats
operator|.
name|tot_pkts
operator|++
expr_stmt|;
name|si
operator|->
name|_si
operator|.
name|ni
operator|.
name|tot_bytes
operator|+=
name|len
expr_stmt|;
name|si
operator|->
name|_si
operator|.
name|ni
operator|.
name|tot_pkts
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Extract a packet from the head of sub-queue 'q'  * Return a packet or NULL if the queue is empty.  * If getts is set, also extract packet's timestamp from mtag.  */
end_comment

begin_expr_stmt
name|__inline
specifier|static
expr|struct
name|mbuf
operator|*
name|fq_pie_extract_head
argument_list|(
argument|struct fq_pie_flow *q
argument_list|,
argument|aqm_time_t *pkt_ts
argument_list|,
argument|struct fq_pie_si *si
argument_list|,
argument|int getts
argument_list|)
block|{ 	struct
name|mbuf
operator|*
name|m
operator|=
name|q
operator|->
name|mq
operator|.
name|head
block|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|m
return|;
name|q
operator|->
name|mq
operator|.
name|head
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fq_update_stats
argument_list|(
name|q
argument_list|,
name|si
argument_list|,
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|si
operator|->
name|main_q
operator|.
name|ni
operator|.
name|length
operator|==
literal|0
condition|)
comment|/* queue is now idle */
name|si
operator|->
name|main_q
operator|.
name|q_time
operator|=
name|dn_cfg
operator|.
name|curr_time
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|getts
condition|)
block|{
comment|/* extract packet timestamp*/
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|mtag
operator|=
name|m_tag_locate
argument_list|(
name|m
argument_list|,
name|MTAG_ABI_COMPAT
argument_list|,
name|DN_AQM_MTAG_TS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"PIE timestamp mtag not found!"
argument_list|)
expr_stmt|;
operator|*
name|pkt_ts
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pkt_ts
operator|=
operator|*
operator|(
name|aqm_time_t
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
expr_stmt|;
name|m_tag_delete
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_return
return|return
name|m
return|;
end_return

begin_comment
unit|}
comment|/*  * Callout function for drop probability calculation   * This function is called over tupdate ms and takes pointer of FQ-PIE  * flow as an argument   */
end_comment

begin_function
unit|static
name|void
name|fq_calculate_drop_prob
parameter_list|(
name|void
modifier|*
name|x
parameter_list|)
block|{
name|struct
name|fq_pie_flow
modifier|*
name|q
init|=
operator|(
expr|struct
name|fq_pie_flow
operator|*
operator|)
name|x
decl_stmt|;
name|struct
name|pie_status
modifier|*
name|pst
init|=
operator|&
name|q
operator|->
name|pst
decl_stmt|;
name|struct
name|dn_aqm_pie_parms
modifier|*
name|pprms
decl_stmt|;
name|int64_t
name|p
decl_stmt|,
name|prob
decl_stmt|,
name|oldprob
decl_stmt|;
name|aqm_time_t
name|now
decl_stmt|;
name|now
operator|=
name|AQM_UNOW
expr_stmt|;
name|pprms
operator|=
name|pst
operator|->
name|parms
expr_stmt|;
name|prob
operator|=
name|pst
operator|->
name|drop_prob
expr_stmt|;
comment|/* calculate current qdelay */
if|if
condition|(
name|pprms
operator|->
name|flags
operator|&
name|PIE_DEPRATEEST_ENABLED
condition|)
block|{
name|pst
operator|->
name|current_qdelay
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|q
operator|->
name|stats
operator|.
name|len_bytes
operator|*
name|pst
operator|->
name|avg_dq_time
operator|)
operator|>>
name|PIE_DQ_THRESHOLD_BITS
expr_stmt|;
block|}
comment|/* calculate drop probability */
name|p
operator|=
operator|(
name|int64_t
operator|)
name|pprms
operator|->
name|alpha
operator|*
operator|(
operator|(
name|int64_t
operator|)
name|pst
operator|->
name|current_qdelay
operator|-
operator|(
name|int64_t
operator|)
name|pprms
operator|->
name|qdelay_ref
operator|)
expr_stmt|;
name|p
operator|+=
operator|(
name|int64_t
operator|)
name|pprms
operator|->
name|beta
operator|*
operator|(
operator|(
name|int64_t
operator|)
name|pst
operator|->
name|current_qdelay
operator|-
operator|(
name|int64_t
operator|)
name|pst
operator|->
name|qdelay_old
operator|)
expr_stmt|;
comment|/* We PIE_MAX_PROB shift by 12-bits to increase the division precision  */
name|p
operator|*=
operator|(
name|PIE_MAX_PROB
operator|<<
literal|12
operator|)
operator|/
name|AQM_TIME_1S
expr_stmt|;
comment|/* auto-tune drop probability */
if|if
condition|(
name|prob
operator|<
operator|(
name|PIE_MAX_PROB
operator|/
literal|1000000
operator|)
condition|)
comment|/* 0.000001 */
name|p
operator|>>=
literal|11
operator|+
name|PIE_FIX_POINT_BITS
operator|+
literal|12
expr_stmt|;
elseif|else
if|if
condition|(
name|prob
operator|<
operator|(
name|PIE_MAX_PROB
operator|/
literal|100000
operator|)
condition|)
comment|/* 0.00001 */
name|p
operator|>>=
literal|9
operator|+
name|PIE_FIX_POINT_BITS
operator|+
literal|12
expr_stmt|;
elseif|else
if|if
condition|(
name|prob
operator|<
operator|(
name|PIE_MAX_PROB
operator|/
literal|10000
operator|)
condition|)
comment|/* 0.0001 */
name|p
operator|>>=
literal|7
operator|+
name|PIE_FIX_POINT_BITS
operator|+
literal|12
expr_stmt|;
elseif|else
if|if
condition|(
name|prob
operator|<
operator|(
name|PIE_MAX_PROB
operator|/
literal|1000
operator|)
condition|)
comment|/* 0.001 */
name|p
operator|>>=
literal|5
operator|+
name|PIE_FIX_POINT_BITS
operator|+
literal|12
expr_stmt|;
elseif|else
if|if
condition|(
name|prob
operator|<
operator|(
name|PIE_MAX_PROB
operator|/
literal|100
operator|)
condition|)
comment|/* 0.01 */
name|p
operator|>>=
literal|3
operator|+
name|PIE_FIX_POINT_BITS
operator|+
literal|12
expr_stmt|;
elseif|else
if|if
condition|(
name|prob
operator|<
operator|(
name|PIE_MAX_PROB
operator|/
literal|10
operator|)
condition|)
comment|/* 0.1 */
name|p
operator|>>=
literal|1
operator|+
name|PIE_FIX_POINT_BITS
operator|+
literal|12
expr_stmt|;
else|else
name|p
operator|>>=
name|PIE_FIX_POINT_BITS
operator|+
literal|12
expr_stmt|;
name|oldprob
operator|=
name|prob
expr_stmt|;
comment|/* Cap Drop adjustment */
if|if
condition|(
operator|(
name|pprms
operator|->
name|flags
operator|&
name|PIE_CAPDROP_ENABLED
operator|)
operator|&&
name|prob
operator|>=
name|PIE_MAX_PROB
operator|/
literal|10
operator|&&
name|p
operator|>
name|PIE_MAX_PROB
operator|/
literal|50
condition|)
name|p
operator|=
name|PIE_MAX_PROB
operator|/
literal|50
expr_stmt|;
name|prob
operator|=
name|prob
operator|+
name|p
expr_stmt|;
comment|/* decay the drop probability exponentially */
if|if
condition|(
name|pst
operator|->
name|current_qdelay
operator|==
literal|0
operator|&&
name|pst
operator|->
name|qdelay_old
operator|==
literal|0
condition|)
comment|/* 0.98 ~= 1- 1/64 */
name|prob
operator|=
name|prob
operator|-
operator|(
name|prob
operator|>>
literal|6
operator|)
expr_stmt|;
comment|/* check for multiplication over/under flow */
if|if
condition|(
name|p
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|prob
operator|<
name|oldprob
condition|)
block|{
name|D
argument_list|(
literal|"overflow"
argument_list|)
expr_stmt|;
name|prob
operator|=
name|PIE_MAX_PROB
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|prob
operator|>
name|oldprob
condition|)
block|{
name|prob
operator|=
literal|0
expr_stmt|;
name|D
argument_list|(
literal|"underflow"
argument_list|)
expr_stmt|;
block|}
comment|/* make drop probability between 0 and PIE_MAX_PROB*/
if|if
condition|(
name|prob
operator|<
literal|0
condition|)
name|prob
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|prob
operator|>
name|PIE_MAX_PROB
condition|)
name|prob
operator|=
name|PIE_MAX_PROB
expr_stmt|;
name|pst
operator|->
name|drop_prob
operator|=
name|prob
expr_stmt|;
comment|/* store current delay value */
name|pst
operator|->
name|qdelay_old
operator|=
name|pst
operator|->
name|current_qdelay
expr_stmt|;
comment|/* update burst allowance */
if|if
condition|(
operator|(
name|pst
operator|->
name|sflags
operator|&
name|PIE_ACTIVE
operator|)
operator|&&
name|pst
operator|->
name|burst_allowance
condition|)
block|{
if|if
condition|(
name|pst
operator|->
name|burst_allowance
operator|>
name|pprms
operator|->
name|tupdate
condition|)
name|pst
operator|->
name|burst_allowance
operator|-=
name|pprms
operator|->
name|tupdate
expr_stmt|;
else|else
name|pst
operator|->
name|burst_allowance
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pst
operator|->
name|sflags
operator|&
name|PIE_ACTIVE
condition|)
name|callout_reset_sbt
argument_list|(
operator|&
name|pst
operator|->
name|aqm_pie_callout
argument_list|,
operator|(
name|uint64_t
operator|)
name|pprms
operator|->
name|tupdate
operator|*
name|SBT_1US
argument_list|,
literal|0
argument_list|,
name|fq_calculate_drop_prob
argument_list|,
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pst
operator|->
name|lock_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Reset PIE variables& activate the queue  */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|fq_activate_pie
parameter_list|(
name|struct
name|fq_pie_flow
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|pie_status
modifier|*
name|pst
init|=
operator|&
name|q
operator|->
name|pst
decl_stmt|;
name|struct
name|dn_aqm_pie_parms
modifier|*
name|pprms
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pst
operator|->
name|lock_mtx
argument_list|)
expr_stmt|;
name|pprms
operator|=
name|pst
operator|->
name|parms
expr_stmt|;
name|pprms
operator|=
name|pst
operator|->
name|parms
expr_stmt|;
name|pst
operator|->
name|drop_prob
operator|=
literal|0
expr_stmt|;
name|pst
operator|->
name|qdelay_old
operator|=
literal|0
expr_stmt|;
name|pst
operator|->
name|burst_allowance
operator|=
name|pprms
operator|->
name|max_burst
expr_stmt|;
name|pst
operator|->
name|accu_prob
operator|=
literal|0
expr_stmt|;
name|pst
operator|->
name|dq_count
operator|=
literal|0
expr_stmt|;
name|pst
operator|->
name|avg_dq_time
operator|=
literal|0
expr_stmt|;
name|pst
operator|->
name|sflags
operator|=
name|PIE_INMEASUREMENT
operator||
name|PIE_ACTIVE
expr_stmt|;
name|pst
operator|->
name|measurement_start
operator|=
name|AQM_UNOW
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|pst
operator|->
name|aqm_pie_callout
argument_list|,
operator|(
name|uint64_t
operator|)
name|pprms
operator|->
name|tupdate
operator|*
name|SBT_1US
argument_list|,
literal|0
argument_list|,
name|fq_calculate_drop_prob
argument_list|,
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pst
operator|->
name|lock_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    * Deactivate PIE and stop probe update callout   */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|fq_deactivate_pie
parameter_list|(
name|struct
name|pie_status
modifier|*
name|pst
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pst
operator|->
name|lock_mtx
argument_list|)
expr_stmt|;
name|pst
operator|->
name|sflags
operator|&=
operator|~
operator|(
name|PIE_ACTIVE
operator||
name|PIE_INMEASUREMENT
operator|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|pst
operator|->
name|aqm_pie_callout
argument_list|)
expr_stmt|;
comment|//D("PIE Deactivated");
name|mtx_unlock
argument_list|(
operator|&
name|pst
operator|->
name|lock_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    * Initialize PIE for sub-queue 'q'   */
end_comment

begin_function
specifier|static
name|int
name|pie_init
parameter_list|(
name|struct
name|fq_pie_flow
modifier|*
name|q
parameter_list|,
name|struct
name|fq_pie_schk
modifier|*
name|fqpie_schk
parameter_list|)
block|{
name|struct
name|pie_status
modifier|*
name|pst
init|=
operator|&
name|q
operator|->
name|pst
decl_stmt|;
name|struct
name|dn_aqm_pie_parms
modifier|*
name|pprms
init|=
name|pst
operator|->
name|parms
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|pprms
condition|)
block|{
name|D
argument_list|(
literal|"AQM_PIE is not configured"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|psi_extra
operator|->
name|nr_active_q
operator|++
expr_stmt|;
comment|/* For speed optimization, we caculate 1/3 queue size once here */
comment|// XXX limit divided by number of queues divided by 3 ???
name|pst
operator|->
name|one_third_q_size
operator|=
operator|(
name|fqpie_schk
operator|->
name|cfg
operator|.
name|limit
operator|/
name|fqpie_schk
operator|->
name|cfg
operator|.
name|flows_cnt
operator|)
operator|/
literal|3
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pst
operator|->
name|lock_mtx
argument_list|,
literal|"mtx_pie"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|pst
operator|->
name|aqm_pie_callout
argument_list|,
operator|&
name|pst
operator|->
name|lock_mtx
argument_list|,
name|CALLOUT_RETURNUNLOCKED
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*   * callout function to destroy PIE lock, and free fq_pie flows and fq_pie si  * extra memory when number of active sub-queues reaches zero.  * 'x' is a fq_pie_flow to be destroyed  */
end_comment

begin_function
specifier|static
name|void
name|fqpie_callout_cleanup
parameter_list|(
name|void
modifier|*
name|x
parameter_list|)
block|{
name|struct
name|fq_pie_flow
modifier|*
name|q
init|=
name|x
decl_stmt|;
name|struct
name|pie_status
modifier|*
name|pst
init|=
operator|&
name|q
operator|->
name|pst
decl_stmt|;
name|struct
name|fq_pie_si_extra
modifier|*
name|psi_extra
decl_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pst
operator|->
name|lock_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pst
operator|->
name|lock_mtx
argument_list|)
expr_stmt|;
name|psi_extra
operator|=
name|q
operator|->
name|psi_extra
expr_stmt|;
name|DN_BH_WLOCK
argument_list|()
expr_stmt|;
name|psi_extra
operator|->
name|nr_active_q
operator|--
expr_stmt|;
comment|/* when all sub-queues are destroyed, free flows fq_pie extra vars memory */
if|if
condition|(
operator|!
name|psi_extra
operator|->
name|nr_active_q
condition|)
block|{
name|free
argument_list|(
name|psi_extra
operator|->
name|flows
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|psi_extra
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
name|fq_pie_desc
operator|.
name|ref_count
operator|--
expr_stmt|;
block|}
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Clean up PIE status for sub-queue 'q'   * Stop callout timer and destroy mtx using fqpie_callout_cleanup() callout.  */
end_comment

begin_function
specifier|static
name|int
name|pie_cleanup
parameter_list|(
name|struct
name|fq_pie_flow
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|pie_status
modifier|*
name|pst
init|=
operator|&
name|q
operator|->
name|pst
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pst
operator|->
name|lock_mtx
argument_list|)
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|pst
operator|->
name|aqm_pie_callout
argument_list|,
name|SBT_1US
argument_list|,
literal|0
argument_list|,
name|fqpie_callout_cleanup
argument_list|,
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pst
operator|->
name|lock_mtx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * Dequeue and return a pcaket from sub-queue 'q' or NULL if 'q' is empty.  * Also, caculate depature time or queue delay using timestamp  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|pie_dequeue
parameter_list|(
name|struct
name|fq_pie_flow
modifier|*
name|q
parameter_list|,
name|struct
name|fq_pie_si
modifier|*
name|si
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|dn_aqm_pie_parms
modifier|*
name|pprms
decl_stmt|;
name|struct
name|pie_status
modifier|*
name|pst
decl_stmt|;
name|aqm_time_t
name|now
decl_stmt|;
name|aqm_time_t
name|pkt_ts
decl_stmt|,
name|dq_time
decl_stmt|;
name|int32_t
name|w
decl_stmt|;
name|pst
operator|=
operator|&
name|q
operator|->
name|pst
expr_stmt|;
name|pprms
operator|=
name|q
operator|->
name|pst
operator|.
name|parms
expr_stmt|;
comment|/*we extarct packet ts only when Departure Rate Estimation dis not used*/
name|m
operator|=
name|fq_pie_extract_head
argument_list|(
name|q
argument_list|,
operator|&
name|pkt_ts
argument_list|,
name|si
argument_list|,
operator|!
operator|(
name|pprms
operator|->
name|flags
operator|&
name|PIE_DEPRATEEST_ENABLED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
operator|!
operator|(
name|pst
operator|->
name|sflags
operator|&
name|PIE_ACTIVE
operator|)
condition|)
return|return
name|m
return|;
name|now
operator|=
name|AQM_UNOW
expr_stmt|;
if|if
condition|(
name|pprms
operator|->
name|flags
operator|&
name|PIE_DEPRATEEST_ENABLED
condition|)
block|{
comment|/* calculate average depature time */
if|if
condition|(
name|pst
operator|->
name|sflags
operator|&
name|PIE_INMEASUREMENT
condition|)
block|{
name|pst
operator|->
name|dq_count
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|pst
operator|->
name|dq_count
operator|>=
name|PIE_DQ_THRESHOLD
condition|)
block|{
name|dq_time
operator|=
name|now
operator|-
name|pst
operator|->
name|measurement_start
expr_stmt|;
comment|/*  				 * if we don't have old avg dq_time i.e PIE is (re)initialized,  				 * don't use weight to calculate new avg_dq_time 				 */
if|if
condition|(
name|pst
operator|->
name|avg_dq_time
operator|==
literal|0
condition|)
name|pst
operator|->
name|avg_dq_time
operator|=
name|dq_time
expr_stmt|;
else|else
block|{
comment|/*  					 * weight = PIE_DQ_THRESHOLD/2^6, but we scaled  					 * weight by 2^8. Thus, scaled  					 * weight = PIE_DQ_THRESHOLD /2^8  					 * */
name|w
operator|=
name|PIE_DQ_THRESHOLD
operator|>>
literal|8
expr_stmt|;
name|pst
operator|->
name|avg_dq_time
operator|=
operator|(
name|dq_time
operator|*
name|w
operator|+
operator|(
name|pst
operator|->
name|avg_dq_time
operator|*
operator|(
operator|(
literal|1L
operator|<<
literal|8
operator|)
operator|-
name|w
operator|)
operator|)
operator|)
operator|>>
literal|8
expr_stmt|;
name|pst
operator|->
name|sflags
operator|&=
operator|~
name|PIE_INMEASUREMENT
expr_stmt|;
block|}
block|}
block|}
comment|/*  		 * Start new measurment cycle when the queue has 		 *  PIE_DQ_THRESHOLD worth of bytes. 		 */
if|if
condition|(
operator|!
operator|(
name|pst
operator|->
name|sflags
operator|&
name|PIE_INMEASUREMENT
operator|)
operator|&&
name|q
operator|->
name|stats
operator|.
name|len_bytes
operator|>=
name|PIE_DQ_THRESHOLD
condition|)
block|{
name|pst
operator|->
name|sflags
operator||=
name|PIE_INMEASUREMENT
expr_stmt|;
name|pst
operator|->
name|measurement_start
operator|=
name|now
expr_stmt|;
name|pst
operator|->
name|dq_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Optionally, use packet timestamp to estimate queue delay */
else|else
name|pst
operator|->
name|current_qdelay
operator|=
name|now
operator|-
name|pkt_ts
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Enqueue a packet in q, subject to space and FQ-PIE queue management policy  * (whose parameters are in q->fs).  * Update stats for the queue and the scheduler.  * Return 0 on success, 1 on drop. The packet is consumed anyways.  */
end_comment

begin_function
specifier|static
name|int
name|pie_enqueue
parameter_list|(
name|struct
name|fq_pie_flow
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|fq_pie_si
modifier|*
name|si
parameter_list|)
block|{
name|uint64_t
name|len
decl_stmt|;
name|struct
name|pie_status
modifier|*
name|pst
decl_stmt|;
name|struct
name|dn_aqm_pie_parms
modifier|*
name|pprms
decl_stmt|;
name|int
name|t
decl_stmt|;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|pst
operator|=
operator|&
name|q
operator|->
name|pst
expr_stmt|;
name|pprms
operator|=
name|pst
operator|->
name|parms
expr_stmt|;
name|t
operator|=
name|ENQUE
expr_stmt|;
comment|/* drop/mark the packet when PIE is active and burst time elapsed */
if|if
condition|(
name|pst
operator|->
name|sflags
operator|&
name|PIE_ACTIVE
operator|&&
name|pst
operator|->
name|burst_allowance
operator|==
literal|0
operator|&&
name|drop_early
argument_list|(
name|pst
argument_list|,
name|q
operator|->
name|stats
operator|.
name|len_bytes
argument_list|)
operator|==
name|DROP
condition|)
block|{
comment|/*  			 * if drop_prob over ECN threshold, drop the packet  			 * otherwise mark and enqueue it. 			 */
if|if
condition|(
name|pprms
operator|->
name|flags
operator|&
name|PIE_ECN_ENABLED
operator|&&
name|pst
operator|->
name|drop_prob
operator|<
operator|(
name|pprms
operator|->
name|max_ecnth
operator|<<
operator|(
name|PIE_PROB_BITS
operator|-
name|PIE_FIX_POINT_BITS
operator|)
operator|)
operator|&&
name|ecn_mark
argument_list|(
name|m
argument_list|)
condition|)
name|t
operator|=
name|ENQUE
expr_stmt|;
else|else
name|t
operator|=
name|DROP
expr_stmt|;
block|}
comment|/* Turn PIE on when 1/3 of the queue is full */
if|if
condition|(
operator|!
operator|(
name|pst
operator|->
name|sflags
operator|&
name|PIE_ACTIVE
operator|)
operator|&&
name|q
operator|->
name|stats
operator|.
name|len_bytes
operator|>=
name|pst
operator|->
name|one_third_q_size
condition|)
block|{
name|fq_activate_pie
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
comment|/*  reset burst tolerance and optinally turn PIE off*/
if|if
condition|(
name|pst
operator|->
name|drop_prob
operator|==
literal|0
operator|&&
name|pst
operator|->
name|current_qdelay
operator|<
operator|(
name|pprms
operator|->
name|qdelay_ref
operator|>>
literal|1
operator|)
operator|&&
name|pst
operator|->
name|qdelay_old
operator|<
operator|(
name|pprms
operator|->
name|qdelay_ref
operator|>>
literal|1
operator|)
condition|)
block|{
name|pst
operator|->
name|burst_allowance
operator|=
name|pprms
operator|->
name|max_burst
expr_stmt|;
if|if
condition|(
name|pprms
operator|->
name|flags
operator|&
name|PIE_ON_OFF_MODE_ENABLED
operator|&&
name|q
operator|->
name|stats
operator|.
name|len_bytes
operator|<=
literal|0
condition|)
name|fq_deactivate_pie
argument_list|(
name|pst
argument_list|)
expr_stmt|;
block|}
comment|/* Use timestamp if Departure Rate Estimation mode is disabled */
if|if
condition|(
name|t
operator|!=
name|DROP
operator|&&
operator|!
operator|(
name|pprms
operator|->
name|flags
operator|&
name|PIE_DEPRATEEST_ENABLED
operator|)
condition|)
block|{
comment|/* Add TS to mbuf as a TAG */
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|mtag
operator|=
name|m_tag_locate
argument_list|(
name|m
argument_list|,
name|MTAG_ABI_COMPAT
argument_list|,
name|DN_AQM_MTAG_TS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
name|mtag
operator|=
name|m_tag_alloc
argument_list|(
name|MTAG_ABI_COMPAT
argument_list|,
name|DN_AQM_MTAG_TS
argument_list|,
sizeof|sizeof
argument_list|(
name|aqm_time_t
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|t
operator|=
name|DROP
expr_stmt|;
block|}
operator|*
operator|(
name|aqm_time_t
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
operator|=
name|AQM_UNOW
expr_stmt|;
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
name|DROP
condition|)
block|{
name|mq_append
argument_list|(
operator|&
name|q
operator|->
name|mq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|fq_update_stats
argument_list|(
name|q
argument_list|,
name|si
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|fq_update_stats
argument_list|(
name|q
argument_list|,
name|si
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pst
operator|->
name|accu_prob
operator|=
literal|0
expr_stmt|;
name|FREE_PKT
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Drop a packet form the head of FQ-PIE sub-queue */
end_comment

begin_function
specifier|static
name|void
name|pie_drop_head
parameter_list|(
name|struct
name|fq_pie_flow
modifier|*
name|q
parameter_list|,
name|struct
name|fq_pie_si
modifier|*
name|si
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|q
operator|->
name|mq
operator|.
name|head
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|q
operator|->
name|mq
operator|.
name|head
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|fq_update_stats
argument_list|(
name|q
argument_list|,
name|si
argument_list|,
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|main_q
operator|.
name|ni
operator|.
name|length
operator|==
literal|0
condition|)
comment|/* queue is now idle */
name|si
operator|->
name|main_q
operator|.
name|q_time
operator|=
name|dn_cfg
operator|.
name|curr_time
expr_stmt|;
comment|/* reset accu_prob after packet drop */
name|q
operator|->
name|pst
operator|.
name|accu_prob
operator|=
literal|0
expr_stmt|;
name|FREE_PKT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Classify a packet to queue number using Jenkins hash function.  * Return: queue number   * the input of the hash are protocol no, perturbation, src IP, dst IP,  * src port, dst port,  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|fq_pie_classify_flow
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint16_t
name|fcount
parameter_list|,
name|struct
name|fq_pie_si
modifier|*
name|si
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
decl_stmt|;
name|uint8_t
name|tuple
index|[
literal|41
index|]
decl_stmt|;
name|uint16_t
name|hash
init|=
literal|0
decl_stmt|;
comment|//#ifdef INET6
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|int
name|isip6
decl_stmt|;
name|isip6
operator|=
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|->
name|ip_v
operator|==
literal|6
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|isip6
condition|)
block|{
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tuple
index|[
literal|0
index|]
operator|)
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|tuple
index|[
literal|1
index|]
operator|)
operator|=
name|si
operator|->
name|perturbation
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tuple
index|[
literal|5
index|]
argument_list|,
name|ip6
operator|->
name|ip6_src
operator|.
name|s6_addr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tuple
index|[
literal|21
index|]
argument_list|,
name|ip6
operator|->
name|ip6_dst
operator|.
name|s6_addr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ip6
operator|->
name|ip6_nxt
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|ip6
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|tuple
index|[
literal|37
index|]
operator|)
operator|=
name|th
operator|->
name|th_dport
expr_stmt|;
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|tuple
index|[
literal|39
index|]
operator|)
operator|=
name|th
operator|->
name|th_sport
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
name|ip6
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|tuple
index|[
literal|37
index|]
operator|)
operator|=
name|uh
operator|->
name|uh_dport
expr_stmt|;
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|tuple
index|[
literal|39
index|]
operator|)
operator|=
name|uh
operator|->
name|uh_sport
expr_stmt|;
break|break;
default|default:
name|memset
argument_list|(
operator|&
name|tuple
index|[
literal|37
index|]
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|hash
operator|=
name|jenkins_hash
argument_list|(
name|tuple
argument_list|,
literal|41
argument_list|,
name|HASHINIT
argument_list|)
operator|%
name|fcount
expr_stmt|;
return|return
name|hash
return|;
block|}
comment|//#endif
comment|/* IPv4 */
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tuple
index|[
literal|0
index|]
operator|)
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|tuple
index|[
literal|1
index|]
operator|)
operator|=
name|si
operator|->
name|perturbation
expr_stmt|;
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|tuple
index|[
literal|5
index|]
operator|)
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|tuple
index|[
literal|9
index|]
operator|)
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|tuple
index|[
literal|13
index|]
operator|)
operator|=
name|th
operator|->
name|th_dport
expr_stmt|;
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|tuple
index|[
literal|15
index|]
operator|)
operator|=
name|th
operator|->
name|th_sport
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|tuple
index|[
literal|13
index|]
operator|)
operator|=
name|uh
operator|->
name|uh_dport
expr_stmt|;
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|tuple
index|[
literal|15
index|]
operator|)
operator|=
name|uh
operator|->
name|uh_sport
expr_stmt|;
break|break;
default|default:
name|memset
argument_list|(
operator|&
name|tuple
index|[
literal|13
index|]
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|hash
operator|=
name|jenkins_hash
argument_list|(
name|tuple
argument_list|,
literal|17
argument_list|,
name|HASHINIT
argument_list|)
operator|%
name|fcount
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/*  * Enqueue a packet into an appropriate queue according to  * FQ-CoDe; algorithm.  */
end_comment

begin_function
specifier|static
name|int
name|fq_pie_enqueue
parameter_list|(
name|struct
name|dn_sch_inst
modifier|*
name|_si
parameter_list|,
name|struct
name|dn_queue
modifier|*
name|_q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|fq_pie_si
modifier|*
name|si
decl_stmt|;
name|struct
name|fq_pie_schk
modifier|*
name|schk
decl_stmt|;
name|struct
name|dn_sch_fq_pie_parms
modifier|*
name|param
decl_stmt|;
name|struct
name|dn_queue
modifier|*
name|mainq
decl_stmt|;
name|struct
name|fq_pie_flow
modifier|*
name|flows
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|drop
decl_stmt|,
name|i
decl_stmt|,
name|maxidx
decl_stmt|;
name|mainq
operator|=
operator|(
expr|struct
name|dn_queue
operator|*
operator|)
operator|(
name|_si
operator|+
literal|1
operator|)
expr_stmt|;
name|si
operator|=
operator|(
expr|struct
name|fq_pie_si
operator|*
operator|)
name|_si
expr_stmt|;
name|flows
operator|=
name|si
operator|->
name|si_extra
operator|->
name|flows
expr_stmt|;
name|schk
operator|=
operator|(
expr|struct
name|fq_pie_schk
operator|*
operator|)
operator|(
name|si
operator|->
name|_si
operator|.
name|sched
operator|+
literal|1
operator|)
expr_stmt|;
name|param
operator|=
operator|&
name|schk
operator|->
name|cfg
expr_stmt|;
comment|/* classify a packet to queue number*/
name|idx
operator|=
name|fq_pie_classify_flow
argument_list|(
name|m
argument_list|,
name|param
operator|->
name|flows_cnt
argument_list|,
name|si
argument_list|)
expr_stmt|;
comment|/* enqueue packet into appropriate queue using PIE AQM. 	 * Note: 'pie_enqueue' function returns 1 only when it unable to  	 * add timestamp to packet (no limit check)*/
name|drop
operator|=
name|pie_enqueue
argument_list|(
operator|&
name|flows
index|[
name|idx
index|]
argument_list|,
name|m
argument_list|,
name|si
argument_list|)
expr_stmt|;
comment|/* pie unable to timestamp a packet */
if|if
condition|(
name|drop
condition|)
return|return
literal|1
return|;
comment|/* If the flow (sub-queue) is not active ,then add it to tail of 	 * new flows list, initialize and activate it. 	 */
if|if
condition|(
operator|!
name|flows
index|[
name|idx
index|]
operator|.
name|active
condition|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|si
operator|->
name|newflows
argument_list|,
operator|&
name|flows
index|[
name|idx
index|]
argument_list|,
name|flowchain
argument_list|)
expr_stmt|;
name|flows
index|[
name|idx
index|]
operator|.
name|deficit
operator|=
name|param
operator|->
name|quantum
expr_stmt|;
name|fq_activate_pie
argument_list|(
operator|&
name|flows
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|flows
index|[
name|idx
index|]
operator|.
name|active
operator|=
literal|1
expr_stmt|;
block|}
comment|/* check the limit for all queues and remove a packet from the 	 * largest one  	 */
if|if
condition|(
name|mainq
operator|->
name|ni
operator|.
name|length
operator|>
name|schk
operator|->
name|cfg
operator|.
name|limit
condition|)
block|{
comment|/* find first active flow */
for|for
control|(
name|maxidx
operator|=
literal|0
init|;
name|maxidx
operator|<
name|schk
operator|->
name|cfg
operator|.
name|flows_cnt
condition|;
name|maxidx
operator|++
control|)
if|if
condition|(
name|flows
index|[
name|maxidx
index|]
operator|.
name|active
condition|)
break|break;
if|if
condition|(
name|maxidx
operator|<
name|schk
operator|->
name|cfg
operator|.
name|flows_cnt
condition|)
block|{
comment|/* find the largest sub- queue */
for|for
control|(
name|i
operator|=
name|maxidx
operator|+
literal|1
init|;
name|i
operator|<
name|schk
operator|->
name|cfg
operator|.
name|flows_cnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|flows
index|[
name|i
index|]
operator|.
name|active
operator|&&
name|flows
index|[
name|i
index|]
operator|.
name|stats
operator|.
name|length
operator|>
name|flows
index|[
name|maxidx
index|]
operator|.
name|stats
operator|.
name|length
condition|)
name|maxidx
operator|=
name|i
expr_stmt|;
name|pie_drop_head
argument_list|(
operator|&
name|flows
index|[
name|maxidx
index|]
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|drop
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|drop
return|;
block|}
end_function

begin_comment
comment|/*  * Dequeue a packet from an appropriate queue according to  * FQ-CoDel algorithm.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|fq_pie_dequeue
parameter_list|(
name|struct
name|dn_sch_inst
modifier|*
name|_si
parameter_list|)
block|{
name|struct
name|fq_pie_si
modifier|*
name|si
decl_stmt|;
name|struct
name|fq_pie_schk
modifier|*
name|schk
decl_stmt|;
name|struct
name|dn_sch_fq_pie_parms
modifier|*
name|param
decl_stmt|;
name|struct
name|fq_pie_flow
modifier|*
name|f
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|struct
name|fq_pie_list
modifier|*
name|fq_pie_flowlist
decl_stmt|;
name|si
operator|=
operator|(
expr|struct
name|fq_pie_si
operator|*
operator|)
name|_si
expr_stmt|;
name|schk
operator|=
operator|(
expr|struct
name|fq_pie_schk
operator|*
operator|)
operator|(
name|si
operator|->
name|_si
operator|.
name|sched
operator|+
literal|1
operator|)
expr_stmt|;
name|param
operator|=
operator|&
name|schk
operator|->
name|cfg
expr_stmt|;
do|do
block|{
comment|/* select a list to start with */
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|si
operator|->
name|newflows
argument_list|)
condition|)
name|fq_pie_flowlist
operator|=
operator|&
name|si
operator|->
name|oldflows
expr_stmt|;
else|else
name|fq_pie_flowlist
operator|=
operator|&
name|si
operator|->
name|newflows
expr_stmt|;
comment|/* Both new and old queue lists are empty, return NULL */
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
name|fq_pie_flowlist
argument_list|)
condition|)
return|return
name|NULL
return|;
name|f
operator|=
name|STAILQ_FIRST
argument_list|(
name|fq_pie_flowlist
argument_list|)
expr_stmt|;
while|while
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
comment|/* if there is no flow(sub-queue) deficit, increase deficit 			 * by quantum, move the flow to the tail of old flows list 			 * and try another flow. 			 * Otherwise, the flow will be used for dequeue. 			 */
if|if
condition|(
name|f
operator|->
name|deficit
operator|<
literal|0
condition|)
block|{
name|f
operator|->
name|deficit
operator|+=
name|param
operator|->
name|quantum
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
name|fq_pie_flowlist
argument_list|,
name|flowchain
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|si
operator|->
name|oldflows
argument_list|,
name|f
argument_list|,
name|flowchain
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
name|f
operator|=
name|STAILQ_FIRST
argument_list|(
name|fq_pie_flowlist
argument_list|)
expr_stmt|;
block|}
comment|/* the new flows list is empty, try old flows list */
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
name|fq_pie_flowlist
argument_list|)
condition|)
continue|continue;
comment|/* Dequeue a packet from the selected flow */
name|mbuf
operator|=
name|pie_dequeue
argument_list|(
name|f
argument_list|,
name|si
argument_list|)
expr_stmt|;
comment|/* pie did not return a packet */
if|if
condition|(
operator|!
name|mbuf
condition|)
block|{
comment|/* If the selected flow belongs to new flows list, then move  			 * it to the tail of old flows list. Otherwise, deactivate it and 			 * remove it from the old list and 			 */
if|if
condition|(
name|fq_pie_flowlist
operator|==
operator|&
name|si
operator|->
name|newflows
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
name|fq_pie_flowlist
argument_list|,
name|flowchain
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|si
operator|->
name|oldflows
argument_list|,
name|f
argument_list|,
name|flowchain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|fq_deactivate_pie
argument_list|(
operator|&
name|f
operator|->
name|pst
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
name|fq_pie_flowlist
argument_list|,
name|flowchain
argument_list|)
expr_stmt|;
block|}
comment|/* start again */
continue|continue;
block|}
comment|/* we have a packet to return,  		 * update flow deficit and return the packet*/
name|f
operator|->
name|deficit
operator|-=
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
return|return
name|mbuf
return|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/* unreachable point */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize fq_pie scheduler instance.  * also, allocate memory for flows array.  */
end_comment

begin_function
specifier|static
name|int
name|fq_pie_new_sched
parameter_list|(
name|struct
name|dn_sch_inst
modifier|*
name|_si
parameter_list|)
block|{
name|struct
name|fq_pie_si
modifier|*
name|si
decl_stmt|;
name|struct
name|dn_queue
modifier|*
name|q
decl_stmt|;
name|struct
name|fq_pie_schk
modifier|*
name|schk
decl_stmt|;
name|struct
name|fq_pie_flow
modifier|*
name|flows
decl_stmt|;
name|int
name|i
decl_stmt|;
name|si
operator|=
operator|(
expr|struct
name|fq_pie_si
operator|*
operator|)
name|_si
expr_stmt|;
name|schk
operator|=
operator|(
expr|struct
name|fq_pie_schk
operator|*
operator|)
operator|(
name|_si
operator|->
name|sched
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_extra
condition|)
block|{
name|D
argument_list|(
literal|"si already configured!"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* init the main queue */
name|q
operator|=
operator|&
name|si
operator|->
name|main_q
expr_stmt|;
name|set_oid
argument_list|(
operator|&
name|q
operator|->
name|ni
operator|.
name|oid
argument_list|,
name|DN_QUEUE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|_si
operator|=
name|_si
expr_stmt|;
name|q
operator|->
name|fs
operator|=
name|_si
operator|->
name|sched
operator|->
name|fs
expr_stmt|;
comment|/* allocate memory for scheduler instance extra vars */
name|si
operator|->
name|si_extra
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fq_pie_si_extra
argument_list|)
argument_list|,
name|M_DUMMYNET
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_extra
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"cannot allocate memory for fq_pie si extra vars"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* allocate memory for flows array */
name|si
operator|->
name|si_extra
operator|->
name|flows
operator|=
name|malloc
argument_list|(
name|schk
operator|->
name|cfg
operator|.
name|flows_cnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fq_pie_flow
argument_list|)
argument_list|,
name|M_DUMMYNET
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|flows
operator|=
name|si
operator|->
name|si_extra
operator|->
name|flows
expr_stmt|;
if|if
condition|(
name|flows
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|si
operator|->
name|si_extra
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_extra
operator|=
name|NULL
expr_stmt|;
name|D
argument_list|(
literal|"cannot allocate memory for fq_pie flows"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* init perturbation for this si */
name|si
operator|->
name|perturbation
operator|=
name|random
argument_list|()
expr_stmt|;
name|si
operator|->
name|si_extra
operator|->
name|nr_active_q
operator|=
literal|0
expr_stmt|;
comment|/* init the old and new flows lists */
name|STAILQ_INIT
argument_list|(
operator|&
name|si
operator|->
name|newflows
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|si
operator|->
name|oldflows
argument_list|)
expr_stmt|;
comment|/* init the flows (sub-queues) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|schk
operator|->
name|cfg
operator|.
name|flows_cnt
condition|;
name|i
operator|++
control|)
block|{
name|flows
index|[
name|i
index|]
operator|.
name|pst
operator|.
name|parms
operator|=
operator|&
name|schk
operator|->
name|cfg
operator|.
name|pcfg
expr_stmt|;
name|flows
index|[
name|i
index|]
operator|.
name|psi_extra
operator|=
name|si
operator|->
name|si_extra
expr_stmt|;
name|pie_init
argument_list|(
operator|&
name|flows
index|[
name|i
index|]
argument_list|,
name|schk
argument_list|)
expr_stmt|;
block|}
name|fq_pie_desc
operator|.
name|ref_count
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Free fq_pie scheduler instance.  */
end_comment

begin_function
specifier|static
name|int
name|fq_pie_free_sched
parameter_list|(
name|struct
name|dn_sch_inst
modifier|*
name|_si
parameter_list|)
block|{
name|struct
name|fq_pie_si
modifier|*
name|si
decl_stmt|;
name|struct
name|fq_pie_schk
modifier|*
name|schk
decl_stmt|;
name|struct
name|fq_pie_flow
modifier|*
name|flows
decl_stmt|;
name|int
name|i
decl_stmt|;
name|si
operator|=
operator|(
expr|struct
name|fq_pie_si
operator|*
operator|)
name|_si
expr_stmt|;
name|schk
operator|=
operator|(
expr|struct
name|fq_pie_schk
operator|*
operator|)
operator|(
name|_si
operator|->
name|sched
operator|+
literal|1
operator|)
expr_stmt|;
name|flows
operator|=
name|si
operator|->
name|si_extra
operator|->
name|flows
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|schk
operator|->
name|cfg
operator|.
name|flows_cnt
condition|;
name|i
operator|++
control|)
block|{
name|pie_cleanup
argument_list|(
operator|&
name|flows
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|si
operator|->
name|si_extra
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Configure FQ-PIE scheduler.  * the configurations for the scheduler is passed fromipfw  userland.  */
end_comment

begin_function
specifier|static
name|int
name|fq_pie_config
parameter_list|(
name|struct
name|dn_schk
modifier|*
name|_schk
parameter_list|)
block|{
name|struct
name|fq_pie_schk
modifier|*
name|schk
decl_stmt|;
name|struct
name|dn_extra_parms
modifier|*
name|ep
decl_stmt|;
name|struct
name|dn_sch_fq_pie_parms
modifier|*
name|fqp_cfg
decl_stmt|;
name|schk
operator|=
operator|(
expr|struct
name|fq_pie_schk
operator|*
operator|)
operator|(
name|_schk
operator|+
literal|1
operator|)
expr_stmt|;
name|ep
operator|=
operator|(
expr|struct
name|dn_extra_parms
operator|*
operator|)
name|_schk
operator|->
name|cfg
expr_stmt|;
comment|/* par array contains fq_pie configuration as follow 	 * PIE: 0- qdelay_ref,1- tupdate, 2- max_burst 	 * 3- max_ecnth, 4- alpha, 5- beta, 6- flags 	 * FQ_PIE: 7- quantum, 8- limit, 9- flows 	 */
if|if
condition|(
name|ep
operator|&&
name|ep
operator|->
name|oid
operator|.
name|len
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|&&
name|ep
operator|->
name|oid
operator|.
name|subtype
operator|==
name|DN_SCH_PARAMS
condition|)
block|{
name|fqp_cfg
operator|=
operator|&
name|schk
operator|->
name|cfg
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|par
index|[
literal|0
index|]
operator|<
literal|0
condition|)
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|qdelay_ref
operator|=
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|qdelay_ref
expr_stmt|;
else|else
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|qdelay_ref
operator|=
name|ep
operator|->
name|par
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|par
index|[
literal|1
index|]
operator|<
literal|0
condition|)
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|tupdate
operator|=
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|tupdate
expr_stmt|;
else|else
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|tupdate
operator|=
name|ep
operator|->
name|par
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|par
index|[
literal|2
index|]
operator|<
literal|0
condition|)
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|max_burst
operator|=
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|max_burst
expr_stmt|;
else|else
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|max_burst
operator|=
name|ep
operator|->
name|par
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|par
index|[
literal|3
index|]
operator|<
literal|0
condition|)
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|max_ecnth
operator|=
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|max_ecnth
expr_stmt|;
else|else
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|max_ecnth
operator|=
name|ep
operator|->
name|par
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|par
index|[
literal|4
index|]
operator|<
literal|0
condition|)
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|alpha
operator|=
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|alpha
expr_stmt|;
else|else
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|alpha
operator|=
name|ep
operator|->
name|par
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|par
index|[
literal|5
index|]
operator|<
literal|0
condition|)
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|beta
operator|=
name|fq_pie_sysctl
operator|.
name|pcfg
operator|.
name|beta
expr_stmt|;
else|else
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|beta
operator|=
name|ep
operator|->
name|par
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|par
index|[
literal|6
index|]
operator|<
literal|0
condition|)
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|flags
operator|=
name|ep
operator|->
name|par
index|[
literal|6
index|]
expr_stmt|;
comment|/* FQ configurations */
if|if
condition|(
name|ep
operator|->
name|par
index|[
literal|7
index|]
operator|<
literal|0
condition|)
name|fqp_cfg
operator|->
name|quantum
operator|=
name|fq_pie_sysctl
operator|.
name|quantum
expr_stmt|;
else|else
name|fqp_cfg
operator|->
name|quantum
operator|=
name|ep
operator|->
name|par
index|[
literal|7
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|par
index|[
literal|8
index|]
operator|<
literal|0
condition|)
name|fqp_cfg
operator|->
name|limit
operator|=
name|fq_pie_sysctl
operator|.
name|limit
expr_stmt|;
else|else
name|fqp_cfg
operator|->
name|limit
operator|=
name|ep
operator|->
name|par
index|[
literal|8
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|par
index|[
literal|9
index|]
operator|<
literal|0
condition|)
name|fqp_cfg
operator|->
name|flows_cnt
operator|=
name|fq_pie_sysctl
operator|.
name|flows_cnt
expr_stmt|;
else|else
name|fqp_cfg
operator|->
name|flows_cnt
operator|=
name|ep
operator|->
name|par
index|[
literal|9
index|]
expr_stmt|;
comment|/* Bound the configurations */
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|qdelay_ref
operator|=
name|BOUND_VAR
argument_list|(
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|qdelay_ref
argument_list|,
literal|1
argument_list|,
literal|5
operator|*
name|AQM_TIME_1S
argument_list|)
expr_stmt|;
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|tupdate
operator|=
name|BOUND_VAR
argument_list|(
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|tupdate
argument_list|,
literal|1
argument_list|,
literal|5
operator|*
name|AQM_TIME_1S
argument_list|)
expr_stmt|;
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|max_burst
operator|=
name|BOUND_VAR
argument_list|(
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|max_burst
argument_list|,
literal|0
argument_list|,
literal|5
operator|*
name|AQM_TIME_1S
argument_list|)
expr_stmt|;
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|max_ecnth
operator|=
name|BOUND_VAR
argument_list|(
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|max_ecnth
argument_list|,
literal|0
argument_list|,
name|PIE_SCALE
argument_list|)
expr_stmt|;
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|alpha
operator|=
name|BOUND_VAR
argument_list|(
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|alpha
argument_list|,
literal|0
argument_list|,
literal|7
operator|*
name|PIE_SCALE
argument_list|)
expr_stmt|;
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|beta
operator|=
name|BOUND_VAR
argument_list|(
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|beta
argument_list|,
literal|0
argument_list|,
literal|7
operator|*
name|PIE_SCALE
argument_list|)
expr_stmt|;
name|fqp_cfg
operator|->
name|quantum
operator|=
name|BOUND_VAR
argument_list|(
name|fqp_cfg
operator|->
name|quantum
argument_list|,
literal|1
argument_list|,
literal|9000
argument_list|)
expr_stmt|;
name|fqp_cfg
operator|->
name|limit
operator|=
name|BOUND_VAR
argument_list|(
name|fqp_cfg
operator|->
name|limit
argument_list|,
literal|1
argument_list|,
literal|20480
argument_list|)
expr_stmt|;
name|fqp_cfg
operator|->
name|flows_cnt
operator|=
name|BOUND_VAR
argument_list|(
name|fqp_cfg
operator|->
name|flows_cnt
argument_list|,
literal|1
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|D
argument_list|(
literal|"Wrong parameters for fq_pie scheduler"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return FQ-PIE scheduler configurations  * the configurations for the scheduler is passed to userland.  */
end_comment

begin_function
specifier|static
name|int
name|fq_pie_getconfig
parameter_list|(
name|struct
name|dn_schk
modifier|*
name|_schk
parameter_list|,
name|struct
name|dn_extra_parms
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|fq_pie_schk
modifier|*
name|schk
init|=
operator|(
expr|struct
name|fq_pie_schk
operator|*
operator|)
operator|(
name|_schk
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|dn_sch_fq_pie_parms
modifier|*
name|fqp_cfg
decl_stmt|;
name|fqp_cfg
operator|=
operator|&
name|schk
operator|->
name|cfg
expr_stmt|;
name|strcpy
argument_list|(
name|ep
operator|->
name|name
argument_list|,
name|fq_pie_desc
operator|.
name|name
argument_list|)
expr_stmt|;
name|ep
operator|->
name|par
index|[
literal|0
index|]
operator|=
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|qdelay_ref
expr_stmt|;
name|ep
operator|->
name|par
index|[
literal|1
index|]
operator|=
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|tupdate
expr_stmt|;
name|ep
operator|->
name|par
index|[
literal|2
index|]
operator|=
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|max_burst
expr_stmt|;
name|ep
operator|->
name|par
index|[
literal|3
index|]
operator|=
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|max_ecnth
expr_stmt|;
name|ep
operator|->
name|par
index|[
literal|4
index|]
operator|=
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|alpha
expr_stmt|;
name|ep
operator|->
name|par
index|[
literal|5
index|]
operator|=
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|beta
expr_stmt|;
name|ep
operator|->
name|par
index|[
literal|6
index|]
operator|=
name|fqp_cfg
operator|->
name|pcfg
operator|.
name|flags
expr_stmt|;
name|ep
operator|->
name|par
index|[
literal|7
index|]
operator|=
name|fqp_cfg
operator|->
name|quantum
expr_stmt|;
name|ep
operator|->
name|par
index|[
literal|8
index|]
operator|=
name|fqp_cfg
operator|->
name|limit
expr_stmt|;
name|ep
operator|->
name|par
index|[
literal|9
index|]
operator|=
name|fqp_cfg
operator|->
name|flows_cnt
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  FQ-PIE scheduler descriptor  * contains the type of the scheduler, the name, the size of extra  * data structures, and function pointers.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dn_alg
name|fq_pie_desc
init|=
block|{
name|_SI
argument_list|(
argument|.type =
argument_list|)
name|DN_SCHED_FQ_PIE
block|,
name|_SI
argument_list|(
operator|.
name|name
operator|=
argument_list|)
literal|"FQ_PIE"
block|,
name|_SI
argument_list|(
operator|.
name|flags
operator|=
argument_list|)
literal|0
block|,
name|_SI
argument_list|(
operator|.
name|schk_datalen
operator|=
argument_list|)
sizeof|sizeof
argument_list|(
expr|struct
name|fq_pie_schk
argument_list|)
block|,
name|_SI
argument_list|(
operator|.
name|si_datalen
operator|=
argument_list|)
sizeof|sizeof
argument_list|(
expr|struct
name|fq_pie_si
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|dn_sch_inst
argument_list|)
block|,
name|_SI
argument_list|(
operator|.
name|q_datalen
operator|=
argument_list|)
literal|0
block|,
name|_SI
argument_list|(
argument|.enqueue =
argument_list|)
name|fq_pie_enqueue
block|,
name|_SI
argument_list|(
argument|.dequeue =
argument_list|)
name|fq_pie_dequeue
block|,
name|_SI
argument_list|(
argument|.config =
argument_list|)
name|fq_pie_config
block|,
comment|/* new sched i.e. sched X config ...*/
name|_SI
argument_list|(
argument|.destroy =
argument_list|)
name|NULL
block|,
comment|/*sched x delete */
name|_SI
argument_list|(
argument|.new_sched =
argument_list|)
name|fq_pie_new_sched
block|,
comment|/* new schd instance */
name|_SI
argument_list|(
argument|.free_sched =
argument_list|)
name|fq_pie_free_sched
block|,
comment|/* delete schd instance */
name|_SI
argument_list|(
argument|.new_fsk =
argument_list|)
name|NULL
block|,
name|_SI
argument_list|(
argument|.free_fsk =
argument_list|)
name|NULL
block|,
name|_SI
argument_list|(
argument|.new_queue =
argument_list|)
name|NULL
block|,
name|_SI
argument_list|(
argument|.free_queue =
argument_list|)
name|NULL
block|,
name|_SI
argument_list|(
argument|.getconfig =
argument_list|)
name|fq_pie_getconfig
block|,
name|_SI
argument_list|(
operator|.
name|ref_count
operator|=
argument_list|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_DNSCHED_MODULE
argument_list|(
name|dn_fq_pie
argument_list|,
operator|&
name|fq_pie_desc
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

