begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Yandex LLC  * Copyright (c) 2016 Andrey V. Elsukov<ae@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/counter.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rmlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/pfil.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/ip_fw_private.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/nptv6/nptv6.h>
end_include

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|uint16_t
argument_list|,
name|nptv6_eid
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_nptv6_eid
value|VNET(nptv6_eid)
end_define

begin_define
define|#
directive|define
name|IPFW_TLV_NPTV6_NAME
value|IPFW_TLV_EACTION_NAME(V_nptv6_eid)
end_define

begin_function_decl
specifier|static
name|struct
name|nptv6_cfg
modifier|*
name|nptv6_alloc_config
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nptv6_free_config
parameter_list|(
name|struct
name|nptv6_cfg
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|nptv6_cfg
modifier|*
name|nptv6_find
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nptv6_rewrite_internal
parameter_list|(
name|struct
name|nptv6_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nptv6_rewrite_external
parameter_list|(
name|struct
name|nptv6_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NPTV6_LOOKUP
parameter_list|(
name|chain
parameter_list|,
name|cmd
parameter_list|)
define|\
value|(struct nptv6_cfg *)SRV_OBJECT((chain), (cmd)->arg1)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|IN6_MASK_ADDR
end_ifndef

begin_define
define|#
directive|define
name|IN6_MASK_ADDR
parameter_list|(
name|a
parameter_list|,
name|m
parameter_list|)
value|do { \ 	(a)->s6_addr32[0]&= (m)->s6_addr32[0]; \ 	(a)->s6_addr32[1]&= (m)->s6_addr32[1]; \ 	(a)->s6_addr32[2]&= (m)->s6_addr32[2]; \ 	(a)->s6_addr32[3]&= (m)->s6_addr32[3]; \ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IN6_ARE_MASKED_ADDR_EQUAL
end_ifndef

begin_define
define|#
directive|define
name|IN6_ARE_MASKED_ADDR_EQUAL
parameter_list|(
name|d
parameter_list|,
name|a
parameter_list|,
name|m
parameter_list|)
value|(	\ 	(((d)->s6_addr32[0] ^ (a)->s6_addr32[0])& (m)->s6_addr32[0]) == 0&& \ 	(((d)->s6_addr32[1] ^ (a)->s6_addr32[1])& (m)->s6_addr32[1]) == 0&& \ 	(((d)->s6_addr32[2] ^ (a)->s6_addr32[2])& (m)->s6_addr32[2]) == 0&& \ 	(((d)->s6_addr32[3] ^ (a)->s6_addr32[3])& (m)->s6_addr32[3]) == 0 )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|NPTV6_DEBUG
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {			\ 	printf("%s: " fmt "\n", __func__, ## __VA_ARGS__);	\ } while (0)
end_define

begin_define
define|#
directive|define
name|NPTV6_IPDEBUG
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {			\ 	char _s[INET6_ADDRSTRLEN], _d[INET6_ADDRSTRLEN];	\ 	printf("%s: " fmt "\n", __func__, ## __VA_ARGS__);	\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NPTV6_DEBUG
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|NPTV6_IPDEBUG
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|nptv6_getlasthdr
parameter_list|(
name|struct
name|nptv6_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|ip6_hbh
modifier|*
name|hbh
decl_stmt|;
name|int
name|proto
decl_stmt|,
name|hlen
decl_stmt|;
name|hlen
operator|=
operator|(
name|offset
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
operator|*
name|offset
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hlen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ip6
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
expr_stmt|;
name|proto
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
while|while
condition|(
name|proto
operator|==
name|IPPROTO_HOPOPTS
operator|||
name|proto
operator|==
name|IPPROTO_ROUTING
operator|||
name|proto
operator|==
name|IPPROTO_DSTOPTS
condition|)
block|{
name|hbh
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hlen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|proto
operator|=
name|hbh
operator|->
name|ip6h_nxt
expr_stmt|;
name|hlen
operator|+=
operator|(
name|hbh
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
name|NULL
condition|)
operator|*
name|offset
operator|=
name|hlen
expr_stmt|;
return|return
operator|(
name|proto
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nptv6_translate_icmpv6
parameter_list|(
name|struct
name|nptv6_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|icmp6_hdr
modifier|*
name|icmp6
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|m
operator|->
name|m_len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|icmp6
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|NPTV6_DEBUG
argument_list|(
literal|"ICMPv6 type %d"
argument_list|,
name|icmp6
operator|->
name|icmp6_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|icmp6
operator|->
name|icmp6_type
condition|)
block|{
case|case
name|ICMP6_DST_UNREACH
case|:
case|case
name|ICMP6_PACKET_TOO_BIG
case|:
case|case
name|ICMP6_TIME_EXCEEDED
case|:
case|case
name|ICMP6_PARAM_PROB
case|:
break|break;
case|case
name|ICMP6_ECHO_REQUEST
case|:
case|case
name|ICMP6_ECHO_REPLY
case|:
comment|/* nothing to translate */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
comment|/* 		 * XXX: We can add some checks to not translate NDP and MLD 		 * messages. Currently user must explicitly allow these message 		 * types, otherwise packets will be dropped. 		 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|offset
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|icmp6
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
operator|>
name|m
operator|->
name|m_len
condition|)
operator|*
name|mp
operator|=
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ip6
operator|=
name|mtodo
argument_list|(
name|m
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|NPTV6_IPDEBUG
argument_list|(
literal|"offset %d, %s -> %s %d"
argument_list|,
name|offset
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
name|_s
argument_list|,
sizeof|sizeof
argument_list|(
name|_s
argument_list|)
argument_list|)
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|_d
argument_list|,
sizeof|sizeof
argument_list|(
name|_d
argument_list|)
argument_list|)
argument_list|,
name|ip6
operator|->
name|ip6_nxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_ARE_MASKED_ADDR_EQUAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
operator|&
name|cfg
operator|->
name|external
argument_list|,
operator|&
name|cfg
operator|->
name|mask
argument_list|)
condition|)
return|return
operator|(
name|nptv6_rewrite_external
argument_list|(
name|cfg
argument_list|,
name|mp
argument_list|,
name|offset
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|IN6_ARE_MASKED_ADDR_EQUAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
operator|&
name|cfg
operator|->
name|internal
argument_list|,
operator|&
name|cfg
operator|->
name|mask
argument_list|)
condition|)
return|return
operator|(
name|nptv6_rewrite_internal
argument_list|(
name|cfg
argument_list|,
name|mp
argument_list|,
name|offset
argument_list|)
operator|)
return|;
comment|/* 	 * Addresses in the inner IPv6 header doesn't matched to 	 * our prefixes. 	 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nptv6_search_index
parameter_list|(
name|struct
name|nptv6_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|a
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|flags
operator|&
name|NPTV6_48PLEN
condition|)
return|return
operator|(
literal|3
operator|)
return|;
comment|/* Search suitable word index for adjustment */
for|for
control|(
name|idx
operator|=
literal|4
init|;
name|idx
operator|<
literal|8
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|a
operator|->
name|s6_addr16
index|[
name|idx
index|]
operator|!=
literal|0xffff
condition|)
break|break;
comment|/* 	 * RFC 6296 p3.7: If an NPTv6 Translator discovers a datagram with 	 * an IID of all-zeros while performing address mapping, that 	 * datagram MUST be dropped, and an ICMPv6 Parameter Problem error 	 * SHOULD be generated. 	 */
if|if
condition|(
name|idx
operator|==
literal|8
operator|||
operator|(
name|a
operator|->
name|s6_addr32
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|a
operator|->
name|s6_addr32
index|[
literal|3
index|]
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nptv6_copy_addr
parameter_list|(
name|struct
name|in6_addr
modifier|*
name|src
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|dst
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|mask
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
operator|&&
name|mask
operator|->
name|s6_addr8
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|dst
operator|->
name|s6_addr8
index|[
name|i
index|]
operator|&=
operator|~
name|mask
operator|->
name|s6_addr8
index|[
name|i
index|]
expr_stmt|;
name|dst
operator|->
name|s6_addr8
index|[
name|i
index|]
operator||=
name|src
operator|->
name|s6_addr8
index|[
name|i
index|]
operator|&
name|mask
operator|->
name|s6_addr8
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nptv6_rewrite_internal
parameter_list|(
name|struct
name|nptv6_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|in6_addr
modifier|*
name|addr
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|proto
decl_stmt|;
name|uint16_t
name|adj
decl_stmt|;
name|ip6
operator|=
name|mtodo
argument_list|(
operator|*
name|mp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|NPTV6_IPDEBUG
argument_list|(
literal|"offset %d, %s -> %s %d"
argument_list|,
name|offset
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
name|_s
argument_list|,
sizeof|sizeof
argument_list|(
name|_s
argument_list|)
argument_list|)
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|_d
argument_list|,
sizeof|sizeof
argument_list|(
name|_d
argument_list|)
argument_list|)
argument_list|,
name|ip6
operator|->
name|ip6_nxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|addr
operator|=
operator|&
name|ip6
operator|->
name|ip6_src
expr_stmt|;
else|else
block|{
comment|/* 		 * When we rewriting inner IPv6 header, we need to rewrite 		 * destination address back to external prefix. The datagram in 		 * the ICMPv6 payload should looks like it was send from 		 * external prefix. 		 */
name|addr
operator|=
operator|&
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
block|}
name|idx
operator|=
name|nptv6_search_index
argument_list|(
name|cfg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Do not send ICMPv6 error when offset isn't zero. 		 * This means we are rewriting inner IPv6 header in the 		 * ICMPv6 error message. 		 */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|icmp6_error2
argument_list|(
operator|*
name|mp
argument_list|,
name|ICMP6_DST_UNREACH
argument_list|,
name|ICMP6_DST_UNREACH_ADDR
argument_list|,
literal|0
argument_list|,
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|IP_FW_DENY
operator|)
return|;
block|}
name|adj
operator|=
name|addr
operator|->
name|s6_addr16
index|[
name|idx
index|]
expr_stmt|;
name|nptv6_copy_addr
argument_list|(
operator|&
name|cfg
operator|->
name|external
argument_list|,
name|addr
argument_list|,
operator|&
name|cfg
operator|->
name|mask
argument_list|)
expr_stmt|;
name|adj
operator|=
name|cksum_add
argument_list|(
name|adj
argument_list|,
name|cfg
operator|->
name|adjustment
argument_list|)
expr_stmt|;
if|if
condition|(
name|adj
operator|==
literal|0xffff
condition|)
name|adj
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|s6_addr16
index|[
name|idx
index|]
operator|=
name|adj
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We may need to translate addresses in the inner IPv6 		 * header for ICMPv6 error messages. 		 */
name|proto
operator|=
name|nptv6_getlasthdr
argument_list|(
name|cfg
argument_list|,
operator|*
name|mp
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|<
literal|0
operator|||
operator|(
name|proto
operator|==
name|IPPROTO_ICMPV6
operator|&&
name|nptv6_translate_icmpv6
argument_list|(
name|cfg
argument_list|,
name|mp
argument_list|,
name|offset
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|IP_FW_DENY
operator|)
return|;
name|NPTV6STAT_INC
argument_list|(
name|cfg
argument_list|,
name|in2ex
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nptv6_rewrite_external
parameter_list|(
name|struct
name|nptv6_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|in6_addr
modifier|*
name|addr
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|proto
decl_stmt|;
name|uint16_t
name|adj
decl_stmt|;
name|ip6
operator|=
name|mtodo
argument_list|(
operator|*
name|mp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|NPTV6_IPDEBUG
argument_list|(
literal|"offset %d, %s -> %s %d"
argument_list|,
name|offset
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
name|_s
argument_list|,
sizeof|sizeof
argument_list|(
name|_s
argument_list|)
argument_list|)
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|_d
argument_list|,
sizeof|sizeof
argument_list|(
name|_d
argument_list|)
argument_list|)
argument_list|,
name|ip6
operator|->
name|ip6_nxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|addr
operator|=
operator|&
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
else|else
block|{
comment|/* 		 * When we rewriting inner IPv6 header, we need to rewrite 		 * source address back to internal prefix. The datagram in 		 * the ICMPv6 payload should looks like it was send from 		 * internal prefix. 		 */
name|addr
operator|=
operator|&
name|ip6
operator|->
name|ip6_src
expr_stmt|;
block|}
name|idx
operator|=
name|nptv6_search_index
argument_list|(
name|cfg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Do not send ICMPv6 error when offset isn't zero. 		 * This means we are rewriting inner IPv6 header in the 		 * ICMPv6 error message. 		 */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|icmp6_error2
argument_list|(
operator|*
name|mp
argument_list|,
name|ICMP6_DST_UNREACH
argument_list|,
name|ICMP6_DST_UNREACH_ADDR
argument_list|,
literal|0
argument_list|,
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|IP_FW_DENY
operator|)
return|;
block|}
name|adj
operator|=
name|addr
operator|->
name|s6_addr16
index|[
name|idx
index|]
expr_stmt|;
name|nptv6_copy_addr
argument_list|(
operator|&
name|cfg
operator|->
name|internal
argument_list|,
name|addr
argument_list|,
operator|&
name|cfg
operator|->
name|mask
argument_list|)
expr_stmt|;
name|adj
operator|=
name|cksum_add
argument_list|(
name|adj
argument_list|,
operator|~
name|cfg
operator|->
name|adjustment
argument_list|)
expr_stmt|;
if|if
condition|(
name|adj
operator|==
literal|0xffff
condition|)
name|adj
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|s6_addr16
index|[
name|idx
index|]
operator|=
name|adj
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We may need to translate addresses in the inner IPv6 		 * header for ICMPv6 error messages. 		 */
name|proto
operator|=
name|nptv6_getlasthdr
argument_list|(
name|cfg
argument_list|,
operator|*
name|mp
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|<
literal|0
operator|||
operator|(
name|proto
operator|==
name|IPPROTO_ICMPV6
operator|&&
name|nptv6_translate_icmpv6
argument_list|(
name|cfg
argument_list|,
name|mp
argument_list|,
name|offset
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|IP_FW_DENY
operator|)
return|;
name|NPTV6STAT_INC
argument_list|(
name|cfg
argument_list|,
name|ex2in
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ipfw external action handler.  */
end_comment

begin_function
specifier|static
name|int
name|ipfw_nptv6
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|struct
name|ip_fw_args
modifier|*
name|args
parameter_list|,
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|int
modifier|*
name|done
parameter_list|)
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|nptv6_cfg
modifier|*
name|cfg
decl_stmt|;
name|ipfw_insn
modifier|*
name|icmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|*
name|done
operator|=
literal|0
expr_stmt|;
comment|/* try next rule if not matched */
name|ret
operator|=
name|IP_FW_DENY
expr_stmt|;
name|icmd
operator|=
name|cmd
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|opcode
operator|!=
name|O_EXTERNAL_ACTION
operator|||
name|cmd
operator|->
name|arg1
operator|!=
name|V_nptv6_eid
operator|||
name|icmd
operator|->
name|opcode
operator|!=
name|O_EXTERNAL_INSTANCE
operator|||
operator|(
name|cfg
operator|=
name|NPTV6_LOOKUP
argument_list|(
name|chain
argument_list|,
name|icmd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* 	 * We need act as router, so when forwarding is disabled - 	 * do nothing. 	 */
if|if
condition|(
name|V_ip6_forwarding
operator|==
literal|0
operator|||
name|args
operator|->
name|f_id
operator|.
name|addr_type
operator|!=
literal|6
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* 	 * NOTE: we expect ipfw_chk() did m_pullup() up to upper level 	 * protocol's headers. Also we skip some checks, that ip6_input(), 	 * ip6_forward(), ip6_fastfwd() and ipfw_chk() already did. 	 */
name|ip6
operator|=
name|mtod
argument_list|(
name|args
operator|->
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|NPTV6_IPDEBUG
argument_list|(
literal|"eid %u, oid %u, %s -> %s %d"
argument_list|,
name|cmd
operator|->
name|arg1
argument_list|,
name|icmd
operator|->
name|arg1
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
name|_s
argument_list|,
sizeof|sizeof
argument_list|(
name|_s
argument_list|)
argument_list|)
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|_d
argument_list|,
sizeof|sizeof
argument_list|(
name|_d
argument_list|)
argument_list|)
argument_list|,
name|ip6
operator|->
name|ip6_nxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_ARE_MASKED_ADDR_EQUAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
operator|&
name|cfg
operator|->
name|internal
argument_list|,
operator|&
name|cfg
operator|->
name|mask
argument_list|)
condition|)
block|{
comment|/* 		 * XXX: Do not translate packets when both src and dst 		 * are from internal prefix. 		 */
if|if
condition|(
name|IN6_ARE_MASKED_ADDR_EQUAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
operator|&
name|cfg
operator|->
name|internal
argument_list|,
operator|&
name|cfg
operator|->
name|mask
argument_list|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|ret
operator|=
name|nptv6_rewrite_internal
argument_list|(
name|cfg
argument_list|,
operator|&
name|args
operator|->
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_ARE_MASKED_ADDR_EQUAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
operator|&
name|cfg
operator|->
name|external
argument_list|,
operator|&
name|cfg
operator|->
name|mask
argument_list|)
condition|)
name|ret
operator|=
name|nptv6_rewrite_external
argument_list|(
name|cfg
argument_list|,
operator|&
name|args
operator|->
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|ret
operator|)
return|;
comment|/* 	 * If address wasn't rewrited - free mbuf and terminate the search. 	 */
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|args
operator|->
name|m
argument_list|)
expr_stmt|;
name|args
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* mark mbuf as consumed */
block|}
name|NPTV6STAT_INC
argument_list|(
name|cfg
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
operator|*
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Terminate the search if one_pass is set */
operator|*
name|done
operator|=
name|V_fw_one_pass
expr_stmt|;
comment|/* Update args->f_id when one_pass is off */
if|if
condition|(
operator|*
name|done
operator|==
literal|0
condition|)
block|{
name|ip6
operator|=
name|mtod
argument_list|(
name|args
operator|->
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|args
operator|->
name|f_id
operator|.
name|src_ip6
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|args
operator|->
name|f_id
operator|.
name|dst_ip6
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|nptv6_cfg
modifier|*
name|nptv6_alloc_config
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
name|set
parameter_list|)
block|{
name|struct
name|nptv6_cfg
modifier|*
name|cfg
decl_stmt|;
name|cfg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nptv6_cfg
argument_list|)
argument_list|,
name|M_IPFW
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|COUNTER_ARRAY_ALLOC
argument_list|(
name|cfg
operator|->
name|stats
argument_list|,
name|NPTV6STATS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|no
operator|.
name|name
operator|=
name|cfg
operator|->
name|name
expr_stmt|;
name|cfg
operator|->
name|no
operator|.
name|etlv
operator|=
name|IPFW_TLV_NPTV6_NAME
expr_stmt|;
name|cfg
operator|->
name|no
operator|.
name|set
operator|=
name|set
expr_stmt|;
name|strlcpy
argument_list|(
name|cfg
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nptv6_free_config
parameter_list|(
name|struct
name|nptv6_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|COUNTER_ARRAY_FREE
argument_list|(
name|cfg
operator|->
name|stats
argument_list|,
name|NPTV6STATS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
argument_list|,
name|M_IPFW
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nptv6_export_config
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|struct
name|nptv6_cfg
modifier|*
name|cfg
parameter_list|,
name|ipfw_nptv6_cfg
modifier|*
name|uc
parameter_list|)
block|{
name|uc
operator|->
name|internal
operator|=
name|cfg
operator|->
name|internal
expr_stmt|;
name|uc
operator|->
name|external
operator|=
name|cfg
operator|->
name|external
expr_stmt|;
name|uc
operator|->
name|plen
operator|=
name|cfg
operator|->
name|plen
expr_stmt|;
name|uc
operator|->
name|flags
operator|=
name|cfg
operator|->
name|flags
operator|&
name|NPTV6_FLAGSMASK
expr_stmt|;
name|uc
operator|->
name|set
operator|=
name|cfg
operator|->
name|no
operator|.
name|set
expr_stmt|;
name|strlcpy
argument_list|(
name|uc
operator|->
name|name
argument_list|,
name|cfg
operator|->
name|no
operator|.
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|uc
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|nptv6_dump_arg
block|{
name|struct
name|ip_fw_chain
modifier|*
name|ch
decl_stmt|;
name|struct
name|sockopt_data
modifier|*
name|sd
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|export_config_cb
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|struct
name|named_object
modifier|*
name|no
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nptv6_dump_arg
modifier|*
name|da
init|=
operator|(
expr|struct
name|nptv6_dump_arg
operator|*
operator|)
name|arg
decl_stmt|;
name|ipfw_nptv6_cfg
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
operator|(
name|ipfw_nptv6_cfg
operator|*
operator|)
name|ipfw_get_sopt_space
argument_list|(
name|da
operator|->
name|sd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|uc
argument_list|)
argument_list|)
expr_stmt|;
name|nptv6_export_config
argument_list|(
name|da
operator|->
name|ch
argument_list|,
operator|(
expr|struct
name|nptv6_cfg
operator|*
operator|)
name|no
argument_list|,
name|uc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|nptv6_cfg
modifier|*
name|nptv6_find
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
name|set
parameter_list|)
block|{
name|struct
name|nptv6_cfg
modifier|*
name|cfg
decl_stmt|;
name|cfg
operator|=
operator|(
expr|struct
name|nptv6_cfg
operator|*
operator|)
name|ipfw_objhash_lookup_name_type
argument_list|(
name|ni
argument_list|,
name|set
argument_list|,
name|IPFW_TLV_NPTV6_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nptv6_calculate_adjustment
parameter_list|(
name|struct
name|nptv6_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|,
name|e
decl_stmt|;
name|uint16_t
modifier|*
name|p
decl_stmt|;
comment|/* Calculate checksum of internal prefix */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|cfg
operator|->
name|internal
init|;
name|p
operator|<
operator|(
name|uint16_t
operator|*
operator|)
operator|(
operator|&
name|cfg
operator|->
name|internal
operator|+
literal|1
operator|)
condition|;
name|p
operator|++
control|)
name|i
operator|=
name|cksum_add
argument_list|(
name|i
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* Calculate checksum of external prefix */
for|for
control|(
name|e
operator|=
literal|0
operator|,
name|p
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|cfg
operator|->
name|external
init|;
name|p
operator|<
operator|(
name|uint16_t
operator|*
operator|)
operator|(
operator|&
name|cfg
operator|->
name|external
operator|+
literal|1
operator|)
condition|;
name|p
operator|++
control|)
name|e
operator|=
name|cksum_add
argument_list|(
name|e
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* Adjustment value for Int->Ext direction */
name|cfg
operator|->
name|adjustment
operator|=
name|cksum_add
argument_list|(
operator|~
name|e
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Creates new NPTv6 instance.  * Data layout (v0)(current):  * Request: [ ipfw_obj_lheader ipfw_nptv6_cfg ]  *  * Returns 0 on success  */
end_comment

begin_function
specifier|static
name|int
name|nptv6_create
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|struct
name|in6_addr
name|mask
decl_stmt|;
name|ipfw_obj_lheader
modifier|*
name|olh
decl_stmt|;
name|ipfw_nptv6_cfg
modifier|*
name|uc
decl_stmt|;
name|struct
name|namedobj_instance
modifier|*
name|ni
decl_stmt|;
name|struct
name|nptv6_cfg
modifier|*
name|cfg
decl_stmt|;
if|if
condition|(
name|sd
operator|->
name|valsize
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|olh
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|uc
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|olh
operator|=
operator|(
name|ipfw_obj_lheader
operator|*
operator|)
name|sd
operator|->
name|kbuf
expr_stmt|;
name|uc
operator|=
operator|(
name|ipfw_nptv6_cfg
operator|*
operator|)
operator|(
name|olh
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ipfw_check_object_name_generic
argument_list|(
name|uc
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uc
operator|->
name|plen
operator|<
literal|8
operator|||
name|uc
operator|->
name|plen
operator|>
literal|64
operator|||
name|uc
operator|->
name|set
operator|>=
name|IPFW_MAX_SETS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|uc
operator|->
name|internal
argument_list|)
operator|||
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|uc
operator|->
name|external
argument_list|)
operator|||
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|uc
operator|->
name|internal
argument_list|)
operator|||
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|uc
operator|->
name|external
argument_list|)
operator|||
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|uc
operator|->
name|internal
argument_list|)
operator|||
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|uc
operator|->
name|external
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|in6_prefixlen2mask
argument_list|(
operator|&
name|mask
argument_list|,
name|uc
operator|->
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_ARE_MASKED_ADDR_EQUAL
argument_list|(
operator|&
name|uc
operator|->
name|internal
argument_list|,
operator|&
name|uc
operator|->
name|external
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ni
operator|=
name|CHAIN_TO_SRV
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|IPFW_UH_RLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|nptv6_find
argument_list|(
name|ni
argument_list|,
name|uc
operator|->
name|name
argument_list|,
name|uc
operator|->
name|set
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|IPFW_UH_RUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|IPFW_UH_RUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|cfg
operator|=
name|nptv6_alloc_config
argument_list|(
name|uc
operator|->
name|name
argument_list|,
name|uc
operator|->
name|set
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|plen
operator|=
name|uc
operator|->
name|plen
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|plen
operator|<=
literal|48
condition|)
name|cfg
operator|->
name|flags
operator||=
name|NPTV6_48PLEN
expr_stmt|;
name|cfg
operator|->
name|internal
operator|=
name|uc
operator|->
name|internal
expr_stmt|;
name|cfg
operator|->
name|external
operator|=
name|uc
operator|->
name|external
expr_stmt|;
name|cfg
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|IN6_MASK_ADDR
argument_list|(
operator|&
name|cfg
operator|->
name|internal
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|IN6_MASK_ADDR
argument_list|(
operator|&
name|cfg
operator|->
name|external
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|nptv6_calculate_adjustment
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|IPFW_UH_WLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipfw_objhash_alloc_idx
argument_list|(
name|ni
argument_list|,
operator|&
name|cfg
operator|->
name|no
operator|.
name|kidx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IPFW_UH_WUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|nptv6_free_config
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|ipfw_objhash_add
argument_list|(
name|ni
argument_list|,
operator|&
name|cfg
operator|->
name|no
argument_list|)
expr_stmt|;
name|IPFW_WLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|SRV_OBJECT
argument_list|(
name|ch
argument_list|,
name|cfg
operator|->
name|no
operator|.
name|kidx
argument_list|)
operator|=
name|cfg
expr_stmt|;
name|IPFW_WUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|IPFW_UH_WUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroys NPTv6 instance.  * Data layout (v0)(current):  * Request: [ ipfw_obj_header ]  *  * Returns 0 on success  */
end_comment

begin_function
specifier|static
name|int
name|nptv6_destroy
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|ipfw_obj_header
modifier|*
name|oh
decl_stmt|;
name|struct
name|nptv6_cfg
modifier|*
name|cfg
decl_stmt|;
if|if
condition|(
name|sd
operator|->
name|valsize
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|oh
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|oh
operator|=
operator|(
name|ipfw_obj_header
operator|*
operator|)
name|sd
operator|->
name|kbuf
expr_stmt|;
if|if
condition|(
name|ipfw_check_object_name_generic
argument_list|(
name|oh
operator|->
name|ntlv
operator|.
name|name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|IPFW_UH_WLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|cfg
operator|=
name|nptv6_find
argument_list|(
name|CHAIN_TO_SRV
argument_list|(
name|ch
argument_list|)
argument_list|,
name|oh
operator|->
name|ntlv
operator|.
name|name
argument_list|,
name|oh
operator|->
name|ntlv
operator|.
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|==
name|NULL
condition|)
block|{
name|IPFW_UH_WUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
if|if
condition|(
name|cfg
operator|->
name|no
operator|.
name|refcnt
operator|>
literal|0
condition|)
block|{
name|IPFW_UH_WUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|IPFW_WLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|SRV_OBJECT
argument_list|(
name|ch
argument_list|,
name|cfg
operator|->
name|no
operator|.
name|kidx
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|IPFW_WUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ipfw_objhash_del
argument_list|(
name|CHAIN_TO_SRV
argument_list|(
name|ch
argument_list|)
argument_list|,
operator|&
name|cfg
operator|->
name|no
argument_list|)
expr_stmt|;
name|ipfw_objhash_free_idx
argument_list|(
name|CHAIN_TO_SRV
argument_list|(
name|ch
argument_list|)
argument_list|,
name|cfg
operator|->
name|no
operator|.
name|kidx
argument_list|)
expr_stmt|;
name|IPFW_UH_WUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|nptv6_free_config
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get or change nptv6 instance config.  * Request: [ ipfw_obj_header [ ipfw_nptv6_cfg ] ]  */
end_comment

begin_function
specifier|static
name|int
name|nptv6_config
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|chain
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lists all NPTv6 instances currently available in kernel.  * Data layout (v0)(current):  * Request: [ ipfw_obj_lheader ]  * Reply: [ ipfw_obj_lheader ipfw_nptv6_cfg x N ]  *  * Returns 0 on success  */
end_comment

begin_function
specifier|static
name|int
name|nptv6_list
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op3
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|ipfw_obj_lheader
modifier|*
name|olh
decl_stmt|;
name|struct
name|nptv6_dump_arg
name|da
decl_stmt|;
comment|/* Check minimum header size */
if|if
condition|(
name|sd
operator|->
name|valsize
operator|<
sizeof|sizeof
argument_list|(
name|ipfw_obj_lheader
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|olh
operator|=
operator|(
name|ipfw_obj_lheader
operator|*
operator|)
name|ipfw_get_sopt_header
argument_list|(
name|sd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|olh
argument_list|)
argument_list|)
expr_stmt|;
name|IPFW_UH_RLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|olh
operator|->
name|count
operator|=
name|ipfw_objhash_count_type
argument_list|(
name|CHAIN_TO_SRV
argument_list|(
name|ch
argument_list|)
argument_list|,
name|IPFW_TLV_NPTV6_NAME
argument_list|)
expr_stmt|;
name|olh
operator|->
name|objsize
operator|=
sizeof|sizeof
argument_list|(
name|ipfw_nptv6_cfg
argument_list|)
expr_stmt|;
name|olh
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|olh
argument_list|)
operator|+
name|olh
operator|->
name|count
operator|*
name|olh
operator|->
name|objsize
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|valsize
operator|<
name|olh
operator|->
name|size
condition|)
block|{
name|IPFW_UH_RUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|da
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|da
argument_list|)
argument_list|)
expr_stmt|;
name|da
operator|.
name|ch
operator|=
name|ch
expr_stmt|;
name|da
operator|.
name|sd
operator|=
name|sd
expr_stmt|;
name|ipfw_objhash_foreach_type
argument_list|(
name|CHAIN_TO_SRV
argument_list|(
name|ch
argument_list|)
argument_list|,
name|export_config_cb
argument_list|,
operator|&
name|da
argument_list|,
name|IPFW_TLV_NPTV6_NAME
argument_list|)
expr_stmt|;
name|IPFW_UH_RUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|__COPY_STAT_FIELD
parameter_list|(
name|_cfg
parameter_list|,
name|_stats
parameter_list|,
name|_field
parameter_list|)
define|\
value|(_stats)->_field = NPTV6STAT_FETCH(_cfg, _field)
end_define

begin_function
specifier|static
name|void
name|export_stats
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|struct
name|nptv6_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|ipfw_nptv6_stats
modifier|*
name|stats
parameter_list|)
block|{
name|__COPY_STAT_FIELD
argument_list|(
name|cfg
argument_list|,
name|stats
argument_list|,
name|in2ex
argument_list|)
expr_stmt|;
name|__COPY_STAT_FIELD
argument_list|(
name|cfg
argument_list|,
name|stats
argument_list|,
name|ex2in
argument_list|)
expr_stmt|;
name|__COPY_STAT_FIELD
argument_list|(
name|cfg
argument_list|,
name|stats
argument_list|,
name|dropped
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get NPTv6 statistics.  * Data layout (v0)(current):  * Request: [ ipfw_obj_header ]  * Reply: [ ipfw_obj_header ipfw_obj_ctlv [ uint64_t x N ]]  *  * Returns 0 on success  */
end_comment

begin_function
specifier|static
name|int
name|nptv6_stats
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|struct
name|ipfw_nptv6_stats
name|stats
decl_stmt|;
name|struct
name|nptv6_cfg
modifier|*
name|cfg
decl_stmt|;
name|ipfw_obj_header
modifier|*
name|oh
decl_stmt|;
name|ipfw_obj_ctlv
modifier|*
name|ctlv
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|ipfw_obj_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ipfw_obj_ctlv
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|valsize
operator|%
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sd
operator|->
name|valsize
operator|<
name|sz
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|oh
operator|=
operator|(
name|ipfw_obj_header
operator|*
operator|)
name|ipfw_get_sopt_header
argument_list|(
name|sd
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|oh
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ipfw_check_object_name_generic
argument_list|(
name|oh
operator|->
name|ntlv
operator|.
name|name
argument_list|)
operator|!=
literal|0
operator|||
name|oh
operator|->
name|ntlv
operator|.
name|set
operator|>=
name|IPFW_MAX_SETS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memset
argument_list|(
operator|&
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|IPFW_UH_RLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|cfg
operator|=
name|nptv6_find
argument_list|(
name|CHAIN_TO_SRV
argument_list|(
name|ch
argument_list|)
argument_list|,
name|oh
operator|->
name|ntlv
operator|.
name|name
argument_list|,
name|oh
operator|->
name|ntlv
operator|.
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|==
name|NULL
condition|)
block|{
name|IPFW_UH_RUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
name|export_stats
argument_list|(
name|ch
argument_list|,
name|cfg
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|IPFW_UH_RUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ctlv
operator|=
operator|(
name|ipfw_obj_ctlv
operator|*
operator|)
operator|(
name|oh
operator|+
literal|1
operator|)
expr_stmt|;
name|memset
argument_list|(
name|ctlv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctlv
argument_list|)
argument_list|)
expr_stmt|;
name|ctlv
operator|->
name|head
operator|.
name|type
operator|=
name|IPFW_TLV_COUNTERS
expr_stmt|;
name|ctlv
operator|->
name|head
operator|.
name|length
operator|=
name|sz
operator|-
sizeof|sizeof
argument_list|(
name|ipfw_obj_header
argument_list|)
expr_stmt|;
name|ctlv
operator|->
name|count
operator|=
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|ctlv
operator|->
name|objsize
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|ctlv
operator|->
name|version
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|ctlv
operator|+
literal|1
argument_list|,
operator|&
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset NPTv6 statistics.  * Data layout (v0)(current):  * Request: [ ipfw_obj_header ]  *  * Returns 0 on success  */
end_comment

begin_function
specifier|static
name|int
name|nptv6_reset_stats
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|ip_fw3_opheader
modifier|*
name|op
parameter_list|,
name|struct
name|sockopt_data
modifier|*
name|sd
parameter_list|)
block|{
name|struct
name|nptv6_cfg
modifier|*
name|cfg
decl_stmt|;
name|ipfw_obj_header
modifier|*
name|oh
decl_stmt|;
if|if
condition|(
name|sd
operator|->
name|valsize
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|oh
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|oh
operator|=
operator|(
name|ipfw_obj_header
operator|*
operator|)
name|sd
operator|->
name|kbuf
expr_stmt|;
if|if
condition|(
name|ipfw_check_object_name_generic
argument_list|(
name|oh
operator|->
name|ntlv
operator|.
name|name
argument_list|)
operator|!=
literal|0
operator|||
name|oh
operator|->
name|ntlv
operator|.
name|set
operator|>=
name|IPFW_MAX_SETS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|IPFW_UH_WLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|cfg
operator|=
name|nptv6_find
argument_list|(
name|CHAIN_TO_SRV
argument_list|(
name|ch
argument_list|)
argument_list|,
name|oh
operator|->
name|ntlv
operator|.
name|name
argument_list|,
name|oh
operator|->
name|ntlv
operator|.
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|==
name|NULL
condition|)
block|{
name|IPFW_UH_WUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
name|COUNTER_ARRAY_ZERO
argument_list|(
name|cfg
operator|->
name|stats
argument_list|,
name|NPTV6STATS
argument_list|)
expr_stmt|;
name|IPFW_UH_WUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ipfw_sopt_handler
name|scodes
index|[]
init|=
block|{
block|{
name|IP_FW_NPTV6_CREATE
block|,
literal|0
block|,
name|HDIR_SET
block|,
name|nptv6_create
block|}
block|,
block|{
name|IP_FW_NPTV6_DESTROY
block|,
literal|0
block|,
name|HDIR_SET
block|,
name|nptv6_destroy
block|}
block|,
block|{
name|IP_FW_NPTV6_CONFIG
block|,
literal|0
block|,
name|HDIR_BOTH
block|,
name|nptv6_config
block|}
block|,
block|{
name|IP_FW_NPTV6_LIST
block|,
literal|0
block|,
name|HDIR_GET
block|,
name|nptv6_list
block|}
block|,
block|{
name|IP_FW_NPTV6_STATS
block|,
literal|0
block|,
name|HDIR_GET
block|,
name|nptv6_stats
block|}
block|,
block|{
name|IP_FW_NPTV6_RESET_STATS
block|,
literal|0
block|,
name|HDIR_SET
block|,
name|nptv6_reset_stats
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|nptv6_classify
parameter_list|(
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|uint16_t
modifier|*
name|puidx
parameter_list|,
name|uint8_t
modifier|*
name|ptype
parameter_list|)
block|{
name|ipfw_insn
modifier|*
name|icmd
decl_stmt|;
name|icmd
operator|=
name|cmd
operator|-
literal|1
expr_stmt|;
name|NPTV6_DEBUG
argument_list|(
literal|"opcode %d, arg1 %d, opcode0 %d, arg1 %d"
argument_list|,
name|cmd
operator|->
name|opcode
argument_list|,
name|cmd
operator|->
name|arg1
argument_list|,
name|icmd
operator|->
name|opcode
argument_list|,
name|icmd
operator|->
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmd
operator|->
name|opcode
operator|!=
name|O_EXTERNAL_ACTION
operator|||
name|icmd
operator|->
name|arg1
operator|!=
name|V_nptv6_eid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|puidx
operator|=
name|cmd
operator|->
name|arg1
expr_stmt|;
operator|*
name|ptype
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nptv6_update_arg1
parameter_list|(
name|ipfw_insn
modifier|*
name|cmd
parameter_list|,
name|uint16_t
name|idx
parameter_list|)
block|{
name|cmd
operator|->
name|arg1
operator|=
name|idx
expr_stmt|;
name|NPTV6_DEBUG
argument_list|(
literal|"opcode %d, arg1 -> %d"
argument_list|,
name|cmd
operator|->
name|opcode
argument_list|,
name|cmd
operator|->
name|arg1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nptv6_findbyname
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|struct
name|tid_info
modifier|*
name|ti
parameter_list|,
name|struct
name|named_object
modifier|*
modifier|*
name|pno
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|ipfw_objhash_find_type
argument_list|(
name|CHAIN_TO_SRV
argument_list|(
name|ch
argument_list|)
argument_list|,
name|ti
argument_list|,
name|IPFW_TLV_NPTV6_NAME
argument_list|,
name|pno
argument_list|)
expr_stmt|;
name|NPTV6_DEBUG
argument_list|(
literal|"uidx %u, type %u, err %d"
argument_list|,
name|ti
operator|->
name|uidx
argument_list|,
name|ti
operator|->
name|type
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|named_object
modifier|*
name|nptv6_findbykidx
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|uint16_t
name|idx
parameter_list|)
block|{
name|struct
name|namedobj_instance
modifier|*
name|ni
decl_stmt|;
name|struct
name|named_object
modifier|*
name|no
decl_stmt|;
name|IPFW_UH_WLOCK_ASSERT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ni
operator|=
name|CHAIN_TO_SRV
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|no
operator|=
name|ipfw_objhash_lookup_kidx
argument_list|(
name|ni
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|no
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NPT with index %d not found"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|NPTV6_DEBUG
argument_list|(
literal|"kidx %u -> %s"
argument_list|,
name|idx
argument_list|,
name|no
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|no
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nptv6_manage_sets
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|uint16_t
name|set
parameter_list|,
name|uint8_t
name|new_set
parameter_list|,
name|enum
name|ipfw_sets_cmd
name|cmd
parameter_list|)
block|{
return|return
operator|(
name|ipfw_obj_manage_sets
argument_list|(
name|CHAIN_TO_SRV
argument_list|(
name|ch
argument_list|)
argument_list|,
name|IPFW_TLV_NPTV6_NAME
argument_list|,
name|set
argument_list|,
name|new_set
argument_list|,
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|opcode_obj_rewrite
name|opcodes
index|[]
init|=
block|{
block|{
operator|.
name|opcode
operator|=
name|O_EXTERNAL_INSTANCE
block|,
operator|.
name|etlv
operator|=
name|IPFW_TLV_EACTION
comment|/* just show it isn't table */
block|,
operator|.
name|classifier
operator|=
name|nptv6_classify
block|,
operator|.
name|update
operator|=
name|nptv6_update_arg1
block|,
operator|.
name|find_byname
operator|=
name|nptv6_findbyname
block|,
operator|.
name|find_bykidx
operator|=
name|nptv6_findbykidx
block|,
operator|.
name|manage_sets
operator|=
name|nptv6_manage_sets
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|destroy_config_cb
parameter_list|(
name|struct
name|namedobj_instance
modifier|*
name|ni
parameter_list|,
name|struct
name|named_object
modifier|*
name|no
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nptv6_cfg
modifier|*
name|cfg
decl_stmt|;
name|struct
name|ip_fw_chain
modifier|*
name|ch
decl_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|ip_fw_chain
operator|*
operator|)
name|arg
expr_stmt|;
name|IPFW_UH_WLOCK_ASSERT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|(
expr|struct
name|nptv6_cfg
operator|*
operator|)
name|SRV_OBJECT
argument_list|(
name|ch
argument_list|,
name|no
operator|->
name|kidx
argument_list|)
expr_stmt|;
name|SRV_OBJECT
argument_list|(
name|ch
argument_list|,
name|no
operator|->
name|kidx
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|ipfw_objhash_del
argument_list|(
name|ni
argument_list|,
operator|&
name|cfg
operator|->
name|no
argument_list|)
expr_stmt|;
name|ipfw_objhash_free_idx
argument_list|(
name|ni
argument_list|,
name|cfg
operator|->
name|no
operator|.
name|kidx
argument_list|)
expr_stmt|;
name|nptv6_free_config
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nptv6_init
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|V_nptv6_eid
operator|=
name|ipfw_add_eaction
argument_list|(
name|ch
argument_list|,
name|ipfw_nptv6
argument_list|,
literal|"nptv6"
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_nptv6_eid
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|IPFW_ADD_SOPT_HANDLER
argument_list|(
name|first
argument_list|,
name|scodes
argument_list|)
expr_stmt|;
name|IPFW_ADD_OBJ_REWRITER
argument_list|(
name|first
argument_list|,
name|opcodes
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nptv6_uninit
parameter_list|(
name|struct
name|ip_fw_chain
modifier|*
name|ch
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|IPFW_DEL_OBJ_REWRITER
argument_list|(
name|last
argument_list|,
name|opcodes
argument_list|)
expr_stmt|;
name|IPFW_DEL_SOPT_HANDLER
argument_list|(
name|last
argument_list|,
name|scodes
argument_list|)
expr_stmt|;
name|ipfw_del_eaction
argument_list|(
name|ch
argument_list|,
name|V_nptv6_eid
argument_list|)
expr_stmt|;
comment|/* 	 * Since we already have deregistered external action, 	 * our named objects become unaccessible via rules, because 	 * all rules were truncated by ipfw_del_eaction(). 	 * So, we can unlink and destroy our named objects without holding 	 * IPFW_WLOCK(). 	 */
name|IPFW_UH_WLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ipfw_objhash_foreach_type
argument_list|(
name|CHAIN_TO_SRV
argument_list|(
name|ch
argument_list|)
argument_list|,
name|destroy_config_cb
argument_list|,
name|ch
argument_list|,
name|IPFW_TLV_NPTV6_NAME
argument_list|)
expr_stmt|;
name|V_nptv6_eid
operator|=
literal|0
expr_stmt|;
name|IPFW_UH_WUNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

