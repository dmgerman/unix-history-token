begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|DXR_DIRECT_BITS
value|18
end_define

begin_define
define|#
directive|define
name|ALLOW_OOO_EXEC
end_define

begin_define
define|#
directive|define
name|DXR_LOOKUP_TIMING
end_define

begin_comment
comment|//#define	DIR_24_8
end_comment

begin_comment
comment|//#define	RADIX_TIMING
end_comment

begin_comment
comment|//#define	DXR_ITER_TIMING
end_comment

begin_comment
comment|//#define	REPEAT_SAME_KEY
end_comment

begin_define
define|#
directive|define
name|DXR_LOOKUP_CONSISTENCY_CHECK
end_define

begin_comment
comment|/*  * Copyright (c) 2005-2012 University of Zagreb  * Copyright (c) 2005 International Computer Science Institute  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/* Compile-time tunables, overriding defaults from ip_fib.h */
end_comment

begin_define
define|#
directive|define
name|DXR_VPORTS_MAX
value|1024
end_define

begin_comment
comment|/* Debugging options */
end_comment

begin_define
define|#
directive|define
name|DXR_BUILD_TIMING
end_define

begin_define
define|#
directive|define
name|DXR_BUILD_PARANOIC
end_define

begin_comment
comment|//#define	DXR_BUILD_DEBUG
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DXR_ITER_TIMING
argument_list|)
operator|&&
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
end_if

begin_error
error|#
directive|error
error|DXR_ITER_TIMING and DXR_LOOKUP_TIMING are mutualy exclusive
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|"dxr_fwd.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static uint16_t nexthop_ref(struct in_addr, struct ifnet *); static int nexthop_unref(uint16_t);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|schedule_update
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|struct
name|in_addr
name|dst
parameter_list|,
name|int
name|mlen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_chunk
parameter_list|(
name|struct
name|dxr_instance
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_chunk_long
parameter_list|(
name|struct
name|dxr_instance
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dxr_walk
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|in_addr_t
name|dst
parameter_list|,
name|in_addr_t
name|mask
parameter_list|,
name|int
name|nh
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dxr_walk_long
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|in_addr_t
name|dst
parameter_list|,
name|in_addr_t
name|mask
parameter_list|,
name|int
name|nh
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dxr_initheap
parameter_list|(
name|struct
name|dxr_instance
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dxr_heap_inject
parameter_list|(
name|struct
name|dxr_instance
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dxr_parse
parameter_list|(
name|struct
name|dxr_instance
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dxr_parse_long
parameter_list|(
name|struct
name|dxr_instance
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prune_empty_chunks
parameter_list|(
name|struct
name|dxr_instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chunk_ref
parameter_list|(
name|struct
name|dxr_instance
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chunk_unref
parameter_list|(
name|struct
name|dxr_instance
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|apply_pending
parameter_list|(
name|struct
name|dxr_instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dxr_check_tables
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|radix_lookup
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|uint32_t
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DIR_24_8
end_ifdef

begin_if
if|#
directive|if
operator|(
name|DXR_DIRECT_BITS
operator|!=
literal|24
operator|)
end_if

begin_error
error|#
directive|error
error|DXR_DIRECT_BITS must be set to 24 when DIR_24_8 is configured
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|dir_24_8_rebuild
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dir_24_8_lookup
parameter_list|(
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|DXR_ITER_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|RADIX_TIMING
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|dxr_lookup_exercise
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|dxr_heap_dump
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dxr_chunk_dump
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_in_route
parameter_list|(
name|struct
name|rtentry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|DXR_ITER_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|RADIX_TIMING
argument_list|)
end_if

begin_expr_stmt
specifier|static
name|DPCPU_DEFINE
argument_list|(
name|int
argument_list|,
name|valid_timing
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ex_preload
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ex_threads
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ex_iters
init|=
literal|100000
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|iter_stat
block|{
name|uint64_t
name|cnt
decl_stmt|;
name|uint64_t
name|cycles
decl_stmt|;
block|}
decl|static
name|iter_stats
index|[
name|MAXCPU
index|]
index|[
literal|32
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|reduce
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rdtsc_latency
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DUMMY_MEM_SIZE
value|(1<< 28)
end_define

begin_comment
comment|/* 256 M elements, 1 Gbyte of kmem */
end_comment

begin_define
define|#
directive|define
name|DUMMY_MEM_MASK
value|(DUMMY_MEM_SIZE - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DXR_LOOKUP_TIMING ... */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DXR_BUILD_TIMING
end_ifdef

begin_struct
struct|struct
name|update_stat
block|{
name|uint64_t
name|cnt
decl_stmt|;
name|uint64_t
name|cycles
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DXR_BUILD_TIMING */
end_comment

begin_define
define|#
directive|define
name|CHUNK_HASH_BITS
value|16
end_define

begin_define
define|#
directive|define
name|CHUNK_HASH_SIZE
value|(CHUNK_HASH_BITS<< 1)
end_define

begin_define
define|#
directive|define
name|CHUNK_HASH_MASK
value|(CHUNK_HASH_SIZE - 1)
end_define

begin_struct
struct|struct
name|dxr_instance
block|{
name|struct
name|direct_entry
modifier|*
name|direct_tbl
decl_stmt|;
name|struct
name|range_entry_long
modifier|*
name|range_tbl
decl_stmt|;
name|struct
name|dxr_nexthop
modifier|*
name|nexthop_tbl
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|chunk_desc
argument_list|)
name|all_chunks
expr_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|chunk_desc
argument_list|)
name|unused_chunks
expr_stmt|;
comment|/* abuses hash link entry */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|chunk_desc
argument_list|)
name|chunk_hashtbl
index|[
name|CHUNK_HASH_SIZE
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DIR_24_8
name|uint16_t
modifier|*
name|tbl_0_23
decl_stmt|;
name|uint16_t
modifier|*
name|tbl_24_31
decl_stmt|;
endif|#
directive|endif
name|int
name|dxr_enable
decl_stmt|;
name|int
name|async_updates
decl_stmt|;
name|int
name|updates_pending
decl_stmt|;
name|int
name|routes
decl_stmt|;
name|int
name|nexthops
decl_stmt|;
name|int
name|range_tbl_free
decl_stmt|;
name|int
name|nexthop_tbl_size
decl_stmt|;
name|int
name|nexthop_head
decl_stmt|;
name|int
name|nexthop_empty_head
decl_stmt|;
name|int
name|heap_index
decl_stmt|;
name|int
name|chunks_short
decl_stmt|;
name|int
name|chunks_long
decl_stmt|;
name|int
name|fragments_short
decl_stmt|;
name|int
name|fragments_long
decl_stmt|;
name|int
name|aggr_chunks_short
decl_stmt|;
name|int
name|aggr_chunks_long
decl_stmt|;
name|int
name|aggr_fragments_short
decl_stmt|;
name|int
name|aggr_fragments_long
decl_stmt|;
name|struct
name|dxr_heap_entry
name|dxr_heap
index|[
literal|33
index|]
decl_stmt|;
name|uint32_t
name|pending_bitmask
index|[
name|DIRECT_TBL_SIZE
operator|>>
literal|5
index|]
expr_stmt|;
name|int
name|pending_start
decl_stmt|;
name|int
name|pending_end
decl_stmt|;
name|struct
name|dxr_funcs
name|f
decl_stmt|;
name|struct
name|chunk_ptr
name|cptbl
index|[
name|DIRECT_TBL_SIZE
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|dlp
decl_stmt|;
name|struct
name|dxr_stats
name|dxr_stats
decl_stmt|;
ifdef|#
directive|ifdef
name|DXR_BUILD_TIMING
name|struct
name|update_stat
name|update_stats
index|[
literal|34
index|]
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* XXX: Temporary hack */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dxr_instance
name|di_blank
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dxr_instance
modifier|*
name|di_c
init|=
operator|&
name|di_blank
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TREE_LOCK_ASSERT
parameter_list|(
name|di
parameter_list|)
value|tree_lock_assert(di)
end_define

begin_define
define|#
directive|define
name|TREE_RLOCK_ASSERT
parameter_list|(
name|di
parameter_list|)
value|tree_lock_assert(di)
end_define

begin_function
specifier|static
name|void
name|tree_lock_assert
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|)
block|{  }
end_function

begin_define
define|#
directive|define
name|TREE_RLOCK
parameter_list|(
name|di
parameter_list|)
value|tree_rlock(di)
end_define

begin_define
define|#
directive|define
name|TREE_RUNLOCK
parameter_list|(
name|di
parameter_list|)
value|tree_runlock(di)
end_define

begin_function
specifier|static
name|void
name|tree_rlock
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|void
name|tree_runlock
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|int
name|radix_lookup
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|uint32_t
name|dst
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|nh
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|error
operator|=
name|di
operator|->
name|f
operator|.
name|tree_lookup
argument_list|(
name|di
operator|->
name|f
operator|.
name|tree_ptr
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|mask
argument_list|,
operator|&
name|nh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|nh
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dxr_lookup
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|uint32_t
name|dst
parameter_list|)
block|{
specifier|register
name|uint32_t
modifier|*
name|fdescp
decl_stmt|;
specifier|register
name|int32_t
name|nh
decl_stmt|;
specifier|register
name|uint32_t
name|masked_dst
decl_stmt|;
specifier|register
name|uint32_t
name|upperbound
decl_stmt|;
specifier|register
name|uint32_t
name|middle
decl_stmt|;
specifier|register
name|uint32_t
name|lowerbound
decl_stmt|;
ifdef|#
directive|ifdef
name|DXR_ITER_TIMING
name|uint32_t
name|iters
init|=
literal|0
decl_stmt|;
name|uint64_t
name|timer
init|=
name|rdtsc
argument_list|()
decl_stmt|;
define|#
directive|define
name|INCR_ITERS
parameter_list|()
value|iters++;
else|#
directive|else
define|#
directive|define
name|INCR_ITERS
parameter_list|()
endif|#
directive|endif
name|masked_dst
operator|=
name|dst
operator|&
name|DXR_RANGE_MASK
expr_stmt|;
name|fdescp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|di
operator|->
name|direct_tbl
index|[
name|dst
operator|>>
name|DXR_RANGE_SHIFT
index|]
expr_stmt|;
name|lowerbound
operator|=
operator|*
name|fdescp
expr_stmt|;
name|nh
operator|=
name|lowerbound
operator|>>
operator|(
literal|32
operator|-
name|DESC_BASE_BITS
operator|)
expr_stmt|;
comment|/* nh == .base */
if|if
condition|(
name|nh
operator|!=
name|BASE_MAX
condition|)
block|{
comment|/* 		 * Binary search for a matching range - the magic 		 * happens here in this simple loop (unrolling is 		 * just an optimization). 		 */
define|#
directive|define
name|DXR_LOOKUP_STAGE
define|\
value|INCR_ITERS();					 \ 			if (masked_dst< range[middle].start) {		 \ 				upperbound = middle;			 \ 				middle = (middle + lowerbound) / 2;	 \ 			} else if (masked_dst< range[middle + 1].start) { \ 				lowerbound = middle;			 \ 				break;					 \ 			} else {					 \ 				lowerbound = middle + 1;		 \ 				middle = (upperbound + middle + 1) / 2;	\ 			}						 \ 			if (upperbound == lowerbound)			 \ 				break;
if|if
condition|(
name|lowerbound
operator|&
literal|0x1000
condition|)
block|{
comment|/* .long_format set? */
specifier|register
name|struct
name|range_entry_long
modifier|*
name|range
decl_stmt|;
name|upperbound
operator|=
name|lowerbound
operator|&
literal|0xfff
expr_stmt|;
comment|/* .fragments */
name|range
operator|=
operator|&
name|di
operator|->
name|range_tbl
index|[
name|nh
index|]
expr_stmt|;
comment|/* nh == .base */
name|middle
operator|=
name|upperbound
operator|/
literal|2
expr_stmt|;
name|lowerbound
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|nh
operator|=
name|range
index|[
name|lowerbound
index|]
operator|.
name|nexthop
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|range_entry_short
modifier|*
name|range
decl_stmt|;
name|middle
operator|=
name|lowerbound
operator|&
literal|0xfff
expr_stmt|;
comment|/* .fragments */
name|masked_dst
operator|>>=
literal|8
expr_stmt|;
name|range
operator|=
operator|(
expr|struct
name|range_entry_short
operator|*
operator|)
operator|&
name|di
operator|->
name|range_tbl
index|[
name|nh
index|]
expr_stmt|;
name|upperbound
operator|=
name|middle
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|lowerbound
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
name|DXR_LOOKUP_STAGE
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|nh
operator|=
name|range
index|[
name|lowerbound
index|]
operator|.
name|nexthop
expr_stmt|;
block|}
undef|#
directive|undef
name|DXR_LOOKUP_STAGE
block|}
else|else
block|{
comment|/* nexthop is encoded in the fragments field */
name|nh
operator|=
name|lowerbound
operator|&
literal|0xfff
expr_stmt|;
comment|/* XXX hardcoded - revisit this!!! */
block|}
ifdef|#
directive|ifdef
name|DXR_ITER_TIMING
name|timer
operator|=
name|rdtsc
argument_list|()
operator|-
name|timer
expr_stmt|;
if|if
condition|(
name|DPCPU_GET
argument_list|(
name|valid_timing
argument_list|)
condition|)
block|{
name|int
name|cpuid
init|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
decl_stmt|;
name|iter_stats
index|[
name|cpuid
index|]
index|[
name|iters
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
name|iter_stats
index|[
name|cpuid
index|]
index|[
name|iters
index|]
operator|.
name|cycles
operator|+=
name|timer
operator|-
name|rdtsc_latency
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|nh
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Control plane interface / support.  *  * TODO: RTM_CHANGE  * TODO: MPATH  */
end_comment

begin_comment
unit|static int dxr_request(void *state, int req, struct rtentry *rt, struct rt_addrinfo *info) { 	struct sockaddr *dst; 	struct sockaddr *mask; 	struct sockaddr_in *in_gw; 	struct dxr_instance *di; 	int refs;  	dst = rt_key(rt); 	mask = rt_mask(rt); 	fib = rt->rt_fibnum; 	in_gw = SIN(rt->rt_gateway); 	di = (struct dxr_instance *)state;   	TREE_RLOCK_ASSERT(di);  	switch(req) { 	case RTM_DELETE:
comment|/* #ifdef DXR_BUILD_DEBUG 		print_in_route(rt, "RTM_DELETE"); #endif */
end_comment

begin_ifdef
unit|refs = nexthop_unref(di, rt->rt_dxr_nexthop); 		break;  	case RTM_ADD: 		nexthop_ref_rte(di, rt); 		break; 	default:
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
end_ifdef

begin_endif
unit|print_in_route(rt, "unsupported!");
endif|#
directive|endif
end_endif

begin_endif
unit|panic("don't know how to handle request %d", req); 	}  	return (dxr_request(di, req, idst, mlen)); }
endif|#
directive|endif
end_endif

begin_function
name|int
name|dxr_request
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|int
name|req
parameter_list|,
name|struct
name|in_addr
name|dst
parameter_list|,
name|int
name|mlen
parameter_list|,
name|int
name|nh_refs
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DXR_BUILD_TIMING
name|uint64_t
name|timer
decl_stmt|;
name|timer
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|TREE_RLOCK_ASSERT
argument_list|(
name|di
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|RTM_DELETE
case|:
name|di
operator|->
name|routes
operator|--
expr_stmt|;
if|#
directive|if
literal|0
block|if (mlen == 0) {
comment|/* Default route removal */
block|di->nexthop_tbl[0].ifp = NULL; 			di->nexthop_tbl[0].gw.s_addr = 0; 			break; 		}
comment|/* #ifdef DXR_BUILD_DEBUG 		print_in_route(rt, "RTM_DELETE"); #endif */
endif|#
directive|endif
name|schedule_update
argument_list|(
name|di
argument_list|,
name|dst
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
comment|/* 		 * If we have deleted the last reference to a nexthop, 		 * we have to forcibly apply all pending changes to the 		 * FIB, otherwise we might leave a stale pointer there 		 * to a now nonexisting nexthop. 		 */
if|if
condition|(
name|nh_refs
operator|==
literal|0
operator|||
name|di
operator|->
name|async_updates
operator|==
literal|0
condition|)
name|apply_pending
argument_list|(
name|di
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DXR_BUILD_TIMING
name|timer
operator|=
name|rdtsc
argument_list|()
operator|-
name|timer
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|async_updates
operator|==
literal|0
condition|)
block|{
name|di
operator|->
name|update_stats
index|[
name|mlen
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
name|di
operator|->
name|update_stats
index|[
name|mlen
index|]
operator|.
name|cycles
operator|+=
name|timer
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|RTM_ADD
case|:
name|di
operator|->
name|routes
operator|++
expr_stmt|;
if|#
directive|if
literal|0
block|if (mlen == 0) {
comment|/* Default route insertion */
block|di->nexthop_tbl[0].ifp = rt->rt_ifp; 			di->nexthop_tbl[0].gw = in_gw->sin_addr; 			break; 		}  		nexthop_ref_rte(di, rt);
comment|/* #ifdef DXR_BUILD_DEBUG 		print_in_route(rt, "RTM_ADD"); #endif */
endif|#
directive|endif
name|schedule_update
argument_list|(
name|di
argument_list|,
name|dst
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|async_updates
operator|==
literal|0
condition|)
block|{
name|apply_pending
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|di
operator|->
name|unused_chunks
argument_list|)
condition|)
name|prune_empty_chunks
argument_list|(
name|di
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DXR_BUILD_TIMING
name|timer
operator|=
name|rdtsc
argument_list|()
operator|-
name|timer
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|async_updates
operator|==
literal|0
condition|)
block|{
name|di
operator|->
name|update_stats
index|[
name|mlen
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
name|di
operator|->
name|update_stats
index|[
name|mlen
index|]
operator|.
name|cycles
operator|+=
name|timer
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
default|default:
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
name|print_in_route
argument_list|(
name|rt
argument_list|,
literal|"unsupported!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"don't know how to handle request %d"
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dxr_initheap
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|uint32_t
name|dst
parameter_list|,
name|uint32_t
name|chunk
parameter_list|)
block|{
name|uint32_t
name|mask
decl_stmt|;
name|int
name|nh
decl_stmt|;
name|struct
name|dxr_heap_entry
modifier|*
name|fhp
init|=
operator|&
name|di
operator|->
name|dxr_heap
index|[
literal|0
index|]
decl_stmt|;
name|di
operator|->
name|heap_index
operator|=
literal|0
expr_stmt|;
name|TREE_LOCK_ASSERT
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|f
operator|.
name|tree_lookup
argument_list|(
name|di
operator|->
name|f
operator|.
name|tree_ptr
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|mask
argument_list|,
operator|&
name|nh
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fhp
operator|->
name|start
operator|=
name|ntohl
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
name|fhp
operator|->
name|preflen
operator|=
name|ffs
argument_list|(
name|ntohl
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fhp
operator|->
name|preflen
condition|)
name|fhp
operator|->
name|preflen
operator|=
literal|33
operator|-
name|fhp
operator|->
name|preflen
expr_stmt|;
name|fhp
operator|->
name|end
operator|=
name|fhp
operator|->
name|start
operator||
operator|~
name|ntohl
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fhp
operator|->
name|preflen
operator|=
literal|32
expr_stmt|;
name|fhp
operator|->
name|end
operator|=
name|fhp
operator|->
name|start
expr_stmt|;
block|}
name|fhp
operator|->
name|nexthop
operator|=
name|nh
expr_stmt|;
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
comment|//print_in_route(rt, "  initheap");
endif|#
directive|endif
block|}
else|else
block|{
name|fhp
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|fhp
operator|->
name|end
operator|=
literal|0xffffffff
expr_stmt|;
name|fhp
operator|->
name|preflen
operator|=
literal|0
expr_stmt|;
name|fhp
operator|->
name|nexthop
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
name|printf
argument_list|(
literal|"  initheap: DEFAULT\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|schedule_update
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|struct
name|in_addr
name|dst
parameter_list|,
name|int
name|mlen
parameter_list|)
block|{
name|uint32_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|chunk
decl_stmt|;
if|if
condition|(
name|di
operator|->
name|dxr_enable
operator|==
literal|0
condition|)
return|return;
name|start
operator|=
name|ntohl
argument_list|(
name|dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|end
operator|=
name|start
operator||
operator|~
operator|(
name|mlen
condition|?
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|32
operator|-
name|mlen
operator|)
operator|)
operator|-
literal|1
operator|)
else|:
literal|0
operator|)
expr_stmt|;
name|start
operator|=
name|start
operator|>>
name|DXR_RANGE_SHIFT
expr_stmt|;
name|end
operator|=
name|end
operator|>>
name|DXR_RANGE_SHIFT
expr_stmt|;
for|for
control|(
name|chunk
operator|=
name|start
init|;
name|chunk
operator|<=
name|end
condition|;
name|chunk
operator|++
control|)
name|di
operator|->
name|pending_bitmask
index|[
name|chunk
operator|>>
literal|5
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|chunk
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|start
operator|<
name|di
operator|->
name|pending_start
condition|)
name|di
operator|->
name|pending_start
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|di
operator|->
name|pending_end
condition|)
name|di
operator|->
name|pending_end
operator|=
name|end
expr_stmt|;
name|di
operator|->
name|updates_pending
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dxr_check_tables
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nh
decl_stmt|;
name|int
name|error
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DIRECT_TBL_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|nh
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|direct_tbl
index|[
name|i
index|]
operator|.
name|base
operator|==
name|BASE_MAX
condition|)
block|{
comment|/* Nexthop is directly resolvable */
name|nh
operator|=
name|di
operator|->
name|direct_tbl
index|[
name|i
index|]
operator|.
name|fragments
expr_stmt|;
if|if
condition|(
name|nh
operator|>=
name|di
operator|->
name|nexthop_tbl_size
condition|)
block|{
comment|/* Nexthop index out of range */
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|report_err
goto|;
block|}
continue|continue;
block|}
name|report_err
label|:
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"i = %d nh = %d err = %d\n"
argument_list|,
name|i
argument_list|,
name|nh
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dxr_updater
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|pause
argument_list|(
literal|"-"
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
name|dxr_process_one
argument_list|(
name|di
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dxr_process_one
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|)
block|{
name|int
name|last_pending
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DXR_BUILD_TIMING
name|uint64_t
name|timer
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|DXR_ITER_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|RADIX_TIMING
argument_list|)
comment|/* Reduce random keys to those resolvable by binary search */
if|if
condition|(
name|di
operator|->
name|dlp
operator|!=
name|NULL
operator|&&
name|di
operator|->
name|updates_pending
operator|==
literal|0
operator|&&
name|di
operator|->
name|routes
operator|>
literal|400000
operator|&&
name|reduce
condition|)
block|{
name|uint32_t
name|dst
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DUMMY_MEM_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|dst
operator|=
name|di
operator|->
name|dlp
index|[
name|i
index|]
init|;
name|di
operator|->
name|direct_tbl
index|[
name|dst
operator|>>
name|DXR_RANGE_SHIFT
index|]
operator|.
name|base
operator|==
name|BASE_MAX
operator|||
name|dst
operator|>>
literal|24
operator|==
literal|0
operator|||
name|dst
operator|>>
literal|24
operator|==
literal|10
operator|||
name|dst
operator|>>
literal|24
operator|==
literal|127
operator|||
name|dst
operator|>>
literal|24
operator|>=
literal|224
condition|;
name|di
operator|->
name|dlp
index|[
name|i
index|]
operator|=
name|dst
control|)
block|{
name|dst
operator|=
name|arc4random
argument_list|()
expr_stmt|;
block|}
block|}
name|reduce
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|di
operator|->
name|async_updates
condition|)
block|{
name|TREE_RLOCK
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|updates_pending
operator|&&
name|di
operator|->
name|updates_pending
operator|==
name|last_pending
condition|)
block|{
ifdef|#
directive|ifdef
name|DXR_BUILD_TIMING
name|timer
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|apply_pending
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|di
operator|->
name|unused_chunks
argument_list|)
condition|)
name|prune_empty_chunks
argument_list|(
name|di
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DXR_BUILD_TIMING
name|timer
operator|=
name|rdtsc
argument_list|()
operator|-
name|timer
expr_stmt|;
name|timer
operator|=
name|timer
operator|*
literal|1000000
operator|/
name|tsc_freq
expr_stmt|;
name|printf
argument_list|(
literal|"FIB updated: %u prefixes in %u.%03u"
literal|" ms\n"
argument_list|,
name|di
operator|->
name|updates_pending
argument_list|,
call|(
name|int
call|)
argument_list|(
name|timer
operator|/
literal|1000
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|timer
operator|%
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DIRECT_TBL_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|di
operator|->
name|direct_tbl
index|[
name|i
index|]
operator|.
name|base
operator|==
name|BASE_MAX
condition|)
name|j
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"FIB rebuilt, %d descriptors,"
literal|" %d directly resolvable\n"
argument_list|,
name|DIRECT_TBL_SIZE
argument_list|,
name|j
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dxr_check_tables
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|di
operator|->
name|updates_pending
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DIR_24_8
name|dir_24_8_rebuild
argument_list|(
name|di
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* FIXME: last_pending is now broken */
name|last_pending
operator|=
name|di
operator|->
name|updates_pending
expr_stmt|;
name|TREE_RUNLOCK
argument_list|(
name|di
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|chunk_desc
modifier|*
name|cdesc_alloc
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|)
block|{
name|struct
name|chunk_desc
modifier|*
name|cdp
decl_stmt|;
name|cdp
operator|=
operator|(
expr|struct
name|chunk_desc
operator|*
operator|)
name|di
operator|->
name|f
operator|.
name|slab_alloc
argument_list|(
name|di
operator|->
name|f
operator|.
name|slab_ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|cdp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cdesc_free
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|struct
name|chunk_desc
modifier|*
name|cdp
parameter_list|)
block|{
name|di
operator|->
name|f
operator|.
name|slab_free
argument_list|(
name|di
operator|->
name|f
operator|.
name|slab_ptr
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prune_empty_chunks
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|)
block|{
name|struct
name|chunk_desc
modifier|*
name|cdp1
decl_stmt|,
modifier|*
name|cdp2
decl_stmt|;
name|int
name|chunk
decl_stmt|,
name|from
decl_stmt|,
name|to
decl_stmt|,
name|len
decl_stmt|;
for|for
control|(
name|cdp1
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|di
operator|->
name|unused_chunks
argument_list|)
init|;
name|cdp1
operator|!=
name|NULL
condition|;
name|cdp1
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|di
operator|->
name|unused_chunks
argument_list|)
control|)
block|{
name|from
operator|=
name|cdp1
operator|->
name|cd_base
operator|+
name|cdp1
operator|->
name|cd_max_size
expr_stmt|;
name|to
operator|=
name|cdp1
operator|->
name|cd_base
expr_stmt|;
name|cdp2
operator|=
name|LIST_NEXT
argument_list|(
name|cdp1
argument_list|,
name|cd_hash_le
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdp2
operator|!=
name|NULL
condition|)
block|{
comment|/* Case A: more than one chunk */
name|len
operator|=
name|cdp2
operator|->
name|cd_base
operator|-
name|from
expr_stmt|;
name|cdp2
operator|->
name|cd_max_size
operator|+=
name|cdp1
operator|->
name|cd_max_size
expr_stmt|;
block|}
else|else
block|{
comment|/* Single empty chunk found */
name|cdp2
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|di
operator|->
name|all_chunks
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdp1
operator|!=
name|cdp2
condition|)
block|{
comment|/* Case B: not the last chunk on the heap */
name|len
operator|=
name|di
operator|->
name|range_tbl_free
operator|-
name|from
expr_stmt|;
name|di
operator|->
name|range_tbl_free
operator|-=
name|cdp1
operator|->
name|cd_max_size
expr_stmt|;
block|}
else|else
block|{
comment|/* Case C: is the last chunk on the heap */
name|di
operator|->
name|range_tbl_free
operator|-=
name|cdp1
operator|->
name|cd_max_size
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|cdp1
argument_list|,
name|cd_all_le
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|cdp1
argument_list|,
name|cd_hash_le
argument_list|)
expr_stmt|;
name|cdesc_free
argument_list|(
name|di
argument_list|,
name|cdp1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|bcopy
argument_list|(
operator|&
name|di
operator|->
name|range_tbl
index|[
name|from
index|]
argument_list|,
operator|&
name|di
operator|->
name|range_tbl
index|[
name|to
index|]
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|di
operator|->
name|range_tbl
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|cdp2
operator|->
name|cd_base
operator|-=
name|cdp1
operator|->
name|cd_max_size
expr_stmt|;
for|for
control|(
name|chunk
operator|=
name|cdp2
operator|->
name|cd_chunk_first
init|;
name|chunk
operator|>=
literal|0
condition|;
name|chunk
operator|=
name|di
operator|->
name|cptbl
index|[
name|chunk
index|]
operator|.
name|cp_chunk_next
control|)
if|if
condition|(
name|di
operator|->
name|direct_tbl
index|[
name|chunk
index|]
operator|.
name|base
operator|!=
name|BASE_MAX
condition|)
name|di
operator|->
name|direct_tbl
index|[
name|chunk
index|]
operator|.
name|base
operator|-=
name|cdp1
operator|->
name|cd_max_size
expr_stmt|;
name|cdp2
operator|=
name|LIST_NEXT
argument_list|(
name|cdp2
argument_list|,
name|cd_all_le
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cdp2
operator|!=
name|cdp1
condition|)
do|;
name|LIST_REMOVE
argument_list|(
name|cdp1
argument_list|,
name|cd_all_le
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|cdp1
argument_list|,
name|cd_hash_le
argument_list|)
expr_stmt|;
name|cdesc_free
argument_list|(
name|di
argument_list|,
name|cdp1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|chunk_hash
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|struct
name|direct_entry
modifier|*
name|fdesc
parameter_list|)
block|{
name|uint32_t
modifier|*
name|p
decl_stmt|;
name|uint32_t
modifier|*
name|l
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|p
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|di
operator|->
name|range_tbl
index|[
name|fdesc
operator|->
name|base
index|]
expr_stmt|;
name|l
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|di
operator|->
name|range_tbl
index|[
name|fdesc
operator|->
name|base
operator|+
name|fdesc
operator|->
name|fragments
index|]
expr_stmt|;
name|hash
operator|=
name|fdesc
operator|->
name|fragments
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<=
name|l
condition|;
name|p
operator|++
control|)
name|hash
operator|=
operator|(
name|hash
operator|<<
literal|1
operator|)
operator|+
operator|(
name|hash
operator|>>
literal|1
operator|)
operator|+
operator|*
name|p
expr_stmt|;
return|return
operator|(
name|hash
operator|+
operator|(
name|hash
operator|>>
literal|16
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|chunk_ref
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|int
name|chunk
parameter_list|)
block|{
name|struct
name|direct_entry
modifier|*
name|fdesc
init|=
operator|&
name|di
operator|->
name|direct_tbl
index|[
name|chunk
index|]
decl_stmt|;
name|struct
name|chunk_desc
modifier|*
name|cdp
decl_stmt|,
modifier|*
name|empty_cdp
decl_stmt|;
name|uint32_t
name|hash
init|=
name|chunk_hash
argument_list|(
name|di
argument_list|,
name|fdesc
argument_list|)
decl_stmt|;
name|int
name|base
init|=
name|fdesc
operator|->
name|base
decl_stmt|;
name|int
name|size
init|=
name|fdesc
operator|->
name|fragments
operator|+
literal|1
decl_stmt|;
comment|/* Find an already existing chunk descriptor */
name|LIST_FOREACH
argument_list|(
argument|cdp
argument_list|,
argument|&di->chunk_hashtbl[hash& CHUNK_HASH_MASK]
argument_list|,
argument|cd_hash_le
argument_list|)
block|{
if|if
condition|(
name|cdp
operator|->
name|cd_hash
operator|==
name|hash
operator|&&
name|cdp
operator|->
name|cd_cur_size
operator|==
name|size
operator|&&
name|memcmp
argument_list|(
operator|&
name|di
operator|->
name|range_tbl
index|[
name|base
index|]
argument_list|,
operator|&
name|di
operator|->
name|range_tbl
index|[
name|cdp
operator|->
name|cd_base
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|range_entry_long
argument_list|)
operator|*
name|size
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cdp
operator|->
name|cd_refcount
operator|++
expr_stmt|;
name|fdesc
operator|->
name|base
operator|=
name|cdp
operator|->
name|cd_base
expr_stmt|;
if|if
condition|(
name|fdesc
operator|->
name|long_format
condition|)
block|{
name|di
operator|->
name|aggr_chunks_long
operator|++
expr_stmt|;
name|di
operator|->
name|aggr_fragments_long
operator|+=
name|size
expr_stmt|;
name|di
operator|->
name|chunks_long
operator|--
expr_stmt|;
name|di
operator|->
name|fragments_long
operator|-=
name|size
expr_stmt|;
block|}
else|else
block|{
name|di
operator|->
name|aggr_chunks_short
operator|++
expr_stmt|;
name|di
operator|->
name|aggr_fragments_short
operator|+=
operator|(
name|size
operator|<<
literal|1
operator|)
expr_stmt|;
name|di
operator|->
name|chunks_short
operator|--
expr_stmt|;
name|di
operator|->
name|fragments_short
operator|-=
operator|(
name|size
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
name|di
operator|->
name|range_tbl_free
operator|-=
name|size
expr_stmt|;
comment|/* Link in the chunk */
name|di
operator|->
name|cptbl
index|[
name|chunk
index|]
operator|.
name|cp_cdp
operator|=
name|cdp
expr_stmt|;
name|di
operator|->
name|cptbl
index|[
name|chunk
index|]
operator|.
name|cp_chunk_next
operator|=
name|cdp
operator|->
name|cd_chunk_first
expr_stmt|;
name|cdp
operator|->
name|cd_chunk_first
operator|=
name|chunk
expr_stmt|;
return|return;
block|}
block|}
comment|/* No matching chunks found. Recycle an empty or allocate a new one */
name|cdp
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|empty_cdp
argument_list|,
argument|&di->unused_chunks
argument_list|,
argument|cd_hash_le
argument_list|)
block|{
if|if
condition|(
name|empty_cdp
operator|->
name|cd_max_size
operator|>=
name|size
operator|&&
operator|(
name|cdp
operator|==
name|NULL
operator|||
name|empty_cdp
operator|->
name|cd_max_size
operator|<
name|cdp
operator|->
name|cd_max_size
operator|)
condition|)
block|{
name|cdp
operator|=
name|empty_cdp
expr_stmt|;
if|if
condition|(
name|empty_cdp
operator|->
name|cd_max_size
operator|==
name|size
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|cdp
operator|!=
name|NULL
condition|)
block|{
comment|/* Copy from heap into the recycled chunk */
name|bcopy
argument_list|(
operator|&
name|di
operator|->
name|range_tbl
index|[
name|fdesc
operator|->
name|base
index|]
argument_list|,
operator|&
name|di
operator|->
name|range_tbl
index|[
name|cdp
operator|->
name|cd_base
index|]
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|range_entry_long
argument_list|)
argument_list|)
expr_stmt|;
name|fdesc
operator|->
name|base
operator|=
name|cdp
operator|->
name|cd_base
expr_stmt|;
name|di
operator|->
name|range_tbl_free
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|cdp
operator|->
name|cd_max_size
operator|>
name|size
operator|+
literal|0
condition|)
block|{
comment|/* XXX hardcoded const! */
comment|/* Alloc a new (empty) descriptor */
name|empty_cdp
operator|=
name|cdesc_alloc
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|empty_cdp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|empty_cdp
operator|->
name|cd_max_size
operator|=
name|cdp
operator|->
name|cd_max_size
operator|-
name|size
expr_stmt|;
name|empty_cdp
operator|->
name|cd_base
operator|=
name|cdp
operator|->
name|cd_base
operator|+
name|size
expr_stmt|;
name|empty_cdp
operator|->
name|cd_chunk_first
operator|=
operator|-
literal|1
expr_stmt|;
name|empty_cdp
operator|->
name|cd_cur_size
operator|=
literal|0
expr_stmt|;
name|LIST_INSERT_BEFORE
argument_list|(
name|cdp
argument_list|,
name|empty_cdp
argument_list|,
name|cd_all_le
argument_list|)
expr_stmt|;
name|LIST_INSERT_AFTER
argument_list|(
name|cdp
argument_list|,
name|empty_cdp
argument_list|,
name|cd_hash_le
argument_list|)
expr_stmt|;
name|cdp
operator|->
name|cd_max_size
operator|=
name|size
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|cdp
argument_list|,
name|cd_hash_le
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Alloc a new descriptor */
name|cdp
operator|=
name|cdesc_alloc
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|cdp
operator|->
name|cd_max_size
operator|=
name|size
expr_stmt|;
name|cdp
operator|->
name|cd_base
operator|=
name|fdesc
operator|->
name|base
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|di
operator|->
name|all_chunks
argument_list|,
name|cdp
argument_list|,
name|cd_all_le
argument_list|)
expr_stmt|;
block|}
name|cdp
operator|->
name|cd_hash
operator|=
name|hash
expr_stmt|;
name|cdp
operator|->
name|cd_refcount
operator|=
literal|1
expr_stmt|;
name|cdp
operator|->
name|cd_cur_size
operator|=
name|size
expr_stmt|;
name|cdp
operator|->
name|cd_chunk_first
operator|=
name|chunk
expr_stmt|;
name|di
operator|->
name|cptbl
index|[
name|chunk
index|]
operator|.
name|cp_cdp
operator|=
name|cdp
expr_stmt|;
name|di
operator|->
name|cptbl
index|[
name|chunk
index|]
operator|.
name|cp_chunk_next
operator|=
operator|-
literal|1
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|di
operator|->
name|chunk_hashtbl
index|[
name|hash
operator|&
name|CHUNK_HASH_MASK
index|]
argument_list|,
name|cdp
argument_list|,
name|cd_hash_le
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|chunk_unref
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|int
name|chunk
parameter_list|)
block|{
name|struct
name|direct_entry
modifier|*
name|fdesc
init|=
operator|&
name|di
operator|->
name|direct_tbl
index|[
name|chunk
index|]
decl_stmt|;
name|struct
name|chunk_desc
modifier|*
name|cdp
init|=
name|di
operator|->
name|cptbl
index|[
name|chunk
index|]
operator|.
name|cp_cdp
decl_stmt|;
name|struct
name|chunk_desc
modifier|*
name|unused_cdp
decl_stmt|;
name|int
name|size
init|=
name|fdesc
operator|->
name|fragments
operator|+
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|--
name|cdp
operator|->
name|cd_refcount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fdesc
operator|->
name|long_format
condition|)
block|{
name|di
operator|->
name|aggr_fragments_long
operator|-=
name|size
expr_stmt|;
name|di
operator|->
name|aggr_chunks_long
operator|--
expr_stmt|;
block|}
else|else
block|{
name|di
operator|->
name|aggr_fragments_short
operator|-=
operator|(
name|size
operator|<<
literal|1
operator|)
expr_stmt|;
name|di
operator|->
name|aggr_chunks_short
operator|--
expr_stmt|;
block|}
comment|/* Unlink chunk */
if|if
condition|(
name|cdp
operator|->
name|cd_chunk_first
operator|==
name|chunk
condition|)
block|{
name|cdp
operator|->
name|cd_chunk_first
operator|=
name|di
operator|->
name|cptbl
index|[
name|chunk
index|]
operator|.
name|cp_chunk_next
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|cdp
operator|->
name|cd_chunk_first
init|;
name|di
operator|->
name|cptbl
index|[
name|i
index|]
operator|.
name|cp_chunk_next
operator|!=
name|chunk
condition|;
name|i
operator|=
name|di
operator|->
name|cptbl
index|[
name|i
index|]
operator|.
name|cp_chunk_next
control|)
block|{}
empty_stmt|;
name|di
operator|->
name|cptbl
index|[
name|i
index|]
operator|.
name|cp_chunk_next
operator|=
name|di
operator|->
name|cptbl
index|[
name|chunk
index|]
operator|.
name|cp_chunk_next
expr_stmt|;
block|}
return|return;
block|}
name|LIST_REMOVE
argument_list|(
name|cdp
argument_list|,
name|cd_hash_le
argument_list|)
expr_stmt|;
name|cdp
operator|->
name|cd_chunk_first
operator|=
operator|-
literal|1
expr_stmt|;
name|cdp
operator|->
name|cd_cur_size
operator|=
literal|0
expr_stmt|;
comment|/* Keep unused chunks sorted with ascending base indices */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|di
operator|->
name|unused_chunks
argument_list|)
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|di
operator|->
name|unused_chunks
argument_list|,
name|cdp
argument_list|,
name|cd_hash_le
argument_list|)
expr_stmt|;
else|else
name|LIST_FOREACH
argument_list|(
argument|unused_cdp
argument_list|,
argument|&di->unused_chunks
argument_list|,
argument|cd_hash_le
argument_list|)
block|{
if|if
condition|(
name|unused_cdp
operator|->
name|cd_base
operator|>
name|cdp
operator|->
name|cd_base
condition|)
block|{
name|LIST_INSERT_BEFORE
argument_list|(
name|unused_cdp
argument_list|,
name|cdp
argument_list|,
name|cd_hash_le
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|unused_cdp
argument_list|,
name|cd_hash_le
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|unused_cdp
argument_list|,
name|cdp
argument_list|,
name|cd_hash_le
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Merge adjacent empty chunks */
if|if
condition|(
operator|(
name|unused_cdp
operator|=
name|LIST_NEXT
argument_list|(
name|cdp
argument_list|,
name|cd_all_le
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|cdp
operator|==
name|LIST_NEXT
argument_list|(
name|unused_cdp
argument_list|,
name|cd_hash_le
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|cdp
argument_list|,
name|cd_hash_le
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|cdp
argument_list|,
name|cd_all_le
argument_list|)
expr_stmt|;
name|unused_cdp
operator|->
name|cd_max_size
operator|+=
name|cdp
operator|->
name|cd_max_size
expr_stmt|;
name|cdesc_free
argument_list|(
name|di
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
name|cdp
operator|=
name|unused_cdp
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|unused_cdp
operator|=
name|LIST_NEXT
argument_list|(
name|cdp
argument_list|,
name|cd_hash_le
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|cdp
operator|==
name|LIST_NEXT
argument_list|(
name|unused_cdp
argument_list|,
name|cd_all_le
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|unused_cdp
argument_list|,
name|cd_hash_le
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|unused_cdp
argument_list|,
name|cd_all_le
argument_list|)
expr_stmt|;
name|cdp
operator|->
name|cd_max_size
operator|+=
name|unused_cdp
operator|->
name|cd_max_size
expr_stmt|;
name|cdesc_free
argument_list|(
name|di
argument_list|,
name|unused_cdp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fdesc
operator|->
name|long_format
condition|)
block|{
name|di
operator|->
name|chunks_long
operator|--
expr_stmt|;
name|di
operator|->
name|fragments_long
operator|-=
name|size
expr_stmt|;
block|}
else|else
block|{
name|di
operator|->
name|chunks_short
operator|--
expr_stmt|;
name|di
operator|->
name|fragments_short
operator|-=
operator|(
name|size
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|update_chunk
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|int
name|chunk
parameter_list|)
block|{
name|struct
name|direct_entry
modifier|*
name|fdesc
init|=
operator|&
name|di
operator|->
name|direct_tbl
index|[
name|chunk
index|]
decl_stmt|;
name|struct
name|range_entry_short
modifier|*
name|fp
decl_stmt|;
name|struct
name|dxr_heap_entry
modifier|*
name|fhp
decl_stmt|;
name|uint32_t
name|first
init|=
name|chunk
operator|<<
name|DXR_RANGE_SHIFT
decl_stmt|;
name|uint32_t
name|last
init|=
name|first
operator||
name|DXR_RANGE_MASK
decl_stmt|;
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
name|printf
argument_list|(
literal|"Updating chunk %05X\n"
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dxr_initheap
argument_list|(
name|di
argument_list|,
name|first
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdesc
operator|->
name|base
operator|<
name|BASE_MAX
condition|)
name|chunk_unref
argument_list|(
name|di
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|fdesc
operator|->
name|base
operator|=
name|di
operator|->
name|range_tbl_free
expr_stmt|;
name|fdesc
operator|->
name|fragments
operator|=
literal|0
expr_stmt|;
name|fdesc
operator|->
name|long_format
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|range_entry_short
operator|*
operator|)
operator|&
name|di
operator|->
name|range_tbl
index|[
name|di
operator|->
name|range_tbl_free
index|]
expr_stmt|;
name|fp
operator|->
name|start
operator|=
operator|(
name|first
operator|&
name|DXR_RANGE_MASK
operator|)
operator|>>
literal|8
expr_stmt|;
name|fp
operator|->
name|nexthop
operator|=
name|di
operator|->
name|dxr_heap
index|[
literal|0
index|]
operator|.
name|nexthop
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|f
operator|.
name|tree_walk
argument_list|(
name|di
operator|->
name|f
operator|.
name|tree_ptr
argument_list|,
name|di
argument_list|,
name|htonl
argument_list|(
name|first
argument_list|)
argument_list|,
name|htonl
argument_list|(
operator|~
name|DXR_RANGE_MASK
argument_list|)
argument_list|,
name|dxr_walk
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|long
operator|)
name|chunk
argument_list|)
operator|==
name|ERANGE
condition|)
block|{
name|update_chunk_long
argument_list|(
name|di
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Flush any remaining objects on the dxr_heap */
name|fp
operator|=
operator|(
expr|struct
name|range_entry_short
operator|*
operator|)
operator|&
name|di
operator|->
name|range_tbl
index|[
name|di
operator|->
name|range_tbl_free
index|]
operator|+
name|fdesc
operator|->
name|fragments
expr_stmt|;
name|fhp
operator|=
operator|&
name|di
operator|->
name|dxr_heap
index|[
name|di
operator|->
name|heap_index
index|]
expr_stmt|;
while|while
condition|(
name|fhp
operator|->
name|preflen
operator|>
name|DXR_DIRECT_BITS
condition|)
block|{
name|int
name|oend
init|=
name|fhp
operator|->
name|end
decl_stmt|;
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
name|printf
argument_list|(
literal|"  flushing heap, preflen=%d\n"
argument_list|,
name|fhp
operator|->
name|preflen
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|di
operator|->
name|heap_index
operator|>
literal|0
condition|)
block|{
name|fhp
operator|--
expr_stmt|;
name|di
operator|->
name|heap_index
operator|--
expr_stmt|;
block|}
else|else
name|dxr_initheap
argument_list|(
name|di
argument_list|,
name|fhp
operator|->
name|end
operator|+
literal|1
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|fhp
operator|->
name|end
operator|>
name|oend
operator|&&
name|fhp
operator|->
name|nexthop
operator|!=
name|fp
operator|->
name|nexthop
condition|)
block|{
comment|/* Have we crossed the upper chunk boundary? */
if|if
condition|(
name|oend
operator|>=
name|last
condition|)
break|break;
name|fp
operator|++
expr_stmt|;
name|fdesc
operator|->
name|fragments
operator|++
expr_stmt|;
name|fp
operator|->
name|start
operator|=
operator|(
operator|(
name|oend
operator|+
literal|1
operator|)
operator|&
name|DXR_RANGE_MASK
operator|)
operator|>>
literal|8
expr_stmt|;
name|fp
operator|->
name|nexthop
operator|=
name|fhp
operator|->
name|nexthop
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
name|dxr_heap_dump
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|dxr_chunk_dump
argument_list|(
name|di
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If the chunk contains only a single fragment, encode 	 * nexthop in the fragments field of the direct lookup table. 	 * In such a case we do not need to store the original chunk 	 * itself any more. 	 * 	 * The actual number of fragments is fdesc->fragments + 1. 	 */
if|if
condition|(
name|fdesc
operator|->
name|fragments
condition|)
block|{
if|if
condition|(
operator|(
name|fdesc
operator|->
name|fragments
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Align mpool_free on a 32 bit boundary */
name|fp
index|[
literal|1
index|]
operator|.
name|start
operator|=
name|fp
operator|->
name|start
expr_stmt|;
name|fp
index|[
literal|1
index|]
operator|.
name|nexthop
operator|=
name|fp
operator|->
name|nexthop
expr_stmt|;
name|fdesc
operator|->
name|fragments
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|di
operator|->
name|chunks_short
operator|++
expr_stmt|;
name|di
operator|->
name|fragments_short
operator|+=
operator|(
name|fdesc
operator|->
name|fragments
operator|+
literal|1
operator|)
expr_stmt|;
name|fdesc
operator|->
name|fragments
operator|>>=
literal|1
expr_stmt|;
name|di
operator|->
name|range_tbl_free
operator|+=
operator|(
name|fdesc
operator|->
name|fragments
operator|+
literal|1
operator|)
expr_stmt|;
name|chunk_ref
argument_list|(
name|di
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fdesc
operator|->
name|base
operator|=
name|BASE_MAX
expr_stmt|;
name|fdesc
operator|->
name|fragments
operator|=
name|fp
operator|->
name|nexthop
expr_stmt|;
block|}
name|di
operator|->
name|pending_bitmask
index|[
name|chunk
operator|>>
literal|5
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|chunk
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_chunk_long
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|int
name|chunk
parameter_list|)
block|{
name|struct
name|direct_entry
modifier|*
name|fdesc
init|=
operator|&
name|di
operator|->
name|direct_tbl
index|[
name|chunk
index|]
decl_stmt|;
name|struct
name|range_entry_long
modifier|*
name|fp
decl_stmt|;
name|struct
name|dxr_heap_entry
modifier|*
name|fhp
decl_stmt|;
name|uint32_t
name|first
init|=
name|chunk
operator|<<
name|DXR_RANGE_SHIFT
decl_stmt|;
name|uint32_t
name|last
init|=
name|first
operator||
name|DXR_RANGE_MASK
decl_stmt|;
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
name|printf
argument_list|(
literal|"Updating chunk %05X\n"
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dxr_initheap
argument_list|(
name|di
argument_list|,
name|first
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|fdesc
operator|->
name|base
operator|=
name|di
operator|->
name|range_tbl_free
expr_stmt|;
name|fdesc
operator|->
name|fragments
operator|=
literal|0
expr_stmt|;
name|fdesc
operator|->
name|long_format
operator|=
literal|1
expr_stmt|;
name|fp
operator|=
operator|&
name|di
operator|->
name|range_tbl
index|[
name|di
operator|->
name|range_tbl_free
index|]
expr_stmt|;
name|fp
operator|->
name|start
operator|=
name|first
operator|&
name|DXR_RANGE_MASK
expr_stmt|;
name|fp
operator|->
name|nexthop
operator|=
name|di
operator|->
name|dxr_heap
index|[
literal|0
index|]
operator|.
name|nexthop
expr_stmt|;
name|di
operator|->
name|f
operator|.
name|tree_walk
argument_list|(
name|di
operator|->
name|f
operator|.
name|tree_ptr
argument_list|,
name|di
argument_list|,
name|htonl
argument_list|(
name|first
argument_list|)
argument_list|,
name|htonl
argument_list|(
operator|~
name|DXR_RANGE_MASK
argument_list|)
argument_list|,
name|dxr_walk_long
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|long
operator|)
name|chunk
argument_list|)
expr_stmt|;
comment|/* Flush any remaining objects on the dxr_heap */
name|fp
operator|=
operator|&
name|di
operator|->
name|range_tbl
index|[
name|fdesc
operator|->
name|base
operator|+
name|fdesc
operator|->
name|fragments
index|]
expr_stmt|;
name|fhp
operator|=
operator|&
name|di
operator|->
name|dxr_heap
index|[
name|di
operator|->
name|heap_index
index|]
expr_stmt|;
while|while
condition|(
name|fhp
operator|->
name|preflen
operator|>
name|DXR_DIRECT_BITS
condition|)
block|{
name|int
name|oend
init|=
name|fhp
operator|->
name|end
decl_stmt|;
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
name|printf
argument_list|(
literal|"  flushing heap, preflen=%d\n"
argument_list|,
name|fhp
operator|->
name|preflen
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|di
operator|->
name|heap_index
operator|>
literal|0
condition|)
block|{
name|fhp
operator|--
expr_stmt|;
name|di
operator|->
name|heap_index
operator|--
expr_stmt|;
block|}
else|else
name|dxr_initheap
argument_list|(
name|di
argument_list|,
name|fhp
operator|->
name|end
operator|+
literal|1
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|fhp
operator|->
name|end
operator|>
name|oend
operator|&&
name|fhp
operator|->
name|nexthop
operator|!=
name|fp
operator|->
name|nexthop
condition|)
block|{
comment|/* Have we crossed the upper chunk boundary? */
if|if
condition|(
name|oend
operator|>=
name|last
condition|)
break|break;
name|fp
operator|++
expr_stmt|;
name|fdesc
operator|->
name|fragments
operator|++
expr_stmt|;
name|fp
operator|->
name|start
operator|=
operator|(
name|oend
operator|+
literal|1
operator|)
operator|&
name|DXR_RANGE_MASK
expr_stmt|;
name|fp
operator|->
name|nexthop
operator|=
name|fhp
operator|->
name|nexthop
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
name|dxr_heap_dump
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|dxr_chunk_dump
argument_list|(
name|di
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If the chunk contains only a single fragment, encode 	 * nexthop in the fragments field of the direct lookup table. 	 * In such a case we do not need to store the original chunk 	 * itself any more. 	 */
if|if
condition|(
name|fdesc
operator|->
name|fragments
condition|)
block|{
name|di
operator|->
name|chunks_long
operator|++
expr_stmt|;
name|di
operator|->
name|fragments_long
operator|+=
operator|(
name|fdesc
operator|->
name|fragments
operator|+
literal|1
operator|)
expr_stmt|;
name|di
operator|->
name|range_tbl_free
operator|+=
operator|(
name|fdesc
operator|->
name|fragments
operator|+
literal|1
operator|)
expr_stmt|;
name|chunk_ref
argument_list|(
name|di
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fdesc
operator|->
name|base
operator|=
name|BASE_MAX
expr_stmt|;
name|fdesc
operator|->
name|fragments
operator|=
name|fp
operator|->
name|nexthop
expr_stmt|;
block|}
name|di
operator|->
name|pending_bitmask
index|[
name|chunk
operator|>>
literal|5
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|chunk
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dxr_walk
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|in_addr_t
name|dst
parameter_list|,
name|in_addr_t
name|mask
parameter_list|,
name|int
name|nh
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|uint32_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|chunk
init|=
operator|(
name|long
operator|)
name|arg
decl_stmt|;
name|int
name|preflen
decl_stmt|;
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
name|print_in_route
argument_list|(
name|rt
argument_list|,
literal|"  dxr_walk"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|start
operator|=
name|ntohl
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|preflen
operator|=
name|ffs
argument_list|(
name|ntohl
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|preflen
condition|)
name|preflen
operator|=
literal|33
operator|-
name|preflen
expr_stmt|;
name|end
operator|=
name|start
operator||
operator|~
name|ntohl
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|preflen
operator|=
literal|32
expr_stmt|;
name|end
operator|=
name|start
expr_stmt|;
block|}
return|return
operator|(
name|dxr_parse
argument_list|(
name|di
argument_list|,
name|chunk
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|preflen
argument_list|,
name|nh
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dxr_walk_long
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|in_addr_t
name|dst
parameter_list|,
name|in_addr_t
name|mask
parameter_list|,
name|int
name|nh
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|uint32_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|chunk
init|=
operator|(
name|long
operator|)
name|arg
decl_stmt|;
name|int
name|preflen
decl_stmt|;
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
name|print_in_route
argument_list|(
name|rt
argument_list|,
literal|"  dxr_walk"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|start
operator|=
name|ntohl
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|preflen
operator|=
name|ffs
argument_list|(
name|ntohl
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|preflen
condition|)
name|preflen
operator|=
literal|33
operator|-
name|preflen
expr_stmt|;
name|end
operator|=
name|start
operator||
operator|~
name|ntohl
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|preflen
operator|=
literal|32
expr_stmt|;
name|end
operator|=
name|start
expr_stmt|;
block|}
return|return
operator|(
name|dxr_parse_long
argument_list|(
name|di
argument_list|,
name|chunk
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|preflen
argument_list|,
name|nh
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__inline
name|dxr_heap_inject
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|uint32_t
name|start
parameter_list|,
name|uint32_t
name|end
parameter_list|,
name|int
name|preflen
parameter_list|,
name|int
name|nh
parameter_list|)
block|{
name|struct
name|dxr_heap_entry
modifier|*
name|fhp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|di
operator|->
name|heap_index
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|preflen
operator|>
name|di
operator|->
name|dxr_heap
index|[
name|i
index|]
operator|.
name|preflen
condition|)
break|break;
elseif|else
if|if
condition|(
name|preflen
operator|<
name|di
operator|->
name|dxr_heap
index|[
name|i
index|]
operator|.
name|preflen
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|di
operator|->
name|dxr_heap
index|[
name|i
index|]
argument_list|,
operator|&
name|di
operator|->
name|dxr_heap
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dxr_heap_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
block|}
name|fhp
operator|=
operator|&
name|di
operator|->
name|dxr_heap
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|fhp
operator|->
name|preflen
operator|=
name|preflen
expr_stmt|;
name|fhp
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|fhp
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|fhp
operator|->
name|nexthop
operator|=
name|nh
expr_stmt|;
name|di
operator|->
name|heap_index
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dxr_parse
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|int
name|chunk
parameter_list|,
name|uint32_t
name|start
parameter_list|,
name|uint32_t
name|end
parameter_list|,
name|int
name|preflen
parameter_list|,
name|int
name|nh
parameter_list|)
block|{
name|struct
name|direct_entry
modifier|*
name|fdesc
decl_stmt|;
name|struct
name|range_entry_short
modifier|*
name|fp
decl_stmt|;
name|struct
name|dxr_heap_entry
modifier|*
name|fhp
decl_stmt|;
name|uint32_t
name|first
decl_stmt|;
name|uint32_t
name|last
decl_stmt|;
name|fdesc
operator|=
operator|&
name|di
operator|->
name|direct_tbl
index|[
name|chunk
index|]
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|range_entry_short
operator|*
operator|)
operator|&
name|di
operator|->
name|range_tbl
index|[
name|fdesc
operator|->
name|base
index|]
operator|+
name|fdesc
operator|->
name|fragments
expr_stmt|;
name|fhp
operator|=
operator|&
name|di
operator|->
name|dxr_heap
index|[
name|di
operator|->
name|heap_index
index|]
expr_stmt|;
name|first
operator|=
name|chunk
operator|<<
name|DXR_RANGE_SHIFT
expr_stmt|;
name|last
operator|=
name|first
operator||
name|DXR_RANGE_MASK
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|last
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Beyond chunk boundaries, we are done */
if|if
condition|(
name|start
operator|<
name|first
condition|)
return|return
literal|0
return|;
comment|/* Skip this route */
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
name|printf
argument_list|(
literal|"  dxr_parse %08X..%08X plen %d nexthop %d\n"
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|preflen
argument_list|,
name|nh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Switch to long format if needed */
if|if
condition|(
operator|(
name|start
operator|&
literal|0xff
operator|)
operator|||
name|end
operator|<
operator|(
name|start
operator||
literal|0xff
operator|)
operator|||
name|nh
operator|>
literal|0xff
condition|)
return|return
name|ERANGE
return|;
if|if
condition|(
name|start
operator|==
name|fhp
operator|->
name|start
condition|)
block|{
ifdef|#
directive|ifdef
name|DXR_BUILD_PARANOIC
if|if
condition|(
name|preflen
operator|>
name|fhp
operator|->
name|preflen
condition|)
block|{
comment|/* This MUST NEVER happen! */
name|panic
argument_list|(
literal|"XXX dxr_parse #1\n"
argument_list|)
expr_stmt|;
name|fp
operator|->
name|nexthop
operator|=
name|nh
expr_stmt|;
block|}
endif|#
directive|endif
name|dxr_heap_inject
argument_list|(
name|di
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|preflen
argument_list|,
name|nh
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DXR_BUILD_PARANOIC
block|}
elseif|else
if|if
condition|(
name|start
operator|<
name|fhp
operator|->
name|start
condition|)
block|{
comment|/* This MUST NEVER happen! */
name|panic
argument_list|(
literal|"XXX dxr_parse #2\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* start> fhp->start */
while|while
condition|(
name|start
operator|>
name|fhp
operator|->
name|end
condition|)
block|{
name|int
name|oend
init|=
name|fhp
operator|->
name|end
decl_stmt|;
if|if
condition|(
name|di
operator|->
name|heap_index
operator|>
literal|0
condition|)
block|{
name|fhp
operator|--
expr_stmt|;
name|di
operator|->
name|heap_index
operator|--
expr_stmt|;
block|}
else|else
name|dxr_initheap
argument_list|(
name|di
argument_list|,
name|fhp
operator|->
name|end
operator|+
literal|1
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|fhp
operator|->
name|end
operator|>
name|oend
operator|&&
name|fhp
operator|->
name|nexthop
operator|!=
name|fp
operator|->
name|nexthop
condition|)
block|{
name|fp
operator|++
expr_stmt|;
name|fdesc
operator|->
name|fragments
operator|++
expr_stmt|;
name|fp
operator|->
name|start
operator|=
operator|(
operator|(
name|oend
operator|+
literal|1
operator|)
operator|&
name|DXR_RANGE_MASK
operator|)
operator|>>
literal|8
expr_stmt|;
name|fp
operator|->
name|nexthop
operator|=
name|fhp
operator|->
name|nexthop
expr_stmt|;
block|}
block|}
if|if
condition|(
name|start
operator|>
operator|(
operator|(
name|chunk
operator|<<
name|DXR_RANGE_SHIFT
operator|)
operator||
operator|(
name|fp
operator|->
name|start
operator|<<
literal|8
operator|)
operator|)
operator|&&
name|nh
operator|!=
name|fp
operator|->
name|nexthop
condition|)
block|{
name|fp
operator|++
expr_stmt|;
name|fdesc
operator|->
name|fragments
operator|++
expr_stmt|;
name|fp
operator|->
name|start
operator|=
operator|(
name|start
operator|&
name|DXR_RANGE_MASK
operator|)
operator|>>
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fdesc
operator|->
name|fragments
condition|)
block|{
if|if
condition|(
operator|(
operator|--
name|fp
operator|)
operator|->
name|nexthop
operator|==
name|nh
condition|)
name|fdesc
operator|->
name|fragments
operator|--
expr_stmt|;
else|else
name|fp
operator|++
expr_stmt|;
block|}
name|fp
operator|->
name|nexthop
operator|=
name|nh
expr_stmt|;
name|dxr_heap_inject
argument_list|(
name|di
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|preflen
argument_list|,
name|nh
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
name|dxr_heap_dump
argument_list|(
name|di
argument_list|, )
expr_stmt|;
name|dxr_chunk_dump
argument_list|(
name|di
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dxr_parse_long
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|int
name|chunk
parameter_list|,
name|uint32_t
name|start
parameter_list|,
name|uint32_t
name|end
parameter_list|,
name|int
name|preflen
parameter_list|,
name|int
name|nh
parameter_list|)
block|{
name|struct
name|direct_entry
modifier|*
name|fdesc
decl_stmt|;
name|struct
name|range_entry_long
modifier|*
name|fp
decl_stmt|;
name|struct
name|dxr_heap_entry
modifier|*
name|fhp
decl_stmt|;
name|uint32_t
name|first
decl_stmt|;
name|uint32_t
name|last
decl_stmt|;
name|fdesc
operator|=
operator|&
name|di
operator|->
name|direct_tbl
index|[
name|chunk
index|]
expr_stmt|;
name|fp
operator|=
operator|&
name|di
operator|->
name|range_tbl
index|[
name|fdesc
operator|->
name|base
operator|+
name|fdesc
operator|->
name|fragments
index|]
expr_stmt|;
name|fhp
operator|=
operator|&
name|di
operator|->
name|dxr_heap
index|[
name|di
operator|->
name|heap_index
index|]
expr_stmt|;
name|first
operator|=
name|chunk
operator|<<
name|DXR_RANGE_SHIFT
expr_stmt|;
name|last
operator|=
name|first
operator||
name|DXR_RANGE_MASK
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|last
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Beyond chunk boundaries, we are done */
if|if
condition|(
name|start
operator|<
name|first
condition|)
return|return
literal|0
return|;
comment|/* Skip this route */
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
name|printf
argument_list|(
literal|"  dxr_parse %08X..%08X plen %d nexthop %d\n"
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|preflen
argument_list|,
name|nh
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|start
operator|==
name|fhp
operator|->
name|start
condition|)
block|{
ifdef|#
directive|ifdef
name|DXR_BUILD_PARANOIC
if|if
condition|(
name|preflen
operator|>
name|fhp
operator|->
name|preflen
condition|)
block|{
comment|/* This MUST NEVER happen! */
name|printf
argument_list|(
literal|"XXX dxr_parse #1\n"
argument_list|)
expr_stmt|;
name|fp
operator|->
name|nexthop
operator|=
name|nh
expr_stmt|;
block|}
endif|#
directive|endif
name|dxr_heap_inject
argument_list|(
name|di
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|preflen
argument_list|,
name|nh
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DXR_BUILD_PARANOIC
block|}
elseif|else
if|if
condition|(
name|start
operator|<
name|fhp
operator|->
name|start
condition|)
block|{
comment|/* This MUST NEVER happen! */
name|printf
argument_list|(
literal|"XXX dxr_parse #2\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* start> fhp->start */
while|while
condition|(
name|start
operator|>
name|fhp
operator|->
name|end
condition|)
block|{
name|int
name|oend
init|=
name|fhp
operator|->
name|end
decl_stmt|;
if|if
condition|(
name|di
operator|->
name|heap_index
operator|>
literal|0
condition|)
block|{
name|fhp
operator|--
expr_stmt|;
name|di
operator|->
name|heap_index
operator|--
expr_stmt|;
block|}
else|else
name|dxr_initheap
argument_list|(
name|di
argument_list|,
name|fhp
operator|->
name|end
operator|+
literal|1
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|fhp
operator|->
name|end
operator|>
name|oend
operator|&&
name|fhp
operator|->
name|nexthop
operator|!=
name|fp
operator|->
name|nexthop
condition|)
block|{
name|fp
operator|++
expr_stmt|;
name|fdesc
operator|->
name|fragments
operator|++
expr_stmt|;
name|fp
operator|->
name|start
operator|=
operator|(
name|oend
operator|+
literal|1
operator|)
operator|&
name|DXR_RANGE_MASK
expr_stmt|;
name|fp
operator|->
name|nexthop
operator|=
name|fhp
operator|->
name|nexthop
expr_stmt|;
block|}
block|}
if|if
condition|(
name|start
operator|>
operator|(
operator|(
name|chunk
operator|<<
name|DXR_RANGE_SHIFT
operator|)
operator||
name|fp
operator|->
name|start
operator|)
operator|&&
name|nh
operator|!=
name|fp
operator|->
name|nexthop
condition|)
block|{
name|fp
operator|++
expr_stmt|;
name|fdesc
operator|->
name|fragments
operator|++
expr_stmt|;
name|fp
operator|->
name|start
operator|=
name|start
operator|&
name|DXR_RANGE_MASK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fdesc
operator|->
name|fragments
condition|)
block|{
if|if
condition|(
operator|(
operator|--
name|fp
operator|)
operator|->
name|nexthop
operator|==
name|nh
condition|)
name|fdesc
operator|->
name|fragments
operator|--
expr_stmt|;
else|else
name|fp
operator|++
expr_stmt|;
block|}
name|fp
operator|->
name|nexthop
operator|=
name|nh
expr_stmt|;
name|dxr_heap_inject
argument_list|(
name|di
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|preflen
argument_list|,
name|nh
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
name|dxr_heap_dump
argument_list|(
name|di
argument_list|, )
expr_stmt|;
name|dxr_chunk_dump
argument_list|(
name|di
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|apply_pending
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|mask
decl_stmt|,
name|bit
decl_stmt|;
name|TREE_LOCK_ASSERT
argument_list|(
name|di
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|di
operator|->
name|pending_start
operator|>>
literal|5
init|;
name|i
operator|<=
name|di
operator|->
name|pending_end
operator|>>
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|mask
operator|=
name|di
operator|->
name|pending_bitmask
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mask
condition|)
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|bit
operator|=
literal|1
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mask
operator|&
name|bit
operator|)
condition|)
name|update_chunk
argument_list|(
name|di
argument_list|,
operator|(
name|i
operator|<<
literal|5
operator|)
operator|+
name|j
argument_list|)
expr_stmt|;
name|bit
operator|+=
name|bit
expr_stmt|;
comment|/* bit<<= 1 */
block|}
block|}
name|di
operator|->
name|pending_start
operator|=
name|DIRECT_TBL_SIZE
expr_stmt|;
name|di
operator|->
name|pending_end
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static uint16_t nexthop_ref_rte(struct rtentry *rte) { 	struct sockaddr_in *in_gw = SIN(rt->rt_gateway); 	int16_t nh;  	if (in_gw->sin_family != AF_INET) 		nh = nexthop_ref((struct in_addr) {0}, rt->rt_ifp); 	else 		nh = nexthop_ref(in_gw->sin_addr, rt->rt_ifp);  	return (nh); }  static uint16_t nexthop_find(struct in_addr gw, struct ifnet *ifp) { 	int16_t nh_i;
comment|/* Search for an existing entry */
end_comment

begin_comment
unit|for (nh_i = nexthop_head; nh_i>= 0; nh_i = nexthop_tbl[nh_i].ll_next) 		if (gw.s_addr == nexthop_tbl[nh_i].gw.s_addr&& 		    ifp == nexthop_tbl[nh_i].ifp) 			break;  	return (nh_i); }  static uint16_t nexthop_ref(struct in_addr gw, struct ifnet *ifp) { 	int16_t nh_i;  	RADIX_NODE_HEAD_LOCK_ASSERT(rt_tables_get_rnh(0, AF_INET));  	nh_i = nexthop_find(gw, ifp);  	if (nh_i>= 0) 		nexthop_tbl[nh_i].refcount++; 	else {
comment|/* The ifnet must not disappear as long as the nexthop exists */
end_comment

begin_comment
unit|if_ref(ifp);
comment|/* Create a new nexthop entry */
end_comment

begin_comment
unit|if (nexthop_empty_head>= 0) { 			nh_i = nexthop_empty_head; 			nexthop_empty_head = nexthop_tbl[nh_i].ll_next; 		} else 			nh_i = nexthop_tbl_size++; 		nexthops++;  		nexthop_tbl[nh_i].refcount = 1; 		nexthop_tbl[nh_i].gw = gw; 		nexthop_tbl[nh_i].ifp = ifp;
comment|/* Add the entry to the nexthop linked list */
end_comment

begin_comment
unit|nexthop_tbl[nh_i].ll_prev = -1; 		nexthop_tbl[nh_i].ll_next = nexthop_head; 		if (nexthop_head>= 0) 			nexthop_tbl[nexthop_head].ll_prev = nh_i; 		nexthop_head = nh_i; 	} 	return (nh_i); }  static int nexthop_unref(uint16_t nh_i) { 	int refc;  	TREE_LOCK_ASSERT(di);  	if ((refc = --nexthop_tbl[nh_i].refcount) == 0) { 		int16_t prev, next;
comment|/* Let the ifnet go */
end_comment

begin_comment
unit|if_rele(nexthop_tbl[nh_i].ifp); 		nexthop_tbl[nh_i].ifp = NULL;
comment|/* Prune our entry from the nexthop list */
end_comment

begin_comment
unit|prev = nexthop_tbl[nh_i].ll_prev; 		next = nexthop_tbl[nh_i].ll_next; 		if (prev>= 0) 			nexthop_tbl[prev].ll_next = next; 		else 			nexthop_head = next; 		if (next>= 0) 			nexthop_tbl[next].ll_prev = prev;
comment|/* Add the entry to empty nexthop list */
end_comment

begin_endif
unit|nexthop_tbl[nh_i].ll_next = nexthop_empty_head; 		nexthop_empty_head = nh_i;  		nexthops--; 	} 	return (refc); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|dxr_mincore
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|vm_paddr_t
name|locked_pa
decl_stmt|;
name|pmap_t
name|pmap
init|=
name|vmspace_pmap
argument_list|(
name|curthread
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
decl_stmt|;
name|locked_pa
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|pmap_mincore
argument_list|(
name|pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|,
operator|&
name|locked_pa
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|dxr_instance
modifier|*
name|dxr_init
parameter_list|(
name|struct
name|malloc_type
modifier|*
name|mtype
parameter_list|,
name|int
name|mflag
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct proc *p = NULL; 	struct thread *td;
endif|#
directive|endif
name|struct
name|dxr_instance
modifier|*
name|di
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* Allocate memory for DXR lookup tables */
if|if
condition|(
operator|(
name|di
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|di
argument_list|)
argument_list|,
name|mtype
argument_list|,
name|mflag
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|di
operator|->
name|direct_tbl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|di
operator|->
name|direct_tbl
argument_list|)
operator|*
name|DIRECT_TBL_SIZE
argument_list|,
name|mtype
argument_list|,
name|mflag
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|di
operator|->
name|range_tbl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|di
operator|->
name|range_tbl
argument_list|)
operator|*
operator|(
name|BASE_MAX
operator|+
literal|1
operator|)
argument_list|,
name|mtype
argument_list|,
name|mflag
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|di
operator|->
name|nexthop_tbl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|di
operator|->
name|nexthop_tbl
argument_list|)
operator|*
name|DXR_VPORTS_MAX
argument_list|,
name|mtype
argument_list|,
name|mflag
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|direct_tbl
operator|==
name|NULL
operator|||
name|di
operator|->
name|range_tbl
operator|==
name|NULL
operator|||
name|di
operator|->
name|nexthop_tbl
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"alloc DXR state failed!\n"
argument_list|)
expr_stmt|;
goto|goto
name|free
goto|;
block|}
ifdef|#
directive|ifdef
name|DIR_24_8
comment|/* Allocate memory for DIR_24_8 lookup tables */
name|di
operator|->
name|tbl_0_23
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|di
operator|->
name|tbl_0_23
argument_list|)
operator|*
operator|(
literal|1
operator|<<
literal|24
operator|)
argument_list|,
name|mtype
argument_list|,
name|mflag
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|di
operator|->
name|tbl_24_31
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|di
operator|->
name|tbl_24_31
argument_list|)
operator|*
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|*
operator|(
literal|1
operator|<<
literal|15
operator|)
argument_list|,
name|mtype
argument_list|,
name|mflags
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|tbl_0_23
operator|==
name|NULL
operator|||
name|di
operator|->
name|tbl_24_31
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"alloc DIR_24_8 state failed!\n"
argument_list|)
expr_stmt|;
goto|goto
name|free
goto|;
block|}
endif|#
directive|endif
comment|/* nexthop_tbl[0] is always used for default route */
comment|/* True by default */
if|#
directive|if
literal|0
block|di->nexthop_tbl[0].gw.s_addr = 0; 	di->nexthop_tbl[0].ifp = NULL;
comment|/* Init default = discard */
block|di->nexthop_tbl[0].refcount = 0;
comment|/* must never be referenced! */
endif|#
directive|endif
name|di
operator|->
name|dxr_enable
operator|=
literal|1
expr_stmt|;
name|di
operator|->
name|async_updates
operator|=
literal|0
expr_stmt|;
comment|/*  use SYNC updates for tables */
name|di
operator|->
name|nexthops
operator|=
literal|0
expr_stmt|;
comment|/* counter for non-default nexthops */
name|di
operator|->
name|nexthop_tbl_size
operator|=
literal|1
expr_stmt|;
comment|/* First empty slot */
name|di
operator|->
name|nexthop_head
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* No allocated nexthops */
name|di
operator|->
name|nexthop_empty_head
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Recycle queue empty */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DIRECT_TBL_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|di
operator|->
name|direct_tbl
index|[
name|i
index|]
operator|.
name|base
operator|=
name|BASE_MAX
expr_stmt|;
name|di
operator|->
name|direct_tbl
index|[
name|i
index|]
operator|.
name|fragments
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|di
operator|->
name|pending_bitmask
argument_list|,
sizeof|sizeof
argument_list|(
name|di
operator|->
name|pending_bitmask
argument_list|)
argument_list|)
expr_stmt|;
name|di
operator|->
name|pending_start
operator|=
name|DIRECT_TBL_SIZE
expr_stmt|;
name|di
operator|->
name|pending_end
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|bzero(&dxr_intrq, sizeof(dxr_intrq)); 	dxr_intrq.ifq_maxlen = 256;
comment|/* XXX -> tunable */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DXR_BUILD_TIMING
name|bzero
argument_list|(
name|di
operator|->
name|update_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|di
operator|->
name|update_stats
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|DXR_ITER_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|RADIX_TIMING
argument_list|)
if|#
directive|if
literal|0
block|di->dlp = malloc(sizeof(*di->dlp) * DUMMY_MEM_SIZE, mtype, 	    mflag | M_ZERO); 	if (di->dlp == NULL) { 		printf("malloc(%llu) failed for dummy lookup memory\n", 		    (long long) sizeof(*di->dlp) * DUMMY_MEM_SIZE); 		goto free; 	} 	else { 		uint64_t start = rdtsc(); 		uint32_t dst;
comment|/* Populate with uniformly random (legal) IPv4 addresses */
block|for (i = 0; i< DUMMY_MEM_SIZE; i++) { 			dst = arc4random(); 			if (dst>> 24 == 0 || dst>> 24 == 10 ||  			    dst>> 24 == 127 || dst>> 24>= 224) 				dst = 0; 			di->dlp[i] = dst; 		}
comment|/* Fix missing keys */
block|for (i = 0; i< DUMMY_MEM_SIZE; i++) { 			for (dst = di->dlp[i]; 			    dst>> 24 == 0 || dst>> 24 == 10 ||  			    dst>> 24 == 127 || dst>> 24>= 224; 			    di->dlp[i] = dst) { 				dst = arc4random(); 			} 		} 		printf("dummy random lookup block initialized:" 		    " %d elements in %llu cycles\n", DUMMY_MEM_SIZE, 		    (long long) (rdtsc() - start)); 	}  	bzero(iter_stats, sizeof(iter_stats));  	for (i = 0; i< mp_ncpus; i++) { 		p = NULL; 		if (kproc_kthread_add(dxr_lookup_exercise, 		    (void *) (size_t) i,&p,&td, RFHIGHPID, 0, 		    "dxr_exercise", "dxr_exercise")) 			panic("Can't create the exerciser thread"); 	}
endif|#
directive|endif
endif|#
directive|endif
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|100
condition|;
name|k
operator|++
control|)
block|{
name|i
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
name|j
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
block|}
name|rdtsc_latency
operator|=
name|j
operator|-
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"rdtsc() latency estimated at %d ticks\n"
argument_list|,
name|rdtsc_latency
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mincore(range_tbl) = %08x\n"
argument_list|,
name|dxr_mincore
argument_list|(
name|di
operator|->
name|range_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mincore(direct_tbl)= %08x\n"
argument_list|,
name|dxr_mincore
argument_list|(
name|di
operator|->
name|direct_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mincore(nexthop_tbl)= %08x\n"
argument_list|,
name|dxr_mincore
argument_list|(
name|di
operator|->
name|nexthop_tbl
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIR_24_8
name|printf
argument_list|(
literal|"mincore(tbl_0_23)= %08x\n"
argument_list|,
name|dxr_mincore
argument_list|(
name|di
operator|->
name|tbl_0_23
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mincore(tbl_24_31)= %08x\n"
argument_list|,
name|dxr_mincore
argument_list|(
name|di
operator|->
name|tbl_24_31
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|DXR_ITER_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|RADIX_TIMING
argument_list|)
comment|//printf("mincore(dlp) = %08x\n", dxr_mincore(di->dlp));
endif|#
directive|endif
name|di_c
operator|=
name|di
expr_stmt|;
return|return
operator|(
name|di
operator|)
return|;
name|free
label|:
name|free
argument_list|(
name|di
operator|->
name|direct_tbl
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|range_tbl
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|nexthop_tbl
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIR_24_8
name|free
argument_list|(
name|di
operator|->
name|tbl_0_23
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|tbl_24_31
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|di
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dxr_setfuncs
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|struct
name|dxr_funcs
modifier|*
name|f
parameter_list|)
block|{
name|di
operator|->
name|f
operator|=
operator|*
name|f
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dxr_destroy
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|struct
name|malloc_type
modifier|*
name|mtype
parameter_list|)
block|{
name|struct
name|chunk_desc
modifier|*
name|cdp
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHUNK_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|cdp
argument_list|,
argument|&di->chunk_hashtbl[i]
argument_list|,
argument|cd_hash_le
argument_list|,
argument|tmp
argument_list|)
name|cdesc_free
argument_list|(
name|di
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH_SAFE
argument_list|(
argument|cdp
argument_list|,
argument|&di->unused_chunks
argument_list|,
argument|cd_hash_le
argument_list|,
argument|tmp
argument_list|)
name|cdesc_free
argument_list|(
name|di
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|direct_tbl
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|range_tbl
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|nexthop_tbl
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIR_24_8
name|free
argument_list|(
name|di
operator|->
name|tbl_0_23
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|tbl_24_31
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|DXR_ITER_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|RADIX_TIMING
argument_list|)
name|free
argument_list|(
name|di
operator|->
name|dlp
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|di
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
name|di_c
operator|=
operator|&
name|di_blank
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|dxr_instance
modifier|*
name|dxr_guess_instance
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|di_c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Our sysctl interface - provides access to a few important state  * and / or performance indicators / counters / statistics, as  * well as read access to individual DXR entries (.rd_entry sysctl).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSCTL_NODE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|dxr_memory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|direct_bits
init|=
name|DXR_DIRECT_BITS
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|sysctl_dxr_enable
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_dxr_memory
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_dxr_readentry
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_dxr_printstruct
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|DXR_ITER_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|RADIX_TIMING
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|sysctl_dxr_iterstats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DXR_BUILD_TIMING
end_ifdef

begin_function_decl
specifier|static
name|int
name|sysctl_dxr_updatestats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet_ip
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet_ip
argument_list|,
name|OID_AUTO
argument_list|,
name|dxr
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"DXR"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_dxr
argument_list|,
name|OID_AUTO
argument_list|,
name|direct_bits
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|direct_bits
argument_list|,
literal|0
argument_list|,
literal|"Number of IPv4 MS bits resolved by direct lookup"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_dxr
argument_list|,
name|OID_AUTO
argument_list|,
name|enable
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_dxr_enable
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|DXR_ITER_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|RADIX_TIMING
argument_list|)
end_if

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_dxr
argument_list|,
name|OID_AUTO
argument_list|,
name|reduce
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|reduce
argument_list|,
literal|0
argument_list|,
literal|"Reduce random keys to those resolvable by binary search"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|SYSCTL_INT(_net_inet_ip_dxr, OID_AUTO, async_updates, CTLFLAG_RW,     di_c->async_updates, 0, "Coalesce route table update requests"); SYSCTL_INT(_net_inet_ip_dxr, OID_AUTO, routes, CTLFLAG_RD,&di->routes, 0, "Number of routes in DXR FIB"); SYSCTL_INT(_net_inet_ip_dxr, OID_AUTO, nexthops, CTLFLAG_RD,&di->nexthops, 0, "Number of next hops used by DXR FIB");  SYSCTL_INT(_net_inet_ip_dxr, OID_AUTO, chunks_short, CTLFLAG_RD,&di->chunks_short, 0, "Number of 16-bit DXR range chunks"); SYSCTL_INT(_net_inet_ip_dxr, OID_AUTO, chunks_long, CTLFLAG_RD,&di->chunks_long, 0, "Number of 32-bit DXR range chunks"); SYSCTL_INT(_net_inet_ip_dxr, OID_AUTO, fragments_short, CTLFLAG_RD,&di->fragments_short, 0, "Number of 16-bit DXR range fragments"); SYSCTL_INT(_net_inet_ip_dxr, OID_AUTO, fragments_long, CTLFLAG_RD,&di->fragments_long, 0, "Number of 32-bit DXR range fragments");  SYSCTL_INT(_net_inet_ip_dxr, OID_AUTO, aggr_chunks_short, CTLFLAG_RD,&di->aggr_chunks_short, 0, "Number of aggregated 16-bit DXR range chunks"); SYSCTL_INT(_net_inet_ip_dxr, OID_AUTO, aggr_chunks_long, CTLFLAG_RD,&di->aggr_chunks_long, 0, "Number of aggregated 32-bit DXR range chunks"); SYSCTL_INT(_net_inet_ip_dxr, OID_AUTO, aggr_fragments_short, CTLFLAG_RD,&di->aggr_fragments_short, 0,     "Number of aggregated 16-bit DXR range fragments"); SYSCTL_INT(_net_inet_ip_dxr, OID_AUTO, aggr_fragments_long, CTLFLAG_RD,&di->aggr_fragments_long, 0,     "Number of aggregated 32-bit DXR range fragments");
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_dxr
argument_list|,
name|OID_AUTO
argument_list|,
name|printstruct
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_dxr_printstruct
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_dxr
argument_list|,
name|OID_AUTO
argument_list|,
name|memory
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_dxr_memory
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|SYSCTL_NODE(_net_inet_ip_dxr, OID_AUTO, stats, CTLFLAG_RW, 0,     "DXR counters and stats"); SYSCTL_INT(_net_inet_ip_dxr_stats, OID_AUTO, local, CTLFLAG_RD,&di->dxr_stats.local, 0, "Number of packets for local addresses"); SYSCTL_INT(_net_inet_ip_dxr_stats, OID_AUTO, slowpath, CTLFLAG_RD,&di->dxr_stats.slowpath, 0, "Number of packets propagated to slowpath"); SYSCTL_INT(_net_inet_ip_dxr_stats, OID_AUTO, fastpath, CTLFLAG_RD,&di->dxr_stats.fastpath, 0, "Number of packets forwarded using DXR lookups"); SYSCTL_INT(_net_inet_ip_dxr_stats, OID_AUTO, no_route, CTLFLAG_RD,&di->dxr_stats.no_route, 0, "Number of packets dropped"); SYSCTL_INT(_net_inet_ip_dxr_stats, OID_AUTO, input_errs, CTLFLAG_RD,&di->dxr_stats.input_errs, 0, "Number of packets dropped"); SYSCTL_INT(_net_inet_ip_dxr_stats, OID_AUTO, output_errs, CTLFLAG_RD,&di->dxr_stats.output_errs, 0, "Number of packets dropped");
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|DXR_ITER_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|RADIX_TIMING
argument_list|)
end_if

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_dxr
argument_list|,
name|OID_AUTO
argument_list|,
name|rdtsc_latency
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|rdtsc_latency
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_dxr
argument_list|,
name|OID_AUTO
argument_list|,
name|ex_threads
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ex_threads
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_dxr
argument_list|,
name|OID_AUTO
argument_list|,
name|ex_preload
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ex_preload
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_dxr
argument_list|,
name|OID_AUTO
argument_list|,
name|ex_iters
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ex_iters
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_dxr
argument_list|,
name|OID_AUTO
argument_list|,
name|iterstats
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_dxr_iterstats
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DXR_BUILD_TIMING
end_ifdef

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_dxr
argument_list|,
name|OID_AUTO
argument_list|,
name|updatestats
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_dxr_updatestats
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_dxr
argument_list|,
name|OID_AUTO
argument_list|,
name|rdentry
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_dxr_readentry
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_dxr_enable
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|new_state
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|dxr_instance
modifier|*
name|di
decl_stmt|;
if|if
condition|(
operator|(
name|di
operator|=
name|dxr_guess_instance
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|new_state
operator|=
name|di
operator|->
name|dxr_enable
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new_state
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|req
operator|->
name|newptr
operator|&&
name|new_state
operator|!=
name|di
operator|->
name|dxr_enable
condition|)
block|{
switch|switch
condition|(
name|new_state
condition|)
block|{
case|case
literal|0
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DIRECT_TBL_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|di
operator|->
name|direct_tbl
index|[
name|i
index|]
operator|.
name|base
operator|=
name|BASE_MAX
expr_stmt|;
name|di
operator|->
name|direct_tbl
index|[
name|i
index|]
operator|.
name|fragments
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
name|di
operator|->
name|pending_bitmask
argument_list|,
sizeof|sizeof
argument_list|(
name|di
operator|->
name|pending_bitmask
argument_list|)
argument_list|)
expr_stmt|;
name|di
operator|->
name|pending_start
operator|=
name|DIRECT_TBL_SIZE
expr_stmt|;
name|di
operator|->
name|pending_end
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|fragments_short
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|fragments_long
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|range_tbl_free
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|dxr_enable
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|DXR_ITER_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|RADIX_TIMING
argument_list|)
name|bzero
argument_list|(
name|iter_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|iter_stats
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DXR_BUILD_TIMING
name|bzero
argument_list|(
name|di
operator|->
name|update_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|di
operator|->
name|update_stats
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
operator|&
name|di
operator|->
name|dxr_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|di
operator|->
name|dxr_stats
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|di
operator|->
name|pending_bitmask
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|di
operator|->
name|pending_bitmask
argument_list|)
argument_list|)
expr_stmt|;
name|di
operator|->
name|pending_start
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|pending_end
operator|=
name|DIRECT_TBL_SIZE
operator|-
literal|1
expr_stmt|;
name|apply_pending
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|di
operator|->
name|dxr_enable
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_dxr_memory
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|dxr_instance
modifier|*
name|di
decl_stmt|;
if|if
condition|(
operator|(
name|di
operator|=
name|dxr_guess_instance
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|int
name|error
init|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|dxr_memory
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|dxr_memory
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|di
operator|->
name|direct_tbl
argument_list|)
operator|*
name|DIRECT_TBL_SIZE
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|di
operator|->
name|range_tbl
argument_list|)
operator|*
name|di
operator|->
name|range_tbl_free
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|di
operator|->
name|nexthop_tbl
argument_list|)
operator|*
operator|(
name|di
operator|->
name|nexthops
operator|+
literal|1
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_dxr_printstruct
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|e
decl_stmt|;
name|struct
name|dxr_instance
modifier|*
name|di
decl_stmt|;
if|if
condition|(
operator|(
name|di
operator|=
name|dxr_guess_instance
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|e
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* print ALL stats */
name|printf
argument_list|(
literal|"-- --\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"async_updates: %d\n"
argument_list|,
name|di
operator|->
name|async_updates
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"routes: %d\n"
argument_list|,
name|di
operator|->
name|routes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"nexthops: %d\n"
argument_list|,
name|di
operator|->
name|nexthops
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"chunks_short: %d\n"
argument_list|,
name|di
operator|->
name|chunks_short
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"chunks_long: %d\n"
argument_list|,
name|di
operator|->
name|chunks_long
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fragments_short: %d\n"
argument_list|,
name|di
operator|->
name|fragments_short
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fragments_long: %d\n"
argument_list|,
name|di
operator|->
name|fragments_long
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"aggr_chunks_short: %d\n"
argument_list|,
name|di
operator|->
name|aggr_chunks_short
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"aggr_chunks_long: %d\n"
argument_list|,
name|di
operator|->
name|aggr_chunks_long
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"aggr_fragments_short: %d\n"
argument_list|,
name|di
operator|->
name|aggr_fragments_short
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"aggr_fragments_long: %d\n"
argument_list|,
name|di
operator|->
name|aggr_fragments_long
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_dxr_readentry
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|dxr_instance
modifier|*
name|di
decl_stmt|;
if|if
condition|(
operator|(
name|di
operator|=
name|dxr_guess_instance
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
condition|)
block|{
name|struct
name|range_entry_short
modifier|*
name|dxr_short
decl_stmt|;
name|struct
name|range_entry_long
modifier|*
name|dxr_long
decl_stmt|;
name|int
name|nh
decl_stmt|,
name|next
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
block|struct ifnet *ifp; 		struct in_addr gw;
endif|#
directive|endif
name|char
modifier|*
name|c
init|=
name|index
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|int
name|chunk
init|=
name|strtol
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|chunk
operator|>=
name|DIRECT_TBL_SIZE
condition|)
return|return
name|ERANGE
return|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|chunk
operator|<
literal|0
operator|||
name|chunk
operator|>=
name|DIRECT_TBL_SIZE
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|c
operator|++
expr_stmt|;
name|i
operator|=
name|strtol
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|di
operator|->
name|direct_tbl
index|[
name|chunk
index|]
operator|.
name|fragments
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|di
operator|->
name|direct_tbl
index|[
name|chunk
index|]
operator|.
name|base
operator|==
name|BASE_MAX
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|dxr_long
operator|=
operator|&
name|di
operator|->
name|range_tbl
index|[
name|di
operator|->
name|direct_tbl
index|[
name|chunk
index|]
operator|.
name|base
index|]
expr_stmt|;
name|dxr_short
operator|=
operator|(
expr|struct
name|range_entry_short
operator|*
operator|)
name|dxr_long
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|direct_tbl
index|[
name|chunk
index|]
operator|.
name|base
operator|!=
name|BASE_MAX
condition|)
block|{
if|if
condition|(
name|di
operator|->
name|direct_tbl
index|[
name|chunk
index|]
operator|.
name|long_format
condition|)
block|{
name|nh
operator|=
name|dxr_long
index|[
name|i
index|]
operator|.
name|nexthop
expr_stmt|;
name|next
operator|+=
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
literal|"%d.%d: %08X -> "
argument_list|,
name|chunk
argument_list|,
name|i
argument_list|,
name|dxr_long
index|[
name|i
index|]
operator|.
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nh
operator|=
name|dxr_short
index|[
name|i
index|]
operator|.
name|nexthop
expr_stmt|;
name|next
operator|+=
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
literal|"%d.%d: %08X -> "
argument_list|,
name|chunk
argument_list|,
name|i
argument_list|,
name|dxr_short
index|[
name|i
index|]
operator|.
name|start
operator|<<
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nh
operator|=
name|di
operator|->
name|direct_tbl
index|[
name|chunk
index|]
operator|.
name|fragments
expr_stmt|;
name|next
operator|+=
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
literal|"%d.%d: %08X -> "
argument_list|,
name|chunk
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
operator|&
name|buf
index|[
name|next
index|]
argument_list|,
literal|"nh=%d"
argument_list|,
name|nh
argument_list|)
expr_stmt|;
comment|/* 		ifp = di->nexthop_tbl[nh].ifp; 		gw = di->nexthop_tbl[nh].gw;  		next += sprintf(&buf[next], "%d:", nh); 		if (ifp)  { 			next += sprintf(&buf[next], "%s", ifp->if_xname); 			if (gw.s_addr) 				sprintf(&buf[next], " %s", inet_ntoa(gw)); 		} else 			sprintf(&buf[next], "DISCARD"); */
name|count
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
name|count
operator|--
expr_stmt|;
else|else
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|DXR_ITER_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|RADIX_TIMING
argument_list|)
end_if

begin_function
specifier|static
name|int
name|sysctl_dxr_iterstats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|iter_stat
name|stats
index|[
literal|32
index|]
decl_stmt|;
name|uint64_t
name|pcpu_cycles
index|[
literal|32
index|]
decl_stmt|;
name|uint64_t
name|sum_cnt
init|=
literal|0
decl_stmt|;
name|uint64_t
name|sum_cycles
init|=
literal|0
decl_stmt|;
name|uint64_t
name|p
decl_stmt|,
name|c
decl_stmt|,
name|l
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cpu
decl_stmt|,
name|active_cpus
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|dxr_instance
modifier|*
name|di
decl_stmt|;
if|if
condition|(
operator|(
name|di
operator|=
name|dxr_guess_instance
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|bzero
argument_list|(
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|mp_ncpus
condition|;
name|cpu
operator|++
control|)
block|{
name|pcpu_cycles
index|[
name|cpu
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|DXR_DIRECT_BITS
condition|;
name|i
operator|++
control|)
block|{
name|sum_cnt
operator|+=
name|iter_stats
index|[
name|cpu
index|]
index|[
name|i
index|]
operator|.
name|cnt
expr_stmt|;
name|stats
index|[
name|i
index|]
operator|.
name|cnt
operator|+=
name|iter_stats
index|[
name|cpu
index|]
index|[
name|i
index|]
operator|.
name|cnt
expr_stmt|;
name|pcpu_cycles
index|[
name|cpu
index|]
operator|+=
name|iter_stats
index|[
name|cpu
index|]
index|[
name|i
index|]
operator|.
name|cycles
expr_stmt|;
name|stats
index|[
name|i
index|]
operator|.
name|cycles
operator|+=
name|iter_stats
index|[
name|cpu
index|]
index|[
name|i
index|]
operator|.
name|cycles
expr_stmt|;
block|}
name|sum_cycles
operator|+=
name|pcpu_cycles
index|[
name|cpu
index|]
expr_stmt|;
if|if
condition|(
name|pcpu_cycles
index|[
name|cpu
index|]
condition|)
name|active_cpus
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sum_cnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\niters:  %% hits     total hits     total cycles"
literal|"   cyc/lkp    M lkp/s"
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|DXR_DIRECT_BITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stats
index|[
name|i
index|]
operator|.
name|cnt
operator|==
literal|0
condition|)
continue|continue;
name|p
operator|=
name|stats
index|[
name|i
index|]
operator|.
name|cnt
operator|*
literal|100000
operator|/
name|sum_cnt
expr_stmt|;
name|c
operator|=
name|stats
index|[
name|i
index|]
operator|.
name|cycles
operator|*
literal|100
operator|/
name|stats
index|[
name|i
index|]
operator|.
name|cnt
expr_stmt|;
name|l
operator|=
name|tsc_freq
operator|/
name|c
operator|*
name|active_cpus
operator|/
literal|10
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n%5u: %3u.%03u %14llu %16llu %6u.%02u"
literal|"   %4u.%03u"
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|p
operator|/
literal|1000
argument_list|,
operator|(
name|int
operator|)
name|p
operator|%
literal|1000
argument_list|,
operator|(
name|long
name|long
operator|)
name|stats
index|[
name|i
index|]
operator|.
name|cnt
argument_list|,
operator|(
name|long
name|long
operator|)
name|stats
index|[
name|i
index|]
operator|.
name|cycles
argument_list|,
operator|(
name|int
operator|)
name|c
operator|/
literal|100
argument_list|,
operator|(
name|int
operator|)
name|c
operator|%
literal|100
argument_list|,
operator|(
name|int
operator|)
name|l
operator|/
literal|1000
argument_list|,
operator|(
name|int
operator|)
name|l
operator|%
literal|1000
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|p
operator|=
literal|100000
expr_stmt|;
name|c
operator|=
name|sum_cycles
operator|*
literal|100
operator|/
name|sum_cnt
expr_stmt|;
name|l
operator|=
name|tsc_freq
operator|/
name|c
operator|*
name|active_cpus
operator|/
literal|10
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n  avg: %3u.%03u %14llu %16llu %6u.%02u   %4u.%03u"
argument_list|,
operator|(
name|int
operator|)
name|p
operator|/
literal|1000
argument_list|,
operator|(
name|int
operator|)
name|p
operator|%
literal|1000
argument_list|,
operator|(
name|long
name|long
operator|)
name|sum_cnt
argument_list|,
operator|(
name|long
name|long
operator|)
name|sum_cycles
argument_list|,
operator|(
name|int
operator|)
name|c
operator|/
literal|100
argument_list|,
operator|(
name|int
operator|)
name|c
operator|%
literal|100
argument_list|,
operator|(
name|int
operator|)
name|l
operator|/
literal|1000
argument_list|,
operator|(
name|int
operator|)
name|l
operator|%
literal|1000
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|sum_cnt
operator|>
name|stats
index|[
literal|0
index|]
operator|.
name|cnt
condition|)
block|{
name|p
operator|=
operator|(
name|sum_cnt
operator|-
name|stats
index|[
literal|0
index|]
operator|.
name|cnt
operator|)
operator|*
literal|100000
operator|/
name|sum_cnt
expr_stmt|;
name|c
operator|=
operator|(
name|sum_cycles
operator|-
name|stats
index|[
literal|0
index|]
operator|.
name|cycles
operator|)
operator|*
literal|100
operator|/
operator|(
name|sum_cnt
operator|-
name|stats
index|[
literal|0
index|]
operator|.
name|cnt
operator|)
expr_stmt|;
name|l
operator|=
name|tsc_freq
operator|/
name|c
operator|*
name|active_cpus
operator|/
literal|10
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\navg_r: %3u.%03u %14llu %16llu %6u.%02u"
literal|"   %4u.%03u"
argument_list|,
operator|(
name|int
operator|)
name|p
operator|/
literal|1000
argument_list|,
operator|(
name|int
operator|)
name|p
operator|%
literal|1000
argument_list|,
operator|(
name|long
name|long
operator|)
name|sum_cnt
operator|-
name|stats
index|[
literal|0
index|]
operator|.
name|cnt
argument_list|,
operator|(
name|long
name|long
operator|)
name|sum_cycles
operator|-
name|stats
index|[
literal|0
index|]
operator|.
name|cycles
argument_list|,
operator|(
name|int
operator|)
name|c
operator|/
literal|100
argument_list|,
operator|(
name|int
operator|)
name|c
operator|%
literal|100
argument_list|,
operator|(
name|int
operator|)
name|l
operator|/
literal|1000
argument_list|,
operator|(
name|int
operator|)
name|l
operator|%
literal|1000
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|bzero
argument_list|(
name|iter_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|iter_stats
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DXR_LOOKUP_TIMING */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DXR_BUILD_TIMING
end_ifdef

begin_function
specifier|static
name|int
name|sysctl_dxr_updatestats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|uint64_t
name|sum_cnt
init|=
literal|0
decl_stmt|;
name|uint64_t
name|sum_cycles
init|=
literal|0
decl_stmt|;
name|uint64_t
name|p
decl_stmt|,
name|c
decl_stmt|,
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|dxr_instance
modifier|*
name|di
decl_stmt|;
if|if
condition|(
operator|(
name|di
operator|=
name|dxr_guess_instance
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|sum_cnt
operator|+=
name|di
operator|->
name|update_stats
index|[
name|i
index|]
operator|.
name|cnt
expr_stmt|;
name|sum_cycles
operator|+=
name|di
operator|->
name|update_stats
index|[
name|i
index|]
operator|.
name|cycles
expr_stmt|;
block|}
if|if
condition|(
name|sum_cnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n plen:  %% hits  total hits    total cycles"
literal|"  cyc/update  ms/update"
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|di
operator|->
name|update_stats
index|[
name|i
index|]
operator|.
name|cnt
operator|==
literal|0
condition|)
continue|continue;
name|p
operator|=
name|di
operator|->
name|update_stats
index|[
name|i
index|]
operator|.
name|cnt
operator|*
literal|100000
operator|/
name|sum_cnt
expr_stmt|;
name|c
operator|=
name|di
operator|->
name|update_stats
index|[
name|i
index|]
operator|.
name|cycles
operator|/
name|di
operator|->
name|update_stats
index|[
name|i
index|]
operator|.
name|cnt
expr_stmt|;
name|t
operator|=
name|c
operator|*
literal|1000000
operator|/
name|tsc_freq
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n%5u: %3u.%03u %11llu %15llu %11u"
literal|"   %4llu.%03llu"
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|p
operator|/
literal|1000
argument_list|,
operator|(
name|int
operator|)
name|p
operator|%
literal|1000
argument_list|,
operator|(
name|long
name|long
operator|)
name|di
operator|->
name|update_stats
index|[
name|i
index|]
operator|.
name|cnt
argument_list|,
operator|(
name|long
name|long
operator|)
name|di
operator|->
name|update_stats
index|[
name|i
index|]
operator|.
name|cycles
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|,
operator|(
name|long
name|long
operator|)
name|t
operator|/
literal|1000
argument_list|,
operator|(
name|long
name|long
operator|)
name|t
operator|%
literal|1000
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|p
operator|=
literal|100000
expr_stmt|;
name|c
operator|=
name|sum_cycles
operator|/
name|sum_cnt
expr_stmt|;
name|t
operator|=
name|c
operator|*
literal|1000000
operator|/
name|tsc_freq
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\ntotal: %3u.%03u %11llu %15llu %11u"
literal|"   %4llu.%03llu"
argument_list|,
operator|(
name|int
operator|)
name|p
operator|/
literal|1000
argument_list|,
operator|(
name|int
operator|)
name|p
operator|%
literal|1000
argument_list|,
operator|(
name|long
name|long
operator|)
name|sum_cnt
argument_list|,
operator|(
name|long
name|long
operator|)
name|sum_cycles
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|,
operator|(
name|long
name|long
operator|)
name|t
operator|/
literal|1000
argument_list|,
operator|(
name|long
name|long
operator|)
name|t
operator|%
literal|1000
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|bzero
argument_list|(
name|di
operator|->
name|update_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|di
operator|->
name|update_stats
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSCTL_NODE */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|DXR_ITER_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|RADIX_TIMING
argument_list|)
end_if

begin_function
specifier|static
name|void
name|dxr_lookup_exercise
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|cpu
init|=
operator|(
name|size_t
operator|)
name|arg
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|dst
init|=
literal|0
decl_stmt|;
name|int
name|dummy_index
init|=
name|random
argument_list|()
operator|&
name|DUMMY_MEM_MASK
decl_stmt|;
name|int
name|nh
decl_stmt|;
ifdef|#
directive|ifdef
name|ALLOW_OOO_EXEC
name|int
modifier|*
name|result_tbl
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|RADIX_TIMING
argument_list|)
name|uint64_t
name|start
decl_stmt|,
name|stop
decl_stmt|;
endif|#
directive|endif
name|struct
name|dxr_instance
modifier|*
name|di
decl_stmt|;
comment|/* XXX: Fix this */
if|if
condition|(
operator|(
name|di
operator|=
name|dxr_guess_instance
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|ALLOW_OOO_EXEC
name|result_tbl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|result_tbl
argument_list|)
operator|*
name|ex_iters
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_tbl
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"malloc() for result_tbl failed, stopping thread %d\n"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
return|return;
comment|/* XXX is this OK? */
block|}
endif|#
directive|endif
comment|/* DXR works always and only in vnet0 */
name|CURVNET_SET
argument_list|(
name|vnet0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Attempt to maintain CPU affinity */
if|if
condition|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|!=
name|cpu
condition|)
block|{
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
comment|/* XXX needed for DXR_ITER_TIMING */
name|DPCPU_SET
argument_list|(
name|valid_timing
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|updates_pending
operator|||
name|di
operator|->
name|dxr_enable
operator|==
literal|0
operator|||
name|di
operator|->
name|dlp
operator|==
name|NULL
operator|||
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|>=
name|ex_threads
condition|)
block|{
if|if
condition|(
name|di
operator|->
name|dlp
operator|==
name|NULL
operator|||
name|ex_threads
operator|==
literal|0
condition|)
name|pause
argument_list|(
literal|"-"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
else|else
name|pause
argument_list|(
literal|"-"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Measure lookup performance on (hopefully) uniformly 		 * random destination addresses in a thight loop. 		 * 		 * XXX locking! 		 */
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_CONSISTENCY_CHECK
argument_list|)
name|TREE_RLOCK
argument_list|(
name|di
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|RADIX_TIMING
argument_list|)
name|start
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ex_iters
condition|;
name|i
operator|++
control|)
block|{
comment|/* Fetch new random IPv4 key */
name|dst
operator|=
name|di
operator|->
name|dlp
index|[
name|dummy_index
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|REPEAT_SAME_KEY
comment|/* Repeat same key 16 times */
if|if
condition|(
operator|(
name|i
operator|&
literal|0xf
operator|)
operator|==
literal|0
condition|)
endif|#
directive|endif
name|dummy_index
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DIR_24_8
name|nh
operator|=
name|dir_24_8_lookup
argument_list|(
name|dst
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|RADIX_TIMING
name|nh
operator|=
name|radix_lookup
argument_list|(
name|di
argument_list|,
name|dst
argument_list|)
expr_stmt|;
else|#
directive|else
name|nh
operator|=
name|dxr_lookup
argument_list|(
name|di
argument_list|,
name|dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALLOW_OOO_EXEC
name|result_tbl
index|[
name|i
index|]
operator|=
name|nh
expr_stmt|;
else|#
directive|else
comment|/* 			 * Create a dependency on nh so that the next 			 * iteration cannot be dispatched out of order, 			 * before completing this one. 			 */
name|dummy_index
operator|+=
operator|(
name|nexthop_tbl
index|[
name|nh
index|]
operator|.
name|refcount
operator|&
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
name|dummy_index
operator|&=
name|DUMMY_MEM_MASK
expr_stmt|;
ifdef|#
directive|ifdef
name|DXR_LOOKUP_CONSISTENCY_CHECK
if|if
condition|(
name|nh
operator|!=
name|radix_lookup
argument_list|(
name|di
argument_list|,
name|dst
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Mismatch for %08X: DXR %d, radix %d\n"
argument_list|,
name|dst
argument_list|,
name|nh
argument_list|,
name|radix_lookup
argument_list|(
name|di
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_TIMING
argument_list|)
operator|||
name|defined
argument_list|(
name|RADIX_TIMING
argument_list|)
name|stop
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
name|iter_stats
index|[
name|cpu
index|]
index|[
literal|0
index|]
operator|.
name|cnt
operator|+=
name|i
expr_stmt|;
name|iter_stats
index|[
name|cpu
index|]
index|[
literal|0
index|]
operator|.
name|cycles
operator|+=
name|stop
operator|-
name|start
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DXR_LOOKUP_CONSISTENCY_CHECK
argument_list|)
name|TREE_RUNLOCK
argument_list|(
name|di
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dummy_index
operator|=
name|random
argument_list|()
operator|&
name|DUMMY_MEM_MASK
expr_stmt|;
name|kern_yield
argument_list|(
name|PRI_USER
argument_list|)
expr_stmt|;
block|}
comment|/* Notreached */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DXR_BUILD_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|dxr_heap_dump
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|)
block|{
name|struct
name|dxr_heap_entry
modifier|*
name|fhp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_addr
name|gw
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fhp
operator|=
operator|&
name|di
operator|->
name|dxr_heap
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|heap_index
condition|;
name|i
operator|++
operator|,
name|fhp
operator|++
control|)
block|{
name|int
name|nh
init|=
name|fhp
operator|->
name|nexthop
decl_stmt|;
name|printf
argument_list|(
literal|"    dxr_heap[%d]: %08X..%08X (plen %d) -> "
argument_list|,
name|i
argument_list|,
name|fhp
operator|->
name|start
argument_list|,
name|fhp
operator|->
name|end
argument_list|,
name|fhp
operator|->
name|preflen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d:"
argument_list|,
name|nh
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|di
operator|->
name|nexthop_tbl
index|[
name|nh
index|]
operator|.
name|ifp
expr_stmt|;
name|gw
operator|=
name|di
operator|->
name|nexthop_tbl
index|[
name|nh
index|]
operator|.
name|gw
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gw
operator|.
name|s_addr
condition|)
name|printf
argument_list|(
literal|"/%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|gw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"DISCARD"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dxr_chunk_dump
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|,
name|int
name|chunk
parameter_list|)
block|{
name|struct
name|direct_entry
modifier|*
name|fdesc
decl_stmt|;
name|struct
name|range_entry_long
modifier|*
name|fp_l
decl_stmt|;
name|struct
name|range_entry_short
modifier|*
name|fp_s
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_addr
name|gw
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nh
decl_stmt|;
name|fdesc
operator|=
operator|&
name|di
operator|->
name|direct_tbl
index|[
name|chunk
index|]
expr_stmt|;
name|fp_l
operator|=
operator|&
name|di
operator|->
name|range_tbl
index|[
name|fdesc
operator|->
name|base
index|]
expr_stmt|;
name|fp_s
operator|=
operator|(
expr|struct
name|range_entry_short
operator|*
operator|)
name|fp_l
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|fdesc
operator|->
name|fragments
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fdesc
operator|->
name|long_format
condition|)
block|{
name|nh
operator|=
name|fp_l
index|[
name|i
index|]
operator|.
name|nexthop
expr_stmt|;
name|printf
argument_list|(
literal|"    range[%d]: %08X -> "
argument_list|,
name|i
argument_list|,
name|fp_l
index|[
name|i
index|]
operator|.
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nh
operator|=
name|fp_s
index|[
name|i
index|]
operator|.
name|nexthop
expr_stmt|;
name|printf
argument_list|(
literal|"    range[%d]: %08X -> "
argument_list|,
name|i
argument_list|,
name|fp_s
index|[
name|i
index|]
operator|.
name|start
operator|<<
literal|8
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%d:"
argument_list|,
name|nh
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|di
operator|->
name|nexthop_tbl
index|[
name|nh
index|]
operator|.
name|ifp
expr_stmt|;
name|gw
operator|=
name|di
operator|->
name|nexthop_tbl
index|[
name|nh
index|]
operator|.
name|gw
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gw
operator|.
name|s_addr
condition|)
name|printf
argument_list|(
literal|"/%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|gw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"DISCARD"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_in_route
parameter_list|(
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|,
specifier|const
name|char
modifier|*
name|txt
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|dst
init|=
name|SIN
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|mask
init|=
name|SIN
argument_list|(
name|rt_mask
argument_list|(
name|rt
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|gw
init|=
name|rt
operator|->
name|rt_gateway
decl_stmt|;
name|int
name|preflen
decl_stmt|,
name|i
decl_stmt|;
name|u_char
modifier|*
name|c
decl_stmt|;
name|printf
argument_list|(
literal|"%s: %s"
argument_list|,
name|txt
argument_list|,
name|inet_ntoa
argument_list|(
name|dst
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|preflen
operator|=
name|ffs
argument_list|(
name|ntohl
argument_list|(
name|mask
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|preflen
condition|)
name|preflen
operator|=
literal|33
operator|-
name|preflen
expr_stmt|;
block|}
else|else
name|preflen
operator|=
literal|32
expr_stmt|;
name|printf
argument_list|(
literal|"/%d"
argument_list|,
name|preflen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -> %s"
argument_list|,
name|rt
operator|->
name|rt_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gw
condition|)
block|{
switch|switch
condition|(
name|gw
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_LINK
case|:
name|c
operator|=
operator|(
name|u_char
operator|*
operator|)
name|LLADDR
argument_list|(
name|SDL
argument_list|(
name|gw
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SDL
argument_list|(
name|gw
argument_list|)
operator|->
name|sdl_alen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02X"
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|AF_INET
case|:
name|printf
argument_list|(
literal|"/%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|SIN
argument_list|(
name|gw
argument_list|)
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"/??"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
condition|)
name|printf
argument_list|(
literal|"UP,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
name|printf
argument_list|(
literal|"GW,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_HOST
condition|)
name|printf
argument_list|(
literal|"HST,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_REJECT
condition|)
name|printf
argument_list|(
literal|"REJ,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_DYNAMIC
condition|)
name|printf
argument_list|(
literal|"DYN,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_MODIFIED
condition|)
name|printf
argument_list|(
literal|"MOD,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_DONE
condition|)
name|printf
argument_list|(
literal|"DONE,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_XRESOLVE
condition|)
name|printf
argument_list|(
literal|"XRES,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LLINFO
condition|)
name|printf
argument_list|(
literal|"LL,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_STATIC
condition|)
name|printf
argument_list|(
literal|"STA,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_BLACKHOLE
condition|)
name|printf
argument_list|(
literal|"BH,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_PROTO1
condition|)
name|printf
argument_list|(
literal|"P1,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_PROTO2
condition|)
name|printf
argument_list|(
literal|"P2,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_PROTO3
condition|)
name|printf
argument_list|(
literal|"P3,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_PINNED
condition|)
name|printf
argument_list|(
literal|"PIN,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LOCAL
condition|)
name|printf
argument_list|(
literal|"LCL,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_BROADCAST
condition|)
name|printf
argument_list|(
literal|"BCAST,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_MULTICAST
condition|)
name|printf
argument_list|(
literal|"MCAST"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" nexthop=%d\n"
argument_list|,
name|rt
operator|->
name|rt_dxr_nexthop
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DIR_24_8
end_ifdef

begin_function
specifier|static
name|int
name|dir_24_8_lookup
parameter_list|(
name|uint32_t
name|dst
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DXR_LOOKUP_CONSISTENCY_CHECK
name|struct
name|route
name|ro
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ro
operator|.
name|ro_dst
decl_stmt|;
name|int
name|check_nh
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|nh
init|=
name|tbl_0_23
index|[
name|dst
operator|>>
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|nh
operator|&
literal|0x8000
condition|)
name|nh
operator|=
name|tbl_24_31
index|[
operator|(
operator|(
name|nh
operator|&
literal|0x7fff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|dst
operator|&
literal|0xff
operator|)
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DXR_LOOKUP_CONSISTENCY_CHECK
name|ro
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|check_nh
operator|=
literal|0
expr_stmt|;
name|rtalloc_ign
argument_list|(
operator|&
name|ro
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|=
name|ro
operator|.
name|ro_rt
operator|)
operator|!=
name|NULL
condition|)
block|{
name|check_nh
operator|=
name|rt
operator|->
name|rt_dxr_nexthop
expr_stmt|;
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
else|else
name|check_nh
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Compare the DIR_24_8 and radix routes - is nexthop the same? 	 */
if|if
condition|(
name|nh
operator|!=
name|check_nh
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_addr
name|gw
decl_stmt|;
name|gw
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|inet_ntoa
argument_list|(
name|gw
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" DIR_24_8: "
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|nexthop_tbl
index|[
name|nh
index|]
operator|.
name|ifp
expr_stmt|;
name|gw
operator|=
name|nexthop_tbl
index|[
name|nh
index|]
operator|.
name|gw
expr_stmt|;
if|if
condition|(
name|ifp
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gw
operator|.
name|s_addr
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|gw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"DISCARD"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"; radix: "
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|nexthop_tbl
index|[
name|check_nh
index|]
operator|.
name|ifp
expr_stmt|;
name|gw
operator|=
name|nexthop_tbl
index|[
name|check_nh
index|]
operator|.
name|gw
expr_stmt|;
if|if
condition|(
name|ifp
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gw
operator|.
name|s_addr
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|gw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"DISCARD"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|nh
return|;
block|}
end_function

begin_comment
comment|/*  * Rebuild DIR_24_8 lookup tables using info from DXR tables.  * DXR MUST be configured as D24R for this to work!  */
end_comment

begin_function
specifier|static
name|void
name|dir_24_8_rebuild
parameter_list|(
name|struct
name|dxr_instance
modifier|*
name|di
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nh
decl_stmt|;
name|int
name|tbl_24_31_free
init|=
literal|0
decl_stmt|;
name|uint32_t
name|dst
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DIRECT_TBL_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|di
operator|->
name|direct_tbl
index|[
name|i
index|]
operator|.
name|base
operator|==
name|BASE_MAX
condition|)
block|{
comment|/* Nexthop is directly resolvable */
name|nh
operator|=
name|di
operator|->
name|direct_tbl
index|[
name|i
index|]
operator|.
name|fragments
expr_stmt|;
name|di
operator|->
name|tbl_0_23
index|[
name|i
index|]
operator|=
name|nh
expr_stmt|;
continue|continue;
block|}
comment|/* Encode 2nd table chunk index in 1st table element */
name|di
operator|->
name|tbl_0_23
index|[
name|i
index|]
operator|=
name|di
operator|->
name|tbl_24_31_free
operator||
literal|0x8000
expr_stmt|;
comment|/* Populate chunk in 2nd table */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
name|dst
operator|=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|i
operator|)
operator|<<
literal|24
operator|)
operator|+
name|j
expr_stmt|;
name|nh
operator|=
name|dxr_lookup
argument_list|(
name|di
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|di
operator|->
name|tbl_24_31
index|[
operator|(
name|di
operator|->
name|tbl_24_31_free
operator|<<
literal|8
operator|)
operator|+
name|j
index|]
operator|=
name|nh
expr_stmt|;
block|}
comment|/* 2nd table chunk is occupied now */
name|di
operator|->
name|tbl_24_31_free
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

