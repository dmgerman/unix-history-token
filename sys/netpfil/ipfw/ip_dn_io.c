begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010 Luigi Rizzo, Riccardo Panicucci, Universita` di Pisa  * All rights reserved  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Dummynet portions related to packet handling.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_comment
comment|/* IFNAMSIZ, struct ifaddr, ifq head, lock.h mutex.h */
end_comment

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_comment
comment|/* ip_len, ip_off */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_comment
comment|/* ip_output(), IP_FORWARDING */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_dummynet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_comment
comment|/* various ether_* routines */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_comment
comment|/* for ip6_input, ip6_output prototypes */
end_comment

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/ip_fw_private.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/dn_heap.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/ip_dn_private.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/dn_sched.h>
end_include

begin_comment
comment|/*  * We keep a private variable for the simulation time, but we could  * probably use an existing one ("softticks" in sys/kern/kern_timeout.c)  * instead of dn_cfg.curr_time  */
end_comment

begin_decl_stmt
name|struct
name|dn_parms
name|dn_cfg
decl_stmt|;
end_decl_stmt

begin_comment
comment|//VNET_DEFINE(struct dn_parms, _base_dn_cfg);
end_comment

begin_decl_stmt
specifier|static
name|long
name|tick_last
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last tick duration (usec). */
end_comment

begin_decl_stmt
specifier|static
name|long
name|tick_delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last vs standard tick diff (usec). */
end_comment

begin_decl_stmt
specifier|static
name|long
name|tick_delta_sum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Accumulated tick difference (usec).*/
end_comment

begin_decl_stmt
specifier|static
name|long
name|tick_adjustment
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tick adjustments done. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|tick_lost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lost(coalesced) ticks number. */
end_comment

begin_comment
comment|/* Adjusted vs non-adjusted curr_time difference (ticks). */
end_comment

begin_decl_stmt
specifier|static
name|long
name|tick_diff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|io_pkt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|io_pkt_fast
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|io_pkt_drop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We use a heap to store entities for which we have pending timer events.  * The heap is checked at every tick and all entities with expired events  * are extracted.  */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_DUMMYNET
argument_list|,
literal|"dummynet"
argument_list|,
literal|"dummynet heap"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|bridge_dn_p
function_decl|)
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SYSCTL_NODE
end_ifdef

begin_comment
comment|/*  * Because of the way the SYSBEGIN/SYSEND macros work on other  * platforms, there should not be functions between them.  * So keep the handlers outside the block.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_hash_size
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|value
decl_stmt|;
name|value
operator|=
name|dn_cfg
operator|.
name|hash_size
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|value
operator|<
literal|16
operator|||
name|value
operator|>
literal|65536
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|dn_cfg
operator|.
name|hash_size
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_limits
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|long
name|value
decl_stmt|;
if|if
condition|(
name|arg2
operator|!=
literal|0
condition|)
name|value
operator|=
name|dn_cfg
operator|.
name|slot_limit
expr_stmt|;
else|else
name|value
operator|=
name|dn_cfg
operator|.
name|byte_limit
expr_stmt|;
name|error
operator|=
name|sysctl_handle_long
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|arg2
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|<
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|dn_cfg
operator|.
name|slot_limit
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|<
literal|1500
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|dn_cfg
operator|.
name|byte_limit
operator|=
name|value
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|SYSBEGIN
argument_list|(
argument|f4
argument_list|)
end_macro

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet_ip
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_inet_ip
argument_list|,
name|OID_AUTO
argument_list|,
name|dummynet
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Dummynet"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* wrapper to pass dn_cfg fields to SYSCTL_* */
end_comment

begin_comment
comment|//#define DC(x)	(&(VNET_NAME(_base_dn_cfg).x))
end_comment

begin_define
define|#
directive|define
name|DC
parameter_list|(
name|x
parameter_list|)
value|(&(dn_cfg.x))
end_define

begin_comment
comment|/* parameters */
end_comment

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|hash_size
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_hash_size
argument_list|,
literal|"I"
argument_list|,
literal|"Default hash table size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|pipe_slot_limit
argument_list|,
name|CTLTYPE_LONG
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|sysctl_limits
argument_list|,
literal|"L"
argument_list|,
literal|"Upper limit in slots for pipe queue."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|pipe_byte_limit
argument_list|,
name|CTLTYPE_LONG
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_limits
argument_list|,
literal|"L"
argument_list|,
literal|"Upper limit in bytes for pipe queue."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|io_fast
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|DC
argument_list|(
name|io_fast
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Enable fast dummynet io."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|DC
argument_list|(
name|debug
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Dummynet debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* RED parameters */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|red_lookup_depth
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|DC
argument_list|(
name|red_lookup_depth
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Depth of RED lookup table"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|red_avg_pkt_size
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|DC
argument_list|(
name|red_avg_pkt_size
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"RED Medium packet size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|red_max_pkt_size
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|DC
argument_list|(
name|red_max_pkt_size
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"RED Max packet size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* time adjustment */
end_comment

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|tick_delta
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|tick_delta
argument_list|,
literal|0
argument_list|,
literal|"Last vs standard tick difference (usec)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|tick_delta_sum
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|tick_delta_sum
argument_list|,
literal|0
argument_list|,
literal|"Accumulated tick difference (usec)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|tick_adjustment
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|tick_adjustment
argument_list|,
literal|0
argument_list|,
literal|"Tick adjustments done."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|tick_diff
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|tick_diff
argument_list|,
literal|0
argument_list|,
literal|"Adjusted vs non-adjusted curr_time difference (ticks)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|tick_lost
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|tick_lost
argument_list|,
literal|0
argument_list|,
literal|"Number of ticks coalesced by dummynet taskqueue."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Drain parameters */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|expire
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|DC
argument_list|(
name|expire
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Expire empty queues/pipes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|expire_cycle
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|DC
argument_list|(
name|expire_cycle
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Expire cycle for queues/pipes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* statistics */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|schk_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|DC
argument_list|(
name|schk_count
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Number of schedulers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|si_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|DC
argument_list|(
name|si_count
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Number of scheduler instances"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|fsk_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|DC
argument_list|(
name|fsk_count
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Number of flowsets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|queue_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|DC
argument_list|(
name|queue_count
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Number of queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|io_pkt
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|io_pkt
argument_list|,
literal|0
argument_list|,
literal|"Number of packets passed to dummynet."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|io_pkt_fast
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|io_pkt_fast
argument_list|,
literal|0
argument_list|,
literal|"Number of packets bypassed dummynet scheduler."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_inet_ip_dummynet
argument_list|,
name|OID_AUTO
argument_list|,
name|io_pkt_drop
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|io_pkt_drop
argument_list|,
literal|0
argument_list|,
literal|"Number of packets dropped by dummynet."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|DC
end_undef

begin_function_decl
name|SYSEND
endif|#
directive|endif
specifier|static
name|void
name|dummynet_send
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Packets processed by dummynet have an mbuf tag associated with  * them that carries their dummynet state.  * Outside dummynet, only the 'rule' field is relevant, and it must  * be at the beginning of the structure.  */
end_comment

begin_struct
struct|struct
name|dn_pkt_tag
block|{
name|struct
name|ipfw_rule_ref
name|rule
decl_stmt|;
comment|/* matching rule	*/
comment|/* second part, dummynet specific */
name|int
name|dn_dir
decl_stmt|;
comment|/* action when packet comes out.*/
comment|/* see ip_fw_private.h		*/
name|uint64_t
name|output_time
decl_stmt|;
comment|/* when the pkt is due for delivery*/
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* interface, for ip_output	*/
name|struct
name|_ip6dn_args
name|ip6opt
decl_stmt|;
comment|/* XXX ipv6 options	*/
block|}
struct|;
end_struct

begin_comment
comment|/*  * Return the mbuf tag holding the dummynet state (it should  * be the first one on the list).  */
end_comment

begin_function
specifier|static
name|struct
name|dn_pkt_tag
modifier|*
name|dn_tag_get
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|m_tag
modifier|*
name|mtag
init|=
name|m_tag_first
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|mtag
operator|!=
name|NULL
operator|&&
name|mtag
operator|->
name|m_tag_cookie
operator|==
name|MTAG_ABI_COMPAT
operator|&&
name|mtag
operator|->
name|m_tag_id
operator|==
name|PACKET_TAG_DUMMYNET
argument_list|,
operator|(
literal|"packet on dummynet queue w/o dummynet tag!"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|dn_pkt_tag
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mq_append
parameter_list|(
name|struct
name|mq
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USERSPACE
comment|// buffers from netmap need to be copied
comment|// XXX note that the routine is not expected to fail
name|ND
argument_list|(
literal|"append %p to %p"
argument_list|,
name|m
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_STACK
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|,
name|ofs
decl_stmt|;
name|ofs
operator|=
name|m
operator|->
name|m_data
operator|-
name|m
operator|->
name|__m_extbuf
expr_stmt|;
comment|// XXX allocate
name|MGETHDR
argument_list|(
name|m_new
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"*** WARNING, volatile buf %p ext %p %d dofs %d m_new %p"
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|__m_extbuf
argument_list|,
name|m
operator|->
name|__m_extlen
argument_list|,
name|ofs
argument_list|,
name|m_new
argument_list|)
expr_stmt|;
name|p
operator|=
name|m_new
operator|->
name|__m_extbuf
expr_stmt|;
comment|/* new pointer */
name|l
operator|=
name|m_new
operator|->
name|__m_extlen
expr_stmt|;
comment|/* new len */
if|if
condition|(
name|l
operator|<=
name|m
operator|->
name|__m_extlen
condition|)
block|{
name|panic
argument_list|(
literal|"extlen too large"
argument_list|)
expr_stmt|;
block|}
operator|*
name|m_new
operator|=
operator|*
name|m
expr_stmt|;
comment|// copy
name|m_new
operator|->
name|m_flags
operator|&=
operator|~
name|M_STACK
expr_stmt|;
name|m_new
operator|->
name|__m_extbuf
operator|=
name|p
expr_stmt|;
comment|// point to new buffer
name|pkt_copy
argument_list|(
name|m
operator|->
name|__m_extbuf
argument_list|,
name|p
argument_list|,
name|m
operator|->
name|__m_extlen
argument_list|)
expr_stmt|;
name|m_new
operator|->
name|m_data
operator|=
name|p
operator|+
name|ofs
expr_stmt|;
name|m
operator|=
name|m_new
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USERSPACE */
if|if
condition|(
name|q
operator|->
name|head
operator|==
name|NULL
condition|)
name|q
operator|->
name|head
operator|=
name|m
expr_stmt|;
else|else
name|q
operator|->
name|tail
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
name|q
operator|->
name|count
operator|++
expr_stmt|;
name|q
operator|->
name|tail
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispose a list of packet. Use a functions so if we need to do  * more work, this is a central point to do it.  */
end_comment

begin_function
name|void
name|dn_free_pkts
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mnext
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|mnext
operator|)
operator|!=
name|NULL
condition|)
block|{
name|mnext
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|FREE_PKT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|red_drops
parameter_list|(
name|struct
name|dn_queue
modifier|*
name|q
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|/* 	 * RED algorithm 	 * 	 * RED calculates the average queue size (avg) using a low-pass filter 	 * with an exponential weighted (w_q) moving average: 	 * 	avg<-  (1-w_q) * avg + w_q * q_size 	 * where q_size is the queue length (measured in bytes or * packets). 	 * 	 * If q_size == 0, we compute the idle time for the link, and set 	 *	avg = (1 - w_q)^(idle/s) 	 * where s is the time needed for transmitting a medium-sized packet. 	 * 	 * Now, if avg< min_th the packet is enqueued. 	 * If avg> max_th the packet is dropped. Otherwise, the packet is 	 * dropped with probability P function of avg. 	 */
name|struct
name|dn_fsk
modifier|*
name|fs
init|=
name|q
operator|->
name|fs
decl_stmt|;
name|int64_t
name|p_b
init|=
literal|0
decl_stmt|;
comment|/* Queue in bytes or packets? */
name|uint32_t
name|q_size
init|=
operator|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_QSIZE_BYTES
operator|)
condition|?
name|q
operator|->
name|ni
operator|.
name|len_bytes
else|:
name|q
operator|->
name|ni
operator|.
name|length
decl_stmt|;
comment|/* Average queue size estimation. */
if|if
condition|(
name|q_size
operator|!=
literal|0
condition|)
block|{
comment|/* Queue is not empty, avg<- avg + (q_size - avg) * w_q */
name|int
name|diff
init|=
name|SCALE
argument_list|(
name|q_size
argument_list|)
operator|-
name|q
operator|->
name|avg
decl_stmt|;
name|int64_t
name|v
init|=
name|SCALE_MUL
argument_list|(
operator|(
name|int64_t
operator|)
name|diff
argument_list|,
operator|(
name|int64_t
operator|)
name|fs
operator|->
name|w_q
argument_list|)
decl_stmt|;
name|q
operator|->
name|avg
operator|+=
operator|(
name|int
operator|)
name|v
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Queue is empty, find for how long the queue has been 		 * empty and use a lookup table for computing 		 * (1 - * w_q)^(idle_time/s) where s is the time to send a 		 * (small) packet. 		 * XXX check wraps... 		 */
if|if
condition|(
name|q
operator|->
name|avg
condition|)
block|{
name|u_int
name|t
init|=
name|div64
argument_list|(
operator|(
name|dn_cfg
operator|.
name|curr_time
operator|-
name|q
operator|->
name|q_time
operator|)
argument_list|,
name|fs
operator|->
name|lookup_step
argument_list|)
decl_stmt|;
name|q
operator|->
name|avg
operator|=
operator|(
name|t
operator|<
name|fs
operator|->
name|lookup_depth
operator|)
condition|?
name|SCALE_MUL
argument_list|(
name|q
operator|->
name|avg
argument_list|,
name|fs
operator|->
name|w_q_lookup
index|[
name|t
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
block|}
comment|/* Should i drop? */
if|if
condition|(
name|q
operator|->
name|avg
operator|<
name|fs
operator|->
name|min_th
condition|)
block|{
name|q
operator|->
name|count
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* accept packet */
block|}
if|if
condition|(
name|q
operator|->
name|avg
operator|>=
name|fs
operator|->
name|max_th
condition|)
block|{
comment|/* average queue>=  max threshold */
if|if
condition|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_IS_ECN
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_IS_GENTLE_RED
condition|)
block|{
comment|/* 			 * According to Gentle-RED, if avg is greater than 			 * max_th the packet is dropped with a probability 			 *	 p_b = c_3 * avg - c_4 			 * where c_3 = (1 - max_p) / max_th 			 *       c_4 = 1 - 2 * max_p 			 */
name|p_b
operator|=
name|SCALE_MUL
argument_list|(
operator|(
name|int64_t
operator|)
name|fs
operator|->
name|c_3
argument_list|,
operator|(
name|int64_t
operator|)
name|q
operator|->
name|avg
argument_list|)
operator|-
name|fs
operator|->
name|c_4
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|count
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|avg
operator|>
name|fs
operator|->
name|min_th
condition|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_IS_ECN
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 		 * We compute p_b using the linear dropping function 		 *	 p_b = c_1 * avg - c_2 		 * where c_1 = max_p / (max_th - min_th) 		 * 	 c_2 = max_p * min_th / (max_th - min_th) 		 */
name|p_b
operator|=
name|SCALE_MUL
argument_list|(
operator|(
name|int64_t
operator|)
name|fs
operator|->
name|c_1
argument_list|,
operator|(
name|int64_t
operator|)
name|q
operator|->
name|avg
argument_list|)
operator|-
name|fs
operator|->
name|c_2
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_QSIZE_BYTES
condition|)
name|p_b
operator|=
name|div64
argument_list|(
operator|(
name|p_b
operator|*
name|len
operator|)
argument_list|,
name|fs
operator|->
name|max_pkt_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|q
operator|->
name|count
operator|==
literal|0
condition|)
name|q
operator|->
name|random
operator|=
name|random
argument_list|()
operator|&
literal|0xffff
expr_stmt|;
else|else
block|{
comment|/* 		 * q->count counts packets arrived since last drop, so a greater 		 * value of q->count means a greater packet drop probability. 		 */
if|if
condition|(
name|SCALE_MUL
argument_list|(
name|p_b
argument_list|,
name|SCALE
argument_list|(
operator|(
name|int64_t
operator|)
name|q
operator|->
name|count
argument_list|)
argument_list|)
operator|>
name|q
operator|->
name|random
condition|)
block|{
name|q
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* After a drop we calculate a new random value. */
name|q
operator|->
name|random
operator|=
name|random
argument_list|()
operator|&
literal|0xffff
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* drop */
block|}
block|}
comment|/* End of RED algorithm. */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* accept */
block|}
end_function

begin_comment
comment|/*  * ECN/ECT Processing (partially adopted from altq)  */
end_comment

begin_function
specifier|static
name|int
name|ecn_mark
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ip
operator|->
name|ip_v
condition|)
block|{
case|case
name|IPVERSION
case|:
block|{
name|u_int8_t
name|otos
decl_stmt|;
name|int
name|sum
decl_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|ip_tos
operator|&
name|IPTOS_ECN_MASK
operator|)
operator|==
name|IPTOS_ECN_NOTECT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not-ECT */
if|if
condition|(
operator|(
name|ip
operator|->
name|ip_tos
operator|&
name|IPTOS_ECN_MASK
operator|)
operator|==
name|IPTOS_ECN_CE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* already marked */
comment|/* 		 * ecn-capable but not marked, 		 * mark CE and update checksum 		 */
name|otos
operator|=
name|ip
operator|->
name|ip_tos
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator||=
name|IPTOS_ECN_CE
expr_stmt|;
comment|/* 		 * update checksum (from RFC1624) 		 *	   HC' = ~(~HC + ~m + m') 		 */
name|sum
operator|=
operator|~
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_sum
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|sum
operator|+=
operator|(
operator|~
name|otos
operator|&
literal|0xffff
operator|)
operator|+
name|ip
operator|->
name|ip_tos
expr_stmt|;
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|sum
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|sum
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* add carry */
name|ip
operator|->
name|ip_sum
operator|=
name|htons
argument_list|(
operator|~
name|sum
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INET6
case|case
operator|(
name|IPV6_VERSION
operator|>>
literal|4
operator|)
case|:
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
name|u_int32_t
name|flowlabel
decl_stmt|;
name|flowlabel
operator|=
name|ntohl
argument_list|(
name|ip6
operator|->
name|ip6_flow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flowlabel
operator|>>
literal|28
operator|)
operator|!=
literal|6
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* version mismatch! */
if|if
condition|(
operator|(
name|flowlabel
operator|&
operator|(
name|IPTOS_ECN_MASK
operator|<<
literal|20
operator|)
operator|)
operator|==
operator|(
name|IPTOS_ECN_NOTECT
operator|<<
literal|20
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not-ECT */
if|if
condition|(
operator|(
name|flowlabel
operator|&
operator|(
name|IPTOS_ECN_MASK
operator|<<
literal|20
operator|)
operator|)
operator|==
operator|(
name|IPTOS_ECN_CE
operator|<<
literal|20
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* already marked */
comment|/* 		 * ecn-capable but not marked, mark CE 		 */
name|flowlabel
operator||=
operator|(
name|IPTOS_ECN_CE
operator|<<
literal|20
operator|)
expr_stmt|;
name|ip6
operator|->
name|ip6_flow
operator|=
name|htonl
argument_list|(
name|flowlabel
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enqueue a packet in q, subject to space and queue management policy  * (whose parameters are in q->fs).  * Update stats for the queue and the scheduler.  * Return 0 on success, 1 on drop. The packet is consumed anyways.  */
end_comment

begin_function
name|int
name|dn_enqueue
parameter_list|(
name|struct
name|dn_queue
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|drop
parameter_list|)
block|{
name|struct
name|dn_fs
modifier|*
name|f
decl_stmt|;
name|struct
name|dn_flow
modifier|*
name|ni
decl_stmt|;
comment|/* stats for scheduler instance */
name|uint64_t
name|len
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|fs
operator|==
name|NULL
operator|||
name|q
operator|->
name|_si
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s fs %p si %p, dropping\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|q
operator|->
name|fs
argument_list|,
name|q
operator|->
name|_si
argument_list|)
expr_stmt|;
name|FREE_PKT
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|f
operator|=
operator|&
operator|(
name|q
operator|->
name|fs
operator|->
name|fs
operator|)
expr_stmt|;
name|ni
operator|=
operator|&
name|q
operator|->
name|_si
operator|->
name|ni
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Update statistics, then check reasons to drop pkt. */
name|q
operator|->
name|ni
operator|.
name|tot_bytes
operator|+=
name|len
expr_stmt|;
name|q
operator|->
name|ni
operator|.
name|tot_pkts
operator|++
expr_stmt|;
name|ni
operator|->
name|tot_bytes
operator|+=
name|len
expr_stmt|;
name|ni
operator|->
name|tot_pkts
operator|++
expr_stmt|;
if|if
condition|(
name|drop
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
name|f
operator|->
name|plr
operator|&&
name|random
argument_list|()
operator|<
name|f
operator|->
name|plr
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
name|f
operator|->
name|flags
operator|&
name|DN_IS_RED
operator|&&
name|red_drops
argument_list|(
name|q
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|f
operator|->
name|flags
operator|&
name|DN_IS_ECN
operator|)
operator|||
operator|!
name|ecn_mark
argument_list|(
name|m
argument_list|)
condition|)
goto|goto
name|drop
goto|;
block|}
if|if
condition|(
name|f
operator|->
name|flags
operator|&
name|DN_QSIZE_BYTES
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|ni
operator|.
name|len_bytes
operator|>
name|f
operator|->
name|qsize
condition|)
goto|goto
name|drop
goto|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|ni
operator|.
name|length
operator|>=
name|f
operator|->
name|qsize
condition|)
block|{
goto|goto
name|drop
goto|;
block|}
name|mq_append
argument_list|(
operator|&
name|q
operator|->
name|mq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|q
operator|->
name|ni
operator|.
name|length
operator|++
expr_stmt|;
name|q
operator|->
name|ni
operator|.
name|len_bytes
operator|+=
name|len
expr_stmt|;
name|ni
operator|->
name|length
operator|++
expr_stmt|;
name|ni
operator|->
name|len_bytes
operator|+=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|drop
label|:
name|io_pkt_drop
operator|++
expr_stmt|;
name|q
operator|->
name|ni
operator|.
name|drops
operator|++
expr_stmt|;
name|ni
operator|->
name|drops
operator|++
expr_stmt|;
name|FREE_PKT
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch packets from the delay line which are due now. If there are  * leftover packets, reinsert the delay line in the heap.  * Runs under scheduler lock.  */
end_comment

begin_function
specifier|static
name|void
name|transmit_event
parameter_list|(
name|struct
name|mq
modifier|*
name|q
parameter_list|,
name|struct
name|delay_line
modifier|*
name|dline
parameter_list|,
name|uint64_t
name|now
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|dn_pkt_tag
modifier|*
name|pkt
init|=
name|NULL
decl_stmt|;
name|dline
operator|->
name|oid
operator|.
name|subtype
operator|=
literal|0
expr_stmt|;
comment|/* not in heap */
while|while
condition|(
operator|(
name|m
operator|=
name|dline
operator|->
name|mq
operator|.
name|head
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pkt
operator|=
name|dn_tag_get
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DN_KEY_LEQ
argument_list|(
name|pkt
operator|->
name|output_time
argument_list|,
name|now
argument_list|)
condition|)
break|break;
name|dline
operator|->
name|mq
operator|.
name|head
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|dline
operator|->
name|mq
operator|.
name|count
operator|--
expr_stmt|;
name|mq_append
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|dline
operator|->
name|oid
operator|.
name|subtype
operator|=
literal|1
expr_stmt|;
comment|/* in heap */
name|heap_insert
argument_list|(
operator|&
name|dn_cfg
operator|.
name|evheap
argument_list|,
name|pkt
operator|->
name|output_time
argument_list|,
name|dline
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Convert the additional MAC overheads/delays into an equivalent  * number of bits for the given data rate. The samples are  * in milliseconds so we need to divide by 1000.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|extra_bits
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|dn_schk
modifier|*
name|s
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|uint64_t
name|bits
decl_stmt|;
name|struct
name|dn_profile
modifier|*
name|pf
init|=
name|s
operator|->
name|profile
decl_stmt|;
if|if
condition|(
operator|!
name|pf
operator|||
name|pf
operator|->
name|samples_no
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|index
operator|=
name|random
argument_list|()
operator|%
name|pf
operator|->
name|samples_no
expr_stmt|;
name|bits
operator|=
name|div64
argument_list|(
operator|(
name|uint64_t
operator|)
name|pf
operator|->
name|samples
index|[
name|index
index|]
operator|*
name|s
operator|->
name|link
operator|.
name|bandwidth
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|pf
operator|->
name|loss_level
condition|)
block|{
name|struct
name|dn_pkt_tag
modifier|*
name|dt
init|=
name|dn_tag_get
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
condition|)
name|dt
operator|->
name|dn_dir
operator|=
name|DIR_DROP
expr_stmt|;
block|}
return|return
name|bits
return|;
block|}
end_function

begin_comment
comment|/*  * Send traffic from a scheduler instance due by 'now'.  * Return a pointer to the head of the queue.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|serve_sched
parameter_list|(
name|struct
name|mq
modifier|*
name|q
parameter_list|,
name|struct
name|dn_sch_inst
modifier|*
name|si
parameter_list|,
name|uint64_t
name|now
parameter_list|)
block|{
name|struct
name|mq
name|def_q
decl_stmt|;
name|struct
name|dn_schk
modifier|*
name|s
init|=
name|si
operator|->
name|sched
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
name|delay_line_idle
init|=
operator|(
name|si
operator|->
name|dline
operator|.
name|mq
operator|.
name|head
operator|==
name|NULL
operator|)
decl_stmt|;
name|int
name|done
decl_stmt|,
name|bw
decl_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|q
operator|=
operator|&
name|def_q
expr_stmt|;
name|q
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
block|}
name|bw
operator|=
name|s
operator|->
name|link
operator|.
name|bandwidth
expr_stmt|;
name|si
operator|->
name|kflags
operator|&=
operator|~
name|DN_ACTIVE
expr_stmt|;
if|if
condition|(
name|bw
operator|>
literal|0
condition|)
name|si
operator|->
name|credit
operator|+=
operator|(
name|now
operator|-
name|si
operator|->
name|sched_time
operator|)
operator|*
name|bw
expr_stmt|;
else|else
name|si
operator|->
name|credit
operator|=
literal|0
expr_stmt|;
name|si
operator|->
name|sched_time
operator|=
name|now
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|si
operator|->
name|credit
operator|>=
literal|0
operator|&&
operator|(
name|m
operator|=
name|s
operator|->
name|fp
operator|->
name|dequeue
argument_list|(
name|si
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|uint64_t
name|len_scaled
decl_stmt|;
name|done
operator|++
expr_stmt|;
name|len_scaled
operator|=
operator|(
name|bw
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|hz
operator|*
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|*
literal|8
operator|+
name|extra_bits
argument_list|(
name|m
argument_list|,
name|s
argument_list|)
operator|)
expr_stmt|;
name|si
operator|->
name|credit
operator|-=
name|len_scaled
expr_stmt|;
comment|/* Move packet in the delay line */
name|dn_tag_get
argument_list|(
name|m
argument_list|)
operator|->
name|output_time
operator|=
name|dn_cfg
operator|.
name|curr_time
operator|+
name|s
operator|->
name|link
operator|.
name|delay
expr_stmt|;
name|mq_append
argument_list|(
operator|&
name|si
operator|->
name|dline
operator|.
name|mq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If credit>= 0 the instance is idle, mark time. 	 * Otherwise put back in the heap, and adjust the output 	 * time of the last inserted packet, m, which was too early. 	 */
if|if
condition|(
name|si
operator|->
name|credit
operator|>=
literal|0
condition|)
block|{
name|si
operator|->
name|idle_time
operator|=
name|now
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|t
decl_stmt|;
name|KASSERT
argument_list|(
name|bw
operator|>
literal|0
argument_list|,
operator|(
literal|"bw=0 and credit<0 ?"
operator|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|div64
argument_list|(
name|bw
operator|-
literal|1
operator|-
name|si
operator|->
name|credit
argument_list|,
name|bw
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|dn_tag_get
argument_list|(
name|m
argument_list|)
operator|->
name|output_time
operator|+=
name|t
expr_stmt|;
name|si
operator|->
name|kflags
operator||=
name|DN_ACTIVE
expr_stmt|;
name|heap_insert
argument_list|(
operator|&
name|dn_cfg
operator|.
name|evheap
argument_list|,
name|now
operator|+
name|t
argument_list|,
name|si
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delay_line_idle
operator|&&
name|done
condition|)
name|transmit_event
argument_list|(
name|q
argument_list|,
operator|&
name|si
operator|->
name|dline
argument_list|,
name|now
argument_list|)
expr_stmt|;
return|return
name|q
operator|->
name|head
return|;
block|}
end_function

begin_comment
comment|/*  * The timer handler for dummynet. Time is computed in ticks, but  * but the code is tolerant to the actual rate at which this is called.  * Once complete, the function reschedules itself for the next tick.  */
end_comment

begin_function
name|void
name|dummynet_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|timeval
name|t
decl_stmt|;
name|struct
name|mq
name|q
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
comment|/* queue to accumulate results */
name|CURVNET_SET
argument_list|(
operator|(
expr|struct
name|vnet
operator|*
operator|)
name|context
argument_list|)
expr_stmt|;
name|DN_BH_WLOCK
argument_list|()
expr_stmt|;
comment|/* Update number of lost(coalesced) ticks. */
name|tick_lost
operator|+=
name|pending
operator|-
literal|1
expr_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* Last tick duration (usec). */
name|tick_last
operator|=
operator|(
name|t
operator|.
name|tv_sec
operator|-
name|dn_cfg
operator|.
name|prev_t
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|t
operator|.
name|tv_usec
operator|-
name|dn_cfg
operator|.
name|prev_t
operator|.
name|tv_usec
operator|)
expr_stmt|;
comment|/* Last tick vs standard tick difference (usec). */
name|tick_delta
operator|=
operator|(
name|tick_last
operator|*
name|hz
operator|-
literal|1000000
operator|)
operator|/
name|hz
expr_stmt|;
comment|/* Accumulated tick difference (usec). */
name|tick_delta_sum
operator|+=
name|tick_delta
expr_stmt|;
name|dn_cfg
operator|.
name|prev_t
operator|=
name|t
expr_stmt|;
comment|/* 	* Adjust curr_time if the accumulated tick difference is 	* greater than the 'standard' tick. Since curr_time should 	* be monotonically increasing, we do positive adjustments 	* as required, and throttle curr_time in case of negative 	* adjustment. 	*/
name|dn_cfg
operator|.
name|curr_time
operator|++
expr_stmt|;
if|if
condition|(
name|tick_delta_sum
operator|-
name|tick
operator|>=
literal|0
condition|)
block|{
name|int
name|diff
init|=
name|tick_delta_sum
operator|/
name|tick
decl_stmt|;
name|dn_cfg
operator|.
name|curr_time
operator|+=
name|diff
expr_stmt|;
name|tick_diff
operator|+=
name|diff
expr_stmt|;
name|tick_delta_sum
operator|%=
name|tick
expr_stmt|;
name|tick_adjustment
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tick_delta_sum
operator|+
name|tick
operator|<=
literal|0
condition|)
block|{
name|dn_cfg
operator|.
name|curr_time
operator|--
expr_stmt|;
name|tick_diff
operator|--
expr_stmt|;
name|tick_delta_sum
operator|+=
name|tick
expr_stmt|;
name|tick_adjustment
operator|++
expr_stmt|;
block|}
comment|/* serve pending events, accumulate in q */
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|dn_id
modifier|*
name|p
decl_stmt|;
comment|/* generic parameter to handler */
if|if
condition|(
name|dn_cfg
operator|.
name|evheap
operator|.
name|elements
operator|==
literal|0
operator|||
name|DN_KEY_LT
argument_list|(
name|dn_cfg
operator|.
name|curr_time
argument_list|,
name|HEAP_TOP
argument_list|(
operator|&
name|dn_cfg
operator|.
name|evheap
argument_list|)
operator|->
name|key
argument_list|)
condition|)
break|break;
name|p
operator|=
name|HEAP_TOP
argument_list|(
operator|&
name|dn_cfg
operator|.
name|evheap
argument_list|)
operator|->
name|object
expr_stmt|;
name|heap_extract
argument_list|(
operator|&
name|dn_cfg
operator|.
name|evheap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|DN_SCH_I
condition|)
block|{
name|serve_sched
argument_list|(
operator|&
name|q
argument_list|,
operator|(
expr|struct
name|dn_sch_inst
operator|*
operator|)
name|p
argument_list|,
name|dn_cfg
operator|.
name|curr_time
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* extracted a delay line */
name|transmit_event
argument_list|(
operator|&
name|q
argument_list|,
operator|(
expr|struct
name|delay_line
operator|*
operator|)
name|p
argument_list|,
name|dn_cfg
operator|.
name|curr_time
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dn_cfg
operator|.
name|expire
operator|&&
operator|++
name|dn_cfg
operator|.
name|expire_cycle
operator|>=
name|dn_cfg
operator|.
name|expire
condition|)
block|{
name|dn_cfg
operator|.
name|expire_cycle
operator|=
literal|0
expr_stmt|;
name|dn_drain_scheduler
argument_list|()
expr_stmt|;
name|dn_drain_queue
argument_list|()
expr_stmt|;
block|}
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
name|dn_reschedule
argument_list|()
expr_stmt|;
if|if
condition|(
name|q
operator|.
name|head
operator|!=
name|NULL
condition|)
name|dummynet_send
argument_list|(
name|q
operator|.
name|head
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * forward a chain of packets to the proper destination.  * This runs outside the dummynet lock.  */
end_comment

begin_function
specifier|static
name|void
name|dummynet_send
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
for|for
control|(
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|n
control|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
comment|/* gcc 3.4.6 complains */
name|struct
name|m_tag
modifier|*
name|tag
decl_stmt|;
name|int
name|dst
decl_stmt|;
name|n
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|tag
operator|=
name|m_tag_first
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
block|{
comment|/* should not happen */
name|dst
operator|=
name|DIR_DROP
expr_stmt|;
block|}
else|else
block|{
name|struct
name|dn_pkt_tag
modifier|*
name|pkt
init|=
name|dn_tag_get
argument_list|(
name|m
argument_list|)
decl_stmt|;
comment|/* extract the dummynet info, rename the tag 			 * to carry reinject info. 			 */
if|if
condition|(
name|pkt
operator|->
name|dn_dir
operator|==
operator|(
name|DIR_OUT
operator||
name|PROTO_LAYER2
operator|)
operator|&&
name|pkt
operator|->
name|ifp
operator|==
name|NULL
condition|)
block|{
name|dst
operator|=
name|DIR_DROP
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|=
name|pkt
operator|->
name|dn_dir
expr_stmt|;
name|ifp
operator|=
name|pkt
operator|->
name|ifp
expr_stmt|;
name|tag
operator|->
name|m_tag_cookie
operator|=
name|MTAG_IPFW_RULE
expr_stmt|;
name|tag
operator|->
name|m_tag_id
operator|=
literal|0
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|dst
condition|)
block|{
case|case
name|DIR_OUT
case|:
name|ip_output
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|IP_FORWARDING
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break ;
case|case
name|DIR_IN
case|:
name|netisr_dispatch
argument_list|(
name|NETISR_IP
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|DIR_IN
operator||
name|PROTO_IPV6
case|:
name|netisr_dispatch
argument_list|(
name|NETISR_IPV6
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIR_OUT
operator||
name|PROTO_IPV6
case|:
name|ip6_output
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|IPV6_FORWARDING
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|DIR_FWD
operator||
name|PROTO_IFB
case|:
comment|/* DN_TO_IFB_FWD: */
if|if
condition|(
name|bridge_dn_p
operator|!=
name|NULL
condition|)
operator|(
call|(
modifier|*
name|bridge_dn_p
call|)
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|)
operator|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"dummynet: if_bridge not loaded\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIR_IN
operator||
name|PROTO_LAYER2
case|:
comment|/* DN_TO_ETH_DEMUX: */
comment|/* 			 * The Ethernet code assumes the Ethernet header is 			 * contiguous in the first mbuf header. 			 * Insure this is true. 			 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ETHER_HDR_LEN
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"dummynet/ether: pullup failed, "
literal|"dropping packet\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ether_demux
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIR_OUT
operator||
name|PROTO_LAYER2
case|:
comment|/* N_TO_ETH_OUT: */
name|ether_output_frame
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIR_DROP
case|:
comment|/* drop the packet after some time */
name|FREE_PKT
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"dummynet: bad switch %d!\n"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|FREE_PKT
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|tag_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|ip_fw_args
modifier|*
name|fwa
parameter_list|)
block|{
name|struct
name|dn_pkt_tag
modifier|*
name|dt
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|mtag
operator|=
name|m_tag_get
argument_list|(
name|PACKET_TAG_DUMMYNET
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dt
argument_list|)
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* Cannot allocate packet header. */
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
comment|/* Attach to mbuf chain. */
name|dt
operator|=
operator|(
expr|struct
name|dn_pkt_tag
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
expr_stmt|;
name|dt
operator|->
name|rule
operator|=
name|fwa
operator|->
name|rule
expr_stmt|;
name|dt
operator|->
name|rule
operator|.
name|info
operator|&=
name|IPFW_ONEPASS
expr_stmt|;
comment|/* only keep this info */
name|dt
operator|->
name|dn_dir
operator|=
name|dir
expr_stmt|;
name|dt
operator|->
name|ifp
operator|=
name|fwa
operator|->
name|oif
expr_stmt|;
comment|/* dt->output tame is updated as we move through */
name|dt
operator|->
name|output_time
operator|=
name|dn_cfg
operator|.
name|curr_time
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * dummynet hook for packets.  * We use the argument to locate the flowset fs and the sched_set sch  * associated to it. The we apply flow_mask and sched_mask to  * determine the queue and scheduler instances.  *  * dir		where shall we send the packet after dummynet.  * *m0		the mbuf with the packet  * ifp		the 'ifp' parameter from the caller.  *		NULL in ip_input, destination interface in ip_output,  */
end_comment

begin_function
name|int
name|dummynet_io
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|ip_fw_args
modifier|*
name|fwa
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|;
name|struct
name|dn_fsk
modifier|*
name|fs
init|=
name|NULL
decl_stmt|;
name|struct
name|dn_sch_inst
modifier|*
name|si
decl_stmt|;
name|struct
name|dn_queue
modifier|*
name|q
init|=
name|NULL
decl_stmt|;
comment|/* default */
name|int
name|fs_id
init|=
operator|(
name|fwa
operator|->
name|rule
operator|.
name|info
operator|&
name|IPFW_INFO_MASK
operator|)
operator|+
operator|(
operator|(
name|fwa
operator|->
name|rule
operator|.
name|info
operator|&
name|IPFW_IS_PIPE
operator|)
condition|?
literal|2
operator|*
name|DN_MAX_ID
else|:
literal|0
operator|)
decl_stmt|;
name|DN_BH_WLOCK
argument_list|()
expr_stmt|;
name|io_pkt
operator|++
expr_stmt|;
comment|/* we could actually tag outside the lock, but who cares... */
if|if
condition|(
name|tag_mbuf
argument_list|(
name|m
argument_list|,
name|dir
argument_list|,
name|fwa
argument_list|)
condition|)
goto|goto
name|dropit
goto|;
if|if
condition|(
name|dn_cfg
operator|.
name|busy
condition|)
block|{
comment|/* if the upper half is busy doing something expensive, 		 * lets queue the packet and move forward 		 */
name|mq_append
argument_list|(
operator|&
name|dn_cfg
operator|.
name|pending
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
comment|/* consumed */
goto|goto
name|done
goto|;
comment|/* already active, nothing to do */
block|}
comment|/* XXX locate_flowset could be optimised with a direct ref. */
name|fs
operator|=
name|dn_ht_find
argument_list|(
name|dn_cfg
operator|.
name|fshash
argument_list|,
name|fs_id
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|==
name|NULL
condition|)
goto|goto
name|dropit
goto|;
comment|/* This queue/pipe does not exist! */
if|if
condition|(
name|fs
operator|->
name|sched
operator|==
name|NULL
condition|)
comment|/* should not happen */
goto|goto
name|dropit
goto|;
comment|/* find scheduler instance, possibly applying sched_mask */
name|si
operator|=
name|ipdn_si_find
argument_list|(
name|fs
operator|->
name|sched
argument_list|,
operator|&
operator|(
name|fwa
operator|->
name|f_id
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|==
name|NULL
condition|)
goto|goto
name|dropit
goto|;
comment|/* 	 * If the scheduler supports multiple queues, find the right one 	 * (otherwise it will be ignored by enqueue). 	 */
if|if
condition|(
name|fs
operator|->
name|sched
operator|->
name|fp
operator|->
name|flags
operator|&
name|DN_MULTIQUEUE
condition|)
block|{
name|q
operator|=
name|ipdn_q_find
argument_list|(
name|fs
argument_list|,
name|si
argument_list|,
operator|&
operator|(
name|fwa
operator|->
name|f_id
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
goto|goto
name|dropit
goto|;
block|}
if|if
condition|(
name|fs
operator|->
name|sched
operator|->
name|fp
operator|->
name|enqueue
argument_list|(
name|si
argument_list|,
name|q
argument_list|,
name|m
argument_list|)
condition|)
block|{
comment|/* packet was dropped by enqueue() */
name|m
operator|=
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
if|if
condition|(
name|si
operator|->
name|kflags
operator|&
name|DN_ACTIVE
condition|)
block|{
name|m
operator|=
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
comment|/* consumed */
goto|goto
name|done
goto|;
comment|/* already active, nothing to do */
block|}
comment|/* compute the initial allowance */
if|if
condition|(
name|si
operator|->
name|idle_time
operator|<
name|dn_cfg
operator|.
name|curr_time
condition|)
block|{
comment|/* Do this only on the first packet on an idle pipe */
name|struct
name|dn_link
modifier|*
name|p
init|=
operator|&
name|fs
operator|->
name|sched
operator|->
name|link
decl_stmt|;
name|si
operator|->
name|sched_time
operator|=
name|dn_cfg
operator|.
name|curr_time
expr_stmt|;
name|si
operator|->
name|credit
operator|=
name|dn_cfg
operator|.
name|io_fast
condition|?
name|p
operator|->
name|bandwidth
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|burst
condition|)
block|{
name|uint64_t
name|burst
init|=
operator|(
name|dn_cfg
operator|.
name|curr_time
operator|-
name|si
operator|->
name|idle_time
operator|)
operator|*
name|p
operator|->
name|bandwidth
decl_stmt|;
if|if
condition|(
name|burst
operator|>
name|p
operator|->
name|burst
condition|)
name|burst
operator|=
name|p
operator|->
name|burst
expr_stmt|;
name|si
operator|->
name|credit
operator|+=
name|burst
expr_stmt|;
block|}
block|}
comment|/* pass through scheduler and delay line */
name|m
operator|=
name|serve_sched
argument_list|(
name|NULL
argument_list|,
name|si
argument_list|,
name|dn_cfg
operator|.
name|curr_time
argument_list|)
expr_stmt|;
comment|/* optimization -- pass it back to ipfw for immediate send */
comment|/* XXX Don't call dummynet_send() if scheduler return the packet 	 *     just enqueued. This avoid a lock order reversal. 	 *      	 */
if|if
condition|(
comment|/*dn_cfg.io_fast&&*/
name|m
operator|==
operator|*
name|m0
operator|&&
operator|(
name|dir
operator|&
name|PROTO_LAYER2
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* fast io, rename the tag * to carry reinject info. */
name|struct
name|m_tag
modifier|*
name|tag
init|=
name|m_tag_first
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|tag
operator|->
name|m_tag_cookie
operator|=
name|MTAG_IPFW_RULE
expr_stmt|;
name|tag
operator|->
name|m_tag_id
operator|=
literal|0
expr_stmt|;
name|io_pkt_fast
operator|++
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_nextpkt
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"dummynet: fast io: pkt chain detected!\n"
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
block|}
name|m
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
block|}
name|done
label|:
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|dummynet_send
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|dropit
label|:
name|io_pkt_drop
operator|++
expr_stmt|;
name|DN_BH_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|FREE_PKT
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|fs
operator|&&
operator|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_NOERROR
operator|)
operator|)
condition|?
literal|0
else|:
name|ENOBUFS
return|;
block|}
end_function

end_unit

