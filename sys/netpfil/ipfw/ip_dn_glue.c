begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010 Riccardo Panicucci, Universita` di Pisa  * All rights reserved  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  *  * Binary compatibility support for /sbin/ipfw RELENG_7 and RELENG_8  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_comment
comment|/* IFNAMSIZ, struct ifaddr, ifq head, lock.h mutex.h */
end_comment

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_comment
comment|/* ip_output(), IP_FORWARDING */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_dummynet.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/ip_fw_private.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/dn_heap.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/ip_dn_private.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/dn_sched.h>
end_include

begin_comment
comment|/* FREEBSD7.2 ip_dummynet.h r191715*/
end_comment

begin_struct
struct|struct
name|dn_heap_entry7
block|{
name|int64_t
name|key
decl_stmt|;
comment|/* sorting key. Topmost element is smallest one */
name|void
modifier|*
name|object
decl_stmt|;
comment|/* object pointer */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dn_heap7
block|{
name|int
name|size
decl_stmt|;
name|int
name|elements
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* XXX if> 0 this is the offset of direct ptr to obj */
name|struct
name|dn_heap_entry7
modifier|*
name|p
decl_stmt|;
comment|/* really an array of "size" entries */
block|}
struct|;
end_struct

begin_comment
comment|/* Common to 7.2 and 8 */
end_comment

begin_struct
struct|struct
name|dn_flow_set
block|{
name|SLIST_ENTRY
argument_list|(
argument|dn_flow_set
argument_list|)
name|next
expr_stmt|;
comment|/* linked list in a hash slot */
name|u_short
name|fs_nr
decl_stmt|;
comment|/* flow_set number       */
name|u_short
name|flags_fs
decl_stmt|;
define|#
directive|define
name|DNOLD_HAVE_FLOW_MASK
value|0x0001
define|#
directive|define
name|DNOLD_IS_RED
value|0x0002
define|#
directive|define
name|DNOLD_IS_GENTLE_RED
value|0x0004
define|#
directive|define
name|DNOLD_QSIZE_IS_BYTES
value|0x0008
comment|/* queue size is measured in bytes */
define|#
directive|define
name|DNOLD_NOERROR
value|0x0010
comment|/* do not report ENOBUFS on drops  */
define|#
directive|define
name|DNOLD_HAS_PROFILE
value|0x0020
comment|/* the pipe has a delay profile. */
define|#
directive|define
name|DNOLD_IS_ECN
value|0x0040
define|#
directive|define
name|DNOLD_IS_PIPE
value|0x4000
define|#
directive|define
name|DNOLD_IS_QUEUE
value|0x8000
name|struct
name|dn_pipe7
modifier|*
name|pipe
decl_stmt|;
comment|/* pointer to parent pipe */
name|u_short
name|parent_nr
decl_stmt|;
comment|/* parent pipe#, 0 if local to a pipe */
name|int
name|weight
decl_stmt|;
comment|/* WFQ queue weight */
name|int
name|qsize
decl_stmt|;
comment|/* queue size in slots or bytes */
name|int
name|plr
decl_stmt|;
comment|/* pkt loss rate (2^31-1 means 100%) */
name|struct
name|ipfw_flow_id
name|flow_mask
decl_stmt|;
comment|/* hash table of queues onto this flow_set */
name|int
name|rq_size
decl_stmt|;
comment|/* number of slots */
name|int
name|rq_elements
decl_stmt|;
comment|/* active elements */
name|struct
name|dn_flow_queue7
modifier|*
modifier|*
name|rq
decl_stmt|;
comment|/* array of rq_size entries */
name|u_int32_t
name|last_expired
decl_stmt|;
comment|/* do not expire too frequently */
name|int
name|backlogged
decl_stmt|;
comment|/* #active queues for this flowset */
comment|/* RED parameters */
define|#
directive|define
name|SCALE_RED
value|16
define|#
directive|define
name|SCALE
parameter_list|(
name|x
parameter_list|)
value|( (x)<< SCALE_RED )
define|#
directive|define
name|SCALE_VAL
parameter_list|(
name|x
parameter_list|)
value|( (x)>> SCALE_RED )
define|#
directive|define
name|SCALE_MUL
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|( ( (x) * (y) )>> SCALE_RED )
name|int
name|w_q
decl_stmt|;
comment|/* queue weight (scaled) */
name|int
name|max_th
decl_stmt|;
comment|/* maximum threshold for queue (scaled) */
name|int
name|min_th
decl_stmt|;
comment|/* minimum threshold for queue (scaled) */
name|int
name|max_p
decl_stmt|;
comment|/* maximum value for p_b (scaled) */
name|u_int
name|c_1
decl_stmt|;
comment|/* max_p/(max_th-min_th) (scaled) */
name|u_int
name|c_2
decl_stmt|;
comment|/* max_p*min_th/(max_th-min_th) (scaled) */
name|u_int
name|c_3
decl_stmt|;
comment|/* for GRED, (1-max_p)/max_th (scaled) */
name|u_int
name|c_4
decl_stmt|;
comment|/* for GRED, 1 - 2*max_p (scaled) */
name|u_int
modifier|*
name|w_q_lookup
decl_stmt|;
comment|/* lookup table for computing (1-w_q)^t */
name|u_int
name|lookup_depth
decl_stmt|;
comment|/* depth of lookup table */
name|int
name|lookup_step
decl_stmt|;
comment|/* granularity inside the lookup table */
name|int
name|lookup_weight
decl_stmt|;
comment|/* equal to (1-w_q)^t / (1-w_q)^(t+1) */
name|int
name|avg_pkt_size
decl_stmt|;
comment|/* medium packet size */
name|int
name|max_pkt_size
decl_stmt|;
comment|/* max packet size */
block|}
struct|;
end_struct

begin_expr_stmt
name|SLIST_HEAD
argument_list|(
name|dn_flow_set_head
argument_list|,
name|dn_flow_set
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DN_IS_PIPE
value|0x4000
end_define

begin_define
define|#
directive|define
name|DN_IS_QUEUE
value|0x8000
end_define

begin_struct
struct|struct
name|dn_flow_queue7
block|{
name|struct
name|dn_flow_queue7
modifier|*
name|next
decl_stmt|;
name|struct
name|ipfw_flow_id
name|id
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
comment|/* queue of packets */
name|u_int
name|len
decl_stmt|;
name|u_int
name|len_bytes
decl_stmt|;
name|u_long
name|numbytes
decl_stmt|;
name|u_int64_t
name|tot_pkts
decl_stmt|;
comment|/* statistics counters  */
name|u_int64_t
name|tot_bytes
decl_stmt|;
name|u_int32_t
name|drops
decl_stmt|;
name|int
name|hash_slot
decl_stmt|;
comment|/* debugging/diagnostic */
comment|/* RED parameters */
name|int
name|avg
decl_stmt|;
comment|/* average queue length est. (scaled) */
name|int
name|count
decl_stmt|;
comment|/* arrivals since last RED drop */
name|int
name|random
decl_stmt|;
comment|/* random value (scaled) */
name|u_int32_t
name|q_time
decl_stmt|;
comment|/* start of queue idle time */
comment|/* WF2Q+ support */
name|struct
name|dn_flow_set
modifier|*
name|fs
decl_stmt|;
comment|/* parent flow set */
name|int
name|heap_pos
decl_stmt|;
comment|/* position (index) of struct in heap */
name|int64_t
name|sched_time
decl_stmt|;
comment|/* current time when queue enters ready_heap */
name|int64_t
name|S
decl_stmt|,
name|F
decl_stmt|;
comment|/* start time, finish time */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dn_pipe7
block|{
comment|/* a pipe */
name|SLIST_ENTRY
argument_list|(
argument|dn_pipe7
argument_list|)
name|next
expr_stmt|;
comment|/* linked list in a hash slot */
name|int
name|pipe_nr
decl_stmt|;
comment|/* number   */
name|int
name|bandwidth
decl_stmt|;
comment|/* really, bytes/tick.  */
name|int
name|delay
decl_stmt|;
comment|/* really, ticks    */
name|struct
name|mbuf
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
comment|/* packets in delay line */
comment|/* WF2Q+ */
name|struct
name|dn_heap7
name|scheduler_heap
decl_stmt|;
comment|/* top extract - key Finish time*/
name|struct
name|dn_heap7
name|not_eligible_heap
decl_stmt|;
comment|/* top extract- key Start time */
name|struct
name|dn_heap7
name|idle_heap
decl_stmt|;
comment|/* random extract - key Start=Finish time */
name|int64_t
name|V
decl_stmt|;
comment|/* virtual time */
name|int
name|sum
decl_stmt|;
comment|/* sum of weights of all active sessions */
name|int
name|numbytes
decl_stmt|;
name|int64_t
name|sched_time
decl_stmt|;
comment|/* time pipe was scheduled in ready_heap */
comment|/* 	* When the tx clock come from an interface (if_name[0] != '\0'), its name 	* is stored below, whereas the ifp is filled when the rule is configured. 	*/
name|char
name|if_name
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|ready
decl_stmt|;
comment|/* set if ifp != NULL and we got a signal from it */
name|struct
name|dn_flow_set
name|fs
decl_stmt|;
comment|/* used with fixed-rate flows */
block|}
struct|;
end_struct

begin_expr_stmt
name|SLIST_HEAD
argument_list|(
name|dn_pipe_head7
argument_list|,
name|dn_pipe7
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* FREEBSD8 ip_dummynet.h r196045 */
end_comment

begin_struct
struct|struct
name|dn_flow_queue8
block|{
name|struct
name|dn_flow_queue8
modifier|*
name|next
decl_stmt|;
name|struct
name|ipfw_flow_id
name|id
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
comment|/* queue of packets */
name|u_int
name|len
decl_stmt|;
name|u_int
name|len_bytes
decl_stmt|;
name|uint64_t
name|numbytes
decl_stmt|;
comment|/* credit for transmission (dynamic queues) */
name|int64_t
name|extra_bits
decl_stmt|;
comment|/* extra bits simulating unavailable channel */
name|u_int64_t
name|tot_pkts
decl_stmt|;
comment|/* statistics counters  */
name|u_int64_t
name|tot_bytes
decl_stmt|;
name|u_int32_t
name|drops
decl_stmt|;
name|int
name|hash_slot
decl_stmt|;
comment|/* debugging/diagnostic */
comment|/* RED parameters */
name|int
name|avg
decl_stmt|;
comment|/* average queue length est. (scaled) */
name|int
name|count
decl_stmt|;
comment|/* arrivals since last RED drop */
name|int
name|random
decl_stmt|;
comment|/* random value (scaled) */
name|int64_t
name|idle_time
decl_stmt|;
comment|/* start of queue idle time */
comment|/* WF2Q+ support */
name|struct
name|dn_flow_set
modifier|*
name|fs
decl_stmt|;
comment|/* parent flow set */
name|int
name|heap_pos
decl_stmt|;
comment|/* position (index) of struct in heap */
name|int64_t
name|sched_time
decl_stmt|;
comment|/* current time when queue enters ready_heap */
name|int64_t
name|S
decl_stmt|,
name|F
decl_stmt|;
comment|/* start time, finish time */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dn_pipe8
block|{
comment|/* a pipe */
name|SLIST_ENTRY
argument_list|(
argument|dn_pipe8
argument_list|)
name|next
expr_stmt|;
comment|/* linked list in a hash slot */
name|int
name|pipe_nr
decl_stmt|;
comment|/* number   */
name|int
name|bandwidth
decl_stmt|;
comment|/* really, bytes/tick.  */
name|int
name|delay
decl_stmt|;
comment|/* really, ticks    */
name|struct
name|mbuf
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
comment|/* packets in delay line */
comment|/* WF2Q+ */
name|struct
name|dn_heap7
name|scheduler_heap
decl_stmt|;
comment|/* top extract - key Finish time*/
name|struct
name|dn_heap7
name|not_eligible_heap
decl_stmt|;
comment|/* top extract- key Start time */
name|struct
name|dn_heap7
name|idle_heap
decl_stmt|;
comment|/* random extract - key Start=Finish time */
name|int64_t
name|V
decl_stmt|;
comment|/* virtual time */
name|int
name|sum
decl_stmt|;
comment|/* sum of weights of all active sessions */
comment|/* Same as in dn_flow_queue, numbytes can become large */
name|int64_t
name|numbytes
decl_stmt|;
comment|/* bits I can transmit (more or less). */
name|uint64_t
name|burst
decl_stmt|;
comment|/* burst size, scaled: bits * hz */
name|int64_t
name|sched_time
decl_stmt|;
comment|/* time pipe was scheduled in ready_heap */
name|int64_t
name|idle_time
decl_stmt|;
comment|/* start of pipe idle time */
name|char
name|if_name
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|ready
decl_stmt|;
comment|/* set if ifp != NULL and we got a signal from it */
name|struct
name|dn_flow_set
name|fs
decl_stmt|;
comment|/* used with fixed-rate flows */
comment|/* fields to simulate a delay profile */
define|#
directive|define
name|ED_MAX_NAME_LEN
value|32
name|char
name|name
index|[
name|ED_MAX_NAME_LEN
index|]
decl_stmt|;
name|int
name|loss_level
decl_stmt|;
name|int
name|samples_no
decl_stmt|;
name|int
modifier|*
name|samples
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ED_MAX_SAMPLES_NO
value|1024
end_define

begin_struct
struct|struct
name|dn_pipe_max8
block|{
name|struct
name|dn_pipe8
name|pipe
decl_stmt|;
name|int
name|samples
index|[
name|ED_MAX_SAMPLES_NO
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|SLIST_HEAD
argument_list|(
name|dn_pipe_head8
argument_list|,
name|dn_pipe8
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Changes from 7.2 to 8:  * dn_pipe:  *      numbytes from int to int64_t  *      add burst (int64_t)  *      add idle_time (int64_t)  *      add profile  *      add struct dn_pipe_max  *      add flag DN_HAS_PROFILE  *  * dn_flow_queue  *      numbytes from u_long to int64_t  *      add extra_bits (int64_t)  *      q_time from u_int32_t to int64_t and name idle_time  *  * dn_flow_set unchanged  *  */
end_comment

begin_comment
comment|/* NOTE:XXX copied from dummynet.c */
end_comment

begin_define
define|#
directive|define
name|O_NEXT
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|)
value|((void *)((char *)p + len))
end_define

begin_function
specifier|static
name|void
name|oid_fill
parameter_list|(
name|struct
name|dn_id
modifier|*
name|oid
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|type
parameter_list|,
name|uintptr_t
name|id
parameter_list|)
block|{
name|oid
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|oid
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|oid
operator|->
name|subtype
operator|=
literal|0
expr_stmt|;
name|oid
operator|->
name|id
operator|=
name|id
expr_stmt|;
block|}
end_function

begin_comment
comment|/* make room in the buffer and move the pointer forward */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|o_next
parameter_list|(
name|struct
name|dn_id
modifier|*
modifier|*
name|o
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|dn_id
modifier|*
name|ret
init|=
operator|*
name|o
decl_stmt|;
name|oid_fill
argument_list|(
name|ret
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|o
operator|=
name|O_NEXT
argument_list|(
operator|*
name|o
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|size_t
name|pipesize7
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_pipe7
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|pipesize8
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_pipe8
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|pipesizemax8
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_pipe_max8
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate 'ipfw' version  * 1: from FreeBSD 7.2  * 0: from FreeBSD 8  * -1: unknown (for now is unused)  *  * It is update when a IP_DUMMYNET_DEL or IP_DUMMYNET_CONFIGURE request arrives  * NOTE: if a IP_DUMMYNET_GET arrives and the 'ipfw' version is unknown,  *       it is suppose to be the FreeBSD 8 version.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|is7
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|convertflags2new
parameter_list|(
name|int
name|src
parameter_list|)
block|{
name|int
name|dst
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|src
operator|&
name|DNOLD_HAVE_FLOW_MASK
condition|)
name|dst
operator||=
name|DN_HAVE_MASK
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|DNOLD_QSIZE_IS_BYTES
condition|)
name|dst
operator||=
name|DN_QSIZE_BYTES
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|DNOLD_NOERROR
condition|)
name|dst
operator||=
name|DN_NOERROR
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|DNOLD_IS_RED
condition|)
name|dst
operator||=
name|DN_IS_RED
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|DNOLD_IS_GENTLE_RED
condition|)
name|dst
operator||=
name|DN_IS_GENTLE_RED
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|DNOLD_IS_ECN
condition|)
name|dst
operator||=
name|DN_IS_ECN
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|DNOLD_HAS_PROFILE
condition|)
name|dst
operator||=
name|DN_HAS_PROFILE
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|convertflags2old
parameter_list|(
name|int
name|src
parameter_list|)
block|{
name|int
name|dst
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|src
operator|&
name|DN_HAVE_MASK
condition|)
name|dst
operator||=
name|DNOLD_HAVE_FLOW_MASK
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|DN_IS_RED
condition|)
name|dst
operator||=
name|DNOLD_IS_RED
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|DN_IS_GENTLE_RED
condition|)
name|dst
operator||=
name|DNOLD_IS_GENTLE_RED
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|DN_NOERROR
condition|)
name|dst
operator||=
name|DNOLD_NOERROR
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|DN_HAS_PROFILE
condition|)
name|dst
operator||=
name|DNOLD_HAS_PROFILE
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|DN_QSIZE_BYTES
condition|)
name|dst
operator||=
name|DNOLD_QSIZE_IS_BYTES
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dn_compat_del
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|dn_pipe7
modifier|*
name|p
init|=
operator|(
expr|struct
name|dn_pipe7
operator|*
operator|)
name|v
decl_stmt|;
name|struct
name|dn_pipe8
modifier|*
name|p8
init|=
operator|(
expr|struct
name|dn_pipe8
operator|*
operator|)
name|v
decl_stmt|;
struct|struct
block|{
name|struct
name|dn_id
name|oid
decl_stmt|;
name|uintptr_t
name|a
index|[
literal|1
index|]
decl_stmt|;
comment|/* add more if we want a list */
block|}
name|cmd
struct|;
comment|/* XXX DN_API_VERSION ??? */
name|oid_fill
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|DN_CMD_DELETE
argument_list|,
name|DN_API_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|is7
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|pipe_nr
operator|==
literal|0
operator|&&
name|p
operator|->
name|fs
operator|.
name|fs_nr
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|p
operator|->
name|pipe_nr
operator|!=
literal|0
operator|&&
name|p
operator|->
name|fs
operator|.
name|fs_nr
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
block|}
else|else
block|{
if|if
condition|(
name|p8
operator|->
name|pipe_nr
operator|==
literal|0
operator|&&
name|p8
operator|->
name|fs
operator|.
name|fs_nr
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|p8
operator|->
name|pipe_nr
operator|!=
literal|0
operator|&&
name|p8
operator|->
name|fs
operator|.
name|fs_nr
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|p
operator|->
name|pipe_nr
operator|!=
literal|0
condition|)
block|{
comment|/* pipe x delete */
name|cmd
operator|.
name|a
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|pipe_nr
expr_stmt|;
name|cmd
operator|.
name|oid
operator|.
name|subtype
operator|=
name|DN_LINK
expr_stmt|;
block|}
else|else
block|{
comment|/* queue x delete */
name|cmd
operator|.
name|oid
operator|.
name|subtype
operator|=
name|DN_FS
expr_stmt|;
name|cmd
operator|.
name|a
index|[
literal|0
index|]
operator|=
operator|(
name|is7
operator|)
condition|?
name|p
operator|->
name|fs
operator|.
name|fs_nr
else|:
name|p8
operator|->
name|fs
operator|.
name|fs_nr
expr_stmt|;
block|}
return|return
name|do_config
argument_list|(
operator|&
name|cmd
argument_list|,
name|cmd
operator|.
name|oid
operator|.
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dn_compat_config_queue
parameter_list|(
name|struct
name|dn_fs
modifier|*
name|fs
parameter_list|,
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|dn_pipe7
modifier|*
name|p7
init|=
operator|(
expr|struct
name|dn_pipe7
operator|*
operator|)
name|v
decl_stmt|;
name|struct
name|dn_pipe8
modifier|*
name|p8
init|=
operator|(
expr|struct
name|dn_pipe8
operator|*
operator|)
name|v
decl_stmt|;
name|struct
name|dn_flow_set
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|is7
condition|)
name|f
operator|=
operator|&
name|p7
operator|->
name|fs
expr_stmt|;
else|else
name|f
operator|=
operator|&
name|p8
operator|->
name|fs
expr_stmt|;
name|fs
operator|->
name|fs_nr
operator|=
name|f
operator|->
name|fs_nr
expr_stmt|;
name|fs
operator|->
name|sched_nr
operator|=
name|f
operator|->
name|parent_nr
expr_stmt|;
name|fs
operator|->
name|flow_mask
operator|=
name|f
operator|->
name|flow_mask
expr_stmt|;
name|fs
operator|->
name|buckets
operator|=
name|f
operator|->
name|rq_size
expr_stmt|;
name|fs
operator|->
name|qsize
operator|=
name|f
operator|->
name|qsize
expr_stmt|;
name|fs
operator|->
name|plr
operator|=
name|f
operator|->
name|plr
expr_stmt|;
name|fs
operator|->
name|par
index|[
literal|0
index|]
operator|=
name|f
operator|->
name|weight
expr_stmt|;
name|fs
operator|->
name|flags
operator|=
name|convertflags2new
argument_list|(
name|f
operator|->
name|flags_fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|flags
operator|&
name|DN_IS_GENTLE_RED
operator|||
name|fs
operator|->
name|flags
operator|&
name|DN_IS_RED
condition|)
block|{
name|fs
operator|->
name|w_q
operator|=
name|f
operator|->
name|w_q
expr_stmt|;
name|fs
operator|->
name|max_th
operator|=
name|f
operator|->
name|max_th
expr_stmt|;
name|fs
operator|->
name|min_th
operator|=
name|f
operator|->
name|min_th
expr_stmt|;
name|fs
operator|->
name|max_p
operator|=
name|f
operator|->
name|max_p
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dn_compat_config_pipe
parameter_list|(
name|struct
name|dn_sch
modifier|*
name|sch
parameter_list|,
name|struct
name|dn_link
modifier|*
name|p
parameter_list|,
name|struct
name|dn_fs
modifier|*
name|fs
parameter_list|,
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|dn_pipe7
modifier|*
name|p7
init|=
operator|(
expr|struct
name|dn_pipe7
operator|*
operator|)
name|v
decl_stmt|;
name|struct
name|dn_pipe8
modifier|*
name|p8
init|=
operator|(
expr|struct
name|dn_pipe8
operator|*
operator|)
name|v
decl_stmt|;
name|int
name|i
init|=
name|p7
operator|->
name|pipe_nr
decl_stmt|;
name|sch
operator|->
name|sched_nr
operator|=
name|i
expr_stmt|;
name|sch
operator|->
name|oid
operator|.
name|subtype
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|link_nr
operator|=
name|i
expr_stmt|;
name|fs
operator|->
name|fs_nr
operator|=
name|i
operator|+
literal|2
operator|*
name|DN_MAX_ID
expr_stmt|;
name|fs
operator|->
name|sched_nr
operator|=
name|i
operator|+
name|DN_MAX_ID
expr_stmt|;
comment|/* Common to 7 and 8 */
name|p
operator|->
name|bandwidth
operator|=
name|p7
operator|->
name|bandwidth
expr_stmt|;
name|p
operator|->
name|delay
operator|=
name|p7
operator|->
name|delay
expr_stmt|;
if|if
condition|(
operator|!
name|is7
condition|)
block|{
comment|/* FreeBSD 8 has burst  */
name|p
operator|->
name|burst
operator|=
name|p8
operator|->
name|burst
expr_stmt|;
block|}
comment|/* fill the fifo flowset */
name|dn_compat_config_queue
argument_list|(
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_nr
operator|=
name|i
operator|+
literal|2
operator|*
name|DN_MAX_ID
expr_stmt|;
name|fs
operator|->
name|sched_nr
operator|=
name|i
operator|+
name|DN_MAX_ID
expr_stmt|;
comment|/* Move scheduler related parameter from fs to sch */
name|sch
operator|->
name|buckets
operator|=
name|fs
operator|->
name|buckets
expr_stmt|;
comment|/*XXX*/
name|fs
operator|->
name|buckets
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|flags
operator|&
name|DN_HAVE_MASK
condition|)
block|{
name|sch
operator|->
name|flags
operator||=
name|DN_HAVE_MASK
expr_stmt|;
name|fs
operator|->
name|flags
operator|&=
operator|~
name|DN_HAVE_MASK
expr_stmt|;
name|sch
operator|->
name|sched_mask
operator|=
name|fs
operator|->
name|flow_mask
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|fs
operator|->
name|flow_mask
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipfw_flow_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dn_compat_config_profile
parameter_list|(
name|struct
name|dn_profile
modifier|*
name|pf
parameter_list|,
name|struct
name|dn_link
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|dn_pipe8
modifier|*
name|p8
init|=
operator|(
expr|struct
name|dn_pipe8
operator|*
operator|)
name|v
decl_stmt|;
name|p8
operator|->
name|samples
operator|=
operator|&
operator|(
operator|(
operator|(
expr|struct
name|dn_pipe_max8
operator|*
operator|)
name|p8
operator|)
operator|->
name|samples
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|pf
operator|->
name|link_nr
operator|=
name|p
operator|->
name|link_nr
expr_stmt|;
name|pf
operator|->
name|loss_level
operator|=
name|p8
operator|->
name|loss_level
expr_stmt|;
comment|// 	pf->bandwidth = p->bandwidth; //XXX bandwidth redundant?
name|pf
operator|->
name|samples_no
operator|=
name|p8
operator|->
name|samples_no
expr_stmt|;
name|strncpy
argument_list|(
name|pf
operator|->
name|name
argument_list|,
name|p8
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|pf
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p8
operator|->
name|samples
argument_list|,
name|pf
operator|->
name|samples
argument_list|,
sizeof|sizeof
argument_list|(
name|pf
operator|->
name|samples
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * If p->pipe_nr != 0 the command is 'pipe x config', so need to create  * the three main struct, else only a flowset is created  */
end_comment

begin_function
specifier|static
name|int
name|dn_compat_configure
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|dn_id
modifier|*
name|buf
init|=
name|NULL
decl_stmt|,
modifier|*
name|base
decl_stmt|;
name|struct
name|dn_sch
modifier|*
name|sch
init|=
name|NULL
decl_stmt|;
name|struct
name|dn_link
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|struct
name|dn_fs
modifier|*
name|fs
init|=
name|NULL
decl_stmt|;
name|struct
name|dn_profile
modifier|*
name|pf
init|=
name|NULL
decl_stmt|;
name|int
name|lmax
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|dn_pipe7
modifier|*
name|p7
init|=
operator|(
expr|struct
name|dn_pipe7
operator|*
operator|)
name|v
decl_stmt|;
name|struct
name|dn_pipe8
modifier|*
name|p8
init|=
operator|(
expr|struct
name|dn_pipe8
operator|*
operator|)
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* number of object to configure */
name|lmax
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_id
argument_list|)
expr_stmt|;
comment|/* command header */
name|lmax
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_sch
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|dn_link
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|dn_fs
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|dn_profile
argument_list|)
expr_stmt|;
name|base
operator|=
name|buf
operator|=
name|malloc
argument_list|(
name|lmax
argument_list|,
name|M_DUMMYNET
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|o_next
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dn_id
argument_list|)
argument_list|,
name|DN_CMD_CONFIG
argument_list|)
expr_stmt|;
name|base
operator|->
name|id
operator|=
name|DN_API_VERSION
expr_stmt|;
comment|/* pipe_nr is the same in p7 and p8 */
name|i
operator|=
name|p7
operator|->
name|pipe_nr
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* pipe config */
name|sch
operator|=
name|o_next
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sch
argument_list|)
argument_list|,
name|DN_SCH
argument_list|)
expr_stmt|;
name|p
operator|=
name|o_next
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|DN_LINK
argument_list|)
expr_stmt|;
name|fs
operator|=
name|o_next
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fs
argument_list|)
argument_list|,
name|DN_FS
argument_list|)
expr_stmt|;
name|error
operator|=
name|dn_compat_config_pipe
argument_list|(
name|sch
argument_list|,
name|p
argument_list|,
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|is7
operator|&&
name|p8
operator|->
name|samples_no
operator|>
literal|0
condition|)
block|{
comment|/* Add profiles*/
name|pf
operator|=
name|o_next
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pf
argument_list|)
argument_list|,
name|DN_PROFILE
argument_list|)
expr_stmt|;
name|error
operator|=
name|dn_compat_config_profile
argument_list|(
name|pf
argument_list|,
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* queue config */
name|fs
operator|=
name|o_next
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fs
argument_list|)
argument_list|,
name|DN_FS
argument_list|)
expr_stmt|;
name|error
operator|=
name|dn_compat_config_queue
argument_list|(
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|error
operator|=
name|do_config
argument_list|(
name|base
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
operator|-
operator|(
name|char
operator|*
operator|)
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|dn_compat_calc_size
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|need
init|=
literal|0
decl_stmt|;
comment|/* XXX use FreeBSD 8 struct size */
comment|/* NOTE: 	 * - half scheduler: 		schk_count/2 	 * - all flowset:		fsk_count 	 * - all flowset queues:	queue_count 	 * - all pipe queue:		si_count 	 */
name|need
operator|+=
name|dn_cfg
operator|.
name|schk_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dn_pipe8
argument_list|)
operator|/
literal|2
expr_stmt|;
name|need
operator|+=
name|dn_cfg
operator|.
name|fsk_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow_set
argument_list|)
expr_stmt|;
name|need
operator|+=
name|dn_cfg
operator|.
name|si_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow_queue8
argument_list|)
expr_stmt|;
name|need
operator|+=
name|dn_cfg
operator|.
name|queue_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow_queue8
argument_list|)
expr_stmt|;
return|return
name|need
return|;
block|}
end_function

begin_function
name|int
name|dn_c_copy_q
parameter_list|(
name|void
modifier|*
name|_ni
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|copy_args
modifier|*
name|a
init|=
name|arg
decl_stmt|;
name|struct
name|dn_flow_queue7
modifier|*
name|fq7
init|=
operator|(
expr|struct
name|dn_flow_queue7
operator|*
operator|)
operator|*
name|a
operator|->
name|start
decl_stmt|;
name|struct
name|dn_flow_queue8
modifier|*
name|fq8
init|=
operator|(
expr|struct
name|dn_flow_queue8
operator|*
operator|)
operator|*
name|a
operator|->
name|start
decl_stmt|;
name|struct
name|dn_flow
modifier|*
name|ni
init|=
operator|(
expr|struct
name|dn_flow
operator|*
operator|)
name|_ni
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
comment|/* XXX hash slot not set */
comment|/* No difference between 7.2/8 */
name|fq7
operator|->
name|len
operator|=
name|ni
operator|->
name|length
expr_stmt|;
name|fq7
operator|->
name|len_bytes
operator|=
name|ni
operator|->
name|len_bytes
expr_stmt|;
name|fq7
operator|->
name|id
operator|=
name|ni
operator|->
name|fid
expr_stmt|;
if|if
condition|(
name|is7
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow_queue7
argument_list|)
expr_stmt|;
name|fq7
operator|->
name|tot_pkts
operator|=
name|ni
operator|->
name|tot_pkts
expr_stmt|;
name|fq7
operator|->
name|tot_bytes
operator|=
name|ni
operator|->
name|tot_bytes
expr_stmt|;
name|fq7
operator|->
name|drops
operator|=
name|ni
operator|->
name|drops
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow_queue8
argument_list|)
expr_stmt|;
name|fq8
operator|->
name|tot_pkts
operator|=
name|ni
operator|->
name|tot_pkts
expr_stmt|;
name|fq8
operator|->
name|tot_bytes
operator|=
name|ni
operator|->
name|tot_bytes
expr_stmt|;
name|fq8
operator|->
name|drops
operator|=
name|ni
operator|->
name|drops
expr_stmt|;
block|}
operator|*
name|a
operator|->
name|start
operator|+=
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dn_c_copy_pipe
parameter_list|(
name|struct
name|dn_schk
modifier|*
name|s
parameter_list|,
name|struct
name|copy_args
modifier|*
name|a
parameter_list|,
name|int
name|nq
parameter_list|)
block|{
name|struct
name|dn_link
modifier|*
name|l
init|=
operator|&
name|s
operator|->
name|link
decl_stmt|;
name|struct
name|dn_fsk
modifier|*
name|f
init|=
name|s
operator|->
name|fs
decl_stmt|;
name|struct
name|dn_pipe7
modifier|*
name|pipe7
init|=
operator|(
expr|struct
name|dn_pipe7
operator|*
operator|)
operator|*
name|a
operator|->
name|start
decl_stmt|;
name|struct
name|dn_pipe8
modifier|*
name|pipe8
init|=
operator|(
expr|struct
name|dn_pipe8
operator|*
operator|)
operator|*
name|a
operator|->
name|start
decl_stmt|;
name|struct
name|dn_flow_set
modifier|*
name|fs
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|is7
condition|)
block|{
name|fs
operator|=
operator|&
name|pipe7
operator|->
name|fs
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_pipe7
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fs
operator|=
operator|&
name|pipe8
operator|->
name|fs
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_pipe8
argument_list|)
expr_stmt|;
block|}
comment|/* These 4 field are the same in pipe7 and pipe8 */
name|pipe7
operator|->
name|next
operator|.
name|sle_next
operator|=
operator|(
expr|struct
name|dn_pipe7
operator|*
operator|)
name|DN_IS_PIPE
expr_stmt|;
name|pipe7
operator|->
name|bandwidth
operator|=
name|l
operator|->
name|bandwidth
expr_stmt|;
name|pipe7
operator|->
name|delay
operator|=
name|l
operator|->
name|delay
operator|*
literal|1000
operator|/
name|hz
expr_stmt|;
name|pipe7
operator|->
name|pipe_nr
operator|=
name|l
operator|->
name|link_nr
operator|-
name|DN_MAX_ID
expr_stmt|;
if|if
condition|(
operator|!
name|is7
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|profile
condition|)
block|{
name|struct
name|dn_profile
modifier|*
name|pf
init|=
name|s
operator|->
name|profile
decl_stmt|;
name|strncpy
argument_list|(
name|pipe8
operator|->
name|name
argument_list|,
name|pf
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|pf
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|pipe8
operator|->
name|loss_level
operator|=
name|pf
operator|->
name|loss_level
expr_stmt|;
name|pipe8
operator|->
name|samples_no
operator|=
name|pf
operator|->
name|samples_no
expr_stmt|;
block|}
name|pipe8
operator|->
name|burst
operator|=
name|div64
argument_list|(
name|l
operator|->
name|burst
argument_list|,
literal|8
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|fs
operator|->
name|flow_mask
operator|=
name|s
operator|->
name|sch
operator|.
name|sched_mask
expr_stmt|;
name|fs
operator|->
name|rq_size
operator|=
name|s
operator|->
name|sch
operator|.
name|buckets
condition|?
name|s
operator|->
name|sch
operator|.
name|buckets
else|:
literal|1
expr_stmt|;
name|fs
operator|->
name|parent_nr
operator|=
name|l
operator|->
name|link_nr
operator|-
name|DN_MAX_ID
expr_stmt|;
name|fs
operator|->
name|qsize
operator|=
name|f
operator|->
name|fs
operator|.
name|qsize
expr_stmt|;
name|fs
operator|->
name|plr
operator|=
name|f
operator|->
name|fs
operator|.
name|plr
expr_stmt|;
name|fs
operator|->
name|w_q
operator|=
name|f
operator|->
name|fs
operator|.
name|w_q
expr_stmt|;
name|fs
operator|->
name|max_th
operator|=
name|f
operator|->
name|max_th
expr_stmt|;
name|fs
operator|->
name|min_th
operator|=
name|f
operator|->
name|min_th
expr_stmt|;
name|fs
operator|->
name|max_p
operator|=
name|f
operator|->
name|fs
operator|.
name|max_p
expr_stmt|;
name|fs
operator|->
name|rq_elements
operator|=
name|nq
expr_stmt|;
name|fs
operator|->
name|flags_fs
operator|=
name|convertflags2old
argument_list|(
name|f
operator|->
name|fs
operator|.
name|flags
argument_list|)
expr_stmt|;
operator|*
name|a
operator|->
name|start
operator|+=
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dn_compat_copy_pipe
parameter_list|(
name|struct
name|copy_args
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|_o
parameter_list|)
block|{
name|int
name|have
init|=
name|a
operator|->
name|end
operator|-
operator|*
name|a
operator|->
name|start
decl_stmt|;
name|int
name|need
init|=
literal|0
decl_stmt|;
name|int
name|pipe_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_pipe8
argument_list|)
decl_stmt|;
name|int
name|queue_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow_queue8
argument_list|)
decl_stmt|;
name|int
name|n_queue
init|=
literal|0
decl_stmt|;
comment|/* number of queues */
name|struct
name|dn_schk
modifier|*
name|s
init|=
operator|(
expr|struct
name|dn_schk
operator|*
operator|)
name|_o
decl_stmt|;
comment|/* calculate needed space: 	 * - struct dn_pipe 	 * - if there are instances, dn_queue * n_instances 	 */
name|n_queue
operator|=
operator|(
name|s
operator|->
name|sch
operator|.
name|flags
operator|&
name|DN_HAVE_MASK
condition|?
name|dn_ht_entries
argument_list|(
name|s
operator|->
name|siht
argument_list|)
else|:
operator|(
name|s
operator|->
name|siht
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|need
operator|=
name|pipe_size
operator|+
name|queue_size
operator|*
name|n_queue
expr_stmt|;
if|if
condition|(
name|have
operator|<
name|need
condition|)
block|{
name|D
argument_list|(
literal|"have %d< need %d"
argument_list|,
name|have
argument_list|,
name|need
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* copy pipe */
name|dn_c_copy_pipe
argument_list|(
name|s
argument_list|,
name|a
argument_list|,
name|n_queue
argument_list|)
expr_stmt|;
comment|/* copy queues */
if|if
condition|(
name|s
operator|->
name|sch
operator|.
name|flags
operator|&
name|DN_HAVE_MASK
condition|)
name|dn_ht_scan
argument_list|(
name|s
operator|->
name|siht
argument_list|,
name|dn_c_copy_q
argument_list|,
name|a
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|siht
condition|)
name|dn_c_copy_q
argument_list|(
name|s
operator|->
name|siht
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dn_c_copy_fs
parameter_list|(
name|struct
name|dn_fsk
modifier|*
name|f
parameter_list|,
name|struct
name|copy_args
modifier|*
name|a
parameter_list|,
name|int
name|nq
parameter_list|)
block|{
name|struct
name|dn_flow_set
modifier|*
name|fs
init|=
operator|(
expr|struct
name|dn_flow_set
operator|*
operator|)
operator|*
name|a
operator|->
name|start
decl_stmt|;
name|fs
operator|->
name|next
operator|.
name|sle_next
operator|=
operator|(
expr|struct
name|dn_flow_set
operator|*
operator|)
name|DN_IS_QUEUE
expr_stmt|;
name|fs
operator|->
name|fs_nr
operator|=
name|f
operator|->
name|fs
operator|.
name|fs_nr
expr_stmt|;
name|fs
operator|->
name|qsize
operator|=
name|f
operator|->
name|fs
operator|.
name|qsize
expr_stmt|;
name|fs
operator|->
name|plr
operator|=
name|f
operator|->
name|fs
operator|.
name|plr
expr_stmt|;
name|fs
operator|->
name|w_q
operator|=
name|f
operator|->
name|fs
operator|.
name|w_q
expr_stmt|;
name|fs
operator|->
name|max_th
operator|=
name|f
operator|->
name|max_th
expr_stmt|;
name|fs
operator|->
name|min_th
operator|=
name|f
operator|->
name|min_th
expr_stmt|;
name|fs
operator|->
name|max_p
operator|=
name|f
operator|->
name|fs
operator|.
name|max_p
expr_stmt|;
name|fs
operator|->
name|flow_mask
operator|=
name|f
operator|->
name|fs
operator|.
name|flow_mask
expr_stmt|;
name|fs
operator|->
name|rq_elements
operator|=
name|nq
expr_stmt|;
name|fs
operator|->
name|rq_size
operator|=
operator|(
name|f
operator|->
name|fs
operator|.
name|buckets
condition|?
name|f
operator|->
name|fs
operator|.
name|buckets
else|:
literal|1
operator|)
expr_stmt|;
name|fs
operator|->
name|parent_nr
operator|=
name|f
operator|->
name|fs
operator|.
name|sched_nr
expr_stmt|;
name|fs
operator|->
name|weight
operator|=
name|f
operator|->
name|fs
operator|.
name|par
index|[
literal|0
index|]
expr_stmt|;
name|fs
operator|->
name|flags_fs
operator|=
name|convertflags2old
argument_list|(
name|f
operator|->
name|fs
operator|.
name|flags
argument_list|)
expr_stmt|;
operator|*
name|a
operator|->
name|start
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow_set
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dn_compat_copy_queue
parameter_list|(
name|struct
name|copy_args
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|_o
parameter_list|)
block|{
name|int
name|have
init|=
name|a
operator|->
name|end
operator|-
operator|*
name|a
operator|->
name|start
decl_stmt|;
name|int
name|need
init|=
literal|0
decl_stmt|;
name|int
name|fs_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow_set
argument_list|)
decl_stmt|;
name|int
name|queue_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow_queue8
argument_list|)
decl_stmt|;
name|struct
name|dn_fsk
modifier|*
name|fs
init|=
operator|(
expr|struct
name|dn_fsk
operator|*
operator|)
name|_o
decl_stmt|;
name|int
name|n_queue
init|=
literal|0
decl_stmt|;
comment|/* number of queues */
name|n_queue
operator|=
operator|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_HAVE_MASK
condition|?
name|dn_ht_entries
argument_list|(
name|fs
operator|->
name|qht
argument_list|)
else|:
operator|(
name|fs
operator|->
name|qht
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|need
operator|=
name|fs_size
operator|+
name|queue_size
operator|*
name|n_queue
expr_stmt|;
if|if
condition|(
name|have
operator|<
name|need
condition|)
block|{
name|D
argument_list|(
literal|"have< need"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* copy flowset */
name|dn_c_copy_fs
argument_list|(
name|fs
argument_list|,
name|a
argument_list|,
name|n_queue
argument_list|)
expr_stmt|;
comment|/* copy queues */
if|if
condition|(
name|fs
operator|->
name|fs
operator|.
name|flags
operator|&
name|DN_HAVE_MASK
condition|)
name|dn_ht_scan
argument_list|(
name|fs
operator|->
name|qht
argument_list|,
name|dn_c_copy_q
argument_list|,
name|a
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fs
operator|->
name|qht
condition|)
name|dn_c_copy_q
argument_list|(
name|fs
operator|->
name|qht
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|copy_data_helper_compat
parameter_list|(
name|void
modifier|*
name|_o
parameter_list|,
name|void
modifier|*
name|_arg
parameter_list|)
block|{
name|struct
name|copy_args
modifier|*
name|a
init|=
name|_arg
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|type
operator|==
name|DN_COMPAT_PIPE
condition|)
block|{
name|struct
name|dn_schk
modifier|*
name|s
init|=
name|_o
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|sch
operator|.
name|oid
operator|.
name|subtype
operator|!=
literal|1
operator|||
name|s
operator|->
name|sch
operator|.
name|sched_nr
operator|<=
name|DN_MAX_ID
condition|)
block|{
return|return
literal|0
return|;
comment|/* not old type */
block|}
comment|/* copy pipe parameters, and if instance exists, copy 		 * other parameters and eventually queues. 		 */
if|if
condition|(
name|dn_compat_copy_pipe
argument_list|(
name|a
argument_list|,
name|_o
argument_list|)
condition|)
return|return
name|DNHT_SCAN_END
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|type
operator|==
name|DN_COMPAT_QUEUE
condition|)
block|{
name|struct
name|dn_fsk
modifier|*
name|fs
init|=
name|_o
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs
operator|.
name|fs_nr
operator|>=
name|DN_MAX_ID
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dn_compat_copy_queue
argument_list|(
name|a
argument_list|,
name|_o
argument_list|)
condition|)
return|return
name|DNHT_SCAN_END
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Main function to manage old requests */
end_comment

begin_function
name|int
name|ip_dummynet_compat
parameter_list|(
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|v
init|=
name|NULL
decl_stmt|;
name|struct
name|dn_id
name|oid
decl_stmt|;
comment|/* Lenght of data, used to found ipfw version... */
name|int
name|len
init|=
name|sopt
operator|->
name|sopt_valsize
decl_stmt|;
comment|/* len can be 0 if command was dummynet_flush */
if|if
condition|(
name|len
operator|==
name|pipesize7
condition|)
block|{
name|D
argument_list|(
literal|"setting compatibility with FreeBSD 7.2"
argument_list|)
expr_stmt|;
name|is7
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
name|pipesize8
operator|||
name|len
operator|==
name|pipesizemax8
condition|)
block|{
name|D
argument_list|(
literal|"setting compatibility with FreeBSD 8"
argument_list|)
expr_stmt|;
name|is7
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
default|default:
name|printf
argument_list|(
literal|"dummynet: -- unknown option %d"
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|IP_DUMMYNET_FLUSH
case|:
name|oid_fill
argument_list|(
operator|&
name|oid
argument_list|,
sizeof|sizeof
argument_list|(
name|oid
argument_list|)
argument_list|,
name|DN_CMD_FLUSH
argument_list|,
name|DN_API_VERSION
argument_list|)
expr_stmt|;
name|do_config
argument_list|(
operator|&
name|oid
argument_list|,
name|oid
operator|.
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_DUMMYNET_DEL
case|:
name|v
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
name|v
argument_list|,
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|dn_compat_del
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_DUMMYNET_CONFIGURE
case|:
name|v
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
name|v
argument_list|,
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|dn_compat_configure
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_DUMMYNET_GET
case|:
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|original_size
init|=
name|sopt
operator|->
name|sopt_valsize
decl_stmt|;
name|int
name|size
decl_stmt|;
name|ret
operator|=
name|dummynet_get
argument_list|(
name|sopt
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
literal|0
return|;
comment|//XXX ?
name|size
operator|=
name|sopt
operator|->
name|sopt_valsize
expr_stmt|;
name|sopt
operator|->
name|sopt_valsize
operator|=
name|original_size
expr_stmt|;
name|D
argument_list|(
literal|"size=%d, buf=%p"
argument_list|,
name|size
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|printf
argument_list|(
literal|"  %s ERROR sooptcopyout\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|,
name|M_DUMMYNET
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

end_unit

