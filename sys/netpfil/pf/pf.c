begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Daniel Hartmeier  * Copyright (c) 2002 - 2008 Henning Brauer  * Copyright (c) 2012 Gleb Smirnoff<glebius@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *    - Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *    - Redistributions in binary form must reproduce the above  *      copyright notice, this list of conditions and the following  *      disclaimer in the documentation and/or other materials provided  *      with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * Effort sponsored in part by the Defense Advanced Research Projects  * Agency (DARPA) and Air Force Research Laboratory, Air Force  * Materiel Command, USAF, under agreement number F30602-01-2-0537.  *  *	$OpenBSD: pf.c,v 1.634 2009/02/27 12:37:45 henning Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_bpf.h"
end_include

begin_include
include|#
directive|include
file|"opt_pf.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/md5.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/radix_mpath.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<net/pfvar.h>
end_include

begin_include
include|#
directive|include
file|<net/if_pflog.h>
end_include

begin_include
include|#
directive|include
file|<net/if_pfsync.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_fib.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp_var.h>
end_include

begin_include
include|#
directive|include
file|<netpfil/ipfw/ip_fw_private.h>
end_include

begin_comment
comment|/* XXX: only for DIR_IN/DIR_OUT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_fib.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/scope6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_define
define|#
directive|define
name|DPFPRINTF
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (V_pf_status.debug>= (n)) printf x
end_define

begin_comment
comment|/*  * Global variables  */
end_comment

begin_comment
comment|/* state tables */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_altqqueue
argument_list|,
name|pf_altqs
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_palist
argument_list|,
name|pf_pabuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_altqqueue
operator|*
argument_list|,
name|pf_altqs_active
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_altqqueue
operator|*
argument_list|,
name|pf_altqs_inactive
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_kstatus
argument_list|,
name|pf_status
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|u_int32_t
argument_list|,
name|ticket_altqs_active
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|u_int32_t
argument_list|,
name|ticket_altqs_inactive
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|altqs_inactive_open
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|u_int32_t
argument_list|,
name|ticket_pabuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|MD5_CTX
argument_list|,
name|pf_tcp_secret_ctx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_tcp_secret_ctx
value|VNET(pf_tcp_secret_ctx)
end_define

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|u_char
argument_list|,
name|pf_tcp_secret
index|[
literal|16
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_tcp_secret
value|VNET(pf_tcp_secret)
end_define

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|pf_tcp_secret_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_tcp_secret_init
value|VNET(pf_tcp_secret_init)
end_define

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|pf_tcp_iss_off
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_tcp_iss_off
value|VNET(pf_tcp_iss_off)
end_define

begin_expr_stmt
name|VNET_DECLARE
argument_list|(
name|int
argument_list|,
name|pf_vnet_active
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_vnet_active
value|VNET(pf_vnet_active)
end_define

begin_comment
comment|/*  * Queue for pf_intr() sends.  */
end_comment

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_PFTEMP
argument_list|,
literal|"pf_temp"
argument_list|,
literal|"pf(4) temporary allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|pf_send_entry
block|{
name|STAILQ_ENTRY
argument_list|(
argument|pf_send_entry
argument_list|)
name|pfse_next
expr_stmt|;
name|struct
name|mbuf
modifier|*
name|pfse_m
decl_stmt|;
enum|enum
block|{
name|PFSE_IP
block|,
name|PFSE_IP6
block|,
name|PFSE_ICMP
block|,
name|PFSE_ICMP6
block|, 	}
name|pfse_type
enum|;
struct|struct
block|{
name|int
name|type
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|mtu
decl_stmt|;
block|}
name|icmpopts
struct|;
block|}
struct|;
end_struct

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|pf_send_head
argument_list|,
name|pf_send_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_send_head
argument_list|,
name|pf_sendqueue
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_sendqueue
value|VNET(pf_sendqueue)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|pf_sendqueue_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|pf_sendqueue_mtx
argument_list|,
operator|&
name|pf_sendqueue_mtx
argument_list|,
literal|"pf send queue"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PF_SENDQ_LOCK
parameter_list|()
value|mtx_lock(&pf_sendqueue_mtx)
end_define

begin_define
define|#
directive|define
name|PF_SENDQ_UNLOCK
parameter_list|()
value|mtx_unlock(&pf_sendqueue_mtx)
end_define

begin_comment
comment|/*  * Queue for pf_overload_task() tasks.  */
end_comment

begin_struct
struct|struct
name|pf_overload_entry
block|{
name|SLIST_ENTRY
argument_list|(
argument|pf_overload_entry
argument_list|)
name|next
expr_stmt|;
name|struct
name|pf_addr
name|addr
decl_stmt|;
name|sa_family_t
name|af
decl_stmt|;
name|uint8_t
name|dir
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|SLIST_HEAD
argument_list|(
name|pf_overload_head
argument_list|,
name|pf_overload_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_overload_head
argument_list|,
name|pf_overloadqueue
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_overloadqueue
value|VNET(pf_overloadqueue)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|task
argument_list|,
name|pf_overloadtask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_overloadtask
value|VNET(pf_overloadtask)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|pf_overloadqueue_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|pf_overloadqueue_mtx
argument_list|,
operator|&
name|pf_overloadqueue_mtx
argument_list|,
literal|"pf overload/flush queue"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PF_OVERLOADQ_LOCK
parameter_list|()
value|mtx_lock(&pf_overloadqueue_mtx)
end_define

begin_define
define|#
directive|define
name|PF_OVERLOADQ_UNLOCK
parameter_list|()
value|mtx_unlock(&pf_overloadqueue_mtx)
end_define

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_rulequeue
argument_list|,
name|pf_unlinked_rules
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mtx
name|pf_unlnkdrules_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|pf_unlnkdrules_mtx
argument_list|,
operator|&
name|pf_unlnkdrules_mtx
argument_list|,
literal|"pf unlinked rules"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|uma_zone_t
argument_list|,
name|pf_sources_z
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_sources_z
value|VNET(pf_sources_z)
end_define

begin_decl_stmt
name|uma_zone_t
name|pf_mtag_z
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|uma_zone_t
argument_list|,
name|pf_state_z
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|uma_zone_t
argument_list|,
name|pf_state_key_z
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|uint64_t
argument_list|,
name|pf_stateid
index|[
name|MAXCPU
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PFID_CPUBITS
value|8
end_define

begin_define
define|#
directive|define
name|PFID_CPUSHIFT
value|(sizeof(uint64_t) * NBBY - PFID_CPUBITS)
end_define

begin_define
define|#
directive|define
name|PFID_CPUMASK
value|((uint64_t)((1<< PFID_CPUBITS) - 1)<<	PFID_CPUSHIFT)
end_define

begin_define
define|#
directive|define
name|PFID_MAXID
value|(~PFID_CPUMASK)
end_define

begin_expr_stmt
name|CTASSERT
argument_list|(
operator|(
literal|1
operator|<<
name|PFID_CPUBITS
operator|)
operator|>=
name|MAXCPU
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|pf_src_tree_remove_state
parameter_list|(
name|struct
name|pf_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_init_threshold
parameter_list|(
name|struct
name|pf_threshold
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_add_threshold
parameter_list|(
name|struct
name|pf_threshold
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_check_threshold
parameter_list|(
name|struct
name|pf_threshold
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_change_ap
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|pf_addr
modifier|*
parameter_list|,
name|u_int16_t
modifier|*
parameter_list|,
name|u_int16_t
modifier|*
parameter_list|,
name|u_int16_t
modifier|*
parameter_list|,
name|struct
name|pf_addr
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|sa_family_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_modulate_sack
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
parameter_list|,
name|struct
name|tcphdr
modifier|*
parameter_list|,
name|struct
name|pf_state_peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_change_icmp
parameter_list|(
name|struct
name|pf_addr
modifier|*
parameter_list|,
name|u_int16_t
modifier|*
parameter_list|,
name|struct
name|pf_addr
modifier|*
parameter_list|,
name|struct
name|pf_addr
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int16_t
modifier|*
parameter_list|,
name|u_int16_t
modifier|*
parameter_list|,
name|u_int16_t
modifier|*
parameter_list|,
name|u_int16_t
modifier|*
parameter_list|,
name|u_int8_t
parameter_list|,
name|sa_family_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_send_tcp
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|pf_rule
modifier|*
parameter_list|,
name|sa_family_t
parameter_list|,
specifier|const
name|struct
name|pf_addr
modifier|*
parameter_list|,
specifier|const
name|struct
name|pf_addr
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|int
parameter_list|,
name|u_int16_t
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_send_icmp
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|sa_family_t
parameter_list|,
name|struct
name|pf_rule
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_detach_state
parameter_list|(
name|struct
name|pf_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_state_key_attach
parameter_list|(
name|struct
name|pf_state_key
modifier|*
parameter_list|,
name|struct
name|pf_state_key
modifier|*
parameter_list|,
name|struct
name|pf_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_state_key_detach
parameter_list|(
name|struct
name|pf_state
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_state_key_ctor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|pf_tcp_iss
parameter_list|(
name|struct
name|pf_pdesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_test_rule
parameter_list|(
name|struct
name|pf_rule
modifier|*
modifier|*
parameter_list|,
name|struct
name|pf_state
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|pfi_kif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
parameter_list|,
name|struct
name|pf_rule
modifier|*
modifier|*
parameter_list|,
name|struct
name|pf_ruleset
modifier|*
modifier|*
parameter_list|,
name|struct
name|inpcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_create_state
parameter_list|(
name|struct
name|pf_rule
modifier|*
parameter_list|,
name|struct
name|pf_rule
modifier|*
parameter_list|,
name|struct
name|pf_rule
modifier|*
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
parameter_list|,
name|struct
name|pf_src_node
modifier|*
parameter_list|,
name|struct
name|pf_state_key
modifier|*
parameter_list|,
name|struct
name|pf_state_key
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int16_t
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|pfi_kif
modifier|*
parameter_list|,
name|struct
name|pf_state
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int16_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_test_fragment
parameter_list|(
name|struct
name|pf_rule
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|pfi_kif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
parameter_list|,
name|struct
name|pf_rule
modifier|*
modifier|*
parameter_list|,
name|struct
name|pf_ruleset
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_tcp_track_full
parameter_list|(
name|struct
name|pf_state_peer
modifier|*
parameter_list|,
name|struct
name|pf_state_peer
modifier|*
parameter_list|,
name|struct
name|pf_state
modifier|*
modifier|*
parameter_list|,
name|struct
name|pfi_kif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
parameter_list|,
name|u_short
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_tcp_track_sloppy
parameter_list|(
name|struct
name|pf_state_peer
modifier|*
parameter_list|,
name|struct
name|pf_state_peer
modifier|*
parameter_list|,
name|struct
name|pf_state
modifier|*
modifier|*
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
parameter_list|,
name|u_short
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_test_state_tcp
parameter_list|(
name|struct
name|pf_state
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|pfi_kif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
parameter_list|,
name|u_short
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_test_state_udp
parameter_list|(
name|struct
name|pf_state
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|pfi_kif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_test_state_icmp
parameter_list|(
name|struct
name|pf_state
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|pfi_kif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
parameter_list|,
name|u_short
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_test_state_other
parameter_list|(
name|struct
name|pf_state
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|pfi_kif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|pf_get_wscale
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int16_t
parameter_list|,
name|sa_family_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|pf_get_mss
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int16_t
parameter_list|,
name|sa_family_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|pf_calc_mss
parameter_list|(
name|struct
name|pf_addr
modifier|*
parameter_list|,
name|sa_family_t
parameter_list|,
name|int
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_check_proto_cksum
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
parameter_list|,
name|sa_family_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_print_state_parts
parameter_list|(
name|struct
name|pf_state
modifier|*
parameter_list|,
name|struct
name|pf_state_key
modifier|*
parameter_list|,
name|struct
name|pf_state_key
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_addr_wrap_neq
parameter_list|(
name|struct
name|pf_addr_wrap
modifier|*
parameter_list|,
name|struct
name|pf_addr_wrap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pf_state
modifier|*
name|pf_find_state
parameter_list|(
name|struct
name|pfi_kif
modifier|*
parameter_list|,
name|struct
name|pf_state_key_cmp
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_src_connlimit
parameter_list|(
name|struct
name|pf_state
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_overload_task
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_insert_src_node
parameter_list|(
name|struct
name|pf_src_node
modifier|*
modifier|*
parameter_list|,
name|struct
name|pf_rule
modifier|*
parameter_list|,
name|struct
name|pf_addr
modifier|*
parameter_list|,
name|sa_family_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|pf_purge_expired_states
parameter_list|(
name|u_int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_purge_unlinked_rules
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_mtag_uminit
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_mtag_free
parameter_list|(
name|struct
name|m_tag
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function_decl
specifier|static
name|void
name|pf_route
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|pf_rule
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|pf_state
modifier|*
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function_decl
specifier|static
name|void
name|pf_change_a6
parameter_list|(
name|struct
name|pf_addr
modifier|*
parameter_list|,
name|u_int16_t
modifier|*
parameter_list|,
name|struct
name|pf_addr
modifier|*
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_route6
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|pf_rule
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|pf_state
modifier|*
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_function_decl
name|int
name|in4_cksum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int8_t
name|nxt
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|pf_end_threads
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_limit
argument_list|,
name|pf_limits
index|[
name|PF_LIMIT_MAX
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PACKET_LOOPED
parameter_list|(
name|pd
parameter_list|)
value|((pd)->pf_mtag&&			\ 				 (pd)->pf_mtag->flags& PF_PACKET_LOOPED)
end_define

begin_define
define|#
directive|define
name|STATE_LOOKUP
parameter_list|(
name|i
parameter_list|,
name|k
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|,
name|pd
parameter_list|)
define|\
value|do {								\ 		(s) = pf_find_state((i), (k), (d));			\ 		if ((s) == NULL)					\ 			return (PF_DROP);				\ 		if (PACKET_LOOPED(pd))					\ 			return (PF_PASS);				\ 		if ((d) == PF_OUT&&					\ 		    (((s)->rule.ptr->rt == PF_ROUTETO&&		\ 		    (s)->rule.ptr->direction == PF_OUT) ||		\ 		    ((s)->rule.ptr->rt == PF_REPLYTO&&			\ 		    (s)->rule.ptr->direction == PF_IN))&&		\ 		    (s)->rt_kif != NULL&&				\ 		    (s)->rt_kif != (i))					\ 			return (PF_PASS);				\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|BOUND_IFACE
parameter_list|(
name|r
parameter_list|,
name|k
parameter_list|)
define|\
value|((r)->rule_flag& PFRULE_IFBOUND) ? (k) : V_pfi_all
end_define

begin_define
define|#
directive|define
name|STATE_INC_COUNTERS
parameter_list|(
name|s
parameter_list|)
define|\
value|do {								\ 		counter_u64_add(s->rule.ptr->states_cur, 1);		\ 		counter_u64_add(s->rule.ptr->states_tot, 1);		\ 		if (s->anchor.ptr != NULL) {				\ 			counter_u64_add(s->anchor.ptr->states_cur, 1);	\ 			counter_u64_add(s->anchor.ptr->states_tot, 1);	\ 		}							\ 		if (s->nat_rule.ptr != NULL) {				\ 			counter_u64_add(s->nat_rule.ptr->states_cur, 1);\ 			counter_u64_add(s->nat_rule.ptr->states_tot, 1);\ 		}							\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|STATE_DEC_COUNTERS
parameter_list|(
name|s
parameter_list|)
define|\
value|do {								\ 		if (s->nat_rule.ptr != NULL)				\ 			counter_u64_add(s->nat_rule.ptr->states_cur, -1);\ 		if (s->anchor.ptr != NULL)				\ 			counter_u64_add(s->anchor.ptr->states_cur, -1);	\ 		counter_u64_add(s->rule.ptr->states_cur, -1);		\ 	} while (0)
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_PFHASH
argument_list|,
literal|"pf_hash"
argument_list|,
literal|"pf(4) hash header structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_keyhash
operator|*
argument_list|,
name|pf_keyhash
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_idhash
operator|*
argument_list|,
name|pf_idhash
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_srchash
operator|*
argument_list|,
name|pf_srchash
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net
argument_list|,
name|OID_AUTO
argument_list|,
name|pf
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"pf(4)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_long
name|pf_hashmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|pf_srchashmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|pf_hashsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|pf_srchashsize
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_pf
argument_list|,
name|OID_AUTO
argument_list|,
name|states_hashsize
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|pf_hashsize
argument_list|,
literal|0
argument_list|,
literal|"Size of pf(4) states hashtable"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_pf
argument_list|,
name|OID_AUTO
argument_list|,
name|source_nodes_hashsize
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|pf_srchashsize
argument_list|,
literal|0
argument_list|,
literal|"Size of pf(4) source nodes hashtable"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|void
operator|*
argument_list|,
name|pf_swi_cookie
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|uint32_t
argument_list|,
name|pf_hashseed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_hashseed
value|VNET(pf_hashseed)
end_define

begin_function
name|int
name|pf_addr_cmp
parameter_list|(
name|struct
name|pf_addr
modifier|*
name|a
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|b
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|a
operator|->
name|addr32
index|[
literal|0
index|]
operator|>
name|b
operator|->
name|addr32
index|[
literal|0
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|addr32
index|[
literal|0
index|]
operator|<
name|b
operator|->
name|addr32
index|[
literal|0
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|a
operator|->
name|addr32
index|[
literal|3
index|]
operator|>
name|b
operator|->
name|addr32
index|[
literal|3
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|addr32
index|[
literal|3
index|]
operator|<
name|b
operator|->
name|addr32
index|[
literal|3
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|addr32
index|[
literal|2
index|]
operator|>
name|b
operator|->
name|addr32
index|[
literal|2
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|addr32
index|[
literal|2
index|]
operator|<
name|b
operator|->
name|addr32
index|[
literal|2
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|addr32
index|[
literal|1
index|]
operator|>
name|b
operator|->
name|addr32
index|[
literal|1
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|addr32
index|[
literal|1
index|]
operator|<
name|b
operator|->
name|addr32
index|[
literal|1
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|addr32
index|[
literal|0
index|]
operator|>
name|b
operator|->
name|addr32
index|[
literal|0
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|addr32
index|[
literal|0
index|]
operator|<
name|b
operator|->
name|addr32
index|[
literal|0
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
name|panic
argument_list|(
literal|"%s: unknown address family %u"
argument_list|,
name|__func__
argument_list|,
name|af
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|pf_hashkey
parameter_list|(
name|struct
name|pf_state_key
modifier|*
name|sk
parameter_list|)
block|{
name|uint32_t
name|h
decl_stmt|;
name|h
operator|=
name|murmur3_32_hash32
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
name|sk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state_key_cmp
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|V_pf_hashseed
argument_list|)
expr_stmt|;
return|return
operator|(
name|h
operator|&
name|pf_hashmask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|pf_hashsrc
parameter_list|(
name|struct
name|pf_addr
modifier|*
name|addr
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|uint32_t
name|h
decl_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
name|h
operator|=
name|murmur3_32_hash32
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|addr
operator|->
name|v4
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
operator|->
name|v4
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|V_pf_hashseed
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|h
operator|=
name|murmur3_32_hash32
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|addr
operator|->
name|v6
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
operator|->
name|v6
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|V_pf_hashseed
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unknown address family %u"
argument_list|,
name|__func__
argument_list|,
name|af
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|h
operator|&
name|pf_srchashmask
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ
end_ifdef

begin_function
specifier|static
name|int
name|pf_state_hash
parameter_list|(
name|struct
name|pf_state
modifier|*
name|s
parameter_list|)
block|{
name|u_int32_t
name|hv
init|=
operator|(
name|intptr_t
operator|)
name|s
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
decl_stmt|;
name|hv
operator|^=
name|crc32
argument_list|(
operator|&
name|s
operator|->
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|hv
operator|^=
name|crc32
argument_list|(
operator|&
name|s
operator|->
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hv
operator|==
literal|0
condition|)
name|hv
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|hv
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
name|void
name|pf_addrcpy
parameter_list|(
name|struct
name|pf_addr
modifier|*
name|dst
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|src
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|dst
operator|->
name|addr32
index|[
literal|0
index|]
operator|=
name|src
operator|->
name|addr32
index|[
literal|0
index|]
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
case|case
name|AF_INET6
case|:
name|dst
operator|->
name|addr32
index|[
literal|0
index|]
operator|=
name|src
operator|->
name|addr32
index|[
literal|0
index|]
expr_stmt|;
name|dst
operator|->
name|addr32
index|[
literal|1
index|]
operator|=
name|src
operator|->
name|addr32
index|[
literal|1
index|]
expr_stmt|;
name|dst
operator|->
name|addr32
index|[
literal|2
index|]
operator|=
name|src
operator|->
name|addr32
index|[
literal|2
index|]
expr_stmt|;
name|dst
operator|->
name|addr32
index|[
literal|3
index|]
operator|=
name|src
operator|->
name|addr32
index|[
literal|3
index|]
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_function
specifier|static
name|void
name|pf_init_threshold
parameter_list|(
name|struct
name|pf_threshold
modifier|*
name|threshold
parameter_list|,
name|u_int32_t
name|limit
parameter_list|,
name|u_int32_t
name|seconds
parameter_list|)
block|{
name|threshold
operator|->
name|limit
operator|=
name|limit
operator|*
name|PF_THRESHOLD_MULT
expr_stmt|;
name|threshold
operator|->
name|seconds
operator|=
name|seconds
expr_stmt|;
name|threshold
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|threshold
operator|->
name|last
operator|=
name|time_uptime
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pf_add_threshold
parameter_list|(
name|struct
name|pf_threshold
modifier|*
name|threshold
parameter_list|)
block|{
name|u_int32_t
name|t
init|=
name|time_uptime
decl_stmt|,
name|diff
init|=
name|t
operator|-
name|threshold
operator|->
name|last
decl_stmt|;
if|if
condition|(
name|diff
operator|>=
name|threshold
operator|->
name|seconds
condition|)
name|threshold
operator|->
name|count
operator|=
literal|0
expr_stmt|;
else|else
name|threshold
operator|->
name|count
operator|-=
name|threshold
operator|->
name|count
operator|*
name|diff
operator|/
name|threshold
operator|->
name|seconds
expr_stmt|;
name|threshold
operator|->
name|count
operator|+=
name|PF_THRESHOLD_MULT
expr_stmt|;
name|threshold
operator|->
name|last
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_check_threshold
parameter_list|(
name|struct
name|pf_threshold
modifier|*
name|threshold
parameter_list|)
block|{
return|return
operator|(
name|threshold
operator|->
name|count
operator|>
name|threshold
operator|->
name|limit
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_src_connlimit
parameter_list|(
name|struct
name|pf_state
modifier|*
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|pf_overload_entry
modifier|*
name|pfoe
decl_stmt|;
name|int
name|bad
init|=
literal|0
decl_stmt|;
name|PF_STATE_LOCK_ASSERT
argument_list|(
operator|*
name|state
argument_list|)
expr_stmt|;
operator|(
operator|*
name|state
operator|)
operator|->
name|src_node
operator|->
name|conn
operator|++
expr_stmt|;
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|tcp_est
operator|=
literal|1
expr_stmt|;
name|pf_add_threshold
argument_list|(
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|src_node
operator|->
name|conn_rate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|rule
operator|.
name|ptr
operator|->
name|max_src_conn
operator|&&
operator|(
operator|*
name|state
operator|)
operator|->
name|rule
operator|.
name|ptr
operator|->
name|max_src_conn
operator|<
operator|(
operator|*
name|state
operator|)
operator|->
name|src_node
operator|->
name|conn
condition|)
block|{
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|lcounters
index|[
name|LCNT_SRCCONN
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bad
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|rule
operator|.
name|ptr
operator|->
name|max_src_conn_rate
operator|.
name|limit
operator|&&
name|pf_check_threshold
argument_list|(
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|src_node
operator|->
name|conn_rate
argument_list|)
condition|)
block|{
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|lcounters
index|[
name|LCNT_SRCCONNRATE
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bad
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bad
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Kill this state. */
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_PURGE
expr_stmt|;
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|state
operator|=
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|state
operator|=
name|TCPS_CLOSED
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|rule
operator|.
name|ptr
operator|->
name|overload_tbl
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Schedule overloading and flushing task. */
name|pfoe
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pfoe
argument_list|)
argument_list|,
name|M_PFTEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfoe
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* too bad :( */
name|bcopy
argument_list|(
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|src_node
operator|->
name|addr
argument_list|,
operator|&
name|pfoe
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|pfoe
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|pfoe
operator|->
name|af
operator|=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|->
name|af
expr_stmt|;
name|pfoe
operator|->
name|rule
operator|=
operator|(
operator|*
name|state
operator|)
operator|->
name|rule
operator|.
name|ptr
expr_stmt|;
name|pfoe
operator|->
name|dir
operator|=
operator|(
operator|*
name|state
operator|)
operator|->
name|direction
expr_stmt|;
name|PF_OVERLOADQ_LOCK
argument_list|()
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|V_pf_overloadqueue
argument_list|,
name|pfoe
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|PF_OVERLOADQ_UNLOCK
argument_list|()
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|V_pf_overloadtask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pf_overload_task
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|pf_overload_head
name|queue
decl_stmt|;
name|struct
name|pfr_addr
name|p
decl_stmt|;
name|struct
name|pf_overload_entry
modifier|*
name|pfoe
decl_stmt|,
modifier|*
name|pfoe1
decl_stmt|;
name|uint32_t
name|killed
init|=
literal|0
decl_stmt|;
name|CURVNET_SET
argument_list|(
operator|(
expr|struct
name|vnet
operator|*
operator|)
name|v
argument_list|)
expr_stmt|;
name|PF_OVERLOADQ_LOCK
argument_list|()
expr_stmt|;
name|queue
operator|=
name|V_pf_overloadqueue
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|V_pf_overloadqueue
argument_list|)
expr_stmt|;
name|PF_OVERLOADQ_UNLOCK
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|pfoe
argument_list|,
argument|&queue
argument_list|,
argument|next
argument_list|)
block|{
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|lcounters
index|[
name|LCNT_OVERLOAD_TABLE
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_pf_status
operator|.
name|debug
operator|>=
name|PF_DEBUG_MISC
condition|)
block|{
name|printf
argument_list|(
literal|"%s: blocking address "
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|pf_print_host
argument_list|(
operator|&
name|pfoe
operator|->
name|addr
argument_list|,
literal|0
argument_list|,
name|pfoe
operator|->
name|af
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|p
operator|.
name|pfra_af
operator|=
name|pfoe
operator|->
name|af
expr_stmt|;
switch|switch
condition|(
name|pfoe
operator|->
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|p
operator|.
name|pfra_net
operator|=
literal|32
expr_stmt|;
name|p
operator|.
name|pfra_ip4addr
operator|=
name|pfoe
operator|->
name|addr
operator|.
name|v4
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|p
operator|.
name|pfra_net
operator|=
literal|128
expr_stmt|;
name|p
operator|.
name|pfra_ip6addr
operator|=
name|pfoe
operator|->
name|addr
operator|.
name|v6
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|pfr_insert_kentry
argument_list|(
name|pfoe
operator|->
name|rule
operator|->
name|overload_tbl
argument_list|,
operator|&
name|p
argument_list|,
name|time_second
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Remove those entries, that don't need flushing. 	 */
name|SLIST_FOREACH_SAFE
argument_list|(
argument|pfoe
argument_list|,
argument|&queue
argument_list|,
argument|next
argument_list|,
argument|pfoe1
argument_list|)
if|if
condition|(
name|pfoe
operator|->
name|rule
operator|->
name|flush
operator|==
literal|0
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|queue
argument_list|,
name|pfoe
argument_list|,
name|pf_overload_entry
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfoe
argument_list|,
name|M_PFTEMP
argument_list|)
expr_stmt|;
block|}
else|else
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|lcounters
index|[
name|LCNT_OVERLOAD_FLUSH
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If nothing to flush, return. */
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|queue
argument_list|)
condition|)
block|{
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|pf_hashmask
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|pf_idhash
modifier|*
name|ih
init|=
operator|&
name|V_pf_idhash
index|[
name|i
index|]
decl_stmt|;
name|struct
name|pf_state_key
modifier|*
name|sk
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|s
decl_stmt|;
name|PF_HASHROW_LOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ih->states
argument_list|,
argument|entry
argument_list|)
block|{
name|sk
operator|=
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|pfoe
argument_list|,
argument|&queue
argument_list|,
argument|next
argument_list|)
if|if
condition|(
name|sk
operator|->
name|af
operator|==
name|pfoe
operator|->
name|af
operator|&&
operator|(
operator|(
name|pfoe
operator|->
name|rule
operator|->
name|flush
operator|&
name|PF_FLUSH_GLOBAL
operator|)
operator|||
name|pfoe
operator|->
name|rule
operator|==
name|s
operator|->
name|rule
operator|.
name|ptr
operator|)
operator|&&
operator|(
operator|(
name|pfoe
operator|->
name|dir
operator|==
name|PF_OUT
operator|&&
name|PF_AEQ
argument_list|(
operator|&
name|pfoe
operator|->
name|addr
argument_list|,
operator|&
name|sk
operator|->
name|addr
index|[
literal|1
index|]
argument_list|,
name|sk
operator|->
name|af
argument_list|)
operator|)
operator|||
operator|(
name|pfoe
operator|->
name|dir
operator|==
name|PF_IN
operator|&&
name|PF_AEQ
argument_list|(
operator|&
name|pfoe
operator|->
name|addr
argument_list|,
operator|&
name|sk
operator|->
name|addr
index|[
literal|0
index|]
argument_list|,
name|sk
operator|->
name|af
argument_list|)
operator|)
operator|)
condition|)
block|{
name|s
operator|->
name|timeout
operator|=
name|PFTM_PURGE
expr_stmt|;
name|s
operator|->
name|src
operator|.
name|state
operator|=
name|s
operator|->
name|dst
operator|.
name|state
operator|=
name|TCPS_CLOSED
expr_stmt|;
name|killed
operator|++
expr_stmt|;
block|}
block|}
name|PF_HASHROW_UNLOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
block|}
name|SLIST_FOREACH_SAFE
argument_list|(
argument|pfoe
argument_list|,
argument|&queue
argument_list|,
argument|next
argument_list|,
argument|pfoe1
argument_list|)
name|free
argument_list|(
name|pfoe
argument_list|,
name|M_PFTEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_pf_status
operator|.
name|debug
operator|>=
name|PF_DEBUG_MISC
condition|)
name|printf
argument_list|(
literal|"%s: %u states killed"
argument_list|,
name|__func__
argument_list|,
name|killed
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Can return locked on failure, so that we can consistently  * allocate and insert a new one.  */
end_comment

begin_function
name|struct
name|pf_src_node
modifier|*
name|pf_find_src_node
parameter_list|(
name|struct
name|pf_addr
modifier|*
name|src
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|rule
parameter_list|,
name|sa_family_t
name|af
parameter_list|,
name|int
name|returnlocked
parameter_list|)
block|{
name|struct
name|pf_srchash
modifier|*
name|sh
decl_stmt|;
name|struct
name|pf_src_node
modifier|*
name|n
decl_stmt|;
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|scounters
index|[
name|SCNT_SRC_NODE_SEARCH
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sh
operator|=
operator|&
name|V_pf_srchash
index|[
name|pf_hashsrc
argument_list|(
name|src
argument_list|,
name|af
argument_list|)
index|]
expr_stmt|;
name|PF_HASHROW_LOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|n
argument_list|,
argument|&sh->nodes
argument_list|,
argument|entry
argument_list|)
if|if
condition|(
name|n
operator|->
name|rule
operator|.
name|ptr
operator|==
name|rule
operator|&&
name|n
operator|->
name|af
operator|==
name|af
operator|&&
operator|(
operator|(
name|af
operator|==
name|AF_INET
operator|&&
name|n
operator|->
name|addr
operator|.
name|v4
operator|.
name|s_addr
operator|==
name|src
operator|->
name|v4
operator|.
name|s_addr
operator|)
operator|||
operator|(
name|af
operator|==
name|AF_INET6
operator|&&
name|bcmp
argument_list|(
operator|&
name|n
operator|->
name|addr
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
name|n
operator|->
name|states
operator|++
expr_stmt|;
name|PF_HASHROW_UNLOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|returnlocked
operator|==
literal|0
condition|)
name|PF_HASHROW_UNLOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_insert_src_node
parameter_list|(
name|struct
name|pf_src_node
modifier|*
modifier|*
name|sn
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|rule
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|src
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|rule
operator|->
name|rule_flag
operator|&
name|PFRULE_RULESRCTRACK
operator|||
name|rule
operator|->
name|rpool
operator|.
name|opts
operator|&
name|PF_POOL_STICKYADDR
operator|)
argument_list|,
operator|(
literal|"%s for non-tracking rule %p"
operator|,
name|__func__
operator|,
name|rule
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sn
operator|==
name|NULL
condition|)
operator|*
name|sn
operator|=
name|pf_find_src_node
argument_list|(
name|src
argument_list|,
name|rule
argument_list|,
name|af
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sn
operator|==
name|NULL
condition|)
block|{
name|struct
name|pf_srchash
modifier|*
name|sh
init|=
operator|&
name|V_pf_srchash
index|[
name|pf_hashsrc
argument_list|(
name|src
argument_list|,
name|af
argument_list|)
index|]
decl_stmt|;
name|PF_HASHROW_ASSERT
argument_list|(
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rule
operator|->
name|max_src_nodes
operator|||
name|counter_u64_fetch
argument_list|(
name|rule
operator|->
name|src_nodes
argument_list|)
operator|<
name|rule
operator|->
name|max_src_nodes
condition|)
operator|(
operator|*
name|sn
operator|)
operator|=
name|uma_zalloc
argument_list|(
name|V_pf_sources_z
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
else|else
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|lcounters
index|[
name|LCNT_SRCNODES
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sn
operator|)
operator|==
name|NULL
condition|)
block|{
name|PF_HASHROW_UNLOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pf_init_threshold
argument_list|(
operator|&
operator|(
operator|*
name|sn
operator|)
operator|->
name|conn_rate
argument_list|,
name|rule
operator|->
name|max_src_conn_rate
operator|.
name|limit
argument_list|,
name|rule
operator|->
name|max_src_conn_rate
operator|.
name|seconds
argument_list|)
expr_stmt|;
operator|(
operator|*
name|sn
operator|)
operator|->
name|af
operator|=
name|af
expr_stmt|;
operator|(
operator|*
name|sn
operator|)
operator|->
name|rule
operator|.
name|ptr
operator|=
name|rule
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
operator|(
operator|*
name|sn
operator|)
operator|->
name|addr
argument_list|,
name|src
argument_list|,
name|af
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sh
operator|->
name|nodes
argument_list|,
operator|*
name|sn
argument_list|,
name|entry
argument_list|)
expr_stmt|;
operator|(
operator|*
name|sn
operator|)
operator|->
name|creation
operator|=
name|time_uptime
expr_stmt|;
operator|(
operator|*
name|sn
operator|)
operator|->
name|ruletype
operator|=
name|rule
operator|->
name|action
expr_stmt|;
operator|(
operator|*
name|sn
operator|)
operator|->
name|states
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sn
operator|)
operator|->
name|rule
operator|.
name|ptr
operator|!=
name|NULL
condition|)
name|counter_u64_add
argument_list|(
operator|(
operator|*
name|sn
operator|)
operator|->
name|rule
operator|.
name|ptr
operator|->
name|src_nodes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PF_HASHROW_UNLOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|scounters
index|[
name|SCNT_SRC_NODE_INSERT
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rule
operator|->
name|max_src_states
operator|&&
operator|(
operator|*
name|sn
operator|)
operator|->
name|states
operator|>=
name|rule
operator|->
name|max_src_states
condition|)
block|{
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|lcounters
index|[
name|LCNT_SRCSTATES
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pf_unlink_src_node
parameter_list|(
name|struct
name|pf_src_node
modifier|*
name|src
parameter_list|)
block|{
name|PF_HASHROW_ASSERT
argument_list|(
operator|&
name|V_pf_srchash
index|[
name|pf_hashsrc
argument_list|(
operator|&
name|src
operator|->
name|addr
argument_list|,
name|src
operator|->
name|af
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|src
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|rule
operator|.
name|ptr
condition|)
name|counter_u64_add
argument_list|(
name|src
operator|->
name|rule
operator|.
name|ptr
operator|->
name|src_nodes
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int
name|pf_free_src_nodes
parameter_list|(
name|struct
name|pf_src_node_list
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|pf_src_node
modifier|*
name|sn
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|u_int
name|count
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|sn
argument_list|,
argument|head
argument_list|,
argument|entry
argument_list|,
argument|tmp
argument_list|)
block|{
name|uma_zfree
argument_list|(
name|V_pf_sources_z
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|scounters
index|[
name|SCNT_SRC_NODE_REMOVALS
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pf_mtag_initialize
parameter_list|()
block|{
name|pf_mtag_z
operator|=
name|uma_zcreate
argument_list|(
literal|"pf mtags"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|m_tag
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pf_mtag
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pf_mtag_uminit
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Per-vnet data storage structures initialization. */
end_comment

begin_function
name|void
name|pf_initialize
parameter_list|()
block|{
name|struct
name|pf_keyhash
modifier|*
name|kh
decl_stmt|;
name|struct
name|pf_idhash
modifier|*
name|ih
decl_stmt|;
name|struct
name|pf_srchash
modifier|*
name|sh
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|pf_hashsize
operator|==
literal|0
operator|||
operator|!
name|powerof2
argument_list|(
name|pf_hashsize
argument_list|)
condition|)
name|pf_hashsize
operator|=
name|PF_HASHSIZ
expr_stmt|;
if|if
condition|(
name|pf_srchashsize
operator|==
literal|0
operator|||
operator|!
name|powerof2
argument_list|(
name|pf_srchashsize
argument_list|)
condition|)
name|pf_srchashsize
operator|=
name|PF_HASHSIZ
operator|/
literal|4
expr_stmt|;
name|V_pf_hashseed
operator|=
name|arc4random
argument_list|()
expr_stmt|;
comment|/* States and state keys storage. */
name|V_pf_state_z
operator|=
name|uma_zcreate
argument_list|(
literal|"pf states"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V_pf_limits
index|[
name|PF_LIMIT_STATES
index|]
operator|.
name|zone
operator|=
name|V_pf_state_z
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|V_pf_state_z
argument_list|,
name|PFSTATE_HIWAT
argument_list|)
expr_stmt|;
name|uma_zone_set_warning
argument_list|(
name|V_pf_state_z
argument_list|,
literal|"PF states limit reached"
argument_list|)
expr_stmt|;
name|V_pf_state_key_z
operator|=
name|uma_zcreate
argument_list|(
literal|"pf state keys"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state_key
argument_list|)
argument_list|,
name|pf_state_key_ctor
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V_pf_keyhash
operator|=
name|malloc
argument_list|(
name|pf_hashsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pf_keyhash
argument_list|)
argument_list|,
name|M_PFHASH
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|V_pf_idhash
operator|=
name|malloc
argument_list|(
name|pf_hashsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pf_idhash
argument_list|)
argument_list|,
name|M_PFHASH
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pf_hashmask
operator|=
name|pf_hashsize
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|kh
operator|=
name|V_pf_keyhash
operator|,
name|ih
operator|=
name|V_pf_idhash
init|;
name|i
operator|<=
name|pf_hashmask
condition|;
name|i
operator|++
operator|,
name|kh
operator|++
operator|,
name|ih
operator|++
control|)
block|{
name|mtx_init
argument_list|(
operator|&
name|kh
operator|->
name|lock
argument_list|,
literal|"pf_keyhash"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ih
operator|->
name|lock
argument_list|,
literal|"pf_idhash"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
comment|/* Source nodes. */
name|V_pf_sources_z
operator|=
name|uma_zcreate
argument_list|(
literal|"pf source nodes"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_src_node
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V_pf_limits
index|[
name|PF_LIMIT_SRC_NODES
index|]
operator|.
name|zone
operator|=
name|V_pf_sources_z
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|V_pf_sources_z
argument_list|,
name|PFSNODE_HIWAT
argument_list|)
expr_stmt|;
name|uma_zone_set_warning
argument_list|(
name|V_pf_sources_z
argument_list|,
literal|"PF source nodes limit reached"
argument_list|)
expr_stmt|;
name|V_pf_srchash
operator|=
name|malloc
argument_list|(
name|pf_srchashsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pf_srchash
argument_list|)
argument_list|,
name|M_PFHASH
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pf_srchashmask
operator|=
name|pf_srchashsize
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sh
operator|=
name|V_pf_srchash
init|;
name|i
operator|<=
name|pf_srchashmask
condition|;
name|i
operator|++
operator|,
name|sh
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|sh
operator|->
name|lock
argument_list|,
literal|"pf_srchash"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* ALTQ */
name|TAILQ_INIT
argument_list|(
operator|&
name|V_pf_altqs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|V_pf_altqs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|V_pf_pabuf
argument_list|)
expr_stmt|;
name|V_pf_altqs_active
operator|=
operator|&
name|V_pf_altqs
index|[
literal|0
index|]
expr_stmt|;
name|V_pf_altqs_inactive
operator|=
operator|&
name|V_pf_altqs
index|[
literal|1
index|]
expr_stmt|;
comment|/* Send& overload+flush queues. */
name|STAILQ_INIT
argument_list|(
operator|&
name|V_pf_sendqueue
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|V_pf_overloadqueue
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|V_pf_overloadtask
argument_list|,
literal|0
argument_list|,
name|pf_overload_task
argument_list|,
name|curvnet
argument_list|)
expr_stmt|;
comment|/* Unlinked, but may be referenced rules. */
name|TAILQ_INIT
argument_list|(
operator|&
name|V_pf_unlinked_rules
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pf_mtag_cleanup
parameter_list|()
block|{
name|uma_zdestroy
argument_list|(
name|pf_mtag_z
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pf_cleanup
parameter_list|()
block|{
name|struct
name|pf_keyhash
modifier|*
name|kh
decl_stmt|;
name|struct
name|pf_idhash
modifier|*
name|ih
decl_stmt|;
name|struct
name|pf_srchash
modifier|*
name|sh
decl_stmt|;
name|struct
name|pf_send_entry
modifier|*
name|pfse
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|kh
operator|=
name|V_pf_keyhash
operator|,
name|ih
operator|=
name|V_pf_idhash
init|;
name|i
operator|<=
name|pf_hashmask
condition|;
name|i
operator|++
operator|,
name|kh
operator|++
operator|,
name|ih
operator|++
control|)
block|{
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|kh
operator|->
name|keys
argument_list|)
argument_list|,
operator|(
literal|"%s: key hash not empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|ih
operator|->
name|states
argument_list|)
argument_list|,
operator|(
literal|"%s: id hash not empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|kh
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ih
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|V_pf_keyhash
argument_list|,
name|M_PFHASH
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|V_pf_idhash
argument_list|,
name|M_PFHASH
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sh
operator|=
name|V_pf_srchash
init|;
name|i
operator|<=
name|pf_srchashmask
condition|;
name|i
operator|++
operator|,
name|sh
operator|++
control|)
block|{
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sh
operator|->
name|nodes
argument_list|)
argument_list|,
operator|(
literal|"%s: source node hash not empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sh
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|V_pf_srchash
argument_list|,
name|M_PFHASH
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|pfse
argument_list|,
argument|&V_pf_sendqueue
argument_list|,
argument|pfse_next
argument_list|,
argument|next
argument_list|)
block|{
name|m_freem
argument_list|(
name|pfse
operator|->
name|pfse_m
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfse
argument_list|,
name|M_PFTEMP
argument_list|)
expr_stmt|;
block|}
name|uma_zdestroy
argument_list|(
name|V_pf_sources_z
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|V_pf_state_z
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|V_pf_state_key_z
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_mtag_uminit
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|struct
name|m_tag
modifier|*
name|t
decl_stmt|;
name|t
operator|=
operator|(
expr|struct
name|m_tag
operator|*
operator|)
name|mem
expr_stmt|;
name|t
operator|->
name|m_tag_cookie
operator|=
name|MTAG_ABI_COMPAT
expr_stmt|;
name|t
operator|->
name|m_tag_id
operator|=
name|PACKET_TAG_PF
expr_stmt|;
name|t
operator|->
name|m_tag_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pf_mtag
argument_list|)
expr_stmt|;
name|t
operator|->
name|m_tag_free
operator|=
name|pf_mtag_free
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pf_mtag_free
parameter_list|(
name|struct
name|m_tag
modifier|*
name|t
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|pf_mtag_z
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|pf_mtag
modifier|*
name|pf_get_mtag
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
if|if
condition|(
operator|(
name|mtag
operator|=
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_PF
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|(
expr|struct
name|pf_mtag
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
operator|)
return|;
name|mtag
operator|=
name|uma_zalloc
argument_list|(
name|pf_mtag_z
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
name|mtag
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_mtag
argument_list|)
argument_list|)
expr_stmt|;
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|pf_mtag
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_state_key_attach
parameter_list|(
name|struct
name|pf_state_key
modifier|*
name|skw
parameter_list|,
name|struct
name|pf_state_key
modifier|*
name|sks
parameter_list|,
name|struct
name|pf_state
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|pf_keyhash
modifier|*
name|khs
decl_stmt|,
modifier|*
name|khw
decl_stmt|,
modifier|*
name|kh
decl_stmt|;
name|struct
name|pf_state_key
modifier|*
name|sk
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|si
decl_stmt|,
modifier|*
name|olds
init|=
name|NULL
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|KASSERT
argument_list|(
name|s
operator|->
name|refs
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: state not pristine"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: state has key"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|s
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: state has key"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We need to lock hash slots of both keys. To avoid deadlock 	 * we always lock the slot with lower address first. Unlock order 	 * isn't important. 	 * 	 * We also need to lock ID hash slot before dropping key 	 * locks. On success we return with ID hash slot locked. 	 */
if|if
condition|(
name|skw
operator|==
name|sks
condition|)
block|{
name|khs
operator|=
name|khw
operator|=
operator|&
name|V_pf_keyhash
index|[
name|pf_hashkey
argument_list|(
name|skw
argument_list|)
index|]
expr_stmt|;
name|PF_HASHROW_LOCK
argument_list|(
name|khs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|khs
operator|=
operator|&
name|V_pf_keyhash
index|[
name|pf_hashkey
argument_list|(
name|sks
argument_list|)
index|]
expr_stmt|;
name|khw
operator|=
operator|&
name|V_pf_keyhash
index|[
name|pf_hashkey
argument_list|(
name|skw
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|khs
operator|==
name|khw
condition|)
block|{
name|PF_HASHROW_LOCK
argument_list|(
name|khs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|khs
operator|<
name|khw
condition|)
block|{
name|PF_HASHROW_LOCK
argument_list|(
name|khs
argument_list|)
expr_stmt|;
name|PF_HASHROW_LOCK
argument_list|(
name|khw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PF_HASHROW_LOCK
argument_list|(
name|khw
argument_list|)
expr_stmt|;
name|PF_HASHROW_LOCK
argument_list|(
name|khs
argument_list|)
expr_stmt|;
block|}
block|}
define|#
directive|define
name|KEYS_UNLOCK
parameter_list|()
value|do {			\ 	if (khs != khw) {			\ 		PF_HASHROW_UNLOCK(khs);		\ 		PF_HASHROW_UNLOCK(khw);		\ 	} else					\ 		PF_HASHROW_UNLOCK(khs);		\ } while (0)
comment|/* 	 * First run: start with wire key. 	 */
name|sk
operator|=
name|skw
expr_stmt|;
name|kh
operator|=
name|khw
expr_stmt|;
name|idx
operator|=
name|PF_SK_WIRE
expr_stmt|;
name|keyattach
label|:
name|LIST_FOREACH
argument_list|(
argument|cur
argument_list|,
argument|&kh->keys
argument_list|,
argument|entry
argument_list|)
if|if
condition|(
name|bcmp
argument_list|(
name|cur
argument_list|,
name|sk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state_key_cmp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|cur
operator|!=
name|NULL
condition|)
block|{
comment|/* Key exists. Check for same kif, if none, add to key. */
name|TAILQ_FOREACH
argument_list|(
argument|si
argument_list|,
argument|&cur->states[idx]
argument_list|,
argument|key_list[idx]
argument_list|)
block|{
name|struct
name|pf_idhash
modifier|*
name|ih
init|=
operator|&
name|V_pf_idhash
index|[
name|PF_IDHASH
argument_list|(
name|si
argument_list|)
index|]
decl_stmt|;
name|PF_HASHROW_LOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|kif
operator|==
name|s
operator|->
name|kif
operator|&&
name|si
operator|->
name|direction
operator|==
name|s
operator|->
name|direction
condition|)
block|{
if|if
condition|(
name|sk
operator|->
name|proto
operator|==
name|IPPROTO_TCP
operator|&&
name|si
operator|->
name|src
operator|.
name|state
operator|>=
name|TCPS_FIN_WAIT_2
operator|&&
name|si
operator|->
name|dst
operator|.
name|state
operator|>=
name|TCPS_FIN_WAIT_2
condition|)
block|{
comment|/* 					 * New state matches an old>FIN_WAIT_2 					 * state. We can't drop key hash locks, 					 * thus we can't unlink it properly. 					 * 					 * As a workaround we drop it into 					 * TCPS_CLOSED state, schedule purge 					 * ASAP and push it into the very end 					 * of the slot TAILQ, so that it won't 					 * conflict with our new state. 					 */
name|si
operator|->
name|src
operator|.
name|state
operator|=
name|si
operator|->
name|dst
operator|.
name|state
operator|=
name|TCPS_CLOSED
expr_stmt|;
name|si
operator|->
name|timeout
operator|=
name|PFTM_PURGE
expr_stmt|;
name|olds
operator|=
name|si
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|V_pf_status
operator|.
name|debug
operator|>=
name|PF_DEBUG_MISC
condition|)
block|{
name|printf
argument_list|(
literal|"pf: %s key attach "
literal|"failed on %s: "
argument_list|,
operator|(
name|idx
operator|==
name|PF_SK_WIRE
operator|)
condition|?
literal|"wire"
else|:
literal|"stack"
argument_list|,
name|s
operator|->
name|kif
operator|->
name|pfik_name
argument_list|)
expr_stmt|;
name|pf_print_state_parts
argument_list|(
name|s
argument_list|,
operator|(
name|idx
operator|==
name|PF_SK_WIRE
operator|)
condition|?
name|sk
else|:
name|NULL
argument_list|,
operator|(
name|idx
operator|==
name|PF_SK_STACK
operator|)
condition|?
name|sk
else|:
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", existing: "
argument_list|)
expr_stmt|;
name|pf_print_state_parts
argument_list|(
name|si
argument_list|,
operator|(
name|idx
operator|==
name|PF_SK_WIRE
operator|)
condition|?
name|sk
else|:
name|NULL
argument_list|,
operator|(
name|idx
operator|==
name|PF_SK_STACK
operator|)
condition|?
name|sk
else|:
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|PF_HASHROW_UNLOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|KEYS_UNLOCK
argument_list|()
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_state_key_z
argument_list|,
name|sk
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|PF_SK_STACK
condition|)
name|pf_detach_state
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
comment|/* collision! */
block|}
block|}
name|PF_HASHROW_UNLOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
block|}
name|uma_zfree
argument_list|(
name|V_pf_state_key_z
argument_list|,
name|sk
argument_list|)
expr_stmt|;
name|s
operator|->
name|key
index|[
name|idx
index|]
operator|=
name|cur
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|kh
operator|->
name|keys
argument_list|,
name|sk
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|s
operator|->
name|key
index|[
name|idx
index|]
operator|=
name|sk
expr_stmt|;
block|}
name|stateattach
label|:
comment|/* List is sorted, if-bound states before floating. */
if|if
condition|(
name|s
operator|->
name|kif
operator|==
name|V_pfi_all
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|s
operator|->
name|key
index|[
name|idx
index|]
operator|->
name|states
index|[
name|idx
index|]
argument_list|,
name|s
argument_list|,
name|key_list
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|s
operator|->
name|key
index|[
name|idx
index|]
operator|->
name|states
index|[
name|idx
index|]
argument_list|,
name|s
argument_list|,
name|key_list
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|olds
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|s
operator|->
name|key
index|[
name|idx
index|]
operator|->
name|states
index|[
name|idx
index|]
argument_list|,
name|olds
argument_list|,
name|key_list
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|s
operator|->
name|key
index|[
name|idx
index|]
operator|->
name|states
index|[
name|idx
index|]
argument_list|,
name|olds
argument_list|,
name|key_list
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|olds
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Attach done. See how should we (or should not?) 	 * attach a second key. 	 */
if|if
condition|(
name|sks
operator|==
name|skw
condition|)
block|{
name|s
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
operator|=
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
expr_stmt|;
name|idx
operator|=
name|PF_SK_STACK
expr_stmt|;
name|sks
operator|=
name|NULL
expr_stmt|;
goto|goto
name|stateattach
goto|;
block|}
elseif|else
if|if
condition|(
name|sks
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Continue attaching with stack key. 		 */
name|sk
operator|=
name|sks
expr_stmt|;
name|kh
operator|=
name|khs
expr_stmt|;
name|idx
operator|=
name|PF_SK_STACK
expr_stmt|;
name|sks
operator|=
name|NULL
expr_stmt|;
goto|goto
name|keyattach
goto|;
block|}
name|PF_STATE_LOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|KEYS_UNLOCK
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s failure"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|KEYS_UNLOCK
block|}
end_function

begin_function
specifier|static
name|void
name|pf_detach_state
parameter_list|(
name|struct
name|pf_state
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|pf_state_key
modifier|*
name|sks
init|=
name|s
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
decl_stmt|;
name|struct
name|pf_keyhash
modifier|*
name|kh
decl_stmt|;
if|if
condition|(
name|sks
operator|!=
name|NULL
condition|)
block|{
name|kh
operator|=
operator|&
name|V_pf_keyhash
index|[
name|pf_hashkey
argument_list|(
name|sks
argument_list|)
index|]
expr_stmt|;
name|PF_HASHROW_LOCK
argument_list|(
name|kh
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
operator|!=
name|NULL
condition|)
name|pf_state_key_detach
argument_list|(
name|s
argument_list|,
name|PF_SK_STACK
argument_list|)
expr_stmt|;
comment|/* 		 * If both point to same key, then we are done. 		 */
if|if
condition|(
name|sks
operator|==
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
condition|)
block|{
name|pf_state_key_detach
argument_list|(
name|s
argument_list|,
name|PF_SK_WIRE
argument_list|)
expr_stmt|;
name|PF_HASHROW_UNLOCK
argument_list|(
name|kh
argument_list|)
expr_stmt|;
return|return;
block|}
name|PF_HASHROW_UNLOCK
argument_list|(
name|kh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|!=
name|NULL
condition|)
block|{
name|kh
operator|=
operator|&
name|V_pf_keyhash
index|[
name|pf_hashkey
argument_list|(
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
argument_list|)
index|]
expr_stmt|;
name|PF_HASHROW_LOCK
argument_list|(
name|kh
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|!=
name|NULL
condition|)
name|pf_state_key_detach
argument_list|(
name|s
argument_list|,
name|PF_SK_WIRE
argument_list|)
expr_stmt|;
name|PF_HASHROW_UNLOCK
argument_list|(
name|kh
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pf_state_key_detach
parameter_list|(
name|struct
name|pf_state
modifier|*
name|s
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|pf_state_key
modifier|*
name|sk
init|=
name|s
operator|->
name|key
index|[
name|idx
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|pf_keyhash
modifier|*
name|kh
init|=
operator|&
name|V_pf_keyhash
index|[
name|pf_hashkey
argument_list|(
name|sk
argument_list|)
index|]
decl_stmt|;
name|PF_HASHROW_ASSERT
argument_list|(
name|kh
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sk
operator|->
name|states
index|[
name|idx
index|]
argument_list|,
name|s
argument_list|,
name|key_list
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|s
operator|->
name|key
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sk
operator|->
name|states
index|[
literal|0
index|]
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sk
operator|->
name|states
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|sk
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_state_key_z
argument_list|,
name|sk
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pf_state_key_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pf_state_key
modifier|*
name|sk
init|=
name|mem
decl_stmt|;
name|bzero
argument_list|(
name|sk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state_key_cmp
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sk
operator|->
name|states
index|[
name|PF_SK_WIRE
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sk
operator|->
name|states
index|[
name|PF_SK_STACK
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|pf_state_key
modifier|*
name|pf_state_key_setup
parameter_list|(
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|saddr
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|daddr
parameter_list|,
name|u_int16_t
name|sport
parameter_list|,
name|u_int16_t
name|dport
parameter_list|)
block|{
name|struct
name|pf_state_key
modifier|*
name|sk
decl_stmt|;
name|sk
operator|=
name|uma_zalloc
argument_list|(
name|V_pf_state_key_z
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sk
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|PF_ACPY
argument_list|(
operator|&
name|sk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|saddr
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|sk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|daddr
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
name|sk
operator|->
name|port
index|[
name|pd
operator|->
name|sidx
index|]
operator|=
name|sport
expr_stmt|;
name|sk
operator|->
name|port
index|[
name|pd
operator|->
name|didx
index|]
operator|=
name|dport
expr_stmt|;
name|sk
operator|->
name|proto
operator|=
name|pd
operator|->
name|proto
expr_stmt|;
name|sk
operator|->
name|af
operator|=
name|pd
operator|->
name|af
expr_stmt|;
return|return
operator|(
name|sk
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|pf_state_key
modifier|*
name|pf_state_key_clone
parameter_list|(
name|struct
name|pf_state_key
modifier|*
name|orig
parameter_list|)
block|{
name|struct
name|pf_state_key
modifier|*
name|sk
decl_stmt|;
name|sk
operator|=
name|uma_zalloc
argument_list|(
name|V_pf_state_key_z
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sk
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bcopy
argument_list|(
name|orig
argument_list|,
name|sk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state_key_cmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sk
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pf_state_insert
parameter_list|(
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|struct
name|pf_state_key
modifier|*
name|skw
parameter_list|,
name|struct
name|pf_state_key
modifier|*
name|sks
parameter_list|,
name|struct
name|pf_state
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|pf_idhash
modifier|*
name|ih
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|cur
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sks
operator|->
name|states
index|[
literal|0
index|]
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sks
operator|->
name|states
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|(
literal|"%s: sks not pristine"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|skw
operator|->
name|states
index|[
literal|0
index|]
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|skw
operator|->
name|states
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|(
literal|"%s: skw not pristine"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|s
operator|->
name|refs
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: state not pristine"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|kif
operator|=
name|kif
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|id
operator|==
literal|0
operator|&&
name|s
operator|->
name|creatorid
operator|==
literal|0
condition|)
block|{
comment|/* XXX: should be atomic, but probability of collision low */
if|if
condition|(
operator|(
name|s
operator|->
name|id
operator|=
name|V_pf_stateid
index|[
name|curcpu
index|]
operator|++
operator|)
operator|==
name|PFID_MAXID
condition|)
name|V_pf_stateid
index|[
name|curcpu
index|]
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|id
operator||=
operator|(
name|uint64_t
operator|)
name|curcpu
operator|<<
name|PFID_CPUSHIFT
expr_stmt|;
name|s
operator|->
name|id
operator|=
name|htobe64
argument_list|(
name|s
operator|->
name|id
argument_list|)
expr_stmt|;
name|s
operator|->
name|creatorid
operator|=
name|V_pf_status
operator|.
name|hostid
expr_stmt|;
block|}
comment|/* Returns with ID locked on success. */
if|if
condition|(
operator|(
name|error
operator|=
name|pf_state_key_attach
argument_list|(
name|skw
argument_list|,
name|sks
argument_list|,
name|s
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ih
operator|=
operator|&
name|V_pf_idhash
index|[
name|PF_IDHASH
argument_list|(
name|s
argument_list|)
index|]
expr_stmt|;
name|PF_HASHROW_ASSERT
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cur
argument_list|,
argument|&ih->states
argument_list|,
argument|entry
argument_list|)
if|if
condition|(
name|cur
operator|->
name|id
operator|==
name|s
operator|->
name|id
operator|&&
name|cur
operator|->
name|creatorid
operator|==
name|s
operator|->
name|creatorid
condition|)
break|break;
if|if
condition|(
name|cur
operator|!=
name|NULL
condition|)
block|{
name|PF_HASHROW_UNLOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_pf_status
operator|.
name|debug
operator|>=
name|PF_DEBUG_MISC
condition|)
block|{
name|printf
argument_list|(
literal|"pf: state ID collision: "
literal|"id: %016llx creatorid: %08x\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|be64toh
argument_list|(
name|s
operator|->
name|id
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|s
operator|->
name|creatorid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pf_detach_state
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ih
operator|->
name|states
argument_list|,
name|s
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* One for keys, one for ID hash. */
name|refcount_init
argument_list|(
operator|&
name|s
operator|->
name|refs
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|fcounters
index|[
name|FCNT_STATE_INSERT
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfsync_insert_state_ptr
operator|!=
name|NULL
condition|)
name|pfsync_insert_state_ptr
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Returns locked. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find state by ID: returns with locked row on success.  */
end_comment

begin_function
name|struct
name|pf_state
modifier|*
name|pf_find_state_byid
parameter_list|(
name|uint64_t
name|id
parameter_list|,
name|uint32_t
name|creatorid
parameter_list|)
block|{
name|struct
name|pf_idhash
modifier|*
name|ih
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|s
decl_stmt|;
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|fcounters
index|[
name|FCNT_STATE_SEARCH
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ih
operator|=
operator|&
name|V_pf_idhash
index|[
operator|(
name|be64toh
argument_list|(
name|id
argument_list|)
operator|%
operator|(
name|pf_hashmask
operator|+
literal|1
operator|)
operator|)
index|]
expr_stmt|;
name|PF_HASHROW_LOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ih->states
argument_list|,
argument|entry
argument_list|)
if|if
condition|(
name|s
operator|->
name|id
operator|==
name|id
operator|&&
name|s
operator|->
name|creatorid
operator|==
name|creatorid
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|PF_HASHROW_UNLOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find state by key.  * Returns with ID hash slot locked on success.  */
end_comment

begin_function
specifier|static
name|struct
name|pf_state
modifier|*
name|pf_find_state
parameter_list|(
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|struct
name|pf_state_key_cmp
modifier|*
name|key
parameter_list|,
name|u_int
name|dir
parameter_list|)
block|{
name|struct
name|pf_keyhash
modifier|*
name|kh
decl_stmt|;
name|struct
name|pf_state_key
modifier|*
name|sk
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|s
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|fcounters
index|[
name|FCNT_STATE_SEARCH
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kh
operator|=
operator|&
name|V_pf_keyhash
index|[
name|pf_hashkey
argument_list|(
operator|(
expr|struct
name|pf_state_key
operator|*
block|)
function|key
end_function

begin_empty_stmt
unit|)]
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|PF_HASHROW_LOCK
argument_list|(
name|kh
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|LIST_FOREACH
argument_list|(
argument|sk
argument_list|,
argument|&kh->keys
argument_list|,
argument|entry
argument_list|)
end_macro

begin_if
if|if
condition|(
name|bcmp
argument_list|(
name|sk
argument_list|,
name|key
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state_key_cmp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
end_if

begin_if
if|if
condition|(
name|sk
operator|==
name|NULL
condition|)
block|{
name|PF_HASHROW_UNLOCK
argument_list|(
name|kh
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|idx
operator|=
operator|(
name|dir
operator|==
name|PF_IN
condition|?
name|PF_SK_WIRE
else|:
name|PF_SK_STACK
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* List is sorted, if-bound states before floating ones. */
end_comment

begin_macro
name|TAILQ_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&sk->states[idx]
argument_list|,
argument|key_list[idx]
argument_list|)
end_macro

begin_if
if|if
condition|(
name|s
operator|->
name|kif
operator|==
name|V_pfi_all
operator|||
name|s
operator|->
name|kif
operator|==
name|kif
condition|)
block|{
name|PF_STATE_LOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|PF_HASHROW_UNLOCK
argument_list|(
name|kh
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|timeout
operator|>=
name|PFTM_MAX
condition|)
block|{
comment|/* 				 * State is either being processed by 				 * pf_unlink_state() in an other thread, or 				 * is scheduled for immediate expiry. 				 */
name|PF_STATE_UNLOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|PF_HASHROW_UNLOCK
argument_list|(
name|kh
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|NULL
operator|)
return|;
end_return

begin_function
unit|}  struct
name|pf_state
modifier|*
name|pf_find_state_all
parameter_list|(
name|struct
name|pf_state_key_cmp
modifier|*
name|key
parameter_list|,
name|u_int
name|dir
parameter_list|,
name|int
modifier|*
name|more
parameter_list|)
block|{
name|struct
name|pf_keyhash
modifier|*
name|kh
decl_stmt|;
name|struct
name|pf_state_key
modifier|*
name|sk
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|s
decl_stmt|,
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|inout
init|=
literal|0
decl_stmt|;
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|fcounters
index|[
name|FCNT_STATE_SEARCH
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kh
operator|=
operator|&
name|V_pf_keyhash
index|[
name|pf_hashkey
argument_list|(
operator|(
expr|struct
name|pf_state_key
operator|*
block|)
function|key
end_function

begin_empty_stmt
unit|)]
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|PF_HASHROW_LOCK
argument_list|(
name|kh
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|LIST_FOREACH
argument_list|(
argument|sk
argument_list|,
argument|&kh->keys
argument_list|,
argument|entry
argument_list|)
end_macro

begin_if
if|if
condition|(
name|bcmp
argument_list|(
name|sk
argument_list|,
name|key
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state_key_cmp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
end_if

begin_if
if|if
condition|(
name|sk
operator|==
name|NULL
condition|)
block|{
name|PF_HASHROW_UNLOCK
argument_list|(
name|kh
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_if

begin_switch
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|PF_IN
case|:
name|idx
operator|=
name|PF_SK_WIRE
expr_stmt|;
break|break;
case|case
name|PF_OUT
case|:
name|idx
operator|=
name|PF_SK_STACK
expr_stmt|;
break|break;
case|case
name|PF_INOUT
case|:
name|idx
operator|=
name|PF_SK_WIRE
expr_stmt|;
name|inout
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: dir %u"
argument_list|,
name|__func__
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
end_switch

begin_label
name|second_run
label|:
end_label

begin_macro
name|TAILQ_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&sk->states[idx]
argument_list|,
argument|key_list[idx]
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|more
operator|==
name|NULL
condition|)
block|{
name|PF_HASHROW_UNLOCK
argument_list|(
name|kh
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
if|if
condition|(
name|ret
condition|)
operator|(
operator|*
name|more
operator|)
operator|++
expr_stmt|;
else|else
name|ret
operator|=
name|s
expr_stmt|;
block|}
end_block

begin_if
if|if
condition|(
name|inout
operator|==
literal|1
condition|)
block|{
name|inout
operator|=
literal|0
expr_stmt|;
name|idx
operator|=
name|PF_SK_STACK
expr_stmt|;
goto|goto
name|second_run
goto|;
block|}
end_if

begin_expr_stmt
name|PF_HASHROW_UNLOCK
argument_list|(
name|kh
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|ret
operator|)
return|;
end_return

begin_comment
unit|}
comment|/* END state table stuff */
end_comment

begin_function
unit|static
name|void
name|pf_send
parameter_list|(
name|struct
name|pf_send_entry
modifier|*
name|pfse
parameter_list|)
block|{
name|PF_SENDQ_LOCK
argument_list|()
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|V_pf_sendqueue
argument_list|,
name|pfse
argument_list|,
name|pfse_next
argument_list|)
expr_stmt|;
name|PF_SENDQ_UNLOCK
argument_list|()
expr_stmt|;
name|swi_sched
argument_list|(
name|V_pf_swi_cookie
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pf_intr
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|pf_send_head
name|queue
decl_stmt|;
name|struct
name|pf_send_entry
modifier|*
name|pfse
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|CURVNET_SET
argument_list|(
operator|(
expr|struct
name|vnet
operator|*
operator|)
name|v
argument_list|)
expr_stmt|;
name|PF_SENDQ_LOCK
argument_list|()
expr_stmt|;
name|queue
operator|=
name|V_pf_sendqueue
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|V_pf_sendqueue
argument_list|)
expr_stmt|;
name|PF_SENDQ_UNLOCK
argument_list|()
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|pfse
argument_list|,
argument|&queue
argument_list|,
argument|pfse_next
argument_list|,
argument|next
argument_list|)
block|{
switch|switch
condition|(
name|pfse
operator|->
name|pfse_type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|PFSE_IP
case|:
name|ip_output
argument_list|(
name|pfse
operator|->
name|pfse_m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|PFSE_ICMP
case|:
name|icmp_error
argument_list|(
name|pfse
operator|->
name|pfse_m
argument_list|,
name|pfse
operator|->
name|icmpopts
operator|.
name|type
argument_list|,
name|pfse
operator|->
name|icmpopts
operator|.
name|code
argument_list|,
literal|0
argument_list|,
name|pfse
operator|->
name|icmpopts
operator|.
name|mtu
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|PFSE_IP6
case|:
name|ip6_output
argument_list|(
name|pfse
operator|->
name|pfse_m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|PFSE_ICMP6
case|:
name|icmp6_error
argument_list|(
name|pfse
operator|->
name|pfse_m
argument_list|,
name|pfse
operator|->
name|icmpopts
operator|.
name|type
argument_list|,
name|pfse
operator|->
name|icmpopts
operator|.
name|code
argument_list|,
name|pfse
operator|->
name|icmpopts
operator|.
name|mtu
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
name|panic
argument_list|(
literal|"%s: unknown type"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pfse
argument_list|,
name|M_PFTEMP
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pf_purge_thread
parameter_list|(
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|u_int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|rw_sleep
argument_list|(
name|pf_purge_thread
argument_list|,
operator|&
name|pf_rules_lock
argument_list|,
literal|0
argument_list|,
literal|"pftm"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
name|VNET_LIST_RLOCK
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf_end_threads
condition|)
block|{
name|pf_end_threads
operator|++
expr_stmt|;
name|wakeup
argument_list|(
name|pf_purge_thread
argument_list|)
expr_stmt|;
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Wait while V_pf_default_rule.timeout is initialized. */
if|if
condition|(
name|V_pf_vnet_active
operator|==
literal|0
condition|)
block|{
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* Process 1/interval fraction of the state table every run. */
name|idx
operator|=
name|pf_purge_expired_states
argument_list|(
name|idx
argument_list|,
name|pf_hashmask
operator|/
operator|(
name|V_pf_default_rule
operator|.
name|timeout
index|[
name|PFTM_INTERVAL
index|]
operator|*
literal|10
operator|)
argument_list|)
expr_stmt|;
comment|/* Purge other expired types every PFTM_INTERVAL seconds. */
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Order is important: 			 * - states and src nodes reference rules 			 * - states and rules reference kifs 			 */
name|pf_purge_expired_fragments
argument_list|()
expr_stmt|;
name|pf_purge_expired_src_nodes
argument_list|()
expr_stmt|;
name|pf_purge_unlinked_rules
argument_list|()
expr_stmt|;
name|pfi_kif_purge
argument_list|()
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_LIST_RUNLOCK
argument_list|()
expr_stmt|;
block|}
comment|/* not reached */
block|}
end_function

begin_function
name|void
name|pf_unload_vnet_purge
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * To cleanse up all kifs and rules we need 	 * two runs: first one clears reference flags, 	 * then pf_purge_expired_states() doesn't 	 * raise them, and then second run frees. 	 */
name|pf_purge_unlinked_rules
argument_list|()
expr_stmt|;
name|pfi_kif_purge
argument_list|()
expr_stmt|;
comment|/* 	 * Now purge everything. 	 */
name|pf_purge_expired_states
argument_list|(
literal|0
argument_list|,
name|pf_hashmask
argument_list|)
expr_stmt|;
name|pf_purge_expired_fragments
argument_list|()
expr_stmt|;
name|pf_purge_expired_src_nodes
argument_list|()
expr_stmt|;
comment|/* 	 * Now all kifs& rules should be unreferenced, 	 * thus should be successfully freed. 	 */
name|pf_purge_unlinked_rules
argument_list|()
expr_stmt|;
name|pfi_kif_purge
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|u_int32_t
name|pf_state_expires
parameter_list|(
specifier|const
name|struct
name|pf_state
modifier|*
name|state
parameter_list|)
block|{
name|u_int32_t
name|timeout
decl_stmt|;
name|u_int32_t
name|start
decl_stmt|;
name|u_int32_t
name|end
decl_stmt|;
name|u_int32_t
name|states
decl_stmt|;
comment|/* handle all PFTM_*> PFTM_MAX here */
if|if
condition|(
name|state
operator|->
name|timeout
operator|==
name|PFTM_PURGE
condition|)
return|return
operator|(
name|time_uptime
operator|)
return|;
name|KASSERT
argument_list|(
name|state
operator|->
name|timeout
operator|!=
name|PFTM_UNLINKED
argument_list|,
operator|(
literal|"pf_state_expires: timeout == PFTM_UNLINKED"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|state
operator|->
name|timeout
operator|<
name|PFTM_MAX
operator|)
argument_list|,
operator|(
literal|"pf_state_expires: timeout> PFTM_MAX"
operator|)
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|state
operator|->
name|rule
operator|.
name|ptr
operator|->
name|timeout
index|[
name|state
operator|->
name|timeout
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|timeout
condition|)
name|timeout
operator|=
name|V_pf_default_rule
operator|.
name|timeout
index|[
name|state
operator|->
name|timeout
index|]
expr_stmt|;
name|start
operator|=
name|state
operator|->
name|rule
operator|.
name|ptr
operator|->
name|timeout
index|[
name|PFTM_ADAPTIVE_START
index|]
expr_stmt|;
if|if
condition|(
name|start
condition|)
block|{
name|end
operator|=
name|state
operator|->
name|rule
operator|.
name|ptr
operator|->
name|timeout
index|[
name|PFTM_ADAPTIVE_END
index|]
expr_stmt|;
name|states
operator|=
name|counter_u64_fetch
argument_list|(
name|state
operator|->
name|rule
operator|.
name|ptr
operator|->
name|states_cur
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|V_pf_default_rule
operator|.
name|timeout
index|[
name|PFTM_ADAPTIVE_START
index|]
expr_stmt|;
name|end
operator|=
name|V_pf_default_rule
operator|.
name|timeout
index|[
name|PFTM_ADAPTIVE_END
index|]
expr_stmt|;
name|states
operator|=
name|V_pf_status
operator|.
name|states
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|&&
name|states
operator|>
name|start
operator|&&
name|start
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|states
operator|<
name|end
condition|)
return|return
operator|(
name|state
operator|->
name|expire
operator|+
name|timeout
operator|*
operator|(
name|end
operator|-
name|states
operator|)
operator|/
operator|(
name|end
operator|-
name|start
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|time_uptime
operator|)
return|;
block|}
return|return
operator|(
name|state
operator|->
name|expire
operator|+
name|timeout
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pf_purge_expired_src_nodes
parameter_list|()
block|{
name|struct
name|pf_src_node_list
name|freelist
decl_stmt|;
name|struct
name|pf_srchash
modifier|*
name|sh
decl_stmt|;
name|struct
name|pf_src_node
modifier|*
name|cur
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|i
decl_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|freelist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sh
operator|=
name|V_pf_srchash
init|;
name|i
operator|<=
name|pf_srchashmask
condition|;
name|i
operator|++
operator|,
name|sh
operator|++
control|)
block|{
name|PF_HASHROW_LOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|cur
argument_list|,
argument|&sh->nodes
argument_list|,
argument|entry
argument_list|,
argument|next
argument_list|)
if|if
condition|(
name|cur
operator|->
name|states
operator|==
literal|0
operator|&&
name|cur
operator|->
name|expire
operator|<=
name|time_uptime
condition|)
block|{
name|pf_unlink_src_node
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|freelist
argument_list|,
name|cur
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|->
name|rule
operator|.
name|ptr
operator|!=
name|NULL
condition|)
name|cur
operator|->
name|rule
operator|.
name|ptr
operator|->
name|rule_flag
operator||=
name|PFRULE_REFS
expr_stmt|;
name|PF_HASHROW_UNLOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
name|pf_free_src_nodes
argument_list|(
operator|&
name|freelist
argument_list|)
expr_stmt|;
name|V_pf_status
operator|.
name|src_nodes
operator|=
name|uma_zone_get_cur
argument_list|(
name|V_pf_sources_z
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pf_src_tree_remove_state
parameter_list|(
name|struct
name|pf_state
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|pf_src_node
modifier|*
name|sn
decl_stmt|;
name|struct
name|pf_srchash
modifier|*
name|sh
decl_stmt|;
name|uint32_t
name|timeout
decl_stmt|;
name|timeout
operator|=
name|s
operator|->
name|rule
operator|.
name|ptr
operator|->
name|timeout
index|[
name|PFTM_SRC_NODE
index|]
condition|?
name|s
operator|->
name|rule
operator|.
name|ptr
operator|->
name|timeout
index|[
name|PFTM_SRC_NODE
index|]
else|:
name|V_pf_default_rule
operator|.
name|timeout
index|[
name|PFTM_SRC_NODE
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|src_node
operator|!=
name|NULL
condition|)
block|{
name|sn
operator|=
name|s
operator|->
name|src_node
expr_stmt|;
name|sh
operator|=
operator|&
name|V_pf_srchash
index|[
name|pf_hashsrc
argument_list|(
operator|&
name|sn
operator|->
name|addr
argument_list|,
name|sn
operator|->
name|af
argument_list|)
index|]
expr_stmt|;
name|PF_HASHROW_LOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|src
operator|.
name|tcp_est
condition|)
operator|--
name|sn
operator|->
name|conn
expr_stmt|;
if|if
condition|(
operator|--
name|sn
operator|->
name|states
operator|==
literal|0
condition|)
name|sn
operator|->
name|expire
operator|=
name|time_uptime
operator|+
name|timeout
expr_stmt|;
name|PF_HASHROW_UNLOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|nat_src_node
operator|!=
name|s
operator|->
name|src_node
operator|&&
name|s
operator|->
name|nat_src_node
operator|!=
name|NULL
condition|)
block|{
name|sn
operator|=
name|s
operator|->
name|nat_src_node
expr_stmt|;
name|sh
operator|=
operator|&
name|V_pf_srchash
index|[
name|pf_hashsrc
argument_list|(
operator|&
name|sn
operator|->
name|addr
argument_list|,
name|sn
operator|->
name|af
argument_list|)
index|]
expr_stmt|;
name|PF_HASHROW_LOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sn
operator|->
name|states
operator|==
literal|0
condition|)
name|sn
operator|->
name|expire
operator|=
name|time_uptime
operator|+
name|timeout
expr_stmt|;
name|PF_HASHROW_UNLOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|src_node
operator|=
name|s
operator|->
name|nat_src_node
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unlink and potentilly free a state. Function may be  * called with ID hash row locked, but always returns  * unlocked, since it needs to go through key hash locking.  */
end_comment

begin_function
name|int
name|pf_unlink_state
parameter_list|(
name|struct
name|pf_state
modifier|*
name|s
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|pf_idhash
modifier|*
name|ih
init|=
operator|&
name|V_pf_idhash
index|[
name|PF_IDHASH
argument_list|(
name|s
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PF_ENTER_LOCKED
operator|)
operator|==
literal|0
condition|)
name|PF_HASHROW_LOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
else|else
name|PF_HASHROW_ASSERT
argument_list|(
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|timeout
operator|==
name|PFTM_UNLINKED
condition|)
block|{
comment|/* 		 * State is being processed 		 * by pf_unlink_state() in 		 * an other thread. 		 */
name|PF_HASHROW_UNLOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXXGL: undefined actually */
block|}
if|if
condition|(
name|s
operator|->
name|src
operator|.
name|state
operator|==
name|PF_TCPS_PROXY_DST
condition|)
block|{
comment|/* XXX wire key the right one? */
name|pf_send_tcp
argument_list|(
name|NULL
argument_list|,
name|s
operator|->
name|rule
operator|.
name|ptr
argument_list|,
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|->
name|af
argument_list|,
operator|&
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|->
name|addr
index|[
literal|1
index|]
argument_list|,
operator|&
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|->
name|addr
index|[
literal|0
index|]
argument_list|,
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|->
name|port
index|[
literal|1
index|]
argument_list|,
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|->
name|port
index|[
literal|0
index|]
argument_list|,
name|s
operator|->
name|src
operator|.
name|seqhi
argument_list|,
name|s
operator|->
name|src
operator|.
name|seqlo
operator|+
literal|1
argument_list|,
name|TH_RST
operator||
name|TH_ACK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|s
operator|->
name|tag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|s
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|pf_src_tree_remove_state
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfsync_delete_state_ptr
operator|!=
name|NULL
condition|)
name|pfsync_delete_state_ptr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|STATE_DEC_COUNTERS
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|timeout
operator|=
name|PFTM_UNLINKED
expr_stmt|;
name|PF_HASHROW_UNLOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|pf_detach_state
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|refcount_release
argument_list|(
operator|&
name|s
operator|->
name|refs
argument_list|)
expr_stmt|;
return|return
operator|(
name|pf_release_state
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pf_free_state
parameter_list|(
name|struct
name|pf_state
modifier|*
name|cur
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|cur
operator|->
name|refs
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: %p has refs"
operator|,
name|__func__
operator|,
name|cur
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cur
operator|->
name|timeout
operator|==
name|PFTM_UNLINKED
argument_list|,
operator|(
literal|"%s: timeout %u"
operator|,
name|__func__
operator|,
name|cur
operator|->
name|timeout
operator|)
argument_list|)
expr_stmt|;
name|pf_normalize_tcp_cleanup
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_state_z
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|fcounters
index|[
name|FCNT_STATE_REMOVALS
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called only from pf_purge_thread(), thus serialized.  */
end_comment

begin_function
specifier|static
name|u_int
name|pf_purge_expired_states
parameter_list|(
name|u_int
name|i
parameter_list|,
name|int
name|maxcheck
parameter_list|)
block|{
name|struct
name|pf_idhash
modifier|*
name|ih
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|s
decl_stmt|;
name|V_pf_status
operator|.
name|states
operator|=
name|uma_zone_get_cur
argument_list|(
name|V_pf_state_z
argument_list|)
expr_stmt|;
comment|/* 	 * Go through hash and unlink states that expire now. 	 */
while|while
condition|(
name|maxcheck
operator|>
literal|0
condition|)
block|{
name|ih
operator|=
operator|&
name|V_pf_idhash
index|[
name|i
index|]
expr_stmt|;
name|relock
label|:
name|PF_HASHROW_LOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ih->states
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|pf_state_expires
argument_list|(
name|s
argument_list|)
operator|<=
name|time_uptime
condition|)
block|{
name|V_pf_status
operator|.
name|states
operator|-=
name|pf_unlink_state
argument_list|(
name|s
argument_list|,
name|PF_ENTER_LOCKED
argument_list|)
expr_stmt|;
goto|goto
name|relock
goto|;
block|}
name|s
operator|->
name|rule
operator|.
name|ptr
operator|->
name|rule_flag
operator||=
name|PFRULE_REFS
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|!=
name|NULL
condition|)
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|rule_flag
operator||=
name|PFRULE_REFS
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|anchor
operator|.
name|ptr
operator|!=
name|NULL
condition|)
name|s
operator|->
name|anchor
operator|.
name|ptr
operator|->
name|rule_flag
operator||=
name|PFRULE_REFS
expr_stmt|;
name|s
operator|->
name|kif
operator|->
name|pfik_flags
operator||=
name|PFI_IFLAG_REFS
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|rt_kif
condition|)
name|s
operator|->
name|rt_kif
operator|->
name|pfik_flags
operator||=
name|PFI_IFLAG_REFS
expr_stmt|;
block|}
name|PF_HASHROW_UNLOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
comment|/* Return when we hit end of hash. */
if|if
condition|(
operator|++
name|i
operator|>
name|pf_hashmask
condition|)
block|{
name|V_pf_status
operator|.
name|states
operator|=
name|uma_zone_get_cur
argument_list|(
name|V_pf_state_z
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|maxcheck
operator|--
expr_stmt|;
block|}
name|V_pf_status
operator|.
name|states
operator|=
name|uma_zone_get_cur
argument_list|(
name|V_pf_state_z
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pf_purge_unlinked_rules
parameter_list|()
block|{
name|struct
name|pf_rulequeue
name|tmpq
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|r
decl_stmt|,
modifier|*
name|r1
decl_stmt|;
comment|/* 	 * If we have overloading task pending, then we'd 	 * better skip purging this time. There is a tiny 	 * probability that overloading task references 	 * an already unlinked rule. 	 */
name|PF_OVERLOADQ_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|V_pf_overloadqueue
argument_list|)
condition|)
block|{
name|PF_OVERLOADQ_UNLOCK
argument_list|()
expr_stmt|;
return|return;
block|}
name|PF_OVERLOADQ_UNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Do naive mark-and-sweep garbage collecting of old rules. 	 * Reference flag is raised by pf_purge_expired_states() 	 * and pf_purge_expired_src_nodes(). 	 * 	 * To avoid LOR between PF_UNLNKDRULES_LOCK/PF_RULES_WLOCK, 	 * use a temporary queue. 	 */
name|TAILQ_INIT
argument_list|(
operator|&
name|tmpq
argument_list|)
expr_stmt|;
name|PF_UNLNKDRULES_LOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|r
argument_list|,
argument|&V_pf_unlinked_rules
argument_list|,
argument|entries
argument_list|,
argument|r1
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_REFS
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|V_pf_unlinked_rules
argument_list|,
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|tmpq
argument_list|,
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|->
name|rule_flag
operator|&=
operator|~
name|PFRULE_REFS
expr_stmt|;
block|}
name|PF_UNLNKDRULES_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|tmpq
argument_list|)
condition|)
block|{
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|r
argument_list|,
argument|&tmpq
argument_list|,
argument|entries
argument_list|,
argument|r1
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|tmpq
argument_list|,
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|pf_free_rule
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pf_print_host
parameter_list|(
name|struct
name|pf_addr
modifier|*
name|addr
parameter_list|,
name|u_int16_t
name|p
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|u_int32_t
name|a
init|=
name|ntohl
argument_list|(
name|addr
operator|->
name|addr32
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%u.%u.%u.%u"
argument_list|,
operator|(
name|a
operator|>>
literal|24
operator|)
operator|&
literal|255
argument_list|,
operator|(
name|a
operator|>>
literal|16
operator|)
operator|&
literal|255
argument_list|,
operator|(
name|a
operator|>>
literal|8
operator|)
operator|&
literal|255
argument_list|,
name|a
operator|&
literal|255
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|=
name|ntohs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":%u"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|u_int16_t
name|b
decl_stmt|;
name|u_int8_t
name|i
decl_stmt|,
name|curstart
decl_stmt|,
name|curend
decl_stmt|,
name|maxstart
decl_stmt|,
name|maxend
decl_stmt|;
name|curstart
operator|=
name|curend
operator|=
name|maxstart
operator|=
name|maxend
operator|=
literal|255
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|addr
operator|->
name|addr16
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|curstart
operator|==
literal|255
condition|)
name|curstart
operator|=
name|i
expr_stmt|;
name|curend
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|curend
operator|-
name|curstart
operator|)
operator|>
operator|(
name|maxend
operator|-
name|maxstart
operator|)
condition|)
block|{
name|maxstart
operator|=
name|curstart
expr_stmt|;
name|maxend
operator|=
name|curend
expr_stmt|;
block|}
name|curstart
operator|=
name|curend
operator|=
literal|255
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|curend
operator|-
name|curstart
operator|)
operator|>
operator|(
name|maxend
operator|-
name|maxstart
operator|)
condition|)
block|{
name|maxstart
operator|=
name|curstart
expr_stmt|;
name|maxend
operator|=
name|curend
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|maxstart
operator|&&
name|i
operator|<=
name|maxend
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|maxend
condition|)
name|printf
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|ntohs
argument_list|(
name|addr
operator|->
name|addr16
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x"
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|7
condition|)
name|printf
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|=
name|ntohs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[%u]"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
block|}
block|}
end_function

begin_function
name|void
name|pf_print_state
parameter_list|(
name|struct
name|pf_state
modifier|*
name|s
parameter_list|)
block|{
name|pf_print_state_parts
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pf_print_state_parts
parameter_list|(
name|struct
name|pf_state
modifier|*
name|s
parameter_list|,
name|struct
name|pf_state_key
modifier|*
name|skwp
parameter_list|,
name|struct
name|pf_state_key
modifier|*
name|sksp
parameter_list|)
block|{
name|struct
name|pf_state_key
modifier|*
name|skw
decl_stmt|,
modifier|*
name|sks
decl_stmt|;
name|u_int8_t
name|proto
decl_stmt|,
name|dir
decl_stmt|;
comment|/* Do our best to fill these, but they're skipped if NULL */
name|skw
operator|=
name|skwp
condition|?
name|skwp
else|:
operator|(
name|s
condition|?
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
else|:
name|NULL
operator|)
expr_stmt|;
name|sks
operator|=
name|sksp
condition|?
name|sksp
else|:
operator|(
name|s
condition|?
name|s
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
else|:
name|NULL
operator|)
expr_stmt|;
name|proto
operator|=
name|skw
condition|?
name|skw
operator|->
name|proto
else|:
operator|(
name|sks
condition|?
name|sks
operator|->
name|proto
else|:
literal|0
operator|)
expr_stmt|;
name|dir
operator|=
name|s
condition|?
name|s
operator|->
name|direction
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_IPV4
case|:
name|printf
argument_list|(
literal|"IPv4"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_IPV6
case|:
name|printf
argument_list|(
literal|"IPv6"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|printf
argument_list|(
literal|"TCP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|printf
argument_list|(
literal|"UDP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|printf
argument_list|(
literal|"ICMP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMPV6
case|:
name|printf
argument_list|(
literal|"ICMPv6"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%u"
argument_list|,
name|proto
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|PF_IN
case|:
name|printf
argument_list|(
literal|" in"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_OUT
case|:
name|printf
argument_list|(
literal|" out"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|skw
condition|)
block|{
name|printf
argument_list|(
literal|" wire: "
argument_list|)
expr_stmt|;
name|pf_print_host
argument_list|(
operator|&
name|skw
operator|->
name|addr
index|[
literal|0
index|]
argument_list|,
name|skw
operator|->
name|port
index|[
literal|0
index|]
argument_list|,
name|skw
operator|->
name|af
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|pf_print_host
argument_list|(
operator|&
name|skw
operator|->
name|addr
index|[
literal|1
index|]
argument_list|,
name|skw
operator|->
name|port
index|[
literal|1
index|]
argument_list|,
name|skw
operator|->
name|af
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sks
condition|)
block|{
name|printf
argument_list|(
literal|" stack: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sks
operator|!=
name|skw
condition|)
block|{
name|pf_print_host
argument_list|(
operator|&
name|sks
operator|->
name|addr
index|[
literal|0
index|]
argument_list|,
name|sks
operator|->
name|port
index|[
literal|0
index|]
argument_list|,
name|sks
operator|->
name|af
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|pf_print_host
argument_list|(
operator|&
name|sks
operator|->
name|addr
index|[
literal|1
index|]
argument_list|,
name|sks
operator|->
name|port
index|[
literal|1
index|]
argument_list|,
name|sks
operator|->
name|af
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|proto
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|printf
argument_list|(
literal|" [lo=%u high=%u win=%u modulator=%u"
argument_list|,
name|s
operator|->
name|src
operator|.
name|seqlo
argument_list|,
name|s
operator|->
name|src
operator|.
name|seqhi
argument_list|,
name|s
operator|->
name|src
operator|.
name|max_win
argument_list|,
name|s
operator|->
name|src
operator|.
name|seqdiff
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|src
operator|.
name|wscale
operator|&&
name|s
operator|->
name|dst
operator|.
name|wscale
condition|)
name|printf
argument_list|(
literal|" wscale=%u"
argument_list|,
name|s
operator|->
name|src
operator|.
name|wscale
operator|&
name|PF_WSCALE_MASK
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" [lo=%u high=%u win=%u modulator=%u"
argument_list|,
name|s
operator|->
name|dst
operator|.
name|seqlo
argument_list|,
name|s
operator|->
name|dst
operator|.
name|seqhi
argument_list|,
name|s
operator|->
name|dst
operator|.
name|max_win
argument_list|,
name|s
operator|->
name|dst
operator|.
name|seqdiff
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|src
operator|.
name|wscale
operator|&&
name|s
operator|->
name|dst
operator|.
name|wscale
condition|)
name|printf
argument_list|(
literal|" wscale=%u"
argument_list|,
name|s
operator|->
name|dst
operator|.
name|wscale
operator|&
name|PF_WSCALE_MASK
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %u:%u"
argument_list|,
name|s
operator|->
name|src
operator|.
name|state
argument_list|,
name|s
operator|->
name|dst
operator|.
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pf_print_flags
parameter_list|(
name|u_int8_t
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|TH_FIN
condition|)
name|printf
argument_list|(
literal|"F"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|TH_SYN
condition|)
name|printf
argument_list|(
literal|"S"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|TH_RST
condition|)
name|printf
argument_list|(
literal|"R"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|TH_PUSH
condition|)
name|printf
argument_list|(
literal|"P"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|TH_ACK
condition|)
name|printf
argument_list|(
literal|"A"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|TH_URG
condition|)
name|printf
argument_list|(
literal|"U"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|TH_ECE
condition|)
name|printf
argument_list|(
literal|"E"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|TH_CWR
condition|)
name|printf
argument_list|(
literal|"W"
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|PF_SET_SKIP_STEPS
parameter_list|(
name|i
parameter_list|)
define|\
value|do {							\ 		while (head[i] != cur) {			\ 			head[i]->skip[i].ptr = cur;		\ 			head[i] = TAILQ_NEXT(head[i], entries);	\ 		}						\ 	} while (0)
end_define

begin_function
name|void
name|pf_calc_skip_steps
parameter_list|(
name|struct
name|pf_rulequeue
modifier|*
name|rules
parameter_list|)
block|{
name|struct
name|pf_rule
modifier|*
name|cur
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|head
index|[
name|PF_SKIP_COUNT
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cur
operator|=
name|TAILQ_FIRST
argument_list|(
name|rules
argument_list|)
expr_stmt|;
name|prev
operator|=
name|cur
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PF_SKIP_COUNT
condition|;
operator|++
name|i
control|)
name|head
index|[
name|i
index|]
operator|=
name|cur
expr_stmt|;
while|while
condition|(
name|cur
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cur
operator|->
name|kif
operator|!=
name|prev
operator|->
name|kif
operator|||
name|cur
operator|->
name|ifnot
operator|!=
name|prev
operator|->
name|ifnot
condition|)
name|PF_SET_SKIP_STEPS
argument_list|(
name|PF_SKIP_IFP
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|direction
operator|!=
name|prev
operator|->
name|direction
condition|)
name|PF_SET_SKIP_STEPS
argument_list|(
name|PF_SKIP_DIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|af
operator|!=
name|prev
operator|->
name|af
condition|)
name|PF_SET_SKIP_STEPS
argument_list|(
name|PF_SKIP_AF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|proto
operator|!=
name|prev
operator|->
name|proto
condition|)
name|PF_SET_SKIP_STEPS
argument_list|(
name|PF_SKIP_PROTO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|src
operator|.
name|neg
operator|!=
name|prev
operator|->
name|src
operator|.
name|neg
operator|||
name|pf_addr_wrap_neq
argument_list|(
operator|&
name|cur
operator|->
name|src
operator|.
name|addr
argument_list|,
operator|&
name|prev
operator|->
name|src
operator|.
name|addr
argument_list|)
condition|)
name|PF_SET_SKIP_STEPS
argument_list|(
name|PF_SKIP_SRC_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|src
operator|.
name|port
index|[
literal|0
index|]
operator|!=
name|prev
operator|->
name|src
operator|.
name|port
index|[
literal|0
index|]
operator|||
name|cur
operator|->
name|src
operator|.
name|port
index|[
literal|1
index|]
operator|!=
name|prev
operator|->
name|src
operator|.
name|port
index|[
literal|1
index|]
operator|||
name|cur
operator|->
name|src
operator|.
name|port_op
operator|!=
name|prev
operator|->
name|src
operator|.
name|port_op
condition|)
name|PF_SET_SKIP_STEPS
argument_list|(
name|PF_SKIP_SRC_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|dst
operator|.
name|neg
operator|!=
name|prev
operator|->
name|dst
operator|.
name|neg
operator|||
name|pf_addr_wrap_neq
argument_list|(
operator|&
name|cur
operator|->
name|dst
operator|.
name|addr
argument_list|,
operator|&
name|prev
operator|->
name|dst
operator|.
name|addr
argument_list|)
condition|)
name|PF_SET_SKIP_STEPS
argument_list|(
name|PF_SKIP_DST_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|dst
operator|.
name|port
index|[
literal|0
index|]
operator|!=
name|prev
operator|->
name|dst
operator|.
name|port
index|[
literal|0
index|]
operator|||
name|cur
operator|->
name|dst
operator|.
name|port
index|[
literal|1
index|]
operator|!=
name|prev
operator|->
name|dst
operator|.
name|port
index|[
literal|1
index|]
operator|||
name|cur
operator|->
name|dst
operator|.
name|port_op
operator|!=
name|prev
operator|->
name|dst
operator|.
name|port_op
condition|)
name|PF_SET_SKIP_STEPS
argument_list|(
name|PF_SKIP_DST_PORT
argument_list|)
expr_stmt|;
name|prev
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|TAILQ_NEXT
argument_list|(
name|cur
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PF_SKIP_COUNT
condition|;
operator|++
name|i
control|)
name|PF_SET_SKIP_STEPS
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_addr_wrap_neq
parameter_list|(
name|struct
name|pf_addr_wrap
modifier|*
name|aw1
parameter_list|,
name|struct
name|pf_addr_wrap
modifier|*
name|aw2
parameter_list|)
block|{
if|if
condition|(
name|aw1
operator|->
name|type
operator|!=
name|aw2
operator|->
name|type
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|aw1
operator|->
name|type
condition|)
block|{
case|case
name|PF_ADDR_ADDRMASK
case|:
case|case
name|PF_ADDR_RANGE
case|:
if|if
condition|(
name|PF_ANEQ
argument_list|(
operator|&
name|aw1
operator|->
name|v
operator|.
name|a
operator|.
name|addr
argument_list|,
operator|&
name|aw2
operator|->
name|v
operator|.
name|a
operator|.
name|addr
argument_list|,
name|AF_INET6
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
operator|&
name|aw1
operator|->
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
operator|&
name|aw2
operator|->
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
name|AF_INET6
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PF_ADDR_DYNIFTL
case|:
return|return
operator|(
name|aw1
operator|->
name|p
operator|.
name|dyn
operator|->
name|pfid_kt
operator|!=
name|aw2
operator|->
name|p
operator|.
name|dyn
operator|->
name|pfid_kt
operator|)
return|;
case|case
name|PF_ADDR_NOROUTE
case|:
case|case
name|PF_ADDR_URPFFAILED
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PF_ADDR_TABLE
case|:
return|return
operator|(
name|aw1
operator|->
name|p
operator|.
name|tbl
operator|!=
name|aw2
operator|->
name|p
operator|.
name|tbl
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"invalid address type: %d\n"
argument_list|,
name|aw1
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Checksum updates are a little complicated because the checksum in the TCP/UDP  * header isn't always a full checksum. In some cases (i.e. output) it's a  * pseudo-header checksum, which is a partial checksum over src/dst IP  * addresses, protocol number and length.  *  * That means we have the following cases:  *  * Input or forwarding: we don't have TSO, the checksum fields are full  *  	checksums, we need to update the checksum whenever we change anything.  *  * Output (i.e. the checksum is a pseudo-header checksum):  *  	x The field being updated is src/dst address or affects the length of  *  	the packet. We need to update the pseudo-header checksum (note that this  *  	checksum is not ones' complement).  *  	x Some other field is being modified (e.g. src/dst port numbers): We  *  	don't have to update anything.  **/
end_comment

begin_function
name|u_int16_t
name|pf_cksum_fixup
parameter_list|(
name|u_int16_t
name|cksum
parameter_list|,
name|u_int16_t
name|old
parameter_list|,
name|u_int16_t
name|new
parameter_list|,
name|u_int8_t
name|udp
parameter_list|)
block|{
name|u_int32_t
name|l
decl_stmt|;
if|if
condition|(
name|udp
operator|&&
operator|!
name|cksum
condition|)
return|return
operator|(
literal|0x0000
operator|)
return|;
name|l
operator|=
name|cksum
operator|+
name|old
operator|-
name|new
expr_stmt|;
name|l
operator|=
operator|(
name|l
operator|>>
literal|16
operator|)
operator|+
operator|(
name|l
operator|&
literal|65535
operator|)
expr_stmt|;
name|l
operator|=
name|l
operator|&
literal|65535
expr_stmt|;
if|if
condition|(
name|udp
operator|&&
operator|!
name|l
condition|)
return|return
operator|(
literal|0xFFFF
operator|)
return|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_function
name|u_int16_t
name|pf_proto_cksum_fixup
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int16_t
name|cksum
parameter_list|,
name|u_int16_t
name|old
parameter_list|,
name|u_int16_t
name|new
parameter_list|,
name|u_int8_t
name|udp
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DELAY_DATA
operator||
name|CSUM_DELAY_DATA_IPV6
operator|)
condition|)
return|return
operator|(
name|cksum
operator|)
return|;
return|return
operator|(
name|pf_cksum_fixup
argument_list|(
name|cksum
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|udp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pf_change_ap
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|a
parameter_list|,
name|u_int16_t
modifier|*
name|p
parameter_list|,
name|u_int16_t
modifier|*
name|ic
parameter_list|,
name|u_int16_t
modifier|*
name|pc
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|an
parameter_list|,
name|u_int16_t
name|pn
parameter_list|,
name|u_int8_t
name|u
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|struct
name|pf_addr
name|ao
decl_stmt|;
name|u_int16_t
name|po
init|=
operator|*
name|p
decl_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|ao
argument_list|,
name|a
argument_list|,
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
name|a
argument_list|,
name|an
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DELAY_DATA
operator||
name|CSUM_DELAY_DATA_IPV6
operator|)
condition|)
operator|*
name|pc
operator|=
operator|~
operator|*
name|pc
expr_stmt|;
operator|*
name|p
operator|=
name|pn
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
operator|*
name|ic
operator|=
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
operator|*
name|ic
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|0
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|1
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|pn
expr_stmt|;
operator|*
name|pc
operator|=
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
operator|*
name|pc
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|0
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|0
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|1
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|1
index|]
argument_list|,
name|u
argument_list|)
expr_stmt|;
operator|*
name|pc
operator|=
name|pf_proto_cksum_fixup
argument_list|(
name|m
argument_list|,
operator|*
name|pc
argument_list|,
name|po
argument_list|,
name|pn
argument_list|,
name|u
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
operator|*
name|pc
operator|=
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
operator|*
name|pc
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|0
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|0
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|1
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|1
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|2
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|2
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|3
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|3
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|4
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|4
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|5
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|5
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|6
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|6
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|7
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|7
index|]
argument_list|,
name|u
argument_list|)
expr_stmt|;
operator|*
name|pc
operator|=
name|pf_proto_cksum_fixup
argument_list|(
name|m
argument_list|,
operator|*
name|pc
argument_list|,
name|po
argument_list|,
name|pn
argument_list|,
name|u
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DELAY_DATA
operator||
name|CSUM_DELAY_DATA_IPV6
operator|)
condition|)
block|{
operator|*
name|pc
operator|=
operator|~
operator|*
name|pc
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pc
condition|)
operator|*
name|pc
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Changes a u_int32_t.  Uses a void * so there are no align restrictions */
end_comment

begin_function
name|void
name|pf_change_a
parameter_list|(
name|void
modifier|*
name|a
parameter_list|,
name|u_int16_t
modifier|*
name|c
parameter_list|,
name|u_int32_t
name|an
parameter_list|,
name|u_int8_t
name|u
parameter_list|)
block|{
name|u_int32_t
name|ao
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|ao
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|ao
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|a
argument_list|,
operator|&
name|an
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|c
operator|=
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
operator|*
name|c
argument_list|,
name|ao
operator|/
literal|65536
argument_list|,
name|an
operator|/
literal|65536
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|%
literal|65536
argument_list|,
name|an
operator|%
literal|65536
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pf_change_proto_a
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|a
parameter_list|,
name|u_int16_t
modifier|*
name|c
parameter_list|,
name|u_int32_t
name|an
parameter_list|,
name|u_int8_t
name|udp
parameter_list|)
block|{
name|u_int32_t
name|ao
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|ao
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|ao
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|a
argument_list|,
operator|&
name|an
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|c
operator|=
name|pf_proto_cksum_fixup
argument_list|(
name|m
argument_list|,
name|pf_proto_cksum_fixup
argument_list|(
name|m
argument_list|,
operator|*
name|c
argument_list|,
name|ao
operator|/
literal|65536
argument_list|,
name|an
operator|/
literal|65536
argument_list|,
name|udp
argument_list|)
argument_list|,
name|ao
operator|%
literal|65536
argument_list|,
name|an
operator|%
literal|65536
argument_list|,
name|udp
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
specifier|static
name|void
name|pf_change_a6
parameter_list|(
name|struct
name|pf_addr
modifier|*
name|a
parameter_list|,
name|u_int16_t
modifier|*
name|c
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|an
parameter_list|,
name|u_int8_t
name|u
parameter_list|)
block|{
name|struct
name|pf_addr
name|ao
decl_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|ao
argument_list|,
name|a
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
name|a
argument_list|,
name|an
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
operator|*
name|c
operator|=
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
operator|*
name|c
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|0
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|0
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|1
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|1
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|2
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|2
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|3
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|3
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|4
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|4
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|5
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|5
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|6
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|6
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ao
operator|.
name|addr16
index|[
literal|7
index|]
argument_list|,
name|an
operator|->
name|addr16
index|[
literal|7
index|]
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_function
specifier|static
name|void
name|pf_change_icmp
parameter_list|(
name|struct
name|pf_addr
modifier|*
name|ia
parameter_list|,
name|u_int16_t
modifier|*
name|ip
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|oa
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|na
parameter_list|,
name|u_int16_t
name|np
parameter_list|,
name|u_int16_t
modifier|*
name|pc
parameter_list|,
name|u_int16_t
modifier|*
name|h2c
parameter_list|,
name|u_int16_t
modifier|*
name|ic
parameter_list|,
name|u_int16_t
modifier|*
name|hc
parameter_list|,
name|u_int8_t
name|u
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|struct
name|pf_addr
name|oia
decl_stmt|,
name|ooa
decl_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|oia
argument_list|,
name|ia
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|oa
condition|)
name|PF_ACPY
argument_list|(
operator|&
name|ooa
argument_list|,
name|oa
argument_list|,
name|af
argument_list|)
expr_stmt|;
comment|/* Change inner protocol port, fix inner protocol checksum. */
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
block|{
name|u_int16_t
name|oip
init|=
operator|*
name|ip
decl_stmt|;
name|u_int32_t
name|opc
decl_stmt|;
if|if
condition|(
name|pc
operator|!=
name|NULL
condition|)
name|opc
operator|=
operator|*
name|pc
expr_stmt|;
operator|*
name|ip
operator|=
name|np
expr_stmt|;
if|if
condition|(
name|pc
operator|!=
name|NULL
condition|)
operator|*
name|pc
operator|=
name|pf_cksum_fixup
argument_list|(
operator|*
name|pc
argument_list|,
name|oip
argument_list|,
operator|*
name|ip
argument_list|,
name|u
argument_list|)
expr_stmt|;
operator|*
name|ic
operator|=
name|pf_cksum_fixup
argument_list|(
operator|*
name|ic
argument_list|,
name|oip
argument_list|,
operator|*
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|!=
name|NULL
condition|)
operator|*
name|ic
operator|=
name|pf_cksum_fixup
argument_list|(
operator|*
name|ic
argument_list|,
name|opc
argument_list|,
operator|*
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Change inner ip address, fix inner ip and icmp checksums. */
name|PF_ACPY
argument_list|(
name|ia
argument_list|,
name|na
argument_list|,
name|af
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|u_int32_t
name|oh2c
init|=
operator|*
name|h2c
decl_stmt|;
operator|*
name|h2c
operator|=
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
operator|*
name|h2c
argument_list|,
name|oia
operator|.
name|addr16
index|[
literal|0
index|]
argument_list|,
name|ia
operator|->
name|addr16
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|oia
operator|.
name|addr16
index|[
literal|1
index|]
argument_list|,
name|ia
operator|->
name|addr16
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ic
operator|=
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
operator|*
name|ic
argument_list|,
name|oia
operator|.
name|addr16
index|[
literal|0
index|]
argument_list|,
name|ia
operator|->
name|addr16
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|oia
operator|.
name|addr16
index|[
literal|1
index|]
argument_list|,
name|ia
operator|->
name|addr16
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ic
operator|=
name|pf_cksum_fixup
argument_list|(
operator|*
name|ic
argument_list|,
name|oh2c
argument_list|,
operator|*
name|h2c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
operator|*
name|ic
operator|=
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
operator|*
name|ic
argument_list|,
name|oia
operator|.
name|addr16
index|[
literal|0
index|]
argument_list|,
name|ia
operator|->
name|addr16
index|[
literal|0
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|oia
operator|.
name|addr16
index|[
literal|1
index|]
argument_list|,
name|ia
operator|->
name|addr16
index|[
literal|1
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|oia
operator|.
name|addr16
index|[
literal|2
index|]
argument_list|,
name|ia
operator|->
name|addr16
index|[
literal|2
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|oia
operator|.
name|addr16
index|[
literal|3
index|]
argument_list|,
name|ia
operator|->
name|addr16
index|[
literal|3
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|oia
operator|.
name|addr16
index|[
literal|4
index|]
argument_list|,
name|ia
operator|->
name|addr16
index|[
literal|4
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|oia
operator|.
name|addr16
index|[
literal|5
index|]
argument_list|,
name|ia
operator|->
name|addr16
index|[
literal|5
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|oia
operator|.
name|addr16
index|[
literal|6
index|]
argument_list|,
name|ia
operator|->
name|addr16
index|[
literal|6
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|oia
operator|.
name|addr16
index|[
literal|7
index|]
argument_list|,
name|ia
operator|->
name|addr16
index|[
literal|7
index|]
argument_list|,
name|u
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
comment|/* Outer ip address, fix outer ip or icmpv6 checksum, if necessary. */
if|if
condition|(
name|oa
condition|)
block|{
name|PF_ACPY
argument_list|(
name|oa
argument_list|,
name|na
argument_list|,
name|af
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
operator|*
name|hc
operator|=
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
operator|*
name|hc
argument_list|,
name|ooa
operator|.
name|addr16
index|[
literal|0
index|]
argument_list|,
name|oa
operator|->
name|addr16
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ooa
operator|.
name|addr16
index|[
literal|1
index|]
argument_list|,
name|oa
operator|->
name|addr16
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
operator|*
name|ic
operator|=
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
name|pf_cksum_fixup
argument_list|(
operator|*
name|ic
argument_list|,
name|ooa
operator|.
name|addr16
index|[
literal|0
index|]
argument_list|,
name|oa
operator|->
name|addr16
index|[
literal|0
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ooa
operator|.
name|addr16
index|[
literal|1
index|]
argument_list|,
name|oa
operator|->
name|addr16
index|[
literal|1
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ooa
operator|.
name|addr16
index|[
literal|2
index|]
argument_list|,
name|oa
operator|->
name|addr16
index|[
literal|2
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ooa
operator|.
name|addr16
index|[
literal|3
index|]
argument_list|,
name|oa
operator|->
name|addr16
index|[
literal|3
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ooa
operator|.
name|addr16
index|[
literal|4
index|]
argument_list|,
name|oa
operator|->
name|addr16
index|[
literal|4
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ooa
operator|.
name|addr16
index|[
literal|5
index|]
argument_list|,
name|oa
operator|->
name|addr16
index|[
literal|5
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ooa
operator|.
name|addr16
index|[
literal|6
index|]
argument_list|,
name|oa
operator|->
name|addr16
index|[
literal|6
index|]
argument_list|,
name|u
argument_list|)
argument_list|,
name|ooa
operator|.
name|addr16
index|[
literal|7
index|]
argument_list|,
name|oa
operator|->
name|addr16
index|[
literal|7
index|]
argument_list|,
name|u
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Need to modulate the sequence numbers in the TCP SACK option  * (credits to Krzysztof Pfaff for report and patch)  */
end_comment

begin_function
specifier|static
name|int
name|pf_modulate_sack
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|pf_state_peer
modifier|*
name|dst
parameter_list|)
block|{
name|int
name|hlen
init|=
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
decl_stmt|,
name|thoptlen
init|=
name|hlen
decl_stmt|;
name|u_int8_t
name|opts
index|[
name|TCP_MAXOLEN
index|]
decl_stmt|,
modifier|*
name|opt
init|=
name|opts
decl_stmt|;
name|int
name|copyback
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|olen
decl_stmt|;
name|struct
name|sackblk
name|sack
decl_stmt|;
define|#
directive|define
name|TCPOLEN_SACKLEN
value|(TCPOLEN_SACK + 2)
if|if
condition|(
name|hlen
operator|<
name|TCPOLEN_SACKLEN
operator|||
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|,
name|opts
argument_list|,
name|hlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pd
operator|->
name|af
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|hlen
operator|>=
name|TCPOLEN_SACKLEN
condition|)
block|{
name|olen
operator|=
name|opt
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
operator|*
name|opt
condition|)
block|{
case|case
name|TCPOPT_EOL
case|:
comment|/* FALLTHROUGH */
case|case
name|TCPOPT_NOP
case|:
name|opt
operator|++
expr_stmt|;
name|hlen
operator|--
expr_stmt|;
break|break;
case|case
name|TCPOPT_SACK
case|:
if|if
condition|(
name|olen
operator|>
name|hlen
condition|)
name|olen
operator|=
name|hlen
expr_stmt|;
if|if
condition|(
name|olen
operator|>=
name|TCPOLEN_SACKLEN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|+
name|TCPOLEN_SACK
operator|<=
name|olen
condition|;
name|i
operator|+=
name|TCPOLEN_SACK
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|sack
argument_list|,
operator|&
name|opt
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sack
argument_list|)
argument_list|)
expr_stmt|;
name|pf_change_proto_a
argument_list|(
name|m
argument_list|,
operator|&
name|sack
operator|.
name|start
argument_list|,
operator|&
name|th
operator|->
name|th_sum
argument_list|,
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|sack
operator|.
name|start
argument_list|)
operator|-
name|dst
operator|->
name|seqdiff
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pf_change_proto_a
argument_list|(
name|m
argument_list|,
operator|&
name|sack
operator|.
name|end
argument_list|,
operator|&
name|th
operator|->
name|th_sum
argument_list|,
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|sack
operator|.
name|end
argument_list|)
operator|-
name|dst
operator|->
name|seqdiff
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|opt
index|[
name|i
index|]
argument_list|,
operator|&
name|sack
argument_list|,
sizeof|sizeof
argument_list|(
name|sack
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|copyback
operator|=
literal|1
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
name|olen
operator|<
literal|2
condition|)
name|olen
operator|=
literal|2
expr_stmt|;
name|hlen
operator|-=
name|olen
expr_stmt|;
name|opt
operator|+=
name|olen
expr_stmt|;
block|}
block|}
if|if
condition|(
name|copyback
condition|)
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|,
name|thoptlen
argument_list|,
operator|(
name|caddr_t
operator|)
name|opts
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyback
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pf_send_tcp
parameter_list|(
name|struct
name|mbuf
modifier|*
name|replyto
parameter_list|,
specifier|const
name|struct
name|pf_rule
modifier|*
name|r
parameter_list|,
name|sa_family_t
name|af
parameter_list|,
specifier|const
name|struct
name|pf_addr
modifier|*
name|saddr
parameter_list|,
specifier|const
name|struct
name|pf_addr
modifier|*
name|daddr
parameter_list|,
name|u_int16_t
name|sport
parameter_list|,
name|u_int16_t
name|dport
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|u_int32_t
name|ack
parameter_list|,
name|u_int8_t
name|flags
parameter_list|,
name|u_int16_t
name|win
parameter_list|,
name|u_int16_t
name|mss
parameter_list|,
name|u_int8_t
name|ttl
parameter_list|,
name|int
name|tag
parameter_list|,
name|u_int16_t
name|rtag
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|pf_send_entry
modifier|*
name|pfse
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|,
name|tlen
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ip
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|h6
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* INET6 */
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|char
modifier|*
name|opt
decl_stmt|;
name|struct
name|pf_mtag
modifier|*
name|pf_mtag
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|th
operator|=
name|NULL
expr_stmt|;
comment|/* maximum segment size tcp option */
name|tlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mss
condition|)
name|tlen
operator|+=
literal|4
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|tlen
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|tlen
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
name|panic
argument_list|(
literal|"%s: unsupported af %d"
argument_list|,
name|__func__
argument_list|,
name|af
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate outgoing queue entry, mbuf and mbuf tag. */
name|pfse
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pfse
argument_list|)
argument_list|,
name|M_PFTEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfse
operator|==
name|NULL
condition|)
return|return;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pfse
argument_list|,
name|M_PFTEMP
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|MAC
name|mac_netinet_firewall_send
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|pf_mtag
operator|=
name|pf_get_mtag
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pfse
argument_list|,
name|M_PFTEMP
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tag
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_SKIP_FIREWALL
expr_stmt|;
name|pf_mtag
operator|->
name|tag
operator|=
name|rtag
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|rtableid
operator|>=
literal|0
condition|)
name|M_SETFIB
argument_list|(
name|m
argument_list|,
name|r
operator|->
name|rtableid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|qid
condition|)
block|{
name|pf_mtag
operator|->
name|qid
operator|=
name|r
operator|->
name|qid
expr_stmt|;
comment|/* add hints for ecn */
name|pf_mtag
operator|->
name|hdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ALTQ */
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|h
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* IP header fields included in the TCP checksum */
name|h
operator|->
name|ip_p
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|h
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
name|h
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|saddr
operator|->
name|v4
operator|.
name|s_addr
expr_stmt|;
name|h
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|daddr
operator|->
name|v4
operator|.
name|s_addr
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|h
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|h6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
comment|/* IP header fields included in the TCP checksum */
name|h6
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|h6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|h6
operator|->
name|ip6_src
argument_list|,
operator|&
name|saddr
operator|->
name|v6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|h6
operator|->
name|ip6_dst
argument_list|,
operator|&
name|daddr
operator|->
name|v6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|h6
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
comment|/* TCP header */
name|th
operator|->
name|th_sport
operator|=
name|sport
expr_stmt|;
name|th
operator|->
name|th_dport
operator|=
name|dport
expr_stmt|;
name|th
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_ack
operator|=
name|htonl
argument_list|(
name|ack
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_off
operator|=
name|tlen
operator|>>
literal|2
expr_stmt|;
name|th
operator|->
name|th_flags
operator|=
name|flags
expr_stmt|;
name|th
operator|->
name|th_win
operator|=
name|htons
argument_list|(
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|mss
condition|)
block|{
name|opt
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|th
operator|+
literal|1
operator|)
expr_stmt|;
name|opt
index|[
literal|0
index|]
operator|=
name|TCPOPT_MAXSEG
expr_stmt|;
name|opt
index|[
literal|1
index|]
operator|=
literal|4
expr_stmt|;
name|HTONS
argument_list|(
name|mss
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|mss
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|opt
operator|+
literal|2
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
comment|/* TCP checksum */
name|th
operator|->
name|th_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Finish the IP header */
name|h
operator|->
name|ip_v
operator|=
literal|4
expr_stmt|;
name|h
operator|->
name|ip_hl
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|h
operator|->
name|ip_tos
operator|=
name|IPTOS_LOWDELAY
expr_stmt|;
name|h
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|V_path_mtu_discovery
condition|?
name|IP_DF
else|:
literal|0
argument_list|)
expr_stmt|;
name|h
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|h
operator|->
name|ip_ttl
operator|=
name|ttl
condition|?
name|ttl
else|:
name|V_ip_defttl
expr_stmt|;
name|h
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|pfse
operator|->
name|pfse_type
operator|=
name|PFSE_IP
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
comment|/* TCP checksum */
name|th
operator|->
name|th_sum
operator|=
name|in6_cksum
argument_list|(
name|m
argument_list|,
name|IPPROTO_TCP
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|h6
operator|->
name|ip6_vfc
operator||=
name|IPV6_VERSION
expr_stmt|;
name|h6
operator|->
name|ip6_hlim
operator|=
name|IPV6_DEFHLIM
expr_stmt|;
name|pfse
operator|->
name|pfse_type
operator|=
name|PFSE_IP6
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
name|pfse
operator|->
name|pfse_m
operator|=
name|m
expr_stmt|;
name|pf_send
argument_list|(
name|pfse
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_ieee8021q_setpcp
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int8_t
name|prio
parameter_list|)
block|{
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|KASSERT
argument_list|(
name|prio
operator|<=
name|PF_PRIO_MAX
argument_list|,
operator|(
literal|"%s with invalid pcp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|mtag
operator|=
name|m_tag_locate
argument_list|(
name|m
argument_list|,
name|MTAG_8021Q
argument_list|,
name|MTAG_8021Q_PCP_OUT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
block|{
name|mtag
operator|=
name|m_tag_alloc
argument_list|(
name|MTAG_8021Q
argument_list|,
name|MTAG_8021Q_PCP_OUT
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
operator|=
name|prio
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_match_ieee8021q_pcp
parameter_list|(
name|u_int8_t
name|prio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|u_int8_t
name|mpcp
decl_stmt|;
name|mtag
operator|=
name|m_tag_locate
argument_list|(
name|m
argument_list|,
name|MTAG_8021Q
argument_list|,
name|MTAG_8021Q_PCP_IN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|prio
operator|==
name|PF_PRIO_ZERO
condition|)
name|prio
operator|=
literal|0
expr_stmt|;
name|mpcp
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|mpcp
operator|==
name|prio
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pf_send_icmp
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int8_t
name|type
parameter_list|,
name|u_int8_t
name|code
parameter_list|,
name|sa_family_t
name|af
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|pf_send_entry
modifier|*
name|pfse
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|pf_mtag
modifier|*
name|pf_mtag
decl_stmt|;
comment|/* Allocate outgoing queue entry, mbuf and mbuf tag. */
name|pfse
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pfse
argument_list|)
argument_list|,
name|M_PFTEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfse
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|m0
operator|=
name|m_copypacket
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pfse
argument_list|,
name|M_PFTEMP
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|pf_mtag
operator|=
name|pf_get_mtag
argument_list|(
name|m0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pfse
argument_list|,
name|M_PFTEMP
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX: revisit */
name|m0
operator|->
name|m_flags
operator||=
name|M_SKIP_FIREWALL
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|rtableid
operator|>=
literal|0
condition|)
name|M_SETFIB
argument_list|(
name|m0
argument_list|,
name|r
operator|->
name|rtableid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ
if|if
condition|(
name|r
operator|->
name|qid
condition|)
block|{
name|pf_mtag
operator|->
name|qid
operator|=
name|r
operator|->
name|qid
expr_stmt|;
comment|/* add hints for ecn */
name|pf_mtag
operator|->
name|hdr
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ALTQ */
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|pfse
operator|->
name|pfse_type
operator|=
name|PFSE_ICMP
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|pfse
operator|->
name|pfse_type
operator|=
name|PFSE_ICMP6
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
name|pfse
operator|->
name|pfse_m
operator|=
name|m0
expr_stmt|;
name|pfse
operator|->
name|icmpopts
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|pfse
operator|->
name|icmpopts
operator|.
name|code
operator|=
name|code
expr_stmt|;
name|pf_send
argument_list|(
name|pfse
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return 1 if the addresses a and b match (with mask m), otherwise return 0.  * If n is 0, they match if they are equal. If n is != 0, they match if they  * are different.  */
end_comment

begin_function
name|int
name|pf_match_addr
parameter_list|(
name|u_int8_t
name|n
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|a
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|m
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|b
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|int
name|match
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
operator|(
name|a
operator|->
name|addr32
index|[
literal|0
index|]
operator|&
name|m
operator|->
name|addr32
index|[
literal|0
index|]
operator|)
operator|==
operator|(
name|b
operator|->
name|addr32
index|[
literal|0
index|]
operator|&
name|m
operator|->
name|addr32
index|[
literal|0
index|]
operator|)
condition|)
name|match
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
operator|(
operator|(
name|a
operator|->
name|addr32
index|[
literal|0
index|]
operator|&
name|m
operator|->
name|addr32
index|[
literal|0
index|]
operator|)
operator|==
operator|(
name|b
operator|->
name|addr32
index|[
literal|0
index|]
operator|&
name|m
operator|->
name|addr32
index|[
literal|0
index|]
operator|)
operator|)
operator|&&
operator|(
operator|(
name|a
operator|->
name|addr32
index|[
literal|1
index|]
operator|&
name|m
operator|->
name|addr32
index|[
literal|1
index|]
operator|)
operator|==
operator|(
name|b
operator|->
name|addr32
index|[
literal|1
index|]
operator|&
name|m
operator|->
name|addr32
index|[
literal|1
index|]
operator|)
operator|)
operator|&&
operator|(
operator|(
name|a
operator|->
name|addr32
index|[
literal|2
index|]
operator|&
name|m
operator|->
name|addr32
index|[
literal|2
index|]
operator|)
operator|==
operator|(
name|b
operator|->
name|addr32
index|[
literal|2
index|]
operator|&
name|m
operator|->
name|addr32
index|[
literal|2
index|]
operator|)
operator|)
operator|&&
operator|(
operator|(
name|a
operator|->
name|addr32
index|[
literal|3
index|]
operator|&
name|m
operator|->
name|addr32
index|[
literal|3
index|]
operator|)
operator|==
operator|(
name|b
operator|->
name|addr32
index|[
literal|3
index|]
operator|&
name|m
operator|->
name|addr32
index|[
literal|3
index|]
operator|)
operator|)
condition|)
name|match
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
if|if
condition|(
name|match
condition|)
block|{
if|if
condition|(
name|n
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|n
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return 1 if b<= a<= e, otherwise return 0.  */
end_comment

begin_function
name|int
name|pf_match_addr_range
parameter_list|(
name|struct
name|pf_addr
modifier|*
name|b
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|e
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|a
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|a
operator|->
name|addr32
index|[
literal|0
index|]
argument_list|)
operator|<
name|ntohl
argument_list|(
name|b
operator|->
name|addr32
index|[
literal|0
index|]
argument_list|)
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|a
operator|->
name|addr32
index|[
literal|0
index|]
argument_list|)
operator|>
name|ntohl
argument_list|(
name|e
operator|->
name|addr32
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|int
name|i
decl_stmt|;
comment|/* check a>= b */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ntohl
argument_list|(
name|a
operator|->
name|addr32
index|[
name|i
index|]
argument_list|)
operator|>
name|ntohl
argument_list|(
name|b
operator|->
name|addr32
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|ntohl
argument_list|(
name|a
operator|->
name|addr32
index|[
name|i
index|]
argument_list|)
operator|<
name|ntohl
argument_list|(
name|b
operator|->
name|addr32
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* check a<= e */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ntohl
argument_list|(
name|a
operator|->
name|addr32
index|[
name|i
index|]
argument_list|)
operator|<
name|ntohl
argument_list|(
name|e
operator|->
name|addr32
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|ntohl
argument_list|(
name|a
operator|->
name|addr32
index|[
name|i
index|]
argument_list|)
operator|>
name|ntohl
argument_list|(
name|e
operator|->
name|addr32
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_match
parameter_list|(
name|u_int8_t
name|op
parameter_list|,
name|u_int32_t
name|a1
parameter_list|,
name|u_int32_t
name|a2
parameter_list|,
name|u_int32_t
name|p
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|PF_OP_IRG
case|:
return|return
operator|(
operator|(
name|p
operator|>
name|a1
operator|)
operator|&&
operator|(
name|p
operator|<
name|a2
operator|)
operator|)
return|;
case|case
name|PF_OP_XRG
case|:
return|return
operator|(
operator|(
name|p
operator|<
name|a1
operator|)
operator|||
operator|(
name|p
operator|>
name|a2
operator|)
operator|)
return|;
case|case
name|PF_OP_RRG
case|:
return|return
operator|(
operator|(
name|p
operator|>=
name|a1
operator|)
operator|&&
operator|(
name|p
operator|<=
name|a2
operator|)
operator|)
return|;
case|case
name|PF_OP_EQ
case|:
return|return
operator|(
name|p
operator|==
name|a1
operator|)
return|;
case|case
name|PF_OP_NE
case|:
return|return
operator|(
name|p
operator|!=
name|a1
operator|)
return|;
case|case
name|PF_OP_LT
case|:
return|return
operator|(
name|p
operator|<
name|a1
operator|)
return|;
case|case
name|PF_OP_LE
case|:
return|return
operator|(
name|p
operator|<=
name|a1
operator|)
return|;
case|case
name|PF_OP_GT
case|:
return|return
operator|(
name|p
operator|>
name|a1
operator|)
return|;
case|case
name|PF_OP_GE
case|:
return|return
operator|(
name|p
operator|>=
name|a1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* never reached */
block|}
end_function

begin_function
name|int
name|pf_match_port
parameter_list|(
name|u_int8_t
name|op
parameter_list|,
name|u_int16_t
name|a1
parameter_list|,
name|u_int16_t
name|a2
parameter_list|,
name|u_int16_t
name|p
parameter_list|)
block|{
name|NTOHS
argument_list|(
name|a1
argument_list|)
expr_stmt|;
name|NTOHS
argument_list|(
name|a2
argument_list|)
expr_stmt|;
name|NTOHS
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|pf_match
argument_list|(
name|op
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_match_uid
parameter_list|(
name|u_int8_t
name|op
parameter_list|,
name|uid_t
name|a1
parameter_list|,
name|uid_t
name|a2
parameter_list|,
name|uid_t
name|u
parameter_list|)
block|{
if|if
condition|(
name|u
operator|==
name|UID_MAX
operator|&&
name|op
operator|!=
name|PF_OP_EQ
operator|&&
name|op
operator|!=
name|PF_OP_NE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|pf_match
argument_list|(
name|op
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|u
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_match_gid
parameter_list|(
name|u_int8_t
name|op
parameter_list|,
name|gid_t
name|a1
parameter_list|,
name|gid_t
name|a2
parameter_list|,
name|gid_t
name|g
parameter_list|)
block|{
if|if
condition|(
name|g
operator|==
name|GID_MAX
operator|&&
name|op
operator|!=
name|PF_OP_EQ
operator|&&
name|op
operator|!=
name|PF_OP_NE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|pf_match
argument_list|(
name|op
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|g
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pf_match_tag
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|r
parameter_list|,
name|int
modifier|*
name|tag
parameter_list|,
name|int
name|mtag
parameter_list|)
block|{
if|if
condition|(
operator|*
name|tag
operator|==
operator|-
literal|1
condition|)
operator|*
name|tag
operator|=
name|mtag
expr_stmt|;
return|return
operator|(
operator|(
operator|!
name|r
operator|->
name|match_tag_not
operator|&&
name|r
operator|->
name|match_tag
operator|==
operator|*
name|tag
operator|)
operator|||
operator|(
name|r
operator|->
name|match_tag_not
operator|&&
name|r
operator|->
name|match_tag
operator|!=
operator|*
name|tag
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pf_tag_packet
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|tag
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: tag %d"
operator|,
name|__func__
operator|,
name|tag
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pf_mtag
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|pd
operator|->
name|pf_mtag
operator|=
name|pf_get_mtag
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|pd
operator|->
name|pf_mtag
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PF_ANCHOR_STACKSIZE
value|32
end_define

begin_struct
struct|struct
name|pf_anchor_stackframe
block|{
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|r
decl_stmt|;
comment|/* XXX: + match bit */
name|struct
name|pf_anchor
modifier|*
name|child
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * XXX: We rely on malloc(9) returning pointer aligned addresses.  */
end_comment

begin_define
define|#
directive|define
name|PF_ANCHORSTACK_MATCH
value|0x00000001
end_define

begin_define
define|#
directive|define
name|PF_ANCHORSTACK_MASK
value|(PF_ANCHORSTACK_MATCH)
end_define

begin_define
define|#
directive|define
name|PF_ANCHOR_MATCH
parameter_list|(
name|f
parameter_list|)
value|((uintptr_t)(f)->r& PF_ANCHORSTACK_MATCH)
end_define

begin_define
define|#
directive|define
name|PF_ANCHOR_RULE
parameter_list|(
name|f
parameter_list|)
value|(struct pf_rule *)			\ 				((uintptr_t)(f)->r& ~PF_ANCHORSTACK_MASK)
end_define

begin_define
define|#
directive|define
name|PF_ANCHOR_SET_MATCH
parameter_list|(
name|f
parameter_list|)
value|do { (f)->r = (void *) 			\ 				((uintptr_t)(f)->r | PF_ANCHORSTACK_MATCH);  \ } while (0)
end_define

begin_function
name|void
name|pf_step_into_anchor
parameter_list|(
name|struct
name|pf_anchor_stackframe
modifier|*
name|stack
parameter_list|,
name|int
modifier|*
name|depth
parameter_list|,
name|struct
name|pf_ruleset
modifier|*
modifier|*
name|rs
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|pf_rule
modifier|*
modifier|*
name|r
parameter_list|,
name|struct
name|pf_rule
modifier|*
modifier|*
name|a
parameter_list|,
name|int
modifier|*
name|match
parameter_list|)
block|{
name|struct
name|pf_anchor_stackframe
modifier|*
name|f
decl_stmt|;
name|PF_RULES_RASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|match
condition|)
operator|*
name|match
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|depth
operator|>=
name|PF_ANCHOR_STACKSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: anchor stack overflow on %s\n"
argument_list|,
name|__func__
argument_list|,
operator|(
operator|*
name|r
operator|)
operator|->
name|anchor
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
operator|*
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|depth
operator|==
literal|0
operator|&&
name|a
operator|!=
name|NULL
condition|)
operator|*
name|a
operator|=
operator|*
name|r
expr_stmt|;
name|f
operator|=
name|stack
operator|+
operator|(
operator|*
name|depth
operator|)
operator|++
expr_stmt|;
name|f
operator|->
name|rs
operator|=
operator|*
name|rs
expr_stmt|;
name|f
operator|->
name|r
operator|=
operator|*
name|r
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|r
operator|)
operator|->
name|anchor_wildcard
condition|)
block|{
name|struct
name|pf_anchor_node
modifier|*
name|parent
init|=
operator|&
operator|(
operator|*
name|r
operator|)
operator|->
name|anchor
operator|->
name|children
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|child
operator|=
name|RB_MIN
argument_list|(
name|pf_anchor_node
argument_list|,
name|parent
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|r
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
operator|*
name|rs
operator|=
operator|&
name|f
operator|->
name|child
operator|->
name|ruleset
expr_stmt|;
block|}
else|else
block|{
name|f
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
operator|*
name|rs
operator|=
operator|&
operator|(
operator|*
name|r
operator|)
operator|->
name|anchor
operator|->
name|ruleset
expr_stmt|;
block|}
operator|*
name|r
operator|=
name|TAILQ_FIRST
argument_list|(
operator|(
operator|*
name|rs
operator|)
operator|->
name|rules
index|[
name|n
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pf_step_out_of_anchor
parameter_list|(
name|struct
name|pf_anchor_stackframe
modifier|*
name|stack
parameter_list|,
name|int
modifier|*
name|depth
parameter_list|,
name|struct
name|pf_ruleset
modifier|*
modifier|*
name|rs
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|pf_rule
modifier|*
modifier|*
name|r
parameter_list|,
name|struct
name|pf_rule
modifier|*
modifier|*
name|a
parameter_list|,
name|int
modifier|*
name|match
parameter_list|)
block|{
name|struct
name|pf_anchor_stackframe
modifier|*
name|f
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|fr
decl_stmt|;
name|int
name|quick
init|=
literal|0
decl_stmt|;
name|PF_RULES_RASSERT
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|depth
operator|<=
literal|0
condition|)
break|break;
name|f
operator|=
name|stack
operator|+
operator|*
name|depth
operator|-
literal|1
expr_stmt|;
name|fr
operator|=
name|PF_ANCHOR_RULE
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|struct
name|pf_anchor_node
modifier|*
name|parent
decl_stmt|;
comment|/* 			 * This block traverses through 			 * a wildcard anchor. 			 */
name|parent
operator|=
operator|&
name|fr
operator|->
name|anchor
operator|->
name|children
expr_stmt|;
if|if
condition|(
name|match
operator|!=
name|NULL
operator|&&
operator|*
name|match
condition|)
block|{
comment|/* 				 * If any of "*" matched, then 				 * "foo/ *" matched, mark frame 				 * appropriately. 				 */
name|PF_ANCHOR_SET_MATCH
argument_list|(
name|f
argument_list|)
expr_stmt|;
operator|*
name|match
operator|=
literal|0
expr_stmt|;
block|}
name|f
operator|->
name|child
operator|=
name|RB_NEXT
argument_list|(
name|pf_anchor_node
argument_list|,
name|parent
argument_list|,
name|f
operator|->
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
operator|*
name|rs
operator|=
operator|&
name|f
operator|->
name|child
operator|->
name|ruleset
expr_stmt|;
operator|*
name|r
operator|=
name|TAILQ_FIRST
argument_list|(
operator|(
operator|*
name|rs
operator|)
operator|->
name|rules
index|[
name|n
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|r
operator|==
name|NULL
condition|)
continue|continue;
else|else
break|break;
block|}
block|}
operator|(
operator|*
name|depth
operator|)
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|depth
operator|==
literal|0
operator|&&
name|a
operator|!=
name|NULL
condition|)
operator|*
name|a
operator|=
name|NULL
expr_stmt|;
operator|*
name|rs
operator|=
name|f
operator|->
name|rs
expr_stmt|;
if|if
condition|(
name|PF_ANCHOR_MATCH
argument_list|(
name|f
argument_list|)
operator|||
operator|(
name|match
operator|!=
name|NULL
operator|&&
operator|*
name|match
operator|)
condition|)
name|quick
operator|=
name|fr
operator|->
name|quick
expr_stmt|;
operator|*
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|fr
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|r
operator|==
name|NULL
condition|)
do|;
return|return
operator|(
name|quick
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
name|void
name|pf_poolmask
parameter_list|(
name|struct
name|pf_addr
modifier|*
name|naddr
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|raddr
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|rmask
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|saddr
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|naddr
operator|->
name|addr32
index|[
literal|0
index|]
operator|=
operator|(
name|raddr
operator|->
name|addr32
index|[
literal|0
index|]
operator|&
name|rmask
operator|->
name|addr32
index|[
literal|0
index|]
operator|)
operator||
operator|(
operator|(
name|rmask
operator|->
name|addr32
index|[
literal|0
index|]
operator|^
literal|0xffffffff
operator|)
operator|&
name|saddr
operator|->
name|addr32
index|[
literal|0
index|]
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
case|case
name|AF_INET6
case|:
name|naddr
operator|->
name|addr32
index|[
literal|0
index|]
operator|=
operator|(
name|raddr
operator|->
name|addr32
index|[
literal|0
index|]
operator|&
name|rmask
operator|->
name|addr32
index|[
literal|0
index|]
operator|)
operator||
operator|(
operator|(
name|rmask
operator|->
name|addr32
index|[
literal|0
index|]
operator|^
literal|0xffffffff
operator|)
operator|&
name|saddr
operator|->
name|addr32
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|naddr
operator|->
name|addr32
index|[
literal|1
index|]
operator|=
operator|(
name|raddr
operator|->
name|addr32
index|[
literal|1
index|]
operator|&
name|rmask
operator|->
name|addr32
index|[
literal|1
index|]
operator|)
operator||
operator|(
operator|(
name|rmask
operator|->
name|addr32
index|[
literal|1
index|]
operator|^
literal|0xffffffff
operator|)
operator|&
name|saddr
operator|->
name|addr32
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|naddr
operator|->
name|addr32
index|[
literal|2
index|]
operator|=
operator|(
name|raddr
operator|->
name|addr32
index|[
literal|2
index|]
operator|&
name|rmask
operator|->
name|addr32
index|[
literal|2
index|]
operator|)
operator||
operator|(
operator|(
name|rmask
operator|->
name|addr32
index|[
literal|2
index|]
operator|^
literal|0xffffffff
operator|)
operator|&
name|saddr
operator|->
name|addr32
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|naddr
operator|->
name|addr32
index|[
literal|3
index|]
operator|=
operator|(
name|raddr
operator|->
name|addr32
index|[
literal|3
index|]
operator|&
name|rmask
operator|->
name|addr32
index|[
literal|3
index|]
operator|)
operator||
operator|(
operator|(
name|rmask
operator|->
name|addr32
index|[
literal|3
index|]
operator|^
literal|0xffffffff
operator|)
operator|&
name|saddr
operator|->
name|addr32
index|[
literal|3
index|]
operator|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|pf_addr_inc
parameter_list|(
name|struct
name|pf_addr
modifier|*
name|addr
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|addr
operator|->
name|addr32
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|addr
operator|->
name|addr32
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
case|case
name|AF_INET6
case|:
if|if
condition|(
name|addr
operator|->
name|addr32
index|[
literal|3
index|]
operator|==
literal|0xffffffff
condition|)
block|{
name|addr
operator|->
name|addr32
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|addr32
index|[
literal|2
index|]
operator|==
literal|0xffffffff
condition|)
block|{
name|addr
operator|->
name|addr32
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|addr32
index|[
literal|1
index|]
operator|==
literal|0xffffffff
condition|)
block|{
name|addr
operator|->
name|addr32
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|addr32
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|addr
operator|->
name|addr32
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|addr
operator|->
name|addr32
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|addr
operator|->
name|addr32
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|addr
operator|->
name|addr32
index|[
literal|2
index|]
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|addr
operator|->
name|addr32
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|addr
operator|->
name|addr32
index|[
literal|3
index|]
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|addr
operator|->
name|addr32
index|[
literal|3
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_function
name|int
name|pf_socket_lookup
parameter_list|(
name|int
name|direction
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|pf_addr
modifier|*
name|saddr
decl_stmt|,
modifier|*
name|daddr
decl_stmt|;
name|u_int16_t
name|sport
decl_stmt|,
name|dport
decl_stmt|;
name|struct
name|inpcbinfo
modifier|*
name|pi
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|pd
operator|->
name|lookup
operator|.
name|uid
operator|=
name|UID_MAX
expr_stmt|;
name|pd
operator|->
name|lookup
operator|.
name|gid
operator|=
name|GID_MAX
expr_stmt|;
switch|switch
condition|(
name|pd
operator|->
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|pd
operator|->
name|hdr
operator|.
name|tcp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sport
operator|=
name|pd
operator|->
name|hdr
operator|.
name|tcp
operator|->
name|th_sport
expr_stmt|;
name|dport
operator|=
name|pd
operator|->
name|hdr
operator|.
name|tcp
operator|->
name|th_dport
expr_stmt|;
name|pi
operator|=
operator|&
name|V_tcbinfo
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|pd
operator|->
name|hdr
operator|.
name|udp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sport
operator|=
name|pd
operator|->
name|hdr
operator|.
name|udp
operator|->
name|uh_sport
expr_stmt|;
name|dport
operator|=
name|pd
operator|->
name|hdr
operator|.
name|udp
operator|->
name|uh_dport
expr_stmt|;
name|pi
operator|=
operator|&
name|V_udbinfo
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|direction
operator|==
name|PF_IN
condition|)
block|{
name|saddr
operator|=
name|pd
operator|->
name|src
expr_stmt|;
name|daddr
operator|=
name|pd
operator|->
name|dst
expr_stmt|;
block|}
else|else
block|{
name|u_int16_t
name|p
decl_stmt|;
name|p
operator|=
name|sport
expr_stmt|;
name|sport
operator|=
name|dport
expr_stmt|;
name|dport
operator|=
name|p
expr_stmt|;
name|saddr
operator|=
name|pd
operator|->
name|dst
expr_stmt|;
name|daddr
operator|=
name|pd
operator|->
name|src
expr_stmt|;
block|}
switch|switch
condition|(
name|pd
operator|->
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|inp
operator|=
name|in_pcblookup_mbuf
argument_list|(
name|pi
argument_list|,
name|saddr
operator|->
name|v4
argument_list|,
name|sport
argument_list|,
name|daddr
operator|->
name|v4
argument_list|,
name|dport
argument_list|,
name|INPLOOKUP_RLOCKPCB
argument_list|,
name|NULL
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|inp
operator|=
name|in_pcblookup_mbuf
argument_list|(
name|pi
argument_list|,
name|saddr
operator|->
name|v4
argument_list|,
name|sport
argument_list|,
name|daddr
operator|->
name|v4
argument_list|,
name|dport
argument_list|,
name|INPLOOKUP_WILDCARD
operator||
name|INPLOOKUP_RLOCKPCB
argument_list|,
name|NULL
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|inp
operator|=
name|in6_pcblookup_mbuf
argument_list|(
name|pi
argument_list|,
operator|&
name|saddr
operator|->
name|v6
argument_list|,
name|sport
argument_list|,
operator|&
name|daddr
operator|->
name|v6
argument_list|,
name|dport
argument_list|,
name|INPLOOKUP_RLOCKPCB
argument_list|,
name|NULL
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|inp
operator|=
name|in6_pcblookup_mbuf
argument_list|(
name|pi
argument_list|,
operator|&
name|saddr
operator|->
name|v6
argument_list|,
name|sport
argument_list|,
operator|&
name|daddr
operator|->
name|v6
argument_list|,
name|dport
argument_list|,
name|INPLOOKUP_WILDCARD
operator||
name|INPLOOKUP_RLOCKPCB
argument_list|,
name|NULL
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|INP_RLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|pd
operator|->
name|lookup
operator|.
name|uid
operator|=
name|inp
operator|->
name|inp_cred
operator|->
name|cr_uid
expr_stmt|;
name|pd
operator|->
name|lookup
operator|.
name|gid
operator|=
name|inp
operator|->
name|inp_cred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|pf_get_wscale
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|u_int16_t
name|th_off
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|int
name|hlen
decl_stmt|;
name|u_int8_t
name|hdr
index|[
literal|60
index|]
decl_stmt|;
name|u_int8_t
modifier|*
name|opt
decl_stmt|,
name|optlen
decl_stmt|;
name|u_int8_t
name|wscale
init|=
literal|0
decl_stmt|;
name|hlen
operator|=
name|th_off
operator|<<
literal|2
expr_stmt|;
comment|/* hlen<= sizeof(hdr) */
if|if
condition|(
name|hlen
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|hdr
argument_list|,
name|hlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|af
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|opt
operator|=
name|hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
name|hlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
while|while
condition|(
name|hlen
operator|>=
literal|3
condition|)
block|{
switch|switch
condition|(
operator|*
name|opt
condition|)
block|{
case|case
name|TCPOPT_EOL
case|:
case|case
name|TCPOPT_NOP
case|:
operator|++
name|opt
expr_stmt|;
operator|--
name|hlen
expr_stmt|;
break|break;
case|case
name|TCPOPT_WINDOW
case|:
name|wscale
operator|=
name|opt
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|wscale
operator|>
name|TCP_MAX_WINSHIFT
condition|)
name|wscale
operator|=
name|TCP_MAX_WINSHIFT
expr_stmt|;
name|wscale
operator||=
name|PF_WSCALE_FLAG
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|optlen
operator|=
name|opt
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|optlen
operator|<
literal|2
condition|)
name|optlen
operator|=
literal|2
expr_stmt|;
name|hlen
operator|-=
name|optlen
expr_stmt|;
name|opt
operator|+=
name|optlen
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|wscale
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|pf_get_mss
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|u_int16_t
name|th_off
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|int
name|hlen
decl_stmt|;
name|u_int8_t
name|hdr
index|[
literal|60
index|]
decl_stmt|;
name|u_int8_t
modifier|*
name|opt
decl_stmt|,
name|optlen
decl_stmt|;
name|u_int16_t
name|mss
init|=
name|V_tcp_mssdflt
decl_stmt|;
name|hlen
operator|=
name|th_off
operator|<<
literal|2
expr_stmt|;
comment|/* hlen<= sizeof(hdr) */
if|if
condition|(
name|hlen
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|hdr
argument_list|,
name|hlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|af
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|opt
operator|=
name|hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
name|hlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
while|while
condition|(
name|hlen
operator|>=
name|TCPOLEN_MAXSEG
condition|)
block|{
switch|switch
condition|(
operator|*
name|opt
condition|)
block|{
case|case
name|TCPOPT_EOL
case|:
case|case
name|TCPOPT_NOP
case|:
operator|++
name|opt
expr_stmt|;
operator|--
name|hlen
expr_stmt|;
break|break;
case|case
name|TCPOPT_MAXSEG
case|:
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|opt
operator|+
literal|2
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|mss
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|NTOHS
argument_list|(
name|mss
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|optlen
operator|=
name|opt
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|optlen
operator|<
literal|2
condition|)
name|optlen
operator|=
literal|2
expr_stmt|;
name|hlen
operator|-=
name|optlen
expr_stmt|;
name|opt
operator|+=
name|optlen
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|mss
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|pf_calc_mss
parameter_list|(
name|struct
name|pf_addr
modifier|*
name|addr
parameter_list|,
name|sa_family_t
name|af
parameter_list|,
name|int
name|rtableid
parameter_list|,
name|u_int16_t
name|offer
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|nhop4_basic
name|nh4
decl_stmt|;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
name|struct
name|nhop6_basic
name|nh6
decl_stmt|;
name|struct
name|in6_addr
name|dst6
decl_stmt|;
name|uint32_t
name|scopeid
decl_stmt|;
endif|#
directive|endif
comment|/* INET6 */
name|int
name|hlen
init|=
literal|0
decl_stmt|;
name|uint16_t
name|mss
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|fib4_lookup_nh_basic
argument_list|(
name|rtableid
argument_list|,
name|addr
operator|->
name|v4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|nh4
argument_list|)
operator|==
literal|0
condition|)
name|mss
operator|=
name|nh4
operator|.
name|nh_mtu
operator|-
name|hlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|in6_splitscope
argument_list|(
operator|&
name|addr
operator|->
name|v6
argument_list|,
operator|&
name|dst6
argument_list|,
operator|&
name|scopeid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fib6_lookup_nh_basic
argument_list|(
name|rtableid
argument_list|,
operator|&
name|dst6
argument_list|,
name|scopeid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|nh6
argument_list|)
operator|==
literal|0
condition|)
name|mss
operator|=
name|nh6
operator|.
name|nh_mtu
operator|-
name|hlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
name|mss
operator|=
name|max
argument_list|(
name|V_tcp_mssdflt
argument_list|,
name|mss
argument_list|)
expr_stmt|;
name|mss
operator|=
name|min
argument_list|(
name|mss
argument_list|,
name|offer
argument_list|)
expr_stmt|;
name|mss
operator|=
name|max
argument_list|(
name|mss
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* sanity - at least max opt space */
return|return
operator|(
name|mss
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|pf_tcp_iss
parameter_list|(
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|)
block|{
name|MD5_CTX
name|ctx
decl_stmt|;
name|u_int32_t
name|digest
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|V_pf_tcp_secret_init
operator|==
literal|0
condition|)
block|{
name|read_random
argument_list|(
operator|&
name|V_pf_tcp_secret
argument_list|,
sizeof|sizeof
argument_list|(
name|V_pf_tcp_secret
argument_list|)
argument_list|)
expr_stmt|;
name|MD5Init
argument_list|(
operator|&
name|V_pf_tcp_secret_ctx
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|V_pf_tcp_secret_ctx
argument_list|,
name|V_pf_tcp_secret
argument_list|,
sizeof|sizeof
argument_list|(
name|V_pf_tcp_secret
argument_list|)
argument_list|)
expr_stmt|;
name|V_pf_tcp_secret_init
operator|=
literal|1
expr_stmt|;
block|}
name|ctx
operator|=
name|V_pf_tcp_secret_ctx
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pd
operator|->
name|hdr
operator|.
name|tcp
operator|->
name|th_sport
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pd
operator|->
name|hdr
operator|.
name|tcp
operator|->
name|th_dport
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|MD5Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pd
operator|->
name|src
operator|->
name|v6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pd
operator|->
name|dst
operator|->
name|v6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MD5Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pd
operator|->
name|src
operator|->
name|v4
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pd
operator|->
name|dst
operator|->
name|v4
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MD5Final
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|digest
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|V_pf_tcp_iss_off
operator|+=
literal|4096
expr_stmt|;
define|#
directive|define
name|ISN_RANDOM_INCREMENT
value|(4096 - 1)
return|return
operator|(
name|digest
index|[
literal|0
index|]
operator|+
operator|(
name|arc4random
argument_list|()
operator|&
name|ISN_RANDOM_INCREMENT
operator|)
operator|+
name|V_pf_tcp_iss_off
operator|)
return|;
undef|#
directive|undef
name|ISN_RANDOM_INCREMENT
block|}
end_function

begin_function
specifier|static
name|int
name|pf_test_rule
parameter_list|(
name|struct
name|pf_rule
modifier|*
modifier|*
name|rm
parameter_list|,
name|struct
name|pf_state
modifier|*
modifier|*
name|sm
parameter_list|,
name|int
name|direction
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|struct
name|pf_rule
modifier|*
modifier|*
name|am
parameter_list|,
name|struct
name|pf_ruleset
modifier|*
modifier|*
name|rsm
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|pf_rule
modifier|*
name|nr
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_addr
modifier|*
specifier|const
name|saddr
init|=
name|pd
operator|->
name|src
decl_stmt|;
name|struct
name|pf_addr
modifier|*
specifier|const
name|daddr
init|=
name|pd
operator|->
name|dst
decl_stmt|;
name|sa_family_t
name|af
init|=
name|pd
operator|->
name|af
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|r
decl_stmt|,
modifier|*
name|a
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_src_node
modifier|*
name|nsn
init|=
name|NULL
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
name|pd
operator|->
name|hdr
operator|.
name|tcp
decl_stmt|;
name|struct
name|pf_state_key
modifier|*
name|sk
init|=
name|NULL
decl_stmt|,
modifier|*
name|nk
init|=
name|NULL
decl_stmt|;
name|u_short
name|reason
decl_stmt|;
name|int
name|rewrite
init|=
literal|0
decl_stmt|,
name|hdrlen
init|=
literal|0
decl_stmt|;
name|int
name|tag
init|=
operator|-
literal|1
decl_stmt|,
name|rtableid
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|asd
init|=
literal|0
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
name|int
name|state_icmp
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|sport
init|=
literal|0
decl_stmt|,
name|dport
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|bproto_sum
init|=
literal|0
decl_stmt|,
name|bip_sum
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|icmptype
init|=
literal|0
decl_stmt|,
name|icmpcode
init|=
literal|0
decl_stmt|;
name|struct
name|pf_anchor_stackframe
name|anchor_stack
index|[
name|PF_ANCHOR_STACKSIZE
index|]
decl_stmt|;
name|PF_RULES_RASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
block|{
name|INP_LOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|pd
operator|->
name|lookup
operator|.
name|uid
operator|=
name|inp
operator|->
name|inp_cred
operator|->
name|cr_uid
expr_stmt|;
name|pd
operator|->
name|lookup
operator|.
name|gid
operator|=
name|inp
operator|->
name|inp_cred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
name|pd
operator|->
name|lookup
operator|.
name|done
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|pd
operator|->
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|sport
operator|=
name|th
operator|->
name|th_sport
expr_stmt|;
name|dport
operator|=
name|th
operator|->
name|th_dport
expr_stmt|;
name|hdrlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|sport
operator|=
name|pd
operator|->
name|hdr
operator|.
name|udp
operator|->
name|uh_sport
expr_stmt|;
name|dport
operator|=
name|pd
operator|->
name|hdr
operator|.
name|udp
operator|->
name|uh_dport
expr_stmt|;
name|hdrlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|pd
operator|->
name|hdr
operator|.
name|udp
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET
case|case
name|IPPROTO_ICMP
case|:
if|if
condition|(
name|pd
operator|->
name|af
operator|!=
name|AF_INET
condition|)
break|break;
name|sport
operator|=
name|dport
operator|=
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_id
expr_stmt|;
name|hdrlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|pd
operator|->
name|hdr
operator|.
name|icmp
argument_list|)
expr_stmt|;
name|icmptype
operator|=
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_type
expr_stmt|;
name|icmpcode
operator|=
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_code
expr_stmt|;
if|if
condition|(
name|icmptype
operator|==
name|ICMP_UNREACH
operator|||
name|icmptype
operator|==
name|ICMP_SOURCEQUENCH
operator|||
name|icmptype
operator|==
name|ICMP_REDIRECT
operator|||
name|icmptype
operator|==
name|ICMP_TIMXCEED
operator|||
name|icmptype
operator|==
name|ICMP_PARAMPROB
condition|)
name|state_icmp
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPPROTO_ICMPV6
case|:
if|if
condition|(
name|af
operator|!=
name|AF_INET6
condition|)
break|break;
name|sport
operator|=
name|dport
operator|=
name|pd
operator|->
name|hdr
operator|.
name|icmp6
operator|->
name|icmp6_id
expr_stmt|;
name|hdrlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|pd
operator|->
name|hdr
operator|.
name|icmp6
argument_list|)
expr_stmt|;
name|icmptype
operator|=
name|pd
operator|->
name|hdr
operator|.
name|icmp6
operator|->
name|icmp6_type
expr_stmt|;
name|icmpcode
operator|=
name|pd
operator|->
name|hdr
operator|.
name|icmp6
operator|->
name|icmp6_code
expr_stmt|;
if|if
condition|(
name|icmptype
operator|==
name|ICMP6_DST_UNREACH
operator|||
name|icmptype
operator|==
name|ICMP6_PACKET_TOO_BIG
operator|||
name|icmptype
operator|==
name|ICMP6_TIME_EXCEEDED
operator|||
name|icmptype
operator|==
name|ICMP6_PARAM_PROB
condition|)
name|state_icmp
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
name|sport
operator|=
name|dport
operator|=
name|hdrlen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|r
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_main_ruleset
operator|.
name|rules
index|[
name|PF_RULESET_FILTER
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
comment|/* check packet for BINAT/NAT/RDR */
if|if
condition|(
operator|(
name|nr
operator|=
name|pf_get_translation
argument_list|(
name|pd
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|direction
argument_list|,
name|kif
argument_list|,
operator|&
name|nsn
argument_list|,
operator|&
name|sk
argument_list|,
operator|&
name|nk
argument_list|,
name|saddr
argument_list|,
name|daddr
argument_list|,
name|sport
argument_list|,
name|dport
argument_list|,
name|anchor_stack
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|sk
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: null sk"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nk
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: null nk"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|ip_sum
condition|)
name|bip_sum
operator|=
operator|*
name|pd
operator|->
name|ip_sum
expr_stmt|;
switch|switch
condition|(
name|pd
operator|->
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|bproto_sum
operator|=
name|th
operator|->
name|th_sum
expr_stmt|;
name|pd
operator|->
name|proto_sum
operator|=
operator|&
name|th
operator|->
name|th_sum
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|saddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|sidx
index|]
operator|!=
name|sport
condition|)
block|{
name|pf_change_ap
argument_list|(
name|m
argument_list|,
name|saddr
argument_list|,
operator|&
name|th
operator|->
name|th_sport
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
operator|&
name|th
operator|->
name|th_sum
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
literal|0
argument_list|,
name|af
argument_list|)
expr_stmt|;
name|pd
operator|->
name|sport
operator|=
operator|&
name|th
operator|->
name|th_sport
expr_stmt|;
name|sport
operator|=
name|th
operator|->
name|th_sport
expr_stmt|;
block|}
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|daddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|didx
index|]
operator|!=
name|dport
condition|)
block|{
name|pf_change_ap
argument_list|(
name|m
argument_list|,
name|daddr
argument_list|,
operator|&
name|th
operator|->
name|th_dport
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
operator|&
name|th
operator|->
name|th_sum
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
literal|0
argument_list|,
name|af
argument_list|)
expr_stmt|;
name|dport
operator|=
name|th
operator|->
name|th_dport
expr_stmt|;
name|pd
operator|->
name|dport
operator|=
operator|&
name|th
operator|->
name|th_dport
expr_stmt|;
block|}
name|rewrite
operator|++
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|bproto_sum
operator|=
name|pd
operator|->
name|hdr
operator|.
name|udp
operator|->
name|uh_sum
expr_stmt|;
name|pd
operator|->
name|proto_sum
operator|=
operator|&
name|pd
operator|->
name|hdr
operator|.
name|udp
operator|->
name|uh_sum
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|saddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|sidx
index|]
operator|!=
name|sport
condition|)
block|{
name|pf_change_ap
argument_list|(
name|m
argument_list|,
name|saddr
argument_list|,
operator|&
name|pd
operator|->
name|hdr
operator|.
name|udp
operator|->
name|uh_sport
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
operator|&
name|pd
operator|->
name|hdr
operator|.
name|udp
operator|->
name|uh_sum
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
literal|1
argument_list|,
name|af
argument_list|)
expr_stmt|;
name|sport
operator|=
name|pd
operator|->
name|hdr
operator|.
name|udp
operator|->
name|uh_sport
expr_stmt|;
name|pd
operator|->
name|sport
operator|=
operator|&
name|pd
operator|->
name|hdr
operator|.
name|udp
operator|->
name|uh_sport
expr_stmt|;
block|}
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|daddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|didx
index|]
operator|!=
name|dport
condition|)
block|{
name|pf_change_ap
argument_list|(
name|m
argument_list|,
name|daddr
argument_list|,
operator|&
name|pd
operator|->
name|hdr
operator|.
name|udp
operator|->
name|uh_dport
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
operator|&
name|pd
operator|->
name|hdr
operator|.
name|udp
operator|->
name|uh_sum
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
literal|1
argument_list|,
name|af
argument_list|)
expr_stmt|;
name|dport
operator|=
name|pd
operator|->
name|hdr
operator|.
name|udp
operator|->
name|uh_dport
expr_stmt|;
name|pd
operator|->
name|dport
operator|=
operator|&
name|pd
operator|->
name|hdr
operator|.
name|udp
operator|->
name|uh_dport
expr_stmt|;
block|}
name|rewrite
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET
case|case
name|IPPROTO_ICMP
case|:
name|nk
operator|->
name|port
index|[
literal|0
index|]
operator|=
name|nk
operator|->
name|port
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|saddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|AF_INET
argument_list|)
condition|)
name|pf_change_a
argument_list|(
operator|&
name|saddr
operator|->
name|v4
operator|.
name|s_addr
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
operator|.
name|v4
operator|.
name|s_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|daddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|AF_INET
argument_list|)
condition|)
name|pf_change_a
argument_list|(
operator|&
name|daddr
operator|->
name|v4
operator|.
name|s_addr
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
operator|.
name|v4
operator|.
name|s_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nk
operator|->
name|port
index|[
literal|1
index|]
operator|!=
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_id
condition|)
block|{
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_cksum
operator|=
name|pf_cksum_fixup
argument_list|(
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_cksum
argument_list|,
name|sport
argument_list|,
name|nk
operator|->
name|port
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_id
operator|=
name|nk
operator|->
name|port
index|[
literal|1
index|]
expr_stmt|;
name|pd
operator|->
name|sport
operator|=
operator|&
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_id
expr_stmt|;
block|}
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|ICMP_MINLEN
argument_list|,
operator|(
name|caddr_t
operator|)
name|pd
operator|->
name|hdr
operator|.
name|icmp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPPROTO_ICMPV6
case|:
name|nk
operator|->
name|port
index|[
literal|0
index|]
operator|=
name|nk
operator|->
name|port
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|saddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|AF_INET6
argument_list|)
condition|)
name|pf_change_a6
argument_list|(
name|saddr
argument_list|,
operator|&
name|pd
operator|->
name|hdr
operator|.
name|icmp6
operator|->
name|icmp6_cksum
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|daddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|AF_INET6
argument_list|)
condition|)
name|pf_change_a6
argument_list|(
name|daddr
argument_list|,
operator|&
name|pd
operator|->
name|hdr
operator|.
name|icmp6
operator|->
name|icmp6_cksum
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rewrite
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
default|default:
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|saddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|AF_INET
argument_list|)
condition|)
name|pf_change_a
argument_list|(
operator|&
name|saddr
operator|->
name|v4
operator|.
name|s_addr
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
operator|.
name|v4
operator|.
name|s_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|daddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|AF_INET
argument_list|)
condition|)
name|pf_change_a
argument_list|(
operator|&
name|daddr
operator|->
name|v4
operator|.
name|s_addr
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
operator|.
name|v4
operator|.
name|s_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|saddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|AF_INET6
argument_list|)
condition|)
name|PF_ACPY
argument_list|(
name|saddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|daddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|AF_INET6
argument_list|)
condition|)
name|PF_ACPY
argument_list|(
name|saddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|af
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
block|}
break|break;
block|}
if|if
condition|(
name|nr
operator|->
name|natpass
condition|)
name|r
operator|=
name|NULL
expr_stmt|;
name|pd
operator|->
name|nat_rule
operator|=
name|nr
expr_stmt|;
block|}
while|while
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
name|r
operator|->
name|evaluations
operator|++
expr_stmt|;
if|if
condition|(
name|pfi_kif_match
argument_list|(
name|r
operator|->
name|kif
argument_list|,
name|kif
argument_list|)
operator|==
name|r
operator|->
name|ifnot
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_IFP
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|direction
operator|&&
name|r
operator|->
name|direction
operator|!=
name|direction
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DIR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|af
operator|&&
name|r
operator|->
name|af
operator|!=
name|af
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_AF
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|proto
operator|&&
name|r
operator|->
name|proto
operator|!=
name|pd
operator|->
name|proto
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_PROTO
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|src
operator|.
name|addr
argument_list|,
name|saddr
argument_list|,
name|af
argument_list|,
name|r
operator|->
name|src
operator|.
name|neg
argument_list|,
name|kif
argument_list|,
name|M_GETFIB
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_SRC_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
comment|/* tcp/udp only. port_op always 0 in other cases */
elseif|else
if|if
condition|(
name|r
operator|->
name|src
operator|.
name|port_op
operator|&&
operator|!
name|pf_match_port
argument_list|(
name|r
operator|->
name|src
operator|.
name|port_op
argument_list|,
name|r
operator|->
name|src
operator|.
name|port
index|[
literal|0
index|]
argument_list|,
name|r
operator|->
name|src
operator|.
name|port
index|[
literal|1
index|]
argument_list|,
name|sport
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_SRC_PORT
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|dst
operator|.
name|addr
argument_list|,
name|daddr
argument_list|,
name|af
argument_list|,
name|r
operator|->
name|dst
operator|.
name|neg
argument_list|,
name|NULL
argument_list|,
name|M_GETFIB
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DST_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
comment|/* tcp/udp only. port_op always 0 in other cases */
elseif|else
if|if
condition|(
name|r
operator|->
name|dst
operator|.
name|port_op
operator|&&
operator|!
name|pf_match_port
argument_list|(
name|r
operator|->
name|dst
operator|.
name|port_op
argument_list|,
name|r
operator|->
name|dst
operator|.
name|port
index|[
literal|0
index|]
argument_list|,
name|r
operator|->
name|dst
operator|.
name|port
index|[
literal|1
index|]
argument_list|,
name|dport
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DST_PORT
index|]
operator|.
name|ptr
expr_stmt|;
comment|/* icmp only. type always 0 in other cases */
elseif|else
if|if
condition|(
name|r
operator|->
name|type
operator|&&
name|r
operator|->
name|type
operator|!=
name|icmptype
operator|+
literal|1
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
comment|/* icmp only. type always 0 in other cases */
elseif|else
if|if
condition|(
name|r
operator|->
name|code
operator|&&
name|r
operator|->
name|code
operator|!=
name|icmpcode
operator|+
literal|1
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|tos
operator|&&
operator|!
operator|(
name|r
operator|->
name|tos
operator|==
name|pd
operator|->
name|tos
operator|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_FRAGMENT
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pd
operator|->
name|proto
operator|==
name|IPPROTO_TCP
operator|&&
operator|(
name|r
operator|->
name|flagset
operator|&
name|th
operator|->
name|th_flags
operator|)
operator|!=
name|r
operator|->
name|flags
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
comment|/* tcp/udp only. uid.op always 0 in other cases */
elseif|else
if|if
condition|(
name|r
operator|->
name|uid
operator|.
name|op
operator|&&
operator|(
name|pd
operator|->
name|lookup
operator|.
name|done
operator|||
operator|(
name|pd
operator|->
name|lookup
operator|.
name|done
operator|=
name|pf_socket_lookup
argument_list|(
name|direction
argument_list|,
name|pd
argument_list|,
name|m
argument_list|)
operator|,
literal|1
operator|)
operator|)
operator|&&
operator|!
name|pf_match_uid
argument_list|(
name|r
operator|->
name|uid
operator|.
name|op
argument_list|,
name|r
operator|->
name|uid
operator|.
name|uid
index|[
literal|0
index|]
argument_list|,
name|r
operator|->
name|uid
operator|.
name|uid
index|[
literal|1
index|]
argument_list|,
name|pd
operator|->
name|lookup
operator|.
name|uid
argument_list|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
comment|/* tcp/udp only. gid.op always 0 in other cases */
elseif|else
if|if
condition|(
name|r
operator|->
name|gid
operator|.
name|op
operator|&&
operator|(
name|pd
operator|->
name|lookup
operator|.
name|done
operator|||
operator|(
name|pd
operator|->
name|lookup
operator|.
name|done
operator|=
name|pf_socket_lookup
argument_list|(
name|direction
argument_list|,
name|pd
argument_list|,
name|m
argument_list|)
operator|,
literal|1
operator|)
operator|)
operator|&&
operator|!
name|pf_match_gid
argument_list|(
name|r
operator|->
name|gid
operator|.
name|op
argument_list|,
name|r
operator|->
name|gid
operator|.
name|gid
index|[
literal|0
index|]
argument_list|,
name|r
operator|->
name|gid
operator|.
name|gid
index|[
literal|1
index|]
argument_list|,
name|pd
operator|->
name|lookup
operator|.
name|gid
argument_list|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|prio
operator|&&
operator|!
name|pf_match_ieee8021q_pcp
argument_list|(
name|r
operator|->
name|prio
argument_list|,
name|m
argument_list|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|prob
operator|&&
name|r
operator|->
name|prob
operator|<=
name|arc4random
argument_list|()
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|match_tag
operator|&&
operator|!
name|pf_match_tag
argument_list|(
name|m
argument_list|,
name|r
argument_list|,
operator|&
name|tag
argument_list|,
name|pd
operator|->
name|pf_mtag
condition|?
name|pd
operator|->
name|pf_mtag
operator|->
name|tag
else|:
literal|0
argument_list|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|os_fingerprint
operator|!=
name|PF_OSFP_ANY
operator|&&
operator|(
name|pd
operator|->
name|proto
operator|!=
name|IPPROTO_TCP
operator|||
operator|!
name|pf_osfp_match
argument_list|(
name|pf_osfp_fingerprint
argument_list|(
name|pd
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|th
argument_list|)
argument_list|,
name|r
operator|->
name|os_fingerprint
argument_list|)
operator|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|r
operator|->
name|tag
condition|)
name|tag
operator|=
name|r
operator|->
name|tag
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|rtableid
operator|>=
literal|0
condition|)
name|rtableid
operator|=
name|r
operator|->
name|rtableid
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|anchor
operator|==
name|NULL
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
operator|*
name|rm
operator|=
name|r
expr_stmt|;
operator|*
name|am
operator|=
name|a
expr_stmt|;
operator|*
name|rsm
operator|=
name|ruleset
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rm
operator|)
operator|->
name|quick
condition|)
break|break;
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
else|else
name|pf_step_into_anchor
argument_list|(
name|anchor_stack
argument_list|,
operator|&
name|asd
argument_list|,
operator|&
name|ruleset
argument_list|,
name|PF_RULESET_FILTER
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|match
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|NULL
operator|&&
name|pf_step_out_of_anchor
argument_list|(
name|anchor_stack
argument_list|,
operator|&
name|asd
argument_list|,
operator|&
name|ruleset
argument_list|,
name|PF_RULESET_FILTER
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|match
argument_list|)
condition|)
break|break;
block|}
name|r
operator|=
operator|*
name|rm
expr_stmt|;
name|a
operator|=
operator|*
name|am
expr_stmt|;
name|ruleset
operator|=
operator|*
name|rsm
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|log
operator|||
operator|(
name|nr
operator|!=
name|NULL
operator|&&
name|nr
operator|->
name|log
operator|)
condition|)
block|{
if|if
condition|(
name|rewrite
condition|)
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|hdrlen
argument_list|,
name|pd
operator|->
name|hdr
operator|.
name|any
argument_list|)
expr_stmt|;
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|m
argument_list|,
name|af
argument_list|,
name|direction
argument_list|,
name|reason
argument_list|,
name|r
operator|->
name|log
condition|?
name|r
else|:
name|nr
argument_list|,
name|a
argument_list|,
name|ruleset
argument_list|,
name|pd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r
operator|->
name|action
operator|==
name|PF_DROP
operator|)
operator|&&
operator|(
operator|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_RETURNRST
operator|)
operator|||
operator|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_RETURNICMP
operator|)
operator|||
operator|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_RETURN
operator|)
operator|)
condition|)
block|{
comment|/* undo NAT changes, if they have taken place */
if|if
condition|(
name|nr
operator|!=
name|NULL
condition|)
block|{
name|PF_ACPY
argument_list|(
name|saddr
argument_list|,
operator|&
name|sk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
name|daddr
argument_list|,
operator|&
name|sk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|sport
condition|)
operator|*
name|pd
operator|->
name|sport
operator|=
name|sk
operator|->
name|port
index|[
name|pd
operator|->
name|sidx
index|]
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|dport
condition|)
operator|*
name|pd
operator|->
name|dport
operator|=
name|sk
operator|->
name|port
index|[
name|pd
operator|->
name|didx
index|]
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|proto_sum
condition|)
operator|*
name|pd
operator|->
name|proto_sum
operator|=
name|bproto_sum
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|ip_sum
condition|)
operator|*
name|pd
operator|->
name|ip_sum
operator|=
name|bip_sum
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|hdrlen
argument_list|,
name|pd
operator|->
name|hdr
operator|.
name|any
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pd
operator|->
name|proto
operator|==
name|IPPROTO_TCP
operator|&&
operator|(
operator|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_RETURNRST
operator|)
operator|||
operator|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_RETURN
operator|)
operator|)
operator|&&
operator|!
operator|(
name|th
operator|->
name|th_flags
operator|&
name|TH_RST
operator|)
condition|)
block|{
name|u_int32_t
name|ack
init|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|+
name|pd
operator|->
name|p_len
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ip
modifier|*
name|h4
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|h6
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|h4
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|len
operator|=
name|ntohs
argument_list|(
name|h4
operator|->
name|ip_len
argument_list|)
operator|-
name|off
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|h6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|len
operator|=
name|ntohs
argument_list|(
name|h6
operator|->
name|ip6_plen
argument_list|)
operator|-
operator|(
name|off
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|h6
argument_list|)
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|pf_check_proto_cksum
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|af
argument_list|)
condition|)
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_PROTCKSUM
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_SYN
condition|)
name|ack
operator|++
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_FIN
condition|)
name|ack
operator|++
expr_stmt|;
name|pf_send_tcp
argument_list|(
name|m
argument_list|,
name|r
argument_list|,
name|af
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|th
operator|->
name|th_dport
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
argument_list|,
name|ack
argument_list|,
name|TH_RST
operator||
name|TH_ACK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|r
operator|->
name|return_ttl
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|kif
operator|->
name|pfik_ifp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pd
operator|->
name|proto
operator|!=
name|IPPROTO_ICMP
operator|&&
name|af
operator|==
name|AF_INET
operator|&&
name|r
operator|->
name|return_icmp
condition|)
name|pf_send_icmp
argument_list|(
name|m
argument_list|,
name|r
operator|->
name|return_icmp
operator|>>
literal|8
argument_list|,
name|r
operator|->
name|return_icmp
operator|&
literal|255
argument_list|,
name|af
argument_list|,
name|r
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pd
operator|->
name|proto
operator|!=
name|IPPROTO_ICMPV6
operator|&&
name|af
operator|==
name|AF_INET6
operator|&&
name|r
operator|->
name|return_icmp6
condition|)
name|pf_send_icmp
argument_list|(
name|m
argument_list|,
name|r
operator|->
name|return_icmp6
operator|>>
literal|8
argument_list|,
name|r
operator|->
name|return_icmp6
operator|&
literal|255
argument_list|,
name|af
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|action
operator|==
name|PF_DROP
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|tag
operator|>
literal|0
operator|&&
name|pf_tag_packet
argument_list|(
name|m
argument_list|,
name|pd
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|rtableid
operator|>=
literal|0
condition|)
name|M_SETFIB
argument_list|(
name|m
argument_list|,
name|rtableid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state_icmp
operator|&&
operator|(
name|r
operator|->
name|keep_state
operator|||
name|nr
operator|!=
name|NULL
operator|||
operator|(
name|pd
operator|->
name|flags
operator|&
name|PFDESC_TCP_NORM
operator|)
operator|)
condition|)
block|{
name|int
name|action
decl_stmt|;
name|action
operator|=
name|pf_create_state
argument_list|(
name|r
argument_list|,
name|nr
argument_list|,
name|a
argument_list|,
name|pd
argument_list|,
name|nsn
argument_list|,
name|nk
argument_list|,
name|sk
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|sport
argument_list|,
name|dport
argument_list|,
operator|&
name|rewrite
argument_list|,
name|kif
argument_list|,
name|sm
argument_list|,
name|tag
argument_list|,
name|bproto_sum
argument_list|,
name|bip_sum
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|!=
name|PF_PASS
condition|)
return|return
operator|(
name|action
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|sk
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|V_pf_state_key_z
argument_list|,
name|sk
argument_list|)
expr_stmt|;
if|if
condition|(
name|nk
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|V_pf_state_key_z
argument_list|,
name|nk
argument_list|)
expr_stmt|;
block|}
comment|/* copy back packet headers if we performed NAT operations */
if|if
condition|(
name|rewrite
condition|)
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|hdrlen
argument_list|,
name|pd
operator|->
name|hdr
operator|.
name|any
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sm
operator|!=
name|NULL
operator|&&
operator|!
operator|(
operator|(
operator|*
name|sm
operator|)
operator|->
name|state_flags
operator|&
name|PFSTATE_NOSYNC
operator|)
operator|&&
name|direction
operator|==
name|PF_OUT
operator|&&
name|pfsync_defer_ptr
operator|!=
name|NULL
operator|&&
name|pfsync_defer_ptr
argument_list|(
operator|*
name|sm
argument_list|,
name|m
argument_list|)
condition|)
comment|/* 		 * We want the state created, but we dont 		 * want to send this in case a partner 		 * firewall has to know about it to allow 		 * replies through it. 		 */
return|return
operator|(
name|PF_DEFER
operator|)
return|;
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|sk
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|V_pf_state_key_z
argument_list|,
name|sk
argument_list|)
expr_stmt|;
if|if
condition|(
name|nk
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|V_pf_state_key_z
argument_list|,
name|nk
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_create_state
parameter_list|(
name|struct
name|pf_rule
modifier|*
name|r
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|nr
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|a
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|struct
name|pf_src_node
modifier|*
name|nsn
parameter_list|,
name|struct
name|pf_state_key
modifier|*
name|nk
parameter_list|,
name|struct
name|pf_state_key
modifier|*
name|sk
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|u_int16_t
name|sport
parameter_list|,
name|u_int16_t
name|dport
parameter_list|,
name|int
modifier|*
name|rewrite
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|struct
name|pf_state
modifier|*
modifier|*
name|sm
parameter_list|,
name|int
name|tag
parameter_list|,
name|u_int16_t
name|bproto_sum
parameter_list|,
name|u_int16_t
name|bip_sum
parameter_list|,
name|int
name|hdrlen
parameter_list|)
block|{
name|struct
name|pf_state
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_src_node
modifier|*
name|sn
init|=
name|NULL
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
name|pd
operator|->
name|hdr
operator|.
name|tcp
decl_stmt|;
name|u_int16_t
name|mss
init|=
name|V_tcp_mssdflt
decl_stmt|;
name|u_short
name|reason
decl_stmt|;
comment|/* check maximums */
if|if
condition|(
name|r
operator|->
name|max_states
operator|&&
operator|(
name|counter_u64_fetch
argument_list|(
name|r
operator|->
name|states_cur
argument_list|)
operator|>=
name|r
operator|->
name|max_states
operator|)
condition|)
block|{
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|lcounters
index|[
name|LCNT_STATES
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MAXSTATES
argument_list|)
expr_stmt|;
goto|goto
name|csfailed
goto|;
block|}
comment|/* src node for filter rule */
if|if
condition|(
operator|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_SRCTRACK
operator|||
name|r
operator|->
name|rpool
operator|.
name|opts
operator|&
name|PF_POOL_STICKYADDR
operator|)
operator|&&
name|pf_insert_src_node
argument_list|(
operator|&
name|sn
argument_list|,
name|r
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|pd
operator|->
name|af
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_SRCLIMIT
argument_list|)
expr_stmt|;
goto|goto
name|csfailed
goto|;
block|}
comment|/* src node for translation rule */
if|if
condition|(
name|nr
operator|!=
name|NULL
operator|&&
operator|(
name|nr
operator|->
name|rpool
operator|.
name|opts
operator|&
name|PF_POOL_STICKYADDR
operator|)
operator|&&
name|pf_insert_src_node
argument_list|(
operator|&
name|nsn
argument_list|,
name|nr
argument_list|,
operator|&
name|sk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|pd
operator|->
name|af
argument_list|)
condition|)
block|{
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_SRCLIMIT
argument_list|)
expr_stmt|;
goto|goto
name|csfailed
goto|;
block|}
name|s
operator|=
name|uma_zalloc
argument_list|(
name|V_pf_state_z
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
goto|goto
name|csfailed
goto|;
block|}
name|s
operator|->
name|rule
operator|.
name|ptr
operator|=
name|r
expr_stmt|;
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|=
name|nr
expr_stmt|;
name|s
operator|->
name|anchor
operator|.
name|ptr
operator|=
name|a
expr_stmt|;
name|STATE_INC_COUNTERS
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|allow_opts
condition|)
name|s
operator|->
name|state_flags
operator||=
name|PFSTATE_ALLOWOPTS
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_STATESLOPPY
condition|)
name|s
operator|->
name|state_flags
operator||=
name|PFSTATE_SLOPPY
expr_stmt|;
name|s
operator|->
name|log
operator|=
name|r
operator|->
name|log
operator|&
name|PF_LOG_ALL
expr_stmt|;
name|s
operator|->
name|sync_state
operator|=
name|PFSYNC_S_NONE
expr_stmt|;
if|if
condition|(
name|nr
operator|!=
name|NULL
condition|)
name|s
operator|->
name|log
operator||=
name|nr
operator|->
name|log
operator|&
name|PF_LOG_ALL
expr_stmt|;
switch|switch
condition|(
name|pd
operator|->
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|s
operator|->
name|src
operator|.
name|seqlo
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|s
operator|->
name|src
operator|.
name|seqhi
operator|=
name|s
operator|->
name|src
operator|.
name|seqlo
operator|+
name|pd
operator|->
name|p_len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_SYN
operator|&&
name|r
operator|->
name|keep_state
operator|==
name|PF_STATE_MODULATE
condition|)
block|{
comment|/* Generate sequence number modulator */
if|if
condition|(
operator|(
name|s
operator|->
name|src
operator|.
name|seqdiff
operator|=
name|pf_tcp_iss
argument_list|(
name|pd
argument_list|)
operator|-
name|s
operator|->
name|src
operator|.
name|seqlo
operator|)
operator|==
literal|0
condition|)
name|s
operator|->
name|src
operator|.
name|seqdiff
operator|=
literal|1
expr_stmt|;
name|pf_change_proto_a
argument_list|(
name|m
argument_list|,
operator|&
name|th
operator|->
name|th_seq
argument_list|,
operator|&
name|th
operator|->
name|th_sum
argument_list|,
name|htonl
argument_list|(
name|s
operator|->
name|src
operator|.
name|seqlo
operator|+
name|s
operator|->
name|src
operator|.
name|seqdiff
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|rewrite
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|s
operator|->
name|src
operator|.
name|seqdiff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_SYN
condition|)
block|{
name|s
operator|->
name|src
operator|.
name|seqhi
operator|++
expr_stmt|;
name|s
operator|->
name|src
operator|.
name|wscale
operator|=
name|pf_get_wscale
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|th
operator|->
name|th_off
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|src
operator|.
name|max_win
operator|=
name|MAX
argument_list|(
name|ntohs
argument_list|(
name|th
operator|->
name|th_win
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|src
operator|.
name|wscale
operator|&
name|PF_WSCALE_MASK
condition|)
block|{
comment|/* Remove scale factor from initial window */
name|int
name|win
init|=
name|s
operator|->
name|src
operator|.
name|max_win
decl_stmt|;
name|win
operator|+=
literal|1
operator|<<
operator|(
name|s
operator|->
name|src
operator|.
name|wscale
operator|&
name|PF_WSCALE_MASK
operator|)
expr_stmt|;
name|s
operator|->
name|src
operator|.
name|max_win
operator|=
operator|(
name|win
operator|-
literal|1
operator|)
operator|>>
operator|(
name|s
operator|->
name|src
operator|.
name|wscale
operator|&
name|PF_WSCALE_MASK
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_FIN
condition|)
name|s
operator|->
name|src
operator|.
name|seqhi
operator|++
expr_stmt|;
name|s
operator|->
name|dst
operator|.
name|seqhi
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|dst
operator|.
name|max_win
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|src
operator|.
name|state
operator|=
name|TCPS_SYN_SENT
expr_stmt|;
name|s
operator|->
name|dst
operator|.
name|state
operator|=
name|TCPS_CLOSED
expr_stmt|;
name|s
operator|->
name|timeout
operator|=
name|PFTM_TCP_FIRST_PACKET
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|s
operator|->
name|src
operator|.
name|state
operator|=
name|PFUDPS_SINGLE
expr_stmt|;
name|s
operator|->
name|dst
operator|.
name|state
operator|=
name|PFUDPS_NO_TRAFFIC
expr_stmt|;
name|s
operator|->
name|timeout
operator|=
name|PFTM_UDP_FIRST_PACKET
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPPROTO_ICMPV6
case|:
endif|#
directive|endif
name|s
operator|->
name|timeout
operator|=
name|PFTM_ICMP_FIRST_PACKET
expr_stmt|;
break|break;
default|default:
name|s
operator|->
name|src
operator|.
name|state
operator|=
name|PFOTHERS_SINGLE
expr_stmt|;
name|s
operator|->
name|dst
operator|.
name|state
operator|=
name|PFOTHERS_NO_TRAFFIC
expr_stmt|;
name|s
operator|->
name|timeout
operator|=
name|PFTM_OTHER_FIRST_PACKET
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|rt
operator|&&
name|r
operator|->
name|rt
operator|!=
name|PF_FASTROUTE
condition|)
block|{
if|if
condition|(
name|pf_map_addr
argument_list|(
name|pd
operator|->
name|af
argument_list|,
name|r
argument_list|,
name|pd
operator|->
name|src
argument_list|,
operator|&
name|s
operator|->
name|rt_addr
argument_list|,
name|NULL
argument_list|,
operator|&
name|sn
argument_list|)
condition|)
block|{
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MAPFAILED
argument_list|)
expr_stmt|;
name|pf_src_tree_remove_state
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|STATE_DEC_COUNTERS
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_state_z
argument_list|,
name|s
argument_list|)
expr_stmt|;
goto|goto
name|csfailed
goto|;
block|}
name|s
operator|->
name|rt_kif
operator|=
name|r
operator|->
name|rpool
operator|.
name|cur
operator|->
name|kif
expr_stmt|;
block|}
name|s
operator|->
name|creation
operator|=
name|time_uptime
expr_stmt|;
name|s
operator|->
name|expire
operator|=
name|time_uptime
expr_stmt|;
if|if
condition|(
name|sn
operator|!=
name|NULL
condition|)
name|s
operator|->
name|src_node
operator|=
name|sn
expr_stmt|;
if|if
condition|(
name|nsn
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX We only modify one side for now. */
name|PF_ACPY
argument_list|(
operator|&
name|nsn
operator|->
name|raddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
literal|1
index|]
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
name|s
operator|->
name|nat_src_node
operator|=
name|nsn
expr_stmt|;
block|}
if|if
condition|(
name|pd
operator|->
name|proto
operator|==
name|IPPROTO_TCP
condition|)
block|{
if|if
condition|(
operator|(
name|pd
operator|->
name|flags
operator|&
name|PFDESC_TCP_NORM
operator|)
operator|&&
name|pf_normalize_tcp_init
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|pd
argument_list|,
name|th
argument_list|,
operator|&
name|s
operator|->
name|src
argument_list|,
operator|&
name|s
operator|->
name|dst
argument_list|)
condition|)
block|{
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
name|pf_src_tree_remove_state
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|STATE_DEC_COUNTERS
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_state_z
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|pd
operator|->
name|flags
operator|&
name|PFDESC_TCP_NORM
operator|)
operator|&&
name|s
operator|->
name|src
operator|.
name|scrub
operator|&&
name|pf_normalize_tcp_stateful
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|pd
argument_list|,
operator|&
name|reason
argument_list|,
name|th
argument_list|,
name|s
argument_list|,
operator|&
name|s
operator|->
name|src
argument_list|,
operator|&
name|s
operator|->
name|dst
argument_list|,
name|rewrite
argument_list|)
condition|)
block|{
comment|/* This really shouldn't happen!!! */
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_URGENT
argument_list|,
operator|(
literal|"pf_normalize_tcp_stateful failed on first pkt"
operator|)
argument_list|)
expr_stmt|;
name|pf_normalize_tcp_cleanup
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pf_src_tree_remove_state
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|STATE_DEC_COUNTERS
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_state_z
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
block|}
name|s
operator|->
name|direction
operator|=
name|pd
operator|->
name|dir
expr_stmt|;
comment|/* 	 * sk/nk could already been setup by pf_get_translation(). 	 */
if|if
condition|(
name|nr
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|sk
operator|==
name|NULL
operator|&&
name|nk
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"%s: nr %p sk %p, nk %p"
operator|,
name|__func__
operator|,
name|nr
operator|,
name|sk
operator|,
name|nk
operator|)
argument_list|)
expr_stmt|;
name|sk
operator|=
name|pf_state_key_setup
argument_list|(
name|pd
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|sport
argument_list|,
name|dport
argument_list|)
expr_stmt|;
if|if
condition|(
name|sk
operator|==
name|NULL
condition|)
goto|goto
name|csfailed
goto|;
name|nk
operator|=
name|sk
expr_stmt|;
block|}
else|else
name|KASSERT
argument_list|(
operator|(
name|sk
operator|!=
name|NULL
operator|&&
name|nk
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"%s: nr %p sk %p, nk %p"
operator|,
name|__func__
operator|,
name|nr
operator|,
name|sk
operator|,
name|nk
operator|)
argument_list|)
expr_stmt|;
comment|/* Swap sk/nk for PF_OUT. */
if|if
condition|(
name|pf_state_insert
argument_list|(
name|BOUND_IFACE
argument_list|(
name|r
argument_list|,
name|kif
argument_list|)
argument_list|,
operator|(
name|pd
operator|->
name|dir
operator|==
name|PF_IN
operator|)
condition|?
name|sk
else|:
name|nk
argument_list|,
operator|(
name|pd
operator|->
name|dir
operator|==
name|PF_IN
operator|)
condition|?
name|nk
else|:
name|sk
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|pd
operator|->
name|proto
operator|==
name|IPPROTO_TCP
condition|)
name|pf_normalize_tcp_cleanup
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_STATEINS
argument_list|)
expr_stmt|;
name|pf_src_tree_remove_state
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|STATE_DEC_COUNTERS
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_state_z
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
else|else
operator|*
name|sm
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|tag
operator|>
literal|0
condition|)
name|s
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|proto
operator|==
name|IPPROTO_TCP
operator|&&
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_SYN
operator|&&
name|r
operator|->
name|keep_state
operator|==
name|PF_STATE_SYNPROXY
condition|)
block|{
name|s
operator|->
name|src
operator|.
name|state
operator|=
name|PF_TCPS_PROXY_SRC
expr_stmt|;
comment|/* undo NAT changes, if they have taken place */
if|if
condition|(
name|nr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|pf_state_key
modifier|*
name|skt
init|=
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
decl_stmt|;
if|if
condition|(
name|pd
operator|->
name|dir
operator|==
name|PF_OUT
condition|)
name|skt
operator|=
name|s
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
expr_stmt|;
name|PF_ACPY
argument_list|(
name|pd
operator|->
name|src
argument_list|,
operator|&
name|skt
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
name|pd
operator|->
name|dst
argument_list|,
operator|&
name|skt
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|sport
condition|)
operator|*
name|pd
operator|->
name|sport
operator|=
name|skt
operator|->
name|port
index|[
name|pd
operator|->
name|sidx
index|]
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|dport
condition|)
operator|*
name|pd
operator|->
name|dport
operator|=
name|skt
operator|->
name|port
index|[
name|pd
operator|->
name|didx
index|]
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|proto_sum
condition|)
operator|*
name|pd
operator|->
name|proto_sum
operator|=
name|bproto_sum
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|ip_sum
condition|)
operator|*
name|pd
operator|->
name|ip_sum
operator|=
name|bip_sum
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|hdrlen
argument_list|,
name|pd
operator|->
name|hdr
operator|.
name|any
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|src
operator|.
name|seqhi
operator|=
name|htonl
argument_list|(
name|arc4random
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Find mss option */
name|int
name|rtid
init|=
name|M_GETFIB
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|mss
operator|=
name|pf_get_mss
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|th
operator|->
name|th_off
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
name|mss
operator|=
name|pf_calc_mss
argument_list|(
name|pd
operator|->
name|src
argument_list|,
name|pd
operator|->
name|af
argument_list|,
name|rtid
argument_list|,
name|mss
argument_list|)
expr_stmt|;
name|mss
operator|=
name|pf_calc_mss
argument_list|(
name|pd
operator|->
name|dst
argument_list|,
name|pd
operator|->
name|af
argument_list|,
name|rtid
argument_list|,
name|mss
argument_list|)
expr_stmt|;
name|s
operator|->
name|src
operator|.
name|mss
operator|=
name|mss
expr_stmt|;
name|pf_send_tcp
argument_list|(
name|NULL
argument_list|,
name|r
argument_list|,
name|pd
operator|->
name|af
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|th
operator|->
name|th_dport
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
name|s
operator|->
name|src
operator|.
name|seqhi
argument_list|,
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|+
literal|1
argument_list|,
name|TH_SYN
operator||
name|TH_ACK
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|src
operator|.
name|mss
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_SYNPROXY
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_SYNPROXY_DROP
operator|)
return|;
block|}
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|csfailed
label|:
if|if
condition|(
name|sk
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|V_pf_state_key_z
argument_list|,
name|sk
argument_list|)
expr_stmt|;
if|if
condition|(
name|nk
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|V_pf_state_key_z
argument_list|,
name|nk
argument_list|)
expr_stmt|;
if|if
condition|(
name|sn
operator|!=
name|NULL
condition|)
block|{
name|struct
name|pf_srchash
modifier|*
name|sh
decl_stmt|;
name|sh
operator|=
operator|&
name|V_pf_srchash
index|[
name|pf_hashsrc
argument_list|(
operator|&
name|sn
operator|->
name|addr
argument_list|,
name|sn
operator|->
name|af
argument_list|)
index|]
expr_stmt|;
name|PF_HASHROW_LOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sn
operator|->
name|states
operator|==
literal|0
operator|&&
name|sn
operator|->
name|expire
operator|==
literal|0
condition|)
block|{
name|pf_unlink_src_node
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_sources_z
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|scounters
index|[
name|SCNT_SRC_NODE_REMOVALS
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|PF_HASHROW_UNLOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nsn
operator|!=
name|sn
operator|&&
name|nsn
operator|!=
name|NULL
condition|)
block|{
name|struct
name|pf_srchash
modifier|*
name|sh
decl_stmt|;
name|sh
operator|=
operator|&
name|V_pf_srchash
index|[
name|pf_hashsrc
argument_list|(
operator|&
name|nsn
operator|->
name|addr
argument_list|,
name|nsn
operator|->
name|af
argument_list|)
index|]
expr_stmt|;
name|PF_HASHROW_LOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|nsn
operator|->
name|states
operator|==
literal|0
operator|&&
name|nsn
operator|->
name|expire
operator|==
literal|0
condition|)
block|{
name|pf_unlink_src_node
argument_list|(
name|nsn
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_sources_z
argument_list|,
name|nsn
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|V_pf_status
operator|.
name|scounters
index|[
name|SCNT_SRC_NODE_REMOVALS
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|PF_HASHROW_UNLOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_test_fragment
parameter_list|(
name|struct
name|pf_rule
modifier|*
modifier|*
name|rm
parameter_list|,
name|int
name|direction
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|h
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|struct
name|pf_rule
modifier|*
modifier|*
name|am
parameter_list|,
name|struct
name|pf_ruleset
modifier|*
modifier|*
name|rsm
parameter_list|)
block|{
name|struct
name|pf_rule
modifier|*
name|r
decl_stmt|,
modifier|*
name|a
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
init|=
name|NULL
decl_stmt|;
name|sa_family_t
name|af
init|=
name|pd
operator|->
name|af
decl_stmt|;
name|u_short
name|reason
decl_stmt|;
name|int
name|tag
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|asd
init|=
literal|0
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
name|struct
name|pf_anchor_stackframe
name|anchor_stack
index|[
name|PF_ANCHOR_STACKSIZE
index|]
decl_stmt|;
name|PF_RULES_RASSERT
argument_list|()
expr_stmt|;
name|r
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_main_ruleset
operator|.
name|rules
index|[
name|PF_RULESET_FILTER
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
name|r
operator|->
name|evaluations
operator|++
expr_stmt|;
if|if
condition|(
name|pfi_kif_match
argument_list|(
name|r
operator|->
name|kif
argument_list|,
name|kif
argument_list|)
operator|==
name|r
operator|->
name|ifnot
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_IFP
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|direction
operator|&&
name|r
operator|->
name|direction
operator|!=
name|direction
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DIR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|af
operator|&&
name|r
operator|->
name|af
operator|!=
name|af
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_AF
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|proto
operator|&&
name|r
operator|->
name|proto
operator|!=
name|pd
operator|->
name|proto
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_PROTO
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|src
operator|.
name|addr
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|af
argument_list|,
name|r
operator|->
name|src
operator|.
name|neg
argument_list|,
name|kif
argument_list|,
name|M_GETFIB
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_SRC_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|dst
operator|.
name|addr
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|af
argument_list|,
name|r
operator|->
name|dst
operator|.
name|neg
argument_list|,
name|NULL
argument_list|,
name|M_GETFIB
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DST_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|tos
operator|&&
operator|!
operator|(
name|r
operator|->
name|tos
operator|==
name|pd
operator|->
name|tos
operator|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|os_fingerprint
operator|!=
name|PF_OSFP_ANY
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pd
operator|->
name|proto
operator|==
name|IPPROTO_UDP
operator|&&
operator|(
name|r
operator|->
name|src
operator|.
name|port_op
operator|||
name|r
operator|->
name|dst
operator|.
name|port_op
operator|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pd
operator|->
name|proto
operator|==
name|IPPROTO_TCP
operator|&&
operator|(
name|r
operator|->
name|src
operator|.
name|port_op
operator|||
name|r
operator|->
name|dst
operator|.
name|port_op
operator|||
name|r
operator|->
name|flagset
operator|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pd
operator|->
name|proto
operator|==
name|IPPROTO_ICMP
operator|||
name|pd
operator|->
name|proto
operator|==
name|IPPROTO_ICMPV6
operator|)
operator|&&
operator|(
name|r
operator|->
name|type
operator|||
name|r
operator|->
name|code
operator|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|prio
operator|&&
operator|!
name|pf_match_ieee8021q_pcp
argument_list|(
name|r
operator|->
name|prio
argument_list|,
name|m
argument_list|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|prob
operator|&&
name|r
operator|->
name|prob
operator|<=
operator|(
name|arc4random
argument_list|()
operator|%
operator|(
name|UINT_MAX
operator|-
literal|1
operator|)
operator|+
literal|1
operator|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|match_tag
operator|&&
operator|!
name|pf_match_tag
argument_list|(
name|m
argument_list|,
name|r
argument_list|,
operator|&
name|tag
argument_list|,
name|pd
operator|->
name|pf_mtag
condition|?
name|pd
operator|->
name|pf_mtag
operator|->
name|tag
else|:
literal|0
argument_list|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|r
operator|->
name|anchor
operator|==
name|NULL
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
operator|*
name|rm
operator|=
name|r
expr_stmt|;
operator|*
name|am
operator|=
name|a
expr_stmt|;
operator|*
name|rsm
operator|=
name|ruleset
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rm
operator|)
operator|->
name|quick
condition|)
break|break;
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
else|else
name|pf_step_into_anchor
argument_list|(
name|anchor_stack
argument_list|,
operator|&
name|asd
argument_list|,
operator|&
name|ruleset
argument_list|,
name|PF_RULESET_FILTER
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|match
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|NULL
operator|&&
name|pf_step_out_of_anchor
argument_list|(
name|anchor_stack
argument_list|,
operator|&
name|asd
argument_list|,
operator|&
name|ruleset
argument_list|,
name|PF_RULESET_FILTER
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|match
argument_list|)
condition|)
break|break;
block|}
name|r
operator|=
operator|*
name|rm
expr_stmt|;
name|a
operator|=
operator|*
name|am
expr_stmt|;
name|ruleset
operator|=
operator|*
name|rsm
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|log
condition|)
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|m
argument_list|,
name|af
argument_list|,
name|direction
argument_list|,
name|reason
argument_list|,
name|r
argument_list|,
name|a
argument_list|,
name|ruleset
argument_list|,
name|pd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|action
operator|!=
name|PF_PASS
condition|)
return|return
operator|(
name|PF_DROP
operator|)
return|;
if|if
condition|(
name|tag
operator|>
literal|0
operator|&&
name|pf_tag_packet
argument_list|(
name|m
argument_list|,
name|pd
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
return|return
operator|(
name|PF_PASS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_tcp_track_full
parameter_list|(
name|struct
name|pf_state_peer
modifier|*
name|src
parameter_list|,
name|struct
name|pf_state_peer
modifier|*
name|dst
parameter_list|,
name|struct
name|pf_state
modifier|*
modifier|*
name|state
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|u_short
modifier|*
name|reason
parameter_list|,
name|int
modifier|*
name|copyback
parameter_list|)
block|{
name|struct
name|tcphdr
modifier|*
name|th
init|=
name|pd
operator|->
name|hdr
operator|.
name|tcp
decl_stmt|;
name|u_int16_t
name|win
init|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_win
argument_list|)
decl_stmt|;
name|u_int32_t
name|ack
decl_stmt|,
name|end
decl_stmt|,
name|seq
decl_stmt|,
name|orig_seq
decl_stmt|;
name|u_int8_t
name|sws
decl_stmt|,
name|dws
decl_stmt|;
name|int
name|ackskew
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|wscale
operator|&&
name|dst
operator|->
name|wscale
operator|&&
operator|!
operator|(
name|th
operator|->
name|th_flags
operator|&
name|TH_SYN
operator|)
condition|)
block|{
name|sws
operator|=
name|src
operator|->
name|wscale
operator|&
name|PF_WSCALE_MASK
expr_stmt|;
name|dws
operator|=
name|dst
operator|->
name|wscale
operator|&
name|PF_WSCALE_MASK
expr_stmt|;
block|}
else|else
name|sws
operator|=
name|dws
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Sequence tracking algorithm from Guido van Rooij's paper: 	 *   http://www.madison-gurkha.com/publications/tcp_filtering/ 	 *	tcp_filtering.ps 	 */
name|orig_seq
operator|=
name|seq
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|seqlo
operator|==
literal|0
condition|)
block|{
comment|/* First packet from this end. Set its state */
if|if
condition|(
operator|(
name|pd
operator|->
name|flags
operator|&
name|PFDESC_TCP_NORM
operator|||
name|dst
operator|->
name|scrub
operator|)
operator|&&
name|src
operator|->
name|scrub
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|pf_normalize_tcp_init
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|pd
argument_list|,
name|th
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
condition|)
block|{
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
block|}
comment|/* Deferred generation of sequence number modulator */
if|if
condition|(
name|dst
operator|->
name|seqdiff
operator|&&
operator|!
name|src
operator|->
name|seqdiff
condition|)
block|{
comment|/* use random iss for the TCP server */
while|while
condition|(
operator|(
name|src
operator|->
name|seqdiff
operator|=
name|arc4random
argument_list|()
operator|-
name|seq
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|ack
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
operator|-
name|dst
operator|->
name|seqdiff
expr_stmt|;
name|pf_change_proto_a
argument_list|(
name|m
argument_list|,
operator|&
name|th
operator|->
name|th_seq
argument_list|,
operator|&
name|th
operator|->
name|th_sum
argument_list|,
name|htonl
argument_list|(
name|seq
operator|+
name|src
operator|->
name|seqdiff
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pf_change_proto_a
argument_list|(
name|m
argument_list|,
operator|&
name|th
operator|->
name|th_ack
argument_list|,
operator|&
name|th
operator|->
name|th_sum
argument_list|,
name|htonl
argument_list|(
name|ack
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|copyback
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ack
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
expr_stmt|;
block|}
name|end
operator|=
name|seq
operator|+
name|pd
operator|->
name|p_len
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_SYN
condition|)
block|{
name|end
operator|++
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|wscale
operator|&
name|PF_WSCALE_FLAG
condition|)
block|{
name|src
operator|->
name|wscale
operator|=
name|pf_get_wscale
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|th
operator|->
name|th_off
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|wscale
operator|&
name|PF_WSCALE_FLAG
condition|)
block|{
comment|/* Remove scale factor from initial 					 * window */
name|sws
operator|=
name|src
operator|->
name|wscale
operator|&
name|PF_WSCALE_MASK
expr_stmt|;
name|win
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
name|win
operator|+
operator|(
literal|1
operator|<<
name|sws
operator|)
operator|-
literal|1
operator|)
operator|>>
name|sws
expr_stmt|;
name|dws
operator|=
name|dst
operator|->
name|wscale
operator|&
name|PF_WSCALE_MASK
expr_stmt|;
block|}
else|else
block|{
comment|/* fixup other window */
name|dst
operator|->
name|max_win
operator|<<=
name|dst
operator|->
name|wscale
operator|&
name|PF_WSCALE_MASK
expr_stmt|;
comment|/* in case of a retrans SYN|ACK */
name|dst
operator|->
name|wscale
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_FIN
condition|)
name|end
operator|++
expr_stmt|;
name|src
operator|->
name|seqlo
operator|=
name|seq
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|state
operator|<
name|TCPS_SYN_SENT
condition|)
name|src
operator|->
name|state
operator|=
name|TCPS_SYN_SENT
expr_stmt|;
comment|/* 		 * May need to slide the window (seqhi may have been set by 		 * the crappy stack check or if we picked up the connection 		 * after establishment) 		 */
if|if
condition|(
name|src
operator|->
name|seqhi
operator|==
literal|1
operator|||
name|SEQ_GEQ
argument_list|(
name|end
operator|+
name|MAX
argument_list|(
literal|1
argument_list|,
name|dst
operator|->
name|max_win
operator|<<
name|dws
argument_list|)
argument_list|,
name|src
operator|->
name|seqhi
argument_list|)
condition|)
name|src
operator|->
name|seqhi
operator|=
name|end
operator|+
name|MAX
argument_list|(
literal|1
argument_list|,
name|dst
operator|->
name|max_win
operator|<<
name|dws
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|>
name|src
operator|->
name|max_win
condition|)
name|src
operator|->
name|max_win
operator|=
name|win
expr_stmt|;
block|}
else|else
block|{
name|ack
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
operator|-
name|dst
operator|->
name|seqdiff
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|seqdiff
condition|)
block|{
comment|/* Modulate sequence numbers */
name|pf_change_proto_a
argument_list|(
name|m
argument_list|,
operator|&
name|th
operator|->
name|th_seq
argument_list|,
operator|&
name|th
operator|->
name|th_sum
argument_list|,
name|htonl
argument_list|(
name|seq
operator|+
name|src
operator|->
name|seqdiff
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pf_change_proto_a
argument_list|(
name|m
argument_list|,
operator|&
name|th
operator|->
name|th_ack
argument_list|,
operator|&
name|th
operator|->
name|th_sum
argument_list|,
name|htonl
argument_list|(
name|ack
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|copyback
operator|=
literal|1
expr_stmt|;
block|}
name|end
operator|=
name|seq
operator|+
name|pd
operator|->
name|p_len
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_SYN
condition|)
name|end
operator|++
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_FIN
condition|)
name|end
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|th
operator|->
name|th_flags
operator|&
name|TH_ACK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Let it pass through the ack skew check */
name|ack
operator|=
name|dst
operator|->
name|seqlo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ack
operator|==
literal|0
operator|&&
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_ACK
operator||
name|TH_RST
operator|)
operator|)
operator|==
operator|(
name|TH_ACK
operator||
name|TH_RST
operator|)
operator|)
operator|||
comment|/* broken tcp stacks do not set ack */
operator|(
name|dst
operator|->
name|state
operator|<
name|TCPS_SYN_SENT
operator|)
condition|)
block|{
comment|/* 		 * Many stacks (ours included) will set the ACK number in an 		 * FIN|ACK if the SYN times out -- no sequence to ACK. 		 */
name|ack
operator|=
name|dst
operator|->
name|seqlo
expr_stmt|;
block|}
if|if
condition|(
name|seq
operator|==
name|end
condition|)
block|{
comment|/* Ease sequencing restrictions on no data packets */
name|seq
operator|=
name|src
operator|->
name|seqlo
expr_stmt|;
name|end
operator|=
name|seq
expr_stmt|;
block|}
name|ackskew
operator|=
name|dst
operator|->
name|seqlo
operator|-
name|ack
expr_stmt|;
comment|/* 	 * Need to demodulate the sequence numbers in any TCP SACK options 	 * (Selective ACK). We could optionally validate the SACK values 	 * against the current ACK window, either forwards or backwards, but 	 * I'm not confident that SACK has been implemented properly 	 * everywhere. It wouldn't surprise me if several stacks accidentally 	 * SACK too far backwards of previously ACKed data. There really aren't 	 * any security implications of bad SACKing unless the target stack 	 * doesn't validate the option length correctly. Someone trying to 	 * spoof into a TCP connection won't bother blindly sending SACK 	 * options anyway. 	 */
if|if
condition|(
name|dst
operator|->
name|seqdiff
operator|&&
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|pf_modulate_sack
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|pd
argument_list|,
name|th
argument_list|,
name|dst
argument_list|)
condition|)
operator|*
name|copyback
operator|=
literal|1
expr_stmt|;
block|}
define|#
directive|define
name|MAXACKWINDOW
value|(0xffff + 1500)
comment|/* 1500 is an arbitrary fudge factor */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|src
operator|->
name|seqhi
argument_list|,
name|end
argument_list|)
operator|&&
comment|/* Last octet inside other's window space */
name|SEQ_GEQ
argument_list|(
name|seq
argument_list|,
name|src
operator|->
name|seqlo
operator|-
operator|(
name|dst
operator|->
name|max_win
operator|<<
name|dws
operator|)
argument_list|)
operator|&&
comment|/* Retrans: not more than one window back */
operator|(
name|ackskew
operator|>=
operator|-
name|MAXACKWINDOW
operator|)
operator|&&
comment|/* Acking not more than one reassembled fragment backwards */
operator|(
name|ackskew
operator|<=
operator|(
name|MAXACKWINDOW
operator|<<
name|sws
operator|)
operator|)
operator|&&
comment|/* Acking not more than one window forward */
operator|(
operator|(
name|th
operator|->
name|th_flags
operator|&
name|TH_RST
operator|)
operator|==
literal|0
operator|||
name|orig_seq
operator|==
name|src
operator|->
name|seqlo
operator|||
operator|(
name|orig_seq
operator|==
name|src
operator|->
name|seqlo
operator|+
literal|1
operator|)
operator|||
operator|(
name|orig_seq
operator|+
literal|1
operator|==
name|src
operator|->
name|seqlo
operator|)
operator|||
operator|(
name|pd
operator|->
name|flags
operator|&
name|PFDESC_IP_REAS
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Require an exact/+1 sequence match on resets when possible */
if|if
condition|(
name|dst
operator|->
name|scrub
operator|||
name|src
operator|->
name|scrub
condition|)
block|{
if|if
condition|(
name|pf_normalize_tcp_stateful
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|pd
argument_list|,
name|reason
argument_list|,
name|th
argument_list|,
operator|*
name|state
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|copyback
argument_list|)
condition|)
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
comment|/* update max window */
if|if
condition|(
name|src
operator|->
name|max_win
operator|<
name|win
condition|)
name|src
operator|->
name|max_win
operator|=
name|win
expr_stmt|;
comment|/* synchronize sequencing */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|end
argument_list|,
name|src
operator|->
name|seqlo
argument_list|)
condition|)
name|src
operator|->
name|seqlo
operator|=
name|end
expr_stmt|;
comment|/* slide the window of what the other end can send */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|ack
operator|+
operator|(
name|win
operator|<<
name|sws
operator|)
argument_list|,
name|dst
operator|->
name|seqhi
argument_list|)
condition|)
name|dst
operator|->
name|seqhi
operator|=
name|ack
operator|+
name|MAX
argument_list|(
operator|(
name|win
operator|<<
name|sws
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* update states */
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_SYN
condition|)
if|if
condition|(
name|src
operator|->
name|state
operator|<
name|TCPS_SYN_SENT
condition|)
name|src
operator|->
name|state
operator|=
name|TCPS_SYN_SENT
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_FIN
condition|)
if|if
condition|(
name|src
operator|->
name|state
operator|<
name|TCPS_CLOSING
condition|)
name|src
operator|->
name|state
operator|=
name|TCPS_CLOSING
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_ACK
condition|)
block|{
if|if
condition|(
name|dst
operator|->
name|state
operator|==
name|TCPS_SYN_SENT
condition|)
block|{
name|dst
operator|->
name|state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|state
operator|==
name|TCPS_ESTABLISHED
operator|&&
operator|(
operator|*
name|state
operator|)
operator|->
name|src_node
operator|!=
name|NULL
operator|&&
name|pf_src_connlimit
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SRCLIMIT
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|dst
operator|->
name|state
operator|==
name|TCPS_CLOSING
condition|)
name|dst
operator|->
name|state
operator|=
name|TCPS_FIN_WAIT_2
expr_stmt|;
block|}
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_RST
condition|)
name|src
operator|->
name|state
operator|=
name|dst
operator|->
name|state
operator|=
name|TCPS_TIME_WAIT
expr_stmt|;
comment|/* update expire time */
operator|(
operator|*
name|state
operator|)
operator|->
name|expire
operator|=
name|time_uptime
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|state
operator|>=
name|TCPS_FIN_WAIT_2
operator|&&
name|dst
operator|->
name|state
operator|>=
name|TCPS_FIN_WAIT_2
condition|)
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_TCP_CLOSED
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|->
name|state
operator|>=
name|TCPS_CLOSING
operator|&&
name|dst
operator|->
name|state
operator|>=
name|TCPS_CLOSING
condition|)
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_TCP_FIN_WAIT
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|->
name|state
operator|<
name|TCPS_ESTABLISHED
operator|||
name|dst
operator|->
name|state
operator|<
name|TCPS_ESTABLISHED
condition|)
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_TCP_OPENING
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|->
name|state
operator|>=
name|TCPS_CLOSING
operator|||
name|dst
operator|->
name|state
operator|>=
name|TCPS_CLOSING
condition|)
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_TCP_CLOSING
expr_stmt|;
else|else
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_TCP_ESTABLISHED
expr_stmt|;
comment|/* Fall through to PASS packet */
block|}
elseif|else
if|if
condition|(
operator|(
name|dst
operator|->
name|state
operator|<
name|TCPS_SYN_SENT
operator|||
name|dst
operator|->
name|state
operator|>=
name|TCPS_FIN_WAIT_2
operator|||
name|src
operator|->
name|state
operator|>=
name|TCPS_FIN_WAIT_2
operator|)
operator|&&
name|SEQ_GEQ
argument_list|(
name|src
operator|->
name|seqhi
operator|+
name|MAXACKWINDOW
argument_list|,
name|end
argument_list|)
operator|&&
comment|/* Within a window forward of the originating packet */
name|SEQ_GEQ
argument_list|(
name|seq
argument_list|,
name|src
operator|->
name|seqlo
operator|-
name|MAXACKWINDOW
argument_list|)
condition|)
block|{
comment|/* Within a window backward of the originating packet */
comment|/* 		 * This currently handles three situations: 		 *  1) Stupid stacks will shotgun SYNs before their peer 		 *     replies. 		 *  2) When PF catches an already established stream (the 		 *     firewall rebooted, the state table was flushed, routes 		 *     changed...) 		 *  3) Packets get funky immediately after the connection 		 *     closes (this should catch Solaris spurious ACK|FINs 		 *     that web servers like to spew after a close) 		 * 		 * This must be a little more careful than the above code 		 * since packet floods will also be caught here. We don't 		 * update the TTL here to mitigate the damage of a packet 		 * flood and so the same code can handle awkward establishment 		 * and a loosened connection close. 		 * In the establishment case, a correct peer response will 		 * validate the connection, go through the normal state code 		 * and keep updating the state TTL. 		 */
if|if
condition|(
name|V_pf_status
operator|.
name|debug
operator|>=
name|PF_DEBUG_MISC
condition|)
block|{
name|printf
argument_list|(
literal|"pf: loose state match: "
argument_list|)
expr_stmt|;
name|pf_print_state
argument_list|(
operator|*
name|state
argument_list|)
expr_stmt|;
name|pf_print_flags
argument_list|(
name|th
operator|->
name|th_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" seq=%u (%u) ack=%u len=%u ackskew=%d "
literal|"pkts=%llu:%llu dir=%s,%s\n"
argument_list|,
name|seq
argument_list|,
name|orig_seq
argument_list|,
name|ack
argument_list|,
name|pd
operator|->
name|p_len
argument_list|,
name|ackskew
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
operator|*
name|state
argument_list|)
operator|->
name|packets
index|[
literal|0
index|]
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
operator|*
name|state
argument_list|)
operator|->
name|packets
index|[
literal|1
index|]
argument_list|,
name|pd
operator|->
name|dir
operator|==
name|PF_IN
condition|?
literal|"in"
else|:
literal|"out"
argument_list|,
name|pd
operator|->
name|dir
operator|==
operator|(
operator|*
name|state
operator|)
operator|->
name|direction
condition|?
literal|"fwd"
else|:
literal|"rev"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|->
name|scrub
operator|||
name|src
operator|->
name|scrub
condition|)
block|{
if|if
condition|(
name|pf_normalize_tcp_stateful
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|pd
argument_list|,
name|reason
argument_list|,
name|th
argument_list|,
operator|*
name|state
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|copyback
argument_list|)
condition|)
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
comment|/* update max window */
if|if
condition|(
name|src
operator|->
name|max_win
operator|<
name|win
condition|)
name|src
operator|->
name|max_win
operator|=
name|win
expr_stmt|;
comment|/* synchronize sequencing */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|end
argument_list|,
name|src
operator|->
name|seqlo
argument_list|)
condition|)
name|src
operator|->
name|seqlo
operator|=
name|end
expr_stmt|;
comment|/* slide the window of what the other end can send */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|ack
operator|+
operator|(
name|win
operator|<<
name|sws
operator|)
argument_list|,
name|dst
operator|->
name|seqhi
argument_list|)
condition|)
name|dst
operator|->
name|seqhi
operator|=
name|ack
operator|+
name|MAX
argument_list|(
operator|(
name|win
operator|<<
name|sws
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Cannot set dst->seqhi here since this could be a shotgunned 		 * SYN and not an already established connection. 		 */
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_FIN
condition|)
if|if
condition|(
name|src
operator|->
name|state
operator|<
name|TCPS_CLOSING
condition|)
name|src
operator|->
name|state
operator|=
name|TCPS_CLOSING
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_RST
condition|)
name|src
operator|->
name|state
operator|=
name|dst
operator|->
name|state
operator|=
name|TCPS_TIME_WAIT
expr_stmt|;
comment|/* Fall through to PASS packet */
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|state
operator|==
name|TCPS_SYN_SENT
operator|&&
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|state
operator|==
name|TCPS_SYN_SENT
condition|)
block|{
comment|/* Send RST for state mismatches during handshake */
if|if
condition|(
operator|!
operator|(
name|th
operator|->
name|th_flags
operator|&
name|TH_RST
operator|)
condition|)
name|pf_send_tcp
argument_list|(
name|NULL
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|rule
operator|.
name|ptr
argument_list|,
name|pd
operator|->
name|af
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|th
operator|->
name|th_dport
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TH_RST
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|rule
operator|.
name|ptr
operator|->
name|return_ttl
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|kif
operator|->
name|pfik_ifp
argument_list|)
expr_stmt|;
name|src
operator|->
name|seqlo
operator|=
literal|0
expr_stmt|;
name|src
operator|->
name|seqhi
operator|=
literal|1
expr_stmt|;
name|src
operator|->
name|max_win
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|V_pf_status
operator|.
name|debug
operator|>=
name|PF_DEBUG_MISC
condition|)
block|{
name|printf
argument_list|(
literal|"pf: BAD state: "
argument_list|)
expr_stmt|;
name|pf_print_state
argument_list|(
operator|*
name|state
argument_list|)
expr_stmt|;
name|pf_print_flags
argument_list|(
name|th
operator|->
name|th_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" seq=%u (%u) ack=%u len=%u ackskew=%d "
literal|"pkts=%llu:%llu dir=%s,%s\n"
argument_list|,
name|seq
argument_list|,
name|orig_seq
argument_list|,
name|ack
argument_list|,
name|pd
operator|->
name|p_len
argument_list|,
name|ackskew
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
operator|*
name|state
argument_list|)
operator|->
name|packets
index|[
literal|0
index|]
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
operator|*
name|state
argument_list|)
operator|->
name|packets
index|[
literal|1
index|]
argument_list|,
name|pd
operator|->
name|dir
operator|==
name|PF_IN
condition|?
literal|"in"
else|:
literal|"out"
argument_list|,
name|pd
operator|->
name|dir
operator|==
operator|(
operator|*
name|state
operator|)
operator|->
name|direction
condition|?
literal|"fwd"
else|:
literal|"rev"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pf: State failure on: %c %c %c %c | %c %c\n"
argument_list|,
name|SEQ_GEQ
argument_list|(
name|src
operator|->
name|seqhi
argument_list|,
name|end
argument_list|)
condition|?
literal|' '
else|:
literal|'1'
argument_list|,
name|SEQ_GEQ
argument_list|(
name|seq
argument_list|,
name|src
operator|->
name|seqlo
operator|-
operator|(
name|dst
operator|->
name|max_win
operator|<<
name|dws
operator|)
argument_list|)
condition|?
literal|' '
else|:
literal|'2'
argument_list|,
operator|(
name|ackskew
operator|>=
operator|-
name|MAXACKWINDOW
operator|)
condition|?
literal|' '
else|:
literal|'3'
argument_list|,
operator|(
name|ackskew
operator|<=
operator|(
name|MAXACKWINDOW
operator|<<
name|sws
operator|)
operator|)
condition|?
literal|' '
else|:
literal|'4'
argument_list|,
name|SEQ_GEQ
argument_list|(
name|src
operator|->
name|seqhi
operator|+
name|MAXACKWINDOW
argument_list|,
name|end
argument_list|)
condition|?
literal|' '
else|:
literal|'5'
argument_list|,
name|SEQ_GEQ
argument_list|(
name|seq
argument_list|,
name|src
operator|->
name|seqlo
operator|-
name|MAXACKWINDOW
argument_list|)
condition|?
literal|' '
else|:
literal|'6'
argument_list|)
expr_stmt|;
block|}
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_BADSTATE
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
return|return
operator|(
name|PF_PASS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_tcp_track_sloppy
parameter_list|(
name|struct
name|pf_state_peer
modifier|*
name|src
parameter_list|,
name|struct
name|pf_state_peer
modifier|*
name|dst
parameter_list|,
name|struct
name|pf_state
modifier|*
modifier|*
name|state
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|u_short
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|tcphdr
modifier|*
name|th
init|=
name|pd
operator|->
name|hdr
operator|.
name|tcp
decl_stmt|;
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_SYN
condition|)
if|if
condition|(
name|src
operator|->
name|state
operator|<
name|TCPS_SYN_SENT
condition|)
name|src
operator|->
name|state
operator|=
name|TCPS_SYN_SENT
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_FIN
condition|)
if|if
condition|(
name|src
operator|->
name|state
operator|<
name|TCPS_CLOSING
condition|)
name|src
operator|->
name|state
operator|=
name|TCPS_CLOSING
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_ACK
condition|)
block|{
if|if
condition|(
name|dst
operator|->
name|state
operator|==
name|TCPS_SYN_SENT
condition|)
block|{
name|dst
operator|->
name|state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|state
operator|==
name|TCPS_ESTABLISHED
operator|&&
operator|(
operator|*
name|state
operator|)
operator|->
name|src_node
operator|!=
name|NULL
operator|&&
name|pf_src_connlimit
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SRCLIMIT
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|dst
operator|->
name|state
operator|==
name|TCPS_CLOSING
condition|)
block|{
name|dst
operator|->
name|state
operator|=
name|TCPS_FIN_WAIT_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|->
name|state
operator|==
name|TCPS_SYN_SENT
operator|&&
name|dst
operator|->
name|state
operator|<
name|TCPS_SYN_SENT
condition|)
block|{
comment|/* 			 * Handle a special sloppy case where we only see one 			 * half of the connection. If there is a ACK after 			 * the initial SYN without ever seeing a packet from 			 * the destination, set the connection to established. 			 */
name|dst
operator|->
name|state
operator|=
name|src
operator|->
name|state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|src_node
operator|!=
name|NULL
operator|&&
name|pf_src_connlimit
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SRCLIMIT
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|src
operator|->
name|state
operator|==
name|TCPS_CLOSING
operator|&&
name|dst
operator|->
name|state
operator|==
name|TCPS_ESTABLISHED
operator|&&
name|dst
operator|->
name|seqlo
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Handle the closing of half connections where we 			 * don't see the full bidirectional FIN/ACK+ACK 			 * handshake. 			 */
name|dst
operator|->
name|state
operator|=
name|TCPS_CLOSING
expr_stmt|;
block|}
block|}
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_RST
condition|)
name|src
operator|->
name|state
operator|=
name|dst
operator|->
name|state
operator|=
name|TCPS_TIME_WAIT
expr_stmt|;
comment|/* update expire time */
operator|(
operator|*
name|state
operator|)
operator|->
name|expire
operator|=
name|time_uptime
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|state
operator|>=
name|TCPS_FIN_WAIT_2
operator|&&
name|dst
operator|->
name|state
operator|>=
name|TCPS_FIN_WAIT_2
condition|)
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_TCP_CLOSED
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|->
name|state
operator|>=
name|TCPS_CLOSING
operator|&&
name|dst
operator|->
name|state
operator|>=
name|TCPS_CLOSING
condition|)
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_TCP_FIN_WAIT
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|->
name|state
operator|<
name|TCPS_ESTABLISHED
operator|||
name|dst
operator|->
name|state
operator|<
name|TCPS_ESTABLISHED
condition|)
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_TCP_OPENING
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|->
name|state
operator|>=
name|TCPS_CLOSING
operator|||
name|dst
operator|->
name|state
operator|>=
name|TCPS_CLOSING
condition|)
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_TCP_CLOSING
expr_stmt|;
else|else
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_TCP_ESTABLISHED
expr_stmt|;
return|return
operator|(
name|PF_PASS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_test_state_tcp
parameter_list|(
name|struct
name|pf_state
modifier|*
modifier|*
name|state
parameter_list|,
name|int
name|direction
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|void
modifier|*
name|h
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|u_short
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|pf_state_key_cmp
name|key
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
name|pd
operator|->
name|hdr
operator|.
name|tcp
decl_stmt|;
name|int
name|copyback
init|=
literal|0
decl_stmt|;
name|struct
name|pf_state_peer
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|struct
name|pf_state_key
modifier|*
name|sk
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|af
operator|=
name|pd
operator|->
name|af
expr_stmt|;
name|key
operator|.
name|proto
operator|=
name|IPPROTO_TCP
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|PF_IN
condition|)
block|{
comment|/* wire side, straight */
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|0
index|]
operator|=
name|th
operator|->
name|th_sport
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|1
index|]
operator|=
name|th
operator|->
name|th_dport
expr_stmt|;
block|}
else|else
block|{
comment|/* stack side, reverse */
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|1
index|]
operator|=
name|th
operator|->
name|th_sport
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|0
index|]
operator|=
name|th
operator|->
name|th_dport
expr_stmt|;
block|}
name|STATE_LOOKUP
argument_list|(
name|kif
argument_list|,
operator|&
name|key
argument_list|,
name|direction
argument_list|,
operator|*
name|state
argument_list|,
name|pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
operator|(
operator|*
name|state
operator|)
operator|->
name|direction
condition|)
block|{
name|src
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|src
expr_stmt|;
name|dst
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
expr_stmt|;
name|dst
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|src
expr_stmt|;
block|}
name|sk
operator|=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|pd
operator|->
name|didx
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|state
operator|==
name|PF_TCPS_PROXY_SRC
condition|)
block|{
if|if
condition|(
name|direction
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|direction
condition|)
block|{
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SYNPROXY
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_SYNPROXY_DROP
operator|)
return|;
block|}
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_SYN
condition|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|seqlo
condition|)
block|{
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SYNPROXY
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
name|pf_send_tcp
argument_list|(
name|NULL
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|rule
operator|.
name|ptr
argument_list|,
name|pd
operator|->
name|af
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|th
operator|->
name|th_dport
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|seqhi
argument_list|,
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|+
literal|1
argument_list|,
name|TH_SYN
operator||
name|TH_ACK
argument_list|,
literal|0
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|mss
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SYNPROXY
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_SYNPROXY_DROP
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|th
operator|->
name|th_flags
operator|&
name|TH_ACK
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|seqhi
operator|+
literal|1
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|seqlo
operator|+
literal|1
operator|)
condition|)
block|{
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SYNPROXY
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|src_node
operator|!=
name|NULL
operator|&&
name|pf_src_connlimit
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SRCLIMIT
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
else|else
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|state
operator|=
name|PF_TCPS_PROXY_DST
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|state
operator|==
name|PF_TCPS_PROXY_DST
condition|)
block|{
if|if
condition|(
name|direction
operator|==
operator|(
operator|*
name|state
operator|)
operator|->
name|direction
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|)
operator|!=
name|TH_ACK
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|seqhi
operator|+
literal|1
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|seqlo
operator|+
literal|1
operator|)
condition|)
block|{
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SYNPROXY
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|max_win
operator|=
name|MAX
argument_list|(
name|ntohs
argument_list|(
name|th
operator|->
name|th_win
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|seqhi
operator|==
literal|1
condition|)
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|seqhi
operator|=
name|htonl
argument_list|(
name|arc4random
argument_list|()
argument_list|)
expr_stmt|;
name|pf_send_tcp
argument_list|(
name|NULL
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|rule
operator|.
name|ptr
argument_list|,
name|pd
operator|->
name|af
argument_list|,
operator|&
name|sk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
operator|&
name|sk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|sk
operator|->
name|port
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|sk
operator|->
name|port
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|seqhi
argument_list|,
literal|0
argument_list|,
name|TH_SYN
argument_list|,
literal|0
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|mss
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|tag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SYNPROXY
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_SYNPROXY_DROP
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|)
operator|!=
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|seqhi
operator|+
literal|1
operator|)
condition|)
block|{
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SYNPROXY
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
else|else
block|{
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|max_win
operator|=
name|MAX
argument_list|(
name|ntohs
argument_list|(
name|th
operator|->
name|th_win
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|seqlo
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|pf_send_tcp
argument_list|(
name|NULL
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|rule
operator|.
name|ptr
argument_list|,
name|pd
operator|->
name|af
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|th
operator|->
name|th_dport
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|+
literal|1
argument_list|,
name|TH_ACK
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|max_win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|tag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pf_send_tcp
argument_list|(
name|NULL
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|rule
operator|.
name|ptr
argument_list|,
name|pd
operator|->
name|af
argument_list|,
operator|&
name|sk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
operator|&
name|sk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|sk
operator|->
name|port
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|sk
operator|->
name|port
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|seqhi
operator|+
literal|1
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|seqlo
operator|+
literal|1
argument_list|,
name|TH_ACK
argument_list|,
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|max_win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|seqdiff
operator|=
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|seqhi
operator|-
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|seqlo
expr_stmt|;
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|seqdiff
operator|=
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|seqhi
operator|-
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|seqlo
expr_stmt|;
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|seqhi
operator|=
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|seqlo
operator|+
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|max_win
expr_stmt|;
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|seqhi
operator|=
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|seqlo
operator|+
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|max_win
expr_stmt|;
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|wscale
operator|=
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|wscale
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|state
operator|=
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SYNPROXY
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_SYNPROXY_DROP
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_SYN
operator|)
operator|&&
name|dst
operator|->
name|state
operator|>=
name|TCPS_FIN_WAIT_2
operator|&&
name|src
operator|->
name|state
operator|>=
name|TCPS_FIN_WAIT_2
condition|)
block|{
if|if
condition|(
name|V_pf_status
operator|.
name|debug
operator|>=
name|PF_DEBUG_MISC
condition|)
block|{
name|printf
argument_list|(
literal|"pf: state reuse "
argument_list|)
expr_stmt|;
name|pf_print_state
argument_list|(
operator|*
name|state
argument_list|)
expr_stmt|;
name|pf_print_flags
argument_list|(
name|th
operator|->
name|th_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* XXX make sure it's the same direction ?? */
operator|(
operator|*
name|state
operator|)
operator|->
name|src
operator|.
name|state
operator|=
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
operator|.
name|state
operator|=
name|TCPS_CLOSED
expr_stmt|;
name|pf_unlink_state
argument_list|(
operator|*
name|state
argument_list|,
name|PF_ENTER_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|state_flags
operator|&
name|PFSTATE_SLOPPY
condition|)
block|{
if|if
condition|(
name|pf_tcp_track_sloppy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|state
argument_list|,
name|pd
argument_list|,
name|reason
argument_list|)
operator|==
name|PF_DROP
condition|)
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|pf_tcp_track_full
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|state
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|pd
argument_list|,
name|reason
argument_list|,
operator|&
name|copyback
argument_list|)
operator|==
name|PF_DROP
condition|)
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
comment|/* translate source/destination address, if necessary */
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
condition|)
block|{
name|struct
name|pf_state_key
modifier|*
name|nk
init|=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|pd
operator|->
name|didx
index|]
decl_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd
operator|->
name|src
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|pd
operator|->
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|sidx
index|]
operator|!=
name|th
operator|->
name|th_sport
condition|)
name|pf_change_ap
argument_list|(
name|m
argument_list|,
name|pd
operator|->
name|src
argument_list|,
operator|&
name|th
operator|->
name|th_sport
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
operator|&
name|th
operator|->
name|th_sum
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
literal|0
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd
operator|->
name|dst
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|pd
operator|->
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|didx
index|]
operator|!=
name|th
operator|->
name|th_dport
condition|)
name|pf_change_ap
argument_list|(
name|m
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
operator|&
name|th
operator|->
name|th_dport
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
operator|&
name|th
operator|->
name|th_sum
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
literal|0
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
name|copyback
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Copyback sequence modulation or stateful scrub changes if needed */
if|if
condition|(
name|copyback
condition|)
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|th
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_PASS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_test_state_udp
parameter_list|(
name|struct
name|pf_state
modifier|*
modifier|*
name|state
parameter_list|,
name|int
name|direction
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|void
modifier|*
name|h
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|)
block|{
name|struct
name|pf_state_peer
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|struct
name|pf_state_key_cmp
name|key
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
init|=
name|pd
operator|->
name|hdr
operator|.
name|udp
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|af
operator|=
name|pd
operator|->
name|af
expr_stmt|;
name|key
operator|.
name|proto
operator|=
name|IPPROTO_UDP
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|PF_IN
condition|)
block|{
comment|/* wire side, straight */
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|0
index|]
operator|=
name|uh
operator|->
name|uh_sport
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|1
index|]
operator|=
name|uh
operator|->
name|uh_dport
expr_stmt|;
block|}
else|else
block|{
comment|/* stack side, reverse */
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|1
index|]
operator|=
name|uh
operator|->
name|uh_sport
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|0
index|]
operator|=
name|uh
operator|->
name|uh_dport
expr_stmt|;
block|}
name|STATE_LOOKUP
argument_list|(
name|kif
argument_list|,
operator|&
name|key
argument_list|,
name|direction
argument_list|,
operator|*
name|state
argument_list|,
name|pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
operator|(
operator|*
name|state
operator|)
operator|->
name|direction
condition|)
block|{
name|src
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|src
expr_stmt|;
name|dst
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
expr_stmt|;
name|dst
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|src
expr_stmt|;
block|}
comment|/* update states */
if|if
condition|(
name|src
operator|->
name|state
operator|<
name|PFUDPS_SINGLE
condition|)
name|src
operator|->
name|state
operator|=
name|PFUDPS_SINGLE
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|state
operator|==
name|PFUDPS_SINGLE
condition|)
name|dst
operator|->
name|state
operator|=
name|PFUDPS_MULTIPLE
expr_stmt|;
comment|/* update expire time */
operator|(
operator|*
name|state
operator|)
operator|->
name|expire
operator|=
name|time_uptime
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|state
operator|==
name|PFUDPS_MULTIPLE
operator|&&
name|dst
operator|->
name|state
operator|==
name|PFUDPS_MULTIPLE
condition|)
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_UDP_MULTIPLE
expr_stmt|;
else|else
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_UDP_SINGLE
expr_stmt|;
comment|/* translate source/destination address, if necessary */
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
condition|)
block|{
name|struct
name|pf_state_key
modifier|*
name|nk
init|=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|pd
operator|->
name|didx
index|]
decl_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd
operator|->
name|src
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|pd
operator|->
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|sidx
index|]
operator|!=
name|uh
operator|->
name|uh_sport
condition|)
name|pf_change_ap
argument_list|(
name|m
argument_list|,
name|pd
operator|->
name|src
argument_list|,
operator|&
name|uh
operator|->
name|uh_sport
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
operator|&
name|uh
operator|->
name|uh_sum
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
literal|1
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd
operator|->
name|dst
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|pd
operator|->
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|didx
index|]
operator|!=
name|uh
operator|->
name|uh_dport
condition|)
name|pf_change_ap
argument_list|(
name|m
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
operator|&
name|uh
operator|->
name|uh_dport
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
operator|&
name|uh
operator|->
name|uh_sum
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
literal|1
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|uh
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|uh
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|PF_PASS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_test_state_icmp
parameter_list|(
name|struct
name|pf_state
modifier|*
modifier|*
name|state
parameter_list|,
name|int
name|direction
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|void
modifier|*
name|h
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|u_short
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|pf_addr
modifier|*
name|saddr
init|=
name|pd
operator|->
name|src
decl_stmt|,
modifier|*
name|daddr
init|=
name|pd
operator|->
name|dst
decl_stmt|;
name|u_int16_t
name|icmpid
init|=
literal|0
decl_stmt|,
modifier|*
name|icmpsum
decl_stmt|;
name|u_int8_t
name|icmptype
decl_stmt|;
name|int
name|state_icmp
init|=
literal|0
decl_stmt|;
name|struct
name|pf_state_key_cmp
name|key
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pd
operator|->
name|proto
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|IPPROTO_ICMP
case|:
name|icmptype
operator|=
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_type
expr_stmt|;
name|icmpid
operator|=
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_id
expr_stmt|;
name|icmpsum
operator|=
operator|&
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_cksum
expr_stmt|;
if|if
condition|(
name|icmptype
operator|==
name|ICMP_UNREACH
operator|||
name|icmptype
operator|==
name|ICMP_SOURCEQUENCH
operator|||
name|icmptype
operator|==
name|ICMP_REDIRECT
operator|||
name|icmptype
operator|==
name|ICMP_TIMXCEED
operator|||
name|icmptype
operator|==
name|ICMP_PARAMPROB
condition|)
name|state_icmp
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPPROTO_ICMPV6
case|:
name|icmptype
operator|=
name|pd
operator|->
name|hdr
operator|.
name|icmp6
operator|->
name|icmp6_type
expr_stmt|;
name|icmpid
operator|=
name|pd
operator|->
name|hdr
operator|.
name|icmp6
operator|->
name|icmp6_id
expr_stmt|;
name|icmpsum
operator|=
operator|&
name|pd
operator|->
name|hdr
operator|.
name|icmp6
operator|->
name|icmp6_cksum
expr_stmt|;
if|if
condition|(
name|icmptype
operator|==
name|ICMP6_DST_UNREACH
operator|||
name|icmptype
operator|==
name|ICMP6_PACKET_TOO_BIG
operator|||
name|icmptype
operator|==
name|ICMP6_TIME_EXCEEDED
operator|||
name|icmptype
operator|==
name|ICMP6_PARAM_PROB
condition|)
name|state_icmp
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
if|if
condition|(
operator|!
name|state_icmp
condition|)
block|{
comment|/* 		 * ICMP query/reply message not related to a TCP/UDP packet. 		 * Search for an ICMP state. 		 */
name|key
operator|.
name|af
operator|=
name|pd
operator|->
name|af
expr_stmt|;
name|key
operator|.
name|proto
operator|=
name|pd
operator|->
name|proto
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|0
index|]
operator|=
name|key
operator|.
name|port
index|[
literal|1
index|]
operator|=
name|icmpid
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|PF_IN
condition|)
block|{
comment|/* wire side, straight */
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* stack side, reverse */
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
block|}
name|STATE_LOOKUP
argument_list|(
name|kif
argument_list|,
operator|&
name|key
argument_list|,
name|direction
argument_list|,
operator|*
name|state
argument_list|,
name|pd
argument_list|)
expr_stmt|;
operator|(
operator|*
name|state
operator|)
operator|->
name|expire
operator|=
name|time_uptime
expr_stmt|;
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_ICMP_ERROR_REPLY
expr_stmt|;
comment|/* translate source/destination address, if necessary */
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
condition|)
block|{
name|struct
name|pf_state_key
modifier|*
name|nk
init|=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|pd
operator|->
name|didx
index|]
decl_stmt|;
switch|switch
condition|(
name|pd
operator|->
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd
operator|->
name|src
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|AF_INET
argument_list|)
condition|)
name|pf_change_a
argument_list|(
operator|&
name|saddr
operator|->
name|v4
operator|.
name|s_addr
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
operator|.
name|v4
operator|.
name|s_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd
operator|->
name|dst
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|AF_INET
argument_list|)
condition|)
name|pf_change_a
argument_list|(
operator|&
name|daddr
operator|->
name|v4
operator|.
name|s_addr
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
operator|.
name|v4
operator|.
name|s_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nk
operator|->
name|port
index|[
literal|0
index|]
operator|!=
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_id
condition|)
block|{
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_cksum
operator|=
name|pf_cksum_fixup
argument_list|(
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_cksum
argument_list|,
name|icmpid
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_id
operator|=
name|nk
operator|->
name|port
index|[
name|pd
operator|->
name|sidx
index|]
expr_stmt|;
block|}
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|ICMP_MINLEN
argument_list|,
operator|(
name|caddr_t
operator|)
name|pd
operator|->
name|hdr
operator|.
name|icmp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd
operator|->
name|src
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|AF_INET6
argument_list|)
condition|)
name|pf_change_a6
argument_list|(
name|saddr
argument_list|,
operator|&
name|pd
operator|->
name|hdr
operator|.
name|icmp6
operator|->
name|icmp6_cksum
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd
operator|->
name|dst
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|AF_INET6
argument_list|)
condition|)
name|pf_change_a6
argument_list|(
name|daddr
argument_list|,
operator|&
name|pd
operator|->
name|hdr
operator|.
name|icmp6
operator|->
name|icmp6_cksum
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|pd
operator|->
name|hdr
operator|.
name|icmp6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
block|}
return|return
operator|(
name|PF_PASS
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * ICMP error message in response to a TCP/UDP packet. 		 * Extract the inner TCP/UDP header and search for that state. 		 */
name|struct
name|pf_pdesc
name|pd2
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|pd2
argument_list|,
sizeof|sizeof
name|pd2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ip
name|h2
decl_stmt|;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
name|h2_6
decl_stmt|;
name|int
name|terminal
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* INET6 */
name|int
name|ipoff2
init|=
literal|0
decl_stmt|;
name|int
name|off2
init|=
literal|0
decl_stmt|;
name|pd2
operator|.
name|af
operator|=
name|pd
operator|->
name|af
expr_stmt|;
comment|/* Payload packet is from the opposite direction. */
name|pd2
operator|.
name|sidx
operator|=
operator|(
name|direction
operator|==
name|PF_IN
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|pd2
operator|.
name|didx
operator|=
operator|(
name|direction
operator|==
name|PF_IN
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
switch|switch
condition|(
name|pd
operator|->
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
comment|/* offset of h2 in mbuf chain */
name|ipoff2
operator|=
name|off
operator|+
name|ICMP_MINLEN
expr_stmt|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|ipoff2
argument_list|,
operator|&
name|h2
argument_list|,
sizeof|sizeof
argument_list|(
name|h2
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|reason
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: ICMP error message too short "
literal|"(ip)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
comment|/* 			 * ICMP error messages don't refer to non-first 			 * fragments 			 */
if|if
condition|(
name|h2
operator|.
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_OFFMASK
argument_list|)
condition|)
block|{
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_FRAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
comment|/* offset of protocol header that follows h2 */
name|off2
operator|=
name|ipoff2
operator|+
operator|(
name|h2
operator|.
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|pd2
operator|.
name|proto
operator|=
name|h2
operator|.
name|ip_p
expr_stmt|;
name|pd2
operator|.
name|src
operator|=
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h2
operator|.
name|ip_src
expr_stmt|;
name|pd2
operator|.
name|dst
operator|=
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h2
operator|.
name|ip_dst
expr_stmt|;
name|pd2
operator|.
name|ip_sum
operator|=
operator|&
name|h2
operator|.
name|ip_sum
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|ipoff2
operator|=
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|ipoff2
argument_list|,
operator|&
name|h2_6
argument_list|,
sizeof|sizeof
argument_list|(
name|h2_6
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|reason
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: ICMP error message too short "
literal|"(ip6)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
name|pd2
operator|.
name|proto
operator|=
name|h2_6
operator|.
name|ip6_nxt
expr_stmt|;
name|pd2
operator|.
name|src
operator|=
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h2_6
operator|.
name|ip6_src
expr_stmt|;
name|pd2
operator|.
name|dst
operator|=
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h2_6
operator|.
name|ip6_dst
expr_stmt|;
name|pd2
operator|.
name|ip_sum
operator|=
name|NULL
expr_stmt|;
name|off2
operator|=
name|ipoff2
operator|+
sizeof|sizeof
argument_list|(
name|h2_6
argument_list|)
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|pd2
operator|.
name|proto
condition|)
block|{
case|case
name|IPPROTO_FRAGMENT
case|:
comment|/* 					 * ICMPv6 error messages for 					 * non-first fragments 					 */
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_FRAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
case|case
name|IPPROTO_AH
case|:
case|case
name|IPPROTO_HOPOPTS
case|:
case|case
name|IPPROTO_ROUTING
case|:
case|case
name|IPPROTO_DSTOPTS
case|:
block|{
comment|/* get next header and header length */
name|struct
name|ip6_ext
name|opt6
decl_stmt|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off2
argument_list|,
operator|&
name|opt6
argument_list|,
sizeof|sizeof
argument_list|(
name|opt6
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|reason
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: ICMPv6 short opt\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
if|if
condition|(
name|pd2
operator|.
name|proto
operator|==
name|IPPROTO_AH
condition|)
name|off2
operator|+=
operator|(
name|opt6
operator|.
name|ip6e_len
operator|+
literal|2
operator|)
operator|*
literal|4
expr_stmt|;
else|else
name|off2
operator|+=
operator|(
name|opt6
operator|.
name|ip6e_len
operator|+
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
name|pd2
operator|.
name|proto
operator|=
name|opt6
operator|.
name|ip6e_nxt
expr_stmt|;
comment|/* goto the next header */
break|break;
block|}
default|default:
name|terminal
operator|++
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|terminal
condition|)
do|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
switch|switch
condition|(
name|pd2
operator|.
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
block|{
name|struct
name|tcphdr
name|th
decl_stmt|;
name|u_int32_t
name|seq
decl_stmt|;
name|struct
name|pf_state_peer
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|u_int8_t
name|dws
decl_stmt|;
name|int
name|copyback
init|=
literal|0
decl_stmt|;
comment|/* 			 * Only the first 8 bytes of the TCP header can be 			 * expected. Don't access any TCP header fields after 			 * th_seq, an ackskew test is not possible. 			 */
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off2
argument_list|,
operator|&
name|th
argument_list|,
literal|8
argument_list|,
name|NULL
argument_list|,
name|reason
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: ICMP error message too short "
literal|"(tcp)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
name|key
operator|.
name|af
operator|=
name|pd2
operator|.
name|af
expr_stmt|;
name|key
operator|.
name|proto
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|pd2
operator|.
name|src
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|pd2
operator|.
name|dst
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|port
index|[
name|pd2
operator|.
name|sidx
index|]
operator|=
name|th
operator|.
name|th_sport
expr_stmt|;
name|key
operator|.
name|port
index|[
name|pd2
operator|.
name|didx
index|]
operator|=
name|th
operator|.
name|th_dport
expr_stmt|;
name|STATE_LOOKUP
argument_list|(
name|kif
argument_list|,
operator|&
name|key
argument_list|,
name|direction
argument_list|,
operator|*
name|state
argument_list|,
name|pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
operator|(
operator|*
name|state
operator|)
operator|->
name|direction
condition|)
block|{
name|src
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
expr_stmt|;
name|dst
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|src
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|src
expr_stmt|;
name|dst
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|->
name|wscale
operator|&&
name|dst
operator|->
name|wscale
condition|)
name|dws
operator|=
name|dst
operator|->
name|wscale
operator|&
name|PF_WSCALE_MASK
expr_stmt|;
else|else
name|dws
operator|=
literal|0
expr_stmt|;
comment|/* Demodulate sequence number */
name|seq
operator|=
name|ntohl
argument_list|(
name|th
operator|.
name|th_seq
argument_list|)
operator|-
name|src
operator|->
name|seqdiff
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|seqdiff
condition|)
block|{
name|pf_change_a
argument_list|(
operator|&
name|th
operator|.
name|th_seq
argument_list|,
name|icmpsum
argument_list|,
name|htonl
argument_list|(
name|seq
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copyback
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|state
operator|)
operator|->
name|state_flags
operator|&
name|PFSTATE_SLOPPY
operator|)
operator|&&
operator|(
operator|!
name|SEQ_GEQ
argument_list|(
name|src
operator|->
name|seqhi
argument_list|,
name|seq
argument_list|)
operator|||
operator|!
name|SEQ_GEQ
argument_list|(
name|seq
argument_list|,
name|src
operator|->
name|seqlo
operator|-
operator|(
name|dst
operator|->
name|max_win
operator|<<
name|dws
operator|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|V_pf_status
operator|.
name|debug
operator|>=
name|PF_DEBUG_MISC
condition|)
block|{
name|printf
argument_list|(
literal|"pf: BAD ICMP %d:%d "
argument_list|,
name|icmptype
argument_list|,
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_code
argument_list|)
expr_stmt|;
name|pf_print_host
argument_list|(
name|pd
operator|->
name|src
argument_list|,
literal|0
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -> "
argument_list|)
expr_stmt|;
name|pf_print_host
argument_list|(
name|pd
operator|->
name|dst
argument_list|,
literal|0
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" state: "
argument_list|)
expr_stmt|;
name|pf_print_state
argument_list|(
operator|*
name|state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" seq=%u\n"
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_BADSTATE
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|V_pf_status
operator|.
name|debug
operator|>=
name|PF_DEBUG_MISC
condition|)
block|{
name|printf
argument_list|(
literal|"pf: OK ICMP %d:%d "
argument_list|,
name|icmptype
argument_list|,
name|pd
operator|->
name|hdr
operator|.
name|icmp
operator|->
name|icmp_code
argument_list|)
expr_stmt|;
name|pf_print_host
argument_list|(
name|pd
operator|->
name|src
argument_list|,
literal|0
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -> "
argument_list|)
expr_stmt|;
name|pf_print_host
argument_list|(
name|pd
operator|->
name|dst
argument_list|,
literal|0
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" state: "
argument_list|)
expr_stmt|;
name|pf_print_state
argument_list|(
operator|*
name|state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" seq=%u\n"
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* translate source/destination address, if necessary */
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
condition|)
block|{
name|struct
name|pf_state_key
modifier|*
name|nk
init|=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|pd
operator|->
name|didx
index|]
decl_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd2
operator|.
name|src
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|sidx
index|]
operator|!=
name|th
operator|.
name|th_sport
condition|)
name|pf_change_icmp
argument_list|(
name|pd2
operator|.
name|src
argument_list|,
operator|&
name|th
operator|.
name|th_sport
argument_list|,
name|daddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|NULL
argument_list|,
name|pd2
operator|.
name|ip_sum
argument_list|,
name|icmpsum
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
literal|0
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd2
operator|.
name|dst
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|didx
index|]
operator|!=
name|th
operator|.
name|th_dport
condition|)
name|pf_change_icmp
argument_list|(
name|pd2
operator|.
name|dst
argument_list|,
operator|&
name|th
operator|.
name|th_dport
argument_list|,
name|saddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|NULL
argument_list|,
name|pd2
operator|.
name|ip_sum
argument_list|,
name|icmpsum
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
literal|0
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
expr_stmt|;
name|copyback
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|copyback
condition|)
block|{
switch|switch
condition|(
name|pd2
operator|.
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|ICMP_MINLEN
argument_list|,
operator|(
name|caddr_t
operator|)
name|pd
operator|->
name|hdr
operator|.
name|icmp
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|ipoff2
argument_list|,
sizeof|sizeof
argument_list|(
name|h2
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|h2
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|pd
operator|->
name|hdr
operator|.
name|icmp6
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|ipoff2
argument_list|,
sizeof|sizeof
argument_list|(
name|h2_6
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|h2_6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off2
argument_list|,
literal|8
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|th
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|PF_PASS
operator|)
return|;
break|break;
block|}
case|case
name|IPPROTO_UDP
case|:
block|{
name|struct
name|udphdr
name|uh
decl_stmt|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off2
argument_list|,
operator|&
name|uh
argument_list|,
sizeof|sizeof
argument_list|(
name|uh
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|reason
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: ICMP error message too short "
literal|"(udp)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
name|key
operator|.
name|af
operator|=
name|pd2
operator|.
name|af
expr_stmt|;
name|key
operator|.
name|proto
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|pd2
operator|.
name|src
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|pd2
operator|.
name|dst
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|port
index|[
name|pd2
operator|.
name|sidx
index|]
operator|=
name|uh
operator|.
name|uh_sport
expr_stmt|;
name|key
operator|.
name|port
index|[
name|pd2
operator|.
name|didx
index|]
operator|=
name|uh
operator|.
name|uh_dport
expr_stmt|;
name|STATE_LOOKUP
argument_list|(
name|kif
argument_list|,
operator|&
name|key
argument_list|,
name|direction
argument_list|,
operator|*
name|state
argument_list|,
name|pd
argument_list|)
expr_stmt|;
comment|/* translate source/destination address, if necessary */
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
condition|)
block|{
name|struct
name|pf_state_key
modifier|*
name|nk
init|=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|pd
operator|->
name|didx
index|]
decl_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd2
operator|.
name|src
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|sidx
index|]
operator|!=
name|uh
operator|.
name|uh_sport
condition|)
name|pf_change_icmp
argument_list|(
name|pd2
operator|.
name|src
argument_list|,
operator|&
name|uh
operator|.
name|uh_sport
argument_list|,
name|daddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
operator|&
name|uh
operator|.
name|uh_sum
argument_list|,
name|pd2
operator|.
name|ip_sum
argument_list|,
name|icmpsum
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
literal|1
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd2
operator|.
name|dst
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|didx
index|]
operator|!=
name|uh
operator|.
name|uh_dport
condition|)
name|pf_change_icmp
argument_list|(
name|pd2
operator|.
name|dst
argument_list|,
operator|&
name|uh
operator|.
name|uh_dport
argument_list|,
name|saddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
operator|&
name|uh
operator|.
name|uh_sum
argument_list|,
name|pd2
operator|.
name|ip_sum
argument_list|,
name|icmpsum
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
literal|1
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pd2
operator|.
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|ICMP_MINLEN
argument_list|,
operator|(
name|caddr_t
operator|)
name|pd
operator|->
name|hdr
operator|.
name|icmp
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|ipoff2
argument_list|,
sizeof|sizeof
argument_list|(
name|h2
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|h2
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|pd
operator|->
name|hdr
operator|.
name|icmp6
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|ipoff2
argument_list|,
sizeof|sizeof
argument_list|(
name|h2_6
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|h2_6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off2
argument_list|,
sizeof|sizeof
argument_list|(
name|uh
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|uh
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|PF_PASS
operator|)
return|;
break|break;
block|}
ifdef|#
directive|ifdef
name|INET
case|case
name|IPPROTO_ICMP
case|:
block|{
name|struct
name|icmp
name|iih
decl_stmt|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off2
argument_list|,
operator|&
name|iih
argument_list|,
name|ICMP_MINLEN
argument_list|,
name|NULL
argument_list|,
name|reason
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: ICMP error message too short i"
literal|"(icmp)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
name|key
operator|.
name|af
operator|=
name|pd2
operator|.
name|af
expr_stmt|;
name|key
operator|.
name|proto
operator|=
name|IPPROTO_ICMP
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|pd2
operator|.
name|src
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|pd2
operator|.
name|dst
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|0
index|]
operator|=
name|key
operator|.
name|port
index|[
literal|1
index|]
operator|=
name|iih
operator|.
name|icmp_id
expr_stmt|;
name|STATE_LOOKUP
argument_list|(
name|kif
argument_list|,
operator|&
name|key
argument_list|,
name|direction
argument_list|,
operator|*
name|state
argument_list|,
name|pd
argument_list|)
expr_stmt|;
comment|/* translate source/destination address, if necessary */
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
condition|)
block|{
name|struct
name|pf_state_key
modifier|*
name|nk
init|=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|pd
operator|->
name|didx
index|]
decl_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd2
operator|.
name|src
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|sidx
index|]
operator|!=
name|iih
operator|.
name|icmp_id
condition|)
name|pf_change_icmp
argument_list|(
name|pd2
operator|.
name|src
argument_list|,
operator|&
name|iih
operator|.
name|icmp_id
argument_list|,
name|daddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|NULL
argument_list|,
name|pd2
operator|.
name|ip_sum
argument_list|,
name|icmpsum
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
literal|0
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd2
operator|.
name|dst
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|didx
index|]
operator|!=
name|iih
operator|.
name|icmp_id
condition|)
name|pf_change_icmp
argument_list|(
name|pd2
operator|.
name|dst
argument_list|,
operator|&
name|iih
operator|.
name|icmp_id
argument_list|,
name|saddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|NULL
argument_list|,
name|pd2
operator|.
name|ip_sum
argument_list|,
name|icmpsum
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
literal|0
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|ICMP_MINLEN
argument_list|,
operator|(
name|caddr_t
operator|)
name|pd
operator|->
name|hdr
operator|.
name|icmp
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|ipoff2
argument_list|,
sizeof|sizeof
argument_list|(
name|h2
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|h2
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off2
argument_list|,
name|ICMP_MINLEN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iih
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|PF_PASS
operator|)
return|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPPROTO_ICMPV6
case|:
block|{
name|struct
name|icmp6_hdr
name|iih
decl_stmt|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off2
argument_list|,
operator|&
name|iih
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|reason
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: ICMP error message too short "
literal|"(icmp6)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
name|key
operator|.
name|af
operator|=
name|pd2
operator|.
name|af
expr_stmt|;
name|key
operator|.
name|proto
operator|=
name|IPPROTO_ICMPV6
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|pd2
operator|.
name|src
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|pd2
operator|.
name|dst
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|0
index|]
operator|=
name|key
operator|.
name|port
index|[
literal|1
index|]
operator|=
name|iih
operator|.
name|icmp6_id
expr_stmt|;
name|STATE_LOOKUP
argument_list|(
name|kif
argument_list|,
operator|&
name|key
argument_list|,
name|direction
argument_list|,
operator|*
name|state
argument_list|,
name|pd
argument_list|)
expr_stmt|;
comment|/* translate source/destination address, if necessary */
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
condition|)
block|{
name|struct
name|pf_state_key
modifier|*
name|nk
init|=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|pd
operator|->
name|didx
index|]
decl_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd2
operator|.
name|src
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|sidx
index|]
operator|!=
name|iih
operator|.
name|icmp6_id
condition|)
name|pf_change_icmp
argument_list|(
name|pd2
operator|.
name|src
argument_list|,
operator|&
name|iih
operator|.
name|icmp6_id
argument_list|,
name|daddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|NULL
argument_list|,
name|pd2
operator|.
name|ip_sum
argument_list|,
name|icmpsum
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
literal|0
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd2
operator|.
name|dst
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
operator|||
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|didx
index|]
operator|!=
name|iih
operator|.
name|icmp6_id
condition|)
name|pf_change_icmp
argument_list|(
name|pd2
operator|.
name|dst
argument_list|,
operator|&
name|iih
operator|.
name|icmp6_id
argument_list|,
name|saddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|nk
operator|->
name|port
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|NULL
argument_list|,
name|pd2
operator|.
name|ip_sum
argument_list|,
name|icmpsum
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
literal|0
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|pd
operator|->
name|hdr
operator|.
name|icmp6
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|ipoff2
argument_list|,
sizeof|sizeof
argument_list|(
name|h2_6
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|h2_6
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iih
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|PF_PASS
operator|)
return|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
default|default:
block|{
name|key
operator|.
name|af
operator|=
name|pd2
operator|.
name|af
expr_stmt|;
name|key
operator|.
name|proto
operator|=
name|pd2
operator|.
name|proto
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|pd2
operator|.
name|src
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|pd2
operator|.
name|dst
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|0
index|]
operator|=
name|key
operator|.
name|port
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|STATE_LOOKUP
argument_list|(
name|kif
argument_list|,
operator|&
name|key
argument_list|,
name|direction
argument_list|,
operator|*
name|state
argument_list|,
name|pd
argument_list|)
expr_stmt|;
comment|/* translate source/destination address, if necessary */
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
condition|)
block|{
name|struct
name|pf_state_key
modifier|*
name|nk
init|=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|pd
operator|->
name|didx
index|]
decl_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd2
operator|.
name|src
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
condition|)
name|pf_change_icmp
argument_list|(
name|pd2
operator|.
name|src
argument_list|,
name|NULL
argument_list|,
name|daddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|sidx
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|pd2
operator|.
name|ip_sum
argument_list|,
name|icmpsum
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
literal|0
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd2
operator|.
name|dst
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
condition|)
name|pf_change_icmp
argument_list|(
name|pd2
operator|.
name|dst
argument_list|,
name|NULL
argument_list|,
name|saddr
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd2
operator|.
name|didx
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|pd2
operator|.
name|ip_sum
argument_list|,
name|icmpsum
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
literal|0
argument_list|,
name|pd2
operator|.
name|af
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pd2
operator|.
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|ICMP_MINLEN
argument_list|,
operator|(
name|caddr_t
operator|)
name|pd
operator|->
name|hdr
operator|.
name|icmp
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|ipoff2
argument_list|,
sizeof|sizeof
argument_list|(
name|h2
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|h2
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|pd
operator|->
name|hdr
operator|.
name|icmp6
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|ipoff2
argument_list|,
sizeof|sizeof
argument_list|(
name|h2_6
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|h2_6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
block|}
return|return
operator|(
name|PF_PASS
operator|)
return|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pf_test_state_other
parameter_list|(
name|struct
name|pf_state
modifier|*
modifier|*
name|state
parameter_list|,
name|int
name|direction
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|)
block|{
name|struct
name|pf_state_peer
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|struct
name|pf_state_key_cmp
name|key
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|af
operator|=
name|pd
operator|->
name|af
expr_stmt|;
name|key
operator|.
name|proto
operator|=
name|pd
operator|->
name|proto
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|PF_IN
condition|)
block|{
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|0
index|]
operator|=
name|key
operator|.
name|port
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|key
operator|.
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|1
index|]
operator|=
name|key
operator|.
name|port
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|STATE_LOOKUP
argument_list|(
name|kif
argument_list|,
operator|&
name|key
argument_list|,
name|direction
argument_list|,
operator|*
name|state
argument_list|,
name|pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
operator|(
operator|*
name|state
operator|)
operator|->
name|direction
condition|)
block|{
name|src
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|src
expr_stmt|;
name|dst
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|dst
expr_stmt|;
name|dst
operator|=
operator|&
operator|(
operator|*
name|state
operator|)
operator|->
name|src
expr_stmt|;
block|}
comment|/* update states */
if|if
condition|(
name|src
operator|->
name|state
operator|<
name|PFOTHERS_SINGLE
condition|)
name|src
operator|->
name|state
operator|=
name|PFOTHERS_SINGLE
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|state
operator|==
name|PFOTHERS_SINGLE
condition|)
name|dst
operator|->
name|state
operator|=
name|PFOTHERS_MULTIPLE
expr_stmt|;
comment|/* update expire time */
operator|(
operator|*
name|state
operator|)
operator|->
name|expire
operator|=
name|time_uptime
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|state
operator|==
name|PFOTHERS_MULTIPLE
operator|&&
name|dst
operator|->
name|state
operator|==
name|PFOTHERS_MULTIPLE
condition|)
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_OTHER_MULTIPLE
expr_stmt|;
else|else
operator|(
operator|*
name|state
operator|)
operator|->
name|timeout
operator|=
name|PFTM_OTHER_SINGLE
expr_stmt|;
comment|/* translate source/destination address, if necessary */
if|if
condition|(
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|!=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
condition|)
block|{
name|struct
name|pf_state_key
modifier|*
name|nk
init|=
operator|(
operator|*
name|state
operator|)
operator|->
name|key
index|[
name|pd
operator|->
name|didx
index|]
decl_stmt|;
name|KASSERT
argument_list|(
name|nk
argument_list|,
operator|(
literal|"%s: nk is null"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pd
argument_list|,
operator|(
literal|"%s: pd is null"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pd
operator|->
name|src
argument_list|,
operator|(
literal|"%s: pd->src is null"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pd
operator|->
name|dst
argument_list|,
operator|(
literal|"%s: pd->dst is null"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pd
operator|->
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd
operator|->
name|src
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|AF_INET
argument_list|)
condition|)
name|pf_change_a
argument_list|(
operator|&
name|pd
operator|->
name|src
operator|->
name|v4
operator|.
name|s_addr
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
operator|.
name|v4
operator|.
name|s_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd
operator|->
name|dst
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|AF_INET
argument_list|)
condition|)
name|pf_change_a
argument_list|(
operator|&
name|pd
operator|->
name|dst
operator|->
name|v4
operator|.
name|s_addr
argument_list|,
name|pd
operator|->
name|ip_sum
argument_list|,
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
operator|.
name|v4
operator|.
name|s_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd
operator|->
name|src
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|AF_INET
argument_list|)
condition|)
name|PF_ACPY
argument_list|(
name|pd
operator|->
name|src
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|sidx
index|]
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF_ANEQ
argument_list|(
name|pd
operator|->
name|dst
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|AF_INET
argument_list|)
condition|)
name|PF_ACPY
argument_list|(
name|pd
operator|->
name|dst
argument_list|,
operator|&
name|nk
operator|->
name|addr
index|[
name|pd
operator|->
name|didx
index|]
argument_list|,
name|pd
operator|->
name|af
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INET6 */
block|}
block|}
return|return
operator|(
name|PF_PASS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ipoff and off are measured from the start of the mbuf chain.  * h must be at "ipoff" on the mbuf chain.  */
end_comment

begin_function
name|void
modifier|*
name|pf_pull_hdr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|,
name|u_short
modifier|*
name|actionp
parameter_list|,
name|u_short
modifier|*
name|reasonp
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|ip
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
name|u_int16_t
name|fragoff
init|=
operator|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_OFFMASK
operator|)
operator|<<
literal|3
decl_stmt|;
if|if
condition|(
name|fragoff
condition|)
block|{
if|if
condition|(
name|fragoff
operator|>=
name|len
condition|)
name|ACTION_SET
argument_list|(
name|actionp
argument_list|,
name|PF_PASS
argument_list|)
expr_stmt|;
else|else
block|{
name|ACTION_SET
argument_list|(
name|actionp
argument_list|,
name|PF_DROP
argument_list|)
expr_stmt|;
name|REASON_SET
argument_list|(
name|reasonp
argument_list|,
name|PFRES_FRAG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
operator|+
name|len
operator|||
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
operator|<
name|off
operator|+
name|len
condition|)
block|{
name|ACTION_SET
argument_list|(
name|actionp
argument_list|,
name|PF_DROP
argument_list|)
expr_stmt|;
name|REASON_SET
argument_list|(
name|reasonp
argument_list|,
name|PFRES_SHORT
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|ip6_hdr
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
operator|+
name|len
operator|||
operator|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip6_plen
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|)
operator|<
call|(
name|unsigned
call|)
argument_list|(
name|off
operator|+
name|len
argument_list|)
condition|)
block|{
name|ACTION_SET
argument_list|(
name|actionp
argument_list|,
name|PF_DROP
argument_list|)
expr_stmt|;
name|REASON_SET
argument_list|(
name|reasonp
argument_list|,
name|PFRES_SHORT
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RADIX_MPATH
end_ifdef

begin_function
specifier|static
name|int
name|pf_routable_oldmpath
parameter_list|(
name|struct
name|pf_addr
modifier|*
name|addr
parameter_list|,
name|sa_family_t
name|af
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|int
name|rtableid
parameter_list|)
block|{
name|struct
name|radix_node_head
modifier|*
name|rnh
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|dst
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|int
name|check_mpath
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|dst6
decl_stmt|;
name|struct
name|route_in6
name|ro
decl_stmt|;
else|#
directive|else
name|struct
name|route
name|ro
decl_stmt|;
endif|#
directive|endif
name|struct
name|radix_node
modifier|*
name|rn
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|check_mpath
operator|=
literal|0
expr_stmt|;
comment|/* XXX: stick to table 0 for now */
name|rnh
operator|=
name|rt_tables_get_rnh
argument_list|(
literal|0
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnh
operator|!=
name|NULL
operator|&&
name|rn_mpath_capable
argument_list|(
name|rnh
argument_list|)
condition|)
name|check_mpath
operator|=
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ro
argument_list|,
sizeof|sizeof
argument_list|(
name|ro
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
name|dst
operator|=
name|satosin
argument_list|(
operator|&
name|ro
operator|.
name|ro_dst
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|dst
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sin_addr
operator|=
name|addr
operator|->
name|v4
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
comment|/* 		 * Skip check for addresses with embedded interface scope, 		 * as they would always match anyway. 		 */
if|if
condition|(
name|IN6_IS_SCOPE_EMBED
argument_list|(
operator|&
name|addr
operator|->
name|v6
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|dst6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro
operator|.
name|ro_dst
expr_stmt|;
name|dst6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|dst6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|dst6
argument_list|)
expr_stmt|;
name|dst6
operator|->
name|sin6_addr
operator|=
name|addr
operator|->
name|v6
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Skip checks for ipsec interfaces */
if|if
condition|(
name|kif
operator|!=
name|NULL
operator|&&
name|kif
operator|->
name|pfik_ifp
operator|->
name|if_type
operator|==
name|IFT_ENC
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|in6_rtalloc_ign
argument_list|(
operator|&
name|ro
argument_list|,
literal|0
argument_list|,
name|rtableid
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|in_rtalloc_ign
argument_list|(
operator|(
expr|struct
name|route
operator|*
operator|)
operator|&
name|ro
argument_list|,
literal|0
argument_list|,
name|rtableid
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|ro
operator|.
name|ro_rt
operator|!=
name|NULL
condition|)
block|{
comment|/* No interface given, this is a no-route check */
if|if
condition|(
name|kif
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|kif
operator|->
name|pfik_ifp
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Perform uRPF check if passed input interface */
name|ret
operator|=
literal|0
expr_stmt|;
name|rn
operator|=
operator|(
expr|struct
name|radix_node
operator|*
operator|)
name|ro
operator|.
name|ro_rt
expr_stmt|;
do|do
block|{
name|rt
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|rn
expr_stmt|;
name|ifp
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
if|if
condition|(
name|kif
operator|->
name|pfik_ifp
operator|==
name|ifp
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
name|rn
operator|=
name|rn_mpath_next
argument_list|(
name|rn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|check_mpath
operator|==
literal|1
operator|&&
name|rn
operator|!=
name|NULL
operator|&&
name|ret
operator|==
literal|0
condition|)
do|;
block|}
else|else
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ro
operator|.
name|ro_rt
operator|!=
name|NULL
condition|)
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|pf_routable
parameter_list|(
name|struct
name|pf_addr
modifier|*
name|addr
parameter_list|,
name|sa_family_t
name|af
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|int
name|rtableid
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|nhop4_basic
name|nh4
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|nhop6_basic
name|nh6
decl_stmt|;
endif|#
directive|endif
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
ifdef|#
directive|ifdef
name|RADIX_MPATH
name|struct
name|radix_node_head
modifier|*
name|rnh
decl_stmt|;
comment|/* XXX: stick to table 0 for now */
name|rnh
operator|=
name|rt_tables_get_rnh
argument_list|(
literal|0
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnh
operator|!=
name|NULL
operator|&&
name|rn_mpath_capable
argument_list|(
name|rnh
argument_list|)
condition|)
return|return
operator|(
name|pf_routable_oldmpath
argument_list|(
name|addr
argument_list|,
name|af
argument_list|,
name|kif
argument_list|,
name|rtableid
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * Skip check for addresses with embedded interface scope, 	 * as they would always match anyway. 	 */
if|if
condition|(
name|af
operator|==
name|AF_INET6
operator|&&
name|IN6_IS_SCOPE_EMBED
argument_list|(
operator|&
name|addr
operator|->
name|v6
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|af
operator|!=
name|AF_INET
operator|&&
name|af
operator|!=
name|AF_INET6
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Skip checks for ipsec interfaces */
if|if
condition|(
name|kif
operator|!=
name|NULL
operator|&&
name|kif
operator|->
name|pfik_ifp
operator|->
name|if_type
operator|==
name|IFT_ENC
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ifp
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|fib6_lookup_nh_basic
argument_list|(
name|rtableid
argument_list|,
operator|&
name|addr
operator|->
name|v6
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|nh6
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ifp
operator|=
name|nh6
operator|.
name|nh_ifp
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|fib4_lookup_nh_basic
argument_list|(
name|rtableid
argument_list|,
name|addr
operator|->
name|v4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|nh4
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ifp
operator|=
name|nh4
operator|.
name|nh_ifp
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
comment|/* No interface given, this is a no-route check */
if|if
condition|(
name|kif
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|kif
operator|->
name|pfik_ifp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Perform uRPF check if passed input interface */
if|if
condition|(
name|kif
operator|->
name|pfik_ifp
operator|==
name|ifp
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
specifier|static
name|void
name|pf_route
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|r
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|ifnet
modifier|*
name|oifp
parameter_list|,
name|struct
name|pf_state
modifier|*
name|s
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
name|struct
name|sockaddr_in
name|dst
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_addr
name|naddr
decl_stmt|;
name|struct
name|pf_src_node
modifier|*
name|sn
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint16_t
name|ip_len
decl_stmt|,
name|ip_off
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|&&
operator|*
name|m
operator|&&
name|r
operator|&&
name|oifp
argument_list|,
operator|(
literal|"%s: invalid parameters"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|dir
operator|==
name|PF_IN
operator|||
name|dir
operator|==
name|PF_OUT
argument_list|,
operator|(
literal|"%s: invalid direction"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pd
operator|->
name|pf_mtag
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|pd
operator|->
name|pf_mtag
operator|=
name|pf_get_mtag
argument_list|(
operator|*
name|m
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|)
operator|||
name|pd
operator|->
name|pf_mtag
operator|->
name|routed
operator|++
operator|>
literal|3
condition|)
block|{
name|m0
operator|=
operator|*
name|m
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
goto|goto
name|bad_locked
goto|;
block|}
if|if
condition|(
name|r
operator|->
name|rt
operator|==
name|PF_DUPTO
condition|)
block|{
if|if
condition|(
operator|(
name|m0
operator|=
name|m_dup
argument_list|(
operator|*
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|s
condition|)
name|PF_STATE_UNLOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|r
operator|->
name|rt
operator|==
name|PF_REPLYTO
operator|)
operator|==
operator|(
name|r
operator|->
name|direction
operator|==
name|dir
operator|)
condition|)
block|{
if|if
condition|(
name|s
condition|)
name|PF_STATE_UNLOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|m0
operator|=
operator|*
name|m
expr_stmt|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|dst
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|rt
operator|==
name|PF_FASTROUTE
condition|)
block|{
name|struct
name|nhop4_basic
name|nh4
decl_stmt|;
if|if
condition|(
name|s
condition|)
name|PF_STATE_UNLOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|fib4_lookup_nh_basic
argument_list|(
name|M_GETFIB
argument_list|(
name|m0
argument_list|)
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
literal|0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|flowid
argument_list|,
operator|&
name|nh4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|KMOD_IPSTAT_INC
argument_list|(
name|ips_noroute
argument_list|)
expr_stmt|;
name|error
operator|=
name|EHOSTUNREACH
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ifp
operator|=
name|nh4
operator|.
name|nh_ifp
expr_stmt|;
name|dst
operator|.
name|sin_addr
operator|=
name|nh4
operator|.
name|nh_addr
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|r
operator|->
name|rpool
operator|.
name|list
argument_list|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_URGENT
argument_list|,
operator|(
literal|"%s: TAILQ_EMPTY(&r->rpool.list)\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad_locked
goto|;
block|}
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|pf_map_addr
argument_list|(
name|AF_INET
argument_list|,
name|r
argument_list|,
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|ip
operator|->
name|ip_src
argument_list|,
operator|&
name|naddr
argument_list|,
name|NULL
argument_list|,
operator|&
name|sn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PF_AZERO
argument_list|(
operator|&
name|naddr
argument_list|,
name|AF_INET
argument_list|)
condition|)
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|naddr
operator|.
name|v4
operator|.
name|s_addr
expr_stmt|;
name|ifp
operator|=
name|r
operator|->
name|rpool
operator|.
name|cur
operator|->
name|kif
condition|?
name|r
operator|->
name|rpool
operator|.
name|cur
operator|->
name|kif
operator|->
name|pfik_ifp
else|:
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|PF_AZERO
argument_list|(
operator|&
name|s
operator|->
name|rt_addr
argument_list|,
name|AF_INET
argument_list|)
condition|)
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|s
operator|->
name|rt_addr
operator|.
name|v4
operator|.
name|s_addr
expr_stmt|;
name|ifp
operator|=
name|s
operator|->
name|rt_kif
condition|?
name|s
operator|->
name|rt_kif
operator|->
name|pfik_ifp
else|:
name|NULL
expr_stmt|;
name|PF_STATE_UNLOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|oifp
operator|!=
name|ifp
condition|)
block|{
if|if
condition|(
name|pf_test
argument_list|(
name|PF_OUT
argument_list|,
name|ifp
argument_list|,
operator|&
name|m0
argument_list|,
name|NULL
argument_list|)
operator|!=
name|PF_PASS
condition|)
goto|goto
name|bad
goto|;
elseif|else
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|m0
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_URGENT
argument_list|,
operator|(
literal|"%s: m0->m_len< sizeof(struct ip)\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
condition|)
name|m0
operator|->
name|m_flags
operator||=
name|M_SKIP_FIREWALL
expr_stmt|;
name|ip_len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|ip_off
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
comment|/* Copied from FreeBSD 10.0-CURRENT ip_output. */
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA
operator|&
operator|~
name|ifp
operator|->
name|if_hwassist
condition|)
block|{
name|in_delayed_cksum
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_DELAY_DATA
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_SCTP
operator|&
operator|~
name|ifp
operator|->
name|if_hwassist
condition|)
block|{
name|sctp_delayed_cksum
argument_list|(
name|m
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_SCTP
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * If small enough for interface, or the interface will take 	 * care of the fragmentation for us, we can just send directly. 	 */
if|if
condition|(
name|ip_len
operator|<=
name|ifp
operator|->
name|if_mtu
operator|||
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|ifp
operator|->
name|if_hwassist
operator|&
name|CSUM_TSO
operator|)
operator|!=
literal|0
condition|)
block|{
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
operator|&
operator|~
name|ifp
operator|->
name|if_hwassist
condition|)
block|{
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum
argument_list|(
name|m0
argument_list|,
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_IP
expr_stmt|;
block|}
name|m_clrprotoflags
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* Avoid confusing lower layers. */
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|,
name|sintosa
argument_list|(
operator|&
name|dst
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Balk when DF bit is set or the interface didn't support TSO. */
if|if
condition|(
operator|(
name|ip_off
operator|&
name|IP_DF
operator|)
operator|||
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
condition|)
block|{
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
name|KMOD_IPSTAT_INC
argument_list|(
name|ips_cantfrag
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|rt
operator|!=
name|PF_DUPTO
condition|)
block|{
name|icmp_error
argument_list|(
name|m0
argument_list|,
name|ICMP_UNREACH
argument_list|,
name|ICMP_UNREACH_NEEDFRAG
argument_list|,
literal|0
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
name|ip_fragment
argument_list|(
name|ip
argument_list|,
operator|&
name|m0
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|,
name|ifp
operator|->
name|if_hwassist
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
for|for
control|(
init|;
name|m0
condition|;
name|m0
operator|=
name|m1
control|)
block|{
name|m1
operator|=
name|m0
operator|->
name|m_nextpkt
expr_stmt|;
name|m0
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|m_clrprotoflags
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|,
name|sintosa
argument_list|(
operator|&
name|dst
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|KMOD_IPSTAT_INC
argument_list|(
name|ips_fragmented
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|r
operator|->
name|rt
operator|!=
name|PF_DUPTO
condition|)
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
return|return;
name|bad_locked
label|:
if|if
condition|(
name|s
condition|)
name|PF_STATE_UNLOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bad
label|:
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
specifier|static
name|void
name|pf_route6
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|r
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|ifnet
modifier|*
name|oifp
parameter_list|,
name|struct
name|pf_state
modifier|*
name|s
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|sockaddr_in6
name|dst
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_addr
name|naddr
decl_stmt|;
name|struct
name|pf_src_node
modifier|*
name|sn
init|=
name|NULL
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|&&
operator|*
name|m
operator|&&
name|r
operator|&&
name|oifp
argument_list|,
operator|(
literal|"%s: invalid parameters"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|dir
operator|==
name|PF_IN
operator|||
name|dir
operator|==
name|PF_OUT
argument_list|,
operator|(
literal|"%s: invalid direction"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pd
operator|->
name|pf_mtag
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|pd
operator|->
name|pf_mtag
operator|=
name|pf_get_mtag
argument_list|(
operator|*
name|m
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|)
operator|||
name|pd
operator|->
name|pf_mtag
operator|->
name|routed
operator|++
operator|>
literal|3
condition|)
block|{
name|m0
operator|=
operator|*
name|m
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
goto|goto
name|bad_locked
goto|;
block|}
if|if
condition|(
name|r
operator|->
name|rt
operator|==
name|PF_DUPTO
condition|)
block|{
if|if
condition|(
operator|(
name|m0
operator|=
name|m_dup
argument_list|(
operator|*
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|s
condition|)
name|PF_STATE_UNLOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|r
operator|->
name|rt
operator|==
name|PF_REPLYTO
operator|)
operator|==
operator|(
name|r
operator|->
name|direction
operator|==
name|dir
operator|)
condition|)
block|{
if|if
condition|(
name|s
condition|)
name|PF_STATE_UNLOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|m0
operator|=
operator|*
name|m
expr_stmt|;
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|dst
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
comment|/* Cheat. XXX why only in the v6 case??? */
if|if
condition|(
name|r
operator|->
name|rt
operator|==
name|PF_FASTROUTE
condition|)
block|{
if|if
condition|(
name|s
condition|)
name|PF_STATE_UNLOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_flags
operator||=
name|M_SKIP_FIREWALL
expr_stmt|;
name|ip6_output
argument_list|(
name|m0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|r
operator|->
name|rpool
operator|.
name|list
argument_list|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_URGENT
argument_list|,
operator|(
literal|"%s: TAILQ_EMPTY(&r->rpool.list)\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad_locked
goto|;
block|}
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|pf_map_addr
argument_list|(
name|AF_INET6
argument_list|,
name|r
argument_list|,
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
operator|&
name|naddr
argument_list|,
name|NULL
argument_list|,
operator|&
name|sn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PF_AZERO
argument_list|(
operator|&
name|naddr
argument_list|,
name|AF_INET6
argument_list|)
condition|)
name|PF_ACPY
argument_list|(
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|dst
operator|.
name|sin6_addr
argument_list|,
operator|&
name|naddr
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|r
operator|->
name|rpool
operator|.
name|cur
operator|->
name|kif
condition|?
name|r
operator|->
name|rpool
operator|.
name|cur
operator|->
name|kif
operator|->
name|pfik_ifp
else|:
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|PF_AZERO
argument_list|(
operator|&
name|s
operator|->
name|rt_addr
argument_list|,
name|AF_INET6
argument_list|)
condition|)
name|PF_ACPY
argument_list|(
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|dst
operator|.
name|sin6_addr
argument_list|,
operator|&
name|s
operator|->
name|rt_addr
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|s
operator|->
name|rt_kif
condition|?
name|s
operator|->
name|rt_kif
operator|->
name|pfik_ifp
else|:
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|s
condition|)
name|PF_STATE_UNLOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|oifp
operator|!=
name|ifp
condition|)
block|{
if|if
condition|(
name|pf_test6
argument_list|(
name|PF_FWD
argument_list|,
name|ifp
argument_list|,
operator|&
name|m0
argument_list|,
name|NULL
argument_list|)
operator|!=
name|PF_PASS
condition|)
goto|goto
name|bad
goto|;
elseif|else
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|m0
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_URGENT
argument_list|,
operator|(
literal|"%s: m0->m_len< sizeof(struct ip6_hdr)\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
condition|)
name|m0
operator|->
name|m_flags
operator||=
name|M_SKIP_FIREWALL
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA_IPV6
operator|&
operator|~
name|ifp
operator|->
name|if_hwassist
condition|)
block|{
name|uint32_t
name|plen
init|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
decl_stmt|;
name|in6_delayed_cksum
argument_list|(
name|m0
argument_list|,
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_DELAY_DATA_IPV6
expr_stmt|;
block|}
comment|/* 	 * If the packet is too large for the outgoing interface, 	 * send back an icmp6 error. 	 */
if|if
condition|(
name|IN6_IS_SCOPE_EMBED
argument_list|(
operator|&
name|dst
operator|.
name|sin6_addr
argument_list|)
condition|)
name|dst
operator|.
name|sin6_addr
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|ifp
operator|->
name|if_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_long
operator|)
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|ifp
operator|->
name|if_mtu
condition|)
name|nd6_output_ifp
argument_list|(
name|ifp
argument_list|,
name|ifp
argument_list|,
name|m0
argument_list|,
operator|&
name|dst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|in6_ifstat_inc
argument_list|(
name|ifp
argument_list|,
name|ifs6_in_toobig
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|rt
operator|!=
name|PF_DUPTO
condition|)
name|icmp6_error
argument_list|(
name|m0
argument_list|,
name|ICMP6_PACKET_TOO_BIG
argument_list|,
literal|0
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
else|else
goto|goto
name|bad
goto|;
block|}
name|done
label|:
if|if
condition|(
name|r
operator|->
name|rt
operator|!=
name|PF_DUPTO
condition|)
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
return|return;
name|bad_locked
label|:
if|if
condition|(
name|s
condition|)
name|PF_STATE_UNLOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bad
label|:
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_comment
comment|/*  * FreeBSD supports cksum offloads for the following drivers.  *  em(4), fxp(4), ixgb(4), lge(4), ndis(4), nge(4), re(4),  *   ti(4), txp(4), xl(4)  *  * CSUM_DATA_VALID | CSUM_PSEUDO_HDR :  *  network driver performed cksum including pseudo header, need to verify  *   csum_data  * CSUM_DATA_VALID :  *  network driver performed cksum, needs to additional pseudo header  *  cksum computation with partial csum_data(i.e. lack of H/W support for  *  pseudo header, for instance hme(4), sk(4) and possibly gem(4))  *  * After validating the cksum of packet, set both flag CSUM_DATA_VALID and  * CSUM_PSEUDO_HDR in order to avoid recomputation of the cksum in upper  * TCP/UDP layer.  * Also, set csum_data to 0xffff to force cksum validation.  */
end_comment

begin_function
specifier|static
name|int
name|pf_check_proto_cksum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|,
name|u_int8_t
name|p
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|u_int16_t
name|sum
init|=
literal|0
decl_stmt|;
name|int
name|hw_assist
init|=
literal|0
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|off
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|||
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
operator|+
name|len
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DATA_VALID
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_PSEUDO_HDR
condition|)
block|{
name|sum
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htonl
argument_list|(
operator|(
name|u_short
operator|)
name|len
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|+
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sum
operator|^=
literal|0xffff
expr_stmt|;
operator|++
name|hw_assist
expr_stmt|;
block|}
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DATA_VALID
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_PSEUDO_HDR
condition|)
block|{
name|sum
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htonl
argument_list|(
operator|(
name|u_short
operator|)
name|len
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|+
name|IPPROTO_UDP
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sum
operator|^=
literal|0xffff
expr_stmt|;
operator|++
name|hw_assist
expr_stmt|;
block|}
break|break;
case|case
name|IPPROTO_ICMP
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPPROTO_ICMPV6
case|:
endif|#
directive|endif
comment|/* INET6 */
break|break;
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|hw_assist
condition|)
block|{
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|p
operator|==
name|IPPROTO_ICMP
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|off
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|m
operator|->
name|m_data
operator|+=
name|off
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|off
expr_stmt|;
name|sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
name|off
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|off
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sum
operator|=
name|in4_cksum
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sum
operator|=
name|in6_cksum
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|sum
condition|)
block|{
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
block|{
name|KMOD_TCPSTAT_INC
argument_list|(
name|tcps_rcvbadsum
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IPPROTO_UDP
case|:
block|{
name|KMOD_UDPSTAT_INC
argument_list|(
name|udps_badsum
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|INET
case|case
name|IPPROTO_ICMP
case|:
block|{
name|KMOD_ICMPSTAT_INC
argument_list|(
name|icps_checksum
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPPROTO_ICMPV6
case|:
block|{
name|KMOD_ICMP6STAT_INC
argument_list|(
name|icp6s_checksum
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|==
name|IPPROTO_TCP
operator|||
name|p
operator|==
name|IPPROTO_UDP
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
name|int
name|pf_test
parameter_list|(
name|int
name|dir
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|pfi_kif
modifier|*
name|kif
decl_stmt|;
name|u_short
name|action
decl_stmt|,
name|reason
init|=
literal|0
decl_stmt|,
name|log
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|;
name|struct
name|ip
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|ipfwtag
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|a
init|=
name|NULL
decl_stmt|,
modifier|*
name|r
init|=
operator|&
name|V_pf_default_rule
decl_stmt|,
modifier|*
name|tr
decl_stmt|,
modifier|*
name|nr
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_pdesc
name|pd
decl_stmt|;
name|int
name|off
decl_stmt|,
name|dirndx
decl_stmt|,
name|pqid
init|=
literal|0
decl_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|V_pf_status
operator|.
name|running
condition|)
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|memset
argument_list|(
operator|&
name|pd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pd
argument_list|)
argument_list|)
expr_stmt|;
name|kif
operator|=
operator|(
expr|struct
name|pfi_kif
operator|*
operator|)
name|ifp
operator|->
name|if_pf_kif
expr_stmt|;
if|if
condition|(
name|kif
operator|==
name|NULL
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_URGENT
argument_list|,
operator|(
literal|"pf_test: kif == NULL, if_xname %s\n"
operator|,
name|ifp
operator|->
name|if_xname
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
if|if
condition|(
name|kif
operator|->
name|pfik_flags
operator|&
name|PFI_IFLAG_SKIP
condition|)
return|return
operator|(
name|PF_PASS
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_SKIP_FIREWALL
condition|)
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|pd
operator|.
name|pf_mtag
operator|=
name|pf_find_mtag
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|ip_divert_ptr
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|ipfwtag
operator|=
name|m_tag_locate
argument_list|(
name|m
argument_list|,
name|MTAG_IPFW_RULE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|struct
name|ipfw_rule_ref
modifier|*
name|rr
init|=
operator|(
expr|struct
name|ipfw_rule_ref
operator|*
operator|)
operator|(
name|ipfwtag
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|rr
operator|->
name|info
operator|&
name|IPFW_IS_DIVERT
operator|&&
name|rr
operator|->
name|rulenum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pd
operator|.
name|pf_mtag
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|pd
operator|.
name|pf_mtag
operator|=
name|pf_get_mtag
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|pd
operator|.
name|pf_mtag
operator|->
name|flags
operator||=
name|PF_PACKET_LOOPED
expr_stmt|;
name|m_tag_delete
argument_list|(
name|m
argument_list|,
name|ipfwtag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pd
operator|.
name|pf_mtag
operator|&&
name|pd
operator|.
name|pf_mtag
operator|->
name|flags
operator|&
name|PF_FASTFWD_OURS_PRESENT
condition|)
block|{
name|m
operator|->
name|m_flags
operator||=
name|M_FASTFWD_OURS
expr_stmt|;
name|pd
operator|.
name|pf_mtag
operator|->
name|flags
operator|&=
operator|~
name|PF_FASTFWD_OURS_PRESENT
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pf_normalize_ip
argument_list|(
name|m0
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
operator|&
name|reason
argument_list|,
operator|&
name|pd
argument_list|)
operator|!=
name|PF_PASS
condition|)
block|{
comment|/* We do IP header normalization and packet reassembly here */
name|action
operator|=
name|PF_DROP
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|m
operator|=
operator|*
name|m0
expr_stmt|;
comment|/* pf_normalize messes with m0 */
name|h
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|off
operator|=
name|h
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|off
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_SHORT
argument_list|)
expr_stmt|;
name|log
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|pd
operator|.
name|src
operator|=
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h
operator|->
name|ip_src
expr_stmt|;
name|pd
operator|.
name|dst
operator|=
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h
operator|->
name|ip_dst
expr_stmt|;
name|pd
operator|.
name|sport
operator|=
name|pd
operator|.
name|dport
operator|=
name|NULL
expr_stmt|;
name|pd
operator|.
name|ip_sum
operator|=
operator|&
name|h
operator|->
name|ip_sum
expr_stmt|;
name|pd
operator|.
name|proto_sum
operator|=
name|NULL
expr_stmt|;
name|pd
operator|.
name|proto
operator|=
name|h
operator|->
name|ip_p
expr_stmt|;
name|pd
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
name|pd
operator|.
name|sidx
operator|=
operator|(
name|dir
operator|==
name|PF_IN
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|pd
operator|.
name|didx
operator|=
operator|(
name|dir
operator|==
name|PF_IN
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|pd
operator|.
name|af
operator|=
name|AF_INET
expr_stmt|;
name|pd
operator|.
name|tos
operator|=
name|h
operator|->
name|ip_tos
expr_stmt|;
name|pd
operator|.
name|tot_len
operator|=
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
expr_stmt|;
comment|/* handle fragments that didn't get reassembled by normalization */
if|if
condition|(
name|h
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_MF
operator||
name|IP_OFFMASK
argument_list|)
condition|)
block|{
name|action
operator|=
name|pf_test_fragment
argument_list|(
operator|&
name|r
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|h
argument_list|,
operator|&
name|pd
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|ruleset
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|h
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
block|{
name|struct
name|tcphdr
name|th
decl_stmt|;
name|pd
operator|.
name|hdr
operator|.
name|tcp
operator|=
operator|&
name|th
expr_stmt|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|th
argument_list|,
sizeof|sizeof
argument_list|(
name|th
argument_list|)
argument_list|,
operator|&
name|action
argument_list|,
operator|&
name|reason
argument_list|,
name|AF_INET
argument_list|)
condition|)
block|{
name|log
operator|=
name|action
operator|!=
name|PF_PASS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|pd
operator|.
name|p_len
operator|=
name|pd
operator|.
name|tot_len
operator|-
name|off
operator|-
operator|(
name|th
operator|.
name|th_off
operator|<<
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|th
operator|.
name|th_flags
operator|&
name|TH_ACK
operator|)
operator|&&
name|pd
operator|.
name|p_len
operator|==
literal|0
condition|)
name|pqid
operator|=
literal|1
expr_stmt|;
name|action
operator|=
name|pf_normalize_tcp
argument_list|(
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|off
argument_list|,
name|h
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|PF_DROP
condition|)
goto|goto
name|done
goto|;
name|action
operator|=
name|pf_test_state_tcp
argument_list|(
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|h
argument_list|,
operator|&
name|pd
argument_list|,
operator|&
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|PF_PASS
condition|)
block|{
if|if
condition|(
name|pfsync_update_state_ptr
operator|!=
name|NULL
condition|)
name|pfsync_update_state_ptr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|r
operator|=
name|s
operator|->
name|rule
operator|.
name|ptr
expr_stmt|;
name|a
operator|=
name|s
operator|->
name|anchor
operator|.
name|ptr
expr_stmt|;
name|log
operator|=
name|s
operator|->
name|log
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|action
operator|=
name|pf_test_rule
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|pd
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|ruleset
argument_list|,
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IPPROTO_UDP
case|:
block|{
name|struct
name|udphdr
name|uh
decl_stmt|;
name|pd
operator|.
name|hdr
operator|.
name|udp
operator|=
operator|&
name|uh
expr_stmt|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|uh
argument_list|,
sizeof|sizeof
argument_list|(
name|uh
argument_list|)
argument_list|,
operator|&
name|action
argument_list|,
operator|&
name|reason
argument_list|,
name|AF_INET
argument_list|)
condition|)
block|{
name|log
operator|=
name|action
operator|!=
name|PF_PASS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|uh
operator|.
name|uh_dport
operator|==
literal|0
operator|||
name|ntohs
argument_list|(
name|uh
operator|.
name|uh_ulen
argument_list|)
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|off
operator|||
name|ntohs
argument_list|(
name|uh
operator|.
name|uh_ulen
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
condition|)
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_SHORT
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|action
operator|=
name|pf_test_state_udp
argument_list|(
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|h
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|PF_PASS
condition|)
block|{
if|if
condition|(
name|pfsync_update_state_ptr
operator|!=
name|NULL
condition|)
name|pfsync_update_state_ptr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|r
operator|=
name|s
operator|->
name|rule
operator|.
name|ptr
expr_stmt|;
name|a
operator|=
name|s
operator|->
name|anchor
operator|.
name|ptr
expr_stmt|;
name|log
operator|=
name|s
operator|->
name|log
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|action
operator|=
name|pf_test_rule
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|pd
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|ruleset
argument_list|,
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IPPROTO_ICMP
case|:
block|{
name|struct
name|icmp
name|ih
decl_stmt|;
name|pd
operator|.
name|hdr
operator|.
name|icmp
operator|=
operator|&
name|ih
expr_stmt|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|ih
argument_list|,
name|ICMP_MINLEN
argument_list|,
operator|&
name|action
argument_list|,
operator|&
name|reason
argument_list|,
name|AF_INET
argument_list|)
condition|)
block|{
name|log
operator|=
name|action
operator|!=
name|PF_PASS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|action
operator|=
name|pf_test_state_icmp
argument_list|(
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|h
argument_list|,
operator|&
name|pd
argument_list|,
operator|&
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|PF_PASS
condition|)
block|{
if|if
condition|(
name|pfsync_update_state_ptr
operator|!=
name|NULL
condition|)
name|pfsync_update_state_ptr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|r
operator|=
name|s
operator|->
name|rule
operator|.
name|ptr
expr_stmt|;
name|a
operator|=
name|s
operator|->
name|anchor
operator|.
name|ptr
expr_stmt|;
name|log
operator|=
name|s
operator|->
name|log
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|action
operator|=
name|pf_test_rule
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|pd
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|ruleset
argument_list|,
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPPROTO_ICMPV6
case|:
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: dropping IPv4 packet with ICMPv6 payload\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
default|default:
name|action
operator|=
name|pf_test_state_other
argument_list|(
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|PF_PASS
condition|)
block|{
if|if
condition|(
name|pfsync_update_state_ptr
operator|!=
name|NULL
condition|)
name|pfsync_update_state_ptr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|r
operator|=
name|s
operator|->
name|rule
operator|.
name|ptr
expr_stmt|;
name|a
operator|=
name|s
operator|->
name|anchor
operator|.
name|ptr
expr_stmt|;
name|log
operator|=
name|s
operator|->
name|log
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|action
operator|=
name|pf_test_rule
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|pd
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|ruleset
argument_list|,
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
name|done
label|:
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|PF_PASS
operator|&&
name|h
operator|->
name|ip_hl
operator|>
literal|5
operator|&&
operator|!
operator|(
operator|(
name|s
operator|&&
name|s
operator|->
name|state_flags
operator|&
name|PFSTATE_ALLOWOPTS
operator|)
operator|||
name|r
operator|->
name|allow_opts
operator|)
condition|)
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_IPOPTIONS
argument_list|)
expr_stmt|;
name|log
operator|=
name|r
operator|->
name|log
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: dropping packet with ip options\n"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|&&
name|s
operator|->
name|tag
operator|>
literal|0
operator|&&
name|pf_tag_packet
argument_list|(
name|m
argument_list|,
operator|&
name|pd
argument_list|,
name|s
operator|->
name|tag
argument_list|)
condition|)
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|rtableid
operator|>=
literal|0
condition|)
name|M_SETFIB
argument_list|(
name|m
argument_list|,
name|r
operator|->
name|rtableid
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|scrub_flags
operator|&
name|PFSTATE_SETPRIO
condition|)
block|{
if|if
condition|(
name|pd
operator|.
name|tos
operator|&
name|IPTOS_LOWDELAY
condition|)
name|pqid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pf_ieee8021q_setpcp
argument_list|(
name|m
argument_list|,
name|r
operator|->
name|set_prio
index|[
name|pqid
index|]
argument_list|)
condition|)
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
name|log
operator|=
literal|1
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: failed to allocate 802.1q mtag\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ALTQ
if|if
condition|(
name|action
operator|==
name|PF_PASS
operator|&&
name|r
operator|->
name|qid
condition|)
block|{
if|if
condition|(
name|pd
operator|.
name|pf_mtag
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|pd
operator|.
name|pf_mtag
operator|=
name|pf_get_mtag
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|pd
operator|.
name|pf_mtag
operator|->
name|qid_hash
operator|=
name|pf_state_hash
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|pqid
operator|||
operator|(
name|pd
operator|.
name|tos
operator|&
name|IPTOS_LOWDELAY
operator|)
condition|)
name|pd
operator|.
name|pf_mtag
operator|->
name|qid
operator|=
name|r
operator|->
name|pqid
expr_stmt|;
else|else
name|pd
operator|.
name|pf_mtag
operator|->
name|qid
operator|=
name|r
operator|->
name|qid
expr_stmt|;
comment|/* Add hints for ecn. */
name|pd
operator|.
name|pf_mtag
operator|->
name|hdr
operator|=
name|h
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ALTQ */
comment|/* 	 * connections redirected to loopback should not match sockets 	 * bound specifically to loopback due to security implications, 	 * see tcp_input() and in_pcblookup_listen(). 	 */
if|if
condition|(
name|dir
operator|==
name|PF_IN
operator|&&
name|action
operator|==
name|PF_PASS
operator|&&
operator|(
name|pd
operator|.
name|proto
operator|==
name|IPPROTO_TCP
operator|||
name|pd
operator|.
name|proto
operator|==
name|IPPROTO_UDP
operator|)
operator|&&
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|action
operator|==
name|PF_RDR
operator|||
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|action
operator|==
name|PF_BINAT
operator|)
operator|&&
operator|(
name|ntohl
argument_list|(
name|pd
operator|.
name|dst
operator|->
name|v4
operator|.
name|s_addr
argument_list|)
operator|>>
name|IN_CLASSA_NSHIFT
operator|)
operator|==
name|IN_LOOPBACKNET
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_SKIP_FIREWALL
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|PF_PASS
operator|&&
name|r
operator|->
name|divert
operator|.
name|port
operator|&&
name|ip_divert_ptr
operator|!=
name|NULL
operator|&&
operator|!
name|PACKET_LOOPED
argument_list|(
operator|&
name|pd
argument_list|)
condition|)
block|{
name|ipfwtag
operator|=
name|m_tag_alloc
argument_list|(
name|MTAG_IPFW_RULE
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipfw_rule_ref
argument_list|)
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipfwtag
operator|!=
name|NULL
condition|)
block|{
operator|(
operator|(
expr|struct
name|ipfw_rule_ref
operator|*
operator|)
operator|(
name|ipfwtag
operator|+
literal|1
operator|)
operator|)
operator|->
name|info
operator|=
name|ntohs
argument_list|(
name|r
operator|->
name|divert
operator|.
name|port
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|ipfw_rule_ref
operator|*
operator|)
operator|(
name|ipfwtag
operator|+
literal|1
operator|)
operator|)
operator|->
name|rulenum
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|PF_STATE_UNLOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|ipfwtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_FASTFWD_OURS
condition|)
block|{
if|if
condition|(
name|pd
operator|.
name|pf_mtag
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|pd
operator|.
name|pf_mtag
operator|=
name|pf_get_mtag
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
name|log
operator|=
literal|1
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: failed to allocate tag\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pd
operator|.
name|pf_mtag
operator|->
name|flags
operator||=
name|PF_FASTFWD_OURS_PRESENT
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_FASTFWD_OURS
expr_stmt|;
block|}
block|}
name|ip_divert_ptr
argument_list|(
operator|*
name|m0
argument_list|,
name|dir
operator|==
name|PF_IN
condition|?
name|DIR_IN
else|:
name|DIR_OUT
argument_list|)
expr_stmt|;
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
else|else
block|{
comment|/* XXX: ipfw has the same behaviour! */
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
name|log
operator|=
literal|1
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: failed to allocate divert tag\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|log
condition|)
block|{
name|struct
name|pf_rule
modifier|*
name|lr
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|log
operator|&
name|PF_LOG_ALL
condition|)
name|lr
operator|=
name|s
operator|->
name|nat_rule
operator|.
name|ptr
expr_stmt|;
else|else
name|lr
operator|=
name|r
expr_stmt|;
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|m
argument_list|,
name|AF_INET
argument_list|,
name|dir
argument_list|,
name|reason
argument_list|,
name|lr
argument_list|,
name|a
argument_list|,
name|ruleset
argument_list|,
operator|&
name|pd
argument_list|,
operator|(
name|s
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
block|}
name|kif
operator|->
name|pfik_bytes
index|[
literal|0
index|]
index|[
name|dir
operator|==
name|PF_OUT
index|]
index|[
name|action
operator|!=
name|PF_PASS
index|]
operator|+=
name|pd
operator|.
name|tot_len
expr_stmt|;
name|kif
operator|->
name|pfik_packets
index|[
literal|0
index|]
index|[
name|dir
operator|==
name|PF_OUT
index|]
index|[
name|action
operator|!=
name|PF_PASS
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|PF_PASS
operator|||
name|r
operator|->
name|action
operator|==
name|PF_DROP
condition|)
block|{
name|dirndx
operator|=
operator|(
name|dir
operator|==
name|PF_OUT
operator|)
expr_stmt|;
name|r
operator|->
name|packets
index|[
name|dirndx
index|]
operator|++
expr_stmt|;
name|r
operator|->
name|bytes
index|[
name|dirndx
index|]
operator|+=
name|pd
operator|.
name|tot_len
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
name|a
operator|->
name|packets
index|[
name|dirndx
index|]
operator|++
expr_stmt|;
name|a
operator|->
name|bytes
index|[
name|dirndx
index|]
operator|+=
name|pd
operator|.
name|tot_len
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|packets
index|[
name|dirndx
index|]
operator|++
expr_stmt|;
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|bytes
index|[
name|dirndx
index|]
operator|+=
name|pd
operator|.
name|tot_len
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|src_node
operator|!=
name|NULL
condition|)
block|{
name|s
operator|->
name|src_node
operator|->
name|packets
index|[
name|dirndx
index|]
operator|++
expr_stmt|;
name|s
operator|->
name|src_node
operator|->
name|bytes
index|[
name|dirndx
index|]
operator|+=
name|pd
operator|.
name|tot_len
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|nat_src_node
operator|!=
name|NULL
condition|)
block|{
name|s
operator|->
name|nat_src_node
operator|->
name|packets
index|[
name|dirndx
index|]
operator|++
expr_stmt|;
name|s
operator|->
name|nat_src_node
operator|->
name|bytes
index|[
name|dirndx
index|]
operator|+=
name|pd
operator|.
name|tot_len
expr_stmt|;
block|}
name|dirndx
operator|=
operator|(
name|dir
operator|==
name|s
operator|->
name|direction
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|s
operator|->
name|packets
index|[
name|dirndx
index|]
operator|++
expr_stmt|;
name|s
operator|->
name|bytes
index|[
name|dirndx
index|]
operator|+=
name|pd
operator|.
name|tot_len
expr_stmt|;
block|}
name|tr
operator|=
name|r
expr_stmt|;
name|nr
operator|=
operator|(
name|s
operator|!=
name|NULL
operator|)
condition|?
name|s
operator|->
name|nat_rule
operator|.
name|ptr
else|:
name|pd
operator|.
name|nat_rule
expr_stmt|;
if|if
condition|(
name|nr
operator|!=
name|NULL
operator|&&
name|r
operator|==
operator|&
name|V_pf_default_rule
condition|)
name|tr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|src
operator|.
name|addr
operator|.
name|type
operator|==
name|PF_ADDR_TABLE
condition|)
name|pfr_update_stats
argument_list|(
name|tr
operator|->
name|src
operator|.
name|addr
operator|.
name|p
operator|.
name|tbl
argument_list|,
operator|(
name|s
operator|==
name|NULL
operator|)
condition|?
name|pd
operator|.
name|src
else|:
operator|&
name|s
operator|->
name|key
index|[
operator|(
name|s
operator|->
name|direction
operator|==
name|PF_IN
operator|)
index|]
operator|->
name|addr
index|[
operator|(
name|s
operator|->
name|direction
operator|==
name|PF_OUT
operator|)
index|]
argument_list|,
name|pd
operator|.
name|af
argument_list|,
name|pd
operator|.
name|tot_len
argument_list|,
name|dir
operator|==
name|PF_OUT
argument_list|,
name|r
operator|->
name|action
operator|==
name|PF_PASS
argument_list|,
name|tr
operator|->
name|src
operator|.
name|neg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|dst
operator|.
name|addr
operator|.
name|type
operator|==
name|PF_ADDR_TABLE
condition|)
name|pfr_update_stats
argument_list|(
name|tr
operator|->
name|dst
operator|.
name|addr
operator|.
name|p
operator|.
name|tbl
argument_list|,
operator|(
name|s
operator|==
name|NULL
operator|)
condition|?
name|pd
operator|.
name|dst
else|:
operator|&
name|s
operator|->
name|key
index|[
operator|(
name|s
operator|->
name|direction
operator|==
name|PF_IN
operator|)
index|]
operator|->
name|addr
index|[
operator|(
name|s
operator|->
name|direction
operator|==
name|PF_IN
operator|)
index|]
argument_list|,
name|pd
operator|.
name|af
argument_list|,
name|pd
operator|.
name|tot_len
argument_list|,
name|dir
operator|==
name|PF_OUT
argument_list|,
name|r
operator|->
name|action
operator|==
name|PF_PASS
argument_list|,
name|tr
operator|->
name|dst
operator|.
name|neg
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|PF_SYNPROXY_DROP
case|:
name|m_freem
argument_list|(
operator|*
name|m0
argument_list|)
expr_stmt|;
case|case
name|PF_DEFER
case|:
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
name|action
operator|=
name|PF_PASS
expr_stmt|;
break|break;
case|case
name|PF_DROP
case|:
name|m_freem
argument_list|(
operator|*
name|m0
argument_list|)
expr_stmt|;
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
comment|/* pf_route() returns unlocked. */
if|if
condition|(
name|r
operator|->
name|rt
condition|)
block|{
name|pf_route
argument_list|(
name|m0
argument_list|,
name|r
argument_list|,
name|dir
argument_list|,
name|kif
operator|->
name|pfik_ifp
argument_list|,
name|s
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
break|break;
block|}
if|if
condition|(
name|s
condition|)
name|PF_STATE_UNLOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
name|int
name|pf_test6
parameter_list|(
name|int
name|dir
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|pfi_kif
modifier|*
name|kif
decl_stmt|;
name|u_short
name|action
decl_stmt|,
name|reason
init|=
literal|0
decl_stmt|,
name|log
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|,
modifier|*
name|n
init|=
name|NULL
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|a
init|=
name|NULL
decl_stmt|,
modifier|*
name|r
init|=
operator|&
name|V_pf_default_rule
decl_stmt|,
modifier|*
name|tr
decl_stmt|,
modifier|*
name|nr
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_pdesc
name|pd
decl_stmt|;
name|int
name|off
decl_stmt|,
name|terminal
init|=
literal|0
decl_stmt|,
name|dirndx
decl_stmt|,
name|rh_cnt
init|=
literal|0
decl_stmt|,
name|pqid
init|=
literal|0
decl_stmt|;
name|int
name|fwdir
init|=
name|dir
decl_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Detect packet forwarding. 	 * If the input interface is different from the output interface we're 	 * forwarding. 	 * We do need to be careful about bridges. If the 	 * net.link.bridge.pfil_bridge sysctl is set we can be filtering on a 	 * bridge, so if the input interface is a bridge member and the output 	 * interface is its bridge or a member of the same bridge we're not 	 * actually forwarding but bridging. 	 */
if|if
condition|(
name|dir
operator|==
name|PF_OUT
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|&&
name|ifp
operator|!=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_bridge
operator|==
name|NULL
operator|||
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_bridge
operator|!=
name|ifp
operator|->
name|if_softc
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_bridge
operator|!=
name|ifp
operator|->
name|if_bridge
operator|)
operator|)
condition|)
name|fwdir
operator|=
name|PF_FWD
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|PF_FWD
condition|)
name|dir
operator|=
name|PF_OUT
expr_stmt|;
if|if
condition|(
operator|!
name|V_pf_status
operator|.
name|running
condition|)
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|memset
argument_list|(
operator|&
name|pd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pd
argument_list|)
argument_list|)
expr_stmt|;
name|pd
operator|.
name|pf_mtag
operator|=
name|pf_find_mtag
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|.
name|pf_mtag
operator|&&
name|pd
operator|.
name|pf_mtag
operator|->
name|flags
operator|&
name|PF_TAG_GENERATED
condition|)
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|kif
operator|=
operator|(
expr|struct
name|pfi_kif
operator|*
operator|)
name|ifp
operator|->
name|if_pf_kif
expr_stmt|;
if|if
condition|(
name|kif
operator|==
name|NULL
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_URGENT
argument_list|,
operator|(
literal|"pf_test6: kif == NULL, if_xname %s\n"
operator|,
name|ifp
operator|->
name|if_xname
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
if|if
condition|(
name|kif
operator|->
name|pfik_flags
operator|&
name|PFI_IFLAG_SKIP
condition|)
return|return
operator|(
name|PF_PASS
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_SKIP_FIREWALL
condition|)
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
comment|/* We do IP header normalization and packet reassembly here */
if|if
condition|(
name|pf_normalize_ip6
argument_list|(
name|m0
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
operator|&
name|reason
argument_list|,
operator|&
name|pd
argument_list|)
operator|!=
name|PF_PASS
condition|)
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|m
operator|=
operator|*
name|m0
expr_stmt|;
comment|/* pf_normalize messes with m0 */
name|h
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* 	 * we do not support jumbogram yet.  if we keep going, zero ip6_plen 	 * will do something bad, so drop the packet for now. 	 */
if|if
condition|(
name|htons
argument_list|(
name|h
operator|->
name|ip6_plen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_NORM
argument_list|)
expr_stmt|;
comment|/*XXX*/
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
name|pd
operator|.
name|src
operator|=
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h
operator|->
name|ip6_src
expr_stmt|;
name|pd
operator|.
name|dst
operator|=
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h
operator|->
name|ip6_dst
expr_stmt|;
name|pd
operator|.
name|sport
operator|=
name|pd
operator|.
name|dport
operator|=
name|NULL
expr_stmt|;
name|pd
operator|.
name|ip_sum
operator|=
name|NULL
expr_stmt|;
name|pd
operator|.
name|proto_sum
operator|=
name|NULL
expr_stmt|;
name|pd
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
name|pd
operator|.
name|sidx
operator|=
operator|(
name|dir
operator|==
name|PF_IN
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|pd
operator|.
name|didx
operator|=
operator|(
name|dir
operator|==
name|PF_IN
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|pd
operator|.
name|af
operator|=
name|AF_INET6
expr_stmt|;
name|pd
operator|.
name|tos
operator|=
literal|0
expr_stmt|;
name|pd
operator|.
name|tot_len
operator|=
name|ntohs
argument_list|(
name|h
operator|->
name|ip6_plen
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
operator|(
name|caddr_t
operator|)
name|h
operator|-
name|m
operator|->
name|m_data
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|pd
operator|.
name|proto
operator|=
name|h
operator|->
name|ip6_nxt
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|pd
operator|.
name|proto
condition|)
block|{
case|case
name|IPPROTO_FRAGMENT
case|:
name|action
operator|=
name|pf_test_fragment
argument_list|(
operator|&
name|r
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|h
argument_list|,
operator|&
name|pd
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|ruleset
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|PF_DROP
condition|)
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_FRAG
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|IPPROTO_ROUTING
case|:
block|{
name|struct
name|ip6_rthdr
name|rthdr
decl_stmt|;
if|if
condition|(
name|rh_cnt
operator|++
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: IPv6 more than one rthdr\n"
operator|)
argument_list|)
expr_stmt|;
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_IPOPTIONS
argument_list|)
expr_stmt|;
name|log
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|rthdr
argument_list|,
sizeof|sizeof
argument_list|(
name|rthdr
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|reason
argument_list|,
name|pd
operator|.
name|af
argument_list|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: IPv6 short rthdr\n"
operator|)
argument_list|)
expr_stmt|;
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_SHORT
argument_list|)
expr_stmt|;
name|log
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|rthdr
operator|.
name|ip6r_type
operator|==
name|IPV6_RTHDR_TYPE_0
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: IPv6 rthdr0\n"
operator|)
argument_list|)
expr_stmt|;
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_IPOPTIONS
argument_list|)
expr_stmt|;
name|log
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* FALLTHROUGH */
block|}
case|case
name|IPPROTO_AH
case|:
case|case
name|IPPROTO_HOPOPTS
case|:
case|case
name|IPPROTO_DSTOPTS
case|:
block|{
comment|/* get next header and header length */
name|struct
name|ip6_ext
name|opt6
decl_stmt|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|opt6
argument_list|,
sizeof|sizeof
argument_list|(
name|opt6
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|reason
argument_list|,
name|pd
operator|.
name|af
argument_list|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: IPv6 short opt\n"
operator|)
argument_list|)
expr_stmt|;
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|log
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|pd
operator|.
name|proto
operator|==
name|IPPROTO_AH
condition|)
name|off
operator|+=
operator|(
name|opt6
operator|.
name|ip6e_len
operator|+
literal|2
operator|)
operator|*
literal|4
expr_stmt|;
else|else
name|off
operator|+=
operator|(
name|opt6
operator|.
name|ip6e_len
operator|+
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
name|pd
operator|.
name|proto
operator|=
name|opt6
operator|.
name|ip6e_nxt
expr_stmt|;
comment|/* goto the next header */
break|break;
block|}
default|default:
name|terminal
operator|++
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|terminal
condition|)
do|;
comment|/* if there's no routing header, use unmodified mbuf for checksumming */
if|if
condition|(
operator|!
name|n
condition|)
name|n
operator|=
name|m
expr_stmt|;
switch|switch
condition|(
name|pd
operator|.
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
block|{
name|struct
name|tcphdr
name|th
decl_stmt|;
name|pd
operator|.
name|hdr
operator|.
name|tcp
operator|=
operator|&
name|th
expr_stmt|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|th
argument_list|,
sizeof|sizeof
argument_list|(
name|th
argument_list|)
argument_list|,
operator|&
name|action
argument_list|,
operator|&
name|reason
argument_list|,
name|AF_INET6
argument_list|)
condition|)
block|{
name|log
operator|=
name|action
operator|!=
name|PF_PASS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|pd
operator|.
name|p_len
operator|=
name|pd
operator|.
name|tot_len
operator|-
name|off
operator|-
operator|(
name|th
operator|.
name|th_off
operator|<<
literal|2
operator|)
expr_stmt|;
name|action
operator|=
name|pf_normalize_tcp
argument_list|(
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|off
argument_list|,
name|h
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|PF_DROP
condition|)
goto|goto
name|done
goto|;
name|action
operator|=
name|pf_test_state_tcp
argument_list|(
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|h
argument_list|,
operator|&
name|pd
argument_list|,
operator|&
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|PF_PASS
condition|)
block|{
if|if
condition|(
name|pfsync_update_state_ptr
operator|!=
name|NULL
condition|)
name|pfsync_update_state_ptr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|r
operator|=
name|s
operator|->
name|rule
operator|.
name|ptr
expr_stmt|;
name|a
operator|=
name|s
operator|->
name|anchor
operator|.
name|ptr
expr_stmt|;
name|log
operator|=
name|s
operator|->
name|log
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|action
operator|=
name|pf_test_rule
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|pd
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|ruleset
argument_list|,
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IPPROTO_UDP
case|:
block|{
name|struct
name|udphdr
name|uh
decl_stmt|;
name|pd
operator|.
name|hdr
operator|.
name|udp
operator|=
operator|&
name|uh
expr_stmt|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|uh
argument_list|,
sizeof|sizeof
argument_list|(
name|uh
argument_list|)
argument_list|,
operator|&
name|action
argument_list|,
operator|&
name|reason
argument_list|,
name|AF_INET6
argument_list|)
condition|)
block|{
name|log
operator|=
name|action
operator|!=
name|PF_PASS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|uh
operator|.
name|uh_dport
operator|==
literal|0
operator|||
name|ntohs
argument_list|(
name|uh
operator|.
name|uh_ulen
argument_list|)
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|off
operator|||
name|ntohs
argument_list|(
name|uh
operator|.
name|uh_ulen
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
condition|)
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_SHORT
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|action
operator|=
name|pf_test_state_udp
argument_list|(
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|h
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|PF_PASS
condition|)
block|{
if|if
condition|(
name|pfsync_update_state_ptr
operator|!=
name|NULL
condition|)
name|pfsync_update_state_ptr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|r
operator|=
name|s
operator|->
name|rule
operator|.
name|ptr
expr_stmt|;
name|a
operator|=
name|s
operator|->
name|anchor
operator|.
name|ptr
expr_stmt|;
name|log
operator|=
name|s
operator|->
name|log
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|action
operator|=
name|pf_test_rule
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|pd
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|ruleset
argument_list|,
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IPPROTO_ICMP
case|:
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: dropping IPv6 packet with ICMPv4 payload\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
name|IPPROTO_ICMPV6
case|:
block|{
name|struct
name|icmp6_hdr
name|ih
decl_stmt|;
name|pd
operator|.
name|hdr
operator|.
name|icmp6
operator|=
operator|&
name|ih
expr_stmt|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|ih
argument_list|,
sizeof|sizeof
argument_list|(
name|ih
argument_list|)
argument_list|,
operator|&
name|action
argument_list|,
operator|&
name|reason
argument_list|,
name|AF_INET6
argument_list|)
condition|)
block|{
name|log
operator|=
name|action
operator|!=
name|PF_PASS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|action
operator|=
name|pf_test_state_icmp
argument_list|(
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|h
argument_list|,
operator|&
name|pd
argument_list|,
operator|&
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|PF_PASS
condition|)
block|{
if|if
condition|(
name|pfsync_update_state_ptr
operator|!=
name|NULL
condition|)
name|pfsync_update_state_ptr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|r
operator|=
name|s
operator|->
name|rule
operator|.
name|ptr
expr_stmt|;
name|a
operator|=
name|s
operator|->
name|anchor
operator|.
name|ptr
expr_stmt|;
name|log
operator|=
name|s
operator|->
name|log
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|action
operator|=
name|pf_test_rule
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|pd
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|ruleset
argument_list|,
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|action
operator|=
name|pf_test_state_other
argument_list|(
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|PF_PASS
condition|)
block|{
if|if
condition|(
name|pfsync_update_state_ptr
operator|!=
name|NULL
condition|)
name|pfsync_update_state_ptr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|r
operator|=
name|s
operator|->
name|rule
operator|.
name|ptr
expr_stmt|;
name|a
operator|=
name|s
operator|->
name|anchor
operator|.
name|ptr
expr_stmt|;
name|log
operator|=
name|s
operator|->
name|log
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|action
operator|=
name|pf_test_rule
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|s
argument_list|,
name|dir
argument_list|,
name|kif
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|pd
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|ruleset
argument_list|,
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
name|done
label|:
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|m
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* handle dangerous IPv6 extension headers. */
if|if
condition|(
name|action
operator|==
name|PF_PASS
operator|&&
name|rh_cnt
operator|&&
operator|!
operator|(
operator|(
name|s
operator|&&
name|s
operator|->
name|state_flags
operator|&
name|PFSTATE_ALLOWOPTS
operator|)
operator|||
name|r
operator|->
name|allow_opts
operator|)
condition|)
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_IPOPTIONS
argument_list|)
expr_stmt|;
name|log
operator|=
name|r
operator|->
name|log
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: dropping packet with dangerous v6 headers\n"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|&&
name|s
operator|->
name|tag
operator|>
literal|0
operator|&&
name|pf_tag_packet
argument_list|(
name|m
argument_list|,
operator|&
name|pd
argument_list|,
name|s
operator|->
name|tag
argument_list|)
condition|)
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|rtableid
operator|>=
literal|0
condition|)
name|M_SETFIB
argument_list|(
name|m
argument_list|,
name|r
operator|->
name|rtableid
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|scrub_flags
operator|&
name|PFSTATE_SETPRIO
condition|)
block|{
if|if
condition|(
name|pd
operator|.
name|tos
operator|&
name|IPTOS_LOWDELAY
condition|)
name|pqid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pf_ieee8021q_setpcp
argument_list|(
name|m
argument_list|,
name|r
operator|->
name|set_prio
index|[
name|pqid
index|]
argument_list|)
condition|)
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
name|log
operator|=
literal|1
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: failed to allocate 802.1q mtag\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ALTQ
if|if
condition|(
name|action
operator|==
name|PF_PASS
operator|&&
name|r
operator|->
name|qid
condition|)
block|{
if|if
condition|(
name|pd
operator|.
name|pf_mtag
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|pd
operator|.
name|pf_mtag
operator|=
name|pf_get_mtag
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|action
operator|=
name|PF_DROP
expr_stmt|;
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|pd
operator|.
name|pf_mtag
operator|->
name|qid_hash
operator|=
name|pf_state_hash
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|.
name|tos
operator|&
name|IPTOS_LOWDELAY
condition|)
name|pd
operator|.
name|pf_mtag
operator|->
name|qid
operator|=
name|r
operator|->
name|pqid
expr_stmt|;
else|else
name|pd
operator|.
name|pf_mtag
operator|->
name|qid
operator|=
name|r
operator|->
name|qid
expr_stmt|;
comment|/* Add hints for ecn. */
name|pd
operator|.
name|pf_mtag
operator|->
name|hdr
operator|=
name|h
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ALTQ */
if|if
condition|(
name|dir
operator|==
name|PF_IN
operator|&&
name|action
operator|==
name|PF_PASS
operator|&&
operator|(
name|pd
operator|.
name|proto
operator|==
name|IPPROTO_TCP
operator|||
name|pd
operator|.
name|proto
operator|==
name|IPPROTO_UDP
operator|)
operator|&&
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|action
operator|==
name|PF_RDR
operator|||
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|action
operator|==
name|PF_BINAT
operator|)
operator|&&
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|pd
operator|.
name|dst
operator|->
name|v6
argument_list|)
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_SKIP_FIREWALL
expr_stmt|;
comment|/* XXX: Anybody working on it?! */
if|if
condition|(
name|r
operator|->
name|divert
operator|.
name|port
condition|)
name|printf
argument_list|(
literal|"pf: divert(9) is not supported for IPv6\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
condition|)
block|{
name|struct
name|pf_rule
modifier|*
name|lr
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|log
operator|&
name|PF_LOG_ALL
condition|)
name|lr
operator|=
name|s
operator|->
name|nat_rule
operator|.
name|ptr
expr_stmt|;
else|else
name|lr
operator|=
name|r
expr_stmt|;
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|m
argument_list|,
name|AF_INET6
argument_list|,
name|dir
argument_list|,
name|reason
argument_list|,
name|lr
argument_list|,
name|a
argument_list|,
name|ruleset
argument_list|,
operator|&
name|pd
argument_list|,
operator|(
name|s
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
block|}
name|kif
operator|->
name|pfik_bytes
index|[
literal|1
index|]
index|[
name|dir
operator|==
name|PF_OUT
index|]
index|[
name|action
operator|!=
name|PF_PASS
index|]
operator|+=
name|pd
operator|.
name|tot_len
expr_stmt|;
name|kif
operator|->
name|pfik_packets
index|[
literal|1
index|]
index|[
name|dir
operator|==
name|PF_OUT
index|]
index|[
name|action
operator|!=
name|PF_PASS
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|PF_PASS
operator|||
name|r
operator|->
name|action
operator|==
name|PF_DROP
condition|)
block|{
name|dirndx
operator|=
operator|(
name|dir
operator|==
name|PF_OUT
operator|)
expr_stmt|;
name|r
operator|->
name|packets
index|[
name|dirndx
index|]
operator|++
expr_stmt|;
name|r
operator|->
name|bytes
index|[
name|dirndx
index|]
operator|+=
name|pd
operator|.
name|tot_len
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
name|a
operator|->
name|packets
index|[
name|dirndx
index|]
operator|++
expr_stmt|;
name|a
operator|->
name|bytes
index|[
name|dirndx
index|]
operator|+=
name|pd
operator|.
name|tot_len
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|packets
index|[
name|dirndx
index|]
operator|++
expr_stmt|;
name|s
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|bytes
index|[
name|dirndx
index|]
operator|+=
name|pd
operator|.
name|tot_len
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|src_node
operator|!=
name|NULL
condition|)
block|{
name|s
operator|->
name|src_node
operator|->
name|packets
index|[
name|dirndx
index|]
operator|++
expr_stmt|;
name|s
operator|->
name|src_node
operator|->
name|bytes
index|[
name|dirndx
index|]
operator|+=
name|pd
operator|.
name|tot_len
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|nat_src_node
operator|!=
name|NULL
condition|)
block|{
name|s
operator|->
name|nat_src_node
operator|->
name|packets
index|[
name|dirndx
index|]
operator|++
expr_stmt|;
name|s
operator|->
name|nat_src_node
operator|->
name|bytes
index|[
name|dirndx
index|]
operator|+=
name|pd
operator|.
name|tot_len
expr_stmt|;
block|}
name|dirndx
operator|=
operator|(
name|dir
operator|==
name|s
operator|->
name|direction
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|s
operator|->
name|packets
index|[
name|dirndx
index|]
operator|++
expr_stmt|;
name|s
operator|->
name|bytes
index|[
name|dirndx
index|]
operator|+=
name|pd
operator|.
name|tot_len
expr_stmt|;
block|}
name|tr
operator|=
name|r
expr_stmt|;
name|nr
operator|=
operator|(
name|s
operator|!=
name|NULL
operator|)
condition|?
name|s
operator|->
name|nat_rule
operator|.
name|ptr
else|:
name|pd
operator|.
name|nat_rule
expr_stmt|;
if|if
condition|(
name|nr
operator|!=
name|NULL
operator|&&
name|r
operator|==
operator|&
name|V_pf_default_rule
condition|)
name|tr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|src
operator|.
name|addr
operator|.
name|type
operator|==
name|PF_ADDR_TABLE
condition|)
name|pfr_update_stats
argument_list|(
name|tr
operator|->
name|src
operator|.
name|addr
operator|.
name|p
operator|.
name|tbl
argument_list|,
operator|(
name|s
operator|==
name|NULL
operator|)
condition|?
name|pd
operator|.
name|src
else|:
operator|&
name|s
operator|->
name|key
index|[
operator|(
name|s
operator|->
name|direction
operator|==
name|PF_IN
operator|)
index|]
operator|->
name|addr
index|[
literal|0
index|]
argument_list|,
name|pd
operator|.
name|af
argument_list|,
name|pd
operator|.
name|tot_len
argument_list|,
name|dir
operator|==
name|PF_OUT
argument_list|,
name|r
operator|->
name|action
operator|==
name|PF_PASS
argument_list|,
name|tr
operator|->
name|src
operator|.
name|neg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|dst
operator|.
name|addr
operator|.
name|type
operator|==
name|PF_ADDR_TABLE
condition|)
name|pfr_update_stats
argument_list|(
name|tr
operator|->
name|dst
operator|.
name|addr
operator|.
name|p
operator|.
name|tbl
argument_list|,
operator|(
name|s
operator|==
name|NULL
operator|)
condition|?
name|pd
operator|.
name|dst
else|:
operator|&
name|s
operator|->
name|key
index|[
operator|(
name|s
operator|->
name|direction
operator|==
name|PF_IN
operator|)
index|]
operator|->
name|addr
index|[
literal|1
index|]
argument_list|,
name|pd
operator|.
name|af
argument_list|,
name|pd
operator|.
name|tot_len
argument_list|,
name|dir
operator|==
name|PF_OUT
argument_list|,
name|r
operator|->
name|action
operator|==
name|PF_PASS
argument_list|,
name|tr
operator|->
name|dst
operator|.
name|neg
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|PF_SYNPROXY_DROP
case|:
name|m_freem
argument_list|(
operator|*
name|m0
argument_list|)
expr_stmt|;
case|case
name|PF_DEFER
case|:
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
name|action
operator|=
name|PF_PASS
expr_stmt|;
break|break;
case|case
name|PF_DROP
case|:
name|m_freem
argument_list|(
operator|*
name|m0
argument_list|)
expr_stmt|;
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
comment|/* pf_route6() returns unlocked. */
if|if
condition|(
name|r
operator|->
name|rt
condition|)
block|{
name|pf_route6
argument_list|(
name|m0
argument_list|,
name|r
argument_list|,
name|dir
argument_list|,
name|kif
operator|->
name|pfik_ifp
argument_list|,
name|s
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
break|break;
block|}
if|if
condition|(
name|s
condition|)
name|PF_STATE_UNLOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* If reassembled packet passed, create new fragments. */
if|if
condition|(
name|action
operator|==
name|PF_PASS
operator|&&
operator|*
name|m0
operator|&&
name|fwdir
operator|==
name|PF_FWD
operator|&&
operator|(
name|mtag
operator|=
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PF_REASSEMBLED
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|action
operator|=
name|pf_refragment6
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

end_unit

