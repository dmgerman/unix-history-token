begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: pf_ioctl.c,v 1.213 2009/02/15 21:46:12 mbalmer Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2001 Daniel Hartmeier  * Copyright (c) 2002,2003 Henning Brauer  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *    - Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *    - Redistributions in binary form must reproduce the above  *      copyright notice, this list of conditions and the following  *      disclaimer in the documentation and/or other materials provided  *      with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * Effort sponsored in part by the Defense Advanced Research Projects  * Agency (DARPA) and Air Force Research Laboratory, Air Force  * Materiel Command, USAF, under agreement number F30602-01-2-0537.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_bpf.h"
end_include

begin_include
include|#
directive|include
file|"opt_pf.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/md5.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/pfil.h>
end_include

begin_include
include|#
directive|include
file|<net/pfvar.h>
end_include

begin_include
include|#
directive|include
file|<net/if_pfsync.h>
end_include

begin_include
include|#
directive|include
file|<net/if_pflog.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ
end_ifdef

begin_include
include|#
directive|include
file|<altq/altq.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|pfattach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pf_pool
modifier|*
name|pf_get_pool
parameter_list|(
name|char
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_mv_pool
parameter_list|(
name|struct
name|pf_palist
modifier|*
parameter_list|,
name|struct
name|pf_palist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_empty_pool
parameter_list|(
name|struct
name|pf_palist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pfioctl
parameter_list|(
name|struct
name|cdev
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ
end_ifdef

begin_function_decl
specifier|static
name|int
name|pf_begin_altq
parameter_list|(
name|u_int32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_rollback_altq
parameter_list|(
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_commit_altq
parameter_list|(
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_enable_altq
parameter_list|(
name|struct
name|pf_altq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_disable_altq
parameter_list|(
name|struct
name|pf_altq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|pf_qname2qid
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_qid_unref
parameter_list|(
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ */
end_comment

begin_function_decl
specifier|static
name|int
name|pf_begin_rules
parameter_list|(
name|u_int32_t
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_rollback_rules
parameter_list|(
name|u_int32_t
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_setup_pfsync_matching
parameter_list|(
name|struct
name|pf_ruleset
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_hash_rule
parameter_list|(
name|MD5_CTX
modifier|*
parameter_list|,
name|struct
name|pf_rule
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_hash_rule_addr
parameter_list|(
name|MD5_CTX
modifier|*
parameter_list|,
name|struct
name|pf_rule_addr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_commit_rules
parameter_list|(
name|u_int32_t
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_addr_setup
parameter_list|(
name|struct
name|pf_ruleset
modifier|*
parameter_list|,
name|struct
name|pf_addr_wrap
modifier|*
parameter_list|,
name|sa_family_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_addr_copyout
parameter_list|(
name|struct
name|pf_addr_wrap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_rule
argument_list|,
name|pf_default_rule
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ
end_ifdef

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|pf_altq_running
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_altq_running
value|VNET(pf_altq_running)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TAGID_MAX
value|50000
end_define

begin_struct
struct|struct
name|pf_tagname
block|{
name|TAILQ_ENTRY
argument_list|(
argument|pf_tagname
argument_list|)
name|entries
expr_stmt|;
name|char
name|name
index|[
name|PF_TAG_NAME_SIZE
index|]
decl_stmt|;
name|uint16_t
name|tag
decl_stmt|;
name|int
name|ref
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|pf_tags
argument_list|,
name|pf_tagname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_tags
value|VNET(pf_tags)
end_define

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_tags
argument_list|,
name|pf_tags
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_qids
value|VNET(pf_qids)
end_define

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_tags
argument_list|,
name|pf_qids
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_PFTAG
argument_list|,
literal|"pf_tag"
argument_list|,
literal|"pf(4) tag names"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_PFALTQ
argument_list|,
literal|"pf_altq"
argument_list|,
literal|"pf(4) altq configuration db"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_PFRULE
argument_list|,
literal|"pf_rule"
argument_list|,
literal|"pf(4) rules"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
operator|(
name|PF_QNAME_SIZE
operator|!=
name|PF_TAG_NAME_SIZE
operator|)
end_if

begin_error
error|#
directive|error
error|PF_QNAME_SIZE must be equal to PF_TAG_NAME_SIZE
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|u_int16_t
name|tagname2tag
parameter_list|(
name|struct
name|pf_tags
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|pf_tagname2tag
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tag_unref
parameter_list|(
name|struct
name|pf_tags
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DPFPRINTF
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (V_pf_status.debug>= (n)) printf x
end_define

begin_decl_stmt
name|struct
name|cdev
modifier|*
name|pf_dev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX - These are new and need to be checked when moveing to a new version  */
end_comment

begin_function_decl
specifier|static
name|void
name|pf_clear_states
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_clear_tables
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_clear_srcnodes
parameter_list|(
name|struct
name|pf_src_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_tbladdr_copyout
parameter_list|(
name|struct
name|pf_addr_wrap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Wrapper functions for pfil(9) hooks  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function_decl
specifier|static
name|int
name|pf_check_in
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_check_out
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function_decl
specifier|static
name|int
name|pf_check6_in
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_check6_out
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|hook_pf
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dehook_pf
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|shutdown_pf
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_load
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_unload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|pf_cdevsw
init|=
block|{
operator|.
name|d_ioctl
operator|=
name|pfioctl
block|,
operator|.
name|d_name
operator|=
name|PF_NAME
block|,
operator|.
name|d_version
operator|=
name|D_VERSION
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
specifier|volatile
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|pf_pfil_hooked
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_pfil_hooked
value|VNET(pf_pfil_hooked)
end_define

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|pf_end_threads
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|rwlock
name|pf_rules_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pfsync */
end_comment

begin_decl_stmt
name|pfsync_state_import_t
modifier|*
name|pfsync_state_import_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pfsync_insert_state_t
modifier|*
name|pfsync_insert_state_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pfsync_update_state_t
modifier|*
name|pfsync_update_state_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pfsync_delete_state_t
modifier|*
name|pfsync_delete_state_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pfsync_clear_states_t
modifier|*
name|pfsync_clear_states_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pfsync_defer_t
modifier|*
name|pfsync_defer_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pflog */
end_comment

begin_decl_stmt
name|pflog_packet_t
modifier|*
name|pflog_packet_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|pfattach
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|my_timeout
init|=
name|V_pf_default_rule
operator|.
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pf_initialize
argument_list|()
expr_stmt|;
name|pfr_initialize
argument_list|()
expr_stmt|;
name|pfi_initialize
argument_list|()
expr_stmt|;
name|pf_normalize_init
argument_list|()
expr_stmt|;
name|V_pf_limits
index|[
name|PF_LIMIT_STATES
index|]
operator|.
name|limit
operator|=
name|PFSTATE_HIWAT
expr_stmt|;
name|V_pf_limits
index|[
name|PF_LIMIT_SRC_NODES
index|]
operator|.
name|limit
operator|=
name|PFSNODE_HIWAT
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|V_pf_anchors
argument_list|)
expr_stmt|;
name|pf_init_ruleset
argument_list|(
operator|&
name|pf_main_ruleset
argument_list|)
expr_stmt|;
comment|/* default rule should never be garbage collected */
name|V_pf_default_rule
operator|.
name|entries
operator|.
name|tqe_prev
operator|=
operator|&
name|V_pf_default_rule
operator|.
name|entries
operator|.
name|tqe_next
expr_stmt|;
ifdef|#
directive|ifdef
name|PF_DEFAULT_TO_DROP
name|V_pf_default_rule
operator|.
name|action
operator|=
name|PF_DROP
expr_stmt|;
else|#
directive|else
name|V_pf_default_rule
operator|.
name|action
operator|=
name|PF_PASS
expr_stmt|;
endif|#
directive|endif
name|V_pf_default_rule
operator|.
name|nr
operator|=
operator|-
literal|1
expr_stmt|;
name|V_pf_default_rule
operator|.
name|rtableid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* initialize default timeouts */
name|my_timeout
index|[
name|PFTM_TCP_FIRST_PACKET
index|]
operator|=
name|PFTM_TCP_FIRST_PACKET_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_TCP_OPENING
index|]
operator|=
name|PFTM_TCP_OPENING_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_TCP_ESTABLISHED
index|]
operator|=
name|PFTM_TCP_ESTABLISHED_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_TCP_CLOSING
index|]
operator|=
name|PFTM_TCP_CLOSING_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_TCP_FIN_WAIT
index|]
operator|=
name|PFTM_TCP_FIN_WAIT_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_TCP_CLOSED
index|]
operator|=
name|PFTM_TCP_CLOSED_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_UDP_FIRST_PACKET
index|]
operator|=
name|PFTM_UDP_FIRST_PACKET_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_UDP_SINGLE
index|]
operator|=
name|PFTM_UDP_SINGLE_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_UDP_MULTIPLE
index|]
operator|=
name|PFTM_UDP_MULTIPLE_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_ICMP_FIRST_PACKET
index|]
operator|=
name|PFTM_ICMP_FIRST_PACKET_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_ICMP_ERROR_REPLY
index|]
operator|=
name|PFTM_ICMP_ERROR_REPLY_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_OTHER_FIRST_PACKET
index|]
operator|=
name|PFTM_OTHER_FIRST_PACKET_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_OTHER_SINGLE
index|]
operator|=
name|PFTM_OTHER_SINGLE_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_OTHER_MULTIPLE
index|]
operator|=
name|PFTM_OTHER_MULTIPLE_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_FRAG
index|]
operator|=
name|PFTM_FRAG_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_INTERVAL
index|]
operator|=
name|PFTM_INTERVAL_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_SRC_NODE
index|]
operator|=
name|PFTM_SRC_NODE_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_TS_DIFF
index|]
operator|=
name|PFTM_TS_DIFF_VAL
expr_stmt|;
name|my_timeout
index|[
name|PFTM_ADAPTIVE_START
index|]
operator|=
name|PFSTATE_ADAPT_START
expr_stmt|;
name|my_timeout
index|[
name|PFTM_ADAPTIVE_END
index|]
operator|=
name|PFSTATE_ADAPT_END
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|V_pf_status
argument_list|,
sizeof|sizeof
argument_list|(
name|V_pf_status
argument_list|)
argument_list|)
expr_stmt|;
name|V_pf_status
operator|.
name|debug
operator|=
name|PF_DEBUG_URGENT
expr_stmt|;
name|V_pf_pfil_hooked
operator|=
literal|0
expr_stmt|;
comment|/* XXX do our best to avoid a conflict */
name|V_pf_status
operator|.
name|hostid
operator|=
name|arc4random
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|kproc_create
argument_list|(
name|pf_purge_thread
argument_list|,
name|curvnet
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pf purge"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
comment|/* XXXGL: leaked all above. */
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|swi_add
argument_list|(
name|NULL
argument_list|,
literal|"pf send"
argument_list|,
name|pf_intr
argument_list|,
name|curvnet
argument_list|,
name|SWI_NET
argument_list|,
name|INTR_MPSAFE
argument_list|,
operator|&
name|V_pf_swi_cookie
argument_list|)
operator|)
operator|!=
literal|0
condition|)
comment|/* XXXGL: leaked all above. */
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pf_pool
modifier|*
name|pf_get_pool
parameter_list|(
name|char
modifier|*
name|anchor
parameter_list|,
name|u_int32_t
name|ticket
parameter_list|,
name|u_int8_t
name|rule_action
parameter_list|,
name|u_int32_t
name|rule_number
parameter_list|,
name|u_int8_t
name|r_last
parameter_list|,
name|u_int8_t
name|active
parameter_list|,
name|u_int8_t
name|check_ticket
parameter_list|)
block|{
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|int
name|rs_num
decl_stmt|;
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|rule_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|active
condition|)
block|{
if|if
condition|(
name|check_ticket
operator|&&
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|r_last
condition|)
name|rule
operator|=
name|TAILQ_LAST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|pf_rulequeue
argument_list|)
expr_stmt|;
else|else
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|check_ticket
operator|&&
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|r_last
condition|)
name|rule
operator|=
name|TAILQ_LAST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|,
name|pf_rulequeue
argument_list|)
expr_stmt|;
else|else
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|r_last
condition|)
block|{
while|while
condition|(
operator|(
name|rule
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|rule
operator|->
name|nr
operator|!=
name|rule_number
operator|)
condition|)
name|rule
operator|=
name|TAILQ_NEXT
argument_list|(
name|rule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|rule
operator|->
name|rpool
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pf_mv_pool
parameter_list|(
name|struct
name|pf_palist
modifier|*
name|poola
parameter_list|,
name|struct
name|pf_palist
modifier|*
name|poolb
parameter_list|)
block|{
name|struct
name|pf_pooladdr
modifier|*
name|mv_pool_pa
decl_stmt|;
while|while
condition|(
operator|(
name|mv_pool_pa
operator|=
name|TAILQ_FIRST
argument_list|(
name|poola
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|poola
argument_list|,
name|mv_pool_pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|poolb
argument_list|,
name|mv_pool_pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pf_empty_pool
parameter_list|(
name|struct
name|pf_palist
modifier|*
name|poola
parameter_list|)
block|{
name|struct
name|pf_pooladdr
modifier|*
name|pa
decl_stmt|;
while|while
condition|(
operator|(
name|pa
operator|=
name|TAILQ_FIRST
argument_list|(
name|poola
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|pa
operator|->
name|addr
operator|.
name|type
condition|)
block|{
case|case
name|PF_ADDR_DYNIFTL
case|:
name|pfi_dynaddr_remove
argument_list|(
name|pa
operator|->
name|addr
operator|.
name|p
operator|.
name|dyn
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_ADDR_TABLE
case|:
name|pfr_detach_table
argument_list|(
name|pa
operator|->
name|addr
operator|.
name|p
operator|.
name|tbl
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pa
operator|->
name|kif
condition|)
name|pfi_kif_unref
argument_list|(
name|pa
operator|->
name|kif
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|poola
argument_list|,
name|pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pa
argument_list|,
name|M_PFRULE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pf_unlink_rule
parameter_list|(
name|struct
name|pf_rulequeue
modifier|*
name|rulequeue
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|rule
parameter_list|)
block|{
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|rulequeue
argument_list|,
name|rule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|PF_UNLNKDRULES_LOCK
argument_list|()
expr_stmt|;
name|rule
operator|->
name|rule_flag
operator||=
name|PFRULE_REFS
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|V_pf_unlinked_rules
argument_list|,
name|rule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|PF_UNLNKDRULES_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pf_free_rule
parameter_list|(
name|struct
name|pf_rule
modifier|*
name|rule
parameter_list|)
block|{
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|tag
condition|)
name|tag_unref
argument_list|(
operator|&
name|V_pf_tags
argument_list|,
name|rule
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|match_tag
condition|)
name|tag_unref
argument_list|(
operator|&
name|V_pf_tags
argument_list|,
name|rule
operator|->
name|match_tag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ
if|if
condition|(
name|rule
operator|->
name|pqid
operator|!=
name|rule
operator|->
name|qid
condition|)
name|pf_qid_unref
argument_list|(
name|rule
operator|->
name|pqid
argument_list|)
expr_stmt|;
name|pf_qid_unref
argument_list|(
name|rule
operator|->
name|qid
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|rule
operator|->
name|src
operator|.
name|addr
operator|.
name|type
condition|)
block|{
case|case
name|PF_ADDR_DYNIFTL
case|:
name|pfi_dynaddr_remove
argument_list|(
name|rule
operator|->
name|src
operator|.
name|addr
operator|.
name|p
operator|.
name|dyn
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_ADDR_TABLE
case|:
name|pfr_detach_table
argument_list|(
name|rule
operator|->
name|src
operator|.
name|addr
operator|.
name|p
operator|.
name|tbl
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|rule
operator|->
name|dst
operator|.
name|addr
operator|.
name|type
condition|)
block|{
case|case
name|PF_ADDR_DYNIFTL
case|:
name|pfi_dynaddr_remove
argument_list|(
name|rule
operator|->
name|dst
operator|.
name|addr
operator|.
name|p
operator|.
name|dyn
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_ADDR_TABLE
case|:
name|pfr_detach_table
argument_list|(
name|rule
operator|->
name|dst
operator|.
name|addr
operator|.
name|p
operator|.
name|tbl
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rule
operator|->
name|overload_tbl
condition|)
name|pfr_detach_table
argument_list|(
name|rule
operator|->
name|overload_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|kif
condition|)
name|pfi_kif_unref
argument_list|(
name|rule
operator|->
name|kif
argument_list|)
expr_stmt|;
name|pf_anchor_remove
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|pf_empty_pool
argument_list|(
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rule
argument_list|,
name|M_PFRULE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|tagname2tag
parameter_list|(
name|struct
name|pf_tags
modifier|*
name|head
parameter_list|,
name|char
modifier|*
name|tagname
parameter_list|)
block|{
name|struct
name|pf_tagname
modifier|*
name|tag
decl_stmt|,
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|u_int16_t
name|new_tagid
init|=
literal|1
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tag
argument_list|,
argument|head
argument_list|,
argument|entries
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|tagname
argument_list|,
name|tag
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tag
operator|->
name|ref
operator|++
expr_stmt|;
return|return
operator|(
name|tag
operator|->
name|tag
operator|)
return|;
block|}
comment|/* 	 * to avoid fragmentation, we do a linear search from the beginning 	 * and take the first free slot we find. if there is none or the list 	 * is empty, append a new entry at the end. 	 */
comment|/* new entry */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
name|head
argument_list|)
condition|)
for|for
control|(
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
name|head
argument_list|)
init|;
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|tag
operator|==
name|new_tagid
condition|;
name|p
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|entries
argument_list|)
control|)
name|new_tagid
operator|=
name|p
operator|->
name|tag
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|new_tagid
operator|>
name|TAGID_MAX
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* allocate and fill new struct pf_tagname */
name|tag
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tag
argument_list|)
argument_list|,
name|M_PFTAG
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|strlcpy
argument_list|(
name|tag
operator|->
name|name
argument_list|,
name|tagname
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|tag
operator|->
name|tag
operator|=
name|new_tagid
expr_stmt|;
name|tag
operator|->
name|ref
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
comment|/* insert new entry before p */
name|TAILQ_INSERT_BEFORE
argument_list|(
name|p
argument_list|,
name|tag
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
comment|/* either list empty or no free slot in between */
name|TAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|tag
argument_list|,
name|entries
argument_list|)
expr_stmt|;
return|return
operator|(
name|tag
operator|->
name|tag
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tag_unref
parameter_list|(
name|struct
name|pf_tags
modifier|*
name|head
parameter_list|,
name|u_int16_t
name|tag
parameter_list|)
block|{
name|struct
name|pf_tagname
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
name|head
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|p
operator|->
name|tag
condition|)
block|{
if|if
condition|(
operator|--
name|p
operator|->
name|ref
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|head
argument_list|,
name|p
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|,
name|M_PFTAG
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|pf_tagname2tag
parameter_list|(
name|char
modifier|*
name|tagname
parameter_list|)
block|{
return|return
operator|(
name|tagname2tag
argument_list|(
operator|&
name|V_pf_tags
argument_list|,
name|tagname
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ
end_ifdef

begin_function
specifier|static
name|u_int32_t
name|pf_qname2qid
parameter_list|(
name|char
modifier|*
name|qname
parameter_list|)
block|{
return|return
operator|(
operator|(
name|u_int32_t
operator|)
name|tagname2tag
argument_list|(
operator|&
name|V_pf_qids
argument_list|,
name|qname
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pf_qid_unref
parameter_list|(
name|u_int32_t
name|qid
parameter_list|)
block|{
name|tag_unref
argument_list|(
operator|&
name|V_pf_qids
argument_list|,
operator|(
name|u_int16_t
operator|)
name|qid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_begin_altq
parameter_list|(
name|u_int32_t
modifier|*
name|ticket
parameter_list|)
block|{
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
comment|/* Purge the old altq list */
while|while
condition|(
operator|(
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|V_pf_altqs_inactive
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|V_pf_altqs_inactive
argument_list|,
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|(
name|altq
operator|->
name|local_flags
operator|&
name|PFALTQ_FLAG_IF_REMOVED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* detach and destroy the discipline */
name|error
operator|=
name|altq_remove
argument_list|(
name|altq
argument_list|)
expr_stmt|;
block|}
else|else
name|pf_qid_unref
argument_list|(
name|altq
operator|->
name|qid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|altq
argument_list|,
name|M_PFALTQ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|ticket
operator|=
operator|++
name|V_ticket_altqs_inactive
expr_stmt|;
name|V_altqs_inactive_open
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_rollback_altq
parameter_list|(
name|u_int32_t
name|ticket
parameter_list|)
block|{
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|V_altqs_inactive_open
operator|||
name|ticket
operator|!=
name|V_ticket_altqs_inactive
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Purge the old altq list */
while|while
condition|(
operator|(
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|V_pf_altqs_inactive
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|V_pf_altqs_inactive
argument_list|,
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|(
name|altq
operator|->
name|local_flags
operator|&
name|PFALTQ_FLAG_IF_REMOVED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* detach and destroy the discipline */
name|error
operator|=
name|altq_remove
argument_list|(
name|altq
argument_list|)
expr_stmt|;
block|}
else|else
name|pf_qid_unref
argument_list|(
name|altq
operator|->
name|qid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|altq
argument_list|,
name|M_PFALTQ
argument_list|)
expr_stmt|;
block|}
name|V_altqs_inactive_open
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_commit_altq
parameter_list|(
name|u_int32_t
name|ticket
parameter_list|)
block|{
name|struct
name|pf_altqqueue
modifier|*
name|old_altqs
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|int
name|err
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|V_altqs_inactive_open
operator|||
name|ticket
operator|!=
name|V_ticket_altqs_inactive
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* swap altqs, keep the old. */
name|old_altqs
operator|=
name|V_pf_altqs_active
expr_stmt|;
name|V_pf_altqs_active
operator|=
name|V_pf_altqs_inactive
expr_stmt|;
name|V_pf_altqs_inactive
operator|=
name|old_altqs
expr_stmt|;
name|V_ticket_altqs_active
operator|=
name|V_ticket_altqs_inactive
expr_stmt|;
comment|/* Attach new disciplines */
name|TAILQ_FOREACH
argument_list|(
argument|altq
argument_list|,
argument|V_pf_altqs_active
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|(
name|altq
operator|->
name|local_flags
operator|&
name|PFALTQ_FLAG_IF_REMOVED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* attach the discipline */
name|error
operator|=
name|altq_pfattach
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|V_pf_altq_running
condition|)
name|error
operator|=
name|pf_enable_altq
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Purge the old altq list */
while|while
condition|(
operator|(
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|V_pf_altqs_inactive
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|V_pf_altqs_inactive
argument_list|,
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|(
name|altq
operator|->
name|local_flags
operator|&
name|PFALTQ_FLAG_IF_REMOVED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* detach and destroy the discipline */
if|if
condition|(
name|V_pf_altq_running
condition|)
name|error
operator|=
name|pf_disable_altq
argument_list|(
name|altq
argument_list|)
expr_stmt|;
name|err
operator|=
name|altq_pfdetach
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|err
expr_stmt|;
name|err
operator|=
name|altq_remove
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|err
expr_stmt|;
block|}
else|else
name|pf_qid_unref
argument_list|(
name|altq
operator|->
name|qid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|altq
argument_list|,
name|M_PFALTQ
argument_list|)
expr_stmt|;
block|}
name|V_altqs_inactive_open
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_enable_altq
parameter_list|(
name|struct
name|pf_altq
modifier|*
name|altq
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|tb_profile
name|tb
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|ifunit
argument_list|(
name|altq
operator|->
name|ifname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|altq_type
operator|!=
name|ALTQT_NONE
condition|)
name|error
operator|=
name|altq_enable
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* set tokenbucket regulator */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|ifp
operator|!=
name|NULL
operator|&&
name|ALTQ_IS_ENABLED
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|tb
operator|.
name|rate
operator|=
name|altq
operator|->
name|ifbandwidth
expr_stmt|;
name|tb
operator|.
name|depth
operator|=
name|altq
operator|->
name|tbrsize
expr_stmt|;
name|error
operator|=
name|tbr_set
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
operator|&
name|tb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_disable_altq
parameter_list|(
name|struct
name|pf_altq
modifier|*
name|altq
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|tb_profile
name|tb
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|ifunit
argument_list|(
name|altq
operator|->
name|ifname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * when the discipline is no longer referenced, it was overridden 	 * by a new one.  if so, just return. 	 */
if|if
condition|(
name|altq
operator|->
name|altq_disc
operator|!=
name|ifp
operator|->
name|if_snd
operator|.
name|altq_disc
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|altq_disable
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* clear tokenbucket regulator */
name|tb
operator|.
name|rate
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|tbr_set
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
operator|&
name|tb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pf_altq_ifnet_event
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|remove
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp1
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|,
modifier|*
name|a3
decl_stmt|;
name|u_int32_t
name|ticket
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Interrupt userland queue modifications */
if|if
condition|(
name|V_altqs_inactive_open
condition|)
name|pf_rollback_altq
argument_list|(
name|V_ticket_altqs_inactive
argument_list|)
expr_stmt|;
comment|/* Start new altq ruleset */
if|if
condition|(
name|pf_begin_altq
argument_list|(
operator|&
name|ticket
argument_list|)
condition|)
return|return;
comment|/* Copy the current active set */
name|TAILQ_FOREACH
argument_list|(
argument|a1
argument_list|,
argument|V_pf_altqs_active
argument_list|,
argument|entries
argument_list|)
block|{
name|a2
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|a2
argument_list|)
argument_list|,
name|M_PFALTQ
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|a2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_altq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a2
operator|->
name|qname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|a2
operator|->
name|qid
operator|=
name|pf_qname2qid
argument_list|(
name|a2
operator|->
name|qname
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|free
argument_list|(
name|a2
argument_list|,
name|M_PFALTQ
argument_list|)
expr_stmt|;
break|break;
block|}
name|a2
operator|->
name|altq_disc
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|a3
argument_list|,
argument|V_pf_altqs_inactive
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|a3
operator|->
name|ifname
argument_list|,
name|a2
operator|->
name|ifname
argument_list|,
name|IFNAMSIZ
argument_list|)
operator|==
literal|0
operator|&&
name|a3
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|a2
operator|->
name|altq_disc
operator|=
name|a3
operator|->
name|altq_disc
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Deactivate the interface in question */
name|a2
operator|->
name|local_flags
operator|&=
operator|~
name|PFALTQ_FLAG_IF_REMOVED
expr_stmt|;
if|if
condition|(
operator|(
name|ifp1
operator|=
name|ifunit
argument_list|(
name|a2
operator|->
name|ifname
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|remove
operator|&&
name|ifp1
operator|==
name|ifp
operator|)
condition|)
block|{
name|a2
operator|->
name|local_flags
operator||=
name|PFALTQ_FLAG_IF_REMOVED
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|altq_add
argument_list|(
name|a2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ticket
operator|!=
name|V_ticket_altqs_inactive
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|a2
argument_list|,
name|M_PFALTQ
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
name|V_pf_altqs_inactive
argument_list|,
name|a2
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|pf_rollback_altq
argument_list|(
name|ticket
argument_list|)
expr_stmt|;
else|else
name|pf_commit_altq
argument_list|(
name|ticket
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ */
end_comment

begin_function
specifier|static
name|int
name|pf_begin_rules
parameter_list|(
name|u_int32_t
modifier|*
name|ticket
parameter_list|,
name|int
name|rs_num
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor
parameter_list|)
block|{
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|rs_num
operator|<
literal|0
operator|||
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rs
operator|=
name|pf_find_or_create_ruleset
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
while|while
condition|(
operator|(
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pf_unlink_rule
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|rcount
operator|--
expr_stmt|;
block|}
operator|*
name|ticket
operator|=
operator|++
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|open
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_rollback_rules
parameter_list|(
name|u_int32_t
name|ticket
parameter_list|,
name|int
name|rs_num
parameter_list|,
name|char
modifier|*
name|anchor
parameter_list|)
block|{
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|rs_num
operator|<
literal|0
operator|||
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rs
operator|=
name|pf_find_ruleset
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NULL
operator|||
operator|!
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|open
operator|||
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
operator|!=
name|ticket
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|(
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pf_unlink_rule
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|rcount
operator|--
expr_stmt|;
block|}
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|open
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PF_MD5_UPD
parameter_list|(
name|st
parameter_list|,
name|elm
parameter_list|)
define|\
value|MD5Update(ctx, (u_int8_t *)&(st)->elm, sizeof((st)->elm))
end_define

begin_define
define|#
directive|define
name|PF_MD5_UPD_STR
parameter_list|(
name|st
parameter_list|,
name|elm
parameter_list|)
define|\
value|MD5Update(ctx, (u_int8_t *) (st)->elm, strlen((st)->elm))
end_define

begin_define
define|#
directive|define
name|PF_MD5_UPD_HTONL
parameter_list|(
name|st
parameter_list|,
name|elm
parameter_list|,
name|stor
parameter_list|)
value|do {				\ 		(stor) = htonl((st)->elm);				\ 		MD5Update(ctx, (u_int8_t *)&(stor), sizeof(u_int32_t));\ } while (0)
end_define

begin_define
define|#
directive|define
name|PF_MD5_UPD_HTONS
parameter_list|(
name|st
parameter_list|,
name|elm
parameter_list|,
name|stor
parameter_list|)
value|do {				\ 		(stor) = htons((st)->elm);				\ 		MD5Update(ctx, (u_int8_t *)&(stor), sizeof(u_int16_t));\ } while (0)
end_define

begin_function
specifier|static
name|void
name|pf_hash_rule_addr
parameter_list|(
name|MD5_CTX
modifier|*
name|ctx
parameter_list|,
name|struct
name|pf_rule_addr
modifier|*
name|pfr
parameter_list|)
block|{
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|addr
operator|.
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pfr
operator|->
name|addr
operator|.
name|type
condition|)
block|{
case|case
name|PF_ADDR_DYNIFTL
case|:
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|addr
operator|.
name|v
operator|.
name|ifname
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|addr
operator|.
name|iflags
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_ADDR_TABLE
case|:
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|addr
operator|.
name|v
operator|.
name|tblname
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_ADDR_ADDRMASK
case|:
comment|/* XXX ignore af? */
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
operator|.
name|addr32
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
operator|.
name|addr32
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|port
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|port
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|neg
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|port_op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pf_hash_rule
parameter_list|(
name|MD5_CTX
modifier|*
name|ctx
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|rule
parameter_list|)
block|{
name|u_int16_t
name|x
decl_stmt|;
name|u_int32_t
name|y
decl_stmt|;
name|pf_hash_rule_addr
argument_list|(
name|ctx
argument_list|,
operator|&
name|rule
operator|->
name|src
argument_list|)
expr_stmt|;
name|pf_hash_rule_addr
argument_list|(
name|ctx
argument_list|,
operator|&
name|rule
operator|->
name|dst
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_STR
argument_list|(
name|rule
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_STR
argument_list|(
name|rule
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_STR
argument_list|(
name|rule
argument_list|,
name|match_tagname
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_HTONS
argument_list|(
name|rule
argument_list|,
name|match_tag
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* dup? */
name|PF_MD5_UPD_HTONL
argument_list|(
name|rule
argument_list|,
name|os_fingerprint
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_HTONL
argument_list|(
name|rule
argument_list|,
name|prob
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_HTONL
argument_list|(
name|rule
argument_list|,
name|uid
operator|.
name|uid
index|[
literal|0
index|]
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_HTONL
argument_list|(
name|rule
argument_list|,
name|uid
operator|.
name|uid
index|[
literal|1
index|]
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|uid
operator|.
name|op
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_HTONL
argument_list|(
name|rule
argument_list|,
name|gid
operator|.
name|gid
index|[
literal|0
index|]
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_HTONL
argument_list|(
name|rule
argument_list|,
name|gid
operator|.
name|gid
index|[
literal|1
index|]
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|gid
operator|.
name|op
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_HTONL
argument_list|(
name|rule
argument_list|,
name|rule_flag
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|direction
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|af
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|quick
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|ifnot
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|match_tag_not
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|natpass
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|keep_state
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|flagset
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|allow_opts
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|tos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_commit_rules
parameter_list|(
name|u_int32_t
name|ticket
parameter_list|,
name|int
name|rs_num
parameter_list|,
name|char
modifier|*
name|anchor
parameter_list|)
block|{
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|,
modifier|*
modifier|*
name|old_array
decl_stmt|;
name|struct
name|pf_rulequeue
modifier|*
name|old_rules
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int32_t
name|old_rcount
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|rs_num
operator|<
literal|0
operator|||
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rs
operator|=
name|pf_find_ruleset
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NULL
operator|||
operator|!
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|open
operator|||
name|ticket
operator|!=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Calculate checksum for the main ruleset */
if|if
condition|(
name|rs
operator|==
operator|&
name|pf_main_ruleset
condition|)
block|{
name|error
operator|=
name|pf_setup_pfsync_matching
argument_list|(
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Swap rules, keep the old. */
name|old_rules
operator|=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
expr_stmt|;
name|old_rcount
operator|=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|rcount
expr_stmt|;
name|old_array
operator|=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr_array
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
operator|=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr_array
operator|=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr_array
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|rcount
operator|=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|rcount
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
operator|=
name|old_rules
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr_array
operator|=
name|old_array
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|rcount
operator|=
name|old_rcount
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
operator|=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
expr_stmt|;
name|pf_calc_skip_steps
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
comment|/* Purge the old rule list. */
while|while
condition|(
operator|(
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|old_rules
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pf_unlink_rule
argument_list|(
name|old_rules
argument_list|,
name|rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr_array
condition|)
name|free
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr_array
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr_array
operator|=
name|NULL
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|rcount
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|open
operator|=
literal|0
expr_stmt|;
name|pf_remove_if_empty_ruleset
argument_list|(
name|rs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_setup_pfsync_matching
parameter_list|(
name|struct
name|pf_ruleset
modifier|*
name|rs
parameter_list|)
block|{
name|MD5_CTX
name|ctx
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|int
name|rs_cnt
decl_stmt|;
name|u_int8_t
name|digest
index|[
name|PF_MD5_DIGEST_LENGTH
index|]
decl_stmt|;
name|MD5Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|rs_cnt
operator|=
literal|0
init|;
name|rs_cnt
operator|<
name|PF_RULESET_MAX
condition|;
name|rs_cnt
operator|++
control|)
block|{
comment|/* XXX PF_RULESET_SCRUB as well? */
if|if
condition|(
name|rs_cnt
operator|==
name|PF_RULESET_SCRUB
condition|)
continue|continue;
if|if
condition|(
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|ptr_array
condition|)
name|free
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|ptr_array
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|ptr_array
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|rcount
condition|)
block|{
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|ptr_array
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|caddr_t
argument_list|)
operator|*
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|rcount
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|ptr_array
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|rule
argument_list|,
argument|rs->rules[rs_cnt].inactive.ptr
argument_list|,
argument|entries
argument_list|)
block|{
name|pf_hash_rule
argument_list|(
operator|&
name|ctx
argument_list|,
name|rule
argument_list|)
expr_stmt|;
operator|(
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|ptr_array
operator|)
index|[
name|rule
operator|->
name|nr
index|]
operator|=
name|rule
expr_stmt|;
block|}
block|}
name|MD5Final
argument_list|(
name|digest
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|V_pf_status
operator|.
name|pf_chksum
argument_list|,
name|digest
argument_list|,
sizeof|sizeof
argument_list|(
name|V_pf_status
operator|.
name|pf_chksum
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_addr_setup
parameter_list|(
name|struct
name|pf_ruleset
modifier|*
name|ruleset
parameter_list|,
name|struct
name|pf_addr_wrap
modifier|*
name|addr
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|addr
operator|->
name|type
condition|)
block|{
case|case
name|PF_ADDR_TABLE
case|:
name|addr
operator|->
name|p
operator|.
name|tbl
operator|=
name|pfr_attach_table
argument_list|(
name|ruleset
argument_list|,
name|addr
operator|->
name|v
operator|.
name|tblname
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|p
operator|.
name|tbl
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
case|case
name|PF_ADDR_DYNIFTL
case|:
name|error
operator|=
name|pfi_dynaddr_setup
argument_list|(
name|addr
argument_list|,
name|af
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pf_addr_copyout
parameter_list|(
name|struct
name|pf_addr_wrap
modifier|*
name|addr
parameter_list|)
block|{
switch|switch
condition|(
name|addr
operator|->
name|type
condition|)
block|{
case|case
name|PF_ADDR_DYNIFTL
case|:
name|pfi_dynaddr_copyout
argument_list|(
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_ADDR_TABLE
case|:
name|pf_tbladdr_copyout
argument_list|(
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pfioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|CURVNET_SET
argument_list|(
name|TD_TO_VNET
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX keep in sync with switch() below */
if|if
condition|(
name|securelevel_gt
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
literal|2
argument_list|)
condition|)
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGETRULES
case|:
case|case
name|DIOCGETRULE
case|:
case|case
name|DIOCGETADDRS
case|:
case|case
name|DIOCGETADDR
case|:
case|case
name|DIOCGETSTATE
case|:
case|case
name|DIOCSETSTATUSIF
case|:
case|case
name|DIOCGETSTATUS
case|:
case|case
name|DIOCCLRSTATUS
case|:
case|case
name|DIOCNATLOOK
case|:
case|case
name|DIOCSETDEBUG
case|:
case|case
name|DIOCGETSTATES
case|:
case|case
name|DIOCGETTIMEOUT
case|:
case|case
name|DIOCCLRRULECTRS
case|:
case|case
name|DIOCGETLIMIT
case|:
case|case
name|DIOCGETALTQS
case|:
case|case
name|DIOCGETALTQ
case|:
case|case
name|DIOCGETQSTATS
case|:
case|case
name|DIOCGETRULESETS
case|:
case|case
name|DIOCGETRULESET
case|:
case|case
name|DIOCRGETTABLES
case|:
case|case
name|DIOCRGETTSTATS
case|:
case|case
name|DIOCRCLRTSTATS
case|:
case|case
name|DIOCRCLRADDRS
case|:
case|case
name|DIOCRADDADDRS
case|:
case|case
name|DIOCRDELADDRS
case|:
case|case
name|DIOCRSETADDRS
case|:
case|case
name|DIOCRGETADDRS
case|:
case|case
name|DIOCRGETASTATS
case|:
case|case
name|DIOCRCLRASTATS
case|:
case|case
name|DIOCRTSTADDRS
case|:
case|case
name|DIOCOSFPGET
case|:
case|case
name|DIOCGETSRCNODES
case|:
case|case
name|DIOCCLRSRCNODES
case|:
case|case
name|DIOCIGETIFACES
case|:
case|case
name|DIOCGIFSPEED
case|:
case|case
name|DIOCSETIFFLAG
case|:
case|case
name|DIOCCLRIFFLAG
case|:
break|break;
case|case
name|DIOCRCLRTABLES
case|:
case|case
name|DIOCRADDTABLES
case|:
case|case
name|DIOCRDELTABLES
case|:
case|case
name|DIOCRSETTFLAGS
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
operator|)
operator|->
name|pfrio_flags
operator|&
name|PFR_FLAG_DUMMY
condition|)
break|break;
comment|/* dummy operation ok */
return|return
operator|(
name|EPERM
operator|)
return|;
default|default:
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|FWRITE
operator|)
condition|)
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGETRULES
case|:
case|case
name|DIOCGETADDRS
case|:
case|case
name|DIOCGETADDR
case|:
case|case
name|DIOCGETSTATE
case|:
case|case
name|DIOCGETSTATUS
case|:
case|case
name|DIOCGETSTATES
case|:
case|case
name|DIOCGETTIMEOUT
case|:
case|case
name|DIOCGETLIMIT
case|:
case|case
name|DIOCGETALTQS
case|:
case|case
name|DIOCGETALTQ
case|:
case|case
name|DIOCGETQSTATS
case|:
case|case
name|DIOCGETRULESETS
case|:
case|case
name|DIOCGETRULESET
case|:
case|case
name|DIOCNATLOOK
case|:
case|case
name|DIOCRGETTABLES
case|:
case|case
name|DIOCRGETTSTATS
case|:
case|case
name|DIOCRGETADDRS
case|:
case|case
name|DIOCRGETASTATS
case|:
case|case
name|DIOCRTSTADDRS
case|:
case|case
name|DIOCOSFPGET
case|:
case|case
name|DIOCGETSRCNODES
case|:
case|case
name|DIOCIGETIFACES
case|:
case|case
name|DIOCGIFSPEED
case|:
break|break;
case|case
name|DIOCRCLRTABLES
case|:
case|case
name|DIOCRADDTABLES
case|:
case|case
name|DIOCRDELTABLES
case|:
case|case
name|DIOCRCLRTSTATS
case|:
case|case
name|DIOCRCLRADDRS
case|:
case|case
name|DIOCRADDADDRS
case|:
case|case
name|DIOCRDELADDRS
case|:
case|case
name|DIOCRSETADDRS
case|:
case|case
name|DIOCRSETTFLAGS
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
operator|)
operator|->
name|pfrio_flags
operator|&
name|PFR_FLAG_DUMMY
condition|)
block|{
name|flags
operator||=
name|FWRITE
expr_stmt|;
comment|/* need write lock for dummy */
break|break;
comment|/* dummy operation ok */
block|}
return|return
operator|(
name|EACCES
operator|)
return|;
case|case
name|DIOCGETRULE
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
operator|)
operator|->
name|action
operator|==
name|PF_GET_CLR_CNTR
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCSTART
case|:
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|V_pf_status
operator|.
name|running
condition|)
name|error
operator|=
name|EEXIST
expr_stmt|;
else|else
block|{
name|int
name|cpu
decl_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|hook_pf
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: pfil registration failed\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|V_pf_status
operator|.
name|running
operator|=
literal|1
expr_stmt|;
name|V_pf_status
operator|.
name|since
operator|=
name|time_second
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|cpu
argument_list|)
name|V_pf_stateid
index|[
name|cpu
index|]
operator|=
name|time_second
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: started\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|DIOCSTOP
case|:
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|V_pf_status
operator|.
name|running
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
else|else
block|{
name|V_pf_status
operator|.
name|running
operator|=
literal|0
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|dehook_pf
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|V_pf_status
operator|.
name|running
operator|=
literal|1
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: pfil unregistration failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|V_pf_status
operator|.
name|since
operator|=
name|time_second
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: stopped\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|DIOCADDRULE
case|:
block|{
name|struct
name|pfioc_rule
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|struct
name|pf_pooladdr
modifier|*
name|pa
decl_stmt|;
name|struct
name|pfi_kif
modifier|*
name|kif
init|=
name|NULL
decl_stmt|;
name|int
name|rs_num
decl_stmt|;
if|if
condition|(
name|pr
operator|->
name|rule
operator|.
name|return_icmp
operator|>>
literal|8
operator|>
name|ICMP_MAXTYPE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|INET
if|if
condition|(
name|pr
operator|->
name|rule
operator|.
name|af
operator|==
name|AF_INET
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifndef|#
directive|ifndef
name|INET6
if|if
condition|(
name|pr
operator|->
name|rule
operator|.
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
name|rule
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rule
argument_list|)
argument_list|,
name|M_PFRULE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pr
operator|->
name|rule
argument_list|,
name|rule
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_rule
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
name|kif
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|kif
argument_list|)
argument_list|,
name|PFI_MTYPE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rule
operator|->
name|cuid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
expr_stmt|;
name|rule
operator|->
name|cpid
operator|=
name|td
operator|->
name|td_proc
condition|?
name|td
operator|->
name|td_proc
operator|->
name|p_pid
else|:
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
define|#
directive|define
name|ERROUT
parameter_list|(
name|x
parameter_list|)
value|{ error = (x); goto DIOCADDRULE_error; }
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|pr
operator|->
name|anchor
index|[
sizeof|sizeof
argument_list|(
name|pr
operator|->
name|anchor
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pr
operator|->
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"ticket: %d != [%d]%d\n"
operator|,
name|pr
operator|->
name|ticket
operator|,
name|rs_num
operator|,
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
operator|)
argument_list|)
expr_stmt|;
name|ERROUT
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pr
operator|->
name|pool_ticket
operator|!=
name|V_ticket_pabuf
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pool_ticket: %d != %d\n"
operator|,
name|pr
operator|->
name|pool_ticket
operator|,
name|V_ticket_pabuf
operator|)
argument_list|)
expr_stmt|;
name|ERROUT
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
block|}
name|tail
operator|=
name|TAILQ_LAST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|,
name|pf_rulequeue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
condition|)
name|rule
operator|->
name|nr
operator|=
name|tail
operator|->
name|nr
operator|+
literal|1
expr_stmt|;
else|else
name|rule
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
block|{
name|rule
operator|->
name|kif
operator|=
name|pfi_kif_attach
argument_list|(
name|kif
argument_list|,
name|rule
operator|->
name|ifname
argument_list|)
expr_stmt|;
name|pfi_kif_ref
argument_list|(
name|rule
operator|->
name|kif
argument_list|)
expr_stmt|;
block|}
else|else
name|rule
operator|->
name|kif
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|rtableid
operator|>
literal|0
operator|&&
name|rule
operator|->
name|rtableid
operator|>=
name|rt_numfibs
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ
comment|/* set queue IDs */
if|if
condition|(
name|rule
operator|->
name|qname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rule
operator|->
name|qid
operator|=
name|pf_qname2qid
argument_list|(
name|rule
operator|->
name|qname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
elseif|else
if|if
condition|(
name|rule
operator|->
name|pqname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rule
operator|->
name|pqid
operator|=
name|pf_qname2qid
argument_list|(
name|rule
operator|->
name|pqname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
else|else
name|rule
operator|->
name|pqid
operator|=
name|rule
operator|->
name|qid
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|rule
operator|->
name|tagname
index|[
literal|0
index|]
condition|)
if|if
condition|(
operator|(
name|rule
operator|->
name|tag
operator|=
name|pf_tagname2tag
argument_list|(
name|rule
operator|->
name|tagname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|match_tagname
index|[
literal|0
index|]
condition|)
if|if
condition|(
operator|(
name|rule
operator|->
name|match_tag
operator|=
name|pf_tagname2tag
argument_list|(
name|rule
operator|->
name|match_tagname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|rt
operator|&&
operator|!
name|rule
operator|->
name|direction
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
operator|!
name|rule
operator|->
name|log
condition|)
name|rule
operator|->
name|logif
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|logif
operator|>=
name|PFLOGIFS_MAX
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_addr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|rule
operator|->
name|src
operator|.
name|addr
argument_list|,
name|rule
operator|->
name|af
argument_list|)
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
if|if
condition|(
name|pf_addr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|rule
operator|->
name|dst
operator|.
name|addr
argument_list|,
name|rule
operator|->
name|af
argument_list|)
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
if|if
condition|(
name|pf_anchor_setup
argument_list|(
name|rule
argument_list|,
name|ruleset
argument_list|,
name|pr
operator|->
name|anchor_call
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pa
argument_list|,
argument|&V_pf_pabuf
argument_list|,
argument|entries
argument_list|)
if|if
condition|(
name|pa
operator|->
name|addr
operator|.
name|type
operator|==
name|PF_ADDR_TABLE
condition|)
block|{
name|pa
operator|->
name|addr
operator|.
name|p
operator|.
name|tbl
operator|=
name|pfr_attach_table
argument_list|(
name|ruleset
argument_list|,
name|pa
operator|->
name|addr
operator|.
name|v
operator|.
name|tblname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|->
name|addr
operator|.
name|p
operator|.
name|tbl
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|->
name|overload_tblname
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|rule
operator|->
name|overload_tbl
operator|=
name|pfr_attach_table
argument_list|(
name|ruleset
argument_list|,
name|rule
operator|->
name|overload_tblname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|rule
operator|->
name|overload_tbl
operator|->
name|pfrkt_flags
operator||=
name|PFR_TFLAG_ACTIVE
expr_stmt|;
block|}
name|pf_mv_pool
argument_list|(
operator|&
name|V_pf_pabuf
argument_list|,
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
operator|(
name|rule
operator|->
name|action
operator|==
name|PF_NAT
operator|)
operator|||
operator|(
name|rule
operator|->
name|action
operator|==
name|PF_RDR
operator|)
operator|||
operator|(
name|rule
operator|->
name|action
operator|==
name|PF_BINAT
operator|)
operator|)
operator|&&
name|rule
operator|->
name|anchor
operator|==
name|NULL
operator|)
operator|||
operator|(
name|rule
operator|->
name|rt
operator|>
name|PF_FASTROUTE
operator|)
operator|)
operator|&&
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pf_free_rule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
name|rule
operator|->
name|rpool
operator|.
name|cur
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
name|rule
operator|->
name|evaluations
operator|=
name|rule
operator|->
name|packets
index|[
literal|0
index|]
operator|=
name|rule
operator|->
name|packets
index|[
literal|1
index|]
operator|=
name|rule
operator|->
name|bytes
index|[
literal|0
index|]
operator|=
name|rule
operator|->
name|bytes
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|,
name|rule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|rcount
operator|++
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
undef|#
directive|undef
name|ERROUT
name|DIOCADDRULE_error
label|:
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|rule
argument_list|,
name|M_PFRULE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kif
condition|)
name|free
argument_list|(
name|kif
argument_list|,
name|PFI_MTYPE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETRULES
case|:
block|{
name|struct
name|pfioc_rule
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|tail
decl_stmt|;
name|int
name|rs_num
decl_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|pr
operator|->
name|anchor
index|[
sizeof|sizeof
argument_list|(
name|pr
operator|->
name|anchor
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pr
operator|->
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|tail
operator|=
name|TAILQ_LAST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|pf_rulequeue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
condition|)
name|pr
operator|->
name|nr
operator|=
name|tail
operator|->
name|nr
operator|+
literal|1
expr_stmt|;
else|else
name|pr
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|pr
operator|->
name|ticket
operator|=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETRULE
case|:
block|{
name|struct
name|pfioc_rule
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|int
name|rs_num
decl_stmt|,
name|i
decl_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|pr
operator|->
name|anchor
index|[
sizeof|sizeof
argument_list|(
name|pr
operator|->
name|anchor
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pr
operator|->
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pr
operator|->
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rule
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|rule
operator|->
name|nr
operator|!=
name|pr
operator|->
name|nr
operator|)
condition|)
name|rule
operator|=
name|TAILQ_NEXT
argument_list|(
name|rule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|==
name|NULL
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|rule
argument_list|,
operator|&
name|pr
operator|->
name|rule
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_rule
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf_anchor_copyout
argument_list|(
name|ruleset
argument_list|,
name|rule
argument_list|,
name|pr
argument_list|)
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|pf_addr_copyout
argument_list|(
operator|&
name|pr
operator|->
name|rule
operator|.
name|src
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_addr_copyout
argument_list|(
operator|&
name|pr
operator|->
name|rule
operator|.
name|dst
operator|.
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PF_SKIP_COUNT
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|rule
operator|->
name|skip
index|[
name|i
index|]
operator|.
name|ptr
operator|==
name|NULL
condition|)
name|pr
operator|->
name|rule
operator|.
name|skip
index|[
name|i
index|]
operator|.
name|nr
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|pr
operator|->
name|rule
operator|.
name|skip
index|[
name|i
index|]
operator|.
name|nr
operator|=
name|rule
operator|->
name|skip
index|[
name|i
index|]
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|action
operator|==
name|PF_GET_CLR_CNTR
condition|)
block|{
name|rule
operator|->
name|evaluations
operator|=
literal|0
expr_stmt|;
name|rule
operator|->
name|packets
index|[
literal|0
index|]
operator|=
name|rule
operator|->
name|packets
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rule
operator|->
name|bytes
index|[
literal|0
index|]
operator|=
name|rule
operator|->
name|bytes
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rule
operator|->
name|states_tot
operator|=
literal|0
expr_stmt|;
block|}
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCHANGERULE
case|:
block|{
name|struct
name|pfioc_rule
modifier|*
name|pcr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|oldrule
init|=
name|NULL
decl_stmt|,
modifier|*
name|newrule
init|=
name|NULL
decl_stmt|;
name|struct
name|pfi_kif
modifier|*
name|kif
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_pooladdr
modifier|*
name|pa
decl_stmt|;
name|u_int32_t
name|nr
init|=
literal|0
decl_stmt|;
name|int
name|rs_num
decl_stmt|;
if|if
condition|(
name|pcr
operator|->
name|action
operator|<
name|PF_CHANGE_ADD_HEAD
operator|||
name|pcr
operator|->
name|action
operator|>
name|PF_CHANGE_GET_TICKET
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pcr
operator|->
name|rule
operator|.
name|return_icmp
operator|>>
literal|8
operator|>
name|ICMP_MAXTYPE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pcr
operator|->
name|action
operator|!=
name|PF_CHANGE_REMOVE
condition|)
block|{
ifndef|#
directive|ifndef
name|INET
if|if
condition|(
name|pcr
operator|->
name|rule
operator|.
name|af
operator|==
name|AF_INET
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifndef|#
directive|ifndef
name|INET6
if|if
condition|(
name|pcr
operator|->
name|rule
operator|.
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
name|newrule
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newrule
argument_list|)
argument_list|,
name|M_PFRULE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pcr
operator|->
name|rule
argument_list|,
name|newrule
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_rule
argument_list|)
argument_list|)
expr_stmt|;
name|newrule
operator|->
name|cuid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
expr_stmt|;
name|newrule
operator|->
name|cpid
operator|=
name|td
operator|->
name|td_proc
condition|?
name|td
operator|->
name|td_proc
operator|->
name|p_pid
else|:
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|newrule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
comment|/* Initialize refcounting. */
name|newrule
operator|->
name|states_cur
operator|=
literal|0
expr_stmt|;
name|newrule
operator|->
name|entries
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|newrule
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
name|kif
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|kif
argument_list|)
argument_list|,
name|PFI_MTYPE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|ERROUT
parameter_list|(
name|x
parameter_list|)
value|{ error = (x); goto DIOCCHANGERULE_error; }
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_REMOVE
operator|||
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_GET_TICKET
operator|)
operator|&&
name|pcr
operator|->
name|pool_ticket
operator|!=
name|V_ticket_pabuf
condition|)
name|ERROUT
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pcr
operator|->
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pcr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_GET_TICKET
condition|)
block|{
name|pcr
operator|->
name|ticket
operator|=
operator|++
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
expr_stmt|;
name|ERROUT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pcr
operator|->
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr
operator|->
name|action
operator|!=
name|PF_CHANGE_REMOVE
condition|)
block|{
if|if
condition|(
name|newrule
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
block|{
name|newrule
operator|->
name|kif
operator|=
name|pfi_kif_attach
argument_list|(
name|kif
argument_list|,
name|newrule
operator|->
name|ifname
argument_list|)
expr_stmt|;
name|pfi_kif_ref
argument_list|(
name|newrule
operator|->
name|kif
argument_list|)
expr_stmt|;
block|}
else|else
name|newrule
operator|->
name|kif
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|newrule
operator|->
name|rtableid
operator|>
literal|0
operator|&&
name|newrule
operator|->
name|rtableid
operator|>=
name|rt_numfibs
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ
comment|/* set queue IDs */
if|if
condition|(
name|newrule
operator|->
name|qname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|newrule
operator|->
name|qid
operator|=
name|pf_qname2qid
argument_list|(
name|newrule
operator|->
name|qname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
elseif|else
if|if
condition|(
name|newrule
operator|->
name|pqname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|newrule
operator|->
name|pqid
operator|=
name|pf_qname2qid
argument_list|(
name|newrule
operator|->
name|pqname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
else|else
name|newrule
operator|->
name|pqid
operator|=
name|newrule
operator|->
name|qid
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ALTQ */
if|if
condition|(
name|newrule
operator|->
name|tagname
index|[
literal|0
index|]
condition|)
if|if
condition|(
operator|(
name|newrule
operator|->
name|tag
operator|=
name|pf_tagname2tag
argument_list|(
name|newrule
operator|->
name|tagname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|newrule
operator|->
name|match_tagname
index|[
literal|0
index|]
condition|)
if|if
condition|(
operator|(
name|newrule
operator|->
name|match_tag
operator|=
name|pf_tagname2tag
argument_list|(
name|newrule
operator|->
name|match_tagname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|newrule
operator|->
name|rt
operator|&&
operator|!
name|newrule
operator|->
name|direction
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
operator|!
name|newrule
operator|->
name|log
condition|)
name|newrule
operator|->
name|logif
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|newrule
operator|->
name|logif
operator|>=
name|PFLOGIFS_MAX
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_addr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|newrule
operator|->
name|src
operator|.
name|addr
argument_list|,
name|newrule
operator|->
name|af
argument_list|)
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
if|if
condition|(
name|pf_addr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|newrule
operator|->
name|dst
operator|.
name|addr
argument_list|,
name|newrule
operator|->
name|af
argument_list|)
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
if|if
condition|(
name|pf_anchor_setup
argument_list|(
name|newrule
argument_list|,
name|ruleset
argument_list|,
name|pcr
operator|->
name|anchor_call
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pa
argument_list|,
argument|&V_pf_pabuf
argument_list|,
argument|entries
argument_list|)
if|if
condition|(
name|pa
operator|->
name|addr
operator|.
name|type
operator|==
name|PF_ADDR_TABLE
condition|)
block|{
name|pa
operator|->
name|addr
operator|.
name|p
operator|.
name|tbl
operator|=
name|pfr_attach_table
argument_list|(
name|ruleset
argument_list|,
name|pa
operator|->
name|addr
operator|.
name|v
operator|.
name|tblname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|->
name|addr
operator|.
name|p
operator|.
name|tbl
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
if|if
condition|(
name|newrule
operator|->
name|overload_tblname
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|newrule
operator|->
name|overload_tbl
operator|=
name|pfr_attach_table
argument_list|(
name|ruleset
argument_list|,
name|newrule
operator|->
name|overload_tblname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|newrule
operator|->
name|overload_tbl
operator|->
name|pfrkt_flags
operator||=
name|PFR_TFLAG_ACTIVE
expr_stmt|;
block|}
name|pf_mv_pool
argument_list|(
operator|&
name|V_pf_pabuf
argument_list|,
operator|&
name|newrule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
operator|(
name|newrule
operator|->
name|action
operator|==
name|PF_NAT
operator|)
operator|||
operator|(
name|newrule
operator|->
name|action
operator|==
name|PF_RDR
operator|)
operator|||
operator|(
name|newrule
operator|->
name|action
operator|==
name|PF_BINAT
operator|)
operator|||
operator|(
name|newrule
operator|->
name|rt
operator|>
name|PF_FASTROUTE
operator|)
operator|)
operator|&&
operator|!
name|newrule
operator|->
name|anchor
operator|)
operator|)
operator|&&
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|newrule
operator|->
name|rpool
operator|.
name|list
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pf_free_rule
argument_list|(
name|newrule
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
name|newrule
operator|->
name|rpool
operator|.
name|cur
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|newrule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
name|newrule
operator|->
name|evaluations
operator|=
literal|0
expr_stmt|;
name|newrule
operator|->
name|packets
index|[
literal|0
index|]
operator|=
name|newrule
operator|->
name|packets
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|newrule
operator|->
name|bytes
index|[
literal|0
index|]
operator|=
name|newrule
operator|->
name|bytes
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|pf_empty_pool
argument_list|(
operator|&
name|V_pf_pabuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_HEAD
condition|)
name|oldrule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_TAIL
condition|)
name|oldrule
operator|=
name|TAILQ_LAST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|pf_rulequeue
argument_list|)
expr_stmt|;
else|else
block|{
name|oldrule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|oldrule
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|oldrule
operator|->
name|nr
operator|!=
name|pcr
operator|->
name|nr
operator|)
condition|)
name|oldrule
operator|=
name|TAILQ_NEXT
argument_list|(
name|oldrule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldrule
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|newrule
operator|!=
name|NULL
condition|)
name|pf_free_rule
argument_list|(
name|newrule
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_REMOVE
condition|)
block|{
name|pf_unlink_rule
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|oldrule
argument_list|)
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|rcount
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|oldrule
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|newrule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_HEAD
operator|||
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_BEFORE
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|oldrule
argument_list|,
name|newrule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_AFTER
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|oldrule
argument_list|,
name|newrule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|rcount
operator|++
expr_stmt|;
block|}
name|nr
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|oldrule
argument_list|,
argument|ruleset->rules[rs_num].active.ptr
argument_list|,
argument|entries
argument_list|)
name|oldrule
operator|->
name|nr
operator|=
name|nr
operator|++
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
operator|++
expr_stmt|;
name|pf_calc_skip_steps
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|pf_remove_if_empty_ruleset
argument_list|(
name|ruleset
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
undef|#
directive|undef
name|ERROUT
name|DIOCCHANGERULE_error
label|:
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|newrule
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|newrule
argument_list|,
name|M_PFRULE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kif
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|kif
argument_list|,
name|PFI_MTYPE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCLRSTATES
case|:
block|{
name|struct
name|pf_state
modifier|*
name|s
decl_stmt|;
name|struct
name|pfioc_state_kill
modifier|*
name|psk
init|=
operator|(
expr|struct
name|pfioc_state_kill
operator|*
operator|)
name|addr
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|killed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|V_pf_hashmask
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|pf_idhash
modifier|*
name|ih
init|=
operator|&
name|V_pf_idhash
index|[
name|i
index|]
decl_stmt|;
name|relock_DIOCCLRSTATES
label|:
name|PF_HASHROW_LOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ih->states
argument_list|,
argument|entry
argument_list|)
if|if
condition|(
operator|!
name|psk
operator|->
name|psk_ifname
index|[
literal|0
index|]
operator|||
operator|!
name|strcmp
argument_list|(
name|psk
operator|->
name|psk_ifname
argument_list|,
name|s
operator|->
name|kif
operator|->
name|pfik_name
argument_list|)
condition|)
block|{
comment|/* 					 * Don't send out individual 					 * delete messages. 					 */
name|s
operator|->
name|state_flags
operator||=
name|PFSTATE_NOSYNC
expr_stmt|;
name|pf_unlink_state
argument_list|(
name|s
argument_list|,
name|PF_ENTER_LOCKED
argument_list|)
expr_stmt|;
name|killed
operator|++
expr_stmt|;
goto|goto
name|relock_DIOCCLRSTATES
goto|;
block|}
name|PF_HASHROW_UNLOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
block|}
name|psk
operator|->
name|psk_killed
operator|=
name|killed
expr_stmt|;
if|if
condition|(
name|pfsync_clear_states_ptr
operator|!=
name|NULL
condition|)
name|pfsync_clear_states_ptr
argument_list|(
name|V_pf_status
operator|.
name|hostid
argument_list|,
name|psk
operator|->
name|psk_ifname
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCKILLSTATES
case|:
block|{
name|struct
name|pf_state
modifier|*
name|s
decl_stmt|;
name|struct
name|pf_state_key
modifier|*
name|sk
decl_stmt|;
name|struct
name|pf_addr
modifier|*
name|srcaddr
decl_stmt|,
modifier|*
name|dstaddr
decl_stmt|;
name|u_int16_t
name|srcport
decl_stmt|,
name|dstport
decl_stmt|;
name|struct
name|pfioc_state_kill
modifier|*
name|psk
init|=
operator|(
expr|struct
name|pfioc_state_kill
operator|*
operator|)
name|addr
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|killed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|psk
operator|->
name|psk_pfcmp
operator|.
name|id
condition|)
block|{
if|if
condition|(
name|psk
operator|->
name|psk_pfcmp
operator|.
name|creatorid
operator|==
literal|0
condition|)
name|psk
operator|->
name|psk_pfcmp
operator|.
name|creatorid
operator|=
name|V_pf_status
operator|.
name|hostid
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|pf_find_state_byid
argument_list|(
name|psk
operator|->
name|psk_pfcmp
operator|.
name|id
argument_list|,
name|psk
operator|->
name|psk_pfcmp
operator|.
name|creatorid
argument_list|)
operator|)
condition|)
block|{
name|pf_unlink_state
argument_list|(
name|s
argument_list|,
name|PF_ENTER_LOCKED
argument_list|)
expr_stmt|;
name|psk
operator|->
name|psk_killed
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|V_pf_hashmask
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|pf_idhash
modifier|*
name|ih
init|=
operator|&
name|V_pf_idhash
index|[
name|i
index|]
decl_stmt|;
name|relock_DIOCKILLSTATES
label|:
name|PF_HASHROW_LOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ih->states
argument_list|,
argument|entry
argument_list|)
block|{
name|sk
operator|=
name|s
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|direction
operator|==
name|PF_OUT
condition|)
block|{
name|srcaddr
operator|=
operator|&
name|sk
operator|->
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|dstaddr
operator|=
operator|&
name|sk
operator|->
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|srcport
operator|=
name|sk
operator|->
name|port
index|[
literal|0
index|]
expr_stmt|;
name|dstport
operator|=
name|sk
operator|->
name|port
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|srcaddr
operator|=
operator|&
name|sk
operator|->
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|dstaddr
operator|=
operator|&
name|sk
operator|->
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|srcport
operator|=
name|sk
operator|->
name|port
index|[
literal|0
index|]
expr_stmt|;
name|dstport
operator|=
name|sk
operator|->
name|port
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|psk
operator|->
name|psk_af
operator|||
name|sk
operator|->
name|af
operator|==
name|psk
operator|->
name|psk_af
operator|)
operator|&&
operator|(
operator|!
name|psk
operator|->
name|psk_proto
operator|||
name|psk
operator|->
name|psk_proto
operator|==
name|sk
operator|->
name|proto
operator|)
operator|&&
name|PF_MATCHA
argument_list|(
name|psk
operator|->
name|psk_src
operator|.
name|neg
argument_list|,
operator|&
name|psk
operator|->
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|,
operator|&
name|psk
operator|->
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
name|srcaddr
argument_list|,
name|sk
operator|->
name|af
argument_list|)
operator|&&
name|PF_MATCHA
argument_list|(
name|psk
operator|->
name|psk_dst
operator|.
name|neg
argument_list|,
operator|&
name|psk
operator|->
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|,
operator|&
name|psk
operator|->
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
name|dstaddr
argument_list|,
name|sk
operator|->
name|af
argument_list|)
operator|&&
operator|(
name|psk
operator|->
name|psk_src
operator|.
name|port_op
operator|==
literal|0
operator|||
name|pf_match_port
argument_list|(
name|psk
operator|->
name|psk_src
operator|.
name|port_op
argument_list|,
name|psk
operator|->
name|psk_src
operator|.
name|port
index|[
literal|0
index|]
argument_list|,
name|psk
operator|->
name|psk_src
operator|.
name|port
index|[
literal|1
index|]
argument_list|,
name|srcport
argument_list|)
operator|)
operator|&&
operator|(
name|psk
operator|->
name|psk_dst
operator|.
name|port_op
operator|==
literal|0
operator|||
name|pf_match_port
argument_list|(
name|psk
operator|->
name|psk_dst
operator|.
name|port_op
argument_list|,
name|psk
operator|->
name|psk_dst
operator|.
name|port
index|[
literal|0
index|]
argument_list|,
name|psk
operator|->
name|psk_dst
operator|.
name|port
index|[
literal|1
index|]
argument_list|,
name|dstport
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|psk
operator|->
name|psk_label
index|[
literal|0
index|]
operator|||
operator|(
name|s
operator|->
name|rule
operator|.
name|ptr
operator|->
name|label
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|psk
operator|->
name|psk_label
argument_list|,
name|s
operator|->
name|rule
operator|.
name|ptr
operator|->
name|label
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|!
name|psk
operator|->
name|psk_ifname
index|[
literal|0
index|]
operator|||
operator|!
name|strcmp
argument_list|(
name|psk
operator|->
name|psk_ifname
argument_list|,
name|s
operator|->
name|kif
operator|->
name|pfik_name
argument_list|)
operator|)
condition|)
block|{
name|pf_unlink_state
argument_list|(
name|s
argument_list|,
name|PF_ENTER_LOCKED
argument_list|)
expr_stmt|;
name|killed
operator|++
expr_stmt|;
goto|goto
name|relock_DIOCKILLSTATES
goto|;
block|}
block|}
name|PF_HASHROW_UNLOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
block|}
name|psk
operator|->
name|psk_killed
operator|=
name|killed
expr_stmt|;
break|break;
block|}
case|case
name|DIOCADDSTATE
case|:
block|{
name|struct
name|pfioc_state
modifier|*
name|ps
init|=
operator|(
expr|struct
name|pfioc_state
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfsync_state
modifier|*
name|sp
init|=
operator|&
name|ps
operator|->
name|state
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|timeout
operator|>=
name|PFTM_MAX
operator|&&
name|sp
operator|->
name|timeout
operator|!=
name|PFTM_UNTIL_PACKET
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pfsync_state_import_ptr
operator|!=
name|NULL
condition|)
block|{
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfsync_state_import_ptr
argument_list|(
name|sp
argument_list|,
name|PFSYNC_SI_IOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
block|}
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETSTATE
case|:
block|{
name|struct
name|pfioc_state
modifier|*
name|ps
init|=
operator|(
expr|struct
name|pfioc_state
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|pf_find_state_byid
argument_list|(
name|ps
operator|->
name|state
operator|.
name|id
argument_list|,
name|ps
operator|->
name|state
operator|.
name|creatorid
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|pfsync_state_export
argument_list|(
operator|&
name|ps
operator|->
name|state
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|PF_STATE_UNLOCK
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETSTATES
case|:
block|{
name|struct
name|pfioc_states
modifier|*
name|ps
init|=
operator|(
expr|struct
name|pfioc_states
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|s
decl_stmt|;
name|struct
name|pfsync_state
modifier|*
name|pstore
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nr
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|ps_len
operator|==
literal|0
condition|)
block|{
name|nr
operator|=
name|uma_zone_get_cur
argument_list|(
name|V_pf_state_z
argument_list|)
expr_stmt|;
name|ps
operator|->
name|ps_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pfsync_state
argument_list|)
operator|*
name|nr
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|pstore
operator|=
name|malloc
argument_list|(
name|ps
operator|->
name|ps_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|V_pf_hashmask
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|pf_idhash
modifier|*
name|ih
init|=
operator|&
name|V_pf_idhash
index|[
name|i
index|]
decl_stmt|;
name|PF_HASHROW_LOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ih->states
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|s
operator|->
name|timeout
operator|==
name|PFTM_UNLINKED
condition|)
continue|continue;
if|if
condition|(
operator|(
name|nr
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|>
name|ps
operator|->
name|ps_len
condition|)
block|{
name|PF_HASHROW_UNLOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
goto|goto
name|DIOCGETSTATES_full
goto|;
block|}
name|pfsync_state_export
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
name|PF_HASHROW_UNLOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
block|}
name|DIOCGETSTATES_full
label|:
name|error
operator|=
name|copyout
argument_list|(
name|pstore
argument_list|,
name|ps
operator|->
name|ps_states
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pfsync_state
argument_list|)
operator|*
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|pstore
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|ps
operator|->
name|ps_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pfsync_state
argument_list|)
operator|*
name|nr
expr_stmt|;
name|free
argument_list|(
name|pstore
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETSTATUS
case|:
block|{
name|struct
name|pf_status
modifier|*
name|s
init|=
operator|(
expr|struct
name|pf_status
operator|*
operator|)
name|addr
decl_stmt|;
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|V_pf_status
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_status
argument_list|)
argument_list|)
expr_stmt|;
name|pfi_update_status
argument_list|(
name|s
operator|->
name|ifname
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSETSTATUSIF
case|:
block|{
name|struct
name|pfioc_if
modifier|*
name|pi
init|=
operator|(
expr|struct
name|pfioc_if
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|ifname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|V_pf_status
operator|.
name|ifname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|strlcpy
argument_list|(
name|V_pf_status
operator|.
name|ifname
argument_list|,
name|pi
operator|->
name|ifname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCLRSTATUS
case|:
block|{
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|V_pf_status
operator|.
name|counters
argument_list|,
sizeof|sizeof
argument_list|(
name|V_pf_status
operator|.
name|counters
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|V_pf_status
operator|.
name|fcounters
argument_list|,
sizeof|sizeof
argument_list|(
name|V_pf_status
operator|.
name|fcounters
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|V_pf_status
operator|.
name|scounters
argument_list|,
sizeof|sizeof
argument_list|(
name|V_pf_status
operator|.
name|scounters
argument_list|)
argument_list|)
expr_stmt|;
name|V_pf_status
operator|.
name|since
operator|=
name|time_second
expr_stmt|;
if|if
condition|(
operator|*
name|V_pf_status
operator|.
name|ifname
condition|)
name|pfi_update_status
argument_list|(
name|V_pf_status
operator|.
name|ifname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCNATLOOK
case|:
block|{
name|struct
name|pfioc_natlook
modifier|*
name|pnl
init|=
operator|(
expr|struct
name|pfioc_natlook
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_state_key
modifier|*
name|sk
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|state
decl_stmt|;
name|struct
name|pf_state_key_cmp
name|key
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|,
name|direction
init|=
name|pnl
operator|->
name|direction
decl_stmt|;
name|int
name|sidx
decl_stmt|,
name|didx
decl_stmt|;
comment|/* NATLOOK src and dst are reversed, so reverse sidx/didx */
name|sidx
operator|=
operator|(
name|direction
operator|==
name|PF_IN
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|didx
operator|=
operator|(
name|direction
operator|==
name|PF_IN
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|pnl
operator|->
name|proto
operator|||
name|PF_AZERO
argument_list|(
operator|&
name|pnl
operator|->
name|saddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
operator|||
name|PF_AZERO
argument_list|(
operator|&
name|pnl
operator|->
name|daddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
operator|||
operator|(
operator|(
name|pnl
operator|->
name|proto
operator|==
name|IPPROTO_TCP
operator|||
name|pnl
operator|->
name|proto
operator|==
name|IPPROTO_UDP
operator|)
operator|&&
operator|(
operator|!
name|pnl
operator|->
name|dport
operator|||
operator|!
name|pnl
operator|->
name|sport
operator|)
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|bzero
argument_list|(
operator|&
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|af
operator|=
name|pnl
operator|->
name|af
expr_stmt|;
name|key
operator|.
name|proto
operator|=
name|pnl
operator|->
name|proto
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
name|sidx
index|]
argument_list|,
operator|&
name|pnl
operator|->
name|saddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|port
index|[
name|sidx
index|]
operator|=
name|pnl
operator|->
name|sport
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
name|didx
index|]
argument_list|,
operator|&
name|pnl
operator|->
name|daddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|port
index|[
name|didx
index|]
operator|=
name|pnl
operator|->
name|dport
expr_stmt|;
name|state
operator|=
name|pf_find_state_all
argument_list|(
operator|&
name|key
argument_list|,
name|direction
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|1
condition|)
name|error
operator|=
name|E2BIG
expr_stmt|;
comment|/* more than one state */
elseif|else
if|if
condition|(
name|state
operator|!=
name|NULL
condition|)
block|{
comment|/* XXXGL: not locked read */
name|sk
operator|=
name|state
operator|->
name|key
index|[
name|sidx
index|]
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|pnl
operator|->
name|rsaddr
argument_list|,
operator|&
name|sk
operator|->
name|addr
index|[
name|sidx
index|]
argument_list|,
name|sk
operator|->
name|af
argument_list|)
expr_stmt|;
name|pnl
operator|->
name|rsport
operator|=
name|sk
operator|->
name|port
index|[
name|sidx
index|]
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|pnl
operator|->
name|rdaddr
argument_list|,
operator|&
name|sk
operator|->
name|addr
index|[
name|didx
index|]
argument_list|,
name|sk
operator|->
name|af
argument_list|)
expr_stmt|;
name|pnl
operator|->
name|rdport
operator|=
name|sk
operator|->
name|port
index|[
name|didx
index|]
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DIOCSETTIMEOUT
case|:
block|{
name|struct
name|pfioc_tm
modifier|*
name|pt
init|=
operator|(
expr|struct
name|pfioc_tm
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|old
decl_stmt|;
if|if
condition|(
name|pt
operator|->
name|timeout
operator|<
literal|0
operator|||
name|pt
operator|->
name|timeout
operator|>=
name|PFTM_MAX
operator|||
name|pt
operator|->
name|seconds
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|old
operator|=
name|V_pf_default_rule
operator|.
name|timeout
index|[
name|pt
operator|->
name|timeout
index|]
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|timeout
operator|==
name|PFTM_INTERVAL
operator|&&
name|pt
operator|->
name|seconds
operator|==
literal|0
condition|)
name|pt
operator|->
name|seconds
operator|=
literal|1
expr_stmt|;
name|V_pf_default_rule
operator|.
name|timeout
index|[
name|pt
operator|->
name|timeout
index|]
operator|=
name|pt
operator|->
name|seconds
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|timeout
operator|==
name|PFTM_INTERVAL
operator|&&
name|pt
operator|->
name|seconds
operator|<
name|old
condition|)
name|wakeup
argument_list|(
name|pf_purge_thread
argument_list|)
expr_stmt|;
name|pt
operator|->
name|seconds
operator|=
name|old
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETTIMEOUT
case|:
block|{
name|struct
name|pfioc_tm
modifier|*
name|pt
init|=
operator|(
expr|struct
name|pfioc_tm
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|pt
operator|->
name|timeout
operator|<
literal|0
operator|||
name|pt
operator|->
name|timeout
operator|>=
name|PFTM_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|pt
operator|->
name|seconds
operator|=
name|V_pf_default_rule
operator|.
name|timeout
index|[
name|pt
operator|->
name|timeout
index|]
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETLIMIT
case|:
block|{
name|struct
name|pfioc_limit
modifier|*
name|pl
init|=
operator|(
expr|struct
name|pfioc_limit
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|pl
operator|->
name|index
operator|<
literal|0
operator|||
name|pl
operator|->
name|index
operator|>=
name|PF_LIMIT_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|pl
operator|->
name|limit
operator|=
name|V_pf_limits
index|[
name|pl
operator|->
name|index
index|]
operator|.
name|limit
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSETLIMIT
case|:
block|{
name|struct
name|pfioc_limit
modifier|*
name|pl
init|=
operator|(
expr|struct
name|pfioc_limit
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|old_limit
decl_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|pl
operator|->
name|index
operator|<
literal|0
operator|||
name|pl
operator|->
name|index
operator|>=
name|PF_LIMIT_MAX
operator|||
name|V_pf_limits
index|[
name|pl
operator|->
name|index
index|]
operator|.
name|zone
operator|==
name|NULL
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|uma_zone_set_max
argument_list|(
name|V_pf_limits
index|[
name|pl
operator|->
name|index
index|]
operator|.
name|zone
argument_list|,
name|pl
operator|->
name|limit
argument_list|)
expr_stmt|;
name|old_limit
operator|=
name|V_pf_limits
index|[
name|pl
operator|->
name|index
index|]
operator|.
name|limit
expr_stmt|;
name|V_pf_limits
index|[
name|pl
operator|->
name|index
index|]
operator|.
name|limit
operator|=
name|pl
operator|->
name|limit
expr_stmt|;
name|pl
operator|->
name|limit
operator|=
name|old_limit
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSETDEBUG
case|:
block|{
name|u_int32_t
modifier|*
name|level
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
decl_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|V_pf_status
operator|.
name|debug
operator|=
operator|*
name|level
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCLRRULECTRS
case|:
block|{
comment|/* obsoleted by DIOCGETRULE with action=PF_GET_CLR_CNTR */
name|struct
name|pf_ruleset
modifier|*
name|ruleset
init|=
operator|&
name|pf_main_ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rule
argument_list|,
argument|ruleset->rules[PF_RULESET_FILTER].active.ptr
argument_list|,
argument|entries
argument_list|)
block|{
name|rule
operator|->
name|evaluations
operator|=
literal|0
expr_stmt|;
name|rule
operator|->
name|packets
index|[
literal|0
index|]
operator|=
name|rule
operator|->
name|packets
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rule
operator|->
name|bytes
index|[
literal|0
index|]
operator|=
name|rule
operator|->
name|bytes
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGIFSPEED
case|:
block|{
name|struct
name|pf_ifspeed
modifier|*
name|psp
init|=
operator|(
expr|struct
name|pf_ifspeed
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ifspeed
name|ps
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
name|psp
operator|->
name|ifname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* Can we completely trust user-land? */
name|strlcpy
argument_list|(
name|ps
operator|.
name|ifname
argument_list|,
name|psp
operator|->
name|ifname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|ifunit
argument_list|(
name|ps
operator|.
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|psp
operator|->
name|baudrate
operator|=
name|ifp
operator|->
name|if_baudrate
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|ALTQ
case|case
name|DIOCSTARTALTQ
case|:
block|{
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
comment|/* enable all altq interfaces on active list */
name|TAILQ_FOREACH
argument_list|(
argument|altq
argument_list|,
argument|V_pf_altqs_active
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|(
name|altq
operator|->
name|local_flags
operator|&
name|PFALTQ_FLAG_IF_REMOVED
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|pf_enable_altq
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|V_pf_altq_running
operator|=
literal|1
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"altq: started\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSTOPALTQ
case|:
block|{
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
comment|/* disable all altq interfaces on active list */
name|TAILQ_FOREACH
argument_list|(
argument|altq
argument_list|,
argument|V_pf_altqs_active
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|(
name|altq
operator|->
name|local_flags
operator|&
name|PFALTQ_FLAG_IF_REMOVED
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|pf_disable_altq
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|V_pf_altq_running
operator|=
literal|0
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"altq: stopped\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCADDALTQ
case|:
block|{
name|struct
name|pfioc_altq
modifier|*
name|pa
init|=
operator|(
expr|struct
name|pfioc_altq
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|,
modifier|*
name|a
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|altq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|altq
argument_list|)
argument_list|,
name|M_PFALTQ
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pa
operator|->
name|altq
argument_list|,
name|altq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_altq
argument_list|)
argument_list|)
expr_stmt|;
name|altq
operator|->
name|local_flags
operator|=
literal|0
expr_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|pa
operator|->
name|ticket
operator|!=
name|V_ticket_altqs_inactive
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|altq
argument_list|,
name|M_PFALTQ
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* 		 * if this is for a queue, find the discipline and 		 * copy the necessary fields 		 */
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|altq
operator|->
name|qid
operator|=
name|pf_qname2qid
argument_list|(
name|altq
operator|->
name|qname
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
name|free
argument_list|(
name|altq
argument_list|,
name|M_PFALTQ
argument_list|)
expr_stmt|;
break|break;
block|}
name|altq
operator|->
name|altq_disc
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|a
argument_list|,
argument|V_pf_altqs_inactive
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|a
operator|->
name|ifname
argument_list|,
name|altq
operator|->
name|ifname
argument_list|,
name|IFNAMSIZ
argument_list|)
operator|==
literal|0
operator|&&
name|a
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|altq
operator|->
name|altq_disc
operator|=
name|a
operator|->
name|altq_disc
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|ifp
operator|=
name|ifunit
argument_list|(
name|altq
operator|->
name|ifname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|altq
operator|->
name|local_flags
operator||=
name|PFALTQ_FLAG_IF_REMOVED
expr_stmt|;
else|else
name|error
operator|=
name|altq_add
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|altq
argument_list|,
name|M_PFALTQ
argument_list|)
expr_stmt|;
break|break;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
name|V_pf_altqs_inactive
argument_list|,
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|altq
argument_list|,
operator|&
name|pa
operator|->
name|altq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_altq
argument_list|)
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETALTQS
case|:
block|{
name|struct
name|pfioc_altq
modifier|*
name|pa
init|=
operator|(
expr|struct
name|pfioc_altq
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|pa
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|altq
argument_list|,
argument|V_pf_altqs_active
argument_list|,
argument|entries
argument_list|)
name|pa
operator|->
name|nr
operator|++
expr_stmt|;
name|pa
operator|->
name|ticket
operator|=
name|V_ticket_altqs_active
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETALTQ
case|:
block|{
name|struct
name|pfioc_altq
modifier|*
name|pa
init|=
operator|(
expr|struct
name|pfioc_altq
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|u_int32_t
name|nr
decl_stmt|;
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|pa
operator|->
name|ticket
operator|!=
name|V_ticket_altqs_active
condition|)
block|{
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|nr
operator|=
literal|0
expr_stmt|;
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|V_pf_altqs_active
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|altq
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|nr
operator|<
name|pa
operator|->
name|nr
operator|)
condition|)
block|{
name|altq
operator|=
name|TAILQ_NEXT
argument_list|(
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|altq
operator|==
name|NULL
condition|)
block|{
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|altq
argument_list|,
operator|&
name|pa
operator|->
name|altq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_altq
argument_list|)
argument_list|)
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCHANGEALTQ
case|:
comment|/* CHANGEALTQ not supported yet! */
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
case|case
name|DIOCGETQSTATS
case|:
block|{
name|struct
name|pfioc_qstats
modifier|*
name|pq
init|=
operator|(
expr|struct
name|pfioc_qstats
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|u_int32_t
name|nr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|pq
operator|->
name|ticket
operator|!=
name|V_ticket_altqs_active
condition|)
block|{
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|nbytes
operator|=
name|pq
operator|->
name|nbytes
expr_stmt|;
name|nr
operator|=
literal|0
expr_stmt|;
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|V_pf_altqs_active
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|altq
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|nr
operator|<
name|pq
operator|->
name|nr
operator|)
condition|)
block|{
name|altq
operator|=
name|TAILQ_NEXT
argument_list|(
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|altq
operator|==
name|NULL
condition|)
block|{
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|altq
operator|->
name|local_flags
operator|&
name|PFALTQ_FLAG_IF_REMOVED
operator|)
operator|!=
literal|0
condition|)
block|{
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|altq_getqstats
argument_list|(
name|altq
argument_list|,
name|pq
operator|->
name|buf
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|pq
operator|->
name|scheduler
operator|=
name|altq
operator|->
name|scheduler
expr_stmt|;
name|pq
operator|->
name|nbytes
operator|=
name|nbytes
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* ALTQ */
case|case
name|DIOCBEGINADDRS
case|:
block|{
name|struct
name|pfioc_pooladdr
modifier|*
name|pp
init|=
operator|(
expr|struct
name|pfioc_pooladdr
operator|*
operator|)
name|addr
decl_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|pf_empty_pool
argument_list|(
operator|&
name|V_pf_pabuf
argument_list|)
expr_stmt|;
name|pp
operator|->
name|ticket
operator|=
operator|++
name|V_ticket_pabuf
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCADDADDR
case|:
block|{
name|struct
name|pfioc_pooladdr
modifier|*
name|pp
init|=
operator|(
expr|struct
name|pfioc_pooladdr
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_pooladdr
modifier|*
name|pa
decl_stmt|;
name|struct
name|pfi_kif
modifier|*
name|kif
init|=
name|NULL
decl_stmt|;
ifndef|#
directive|ifndef
name|INET
if|if
condition|(
name|pp
operator|->
name|af
operator|==
name|AF_INET
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifndef|#
directive|ifndef
name|INET6
if|if
condition|(
name|pp
operator|->
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
name|pp
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_ADDRMASK
operator|&&
name|pp
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_DYNIFTL
operator|&&
name|pp
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_TABLE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|pa
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pa
argument_list|)
argument_list|,
name|M_PFRULE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pp
operator|->
name|addr
argument_list|,
name|pa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
name|kif
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|kif
argument_list|)
argument_list|,
name|PFI_MTYPE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|ticket
operator|!=
name|V_ticket_pabuf
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|pa
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
name|free
argument_list|(
name|kif
argument_list|,
name|PFI_MTYPE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pa
argument_list|,
name|M_PFRULE
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pa
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
block|{
name|pa
operator|->
name|kif
operator|=
name|pfi_kif_attach
argument_list|(
name|kif
argument_list|,
name|pa
operator|->
name|ifname
argument_list|)
expr_stmt|;
name|pfi_kif_ref
argument_list|(
name|pa
operator|->
name|kif
argument_list|)
expr_stmt|;
block|}
else|else
name|pa
operator|->
name|kif
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pa
operator|->
name|addr
operator|.
name|type
operator|==
name|PF_ADDR_DYNIFTL
operator|&&
operator|(
operator|(
name|error
operator|=
name|pfi_dynaddr_setup
argument_list|(
operator|&
name|pa
operator|->
name|addr
argument_list|,
name|pp
operator|->
name|af
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|pa
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
name|pfi_kif_unref
argument_list|(
name|pa
operator|->
name|kif
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|pa
argument_list|,
name|M_PFRULE
argument_list|)
expr_stmt|;
break|break;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|V_pf_pabuf
argument_list|,
name|pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETADDRS
case|:
block|{
name|struct
name|pfioc_pooladdr
modifier|*
name|pp
init|=
operator|(
expr|struct
name|pfioc_pooladdr
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_pool
modifier|*
name|pool
decl_stmt|;
name|struct
name|pf_pooladdr
modifier|*
name|pa
decl_stmt|;
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|pp
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|pool
operator|=
name|pf_get_pool
argument_list|(
name|pp
operator|->
name|anchor
argument_list|,
name|pp
operator|->
name|ticket
argument_list|,
name|pp
operator|->
name|r_action
argument_list|,
name|pp
operator|->
name|r_num
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
block|{
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|pa
argument_list|,
argument|&pool->list
argument_list|,
argument|entries
argument_list|)
name|pp
operator|->
name|nr
operator|++
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETADDR
case|:
block|{
name|struct
name|pfioc_pooladdr
modifier|*
name|pp
init|=
operator|(
expr|struct
name|pfioc_pooladdr
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_pool
modifier|*
name|pool
decl_stmt|;
name|struct
name|pf_pooladdr
modifier|*
name|pa
decl_stmt|;
name|u_int32_t
name|nr
init|=
literal|0
decl_stmt|;
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|pool
operator|=
name|pf_get_pool
argument_list|(
name|pp
operator|->
name|anchor
argument_list|,
name|pp
operator|->
name|ticket
argument_list|,
name|pp
operator|->
name|r_action
argument_list|,
name|pp
operator|->
name|r_num
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
block|{
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|pa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pa
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|nr
operator|<
name|pp
operator|->
name|nr
operator|)
condition|)
block|{
name|pa
operator|=
name|TAILQ_NEXT
argument_list|(
name|pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pa
operator|==
name|NULL
condition|)
block|{
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|pa
argument_list|,
operator|&
name|pp
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|)
expr_stmt|;
name|pf_addr_copyout
argument_list|(
operator|&
name|pp
operator|->
name|addr
operator|.
name|addr
argument_list|)
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCHANGEADDR
case|:
block|{
name|struct
name|pfioc_pooladdr
modifier|*
name|pca
init|=
operator|(
expr|struct
name|pfioc_pooladdr
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_pool
modifier|*
name|pool
decl_stmt|;
name|struct
name|pf_pooladdr
modifier|*
name|oldpa
init|=
name|NULL
decl_stmt|,
modifier|*
name|newpa
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pfi_kif
modifier|*
name|kif
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pca
operator|->
name|action
operator|<
name|PF_CHANGE_ADD_HEAD
operator|||
name|pca
operator|->
name|action
operator|>
name|PF_CHANGE_REMOVE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pca
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_ADDRMASK
operator|&&
name|pca
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_DYNIFTL
operator|&&
name|pca
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_TABLE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pca
operator|->
name|action
operator|!=
name|PF_CHANGE_REMOVE
condition|)
block|{
ifndef|#
directive|ifndef
name|INET
if|if
condition|(
name|pca
operator|->
name|af
operator|==
name|AF_INET
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifndef|#
directive|ifndef
name|INET6
if|if
condition|(
name|pca
operator|->
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
name|newpa
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newpa
argument_list|)
argument_list|,
name|M_PFRULE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pca
operator|->
name|addr
argument_list|,
name|newpa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpa
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
name|kif
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|kif
argument_list|)
argument_list|,
name|PFI_MTYPE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|ERROUT
parameter_list|(
name|x
parameter_list|)
value|{ error = (x); goto DIOCCHANGEADDR_error; }
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pca
operator|->
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
name|pool
operator|=
name|pf_get_pool
argument_list|(
name|pca
operator|->
name|anchor
argument_list|,
name|pca
operator|->
name|ticket
argument_list|,
name|pca
operator|->
name|r_action
argument_list|,
name|pca
operator|->
name|r_num
argument_list|,
name|pca
operator|->
name|r_last
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|pca
operator|->
name|action
operator|!=
name|PF_CHANGE_REMOVE
condition|)
block|{
if|if
condition|(
name|newpa
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
block|{
name|newpa
operator|->
name|kif
operator|=
name|pfi_kif_attach
argument_list|(
name|kif
argument_list|,
name|newpa
operator|->
name|ifname
argument_list|)
expr_stmt|;
name|pfi_kif_ref
argument_list|(
name|newpa
operator|->
name|kif
argument_list|)
expr_stmt|;
block|}
else|else
name|newpa
operator|->
name|kif
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|newpa
operator|->
name|addr
operator|.
name|type
condition|)
block|{
case|case
name|PF_ADDR_DYNIFTL
case|:
name|error
operator|=
name|pfi_dynaddr_setup
argument_list|(
operator|&
name|newpa
operator|->
name|addr
argument_list|,
name|pca
operator|->
name|af
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_ADDR_TABLE
case|:
name|newpa
operator|->
name|addr
operator|.
name|p
operator|.
name|tbl
operator|=
name|pfr_attach_table
argument_list|(
name|ruleset
argument_list|,
name|newpa
operator|->
name|addr
operator|.
name|v
operator|.
name|tblname
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpa
operator|->
name|addr
operator|.
name|p
operator|.
name|tbl
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|newpa
operator|->
name|kif
condition|)
name|pfi_kif_unref
argument_list|(
name|newpa
operator|->
name|kif
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|newpa
argument_list|,
name|M_PFRULE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pca
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_HEAD
condition|)
name|oldpa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pca
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_TAIL
condition|)
name|oldpa
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|pf_palist
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|oldpa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|oldpa
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|i
operator|<
name|pca
operator|->
name|nr
operator|)
condition|)
block|{
name|oldpa
operator|=
name|TAILQ_NEXT
argument_list|(
name|oldpa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|oldpa
operator|==
name|NULL
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pca
operator|->
name|action
operator|==
name|PF_CHANGE_REMOVE
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|oldpa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|oldpa
operator|->
name|addr
operator|.
name|type
condition|)
block|{
case|case
name|PF_ADDR_DYNIFTL
case|:
name|pfi_dynaddr_remove
argument_list|(
name|oldpa
operator|->
name|addr
operator|.
name|p
operator|.
name|dyn
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_ADDR_TABLE
case|:
name|pfr_detach_table
argument_list|(
name|oldpa
operator|->
name|addr
operator|.
name|p
operator|.
name|tbl
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|oldpa
operator|->
name|kif
condition|)
name|pfi_kif_unref
argument_list|(
name|oldpa
operator|->
name|kif
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oldpa
argument_list|,
name|M_PFRULE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|oldpa
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|newpa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pca
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_HEAD
operator|||
name|pca
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_BEFORE
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|oldpa
argument_list|,
name|newpa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|oldpa
argument_list|,
name|newpa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
name|pool
operator|->
name|cur
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|pool
operator|->
name|counter
argument_list|,
operator|&
name|pool
operator|->
name|cur
operator|->
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|,
name|pca
operator|->
name|af
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
undef|#
directive|undef
name|ERROUT
name|DIOCCHANGEADDR_error
label|:
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|newpa
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|newpa
argument_list|,
name|M_PFRULE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kif
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|kif
argument_list|,
name|PFI_MTYPE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETRULESETS
case|:
block|{
name|struct
name|pfioc_ruleset
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_ruleset
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_anchor
modifier|*
name|anchor
decl_stmt|;
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|pr
operator|->
name|path
index|[
sizeof|sizeof
argument_list|(
name|pr
operator|->
name|path
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pr
operator|->
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|pr
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ruleset
operator|->
name|anchor
operator|==
name|NULL
condition|)
block|{
comment|/* XXX kludge for pf_main_ruleset */
name|RB_FOREACH
argument_list|(
argument|anchor
argument_list|,
argument|pf_anchor_global
argument_list|,
argument|&V_pf_anchors
argument_list|)
if|if
condition|(
name|anchor
operator|->
name|parent
operator|==
name|NULL
condition|)
name|pr
operator|->
name|nr
operator|++
expr_stmt|;
block|}
else|else
block|{
name|RB_FOREACH
argument_list|(
argument|anchor
argument_list|,
argument|pf_anchor_node
argument_list|,
argument|&ruleset->anchor->children
argument_list|)
name|pr
operator|->
name|nr
operator|++
expr_stmt|;
block|}
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETRULESET
case|:
block|{
name|struct
name|pfioc_ruleset
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_ruleset
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_anchor
modifier|*
name|anchor
decl_stmt|;
name|u_int32_t
name|nr
init|=
literal|0
decl_stmt|;
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|pr
operator|->
name|path
index|[
sizeof|sizeof
argument_list|(
name|pr
operator|->
name|path
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pr
operator|->
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|pr
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ruleset
operator|->
name|anchor
operator|==
name|NULL
condition|)
block|{
comment|/* XXX kludge for pf_main_ruleset */
name|RB_FOREACH
argument_list|(
argument|anchor
argument_list|,
argument|pf_anchor_global
argument_list|,
argument|&V_pf_anchors
argument_list|)
if|if
condition|(
name|anchor
operator|->
name|parent
operator|==
name|NULL
operator|&&
name|nr
operator|++
operator|==
name|pr
operator|->
name|nr
condition|)
block|{
name|strlcpy
argument_list|(
name|pr
operator|->
name|name
argument_list|,
name|anchor
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|RB_FOREACH
argument_list|(
argument|anchor
argument_list|,
argument|pf_anchor_node
argument_list|,
argument|&ruleset->anchor->children
argument_list|)
if|if
condition|(
name|nr
operator|++
operator|==
name|pr
operator|->
name|nr
condition|)
block|{
name|strlcpy
argument_list|(
name|pr
operator|->
name|name
argument_list|,
name|anchor
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|pr
operator|->
name|name
index|[
literal|0
index|]
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRCLRTABLES
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_clr_tables
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRADDTABLES
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfr_table
modifier|*
name|pfrts
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
name|io
operator|->
name|pfrio_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
expr_stmt|;
name|pfrts
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|pfrts
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|pfrts
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_add_tables
argument_list|(
name|pfrts
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nadd
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|pfrts
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRDELTABLES
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfr_table
modifier|*
name|pfrts
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
name|io
operator|->
name|pfrio_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
expr_stmt|;
name|pfrts
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|pfrts
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|pfrts
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_del_tables
argument_list|(
name|pfrts
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|pfrts
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRGETTABLES
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfr_table
modifier|*
name|pfrts
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
name|io
operator|->
name|pfrio_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
expr_stmt|;
name|pfrts
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_get_tables
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|pfrts
argument_list|,
operator|&
name|io
operator|->
name|pfrio_size
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|pfrts
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfrts
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRGETTSTATS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfr_tstats
modifier|*
name|pfrtstats
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_tstats
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
name|io
operator|->
name|pfrio_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_tstats
argument_list|)
expr_stmt|;
name|pfrtstats
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_get_tstats
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|pfrtstats
argument_list|,
operator|&
name|io
operator|->
name|pfrio_size
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|pfrtstats
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfrtstats
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRCLRTSTATS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfr_table
modifier|*
name|pfrts
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
name|io
operator|->
name|pfrio_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
expr_stmt|;
name|pfrts
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|pfrts
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|pfrts
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_clr_tstats
argument_list|(
name|pfrts
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nzero
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|pfrts
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRSETTFLAGS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfr_table
modifier|*
name|pfrts
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
name|io
operator|->
name|pfrio_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
expr_stmt|;
name|pfrts
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|pfrts
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|pfrts
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_set_tflags
argument_list|(
name|pfrts
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
name|io
operator|->
name|pfrio_setflag
argument_list|,
name|io
operator|->
name|pfrio_clrflag
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nchange
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|pfrts
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRCLRADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_clr_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRADDADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfr_addr
modifier|*
name|pfras
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
name|io
operator|->
name|pfrio_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
expr_stmt|;
name|pfras
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|pfras
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|pfras
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_add_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|pfras
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nadd
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|io
operator|->
name|pfrio_flags
operator|&
name|PFR_FLAG_FEEDBACK
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|pfras
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfras
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRDELADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfr_addr
modifier|*
name|pfras
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
name|io
operator|->
name|pfrio_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
expr_stmt|;
name|pfras
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|pfras
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|pfras
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_del_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|pfras
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|io
operator|->
name|pfrio_flags
operator|&
name|PFR_FLAG_FEEDBACK
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|pfras
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfras
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRSETADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfr_addr
modifier|*
name|pfras
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
operator|(
name|io
operator|->
name|pfrio_size
operator|+
name|io
operator|->
name|pfrio_size2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
expr_stmt|;
name|pfras
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|pfras
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|pfras
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_set_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|pfras
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_size2
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nadd
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nchange
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|io
operator|->
name|pfrio_flags
operator|&
name|PFR_FLAG_FEEDBACK
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|pfras
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfras
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRGETADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfr_addr
modifier|*
name|pfras
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
name|io
operator|->
name|pfrio_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
expr_stmt|;
name|pfras
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_get_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|pfras
argument_list|,
operator|&
name|io
operator|->
name|pfrio_size
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|pfras
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfras
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRGETASTATS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfr_astats
modifier|*
name|pfrastats
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_astats
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
name|io
operator|->
name|pfrio_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_astats
argument_list|)
expr_stmt|;
name|pfrastats
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_get_astats
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|pfrastats
argument_list|,
operator|&
name|io
operator|->
name|pfrio_size
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|pfrastats
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfrastats
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRCLRASTATS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfr_addr
modifier|*
name|pfras
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
name|io
operator|->
name|pfrio_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
expr_stmt|;
name|pfras
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|pfras
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|pfras
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_clr_astats
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|pfras
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nzero
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|io
operator|->
name|pfrio_flags
operator|&
name|PFR_FLAG_FEEDBACK
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|pfras
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfras
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRTSTADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfr_addr
modifier|*
name|pfras
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
name|io
operator|->
name|pfrio_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
expr_stmt|;
name|pfras
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|pfras
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|pfras
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_tst_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|pfras
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nmatch
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|pfras
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfras
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRINADEFINE
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfr_addr
modifier|*
name|pfras
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
name|io
operator|->
name|pfrio_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
expr_stmt|;
name|pfras
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|pfras
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|pfras
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfr_ina_define
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|pfras
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nadd
argument_list|,
operator|&
name|io
operator|->
name|pfrio_naddr
argument_list|,
name|io
operator|->
name|pfrio_ticket
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|pfras
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCOSFPADD
case|:
block|{
name|struct
name|pf_osfp_ioctl
modifier|*
name|io
init|=
operator|(
expr|struct
name|pf_osfp_ioctl
operator|*
operator|)
name|addr
decl_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pf_osfp_add
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCOSFPGET
case|:
block|{
name|struct
name|pf_osfp_ioctl
modifier|*
name|io
init|=
operator|(
expr|struct
name|pf_osfp_ioctl
operator|*
operator|)
name|addr
decl_stmt|;
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pf_osfp_get
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCXBEGIN
case|:
block|{
name|struct
name|pfioc_trans
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_trans
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfioc_trans_e
modifier|*
name|ioes
decl_stmt|,
modifier|*
name|ioe
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|esize
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ioe
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pfioc_trans_e
argument_list|)
operator|*
name|io
operator|->
name|size
expr_stmt|;
name|ioes
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|io
operator|->
name|array
argument_list|,
name|ioes
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ioe
operator|=
name|ioes
init|;
name|i
operator|<
name|io
operator|->
name|size
condition|;
name|i
operator|++
operator|,
name|ioe
operator|++
control|)
block|{
switch|switch
condition|(
name|ioe
operator|->
name|rs_num
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ
case|case
name|PF_RULESET_ALTQ
case|:
if|if
condition|(
name|ioe
operator|->
name|anchor
index|[
literal|0
index|]
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|pf_begin_altq
argument_list|(
operator|&
name|ioe
operator|->
name|ticket
argument_list|)
operator|)
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
endif|#
directive|endif
comment|/* ALTQ */
case|case
name|PF_RULESET_TABLE
case|:
block|{
name|struct
name|pfr_table
name|table
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|table
argument_list|,
sizeof|sizeof
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|table
operator|.
name|pfrt_anchor
argument_list|,
name|ioe
operator|->
name|anchor
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|.
name|pfrt_anchor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pfr_ina_begin
argument_list|(
operator|&
name|table
argument_list|,
operator|&
name|ioe
operator|->
name|ticket
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
block|}
default|default:
if|if
condition|(
operator|(
name|error
operator|=
name|pf_begin_rules
argument_list|(
operator|&
name|ioe
operator|->
name|ticket
argument_list|,
name|ioe
operator|->
name|rs_num
argument_list|,
name|ioe
operator|->
name|anchor
argument_list|)
operator|)
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
block|}
block|}
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|ioes
argument_list|,
name|io
operator|->
name|array
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCXROLLBACK
case|:
block|{
name|struct
name|pfioc_trans
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_trans
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfioc_trans_e
modifier|*
name|ioe
decl_stmt|,
modifier|*
name|ioes
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|esize
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ioe
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pfioc_trans_e
argument_list|)
operator|*
name|io
operator|->
name|size
expr_stmt|;
name|ioes
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|io
operator|->
name|array
argument_list|,
name|ioes
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ioe
operator|=
name|ioes
init|;
name|i
operator|<
name|io
operator|->
name|size
condition|;
name|i
operator|++
operator|,
name|ioe
operator|++
control|)
block|{
switch|switch
condition|(
name|ioe
operator|->
name|rs_num
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ
case|case
name|PF_RULESET_ALTQ
case|:
if|if
condition|(
name|ioe
operator|->
name|anchor
index|[
literal|0
index|]
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|pf_rollback_altq
argument_list|(
name|ioe
operator|->
name|ticket
argument_list|)
operator|)
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
comment|/* really bad */
block|}
break|break;
endif|#
directive|endif
comment|/* ALTQ */
case|case
name|PF_RULESET_TABLE
case|:
block|{
name|struct
name|pfr_table
name|table
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|table
argument_list|,
sizeof|sizeof
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|table
operator|.
name|pfrt_anchor
argument_list|,
name|ioe
operator|->
name|anchor
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|.
name|pfrt_anchor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pfr_ina_rollback
argument_list|(
operator|&
name|table
argument_list|,
name|ioe
operator|->
name|ticket
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
comment|/* really bad */
block|}
break|break;
block|}
default|default:
if|if
condition|(
operator|(
name|error
operator|=
name|pf_rollback_rules
argument_list|(
name|ioe
operator|->
name|ticket
argument_list|,
name|ioe
operator|->
name|rs_num
argument_list|,
name|ioe
operator|->
name|anchor
argument_list|)
operator|)
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
comment|/* really bad */
block|}
break|break;
block|}
block|}
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCXCOMMIT
case|:
block|{
name|struct
name|pfioc_trans
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_trans
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfioc_trans_e
modifier|*
name|ioe
decl_stmt|,
modifier|*
name|ioes
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|size_t
name|totlen
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|esize
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ioe
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|totlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pfioc_trans_e
argument_list|)
operator|*
name|io
operator|->
name|size
expr_stmt|;
name|ioes
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|io
operator|->
name|array
argument_list|,
name|ioes
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
comment|/* First makes sure everything will succeed. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ioe
operator|=
name|ioes
init|;
name|i
operator|<
name|io
operator|->
name|size
condition|;
name|i
operator|++
operator|,
name|ioe
operator|++
control|)
block|{
switch|switch
condition|(
name|ioe
operator|->
name|rs_num
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ
case|case
name|PF_RULESET_ALTQ
case|:
if|if
condition|(
name|ioe
operator|->
name|anchor
index|[
literal|0
index|]
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
name|V_altqs_inactive_open
operator|||
name|ioe
operator|->
name|ticket
operator|!=
name|V_ticket_altqs_inactive
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
endif|#
directive|endif
comment|/* ALTQ */
case|case
name|PF_RULESET_TABLE
case|:
name|rs
operator|=
name|pf_find_ruleset
argument_list|(
name|ioe
operator|->
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NULL
operator|||
operator|!
name|rs
operator|->
name|topen
operator|||
name|ioe
operator|->
name|ticket
operator|!=
name|rs
operator|->
name|tticket
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
default|default:
if|if
condition|(
name|ioe
operator|->
name|rs_num
operator|<
literal|0
operator|||
name|ioe
operator|->
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rs
operator|=
name|pf_find_ruleset
argument_list|(
name|ioe
operator|->
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NULL
operator|||
operator|!
name|rs
operator|->
name|rules
index|[
name|ioe
operator|->
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|open
operator|||
name|rs
operator|->
name|rules
index|[
name|ioe
operator|->
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
operator|!=
name|ioe
operator|->
name|ticket
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
block|}
block|}
comment|/* Now do the commit - no errors should happen here. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ioe
operator|=
name|ioes
init|;
name|i
operator|<
name|io
operator|->
name|size
condition|;
name|i
operator|++
operator|,
name|ioe
operator|++
control|)
block|{
switch|switch
condition|(
name|ioe
operator|->
name|rs_num
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ
case|case
name|PF_RULESET_ALTQ
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|pf_commit_altq
argument_list|(
name|ioe
operator|->
name|ticket
argument_list|)
operator|)
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
comment|/* really bad */
block|}
break|break;
endif|#
directive|endif
comment|/* ALTQ */
case|case
name|PF_RULESET_TABLE
case|:
block|{
name|struct
name|pfr_table
name|table
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|table
argument_list|,
sizeof|sizeof
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|table
operator|.
name|pfrt_anchor
argument_list|,
name|ioe
operator|->
name|anchor
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|.
name|pfrt_anchor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pfr_ina_commit
argument_list|(
operator|&
name|table
argument_list|,
name|ioe
operator|->
name|ticket
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
comment|/* really bad */
block|}
break|break;
block|}
default|default:
if|if
condition|(
operator|(
name|error
operator|=
name|pf_commit_rules
argument_list|(
name|ioe
operator|->
name|ticket
argument_list|,
name|ioe
operator|->
name|rs_num
argument_list|,
name|ioe
operator|->
name|anchor
argument_list|)
operator|)
condition|)
block|{
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
comment|/* really bad */
block|}
break|break;
block|}
block|}
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ioes
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETSRCNODES
case|:
block|{
name|struct
name|pfioc_src_nodes
modifier|*
name|psn
init|=
operator|(
expr|struct
name|pfioc_src_nodes
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_srchash
modifier|*
name|sh
decl_stmt|;
name|struct
name|pf_src_node
modifier|*
name|n
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|pstore
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|nr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|psn
operator|->
name|psn_len
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sh
operator|=
name|V_pf_srchash
init|;
name|i
operator|<
name|V_pf_srchashmask
condition|;
name|i
operator|++
operator|,
name|sh
operator|++
control|)
block|{
name|PF_HASHROW_LOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|n
argument_list|,
argument|&sh->nodes
argument_list|,
argument|entry
argument_list|)
name|nr
operator|++
expr_stmt|;
name|PF_HASHROW_UNLOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
name|psn
operator|->
name|psn_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pf_src_node
argument_list|)
operator|*
name|nr
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|pstore
operator|=
name|malloc
argument_list|(
name|psn
operator|->
name|psn_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sh
operator|=
name|V_pf_srchash
init|;
name|i
operator|<
name|V_pf_srchashmask
condition|;
name|i
operator|++
operator|,
name|sh
operator|++
control|)
block|{
name|PF_HASHROW_LOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|n
argument_list|,
argument|&sh->nodes
argument_list|,
argument|entry
argument_list|)
block|{
name|int
name|secs
init|=
name|time_uptime
decl_stmt|,
name|diff
decl_stmt|;
if|if
condition|(
operator|(
name|nr
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|>
operator|(
name|unsigned
operator|)
name|psn
operator|->
name|psn_len
condition|)
break|break;
name|bcopy
argument_list|(
name|n
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_src_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|rule
operator|.
name|ptr
operator|!=
name|NULL
condition|)
name|p
operator|->
name|rule
operator|.
name|nr
operator|=
name|n
operator|->
name|rule
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
name|p
operator|->
name|creation
operator|=
name|secs
operator|-
name|p
operator|->
name|creation
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|expire
operator|>
name|secs
condition|)
name|p
operator|->
name|expire
operator|-=
name|secs
expr_stmt|;
else|else
name|p
operator|->
name|expire
operator|=
literal|0
expr_stmt|;
comment|/* Adjust the connection rate estimate. */
name|diff
operator|=
name|secs
operator|-
name|n
operator|->
name|conn_rate
operator|.
name|last
expr_stmt|;
if|if
condition|(
name|diff
operator|>=
name|n
operator|->
name|conn_rate
operator|.
name|seconds
condition|)
name|p
operator|->
name|conn_rate
operator|.
name|count
operator|=
literal|0
expr_stmt|;
else|else
name|p
operator|->
name|conn_rate
operator|.
name|count
operator|-=
name|n
operator|->
name|conn_rate
operator|.
name|count
operator|*
name|diff
operator|/
name|n
operator|->
name|conn_rate
operator|.
name|seconds
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
name|PF_HASHROW_UNLOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|copyout
argument_list|(
name|pstore
argument_list|,
name|psn
operator|->
name|psn_src_nodes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_src_node
argument_list|)
operator|*
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|pstore
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
name|psn
operator|->
name|psn_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pf_src_node
argument_list|)
operator|*
name|nr
expr_stmt|;
name|free
argument_list|(
name|pstore
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCLRSRCNODES
case|:
block|{
name|pf_clear_srcnodes
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|pf_purge_expired_src_nodes
argument_list|()
expr_stmt|;
name|V_pf_status
operator|.
name|src_nodes
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|DIOCKILLSRCNODES
case|:
block|{
name|struct
name|pfioc_src_node_kill
modifier|*
name|psnk
init|=
operator|(
expr|struct
name|pfioc_src_node_kill
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_srchash
modifier|*
name|sh
decl_stmt|;
name|struct
name|pf_src_node
modifier|*
name|sn
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|killed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sh
operator|=
name|V_pf_srchash
init|;
name|i
operator|<
name|V_pf_srchashmask
condition|;
name|i
operator|++
operator|,
name|sh
operator|++
control|)
block|{
comment|/* 		     * XXXGL: we don't ever acquire sources hash lock 		     * but if we ever do, the below call to pf_clear_srcnodes() 		     * would lead to a LOR. 		     */
name|PF_HASHROW_LOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sn
argument_list|,
argument|&sh->nodes
argument_list|,
argument|entry
argument_list|)
if|if
condition|(
name|PF_MATCHA
argument_list|(
name|psnk
operator|->
name|psnk_src
operator|.
name|neg
argument_list|,
operator|&
name|psnk
operator|->
name|psnk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|,
operator|&
name|psnk
operator|->
name|psnk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
operator|&
name|sn
operator|->
name|addr
argument_list|,
name|sn
operator|->
name|af
argument_list|)
operator|&&
name|PF_MATCHA
argument_list|(
name|psnk
operator|->
name|psnk_dst
operator|.
name|neg
argument_list|,
operator|&
name|psnk
operator|->
name|psnk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|,
operator|&
name|psnk
operator|->
name|psnk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
operator|&
name|sn
operator|->
name|raddr
argument_list|,
name|sn
operator|->
name|af
argument_list|)
condition|)
block|{
comment|/* Handle state to src_node linkage */
if|if
condition|(
name|sn
operator|->
name|states
operator|!=
literal|0
condition|)
name|pf_clear_srcnodes
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|sn
operator|->
name|expire
operator|=
literal|1
expr_stmt|;
name|killed
operator|++
expr_stmt|;
block|}
name|PF_HASHROW_UNLOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|killed
operator|>
literal|0
condition|)
name|pf_purge_expired_src_nodes
argument_list|()
expr_stmt|;
name|psnk
operator|->
name|psnk_killed
operator|=
name|killed
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSETHOSTID
case|:
block|{
name|u_int32_t
modifier|*
name|hostid
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
decl_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|hostid
operator|==
literal|0
condition|)
name|V_pf_status
operator|.
name|hostid
operator|=
name|arc4random
argument_list|()
expr_stmt|;
else|else
name|V_pf_status
operator|.
name|hostid
operator|=
operator|*
name|hostid
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCOSFPFLUSH
case|:
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|pf_osfp_flush
argument_list|()
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|DIOCIGETIFACES
case|:
block|{
name|struct
name|pfioc_iface
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_iface
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfi_kif
modifier|*
name|ifstore
decl_stmt|;
name|size_t
name|bufsiz
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfiio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfi_kif
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|bufsiz
operator|=
name|io
operator|->
name|pfiio_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pfi_kif
argument_list|)
expr_stmt|;
name|ifstore
operator|=
name|malloc
argument_list|(
name|bufsiz
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|PF_RULES_RLOCK
argument_list|()
expr_stmt|;
name|pfi_get_ifaces
argument_list|(
name|io
operator|->
name|pfiio_name
argument_list|,
name|ifstore
argument_list|,
operator|&
name|io
operator|->
name|pfiio_size
argument_list|)
expr_stmt|;
name|PF_RULES_RUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|ifstore
argument_list|,
name|io
operator|->
name|pfiio_buffer
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ifstore
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSETIFFLAG
case|:
block|{
name|struct
name|pfioc_iface
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_iface
operator|*
operator|)
name|addr
decl_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfi_set_flags
argument_list|(
name|io
operator|->
name|pfiio_name
argument_list|,
name|io
operator|->
name|pfiio_flags
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCLRIFFLAG
case|:
block|{
name|struct
name|pfioc_iface
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_iface
operator|*
operator|)
name|addr
decl_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|pfi_clear_flags
argument_list|(
name|io
operator|->
name|pfiio_name
argument_list|,
name|io
operator|->
name|pfiio_flags
argument_list|)
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|fail
label|:
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pfsync_state_export
parameter_list|(
name|struct
name|pfsync_state
modifier|*
name|sp
parameter_list|,
name|struct
name|pf_state
modifier|*
name|st
parameter_list|)
block|{
name|bzero
argument_list|(
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pfsync_state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy from state key */
name|sp
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|.
name|addr
index|[
literal|0
index|]
operator|=
name|st
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|->
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|.
name|addr
index|[
literal|1
index|]
operator|=
name|st
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|->
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|sp
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|.
name|port
index|[
literal|0
index|]
operator|=
name|st
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|->
name|port
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|.
name|port
index|[
literal|1
index|]
operator|=
name|st
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|->
name|port
index|[
literal|1
index|]
expr_stmt|;
name|sp
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
operator|.
name|addr
index|[
literal|0
index|]
operator|=
name|st
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
operator|->
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
operator|.
name|addr
index|[
literal|1
index|]
operator|=
name|st
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
operator|->
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|sp
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
operator|.
name|port
index|[
literal|0
index|]
operator|=
name|st
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
operator|->
name|port
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
operator|.
name|port
index|[
literal|1
index|]
operator|=
name|st
operator|->
name|key
index|[
name|PF_SK_STACK
index|]
operator|->
name|port
index|[
literal|1
index|]
expr_stmt|;
name|sp
operator|->
name|proto
operator|=
name|st
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|->
name|proto
expr_stmt|;
name|sp
operator|->
name|af
operator|=
name|st
operator|->
name|key
index|[
name|PF_SK_WIRE
index|]
operator|->
name|af
expr_stmt|;
comment|/* copy from state */
name|strlcpy
argument_list|(
name|sp
operator|->
name|ifname
argument_list|,
name|st
operator|->
name|kif
operator|->
name|pfik_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|ifname
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|st
operator|->
name|rt_addr
argument_list|,
operator|&
name|sp
operator|->
name|rt_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|rt_addr
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|creation
operator|=
name|htonl
argument_list|(
name|time_uptime
operator|-
name|st
operator|->
name|creation
argument_list|)
expr_stmt|;
name|sp
operator|->
name|expire
operator|=
name|pf_state_expires
argument_list|(
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|expire
operator|<=
name|time_uptime
condition|)
name|sp
operator|->
name|expire
operator|=
name|htonl
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|sp
operator|->
name|expire
operator|=
name|htonl
argument_list|(
name|sp
operator|->
name|expire
operator|-
name|time_uptime
argument_list|)
expr_stmt|;
name|sp
operator|->
name|direction
operator|=
name|st
operator|->
name|direction
expr_stmt|;
name|sp
operator|->
name|log
operator|=
name|st
operator|->
name|log
expr_stmt|;
name|sp
operator|->
name|timeout
operator|=
name|st
operator|->
name|timeout
expr_stmt|;
name|sp
operator|->
name|state_flags
operator|=
name|st
operator|->
name|state_flags
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|src_node
condition|)
name|sp
operator|->
name|sync_flags
operator||=
name|PFSYNC_FLAG_SRCNODE
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|nat_src_node
condition|)
name|sp
operator|->
name|sync_flags
operator||=
name|PFSYNC_FLAG_NATSRCNODE
expr_stmt|;
name|sp
operator|->
name|id
operator|=
name|st
operator|->
name|id
expr_stmt|;
name|sp
operator|->
name|creatorid
operator|=
name|st
operator|->
name|creatorid
expr_stmt|;
name|pf_state_peer_hton
argument_list|(
operator|&
name|st
operator|->
name|src
argument_list|,
operator|&
name|sp
operator|->
name|src
argument_list|)
expr_stmt|;
name|pf_state_peer_hton
argument_list|(
operator|&
name|st
operator|->
name|dst
argument_list|,
operator|&
name|sp
operator|->
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|rule
operator|.
name|ptr
operator|==
name|NULL
condition|)
name|sp
operator|->
name|rule
operator|=
name|htonl
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|sp
operator|->
name|rule
operator|=
name|htonl
argument_list|(
name|st
operator|->
name|rule
operator|.
name|ptr
operator|->
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|anchor
operator|.
name|ptr
operator|==
name|NULL
condition|)
name|sp
operator|->
name|anchor
operator|=
name|htonl
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|sp
operator|->
name|anchor
operator|=
name|htonl
argument_list|(
name|st
operator|->
name|anchor
operator|.
name|ptr
operator|->
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|nat_rule
operator|.
name|ptr
operator|==
name|NULL
condition|)
name|sp
operator|->
name|nat_rule
operator|=
name|htonl
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|sp
operator|->
name|nat_rule
operator|=
name|htonl
argument_list|(
name|st
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|nr
argument_list|)
expr_stmt|;
name|pf_state_counter_hton
argument_list|(
name|st
operator|->
name|packets
index|[
literal|0
index|]
argument_list|,
name|sp
operator|->
name|packets
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pf_state_counter_hton
argument_list|(
name|st
operator|->
name|packets
index|[
literal|1
index|]
argument_list|,
name|sp
operator|->
name|packets
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pf_state_counter_hton
argument_list|(
name|st
operator|->
name|bytes
index|[
literal|0
index|]
argument_list|,
name|sp
operator|->
name|bytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pf_state_counter_hton
argument_list|(
name|st
operator|->
name|bytes
index|[
literal|1
index|]
argument_list|,
name|sp
operator|->
name|bytes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pf_tbladdr_copyout
parameter_list|(
name|struct
name|pf_addr_wrap
modifier|*
name|aw
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|kt
decl_stmt|;
name|KASSERT
argument_list|(
name|aw
operator|->
name|type
operator|==
name|PF_ADDR_TABLE
argument_list|,
operator|(
literal|"%s: type %u"
operator|,
name|__func__
operator|,
name|aw
operator|->
name|type
operator|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|aw
operator|->
name|p
operator|.
name|tbl
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
operator|&&
name|kt
operator|->
name|pfrkt_root
operator|!=
name|NULL
condition|)
name|kt
operator|=
name|kt
operator|->
name|pfrkt_root
expr_stmt|;
name|aw
operator|->
name|p
operator|.
name|tbl
operator|=
name|NULL
expr_stmt|;
name|aw
operator|->
name|p
operator|.
name|tblcnt
operator|=
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|?
name|kt
operator|->
name|pfrkt_cnt
else|:
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX - Check for version missmatch!!!  */
end_comment

begin_function
specifier|static
name|void
name|pf_clear_states
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pf_state
modifier|*
name|s
decl_stmt|;
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|V_pf_hashmask
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|pf_idhash
modifier|*
name|ih
init|=
operator|&
name|V_pf_idhash
index|[
name|i
index|]
decl_stmt|;
name|relock
label|:
name|PF_HASHROW_LOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ih->states
argument_list|,
argument|entry
argument_list|)
block|{
name|s
operator|->
name|timeout
operator|=
name|PFTM_PURGE
expr_stmt|;
comment|/* Don't send out individual delete messages. */
name|s
operator|->
name|sync_state
operator|=
name|PFSTATE_NOSYNC
expr_stmt|;
name|pf_unlink_state
argument_list|(
name|s
argument_list|,
name|PF_ENTER_LOCKED
argument_list|)
expr_stmt|;
goto|goto
name|relock
goto|;
block|}
name|PF_HASHROW_UNLOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pf_clear_tables
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pfioc_table
name|io
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|io
argument_list|,
sizeof|sizeof
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|pfr_clr_tables
argument_list|(
operator|&
name|io
operator|.
name|pfrio_table
argument_list|,
operator|&
name|io
operator|.
name|pfrio_ndel
argument_list|,
name|io
operator|.
name|pfrio_flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pf_clear_srcnodes
parameter_list|(
name|struct
name|pf_src_node
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|pf_state
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|V_pf_hashmask
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|pf_idhash
modifier|*
name|ih
init|=
operator|&
name|V_pf_idhash
index|[
name|i
index|]
decl_stmt|;
name|PF_HASHROW_LOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ih->states
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|n
operator|==
name|s
operator|->
name|src_node
condition|)
name|s
operator|->
name|src_node
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|n
operator|==
name|s
operator|->
name|nat_src_node
condition|)
name|s
operator|->
name|nat_src_node
operator|=
name|NULL
expr_stmt|;
block|}
name|PF_HASHROW_UNLOCK
argument_list|(
name|ih
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|struct
name|pf_srchash
modifier|*
name|sh
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sh
operator|=
name|V_pf_srchash
init|;
name|i
operator|<
name|V_pf_srchashmask
condition|;
name|i
operator|++
operator|,
name|sh
operator|++
control|)
block|{
name|PF_HASHROW_LOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|n
argument_list|,
argument|&sh->nodes
argument_list|,
argument|entry
argument_list|)
block|{
name|n
operator|->
name|expire
operator|=
literal|1
expr_stmt|;
name|n
operator|->
name|states
operator|=
literal|0
expr_stmt|;
block|}
name|PF_HASHROW_UNLOCK
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* XXX: hash slot should already be locked here. */
name|n
operator|->
name|expire
operator|=
literal|1
expr_stmt|;
name|n
operator|->
name|states
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * XXX - Check for version missmatch!!!  */
end_comment

begin_comment
comment|/*  * Duplicate pfctl -Fa operation to get rid of as much as we can.  */
end_comment

begin_function
specifier|static
name|int
name|shutdown_pf
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|t
index|[
literal|5
index|]
decl_stmt|;
name|char
name|nn
init|=
literal|'\0'
decl_stmt|;
name|V_pf_status
operator|.
name|running
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|pf_begin_rules
argument_list|(
operator|&
name|t
index|[
literal|0
index|]
argument_list|,
name|PF_RULESET_SCRUB
argument_list|,
operator|&
name|nn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"shutdown_pf: SCRUB\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|pf_begin_rules
argument_list|(
operator|&
name|t
index|[
literal|1
index|]
argument_list|,
name|PF_RULESET_FILTER
argument_list|,
operator|&
name|nn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"shutdown_pf: FILTER\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* XXX: rollback? */
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|pf_begin_rules
argument_list|(
operator|&
name|t
index|[
literal|2
index|]
argument_list|,
name|PF_RULESET_NAT
argument_list|,
operator|&
name|nn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"shutdown_pf: NAT\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* XXX: rollback? */
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|pf_begin_rules
argument_list|(
operator|&
name|t
index|[
literal|3
index|]
argument_list|,
name|PF_RULESET_BINAT
argument_list|,
operator|&
name|nn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"shutdown_pf: BINAT\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* XXX: rollback? */
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|pf_begin_rules
argument_list|(
operator|&
name|t
index|[
literal|4
index|]
argument_list|,
name|PF_RULESET_RDR
argument_list|,
operator|&
name|nn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"shutdown_pf: RDR\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* XXX: rollback? */
block|}
comment|/* XXX: these should always succeed here */
name|pf_commit_rules
argument_list|(
name|t
index|[
literal|0
index|]
argument_list|,
name|PF_RULESET_SCRUB
argument_list|,
operator|&
name|nn
argument_list|)
expr_stmt|;
name|pf_commit_rules
argument_list|(
name|t
index|[
literal|1
index|]
argument_list|,
name|PF_RULESET_FILTER
argument_list|,
operator|&
name|nn
argument_list|)
expr_stmt|;
name|pf_commit_rules
argument_list|(
name|t
index|[
literal|2
index|]
argument_list|,
name|PF_RULESET_NAT
argument_list|,
operator|&
name|nn
argument_list|)
expr_stmt|;
name|pf_commit_rules
argument_list|(
name|t
index|[
literal|3
index|]
argument_list|,
name|PF_RULESET_BINAT
argument_list|,
operator|&
name|nn
argument_list|)
expr_stmt|;
name|pf_commit_rules
argument_list|(
name|t
index|[
literal|4
index|]
argument_list|,
name|PF_RULESET_RDR
argument_list|,
operator|&
name|nn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pf_clear_tables
argument_list|()
operator|)
operator|!=
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|ALTQ
if|if
condition|(
operator|(
name|error
operator|=
name|pf_begin_altq
argument_list|(
operator|&
name|t
index|[
literal|0
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"shutdown_pf: ALTQ\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|pf_commit_altq
argument_list|(
name|t
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pf_clear_states
argument_list|()
expr_stmt|;
name|pf_clear_srcnodes
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* status does not use malloced mem so no need to cleanup */
comment|/* fingerprints and interfaces have thier own cleanup code */
block|}
do|while
condition|(
literal|0
condition|)
do|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
specifier|static
name|int
name|pf_check_in
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
comment|/* 	 * XXX Wed Jul 9 22:03:16 2003 UTC 	 * OpenBSD has changed its byte ordering convention on ip_len/ip_off 	 * in network stack. OpenBSD's network stack have converted 	 * ip_len/ip_off to host byte order frist as FreeBSD. 	 * Now this is not true anymore , so we should convert back to network 	 * byte order. 	 */
name|struct
name|ip
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|int
name|chk
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
comment|/* if m_pkthdr.len is less than ip header, pf will handle. */
name|h
operator|=
name|mtod
argument_list|(
operator|*
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|HTONS
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|HTONS
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
expr_stmt|;
block|}
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|chk
operator|=
name|pf_test
argument_list|(
name|PF_IN
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
if|if
condition|(
name|chk
operator|&&
operator|*
name|m
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* pf_test can change ip header location */
name|h
operator|=
name|mtod
argument_list|(
operator|*
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|NTOHS
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|NTOHS
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
expr_stmt|;
block|}
return|return
name|chk
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_check_out
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
comment|/* 	 * XXX Wed Jul 9 22:03:16 2003 UTC 	 * OpenBSD has changed its byte ordering convention on ip_len/ip_off 	 * in network stack. OpenBSD's network stack have converted 	 * ip_len/ip_off to host byte order frist as FreeBSD. 	 * Now this is not true anymore , so we should convert back to network 	 * byte order. 	 */
name|struct
name|ip
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|int
name|chk
decl_stmt|;
comment|/* We need a proper CSUM befor we start (s. OpenBSD ip_output) */
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA
condition|)
block|{
name|in_delayed_cksum
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|(
operator|*
name|m
operator|)
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_DELAY_DATA
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
condition|)
block|{
comment|/* if m_pkthdr.len is less than ip header, pf will handle. */
name|h
operator|=
name|mtod
argument_list|(
operator|*
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|HTONS
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|HTONS
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
expr_stmt|;
block|}
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|chk
operator|=
name|pf_test
argument_list|(
name|PF_OUT
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
if|if
condition|(
name|chk
operator|&&
operator|*
name|m
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* pf_test can change ip header location */
name|h
operator|=
name|mtod
argument_list|(
operator|*
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|NTOHS
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|NTOHS
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
expr_stmt|;
block|}
return|return
name|chk
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
specifier|static
name|int
name|pf_check6_in
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
comment|/* 	 * IPv6 is not affected by ip_len/ip_off byte order changes. 	 */
name|int
name|chk
decl_stmt|;
comment|/* 	 * In case of loopback traffic IPv6 uses the real interface in 	 * order to support scoped addresses. In order to support stateful 	 * filtering we have change this to lo0 as it is the case in IPv4. 	 */
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|chk
operator|=
name|pf_test6
argument_list|(
name|PF_IN
argument_list|,
operator|(
operator|*
name|m
operator|)
operator|->
name|m_flags
operator|&
name|M_LOOP
condition|?
name|V_loif
else|:
name|ifp
argument_list|,
name|m
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
if|if
condition|(
name|chk
operator|&&
operator|*
name|m
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|chk
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_check6_out
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
comment|/* 	 * IPv6 does not affected ip_len/ip_off byte order changes. 	 */
name|int
name|chk
decl_stmt|;
comment|/* We need a proper CSUM before we start (s. OpenBSD ip_output) */
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
comment|/* XXX-BZ copy&paste error from r126261? */
name|in_delayed_cksum
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
name|m
operator|)
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_DELAY_DATA
expr_stmt|;
block|}
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|chk
operator|=
name|pf_test6
argument_list|(
name|PF_OUT
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
if|if
condition|(
name|chk
operator|&&
operator|*
name|m
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|chk
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_function
specifier|static
name|int
name|hook_pf
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|pfil_head
modifier|*
name|pfh_inet
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|pfil_head
modifier|*
name|pfh_inet6
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|V_pf_pfil_hooked
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|INET
name|pfh_inet
operator|=
name|pfil_head_get
argument_list|(
name|PFIL_TYPE_AF
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfh_inet
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
comment|/* XXX */
name|pfil_add_hook
argument_list|(
name|pf_check_in
argument_list|,
name|NULL
argument_list|,
name|PFIL_IN
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet
argument_list|)
expr_stmt|;
name|pfil_add_hook
argument_list|(
name|pf_check_out
argument_list|,
name|NULL
argument_list|,
name|PFIL_OUT
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|pfh_inet6
operator|=
name|pfil_head_get
argument_list|(
name|PFIL_TYPE_AF
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfh_inet6
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
name|pfil_remove_hook
argument_list|(
name|pf_check_in
argument_list|,
name|NULL
argument_list|,
name|PFIL_IN
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet
argument_list|)
expr_stmt|;
name|pfil_remove_hook
argument_list|(
name|pf_check_out
argument_list|,
name|NULL
argument_list|,
name|PFIL_OUT
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ESRCH
operator|)
return|;
comment|/* XXX */
block|}
name|pfil_add_hook
argument_list|(
name|pf_check6_in
argument_list|,
name|NULL
argument_list|,
name|PFIL_IN
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet6
argument_list|)
expr_stmt|;
name|pfil_add_hook
argument_list|(
name|pf_check6_out
argument_list|,
name|NULL
argument_list|,
name|PFIL_OUT
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet6
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|V_pf_pfil_hooked
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dehook_pf
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|pfil_head
modifier|*
name|pfh_inet
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|pfil_head
modifier|*
name|pfh_inet6
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|V_pf_pfil_hooked
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|INET
name|pfh_inet
operator|=
name|pfil_head_get
argument_list|(
name|PFIL_TYPE_AF
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfh_inet
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
comment|/* XXX */
name|pfil_remove_hook
argument_list|(
name|pf_check_in
argument_list|,
name|NULL
argument_list|,
name|PFIL_IN
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet
argument_list|)
expr_stmt|;
name|pfil_remove_hook
argument_list|(
name|pf_check_out
argument_list|,
name|NULL
argument_list|,
name|PFIL_OUT
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|pfh_inet6
operator|=
name|pfil_head_get
argument_list|(
name|PFIL_TYPE_AF
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfh_inet6
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
comment|/* XXX */
name|pfil_remove_hook
argument_list|(
name|pf_check6_in
argument_list|,
name|NULL
argument_list|,
name|PFIL_IN
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet6
argument_list|)
expr_stmt|;
name|pfil_remove_hook
argument_list|(
name|pf_check6_out
argument_list|,
name|NULL
argument_list|,
name|PFIL_OUT
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet6
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|V_pf_pfil_hooked
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_load
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|VNET_LIST_RLOCK
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|V_pf_pfil_hooked
operator|=
literal|0
expr_stmt|;
name|V_pf_end_threads
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|V_pf_tags
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|V_pf_qids
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_LIST_RUNLOCK
argument_list|()
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|pf_rules_lock
argument_list|,
literal|"pf rulesets"
argument_list|)
expr_stmt|;
name|pf_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|pf_cdevsw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
name|PF_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pfattach
argument_list|()
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_unload
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|V_pf_status
operator|.
name|running
operator|=
literal|0
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|swi_remove
argument_list|(
name|V_pf_swi_cookie
argument_list|)
expr_stmt|;
name|error
operator|=
name|dehook_pf
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * Should not happen! 		 * XXX Due to error code ESRCH, kldunload will show 		 * a message like 'No such process'. 		 */
name|printf
argument_list|(
literal|"%s : pfil unregisteration fail\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|PF_RULES_WLOCK
argument_list|()
expr_stmt|;
name|shutdown_pf
argument_list|()
expr_stmt|;
name|V_pf_end_threads
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|V_pf_end_threads
operator|<
literal|2
condition|)
block|{
name|wakeup_one
argument_list|(
name|pf_purge_thread
argument_list|)
expr_stmt|;
name|rw_sleep
argument_list|(
name|pf_purge_thread
argument_list|,
operator|&
name|pf_rules_lock
argument_list|,
literal|0
argument_list|,
literal|"pftmo"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pf_normalize_cleanup
argument_list|()
expr_stmt|;
name|pfi_cleanup
argument_list|()
expr_stmt|;
name|pfr_cleanup
argument_list|()
expr_stmt|;
name|pf_osfp_flush
argument_list|()
expr_stmt|;
name|pf_cleanup
argument_list|()
expr_stmt|;
name|PF_RULES_WUNLOCK
argument_list|()
expr_stmt|;
name|destroy_dev
argument_list|(
name|pf_dev
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|pf_rules_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
name|pf_load
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_QUIESCE
case|:
comment|/* 		 * Module should not be unloaded due to race conditions. 		 */
name|error
operator|=
name|EPERM
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|error
operator|=
name|pf_unload
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|pf_mod
init|=
block|{
literal|"pf"
block|,
name|pf_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|pf
argument_list|,
name|pf_mod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_FIRST
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|pf
argument_list|,
name|PF_MODVER
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

