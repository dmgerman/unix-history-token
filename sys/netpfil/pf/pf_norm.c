begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2001 Niels Provos<provos@citi.umich.edu>  * Copyright 2011 Alexander Bluhm<bluhm@openbsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	$OpenBSD: pf_norm.c,v 1.114 2009/01/29 14:11:45 henning Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_pf.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<net/pfvar.h>
end_include

begin_include
include|#
directive|include
file|<net/if_pflog.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_struct
struct|struct
name|pf_frent
block|{
name|TAILQ_ENTRY
argument_list|(
argument|pf_frent
argument_list|)
name|fr_next
expr_stmt|;
name|struct
name|mbuf
modifier|*
name|fe_m
decl_stmt|;
name|uint16_t
name|fe_hdrlen
decl_stmt|;
comment|/* ipv4 header lenght with ip options 					   ipv6, extension, fragment header */
name|uint16_t
name|fe_extoff
decl_stmt|;
comment|/* last extension header offset or 0 */
name|uint16_t
name|fe_len
decl_stmt|;
comment|/* fragment length */
name|uint16_t
name|fe_off
decl_stmt|;
comment|/* fragment offset */
name|uint16_t
name|fe_mff
decl_stmt|;
comment|/* more fragment flag */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pf_fragment_cmp
block|{
name|struct
name|pf_addr
name|frc_src
decl_stmt|;
name|struct
name|pf_addr
name|frc_dst
decl_stmt|;
name|uint32_t
name|frc_id
decl_stmt|;
name|sa_family_t
name|frc_af
decl_stmt|;
name|uint8_t
name|frc_proto
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pf_fragment
block|{
name|struct
name|pf_fragment_cmp
name|fr_key
decl_stmt|;
define|#
directive|define
name|fr_src
value|fr_key.frc_src
define|#
directive|define
name|fr_dst
value|fr_key.frc_dst
define|#
directive|define
name|fr_id
value|fr_key.frc_id
define|#
directive|define
name|fr_af
value|fr_key.frc_af
define|#
directive|define
name|fr_proto
value|fr_key.frc_proto
name|RB_ENTRY
argument_list|(
argument|pf_fragment
argument_list|)
name|fr_entry
expr_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|pf_fragment
argument_list|)
name|frag_next
expr_stmt|;
name|uint8_t
name|fr_flags
decl_stmt|;
comment|/* status flags */
define|#
directive|define
name|PFFRAG_SEENLAST
value|0x0001
comment|/* Seen the last fragment for this */
define|#
directive|define
name|PFFRAG_NOBUFFER
value|0x0002
comment|/* Non-buffering fragment cache */
define|#
directive|define
name|PFFRAG_DROP
value|0x0004
comment|/* Drop all fragments */
define|#
directive|define
name|BUFFER_FRAGMENTS
parameter_list|(
name|fr
parameter_list|)
value|(!((fr)->fr_flags& PFFRAG_NOBUFFER))
name|uint16_t
name|fr_max
decl_stmt|;
comment|/* fragment data max */
name|uint32_t
name|fr_timeout
decl_stmt|;
name|uint16_t
name|fr_maxlen
decl_stmt|;
comment|/* maximum length of single fragment */
name|TAILQ_HEAD
argument_list|(
argument|pf_fragq
argument_list|,
argument|pf_frent
argument_list|)
name|fr_queue
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pf_fragment_tag
block|{
name|uint16_t
name|ft_hdrlen
decl_stmt|;
comment|/* header length of reassembled pkt */
name|uint16_t
name|ft_extoff
decl_stmt|;
comment|/* last extension header offset or 0 */
name|uint16_t
name|ft_maxlen
decl_stmt|;
comment|/* maximum fragment payload length */
name|uint32_t
name|ft_id
decl_stmt|;
comment|/* fragment id */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|pf_frag_mtx
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PF_FRAG_LOCK
parameter_list|()
value|mtx_lock(&pf_frag_mtx)
end_define

begin_define
define|#
directive|define
name|PF_FRAG_UNLOCK
parameter_list|()
value|mtx_unlock(&pf_frag_mtx)
end_define

begin_define
define|#
directive|define
name|PF_FRAG_ASSERT
parameter_list|()
value|mtx_assert(&pf_frag_mtx, MA_OWNED)
end_define

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|uma_zone_t
argument_list|,
name|pf_state_scrub_z
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX: shared with pfsync */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|uma_zone_t
argument_list|,
name|pf_frent_z
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_frent_z
value|VNET(pf_frent_z)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|uma_zone_t
argument_list|,
name|pf_frag_z
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_frag_z
value|VNET(pf_frag_z)
end_define

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|pf_fragqueue
argument_list|,
name|pf_fragment
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|pf_cachequeue
argument_list|,
name|pf_fragment
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_fragqueue
argument_list|,
name|pf_fragqueue
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_fragqueue
value|VNET(pf_fragqueue)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_cachequeue
argument_list|,
name|pf_cachequeue
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_cachequeue
value|VNET(pf_cachequeue)
end_define

begin_expr_stmt
name|RB_HEAD
argument_list|(
name|pf_frag_tree
argument_list|,
name|pf_fragment
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_frag_tree
argument_list|,
name|pf_frag_tree
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_frag_tree
value|VNET(pf_frag_tree)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_frag_tree
argument_list|,
name|pf_cache_tree
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_cache_tree
value|VNET(pf_cache_tree)
end_define

begin_function_decl
specifier|static
name|int
name|pf_frag_compare
parameter_list|(
name|struct
name|pf_fragment
modifier|*
parameter_list|,
name|struct
name|pf_fragment
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|RB_PROTOTYPE
argument_list|(
name|pf_frag_tree
argument_list|,
name|pf_fragment
argument_list|,
name|fr_entry
argument_list|,
name|pf_frag_compare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|RB_GENERATE
argument_list|(
name|pf_frag_tree
argument_list|,
name|pf_fragment
argument_list|,
name|fr_entry
argument_list|,
name|pf_frag_compare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|pf_flush_fragments
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_free_fragment
parameter_list|(
name|struct
name|pf_fragment
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_remove_fragment
parameter_list|(
name|struct
name|pf_fragment
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_normalize_tcpopt
parameter_list|(
name|struct
name|pf_rule
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|tcphdr
modifier|*
parameter_list|,
name|int
parameter_list|,
name|sa_family_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pf_frent
modifier|*
name|pf_create_fragment
parameter_list|(
name|u_short
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pf_fragment
modifier|*
name|pf_find_fragment
parameter_list|(
name|struct
name|pf_fragment_cmp
modifier|*
name|key
parameter_list|,
name|struct
name|pf_frag_tree
modifier|*
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pf_fragment
modifier|*
name|pf_fillup_fragment
parameter_list|(
name|struct
name|pf_fragment_cmp
modifier|*
parameter_list|,
name|struct
name|pf_frent
modifier|*
parameter_list|,
name|u_short
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_isfull_fragment
parameter_list|(
name|struct
name|pf_fragment
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|pf_join_fragment
parameter_list|(
name|struct
name|pf_fragment
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function_decl
specifier|static
name|void
name|pf_scrub_ip
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_reassemble
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_short
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|pf_fragcache
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|pf_fragment
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function_decl
specifier|static
name|int
name|pf_reassemble6
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|ip6_hdr
modifier|*
parameter_list|,
name|struct
name|ip6_frag
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint16_t
parameter_list|,
name|u_short
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pf_scrub_ip6
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_define
define|#
directive|define
name|DPFPRINTF
parameter_list|(
name|x
parameter_list|)
value|do {				\ 	if (V_pf_status.debug>= PF_DEBUG_MISC) {	\ 		printf("%s: ", __func__);		\ 		printf x ;				\ 	}						\ } while(0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
specifier|static
name|void
name|pf_ip2key
parameter_list|(
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|pf_fragment_cmp
modifier|*
name|key
parameter_list|)
block|{
name|key
operator|->
name|frc_src
operator|.
name|v4
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|key
operator|->
name|frc_dst
operator|.
name|v4
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|key
operator|->
name|frc_af
operator|=
name|AF_INET
expr_stmt|;
name|key
operator|->
name|frc_proto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|key
operator|->
name|frc_id
operator|=
name|ip
operator|->
name|ip_id
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_function
name|void
name|pf_normalize_init
parameter_list|(
name|void
parameter_list|)
block|{
name|V_pf_frag_z
operator|=
name|uma_zcreate
argument_list|(
literal|"pf frags"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_fragment
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V_pf_frent_z
operator|=
name|uma_zcreate
argument_list|(
literal|"pf frag entries"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_frent
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V_pf_state_scrub_z
operator|=
name|uma_zcreate
argument_list|(
literal|"pf state scrubs"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state_scrub
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V_pf_limits
index|[
name|PF_LIMIT_FRAGS
index|]
operator|.
name|zone
operator|=
name|V_pf_frent_z
expr_stmt|;
name|V_pf_limits
index|[
name|PF_LIMIT_FRAGS
index|]
operator|.
name|limit
operator|=
name|PFFRAG_FRENT_HIWAT
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|V_pf_frent_z
argument_list|,
name|PFFRAG_FRENT_HIWAT
argument_list|)
expr_stmt|;
name|uma_zone_set_warning
argument_list|(
name|V_pf_frent_z
argument_list|,
literal|"PF frag entries limit reached"
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pf_frag_mtx
argument_list|,
literal|"pf fragments"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|V_pf_fragqueue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|V_pf_cachequeue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pf_normalize_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|uma_zdestroy
argument_list|(
name|V_pf_state_scrub_z
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|V_pf_frent_z
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|V_pf_frag_z
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pf_frag_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_frag_compare
parameter_list|(
name|struct
name|pf_fragment
modifier|*
name|a
parameter_list|,
name|struct
name|pf_fragment
modifier|*
name|b
parameter_list|)
block|{
name|int
name|diff
decl_stmt|;
if|if
condition|(
operator|(
name|diff
operator|=
name|a
operator|->
name|fr_id
operator|-
name|b
operator|->
name|fr_id
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|diff
operator|)
return|;
if|if
condition|(
operator|(
name|diff
operator|=
name|a
operator|->
name|fr_proto
operator|-
name|b
operator|->
name|fr_proto
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|diff
operator|)
return|;
if|if
condition|(
operator|(
name|diff
operator|=
name|a
operator|->
name|fr_af
operator|-
name|b
operator|->
name|fr_af
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|diff
operator|)
return|;
if|if
condition|(
operator|(
name|diff
operator|=
name|pf_addr_cmp
argument_list|(
operator|&
name|a
operator|->
name|fr_src
argument_list|,
operator|&
name|b
operator|->
name|fr_src
argument_list|,
name|a
operator|->
name|fr_af
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|diff
operator|)
return|;
if|if
condition|(
operator|(
name|diff
operator|=
name|pf_addr_cmp
argument_list|(
operator|&
name|a
operator|->
name|fr_dst
argument_list|,
operator|&
name|b
operator|->
name|fr_dst
argument_list|,
name|a
operator|->
name|fr_af
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|diff
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pf_purge_expired_fragments
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pf_fragment
modifier|*
name|frag
decl_stmt|;
name|u_int32_t
name|expire
init|=
name|time_uptime
operator|-
name|V_pf_default_rule
operator|.
name|timeout
index|[
name|PFTM_FRAG
index|]
decl_stmt|;
name|PF_FRAG_LOCK
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|frag
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|V_pf_fragqueue
argument_list|,
name|pf_fragqueue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|BUFFER_FRAGMENTS
argument_list|(
name|frag
argument_list|)
operator|)
argument_list|,
operator|(
literal|"BUFFER_FRAGMENTS(frag) == 0: %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|fr_timeout
operator|>
name|expire
condition|)
break|break;
name|DPFPRINTF
argument_list|(
operator|(
literal|"expiring %d(%p)\n"
operator|,
name|frag
operator|->
name|fr_id
operator|,
name|frag
operator|)
argument_list|)
expr_stmt|;
name|pf_free_fragment
argument_list|(
name|frag
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|frag
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|V_pf_cachequeue
argument_list|,
name|pf_cachequeue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
operator|!
name|BUFFER_FRAGMENTS
argument_list|(
name|frag
argument_list|)
operator|)
argument_list|,
operator|(
literal|"BUFFER_FRAGMENTS(frag) != 0: %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|fr_timeout
operator|>
name|expire
condition|)
break|break;
name|DPFPRINTF
argument_list|(
operator|(
literal|"expiring %d(%p)\n"
operator|,
name|frag
operator|->
name|fr_id
operator|,
name|frag
operator|)
argument_list|)
expr_stmt|;
name|pf_free_fragment
argument_list|(
name|frag
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|V_pf_cachequeue
argument_list|)
operator|||
name|TAILQ_LAST
argument_list|(
operator|&
name|V_pf_cachequeue
argument_list|,
name|pf_cachequeue
argument_list|)
operator|!=
name|frag
operator|)
argument_list|,
operator|(
literal|"!(TAILQ_EMPTY() || TAILQ_LAST() == farg): %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
block|}
name|PF_FRAG_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to flush old fragments to make space for new ones  */
end_comment

begin_function
specifier|static
name|void
name|pf_flush_fragments
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pf_fragment
modifier|*
name|frag
decl_stmt|,
modifier|*
name|cache
decl_stmt|;
name|int
name|goal
decl_stmt|;
name|PF_FRAG_ASSERT
argument_list|()
expr_stmt|;
name|goal
operator|=
name|uma_zone_get_cur
argument_list|(
name|V_pf_frent_z
argument_list|)
operator|*
literal|9
operator|/
literal|10
expr_stmt|;
name|DPFPRINTF
argument_list|(
operator|(
literal|"trying to free %d frag entriess\n"
operator|,
name|goal
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|goal
operator|<
name|uma_zone_get_cur
argument_list|(
name|V_pf_frent_z
argument_list|)
condition|)
block|{
name|frag
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|V_pf_fragqueue
argument_list|,
name|pf_fragqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
condition|)
name|pf_free_fragment
argument_list|(
name|frag
argument_list|)
expr_stmt|;
name|cache
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|V_pf_cachequeue
argument_list|,
name|pf_cachequeue
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
condition|)
name|pf_free_fragment
argument_list|(
name|cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
operator|&&
name|cache
operator|==
name|NULL
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Frees the fragments and all associated entries */
end_comment

begin_function
specifier|static
name|void
name|pf_free_fragment
parameter_list|(
name|struct
name|pf_fragment
modifier|*
name|frag
parameter_list|)
block|{
name|struct
name|pf_frent
modifier|*
name|frent
decl_stmt|;
name|PF_FRAG_ASSERT
argument_list|()
expr_stmt|;
comment|/* Free all fragments */
if|if
condition|(
name|BUFFER_FRAGMENTS
argument_list|(
name|frag
argument_list|)
condition|)
block|{
for|for
control|(
name|frent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|)
init|;
name|frent
condition|;
name|frent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|)
control|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|frent
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|frent
operator|->
name|fe_m
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_frent_z
argument_list|,
name|frent
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|frent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|)
init|;
name|frent
condition|;
name|frent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|)
control|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|frent
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|)
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|)
operator|->
name|fe_off
operator|>
name|frent
operator|->
name|fe_len
operator|)
argument_list|,
operator|(
literal|"! (TAILQ_EMPTY() || TAILQ_FIRST()->fe_off>"
literal|" frent->fe_len): %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_frent_z
argument_list|,
name|frent
argument_list|)
expr_stmt|;
block|}
block|}
name|pf_remove_fragment
argument_list|(
name|frag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pf_fragment
modifier|*
name|pf_find_fragment
parameter_list|(
name|struct
name|pf_fragment_cmp
modifier|*
name|key
parameter_list|,
name|struct
name|pf_frag_tree
modifier|*
name|tree
parameter_list|)
block|{
name|struct
name|pf_fragment
modifier|*
name|frag
decl_stmt|;
name|PF_FRAG_ASSERT
argument_list|()
expr_stmt|;
name|frag
operator|=
name|RB_FIND
argument_list|(
name|pf_frag_tree
argument_list|,
name|tree
argument_list|,
operator|(
expr|struct
name|pf_fragment
operator|*
operator|)
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX Are we sure we want to update the timeout? */
name|frag
operator|->
name|fr_timeout
operator|=
name|time_uptime
expr_stmt|;
if|if
condition|(
name|BUFFER_FRAGMENTS
argument_list|(
name|frag
argument_list|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|V_pf_fragqueue
argument_list|,
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|V_pf_fragqueue
argument_list|,
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|V_pf_cachequeue
argument_list|,
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|V_pf_cachequeue
argument_list|,
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|frag
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Removes a fragment from the fragment queue and frees the fragment */
end_comment

begin_function
specifier|static
name|void
name|pf_remove_fragment
parameter_list|(
name|struct
name|pf_fragment
modifier|*
name|frag
parameter_list|)
block|{
name|PF_FRAG_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|BUFFER_FRAGMENTS
argument_list|(
name|frag
argument_list|)
condition|)
block|{
name|RB_REMOVE
argument_list|(
name|pf_frag_tree
argument_list|,
operator|&
name|V_pf_frag_tree
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|V_pf_fragqueue
argument_list|,
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_frag_z
argument_list|,
name|frag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RB_REMOVE
argument_list|(
name|pf_frag_tree
argument_list|,
operator|&
name|V_pf_cache_tree
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|V_pf_cachequeue
argument_list|,
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_frag_z
argument_list|,
name|frag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|pf_frent
modifier|*
name|pf_create_fragment
parameter_list|(
name|u_short
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|pf_frent
modifier|*
name|frent
decl_stmt|;
name|PF_FRAG_ASSERT
argument_list|()
expr_stmt|;
name|frent
operator|=
name|uma_zalloc
argument_list|(
name|V_pf_frent_z
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|frent
operator|==
name|NULL
condition|)
block|{
name|pf_flush_fragments
argument_list|()
expr_stmt|;
name|frent
operator|=
name|uma_zalloc
argument_list|(
name|V_pf_frent_z
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|frent
operator|==
name|NULL
condition|)
block|{
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|frent
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|pf_fragment
modifier|*
name|pf_fillup_fragment
parameter_list|(
name|struct
name|pf_fragment_cmp
modifier|*
name|key
parameter_list|,
name|struct
name|pf_frent
modifier|*
name|frent
parameter_list|,
name|u_short
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|pf_frent
modifier|*
name|after
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|pf_fragment
modifier|*
name|frag
decl_stmt|;
name|uint16_t
name|total
decl_stmt|;
name|PF_FRAG_ASSERT
argument_list|()
expr_stmt|;
comment|/* No empty fragments. */
if|if
condition|(
name|frent
operator|->
name|fe_len
operator|==
literal|0
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"bad fragment: len 0"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad_fragment
goto|;
block|}
comment|/* All fragments are 8 byte aligned. */
if|if
condition|(
name|frent
operator|->
name|fe_mff
operator|&&
operator|(
name|frent
operator|->
name|fe_len
operator|&
literal|0x7
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"bad fragment: mff and len %d"
operator|,
name|frent
operator|->
name|fe_len
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad_fragment
goto|;
block|}
comment|/* Respect maximum length, IP_MAXPACKET == IPV6_MAXPACKET. */
if|if
condition|(
name|frent
operator|->
name|fe_off
operator|+
name|frent
operator|->
name|fe_len
operator|>
name|IP_MAXPACKET
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"bad fragment: max packet %d"
operator|,
name|frent
operator|->
name|fe_off
operator|+
name|frent
operator|->
name|fe_len
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad_fragment
goto|;
block|}
name|DPFPRINTF
argument_list|(
operator|(
name|key
operator|->
name|frc_af
operator|==
name|AF_INET
condition|?
literal|"reass frag %d @ %d-%d"
else|:
literal|"reass frag %#08x @ %d-%d"
operator|,
name|key
operator|->
name|frc_id
operator|,
name|frent
operator|->
name|fe_off
operator|,
name|frent
operator|->
name|fe_off
operator|+
name|frent
operator|->
name|fe_len
operator|)
argument_list|)
expr_stmt|;
comment|/* Fully buffer all of the fragments in this fragment queue. */
name|frag
operator|=
name|pf_find_fragment
argument_list|(
name|key
argument_list|,
operator|&
name|V_pf_frag_tree
argument_list|)
expr_stmt|;
comment|/* Create a new reassembly queue for this packet. */
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
block|{
name|frag
operator|=
name|uma_zalloc
argument_list|(
name|V_pf_frag_z
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
block|{
name|pf_flush_fragments
argument_list|()
expr_stmt|;
name|frag
operator|=
name|uma_zalloc
argument_list|(
name|V_pf_frag_z
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
block|{
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
goto|goto
name|drop_fragment
goto|;
block|}
block|}
operator|*
operator|(
expr|struct
name|pf_fragment_cmp
operator|*
operator|)
name|frag
operator|=
operator|*
name|key
expr_stmt|;
name|frag
operator|->
name|fr_flags
operator|=
literal|0
expr_stmt|;
name|frag
operator|->
name|fr_timeout
operator|=
name|time_uptime
expr_stmt|;
name|frag
operator|->
name|fr_maxlen
operator|=
name|frent
operator|->
name|fe_len
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|)
expr_stmt|;
name|RB_INSERT
argument_list|(
name|pf_frag_tree
argument_list|,
operator|&
name|V_pf_frag_tree
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|V_pf_fragqueue
argument_list|,
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
comment|/* We do not have a previous fragment. */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|frent
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|frag
operator|)
return|;
block|}
name|KASSERT
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|)
argument_list|,
operator|(
literal|"!TAILQ_EMPTY()->fr_queue"
operator|)
argument_list|)
expr_stmt|;
comment|/* Remember maximum fragment len for refragmentation. */
if|if
condition|(
name|frent
operator|->
name|fe_len
operator|>
name|frag
operator|->
name|fr_maxlen
condition|)
name|frag
operator|->
name|fr_maxlen
operator|=
name|frent
operator|->
name|fe_len
expr_stmt|;
comment|/* Maximum data we have seen already. */
name|total
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|pf_fragq
argument_list|)
operator|->
name|fe_off
operator|+
name|TAILQ_LAST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|pf_fragq
argument_list|)
operator|->
name|fe_len
expr_stmt|;
comment|/* Non terminal fragments must have more fragments flag. */
if|if
condition|(
name|frent
operator|->
name|fe_off
operator|+
name|frent
operator|->
name|fe_len
operator|<
name|total
operator|&&
operator|!
name|frent
operator|->
name|fe_mff
condition|)
goto|goto
name|bad_fragment
goto|;
comment|/* Check if we saw the last fragment already. */
if|if
condition|(
operator|!
name|TAILQ_LAST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|pf_fragq
argument_list|)
operator|->
name|fe_mff
condition|)
block|{
if|if
condition|(
name|frent
operator|->
name|fe_off
operator|+
name|frent
operator|->
name|fe_len
operator|>
name|total
operator|||
operator|(
name|frent
operator|->
name|fe_off
operator|+
name|frent
operator|->
name|fe_len
operator|==
name|total
operator|&&
name|frent
operator|->
name|fe_mff
operator|)
condition|)
goto|goto
name|bad_fragment
goto|;
block|}
else|else
block|{
if|if
condition|(
name|frent
operator|->
name|fe_off
operator|+
name|frent
operator|->
name|fe_len
operator|==
name|total
operator|&&
operator|!
name|frent
operator|->
name|fe_mff
condition|)
goto|goto
name|bad_fragment
goto|;
block|}
comment|/* Find a fragment after the current one. */
name|prev
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|after
argument_list|,
argument|&frag->fr_queue
argument_list|,
argument|fr_next
argument_list|)
block|{
if|if
condition|(
name|after
operator|->
name|fe_off
operator|>
name|frent
operator|->
name|fe_off
condition|)
break|break;
name|prev
operator|=
name|after
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|prev
operator|!=
name|NULL
operator|||
name|after
operator|!=
name|NULL
argument_list|,
operator|(
literal|"prev != NULL || after != NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
operator|&&
name|prev
operator|->
name|fe_off
operator|+
name|prev
operator|->
name|fe_len
operator|>
name|frent
operator|->
name|fe_off
condition|)
block|{
name|uint16_t
name|precut
decl_stmt|;
name|precut
operator|=
name|prev
operator|->
name|fe_off
operator|+
name|prev
operator|->
name|fe_len
operator|-
name|frent
operator|->
name|fe_off
expr_stmt|;
if|if
condition|(
name|precut
operator|>=
name|frent
operator|->
name|fe_len
condition|)
goto|goto
name|bad_fragment
goto|;
name|DPFPRINTF
argument_list|(
operator|(
literal|"overlap -%d"
operator|,
name|precut
operator|)
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|frent
operator|->
name|fe_m
argument_list|,
name|precut
argument_list|)
expr_stmt|;
name|frent
operator|->
name|fe_off
operator|+=
name|precut
expr_stmt|;
name|frent
operator|->
name|fe_len
operator|-=
name|precut
expr_stmt|;
block|}
for|for
control|(
init|;
name|after
operator|!=
name|NULL
operator|&&
name|frent
operator|->
name|fe_off
operator|+
name|frent
operator|->
name|fe_len
operator|>
name|after
operator|->
name|fe_off
condition|;
name|after
operator|=
name|next
control|)
block|{
name|uint16_t
name|aftercut
decl_stmt|;
name|aftercut
operator|=
name|frent
operator|->
name|fe_off
operator|+
name|frent
operator|->
name|fe_len
operator|-
name|after
operator|->
name|fe_off
expr_stmt|;
name|DPFPRINTF
argument_list|(
operator|(
literal|"adjust overlap %d"
operator|,
name|aftercut
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aftercut
operator|<
name|after
operator|->
name|fe_len
condition|)
block|{
name|m_adj
argument_list|(
name|after
operator|->
name|fe_m
argument_list|,
name|aftercut
argument_list|)
expr_stmt|;
name|after
operator|->
name|fe_off
operator|+=
name|aftercut
expr_stmt|;
name|after
operator|->
name|fe_len
operator|-=
name|aftercut
expr_stmt|;
break|break;
block|}
comment|/* This fragment is completely overlapped, lose it. */
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|after
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|after
operator|->
name|fe_m
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|after
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_frent_z
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|frent
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|prev
argument_list|,
name|frent
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|frag
operator|)
return|;
name|bad_fragment
label|:
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_FRAG
argument_list|)
expr_stmt|;
name|drop_fragment
label|:
name|uma_zfree
argument_list|(
name|V_pf_frent_z
argument_list|,
name|frent
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_isfull_fragment
parameter_list|(
name|struct
name|pf_fragment
modifier|*
name|frag
parameter_list|)
block|{
name|struct
name|pf_frent
modifier|*
name|frent
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|uint16_t
name|off
decl_stmt|,
name|total
decl_stmt|;
comment|/* Check if we are completely reassembled */
if|if
condition|(
name|TAILQ_LAST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|pf_fragq
argument_list|)
operator|->
name|fe_mff
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Maximum data we have seen already */
name|total
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|pf_fragq
argument_list|)
operator|->
name|fe_off
operator|+
name|TAILQ_LAST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|pf_fragq
argument_list|)
operator|->
name|fe_len
expr_stmt|;
comment|/* Check if we have all the data */
name|off
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|frent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|)
init|;
name|frent
condition|;
name|frent
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|frent
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|off
operator|+=
name|frent
operator|->
name|fe_len
expr_stmt|;
if|if
condition|(
name|off
operator|<
name|total
operator|&&
operator|(
name|next
operator|==
name|NULL
operator|||
name|next
operator|->
name|fe_off
operator|!=
name|off
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"missing fragment at %d, next %d, total %d"
operator|,
name|off
operator|,
name|next
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
name|next
operator|->
name|fe_off
operator|,
name|total
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|DPFPRINTF
argument_list|(
operator|(
literal|"%d< %d?"
operator|,
name|off
operator|,
name|total
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|<
name|total
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KASSERT
argument_list|(
name|off
operator|==
name|total
argument_list|,
operator|(
literal|"off == total"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|pf_join_fragment
parameter_list|(
name|struct
name|pf_fragment
modifier|*
name|frag
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m2
decl_stmt|;
name|struct
name|pf_frent
modifier|*
name|frent
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|frent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|)
expr_stmt|;
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|frent
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|m
operator|=
name|frent
operator|->
name|fe_m
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
operator|(
name|frent
operator|->
name|fe_hdrlen
operator|+
name|frent
operator|->
name|fe_len
operator|)
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_frent_z
argument_list|,
name|frent
argument_list|)
expr_stmt|;
for|for
control|(
name|frent
operator|=
name|next
init|;
name|frent
operator|!=
name|NULL
condition|;
name|frent
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|frent
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|m2
operator|=
name|frent
operator|->
name|fe_m
expr_stmt|;
comment|/* Strip off ip header. */
name|m_adj
argument_list|(
name|m2
argument_list|,
name|frent
operator|->
name|fe_hdrlen
argument_list|)
expr_stmt|;
comment|/* Strip off any trailing bytes. */
name|m_adj
argument_list|(
name|m2
argument_list|,
name|frent
operator|->
name|fe_len
operator|-
name|m2
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_frent_z
argument_list|,
name|frent
argument_list|)
expr_stmt|;
name|m_cat
argument_list|(
name|m
argument_list|,
name|m2
argument_list|)
expr_stmt|;
block|}
comment|/* Remove from fragment queue. */
name|pf_remove_fragment
argument_list|(
name|frag
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
specifier|static
name|int
name|pf_reassemble
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|int
name|dir
parameter_list|,
name|u_short
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|;
name|struct
name|pf_frent
modifier|*
name|frent
decl_stmt|;
name|struct
name|pf_fragment
modifier|*
name|frag
decl_stmt|;
name|struct
name|pf_fragment_cmp
name|key
decl_stmt|;
name|uint16_t
name|total
decl_stmt|,
name|hdrlen
decl_stmt|;
comment|/* Get an entry for the fragment queue */
if|if
condition|(
operator|(
name|frent
operator|=
name|pf_create_fragment
argument_list|(
name|reason
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|PF_DROP
operator|)
return|;
name|frent
operator|->
name|fe_m
operator|=
name|m
expr_stmt|;
name|frent
operator|->
name|fe_hdrlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|frent
operator|->
name|fe_extoff
operator|=
literal|0
expr_stmt|;
name|frent
operator|->
name|fe_len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|-
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|frent
operator|->
name|fe_off
operator|=
operator|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_OFFMASK
operator|)
operator|<<
literal|3
expr_stmt|;
name|frent
operator|->
name|fe_mff
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_MF
expr_stmt|;
name|pf_ip2key
argument_list|(
name|ip
argument_list|,
name|dir
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|frag
operator|=
name|pf_fillup_fragment
argument_list|(
operator|&
name|key
argument_list|,
name|frent
argument_list|,
name|reason
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|PF_DROP
operator|)
return|;
comment|/* The mbuf is part of the fragment entry, no direct free or access */
name|m
operator|=
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|pf_isfull_fragment
argument_list|(
name|frag
argument_list|)
condition|)
return|return
operator|(
name|PF_PASS
operator|)
return|;
comment|/* drop because *m0 is NULL, no error */
comment|/* We have all the data */
name|frent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|frent
operator|!=
name|NULL
argument_list|,
operator|(
literal|"frent != NULL"
operator|)
argument_list|)
expr_stmt|;
name|total
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|pf_fragq
argument_list|)
operator|->
name|fe_off
operator|+
name|TAILQ_LAST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|pf_fragq
argument_list|)
operator|->
name|fe_len
expr_stmt|;
name|hdrlen
operator|=
name|frent
operator|->
name|fe_hdrlen
expr_stmt|;
name|m
operator|=
operator|*
name|m0
operator|=
name|pf_join_fragment
argument_list|(
name|frag
argument_list|)
expr_stmt|;
name|frag
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|int
name|plen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|m
operator|=
operator|*
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|plen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
operator|*
name|m0
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|plen
expr_stmt|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|hdrlen
operator|+
name|total
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|&=
operator|~
operator|(
name|IP_MF
operator||
name|IP_OFFMASK
operator|)
expr_stmt|;
if|if
condition|(
name|hdrlen
operator|+
name|total
operator|>
name|IP_MAXPACKET
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"drop: too big: %d"
operator|,
name|total
operator|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
literal|0
expr_stmt|;
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SHORT
argument_list|)
expr_stmt|;
comment|/* PF_DROP requires a valid mbuf *m0 in pf_test() */
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
name|DPFPRINTF
argument_list|(
operator|(
literal|"complete: %p(%d)\n"
operator|,
name|m
operator|,
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_PASS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
specifier|static
name|int
name|pf_reassemble6
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|struct
name|ip6_hdr
modifier|*
name|ip6
parameter_list|,
name|struct
name|ip6_frag
modifier|*
name|fraghdr
parameter_list|,
name|uint16_t
name|hdrlen
parameter_list|,
name|uint16_t
name|extoff
parameter_list|,
name|u_short
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|;
name|struct
name|pf_frent
modifier|*
name|frent
decl_stmt|;
name|struct
name|pf_fragment
modifier|*
name|frag
decl_stmt|;
name|struct
name|pf_fragment_cmp
name|key
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|struct
name|pf_fragment_tag
modifier|*
name|ftag
decl_stmt|;
name|int
name|off
decl_stmt|;
name|uint32_t
name|frag_id
decl_stmt|;
name|uint16_t
name|total
decl_stmt|,
name|maxlen
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
name|PF_FRAG_LOCK
argument_list|()
expr_stmt|;
comment|/* Get an entry for the fragment queue. */
if|if
condition|(
operator|(
name|frent
operator|=
name|pf_create_fragment
argument_list|(
name|reason
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|PF_FRAG_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
name|frent
operator|->
name|fe_m
operator|=
name|m
expr_stmt|;
name|frent
operator|->
name|fe_hdrlen
operator|=
name|hdrlen
expr_stmt|;
name|frent
operator|->
name|fe_extoff
operator|=
name|extoff
expr_stmt|;
name|frent
operator|->
name|fe_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
operator|-
name|hdrlen
expr_stmt|;
name|frent
operator|->
name|fe_off
operator|=
name|ntohs
argument_list|(
name|fraghdr
operator|->
name|ip6f_offlg
operator|&
name|IP6F_OFF_MASK
argument_list|)
expr_stmt|;
name|frent
operator|->
name|fe_mff
operator|=
name|fraghdr
operator|->
name|ip6f_offlg
operator|&
name|IP6F_MORE_FRAG
expr_stmt|;
name|key
operator|.
name|frc_src
operator|.
name|v6
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|key
operator|.
name|frc_dst
operator|.
name|v6
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|key
operator|.
name|frc_af
operator|=
name|AF_INET6
expr_stmt|;
comment|/* Only the first fragment's protocol is relevant. */
name|key
operator|.
name|frc_proto
operator|=
literal|0
expr_stmt|;
name|key
operator|.
name|frc_id
operator|=
name|fraghdr
operator|->
name|ip6f_ident
expr_stmt|;
if|if
condition|(
operator|(
name|frag
operator|=
name|pf_fillup_fragment
argument_list|(
operator|&
name|key
argument_list|,
name|frent
argument_list|,
name|reason
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|PF_FRAG_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
comment|/* The mbuf is part of the fragment entry, no direct free or access. */
name|m
operator|=
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|pf_isfull_fragment
argument_list|(
name|frag
argument_list|)
condition|)
block|{
name|PF_FRAG_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|PF_PASS
operator|)
return|;
comment|/* Drop because *m0 is NULL, no error. */
block|}
comment|/* We have all the data. */
name|extoff
operator|=
name|frent
operator|->
name|fe_extoff
expr_stmt|;
name|maxlen
operator|=
name|frag
operator|->
name|fr_maxlen
expr_stmt|;
name|frag_id
operator|=
name|frag
operator|->
name|fr_id
expr_stmt|;
name|frent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|frent
operator|!=
name|NULL
argument_list|,
operator|(
literal|"frent != NULL"
operator|)
argument_list|)
expr_stmt|;
name|total
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|pf_fragq
argument_list|)
operator|->
name|fe_off
operator|+
name|TAILQ_LAST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|,
name|pf_fragq
argument_list|)
operator|->
name|fe_len
expr_stmt|;
name|hdrlen
operator|=
name|frent
operator|->
name|fe_hdrlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|m0
operator|=
name|pf_join_fragment
argument_list|(
name|frag
argument_list|)
expr_stmt|;
name|frag
operator|=
name|NULL
expr_stmt|;
name|PF_FRAG_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Take protocol from first fragment header. */
name|m
operator|=
name|m_getptr
argument_list|(
name|m
argument_list|,
name|hdrlen
operator|+
name|offsetof
argument_list|(
expr|struct
name|ip6_frag
argument_list|,
name|ip6f_nxt
argument_list|)
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
argument_list|,
operator|(
literal|"%s: short mbuf chain"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|proto
operator|=
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|m
operator|=
operator|*
name|m0
expr_stmt|;
comment|/* Delete frag6 header */
if|if
condition|(
name|ip6_deletefraghdr
argument_list|(
name|m
argument_list|,
name|hdrlen
argument_list|,
name|M_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|int
name|plen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|m
operator|=
operator|*
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|plen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
operator|*
name|m0
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|plen
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mtag
operator|=
name|m_tag_get
argument_list|(
name|PF_REASSEMBLED
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_fragment_tag
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|ftag
operator|=
operator|(
expr|struct
name|pf_fragment_tag
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
expr_stmt|;
name|ftag
operator|->
name|ft_hdrlen
operator|=
name|hdrlen
expr_stmt|;
name|ftag
operator|->
name|ft_extoff
operator|=
name|extoff
expr_stmt|;
name|ftag
operator|->
name|ft_maxlen
operator|=
name|maxlen
expr_stmt|;
name|ftag
operator|->
name|ft_id
operator|=
name|frag_id
expr_stmt|;
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|ip6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|hdrlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|extoff
condition|)
block|{
comment|/* Write protocol into next field of last extension header. */
name|m
operator|=
name|m_getptr
argument_list|(
name|m
argument_list|,
name|extoff
operator|+
name|offsetof
argument_list|(
expr|struct
name|ip6_ext
argument_list|,
name|ip6e_nxt
argument_list|)
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
argument_list|,
operator|(
literal|"%s: short mbuf chain"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|off
operator|)
operator|=
name|proto
expr_stmt|;
name|m
operator|=
operator|*
name|m0
expr_stmt|;
block|}
else|else
name|ip6
operator|->
name|ip6_nxt
operator|=
name|proto
expr_stmt|;
if|if
condition|(
name|hdrlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|total
operator|>
name|IPV6_MAXPACKET
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"drop: too big: %d"
operator|,
name|total
operator|)
argument_list|)
expr_stmt|;
name|ip6
operator|->
name|ip6_plen
operator|=
literal|0
expr_stmt|;
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SHORT
argument_list|)
expr_stmt|;
comment|/* PF_DROP requires a valid mbuf *m0 in pf_test6(). */
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
name|DPFPRINTF
argument_list|(
operator|(
literal|"complete: %p(%d)"
operator|,
name|m
operator|,
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|fail
label|:
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
comment|/* PF_DROP requires a valid mbuf *m0 in pf_test6(), will free later. */
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|pf_fragcache
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|struct
name|ip
modifier|*
name|h
parameter_list|,
name|struct
name|pf_fragment
modifier|*
modifier|*
name|frag
parameter_list|,
name|int
name|mff
parameter_list|,
name|int
name|drop
parameter_list|,
name|int
modifier|*
name|nomem
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|;
name|struct
name|pf_frent
modifier|*
name|frp
decl_stmt|,
modifier|*
name|fra
decl_stmt|,
modifier|*
name|cur
init|=
name|NULL
decl_stmt|;
name|int
name|ip_len
init|=
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
operator|-
operator|(
name|h
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
decl_stmt|;
name|u_int16_t
name|off
init|=
name|ntohs
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
operator|<<
literal|3
decl_stmt|;
name|u_int16_t
name|max
init|=
name|ip_len
operator|+
name|off
decl_stmt|;
name|int
name|hosed
init|=
literal|0
decl_stmt|;
name|PF_FRAG_ASSERT
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|*
name|frag
operator|==
name|NULL
operator|||
operator|!
name|BUFFER_FRAGMENTS
argument_list|(
operator|*
name|frag
argument_list|)
operator|)
argument_list|,
operator|(
literal|"!(*frag == NULL || !BUFFER_FRAGMENTS(*frag)): %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
comment|/* Create a new range queue for this packet */
if|if
condition|(
operator|*
name|frag
operator|==
name|NULL
condition|)
block|{
operator|*
name|frag
operator|=
name|uma_zalloc
argument_list|(
name|V_pf_frag_z
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|frag
operator|==
name|NULL
condition|)
block|{
name|pf_flush_fragments
argument_list|()
expr_stmt|;
operator|*
name|frag
operator|=
name|uma_zalloc
argument_list|(
name|V_pf_frag_z
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|frag
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
block|}
comment|/* Get an entry for the queue */
name|cur
operator|=
name|uma_zalloc
argument_list|(
name|V_pf_frent_z
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|uma_zfree
argument_list|(
name|V_pf_frag_z
argument_list|,
operator|*
name|frag
argument_list|)
expr_stmt|;
operator|*
name|frag
operator|=
name|NULL
expr_stmt|;
goto|goto
name|no_mem
goto|;
block|}
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator|=
name|PFFRAG_NOBUFFER
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_src
operator|.
name|v4
operator|=
name|h
operator|->
name|ip_src
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_dst
operator|.
name|v4
operator|=
name|h
operator|->
name|ip_dst
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_af
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_proto
operator|=
name|h
operator|->
name|ip_p
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_id
operator|=
name|h
operator|->
name|ip_id
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_timeout
operator|=
name|time_uptime
expr_stmt|;
name|cur
operator|->
name|fe_off
operator|=
name|off
expr_stmt|;
name|cur
operator|->
name|fe_len
operator|=
name|max
expr_stmt|;
comment|/* TODO: fe_len = max - off ? */
name|TAILQ_INIT
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_queue
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_queue
argument_list|,
name|cur
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|RB_INSERT
argument_list|(
name|pf_frag_tree
argument_list|,
operator|&
name|V_pf_cache_tree
argument_list|,
operator|*
name|frag
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|V_pf_cachequeue
argument_list|,
operator|*
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: new %d-%d\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|off
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|pass
goto|;
block|}
comment|/* 	 * Find a fragment after the current one: 	 *  - off contains the real shifted offset. 	 */
name|frp
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|fra
argument_list|,
argument|&(*frag)->fr_queue
argument_list|,
argument|fr_next
argument_list|)
block|{
if|if
condition|(
name|fra
operator|->
name|fe_off
operator|>
name|off
condition|)
break|break;
name|frp
operator|=
name|fra
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|(
name|frp
operator|!=
name|NULL
operator|||
name|fra
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"!(frp != NULL || fra != NULL): %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|!=
name|NULL
condition|)
block|{
name|int
name|precut
decl_stmt|;
name|precut
operator|=
name|frp
operator|->
name|fe_len
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|precut
operator|>=
name|ip_len
condition|)
block|{
comment|/* Fragment is entirely a duplicate */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: dead (%d-%d) %d-%d\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|frp
operator|->
name|fe_off
operator|,
name|frp
operator|->
name|fe_len
operator|,
name|off
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|drop_fragment
goto|;
block|}
if|if
condition|(
name|precut
operator|==
literal|0
condition|)
block|{
comment|/* They are adjacent.  Fixup cache entry */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: adjacent (%d-%d) %d-%d\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|frp
operator|->
name|fe_off
operator|,
name|frp
operator|->
name|fe_len
operator|,
name|off
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
name|frp
operator|->
name|fe_len
operator|=
name|max
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|precut
operator|>
literal|0
condition|)
block|{
comment|/* The first part of this payload overlaps with a 			 * fragment that has already been passed. 			 * Need to trim off the first part of the payload. 			 * But to do so easily, we need to create another 			 * mbuf to throw the original header into. 			 */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: chop %d (%d-%d) %d-%d\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|precut
operator|,
name|frp
operator|->
name|fe_off
operator|,
name|frp
operator|->
name|fe_len
operator|,
name|off
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
name|off
operator|+=
name|precut
expr_stmt|;
name|max
operator|-=
name|precut
expr_stmt|;
comment|/* Update the previous frag to encompass this one */
name|frp
operator|->
name|fe_len
operator|=
name|max
expr_stmt|;
if|if
condition|(
operator|!
name|drop
condition|)
block|{
comment|/* XXX Optimization opportunity 				 * This is a very heavy way to trim the payload. 				 * we could do it much faster by diddling mbuf 				 * internals but that would be even less legible 				 * than this mbuf magic.  For my next trick, 				 * I'll pull a rabbit out of my laptop. 				 */
operator|*
name|m0
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|m0
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
comment|/* From KAME Project : We have missed this! */
name|m_adj
argument_list|(
operator|*
name|m0
argument_list|,
operator|(
name|h
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|-
operator|(
operator|*
name|m0
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
operator|*
name|m0
operator|)
operator|->
name|m_next
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"(*m0)->m_next != NULL: %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|precut
operator|+
operator|(
name|h
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
name|m_cat
argument_list|(
operator|*
name|m0
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|m0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|int
name|plen
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|m
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|m_next
control|)
name|plen
operator|+=
name|t
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|plen
expr_stmt|;
block|}
name|h
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|int
operator|)
name|m
operator|->
name|m_len
operator|==
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
operator|-
name|precut
operator|)
argument_list|,
operator|(
literal|"m->m_len != ntohs(h->ip_len) - precut: %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
operator|+
operator|(
name|precut
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
operator|-
name|precut
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hosed
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* There is a gap between fragments */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: gap %d (%d-%d) %d-%d\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
operator|-
name|precut
operator|,
name|frp
operator|->
name|fe_off
operator|,
name|frp
operator|->
name|fe_len
operator|,
name|off
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|uma_zalloc
argument_list|(
name|V_pf_frent_z
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
name|cur
operator|->
name|fe_off
operator|=
name|off
expr_stmt|;
name|cur
operator|->
name|fe_len
operator|=
name|max
expr_stmt|;
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_queue
argument_list|,
name|frp
argument_list|,
name|cur
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fra
operator|!=
name|NULL
condition|)
block|{
name|int
name|aftercut
decl_stmt|;
name|int
name|merge
init|=
literal|0
decl_stmt|;
name|aftercut
operator|=
name|max
operator|-
name|fra
operator|->
name|fe_off
expr_stmt|;
if|if
condition|(
name|aftercut
operator|==
literal|0
condition|)
block|{
comment|/* Adjacent fragments */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: adjacent %d-%d (%d-%d)\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|off
operator|,
name|max
operator|,
name|fra
operator|->
name|fe_off
operator|,
name|fra
operator|->
name|fe_len
operator|)
argument_list|)
expr_stmt|;
name|fra
operator|->
name|fe_off
operator|=
name|off
expr_stmt|;
name|merge
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aftercut
operator|>
literal|0
condition|)
block|{
comment|/* Need to chop off the tail of this fragment */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: chop %d %d-%d (%d-%d)\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|aftercut
operator|,
name|off
operator|,
name|max
operator|,
name|fra
operator|->
name|fe_off
operator|,
name|fra
operator|->
name|fe_len
operator|)
argument_list|)
expr_stmt|;
name|fra
operator|->
name|fe_off
operator|=
name|off
expr_stmt|;
name|max
operator|-=
name|aftercut
expr_stmt|;
name|merge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|drop
condition|)
block|{
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|aftercut
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|int
name|plen
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|m
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|m_next
control|)
name|plen
operator|+=
name|t
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|plen
expr_stmt|;
block|}
name|h
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|int
operator|)
name|m
operator|->
name|m_len
operator|==
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
operator|-
name|aftercut
operator|)
argument_list|,
operator|(
literal|"m->m_len != ntohs(h->ip_len) - aftercut: %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
operator|-
name|aftercut
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hosed
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|frp
operator|==
name|NULL
condition|)
block|{
comment|/* There is a gap between fragments */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: gap %d %d-%d (%d-%d)\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
operator|-
name|aftercut
operator|,
name|off
operator|,
name|max
operator|,
name|fra
operator|->
name|fe_off
operator|,
name|fra
operator|->
name|fe_len
operator|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|uma_zalloc
argument_list|(
name|V_pf_frent_z
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
name|cur
operator|->
name|fe_off
operator|=
name|off
expr_stmt|;
name|cur
operator|->
name|fe_len
operator|=
name|max
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_queue
argument_list|,
name|cur
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
block|}
comment|/* Need to glue together two separate fragment descriptors */
if|if
condition|(
name|merge
condition|)
block|{
if|if
condition|(
name|cur
operator|&&
name|fra
operator|->
name|fe_off
operator|<=
name|cur
operator|->
name|fe_len
condition|)
block|{
comment|/* Need to merge in a previous 'cur' */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: adjacent(merge "
literal|"%d-%d) %d-%d (%d-%d)\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|cur
operator|->
name|fe_off
operator|,
name|cur
operator|->
name|fe_len
operator|,
name|off
operator|,
name|max
operator|,
name|fra
operator|->
name|fe_off
operator|,
name|fra
operator|->
name|fe_len
operator|)
argument_list|)
expr_stmt|;
name|fra
operator|->
name|fe_off
operator|=
name|cur
operator|->
name|fe_off
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_queue
argument_list|,
name|cur
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_frent_z
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|cur
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frp
operator|&&
name|fra
operator|->
name|fe_off
operator|<=
name|frp
operator|->
name|fe_len
condition|)
block|{
comment|/* Need to merge in a modified 'frp' */
name|KASSERT
argument_list|(
operator|(
name|cur
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"cur != NULL: %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: adjacent(merge "
literal|"%d-%d) %d-%d (%d-%d)\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|frp
operator|->
name|fe_off
operator|,
name|frp
operator|->
name|fe_len
operator|,
name|off
operator|,
name|max
operator|,
name|fra
operator|->
name|fe_off
operator|,
name|fra
operator|->
name|fe_len
operator|)
argument_list|)
expr_stmt|;
name|fra
operator|->
name|fe_off
operator|=
name|frp
operator|->
name|fe_off
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_queue
argument_list|,
name|frp
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pf_frent_z
argument_list|,
name|frp
argument_list|)
expr_stmt|;
name|frp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|hosed
condition|)
block|{
comment|/* 		 * We must keep tracking the overall fragment even when 		 * we're going to drop it anyway so that we know when to 		 * free the overall descriptor.  Thus we drop the frag late. 		 */
goto|goto
name|drop_fragment
goto|;
block|}
name|pass
label|:
comment|/* Update maximum data size */
if|if
condition|(
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
operator|<
name|max
condition|)
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
operator|=
name|max
expr_stmt|;
comment|/* This is the last segment */
if|if
condition|(
operator|!
name|mff
condition|)
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator||=
name|PFFRAG_SEENLAST
expr_stmt|;
comment|/* Check if we are completely reassembled */
if|if
condition|(
operator|(
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator|&
name|PFFRAG_SEENLAST
operator|)
operator|&&
name|TAILQ_FIRST
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_queue
argument_list|)
operator|->
name|fe_off
operator|==
literal|0
operator|&&
name|TAILQ_FIRST
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_queue
argument_list|)
operator|->
name|fe_len
operator|==
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
condition|)
block|{
comment|/* Remove from fragment queue */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: done 0-%d\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
operator|)
argument_list|)
expr_stmt|;
name|pf_free_fragment
argument_list|(
operator|*
name|frag
argument_list|)
expr_stmt|;
operator|*
name|frag
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
name|no_mem
label|:
operator|*
name|nomem
operator|=
literal|1
expr_stmt|;
comment|/* Still need to pay attention to !IP_MF */
if|if
condition|(
operator|!
name|mff
operator|&&
operator|*
name|frag
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator||=
name|PFFRAG_SEENLAST
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
name|drop_fragment
label|:
comment|/* Still need to pay attention to !IP_MF */
if|if
condition|(
operator|!
name|mff
operator|&&
operator|*
name|frag
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator||=
name|PFFRAG_SEENLAST
expr_stmt|;
if|if
condition|(
name|drop
condition|)
block|{
comment|/* This fragment has been deemed bad.  Don't reass */
if|if
condition|(
operator|(
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator|&
name|PFFRAG_DROP
operator|)
operator|==
literal|0
condition|)
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: dropping overall fragment\n"
operator|,
name|h
operator|->
name|ip_id
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator||=
name|PFFRAG_DROP
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
name|int
name|pf_refragment6
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|struct
name|m_tag
modifier|*
name|mtag
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|struct
name|pf_fragment_tag
modifier|*
name|ftag
init|=
operator|(
expr|struct
name|pf_fragment_tag
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|pf_pdesc
name|pd
decl_stmt|;
name|uint32_t
name|frag_id
decl_stmt|;
name|uint16_t
name|hdrlen
decl_stmt|,
name|extoff
decl_stmt|,
name|maxlen
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
name|int
name|error
decl_stmt|,
name|action
decl_stmt|;
name|hdrlen
operator|=
name|ftag
operator|->
name|ft_hdrlen
expr_stmt|;
name|extoff
operator|=
name|ftag
operator|->
name|ft_extoff
expr_stmt|;
name|maxlen
operator|=
name|ftag
operator|->
name|ft_maxlen
expr_stmt|;
name|frag_id
operator|=
name|ftag
operator|->
name|ft_id
expr_stmt|;
name|m_tag_delete
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
name|mtag
operator|=
name|NULL
expr_stmt|;
name|ftag
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|extoff
condition|)
block|{
name|int
name|off
decl_stmt|;
comment|/* Use protocol from next field of last extension header */
name|m
operator|=
name|m_getptr
argument_list|(
name|m
argument_list|,
name|extoff
operator|+
name|offsetof
argument_list|(
expr|struct
name|ip6_ext
argument_list|,
name|ip6e_nxt
argument_list|)
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"pf_refragment6: short mbuf chain"
operator|)
argument_list|)
expr_stmt|;
name|proto
operator|=
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|off
operator|)
operator|=
name|IPPROTO_FRAGMENT
expr_stmt|;
name|m
operator|=
operator|*
name|m0
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ip6_hdr
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|proto
operator|=
name|hdr
operator|->
name|ip6_nxt
expr_stmt|;
name|hdr
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_FRAGMENT
expr_stmt|;
block|}
comment|/* The MTU must be a multiple of 8 bytes, or we risk doing the 	 * fragmentation wrong. */
name|maxlen
operator|=
name|maxlen
operator|&
operator|~
literal|7
expr_stmt|;
comment|/* 	 * Maxlen may be less than 8 if there was only a single 	 * fragment.  As it was fragmented before, add a fragment 	 * header also for a single fragment.  If total or maxlen 	 * is less than 8, ip6_fragment() will return EMSGSIZE and 	 * we drop the packet. 	 */
name|error
operator|=
name|ip6_fragment
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|hdrlen
argument_list|,
name|proto
argument_list|,
name|maxlen
argument_list|,
name|frag_id
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
operator|*
name|m0
operator|)
operator|->
name|m_nextpkt
expr_stmt|;
operator|(
operator|*
name|m0
operator|)
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* The first mbuf contains the unfragmented packet. */
name|m_freem
argument_list|(
operator|*
name|m0
argument_list|)
expr_stmt|;
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
name|action
operator|=
name|PF_PASS
expr_stmt|;
block|}
else|else
block|{
comment|/* Drop expects an mbuf to free. */
name|DPFPRINTF
argument_list|(
operator|(
literal|"refragment error %d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|action
operator|=
name|PF_DROP
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|m
init|;
name|m
condition|;
name|m
operator|=
name|t
control|)
block|{
name|t
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_SKIP_FIREWALL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pd
argument_list|)
argument_list|)
expr_stmt|;
name|pd
operator|.
name|pf_mtag
operator|=
name|pf_find_mtag
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ip6_forward
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|action
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
name|int
name|pf_normalize_ip
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|u_short
modifier|*
name|reason
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|r
decl_stmt|;
name|struct
name|pf_fragment
modifier|*
name|frag
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_fragment_cmp
name|key
decl_stmt|;
name|struct
name|ip
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
name|int
name|mff
init|=
operator|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_MF
operator|)
decl_stmt|;
name|int
name|hlen
init|=
name|h
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
name|u_int16_t
name|fragoff
init|=
operator|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_OFFMASK
operator|)
operator|<<
literal|3
decl_stmt|;
name|u_int16_t
name|max
decl_stmt|;
name|int
name|ip_len
decl_stmt|;
name|int
name|ip_off
decl_stmt|;
name|int
name|tag
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|verdict
decl_stmt|;
name|PF_RULES_RASSERT
argument_list|()
expr_stmt|;
name|r
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_main_ruleset
operator|.
name|rules
index|[
name|PF_RULESET_SCRUB
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
name|r
operator|->
name|evaluations
operator|++
expr_stmt|;
if|if
condition|(
name|pfi_kif_match
argument_list|(
name|r
operator|->
name|kif
argument_list|,
name|kif
argument_list|)
operator|==
name|r
operator|->
name|ifnot
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_IFP
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|direction
operator|&&
name|r
operator|->
name|direction
operator|!=
name|dir
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DIR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|af
operator|&&
name|r
operator|->
name|af
operator|!=
name|AF_INET
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_AF
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|proto
operator|&&
name|r
operator|->
name|proto
operator|!=
name|h
operator|->
name|ip_p
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_PROTO
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|src
operator|.
name|addr
argument_list|,
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|AF_INET
argument_list|,
name|r
operator|->
name|src
operator|.
name|neg
argument_list|,
name|kif
argument_list|,
name|M_GETFIB
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_SRC_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|dst
operator|.
name|addr
argument_list|,
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|AF_INET
argument_list|,
name|r
operator|->
name|dst
operator|.
name|neg
argument_list|,
name|NULL
argument_list|,
name|M_GETFIB
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DST_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|match_tag
operator|&&
operator|!
name|pf_match_tag
argument_list|(
name|m
argument_list|,
name|r
argument_list|,
operator|&
name|tag
argument_list|,
name|pd
operator|->
name|pf_mtag
condition|?
name|pd
operator|->
name|pf_mtag
operator|->
name|tag
else|:
literal|0
argument_list|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|r
operator|==
name|NULL
operator|||
name|r
operator|->
name|action
operator|==
name|PF_NOSCRUB
condition|)
return|return
operator|(
name|PF_PASS
operator|)
return|;
else|else
block|{
name|r
operator|->
name|packets
index|[
name|dir
operator|==
name|PF_OUT
index|]
operator|++
expr_stmt|;
name|r
operator|->
name|bytes
index|[
name|dir
operator|==
name|PF_OUT
index|]
operator|+=
name|pd
operator|->
name|tot_len
expr_stmt|;
block|}
comment|/* Check for illegal packets */
if|if
condition|(
name|hlen
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
name|hlen
operator|>
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
condition|)
goto|goto
name|drop
goto|;
comment|/* Clear IP_DF if the rule uses the no-df option */
if|if
condition|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_NODF
operator|&&
name|h
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_DF
argument_list|)
condition|)
block|{
name|u_int16_t
name|ip_off
init|=
name|h
operator|->
name|ip_off
decl_stmt|;
name|h
operator|->
name|ip_off
operator|&=
name|htons
argument_list|(
operator|~
name|IP_DF
argument_list|)
expr_stmt|;
name|h
operator|->
name|ip_sum
operator|=
name|pf_cksum_fixup
argument_list|(
name|h
operator|->
name|ip_sum
argument_list|,
name|ip_off
argument_list|,
name|h
operator|->
name|ip_off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We will need other tests here */
if|if
condition|(
operator|!
name|fragoff
operator|&&
operator|!
name|mff
condition|)
goto|goto
name|no_fragment
goto|;
comment|/* We're dealing with a fragment now. Don't allow fragments 	 * with IP_DF to enter the cache. If the flag was cleared by 	 * no-df above, fine. Otherwise drop it. 	 */
if|if
condition|(
name|h
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_DF
argument_list|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"IP_DF\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip_len
operator|=
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
operator|-
name|hlen
expr_stmt|;
name|ip_off
operator|=
operator|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_OFFMASK
operator|)
operator|<<
literal|3
expr_stmt|;
comment|/* All fragments are 8 byte aligned */
if|if
condition|(
name|mff
operator|&&
operator|(
name|ip_len
operator|&
literal|0x7
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"mff and %d\n"
operator|,
name|ip_len
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Respect maximum length */
if|if
condition|(
name|fragoff
operator|+
name|ip_len
operator|>
name|IP_MAXPACKET
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"max packet %d\n"
operator|,
name|fragoff
operator|+
name|ip_len
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|max
operator|=
name|fragoff
operator|+
name|ip_len
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|rule_flag
operator|&
operator|(
name|PFRULE_FRAGCROP
operator||
name|PFRULE_FRAGDROP
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Fully buffer all of the fragments */
name|PF_FRAG_LOCK
argument_list|()
expr_stmt|;
name|pf_ip2key
argument_list|(
name|h
argument_list|,
name|dir
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|frag
operator|=
name|pf_find_fragment
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|V_pf_frag_tree
argument_list|)
expr_stmt|;
comment|/* Check if we saw the last fragment already */
if|if
condition|(
name|frag
operator|!=
name|NULL
operator|&&
operator|(
name|frag
operator|->
name|fr_flags
operator|&
name|PFFRAG_SEENLAST
operator|)
operator|&&
name|max
operator|>
name|frag
operator|->
name|fr_max
condition|)
goto|goto
name|bad
goto|;
comment|/* Might return a completely reassembled mbuf, or NULL */
name|DPFPRINTF
argument_list|(
operator|(
literal|"reass frag %d @ %d-%d\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|fragoff
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
name|verdict
operator|=
name|pf_reassemble
argument_list|(
name|m0
argument_list|,
name|h
argument_list|,
name|dir
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|PF_FRAG_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|verdict
operator|!=
name|PF_PASS
condition|)
return|return
operator|(
name|PF_DROP
operator|)
return|;
name|m
operator|=
operator|*
name|m0
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|PF_DROP
operator|)
return|;
comment|/* use mtag from concatenated mbuf chain */
name|pd
operator|->
name|pf_mtag
operator|=
name|pf_find_mtag
argument_list|(
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|pd
operator|->
name|pf_mtag
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: pf_find_mtag returned NULL(1)\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pd
operator|->
name|pf_mtag
operator|=
name|pf_get_mtag
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|no_mem
goto|;
block|}
block|}
endif|#
directive|endif
name|h
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* non-buffering fragment cache (drops or masks overlaps) */
name|int
name|nomem
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dir
operator|==
name|PF_OUT
operator|&&
name|pd
operator|->
name|pf_mtag
operator|->
name|flags
operator|&
name|PF_TAG_FRAGCACHE
condition|)
block|{
comment|/* 			 * Already passed the fragment cache in the 			 * input direction.  If we continued, it would 			 * appear to be a dup and would be dropped. 			 */
goto|goto
name|fragment_pass
goto|;
block|}
name|PF_FRAG_LOCK
argument_list|()
expr_stmt|;
name|pf_ip2key
argument_list|(
name|h
argument_list|,
name|dir
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|frag
operator|=
name|pf_find_fragment
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|V_pf_cache_tree
argument_list|)
expr_stmt|;
comment|/* Check if we saw the last fragment already */
if|if
condition|(
name|frag
operator|!=
name|NULL
operator|&&
operator|(
name|frag
operator|->
name|fr_flags
operator|&
name|PFFRAG_SEENLAST
operator|)
operator|&&
name|max
operator|>
name|frag
operator|->
name|fr_max
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_FRAGDROP
condition|)
name|frag
operator|->
name|fr_flags
operator||=
name|PFFRAG_DROP
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
operator|*
name|m0
operator|=
name|m
operator|=
name|pf_fragcache
argument_list|(
name|m0
argument_list|,
name|h
argument_list|,
operator|&
name|frag
argument_list|,
name|mff
argument_list|,
operator|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_FRAGDROP
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
operator|&
name|nomem
argument_list|)
expr_stmt|;
name|PF_FRAG_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nomem
condition|)
goto|goto
name|no_mem
goto|;
goto|goto
name|drop
goto|;
block|}
comment|/* use mtag from copied and trimmed mbuf chain */
name|pd
operator|->
name|pf_mtag
operator|=
name|pf_find_mtag
argument_list|(
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|pd
operator|->
name|pf_mtag
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: pf_find_mtag returned NULL(2)\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pd
operator|->
name|pf_mtag
operator|=
name|pf_get_mtag
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|no_mem
goto|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|dir
operator|==
name|PF_IN
condition|)
name|pd
operator|->
name|pf_mtag
operator|->
name|flags
operator||=
name|PF_TAG_FRAGCACHE
expr_stmt|;
if|if
condition|(
name|frag
operator|!=
name|NULL
operator|&&
operator|(
name|frag
operator|->
name|fr_flags
operator|&
name|PFFRAG_DROP
operator|)
condition|)
goto|goto
name|drop
goto|;
goto|goto
name|fragment_pass
goto|;
block|}
name|no_fragment
label|:
comment|/* At this point, only IP_DF is allowed in ip_off */
if|if
condition|(
name|h
operator|->
name|ip_off
operator|&
operator|~
name|htons
argument_list|(
name|IP_DF
argument_list|)
condition|)
block|{
name|u_int16_t
name|ip_off
init|=
name|h
operator|->
name|ip_off
decl_stmt|;
name|h
operator|->
name|ip_off
operator|&=
name|htons
argument_list|(
name|IP_DF
argument_list|)
expr_stmt|;
name|h
operator|->
name|ip_sum
operator|=
name|pf_cksum_fixup
argument_list|(
name|h
operator|->
name|ip_sum
argument_list|,
name|ip_off
argument_list|,
name|h
operator|->
name|ip_off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* not missing a return here */
name|fragment_pass
label|:
name|pf_scrub_ip
argument_list|(
operator|&
name|m
argument_list|,
name|r
operator|->
name|rule_flag
argument_list|,
name|r
operator|->
name|min_ttl
argument_list|,
name|r
operator|->
name|set_tos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|rule_flag
operator|&
operator|(
name|PFRULE_FRAGCROP
operator||
name|PFRULE_FRAGDROP
operator|)
operator|)
operator|==
literal|0
condition|)
name|pd
operator|->
name|flags
operator||=
name|PFDESC_IP_REAS
expr_stmt|;
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|no_mem
label|:
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|log
condition|)
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|m
argument_list|,
name|AF_INET
argument_list|,
name|dir
argument_list|,
operator|*
name|reason
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
name|drop
label|:
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_NORM
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|log
condition|)
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|m
argument_list|,
name|AF_INET
argument_list|,
name|dir
argument_list|,
operator|*
name|reason
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
name|bad
label|:
name|DPFPRINTF
argument_list|(
operator|(
literal|"dropping bad fragment\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Free associated fragments */
if|if
condition|(
name|frag
operator|!=
name|NULL
condition|)
block|{
name|pf_free_fragment
argument_list|(
name|frag
argument_list|)
expr_stmt|;
name|PF_FRAG_UNLOCK
argument_list|()
expr_stmt|;
block|}
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_FRAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|log
condition|)
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|m
argument_list|,
name|AF_INET
argument_list|,
name|dir
argument_list|,
operator|*
name|reason
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
name|int
name|pf_normalize_ip6
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|u_short
modifier|*
name|reason
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|r
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
name|int
name|extoff
decl_stmt|;
name|int
name|off
decl_stmt|;
name|struct
name|ip6_ext
name|ext
decl_stmt|;
name|struct
name|ip6_opt
name|opt
decl_stmt|;
name|struct
name|ip6_opt_jumbo
name|jumbo
decl_stmt|;
name|struct
name|ip6_frag
name|frag
decl_stmt|;
name|u_int32_t
name|jumbolen
init|=
literal|0
decl_stmt|,
name|plen
decl_stmt|;
name|int
name|optend
decl_stmt|;
name|int
name|ooff
decl_stmt|;
name|u_int8_t
name|proto
decl_stmt|;
name|int
name|terminal
decl_stmt|;
name|PF_RULES_RASSERT
argument_list|()
expr_stmt|;
name|r
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_main_ruleset
operator|.
name|rules
index|[
name|PF_RULESET_SCRUB
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
name|r
operator|->
name|evaluations
operator|++
expr_stmt|;
if|if
condition|(
name|pfi_kif_match
argument_list|(
name|r
operator|->
name|kif
argument_list|,
name|kif
argument_list|)
operator|==
name|r
operator|->
name|ifnot
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_IFP
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|direction
operator|&&
name|r
operator|->
name|direction
operator|!=
name|dir
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DIR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|af
operator|&&
name|r
operator|->
name|af
operator|!=
name|AF_INET6
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_AF
index|]
operator|.
name|ptr
expr_stmt|;
if|#
directive|if
literal|0
comment|/* header chain! */
if|else if (r->proto&& r->proto != h->ip6_nxt) 			r = r->skip[PF_SKIP_PROTO].ptr;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|src
operator|.
name|addr
argument_list|,
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h
operator|->
name|ip6_src
argument_list|,
name|AF_INET6
argument_list|,
name|r
operator|->
name|src
operator|.
name|neg
argument_list|,
name|kif
argument_list|,
name|M_GETFIB
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_SRC_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|dst
operator|.
name|addr
argument_list|,
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h
operator|->
name|ip6_dst
argument_list|,
name|AF_INET6
argument_list|,
name|r
operator|->
name|dst
operator|.
name|neg
argument_list|,
name|NULL
argument_list|,
name|M_GETFIB
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DST_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|r
operator|==
name|NULL
operator|||
name|r
operator|->
name|action
operator|==
name|PF_NOSCRUB
condition|)
return|return
operator|(
name|PF_PASS
operator|)
return|;
else|else
block|{
name|r
operator|->
name|packets
index|[
name|dir
operator|==
name|PF_OUT
index|]
operator|++
expr_stmt|;
name|r
operator|->
name|bytes
index|[
name|dir
operator|==
name|PF_OUT
index|]
operator|+=
name|pd
operator|->
name|tot_len
expr_stmt|;
block|}
comment|/* Check for illegal packets */
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|IPV6_MAXPACKET
operator|<
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
goto|goto
name|drop
goto|;
name|extoff
operator|=
literal|0
expr_stmt|;
name|off
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|proto
operator|=
name|h
operator|->
name|ip6_nxt
expr_stmt|;
name|terminal
operator|=
literal|0
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_FRAGMENT
case|:
goto|goto
name|fragment
goto|;
break|break;
case|case
name|IPPROTO_AH
case|:
case|case
name|IPPROTO_ROUTING
case|:
case|case
name|IPPROTO_DSTOPTS
case|:
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|ext
argument_list|,
sizeof|sizeof
argument_list|(
name|ext
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AF_INET6
argument_list|)
condition|)
goto|goto
name|shortpkt
goto|;
name|extoff
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|proto
operator|==
name|IPPROTO_AH
condition|)
name|off
operator|+=
operator|(
name|ext
operator|.
name|ip6e_len
operator|+
literal|2
operator|)
operator|*
literal|4
expr_stmt|;
else|else
name|off
operator|+=
operator|(
name|ext
operator|.
name|ip6e_len
operator|+
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
name|proto
operator|=
name|ext
operator|.
name|ip6e_nxt
expr_stmt|;
break|break;
case|case
name|IPPROTO_HOPOPTS
case|:
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|ext
argument_list|,
sizeof|sizeof
argument_list|(
name|ext
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AF_INET6
argument_list|)
condition|)
goto|goto
name|shortpkt
goto|;
name|extoff
operator|=
name|off
expr_stmt|;
name|optend
operator|=
name|off
operator|+
operator|(
name|ext
operator|.
name|ip6e_len
operator|+
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
name|ooff
operator|=
name|off
operator|+
sizeof|sizeof
argument_list|(
name|ext
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|ooff
argument_list|,
operator|&
name|opt
operator|.
name|ip6o_type
argument_list|,
sizeof|sizeof
argument_list|(
name|opt
operator|.
name|ip6o_type
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AF_INET6
argument_list|)
condition|)
goto|goto
name|shortpkt
goto|;
if|if
condition|(
name|opt
operator|.
name|ip6o_type
operator|==
name|IP6OPT_PAD1
condition|)
block|{
name|ooff
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|ooff
argument_list|,
operator|&
name|opt
argument_list|,
sizeof|sizeof
argument_list|(
name|opt
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AF_INET6
argument_list|)
condition|)
goto|goto
name|shortpkt
goto|;
if|if
condition|(
name|ooff
operator|+
sizeof|sizeof
argument_list|(
name|opt
argument_list|)
operator|+
name|opt
operator|.
name|ip6o_len
operator|>
name|optend
condition|)
goto|goto
name|drop
goto|;
switch|switch
condition|(
name|opt
operator|.
name|ip6o_type
condition|)
block|{
case|case
name|IP6OPT_JUMBO
case|:
if|if
condition|(
name|h
operator|->
name|ip6_plen
operator|!=
literal|0
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|ooff
argument_list|,
operator|&
name|jumbo
argument_list|,
sizeof|sizeof
argument_list|(
name|jumbo
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AF_INET6
argument_list|)
condition|)
goto|goto
name|shortpkt
goto|;
name|memcpy
argument_list|(
operator|&
name|jumbolen
argument_list|,
name|jumbo
operator|.
name|ip6oj_jumbo_len
argument_list|,
sizeof|sizeof
argument_list|(
name|jumbolen
argument_list|)
argument_list|)
expr_stmt|;
name|jumbolen
operator|=
name|ntohl
argument_list|(
name|jumbolen
argument_list|)
expr_stmt|;
if|if
condition|(
name|jumbolen
operator|<=
name|IPV6_MAXPACKET
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|jumbolen
operator|!=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
goto|goto
name|drop
goto|;
break|break;
default|default:
break|break;
block|}
name|ooff
operator|+=
sizeof|sizeof
argument_list|(
name|opt
argument_list|)
operator|+
name|opt
operator|.
name|ip6o_len
expr_stmt|;
block|}
do|while
condition|(
name|ooff
operator|<
name|optend
condition|)
do|;
name|off
operator|=
name|optend
expr_stmt|;
name|proto
operator|=
name|ext
operator|.
name|ip6e_nxt
expr_stmt|;
break|break;
default|default:
name|terminal
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|terminal
condition|)
do|;
comment|/* jumbo payload option must be present, or plen> 0 */
if|if
condition|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip6_plen
argument_list|)
operator|==
literal|0
condition|)
name|plen
operator|=
name|jumbolen
expr_stmt|;
else|else
name|plen
operator|=
name|ntohs
argument_list|(
name|h
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
goto|goto
name|shortpkt
goto|;
name|pf_scrub_ip6
argument_list|(
operator|&
name|m
argument_list|,
name|r
operator|->
name|min_ttl
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|fragment
label|:
comment|/* Jumbo payload packets cannot be fragmented. */
name|plen
operator|=
name|ntohs
argument_list|(
name|h
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|==
literal|0
operator|||
name|jumbolen
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
goto|goto
name|shortpkt
goto|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|frag
argument_list|,
sizeof|sizeof
argument_list|(
name|frag
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AF_INET6
argument_list|)
condition|)
goto|goto
name|shortpkt
goto|;
comment|/* Offset now points to data portion. */
name|off
operator|+=
sizeof|sizeof
argument_list|(
name|frag
argument_list|)
expr_stmt|;
comment|/* Returns PF_DROP or *m0 is NULL or completely reassembled mbuf. */
if|if
condition|(
name|pf_reassemble6
argument_list|(
name|m0
argument_list|,
name|h
argument_list|,
operator|&
name|frag
argument_list|,
name|off
argument_list|,
name|extoff
argument_list|,
name|reason
argument_list|)
operator|!=
name|PF_PASS
condition|)
return|return
operator|(
name|PF_DROP
operator|)
return|;
name|m
operator|=
operator|*
name|m0
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|PF_DROP
operator|)
return|;
name|pd
operator|->
name|flags
operator||=
name|PFDESC_IP_REAS
expr_stmt|;
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|shortpkt
label|:
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SHORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|log
condition|)
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|m
argument_list|,
name|AF_INET6
argument_list|,
name|dir
argument_list|,
operator|*
name|reason
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
name|drop
label|:
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_NORM
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|log
condition|)
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|m
argument_list|,
name|AF_INET6
argument_list|,
name|dir
argument_list|,
operator|*
name|reason
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_function
name|int
name|pf_normalize_tcp
parameter_list|(
name|int
name|dir
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|ipoff
parameter_list|,
name|int
name|off
parameter_list|,
name|void
modifier|*
name|h
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|)
block|{
name|struct
name|pf_rule
modifier|*
name|r
decl_stmt|,
modifier|*
name|rm
init|=
name|NULL
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
name|pd
operator|->
name|hdr
operator|.
name|tcp
decl_stmt|;
name|int
name|rewrite
init|=
literal|0
decl_stmt|;
name|u_short
name|reason
decl_stmt|;
name|u_int8_t
name|flags
decl_stmt|;
name|sa_family_t
name|af
init|=
name|pd
operator|->
name|af
decl_stmt|;
name|PF_RULES_RASSERT
argument_list|()
expr_stmt|;
name|r
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_main_ruleset
operator|.
name|rules
index|[
name|PF_RULESET_SCRUB
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
name|r
operator|->
name|evaluations
operator|++
expr_stmt|;
if|if
condition|(
name|pfi_kif_match
argument_list|(
name|r
operator|->
name|kif
argument_list|,
name|kif
argument_list|)
operator|==
name|r
operator|->
name|ifnot
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_IFP
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|direction
operator|&&
name|r
operator|->
name|direction
operator|!=
name|dir
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DIR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|af
operator|&&
name|r
operator|->
name|af
operator|!=
name|af
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_AF
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|proto
operator|&&
name|r
operator|->
name|proto
operator|!=
name|pd
operator|->
name|proto
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_PROTO
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|src
operator|.
name|addr
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|af
argument_list|,
name|r
operator|->
name|src
operator|.
name|neg
argument_list|,
name|kif
argument_list|,
name|M_GETFIB
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_SRC_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|src
operator|.
name|port_op
operator|&&
operator|!
name|pf_match_port
argument_list|(
name|r
operator|->
name|src
operator|.
name|port_op
argument_list|,
name|r
operator|->
name|src
operator|.
name|port
index|[
literal|0
index|]
argument_list|,
name|r
operator|->
name|src
operator|.
name|port
index|[
literal|1
index|]
argument_list|,
name|th
operator|->
name|th_sport
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_SRC_PORT
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|dst
operator|.
name|addr
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|af
argument_list|,
name|r
operator|->
name|dst
operator|.
name|neg
argument_list|,
name|NULL
argument_list|,
name|M_GETFIB
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DST_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|dst
operator|.
name|port_op
operator|&&
operator|!
name|pf_match_port
argument_list|(
name|r
operator|->
name|dst
operator|.
name|port_op
argument_list|,
name|r
operator|->
name|dst
operator|.
name|port
index|[
literal|0
index|]
argument_list|,
name|r
operator|->
name|dst
operator|.
name|port
index|[
literal|1
index|]
argument_list|,
name|th
operator|->
name|th_dport
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DST_PORT
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|os_fingerprint
operator|!=
name|PF_OSFP_ANY
operator|&&
operator|!
name|pf_osfp_match
argument_list|(
name|pf_osfp_fingerprint
argument_list|(
name|pd
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|th
argument_list|)
argument_list|,
name|r
operator|->
name|os_fingerprint
argument_list|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
block|{
name|rm
operator|=
name|r
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rm
operator|==
name|NULL
operator|||
name|rm
operator|->
name|action
operator|==
name|PF_NOSCRUB
condition|)
return|return
operator|(
name|PF_PASS
operator|)
return|;
else|else
block|{
name|r
operator|->
name|packets
index|[
name|dir
operator|==
name|PF_OUT
index|]
operator|++
expr_stmt|;
name|r
operator|->
name|bytes
index|[
name|dir
operator|==
name|PF_OUT
index|]
operator|+=
name|pd
operator|->
name|tot_len
expr_stmt|;
block|}
if|if
condition|(
name|rm
operator|->
name|rule_flag
operator|&
name|PFRULE_REASSEMBLE_TCP
condition|)
name|pd
operator|->
name|flags
operator||=
name|PFDESC_TCP_NORM
expr_stmt|;
name|flags
operator|=
name|th
operator|->
name|th_flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TH_SYN
condition|)
block|{
comment|/* Illegal packet */
if|if
condition|(
name|flags
operator|&
name|TH_RST
condition|)
goto|goto
name|tcp_drop
goto|;
if|if
condition|(
name|flags
operator|&
name|TH_FIN
condition|)
goto|goto
name|tcp_drop
goto|;
block|}
else|else
block|{
comment|/* Illegal packet */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|TH_ACK
operator||
name|TH_RST
operator|)
operator|)
condition|)
goto|goto
name|tcp_drop
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TH_ACK
operator|)
condition|)
block|{
comment|/* These flags are only valid if ACK is set */
if|if
condition|(
operator|(
name|flags
operator|&
name|TH_FIN
operator|)
operator|||
operator|(
name|flags
operator|&
name|TH_PUSH
operator|)
operator|||
operator|(
name|flags
operator|&
name|TH_URG
operator|)
condition|)
goto|goto
name|tcp_drop
goto|;
block|}
comment|/* Check for illegal header length */
if|if
condition|(
name|th
operator|->
name|th_off
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|>>
literal|2
operator|)
condition|)
goto|goto
name|tcp_drop
goto|;
comment|/* If flags changed, or reserved data set, then adjust */
if|if
condition|(
name|flags
operator|!=
name|th
operator|->
name|th_flags
operator|||
name|th
operator|->
name|th_x2
operator|!=
literal|0
condition|)
block|{
name|u_int16_t
name|ov
decl_stmt|,
name|nv
decl_stmt|;
name|ov
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
operator|&
name|th
operator|->
name|th_ack
operator|+
literal|1
operator|)
expr_stmt|;
name|th
operator|->
name|th_flags
operator|=
name|flags
expr_stmt|;
name|th
operator|->
name|th_x2
operator|=
literal|0
expr_stmt|;
name|nv
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
operator|&
name|th
operator|->
name|th_ack
operator|+
literal|1
operator|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|pf_proto_cksum_fixup
argument_list|(
name|m
argument_list|,
name|th
operator|->
name|th_sum
argument_list|,
name|ov
argument_list|,
name|nv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rewrite
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Remove urgent pointer, if TH_URG is not set */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TH_URG
operator|)
operator|&&
name|th
operator|->
name|th_urp
condition|)
block|{
name|th
operator|->
name|th_sum
operator|=
name|pf_proto_cksum_fixup
argument_list|(
name|m
argument_list|,
name|th
operator|->
name|th_sum
argument_list|,
name|th
operator|->
name|th_urp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_urp
operator|=
literal|0
expr_stmt|;
name|rewrite
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Process options */
if|if
condition|(
name|r
operator|->
name|max_mss
operator|&&
name|pf_normalize_tcpopt
argument_list|(
name|r
argument_list|,
name|m
argument_list|,
name|th
argument_list|,
name|off
argument_list|,
name|pd
operator|->
name|af
argument_list|)
condition|)
name|rewrite
operator|=
literal|1
expr_stmt|;
comment|/* copy back packet headers if we sanitized */
if|if
condition|(
name|rewrite
condition|)
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|th
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|tcp_drop
label|:
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_NORM
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|log
condition|)
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|m
argument_list|,
name|AF_INET
argument_list|,
name|dir
argument_list|,
name|reason
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pf_normalize_tcp_init
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|pf_state_peer
modifier|*
name|src
parameter_list|,
name|struct
name|pf_state_peer
modifier|*
name|dst
parameter_list|)
block|{
name|u_int32_t
name|tsval
decl_stmt|,
name|tsecr
decl_stmt|;
name|u_int8_t
name|hdr
index|[
literal|60
index|]
decl_stmt|;
name|u_int8_t
modifier|*
name|opt
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|src
operator|->
name|scrub
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"pf_normalize_tcp_init: src->scrub != NULL"
operator|)
argument_list|)
expr_stmt|;
name|src
operator|->
name|scrub
operator|=
name|uma_zalloc
argument_list|(
name|V_pf_state_scrub_z
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|scrub
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|pd
operator|->
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|ip
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
operator|=
name|h
operator|->
name|ip_ttl
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|ip6_hdr
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
operator|=
name|h
operator|->
name|ip6_hlim
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
block|}
comment|/* 	 * All normalizations below are only begun if we see the start of 	 * the connections.  They must all set an enabled bit in pfss_flags 	 */
if|if
condition|(
operator|(
name|th
operator|->
name|th_flags
operator|&
name|TH_SYN
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|th
operator|->
name|th_off
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|>>
literal|2
operator|)
operator|&&
name|src
operator|->
name|scrub
operator|&&
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|hdr
argument_list|,
name|th
operator|->
name|th_off
operator|<<
literal|2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pd
operator|->
name|af
argument_list|)
condition|)
block|{
comment|/* Diddle with TCP options */
name|int
name|hlen
decl_stmt|;
name|opt
operator|=
name|hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
name|hlen
operator|=
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
while|while
condition|(
name|hlen
operator|>=
name|TCPOLEN_TIMESTAMP
condition|)
block|{
switch|switch
condition|(
operator|*
name|opt
condition|)
block|{
case|case
name|TCPOPT_EOL
case|:
comment|/* FALLTHROUGH */
case|case
name|TCPOPT_NOP
case|:
name|opt
operator|++
expr_stmt|;
name|hlen
operator|--
expr_stmt|;
break|break;
case|case
name|TCPOPT_TIMESTAMP
case|:
if|if
condition|(
name|opt
index|[
literal|1
index|]
operator|>=
name|TCPOLEN_TIMESTAMP
condition|)
block|{
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator||=
name|PFSS_TIMESTAMP
expr_stmt|;
name|src
operator|->
name|scrub
operator|->
name|pfss_ts_mod
operator|=
name|htonl
argument_list|(
name|arc4random
argument_list|()
argument_list|)
expr_stmt|;
comment|/* note PFSS_PAWS not set yet */
name|memcpy
argument_list|(
operator|&
name|tsval
argument_list|,
operator|&
name|opt
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tsecr
argument_list|,
operator|&
name|opt
index|[
literal|6
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|->
name|scrub
operator|->
name|pfss_tsval0
operator|=
name|ntohl
argument_list|(
name|tsval
argument_list|)
expr_stmt|;
name|src
operator|->
name|scrub
operator|->
name|pfss_tsval
operator|=
name|ntohl
argument_list|(
name|tsval
argument_list|)
expr_stmt|;
name|src
operator|->
name|scrub
operator|->
name|pfss_tsecr
operator|=
name|ntohl
argument_list|(
name|tsecr
argument_list|)
expr_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|src
operator|->
name|scrub
operator|->
name|pfss_last
argument_list|)
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
default|default:
name|hlen
operator|-=
name|MAX
argument_list|(
name|opt
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|opt
operator|+=
name|MAX
argument_list|(
name|opt
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pf_normalize_tcp_cleanup
parameter_list|(
name|struct
name|pf_state
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|src
operator|.
name|scrub
condition|)
name|uma_zfree
argument_list|(
name|V_pf_state_scrub_z
argument_list|,
name|state
operator|->
name|src
operator|.
name|scrub
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dst
operator|.
name|scrub
condition|)
name|uma_zfree
argument_list|(
name|V_pf_state_scrub_z
argument_list|,
name|state
operator|->
name|dst
operator|.
name|scrub
argument_list|)
expr_stmt|;
comment|/* Someday... flush the TCP segment reassembly descriptors. */
block|}
end_function

begin_function
name|int
name|pf_normalize_tcp_stateful
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|u_short
modifier|*
name|reason
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|pf_state
modifier|*
name|state
parameter_list|,
name|struct
name|pf_state_peer
modifier|*
name|src
parameter_list|,
name|struct
name|pf_state_peer
modifier|*
name|dst
parameter_list|,
name|int
modifier|*
name|writeback
parameter_list|)
block|{
name|struct
name|timeval
name|uptime
decl_stmt|;
name|u_int32_t
name|tsval
decl_stmt|,
name|tsecr
decl_stmt|;
name|u_int
name|tsval_from_last
decl_stmt|;
name|u_int8_t
name|hdr
index|[
literal|60
index|]
decl_stmt|;
name|u_int8_t
modifier|*
name|opt
decl_stmt|;
name|int
name|copyback
init|=
literal|0
decl_stmt|;
name|int
name|got_ts
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|src
operator|->
name|scrub
operator|||
name|dst
operator|->
name|scrub
operator|)
argument_list|,
operator|(
literal|"%s: src->scrub&& dst->scrub!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Enforce the minimum TTL seen for this connection.  Negate a common 	 * technique to evade an intrusion detection system and confuse 	 * firewall state code. 	 */
switch|switch
condition|(
name|pd
operator|->
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
if|if
condition|(
name|src
operator|->
name|scrub
condition|)
block|{
name|struct
name|ip
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|ip_ttl
operator|>
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
condition|)
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
operator|=
name|h
operator|->
name|ip_ttl
expr_stmt|;
name|h
operator|->
name|ip_ttl
operator|=
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
if|if
condition|(
name|src
operator|->
name|scrub
condition|)
block|{
name|struct
name|ip6_hdr
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|ip6_hlim
operator|>
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
condition|)
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
operator|=
name|h
operator|->
name|ip6_hlim
expr_stmt|;
name|h
operator|->
name|ip6_hlim
operator|=
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
block|}
if|if
condition|(
name|th
operator|->
name|th_off
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|>>
literal|2
operator|)
operator|&&
operator|(
operator|(
name|src
operator|->
name|scrub
operator|&&
operator|(
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_TIMESTAMP
operator|)
operator|)
operator|||
operator|(
name|dst
operator|->
name|scrub
operator|&&
operator|(
name|dst
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_TIMESTAMP
operator|)
operator|)
operator|)
operator|&&
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|hdr
argument_list|,
name|th
operator|->
name|th_off
operator|<<
literal|2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pd
operator|->
name|af
argument_list|)
condition|)
block|{
comment|/* Diddle with TCP options */
name|int
name|hlen
decl_stmt|;
name|opt
operator|=
name|hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
name|hlen
operator|=
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
while|while
condition|(
name|hlen
operator|>=
name|TCPOLEN_TIMESTAMP
condition|)
block|{
switch|switch
condition|(
operator|*
name|opt
condition|)
block|{
case|case
name|TCPOPT_EOL
case|:
comment|/* FALLTHROUGH */
case|case
name|TCPOPT_NOP
case|:
name|opt
operator|++
expr_stmt|;
name|hlen
operator|--
expr_stmt|;
break|break;
case|case
name|TCPOPT_TIMESTAMP
case|:
comment|/* Modulate the timestamps.  Can be used for 				 * NAT detection, OS uptime determination or 				 * reboot detection. 				 */
if|if
condition|(
name|got_ts
condition|)
block|{
comment|/* Huh?  Multiple timestamps!? */
if|if
condition|(
name|V_pf_status
operator|.
name|debug
operator|>=
name|PF_DEBUG_MISC
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"multiple TS??"
operator|)
argument_list|)
expr_stmt|;
name|pf_print_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_TS
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
if|if
condition|(
name|opt
index|[
literal|1
index|]
operator|>=
name|TCPOLEN_TIMESTAMP
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|tsval
argument_list|,
operator|&
name|opt
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsval
operator|&&
name|src
operator|->
name|scrub
operator|&&
operator|(
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_TIMESTAMP
operator|)
condition|)
block|{
name|tsval
operator|=
name|ntohl
argument_list|(
name|tsval
argument_list|)
expr_stmt|;
name|pf_change_proto_a
argument_list|(
name|m
argument_list|,
operator|&
name|opt
index|[
literal|2
index|]
argument_list|,
operator|&
name|th
operator|->
name|th_sum
argument_list|,
name|htonl
argument_list|(
name|tsval
operator|+
name|src
operator|->
name|scrub
operator|->
name|pfss_ts_mod
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copyback
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Modulate TS reply iff valid (!0) */
name|memcpy
argument_list|(
operator|&
name|tsecr
argument_list|,
operator|&
name|opt
index|[
literal|6
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsecr
operator|&&
name|dst
operator|->
name|scrub
operator|&&
operator|(
name|dst
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_TIMESTAMP
operator|)
condition|)
block|{
name|tsecr
operator|=
name|ntohl
argument_list|(
name|tsecr
argument_list|)
operator|-
name|dst
operator|->
name|scrub
operator|->
name|pfss_ts_mod
expr_stmt|;
name|pf_change_proto_a
argument_list|(
name|m
argument_list|,
operator|&
name|opt
index|[
literal|6
index|]
argument_list|,
operator|&
name|th
operator|->
name|th_sum
argument_list|,
name|htonl
argument_list|(
name|tsecr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copyback
operator|=
literal|1
expr_stmt|;
block|}
name|got_ts
operator|=
literal|1
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
default|default:
name|hlen
operator|-=
name|MAX
argument_list|(
name|opt
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|opt
operator|+=
name|MAX
argument_list|(
name|opt
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|copyback
condition|)
block|{
comment|/* Copyback the options, caller copys back header */
operator|*
name|writeback
operator|=
literal|1
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|,
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|,
name|hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Must invalidate PAWS checks on connections idle for too long. 	 * The fastest allowed timestamp clock is 1ms.  That turns out to 	 * be about 24 days before it wraps.  XXX Right now our lowerbound 	 * TS echo check only works for the first 12 days of a connection 	 * when the TS has exhausted half its 32bit space 	 */
define|#
directive|define
name|TS_MAX_IDLE
value|(24*24*60*60)
define|#
directive|define
name|TS_MAX_CONN
value|(12*24*60*60)
comment|/* XXX remove when better tsecr check */
name|getmicrouptime
argument_list|(
operator|&
name|uptime
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|scrub
operator|&&
operator|(
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_PAWS
operator|)
operator|&&
operator|(
name|uptime
operator|.
name|tv_sec
operator|-
name|src
operator|->
name|scrub
operator|->
name|pfss_last
operator|.
name|tv_sec
operator|>
name|TS_MAX_IDLE
operator|||
name|time_uptime
operator|-
name|state
operator|->
name|creation
operator|>
name|TS_MAX_CONN
operator|)
condition|)
block|{
if|if
condition|(
name|V_pf_status
operator|.
name|debug
operator|>=
name|PF_DEBUG_MISC
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"src idled out of PAWS\n"
operator|)
argument_list|)
expr_stmt|;
name|pf_print_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|=
operator|(
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
operator|~
name|PFSS_PAWS
operator|)
operator||
name|PFSS_PAWS_IDLED
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|->
name|scrub
operator|&&
operator|(
name|dst
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_PAWS
operator|)
operator|&&
name|uptime
operator|.
name|tv_sec
operator|-
name|dst
operator|->
name|scrub
operator|->
name|pfss_last
operator|.
name|tv_sec
operator|>
name|TS_MAX_IDLE
condition|)
block|{
if|if
condition|(
name|V_pf_status
operator|.
name|debug
operator|>=
name|PF_DEBUG_MISC
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"dst idled out of PAWS\n"
operator|)
argument_list|)
expr_stmt|;
name|pf_print_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|dst
operator|->
name|scrub
operator|->
name|pfss_flags
operator|=
operator|(
name|dst
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
operator|~
name|PFSS_PAWS
operator|)
operator||
name|PFSS_PAWS_IDLED
expr_stmt|;
block|}
if|if
condition|(
name|got_ts
operator|&&
name|src
operator|->
name|scrub
operator|&&
name|dst
operator|->
name|scrub
operator|&&
operator|(
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_PAWS
operator|)
operator|&&
operator|(
name|dst
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_PAWS
operator|)
condition|)
block|{
comment|/* Validate that the timestamps are "in-window". 		 * RFC1323 describes TCP Timestamp options that allow 		 * measurement of RTT (round trip time) and PAWS 		 * (protection against wrapped sequence numbers).  PAWS 		 * gives us a set of rules for rejecting packets on 		 * long fat pipes (packets that were somehow delayed 		 * in transit longer than the time it took to send the 		 * full TCP sequence space of 4Gb).  We can use these 		 * rules and infer a few others that will let us treat 		 * the 32bit timestamp and the 32bit echoed timestamp 		 * as sequence numbers to prevent a blind attacker from 		 * inserting packets into a connection. 		 * 		 * RFC1323 tells us: 		 *  - The timestamp on this packet must be greater than 		 *    or equal to the last value echoed by the other 		 *    endpoint.  The RFC says those will be discarded 		 *    since it is a dup that has already been acked. 		 *    This gives us a lowerbound on the timestamp. 		 *        timestamp>= other last echoed timestamp 		 *  - The timestamp will be less than or equal to 		 *    the last timestamp plus the time between the 		 *    last packet and now.  The RFC defines the max 		 *    clock rate as 1ms.  We will allow clocks to be 		 *    up to 10% fast and will allow a total difference 		 *    or 30 seconds due to a route change.  And this 		 *    gives us an upperbound on the timestamp. 		 *        timestamp<= last timestamp + max ticks 		 *    We have to be careful here.  Windows will send an 		 *    initial timestamp of zero and then initialize it 		 *    to a random value after the 3whs; presumably to 		 *    avoid a DoS by having to call an expensive RNG 		 *    during a SYN flood.  Proof MS has at least one 		 *    good security geek. 		 * 		 *  - The TCP timestamp option must also echo the other 		 *    endpoints timestamp.  The timestamp echoed is the 		 *    one carried on the earliest unacknowledged segment 		 *    on the left edge of the sequence window.  The RFC 		 *    states that the host will reject any echoed 		 *    timestamps that were larger than any ever sent. 		 *    This gives us an upperbound on the TS echo. 		 *        tescr<= largest_tsval 		 *  - The lowerbound on the TS echo is a little more 		 *    tricky to determine.  The other endpoint's echoed 		 *    values will not decrease.  But there may be 		 *    network conditions that re-order packets and 		 *    cause our view of them to decrease.  For now the 		 *    only lowerbound we can safely determine is that 		 *    the TS echo will never be less than the original 		 *    TS.  XXX There is probably a better lowerbound. 		 *    Remove TS_MAX_CONN with better lowerbound check. 		 *        tescr>= other original TS 		 * 		 * It is also important to note that the fastest 		 * timestamp clock of 1ms will wrap its 32bit space in 		 * 24 days.  So we just disable TS checking after 24 		 * days of idle time.  We actually must use a 12d 		 * connection limit until we can come up with a better 		 * lowerbound to the TS echo check. 		 */
name|struct
name|timeval
name|delta_ts
decl_stmt|;
name|int
name|ts_fudge
decl_stmt|;
comment|/* 		 * PFTM_TS_DIFF is how many seconds of leeway to allow 		 * a host's timestamp.  This can happen if the previous 		 * packet got delayed in transit for much longer than 		 * this packet. 		 */
if|if
condition|(
operator|(
name|ts_fudge
operator|=
name|state
operator|->
name|rule
operator|.
name|ptr
operator|->
name|timeout
index|[
name|PFTM_TS_DIFF
index|]
operator|)
operator|==
literal|0
condition|)
name|ts_fudge
operator|=
name|V_pf_default_rule
operator|.
name|timeout
index|[
name|PFTM_TS_DIFF
index|]
expr_stmt|;
comment|/* Calculate max ticks since the last timestamp */
define|#
directive|define
name|TS_MAXFREQ
value|1100
comment|/* RFC max TS freq of 1Khz + 10% skew */
define|#
directive|define
name|TS_MICROSECS
value|1000000
comment|/* microseconds per second */
name|delta_ts
operator|=
name|uptime
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|delta_ts
argument_list|,
operator|&
name|src
operator|->
name|scrub
operator|->
name|pfss_last
argument_list|)
expr_stmt|;
name|tsval_from_last
operator|=
operator|(
name|delta_ts
operator|.
name|tv_sec
operator|+
name|ts_fudge
operator|)
operator|*
name|TS_MAXFREQ
expr_stmt|;
name|tsval_from_last
operator|+=
name|delta_ts
operator|.
name|tv_usec
operator|/
operator|(
name|TS_MICROSECS
operator|/
name|TS_MAXFREQ
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|src
operator|->
name|state
operator|>=
name|TCPS_ESTABLISHED
operator|&&
name|dst
operator|->
name|state
operator|>=
name|TCPS_ESTABLISHED
operator|)
operator|&&
operator|(
name|SEQ_LT
argument_list|(
name|tsval
argument_list|,
name|dst
operator|->
name|scrub
operator|->
name|pfss_tsecr
argument_list|)
operator|||
name|SEQ_GT
argument_list|(
name|tsval
argument_list|,
name|src
operator|->
name|scrub
operator|->
name|pfss_tsval
operator|+
name|tsval_from_last
argument_list|)
operator|||
operator|(
name|tsecr
operator|&&
operator|(
name|SEQ_GT
argument_list|(
name|tsecr
argument_list|,
name|dst
operator|->
name|scrub
operator|->
name|pfss_tsval
argument_list|)
operator|||
name|SEQ_LT
argument_list|(
name|tsecr
argument_list|,
name|dst
operator|->
name|scrub
operator|->
name|pfss_tsval0
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Bad RFC1323 implementation or an insertion attack. 			 * 			 * - Solaris 2.6 and 2.7 are known to send another ACK 			 *   after the FIN,FIN|ACK,ACK closing that carries 			 *   an old timestamp. 			 */
name|DPFPRINTF
argument_list|(
operator|(
literal|"Timestamp failed %c%c%c%c\n"
operator|,
name|SEQ_LT
argument_list|(
name|tsval
argument_list|,
name|dst
operator|->
name|scrub
operator|->
name|pfss_tsecr
argument_list|)
condition|?
literal|'0'
else|:
literal|' '
operator|,
name|SEQ_GT
argument_list|(
name|tsval
argument_list|,
name|src
operator|->
name|scrub
operator|->
name|pfss_tsval
operator|+
name|tsval_from_last
argument_list|)
condition|?
literal|'1'
else|:
literal|' '
operator|,
name|SEQ_GT
argument_list|(
name|tsecr
argument_list|,
name|dst
operator|->
name|scrub
operator|->
name|pfss_tsval
argument_list|)
condition|?
literal|'2'
else|:
literal|' '
operator|,
name|SEQ_LT
argument_list|(
name|tsecr
argument_list|,
name|dst
operator|->
name|scrub
operator|->
name|pfss_tsval0
argument_list|)
condition|?
literal|'3'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
name|DPFPRINTF
argument_list|(
operator|(
literal|" tsval: %u  tsecr: %u  +ticks: %u  "
literal|"idle: %jus %lums\n"
operator|,
name|tsval
operator|,
name|tsecr
operator|,
name|tsval_from_last
operator|,
operator|(
name|uintmax_t
operator|)
name|delta_ts
operator|.
name|tv_sec
operator|,
name|delta_ts
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
argument_list|)
expr_stmt|;
name|DPFPRINTF
argument_list|(
operator|(
literal|" src->tsval: %u  tsecr: %u\n"
operator|,
name|src
operator|->
name|scrub
operator|->
name|pfss_tsval
operator|,
name|src
operator|->
name|scrub
operator|->
name|pfss_tsecr
operator|)
argument_list|)
expr_stmt|;
name|DPFPRINTF
argument_list|(
operator|(
literal|" dst->tsval: %u  tsecr: %u  tsval0: %u"
literal|"\n"
operator|,
name|dst
operator|->
name|scrub
operator|->
name|pfss_tsval
operator|,
name|dst
operator|->
name|scrub
operator|->
name|pfss_tsecr
operator|,
name|dst
operator|->
name|scrub
operator|->
name|pfss_tsval0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_pf_status
operator|.
name|debug
operator|>=
name|PF_DEBUG_MISC
condition|)
block|{
name|pf_print_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|pf_print_flags
argument_list|(
name|th
operator|->
name|th_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_TS
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
comment|/* XXX I'd really like to require tsecr but it's optional */
block|}
elseif|else
if|if
condition|(
operator|!
name|got_ts
operator|&&
operator|(
name|th
operator|->
name|th_flags
operator|&
name|TH_RST
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|src
operator|->
name|state
operator|==
name|TCPS_ESTABLISHED
operator|&&
name|dst
operator|->
name|state
operator|==
name|TCPS_ESTABLISHED
operator|)
operator|||
name|pd
operator|->
name|p_len
operator|>
literal|0
operator|||
operator|(
name|th
operator|->
name|th_flags
operator|&
name|TH_SYN
operator|)
operator|)
operator|&&
name|src
operator|->
name|scrub
operator|&&
name|dst
operator|->
name|scrub
operator|&&
operator|(
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_PAWS
operator|)
operator|&&
operator|(
name|dst
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_PAWS
operator|)
condition|)
block|{
comment|/* Didn't send a timestamp.  Timestamps aren't really useful 		 * when: 		 *  - connection opening or closing (often not even sent). 		 *    but we must not let an attacker to put a FIN on a 		 *    data packet to sneak it through our ESTABLISHED check. 		 *  - on a TCP reset.  RFC suggests not even looking at TS. 		 *  - on an empty ACK.  The TS will not be echoed so it will 		 *    probably not help keep the RTT calculation in sync and 		 *    there isn't as much danger when the sequence numbers 		 *    got wrapped.  So some stacks don't include TS on empty 		 *    ACKs :-( 		 * 		 * To minimize the disruption to mostly RFC1323 conformant 		 * stacks, we will only require timestamps on data packets. 		 * 		 * And what do ya know, we cannot require timestamps on data 		 * packets.  There appear to be devices that do legitimate 		 * TCP connection hijacking.  There are HTTP devices that allow 		 * a 3whs (with timestamps) and then buffer the HTTP request. 		 * If the intermediate device has the HTTP response cache, it 		 * will spoof the response but not bother timestamping its 		 * packets.  So we can look for the presence of a timestamp in 		 * the first data packet and if there, require it in all future 		 * packets. 		 */
if|if
condition|(
name|pd
operator|->
name|p_len
operator|>
literal|0
operator|&&
operator|(
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_DATA_TS
operator|)
condition|)
block|{
comment|/* 			 * Hey!  Someone tried to sneak a packet in.  Or the 			 * stack changed its RFC1323 behavior?!?! 			 */
if|if
condition|(
name|V_pf_status
operator|.
name|debug
operator|>=
name|PF_DEBUG_MISC
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"Did not receive expected RFC1323 "
literal|"timestamp\n"
operator|)
argument_list|)
expr_stmt|;
name|pf_print_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|pf_print_flags
argument_list|(
name|th
operator|->
name|th_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_TS
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
block|}
comment|/* 	 * We will note if a host sends his data packets with or without 	 * timestamps.  And require all data packets to contain a timestamp 	 * if the first does.  PAWS implicitly requires that all data packets be 	 * timestamped.  But I think there are middle-man devices that hijack 	 * TCP streams immediately after the 3whs and don't timestamp their 	 * packets (seen in a WWW accelerator or cache). 	 */
if|if
condition|(
name|pd
operator|->
name|p_len
operator|>
literal|0
operator|&&
name|src
operator|->
name|scrub
operator|&&
operator|(
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
operator|(
name|PFSS_TIMESTAMP
operator||
name|PFSS_DATA_TS
operator||
name|PFSS_DATA_NOTS
operator|)
operator|)
operator|==
name|PFSS_TIMESTAMP
condition|)
block|{
if|if
condition|(
name|got_ts
condition|)
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator||=
name|PFSS_DATA_TS
expr_stmt|;
else|else
block|{
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator||=
name|PFSS_DATA_NOTS
expr_stmt|;
if|if
condition|(
name|V_pf_status
operator|.
name|debug
operator|>=
name|PF_DEBUG_MISC
operator|&&
name|dst
operator|->
name|scrub
operator|&&
operator|(
name|dst
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_TIMESTAMP
operator|)
condition|)
block|{
comment|/* Don't warn if other host rejected RFC1323 */
name|DPFPRINTF
argument_list|(
operator|(
literal|"Broken RFC1323 stack did not "
literal|"timestamp data packet. Disabled PAWS "
literal|"security.\n"
operator|)
argument_list|)
expr_stmt|;
name|pf_print_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|pf_print_flags
argument_list|(
name|th
operator|->
name|th_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Update PAWS values 	 */
if|if
condition|(
name|got_ts
operator|&&
name|src
operator|->
name|scrub
operator|&&
name|PFSS_TIMESTAMP
operator|==
operator|(
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
operator|(
name|PFSS_PAWS_IDLED
operator||
name|PFSS_TIMESTAMP
operator|)
operator|)
condition|)
block|{
name|getmicrouptime
argument_list|(
operator|&
name|src
operator|->
name|scrub
operator|->
name|pfss_last
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|tsval
argument_list|,
name|src
operator|->
name|scrub
operator|->
name|pfss_tsval
argument_list|)
operator|||
operator|(
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_PAWS
operator|)
operator|==
literal|0
condition|)
name|src
operator|->
name|scrub
operator|->
name|pfss_tsval
operator|=
name|tsval
expr_stmt|;
if|if
condition|(
name|tsecr
condition|)
block|{
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|tsecr
argument_list|,
name|src
operator|->
name|scrub
operator|->
name|pfss_tsecr
argument_list|)
operator|||
operator|(
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_PAWS
operator|)
operator|==
literal|0
condition|)
name|src
operator|->
name|scrub
operator|->
name|pfss_tsecr
operator|=
name|tsecr
expr_stmt|;
if|if
condition|(
operator|(
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_PAWS
operator|)
operator|==
literal|0
operator|&&
operator|(
name|SEQ_LT
argument_list|(
name|tsval
argument_list|,
name|src
operator|->
name|scrub
operator|->
name|pfss_tsval0
argument_list|)
operator|||
name|src
operator|->
name|scrub
operator|->
name|pfss_tsval0
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* tsval0 MUST be the lowest timestamp */
name|src
operator|->
name|scrub
operator|->
name|pfss_tsval0
operator|=
name|tsval
expr_stmt|;
block|}
comment|/* Only fully initialized after a TS gets echoed */
if|if
condition|(
operator|(
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_PAWS
operator|)
operator|==
literal|0
condition|)
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator||=
name|PFSS_PAWS
expr_stmt|;
block|}
block|}
comment|/* I have a dream....  TCP segment reassembly.... */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_normalize_tcpopt
parameter_list|(
name|struct
name|pf_rule
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|int
name|off
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|u_int16_t
modifier|*
name|mss
decl_stmt|;
name|int
name|thoff
decl_stmt|;
name|int
name|opt
decl_stmt|,
name|cnt
decl_stmt|,
name|optlen
init|=
literal|0
decl_stmt|;
name|int
name|rewrite
init|=
literal|0
decl_stmt|;
name|u_char
name|opts
index|[
name|TCP_MAXOLEN
index|]
decl_stmt|;
name|u_char
modifier|*
name|optp
init|=
name|opts
decl_stmt|;
name|thoff
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
name|cnt
operator|=
name|thoff
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|0
operator|&&
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|,
name|opts
argument_list|,
name|cnt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|af
argument_list|)
condition|)
return|return
operator|(
name|rewrite
operator|)
return|;
for|for
control|(
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|-=
name|optlen
operator|,
name|optp
operator|+=
name|optlen
control|)
block|{
name|opt
operator|=
name|optp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|TCPOPT_EOL
condition|)
break|break;
if|if
condition|(
name|opt
operator|==
name|TCPOPT_NOP
condition|)
name|optlen
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cnt
operator|<
literal|2
condition|)
break|break;
name|optlen
operator|=
name|optp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|optlen
operator|<
literal|2
operator|||
name|optlen
operator|>
name|cnt
condition|)
break|break;
block|}
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|TCPOPT_MAXSEG
case|:
name|mss
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|optp
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntohs
argument_list|(
operator|*
name|mss
argument_list|)
operator|)
operator|>
name|r
operator|->
name|max_mss
condition|)
block|{
name|th
operator|->
name|th_sum
operator|=
name|pf_proto_cksum_fixup
argument_list|(
name|m
argument_list|,
name|th
operator|->
name|th_sum
argument_list|,
operator|*
name|mss
argument_list|,
name|htons
argument_list|(
name|r
operator|->
name|max_mss
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mss
operator|=
name|htons
argument_list|(
name|r
operator|->
name|max_mss
argument_list|)
expr_stmt|;
name|rewrite
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|rewrite
condition|)
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|,
name|thoff
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|,
name|opts
argument_list|)
expr_stmt|;
return|return
operator|(
name|rewrite
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
specifier|static
name|void
name|pf_scrub_ip
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|u_int32_t
name|flags
parameter_list|,
name|u_int8_t
name|min_ttl
parameter_list|,
name|u_int8_t
name|tos
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|;
name|struct
name|ip
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
comment|/* Clear IP_DF if no-df was requested */
if|if
condition|(
name|flags
operator|&
name|PFRULE_NODF
operator|&&
name|h
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_DF
argument_list|)
condition|)
block|{
name|u_int16_t
name|ip_off
init|=
name|h
operator|->
name|ip_off
decl_stmt|;
name|h
operator|->
name|ip_off
operator|&=
name|htons
argument_list|(
operator|~
name|IP_DF
argument_list|)
expr_stmt|;
name|h
operator|->
name|ip_sum
operator|=
name|pf_cksum_fixup
argument_list|(
name|h
operator|->
name|ip_sum
argument_list|,
name|ip_off
argument_list|,
name|h
operator|->
name|ip_off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Enforce a minimum ttl, may cause endless packet loops */
if|if
condition|(
name|min_ttl
operator|&&
name|h
operator|->
name|ip_ttl
operator|<
name|min_ttl
condition|)
block|{
name|u_int16_t
name|ip_ttl
init|=
name|h
operator|->
name|ip_ttl
decl_stmt|;
name|h
operator|->
name|ip_ttl
operator|=
name|min_ttl
expr_stmt|;
name|h
operator|->
name|ip_sum
operator|=
name|pf_cksum_fixup
argument_list|(
name|h
operator|->
name|ip_sum
argument_list|,
name|ip_ttl
argument_list|,
name|h
operator|->
name|ip_ttl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Enforce tos */
if|if
condition|(
name|flags
operator|&
name|PFRULE_SET_TOS
condition|)
block|{
name|u_int16_t
name|ov
decl_stmt|,
name|nv
decl_stmt|;
name|ov
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|h
expr_stmt|;
name|h
operator|->
name|ip_tos
operator|=
name|tos
expr_stmt|;
name|nv
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|h
expr_stmt|;
name|h
operator|->
name|ip_sum
operator|=
name|pf_cksum_fixup
argument_list|(
name|h
operator|->
name|ip_sum
argument_list|,
name|ov
argument_list|,
name|nv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* random-id, but not for fragments */
if|if
condition|(
name|flags
operator|&
name|PFRULE_RANDOMID
operator|&&
operator|!
operator|(
name|h
operator|->
name|ip_off
operator|&
operator|~
name|htons
argument_list|(
name|IP_DF
argument_list|)
operator|)
condition|)
block|{
name|u_int16_t
name|ip_id
init|=
name|h
operator|->
name|ip_id
decl_stmt|;
name|h
operator|->
name|ip_id
operator|=
name|ip_randomid
argument_list|()
expr_stmt|;
name|h
operator|->
name|ip_sum
operator|=
name|pf_cksum_fixup
argument_list|(
name|h
operator|->
name|ip_sum
argument_list|,
name|ip_id
argument_list|,
name|h
operator|->
name|ip_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
specifier|static
name|void
name|pf_scrub_ip6
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|u_int8_t
name|min_ttl
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
comment|/* Enforce a minimum ttl, may cause endless packet loops */
if|if
condition|(
name|min_ttl
operator|&&
name|h
operator|->
name|ip6_hlim
operator|<
name|min_ttl
condition|)
name|h
operator|->
name|ip6_hlim
operator|=
name|min_ttl
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

