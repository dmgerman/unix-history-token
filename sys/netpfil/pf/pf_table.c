begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: pf_table.c,v 1.79 2008/10/08 06:24:50 mcbride Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2002 Cedric Berger  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *    - Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *    - Redistributions in binary form must reproduce the above  *      copyright notice, this list of conditions and the following  *      disclaimer in the documentation and/or other materials provided  *      with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<net/pfvar.h>
end_include

begin_define
define|#
directive|define
name|ACCEPT_FLAGS
parameter_list|(
name|flags
parameter_list|,
name|oklist
parameter_list|)
define|\
value|do {					\ 		if ((flags& ~(oklist))&	\ 		    PFR_FLAG_ALLMASK)		\ 			return (EINVAL);	\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|FILLIN_SIN
parameter_list|(
name|sin
parameter_list|,
name|addr
parameter_list|)
define|\
value|do {					\ 		(sin).sin_len = sizeof(sin);	\ 		(sin).sin_family = AF_INET;	\ 		(sin).sin_addr = (addr);	\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|FILLIN_SIN6
parameter_list|(
name|sin6
parameter_list|,
name|addr
parameter_list|)
define|\
value|do {					\ 		(sin6).sin6_len = sizeof(sin6);	\ 		(sin6).sin6_family = AF_INET6;	\ 		(sin6).sin6_addr = (addr);	\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|SWAP
parameter_list|(
name|type
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
define|\
value|do {					\ 		type tmp = a1;			\ 		a1 = a2;			\ 		a2 = tmp;			\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|SUNION2PF
parameter_list|(
name|su
parameter_list|,
name|af
parameter_list|)
value|(((af)==AF_INET) ?	\     (struct pf_addr *)&(su)->sin.sin_addr :	\     (struct pf_addr *)&(su)->sin6.sin6_addr)
end_define

begin_define
define|#
directive|define
name|AF_BITS
parameter_list|(
name|af
parameter_list|)
value|(((af)==AF_INET)?32:128)
end_define

begin_define
define|#
directive|define
name|ADDR_NETWORK
parameter_list|(
name|ad
parameter_list|)
value|((ad)->pfra_net< AF_BITS((ad)->pfra_af))
end_define

begin_define
define|#
directive|define
name|KENTRY_NETWORK
parameter_list|(
name|ke
parameter_list|)
value|((ke)->pfrke_net< AF_BITS((ke)->pfrke_af))
end_define

begin_define
define|#
directive|define
name|KENTRY_RNF_ROOT
parameter_list|(
name|ke
parameter_list|)
define|\
value|((((struct radix_node *)(ke))->rn_flags& RNF_ROOT) != 0)
end_define

begin_define
define|#
directive|define
name|NO_ADDRESSES
value|(-1)
end_define

begin_define
define|#
directive|define
name|ENQUEUE_UNMARKED_ONLY
value|(1)
end_define

begin_define
define|#
directive|define
name|INVERT_NEG_FLAG
value|(1)
end_define

begin_struct
struct|struct
name|pfr_walktree
block|{
enum|enum
name|pfrw_op
block|{
name|PFRW_MARK
block|,
name|PFRW_SWEEP
block|,
name|PFRW_ENQUEUE
block|,
name|PFRW_GET_ADDRS
block|,
name|PFRW_GET_ASTATS
block|,
name|PFRW_POOL_GET
block|,
name|PFRW_DYNADDR_UPDATE
block|}
name|pfrw_op
enum|;
union|union
block|{
name|struct
name|pfr_addr
modifier|*
name|pfrw1_addr
decl_stmt|;
name|struct
name|pfr_astats
modifier|*
name|pfrw1_astats
decl_stmt|;
name|struct
name|pfr_kentryworkq
modifier|*
name|pfrw1_workq
decl_stmt|;
name|struct
name|pfr_kentry
modifier|*
name|pfrw1_kentry
decl_stmt|;
name|struct
name|pfi_dynaddr
modifier|*
name|pfrw1_dyn
decl_stmt|;
block|}
name|pfrw_1
union|;
name|int
name|pfrw_free
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|pfrw_addr
value|pfrw_1.pfrw1_addr
end_define

begin_define
define|#
directive|define
name|pfrw_astats
value|pfrw_1.pfrw1_astats
end_define

begin_define
define|#
directive|define
name|pfrw_workq
value|pfrw_1.pfrw1_workq
end_define

begin_define
define|#
directive|define
name|pfrw_kentry
value|pfrw_1.pfrw1_kentry
end_define

begin_define
define|#
directive|define
name|pfrw_dyn
value|pfrw_1.pfrw1_dyn
end_define

begin_define
define|#
directive|define
name|pfrw_cnt
value|pfrw_free
end_define

begin_define
define|#
directive|define
name|senderr
parameter_list|(
name|e
parameter_list|)
value|do { rv = (e); goto _bad; } while (0)
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_PFTABLE
argument_list|,
literal|"pf_table"
argument_list|,
literal|"pf(4) tables structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|uma_zone_t
argument_list|,
name|pfr_kentry_z
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pfr_kentry_z
value|VNET(pfr_kentry_z)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|uma_zone_t
argument_list|,
name|pfr_kcounters_z
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pfr_kcounters_z
value|VNET(pfr_kcounters_z)
end_define

begin_decl_stmt
specifier|static
name|struct
name|pf_addr
name|pfr_ffaddr
init|=
block|{
operator|.
name|addr32
operator|=
block|{
literal|0xffffffff
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|pfr_copyout_addr
parameter_list|(
name|struct
name|pfr_addr
modifier|*
parameter_list|,
name|struct
name|pfr_kentry
modifier|*
name|ke
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pfr_validate_addr
parameter_list|(
name|struct
name|pfr_addr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_enqueue_addrs
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
parameter_list|,
name|struct
name|pfr_kentryworkq
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_mark_addrs
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pfr_kentry
modifier|*
name|pfr_lookup_addr
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
parameter_list|,
name|struct
name|pfr_addr
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pfr_kentry
modifier|*
name|pfr_create_kentry
parameter_list|(
name|struct
name|pfr_addr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_destroy_kentries
parameter_list|(
name|struct
name|pfr_kentryworkq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_destroy_kentry
parameter_list|(
name|struct
name|pfr_kentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_insert_kentries
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
parameter_list|,
name|struct
name|pfr_kentryworkq
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_remove_kentries
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
parameter_list|,
name|struct
name|pfr_kentryworkq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_clstats_kentries
parameter_list|(
name|struct
name|pfr_kentryworkq
modifier|*
parameter_list|,
name|long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_reset_feedback
parameter_list|(
name|struct
name|pfr_addr
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_prepare_network
parameter_list|(
name|union
name|sockaddr_union
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pfr_route_kentry
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
parameter_list|,
name|struct
name|pfr_kentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pfr_unroute_kentry
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
parameter_list|,
name|struct
name|pfr_kentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pfr_walktree
parameter_list|(
name|struct
name|radix_node
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pfr_validate_table
parameter_list|(
name|struct
name|pfr_table
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pfr_fix_anchor
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_commit_ktable
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_insert_ktables
parameter_list|(
name|struct
name|pfr_ktableworkq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_insert_ktable
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_setflags_ktables
parameter_list|(
name|struct
name|pfr_ktableworkq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_setflags_ktable
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_clstats_ktables
parameter_list|(
name|struct
name|pfr_ktableworkq
modifier|*
parameter_list|,
name|long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_clstats_ktable
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
parameter_list|,
name|long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pfr_ktable
modifier|*
name|pfr_create_ktable
parameter_list|(
name|struct
name|pfr_table
modifier|*
parameter_list|,
name|long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_destroy_ktables
parameter_list|(
name|struct
name|pfr_ktableworkq
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_destroy_ktable
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pfr_ktable_compare
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
parameter_list|,
name|struct
name|pfr_ktable
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pfr_ktable
modifier|*
name|pfr_lookup_table
parameter_list|(
name|struct
name|pfr_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfr_clean_node_mask
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
parameter_list|,
name|struct
name|pfr_kentryworkq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pfr_table_count
parameter_list|(
name|struct
name|pfr_table
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pfr_skip_table
parameter_list|(
name|struct
name|pfr_table
modifier|*
parameter_list|,
name|struct
name|pfr_ktable
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pfr_kentry
modifier|*
name|pfr_kentry_byidx
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|RB_PROTOTYPE
argument_list|(
name|pfr_ktablehead
argument_list|,
name|pfr_ktable
argument_list|,
name|pfrkt_tree
argument_list|,
name|pfr_ktable_compare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|RB_GENERATE
argument_list|(
name|pfr_ktablehead
argument_list|,
name|pfr_ktable
argument_list|,
name|pfrkt_tree
argument_list|,
name|pfr_ktable_compare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|pfr_ktablehead
name|pfr_ktables
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pfr_table
name|pfr_nulltable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pfr_ktable_cnt
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pfr_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|V_pfr_kentry_z
operator|=
name|uma_zcreate
argument_list|(
literal|"pf table entries"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_kentry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V_pfr_kcounters_z
operator|=
name|uma_zcreate
argument_list|(
literal|"pf table counters"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_kcounters
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V_pf_limits
index|[
name|PF_LIMIT_TABLE_ENTRIES
index|]
operator|.
name|zone
operator|=
name|V_pfr_kentry_z
expr_stmt|;
name|V_pf_limits
index|[
name|PF_LIMIT_TABLE_ENTRIES
index|]
operator|.
name|limit
operator|=
name|PFR_KENTRY_HIWAT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pfr_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|uma_zdestroy
argument_list|(
name|V_pfr_kentry_z
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|V_pfr_kcounters_z
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pfr_clr_addrs
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|int
modifier|*
name|ndel
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|kt
decl_stmt|;
name|struct
name|pfr_kentryworkq
name|workq
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_DUMMY
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_validate_table
argument_list|(
name|tbl
argument_list|,
literal|0
argument_list|,
name|flags
operator|&
name|PFR_FLAG_USERIOCTL
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|kt
operator|=
name|pfr_lookup_table
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
operator|||
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_CONST
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|pfr_enqueue_addrs
argument_list|(
name|kt
argument_list|,
operator|&
name|workq
argument_list|,
name|ndel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_FLAG_DUMMY
operator|)
condition|)
block|{
name|pfr_remove_kentries
argument_list|(
name|kt
argument_list|,
operator|&
name|workq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|kt
operator|->
name|pfrkt_cnt
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: non-null pfrkt_cnt"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_add_addrs
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|struct
name|pfr_addr
modifier|*
name|addr
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|nadd
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|kt
decl_stmt|,
modifier|*
name|tmpkt
decl_stmt|;
name|struct
name|pfr_kentryworkq
name|workq
decl_stmt|;
name|struct
name|pfr_kentry
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|pfr_addr
modifier|*
name|ad
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|,
name|xadd
init|=
literal|0
decl_stmt|;
name|long
name|tzero
init|=
name|time_second
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_DUMMY
operator||
name|PFR_FLAG_FEEDBACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_validate_table
argument_list|(
name|tbl
argument_list|,
literal|0
argument_list|,
name|flags
operator|&
name|PFR_FLAG_USERIOCTL
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|kt
operator|=
name|pfr_lookup_table
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
operator|||
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_CONST
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|tmpkt
operator|=
name|pfr_create_ktable
argument_list|(
operator|&
name|pfr_nulltable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpkt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|SLIST_INIT
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ad
operator|=
name|addr
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|ad
operator|++
control|)
block|{
if|if
condition|(
name|pfr_validate_addr
argument_list|(
name|ad
argument_list|)
condition|)
name|senderr
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|p
operator|=
name|pfr_lookup_addr
argument_list|(
name|kt
argument_list|,
name|ad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|q
operator|=
name|pfr_lookup_addr
argument_list|(
name|tmpkt
argument_list|,
name|ad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_FLAG_FEEDBACK
condition|)
block|{
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
name|ad
operator|->
name|pfra_fback
operator|=
name|PFR_FB_DUPLICATE
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|ad
operator|->
name|pfra_fback
operator|=
name|PFR_FB_ADDED
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|pfrke_not
operator|!=
name|ad
operator|->
name|pfra_not
condition|)
name|ad
operator|->
name|pfra_fback
operator|=
name|PFR_FB_CONFLICT
expr_stmt|;
else|else
name|ad
operator|->
name|pfra_fback
operator|=
name|PFR_FB_NONE
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
name|q
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|pfr_create_kentry
argument_list|(
name|ad
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_route_kentry
argument_list|(
name|tmpkt
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|pfr_destroy_kentry
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ad
operator|->
name|pfra_fback
operator|=
name|PFR_FB_NONE
expr_stmt|;
block|}
else|else
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|workq
argument_list|,
name|p
argument_list|,
name|pfrke_workq
argument_list|)
expr_stmt|;
name|xadd
operator|++
expr_stmt|;
block|}
block|}
block|}
name|pfr_clean_node_mask
argument_list|(
name|tmpkt
argument_list|,
operator|&
name|workq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_FLAG_DUMMY
operator|)
condition|)
name|pfr_insert_kentries
argument_list|(
name|kt
argument_list|,
operator|&
name|workq
argument_list|,
name|tzero
argument_list|)
expr_stmt|;
else|else
name|pfr_destroy_kentries
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nadd
operator|!=
name|NULL
condition|)
operator|*
name|nadd
operator|=
name|xadd
expr_stmt|;
name|pfr_destroy_ktable
argument_list|(
name|tmpkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|_bad
label|:
name|pfr_clean_node_mask
argument_list|(
name|tmpkt
argument_list|,
operator|&
name|workq
argument_list|)
expr_stmt|;
name|pfr_destroy_kentries
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_FLAG_FEEDBACK
condition|)
name|pfr_reset_feedback
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pfr_destroy_ktable
argument_list|(
name|tmpkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_del_addrs
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|struct
name|pfr_addr
modifier|*
name|addr
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|ndel
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|kt
decl_stmt|;
name|struct
name|pfr_kentryworkq
name|workq
decl_stmt|;
name|struct
name|pfr_kentry
modifier|*
name|p
decl_stmt|;
name|struct
name|pfr_addr
modifier|*
name|ad
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|,
name|xdel
init|=
literal|0
decl_stmt|,
name|log
init|=
literal|1
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_DUMMY
operator||
name|PFR_FLAG_FEEDBACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_validate_table
argument_list|(
name|tbl
argument_list|,
literal|0
argument_list|,
name|flags
operator|&
name|PFR_FLAG_USERIOCTL
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|kt
operator|=
name|pfr_lookup_table
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
operator|||
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_CONST
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 	 * there are two algorithms to choose from here. 	 * with: 	 *   n: number of addresses to delete 	 *   N: number of addresses in the table 	 * 	 * one is O(N) and is better for large 'n' 	 * one is O(n*LOG(N)) and is better for small 'n' 	 * 	 * following code try to decide which one is best. 	 */
for|for
control|(
name|i
operator|=
name|kt
operator|->
name|pfrkt_cnt
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|>>=
literal|1
control|)
name|log
operator|++
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|kt
operator|->
name|pfrkt_cnt
operator|/
name|log
condition|)
block|{
comment|/* full table scan */
name|pfr_mark_addrs
argument_list|(
name|kt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* iterate over addresses to delete */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ad
operator|=
name|addr
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|ad
operator|++
control|)
block|{
if|if
condition|(
name|pfr_validate_addr
argument_list|(
name|ad
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|p
operator|=
name|pfr_lookup_addr
argument_list|(
name|kt
argument_list|,
name|ad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|p
operator|->
name|pfrke_mark
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|SLIST_INIT
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ad
operator|=
name|addr
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|ad
operator|++
control|)
block|{
if|if
condition|(
name|pfr_validate_addr
argument_list|(
name|ad
argument_list|)
condition|)
name|senderr
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|p
operator|=
name|pfr_lookup_addr
argument_list|(
name|kt
argument_list|,
name|ad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_FLAG_FEEDBACK
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|ad
operator|->
name|pfra_fback
operator|=
name|PFR_FB_NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|pfrke_not
operator|!=
name|ad
operator|->
name|pfra_not
condition|)
name|ad
operator|->
name|pfra_fback
operator|=
name|PFR_FB_CONFLICT
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|pfrke_mark
condition|)
name|ad
operator|->
name|pfra_fback
operator|=
name|PFR_FB_DUPLICATE
expr_stmt|;
else|else
name|ad
operator|->
name|pfra_fback
operator|=
name|PFR_FB_DELETED
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|pfrke_not
operator|==
name|ad
operator|->
name|pfra_not
operator|&&
operator|!
name|p
operator|->
name|pfrke_mark
condition|)
block|{
name|p
operator|->
name|pfrke_mark
operator|=
literal|1
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|workq
argument_list|,
name|p
argument_list|,
name|pfrke_workq
argument_list|)
expr_stmt|;
name|xdel
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_FLAG_DUMMY
operator|)
condition|)
name|pfr_remove_kentries
argument_list|(
name|kt
argument_list|,
operator|&
name|workq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndel
operator|!=
name|NULL
condition|)
operator|*
name|ndel
operator|=
name|xdel
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|_bad
label|:
if|if
condition|(
name|flags
operator|&
name|PFR_FLAG_FEEDBACK
condition|)
name|pfr_reset_feedback
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_set_addrs
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|struct
name|pfr_addr
modifier|*
name|addr
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|size2
parameter_list|,
name|int
modifier|*
name|nadd
parameter_list|,
name|int
modifier|*
name|ndel
parameter_list|,
name|int
modifier|*
name|nchange
parameter_list|,
name|int
name|flags
parameter_list|,
name|u_int32_t
name|ignore_pfrt_flags
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|kt
decl_stmt|,
modifier|*
name|tmpkt
decl_stmt|;
name|struct
name|pfr_kentryworkq
name|addq
decl_stmt|,
name|delq
decl_stmt|,
name|changeq
decl_stmt|;
name|struct
name|pfr_kentry
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|pfr_addr
name|ad
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|,
name|xadd
init|=
literal|0
decl_stmt|,
name|xdel
init|=
literal|0
decl_stmt|,
name|xchange
init|=
literal|0
decl_stmt|;
name|long
name|tzero
init|=
name|time_second
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_DUMMY
operator||
name|PFR_FLAG_FEEDBACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_validate_table
argument_list|(
name|tbl
argument_list|,
name|ignore_pfrt_flags
argument_list|,
name|flags
operator|&
name|PFR_FLAG_USERIOCTL
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|kt
operator|=
name|pfr_lookup_table
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
operator|||
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_CONST
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|tmpkt
operator|=
name|pfr_create_ktable
argument_list|(
operator|&
name|pfr_nulltable
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpkt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|pfr_mark_addrs
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|addq
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|delq
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|changeq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * XXXGL: undertand pf_if usage of this function 		 * and make ad a moving pointer 		 */
name|bcopy
argument_list|(
name|addr
operator|+
name|i
argument_list|,
operator|&
name|ad
argument_list|,
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_validate_addr
argument_list|(
operator|&
name|ad
argument_list|)
condition|)
name|senderr
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|ad
operator|.
name|pfra_fback
operator|=
name|PFR_FB_NONE
expr_stmt|;
name|p
operator|=
name|pfr_lookup_addr
argument_list|(
name|kt
argument_list|,
operator|&
name|ad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|pfrke_mark
condition|)
block|{
name|ad
operator|.
name|pfra_fback
operator|=
name|PFR_FB_DUPLICATE
expr_stmt|;
goto|goto
name|_skip
goto|;
block|}
name|p
operator|->
name|pfrke_mark
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pfrke_not
operator|!=
name|ad
operator|.
name|pfra_not
condition|)
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|changeq
argument_list|,
name|p
argument_list|,
name|pfrke_workq
argument_list|)
expr_stmt|;
name|ad
operator|.
name|pfra_fback
operator|=
name|PFR_FB_CHANGED
expr_stmt|;
name|xchange
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|q
operator|=
name|pfr_lookup_addr
argument_list|(
name|tmpkt
argument_list|,
operator|&
name|ad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
name|ad
operator|.
name|pfra_fback
operator|=
name|PFR_FB_DUPLICATE
expr_stmt|;
goto|goto
name|_skip
goto|;
block|}
name|p
operator|=
name|pfr_create_kentry
argument_list|(
operator|&
name|ad
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_route_kentry
argument_list|(
name|tmpkt
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|pfr_destroy_kentry
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ad
operator|.
name|pfra_fback
operator|=
name|PFR_FB_NONE
expr_stmt|;
block|}
else|else
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|addq
argument_list|,
name|p
argument_list|,
name|pfrke_workq
argument_list|)
expr_stmt|;
name|ad
operator|.
name|pfra_fback
operator|=
name|PFR_FB_ADDED
expr_stmt|;
name|xadd
operator|++
expr_stmt|;
block|}
block|}
name|_skip
label|:
if|if
condition|(
name|flags
operator|&
name|PFR_FLAG_FEEDBACK
condition|)
name|bcopy
argument_list|(
operator|&
name|ad
argument_list|,
name|addr
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pfr_enqueue_addrs
argument_list|(
name|kt
argument_list|,
operator|&
name|delq
argument_list|,
operator|&
name|xdel
argument_list|,
name|ENQUEUE_UNMARKED_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PFR_FLAG_FEEDBACK
operator|)
operator|&&
operator|*
name|size2
condition|)
block|{
if|if
condition|(
operator|*
name|size2
operator|<
name|size
operator|+
name|xdel
condition|)
block|{
operator|*
name|size2
operator|=
name|size
operator|+
name|xdel
expr_stmt|;
name|senderr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&delq
argument_list|,
argument|pfrke_workq
argument_list|)
block|{
name|pfr_copyout_addr
argument_list|(
operator|&
name|ad
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ad
operator|.
name|pfra_fback
operator|=
name|PFR_FB_DELETED
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ad
argument_list|,
name|addr
operator|+
name|size
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|pfr_clean_node_mask
argument_list|(
name|tmpkt
argument_list|,
operator|&
name|addq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_FLAG_DUMMY
operator|)
condition|)
block|{
name|pfr_insert_kentries
argument_list|(
name|kt
argument_list|,
operator|&
name|addq
argument_list|,
name|tzero
argument_list|)
expr_stmt|;
name|pfr_remove_kentries
argument_list|(
name|kt
argument_list|,
operator|&
name|delq
argument_list|)
expr_stmt|;
name|pfr_clstats_kentries
argument_list|(
operator|&
name|changeq
argument_list|,
name|tzero
argument_list|,
name|INVERT_NEG_FLAG
argument_list|)
expr_stmt|;
block|}
else|else
name|pfr_destroy_kentries
argument_list|(
operator|&
name|addq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nadd
operator|!=
name|NULL
condition|)
operator|*
name|nadd
operator|=
name|xadd
expr_stmt|;
if|if
condition|(
name|ndel
operator|!=
name|NULL
condition|)
operator|*
name|ndel
operator|=
name|xdel
expr_stmt|;
if|if
condition|(
name|nchange
operator|!=
name|NULL
condition|)
operator|*
name|nchange
operator|=
name|xchange
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PFR_FLAG_FEEDBACK
operator|)
operator|&&
name|size2
condition|)
operator|*
name|size2
operator|=
name|size
operator|+
name|xdel
expr_stmt|;
name|pfr_destroy_ktable
argument_list|(
name|tmpkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|_bad
label|:
name|pfr_clean_node_mask
argument_list|(
name|tmpkt
argument_list|,
operator|&
name|addq
argument_list|)
expr_stmt|;
name|pfr_destroy_kentries
argument_list|(
operator|&
name|addq
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_FLAG_FEEDBACK
condition|)
name|pfr_reset_feedback
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pfr_destroy_ktable
argument_list|(
name|tmpkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_tst_addrs
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|struct
name|pfr_addr
modifier|*
name|addr
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|nmatch
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|kt
decl_stmt|;
name|struct
name|pfr_kentry
modifier|*
name|p
decl_stmt|;
name|struct
name|pfr_addr
modifier|*
name|ad
decl_stmt|;
name|int
name|i
decl_stmt|,
name|xmatch
init|=
literal|0
decl_stmt|;
name|PF_RULES_RASSERT
argument_list|()
expr_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_REPLACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_validate_table
argument_list|(
name|tbl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|kt
operator|=
name|pfr_lookup_table
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
operator|||
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ad
operator|=
name|addr
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|ad
operator|++
control|)
block|{
if|if
condition|(
name|pfr_validate_addr
argument_list|(
name|ad
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ADDR_NETWORK
argument_list|(
name|ad
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|p
operator|=
name|pfr_lookup_addr
argument_list|(
name|kt
argument_list|,
name|ad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_FLAG_REPLACE
condition|)
name|pfr_copyout_addr
argument_list|(
name|ad
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ad
operator|->
name|pfra_fback
operator|=
operator|(
name|p
operator|==
name|NULL
operator|)
condition|?
name|PFR_FB_NONE
else|:
operator|(
name|p
operator|->
name|pfrke_not
condition|?
name|PFR_FB_NOTMATCH
else|:
name|PFR_FB_MATCH
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|!
name|p
operator|->
name|pfrke_not
condition|)
name|xmatch
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nmatch
operator|!=
name|NULL
condition|)
operator|*
name|nmatch
operator|=
name|xmatch
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_get_addrs
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|struct
name|pfr_addr
modifier|*
name|addr
parameter_list|,
name|int
modifier|*
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|kt
decl_stmt|;
name|struct
name|pfr_walktree
name|w
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|PF_RULES_RASSERT
argument_list|()
expr_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_validate_table
argument_list|(
name|tbl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|kt
operator|=
name|pfr_lookup_table
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
operator|||
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
name|kt
operator|->
name|pfrkt_cnt
operator|>
operator|*
name|size
condition|)
block|{
operator|*
name|size
operator|=
name|kt
operator|->
name|pfrkt_cnt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|pfrw_op
operator|=
name|PFRW_GET_ADDRS
expr_stmt|;
name|w
operator|.
name|pfrw_addr
operator|=
name|addr
expr_stmt|;
name|w
operator|.
name|pfrw_free
operator|=
name|kt
operator|->
name|pfrkt_cnt
expr_stmt|;
name|rv
operator|=
name|kt
operator|->
name|pfrkt_ip4
operator|->
name|rnh_walktree
argument_list|(
name|kt
operator|->
name|pfrkt_ip4
argument_list|,
name|pfr_walktree
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
name|rv
operator|=
name|kt
operator|->
name|pfrkt_ip6
operator|->
name|rnh_walktree
argument_list|(
name|kt
operator|->
name|pfrkt_ip6
argument_list|,
name|pfr_walktree
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|KASSERT
argument_list|(
name|w
operator|.
name|pfrw_free
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: corruption detected (%d)"
operator|,
name|__func__
operator|,
name|w
operator|.
name|pfrw_free
operator|)
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|kt
operator|->
name|pfrkt_cnt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_get_astats
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|struct
name|pfr_astats
modifier|*
name|addr
parameter_list|,
name|int
modifier|*
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|kt
decl_stmt|;
name|struct
name|pfr_walktree
name|w
decl_stmt|;
name|struct
name|pfr_kentryworkq
name|workq
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|long
name|tzero
init|=
name|time_second
decl_stmt|;
name|PF_RULES_RASSERT
argument_list|()
expr_stmt|;
comment|/* XXX PFR_FLAG_CLSTATS disabled */
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_validate_table
argument_list|(
name|tbl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|kt
operator|=
name|pfr_lookup_table
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
operator|||
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
name|kt
operator|->
name|pfrkt_cnt
operator|>
operator|*
name|size
condition|)
block|{
operator|*
name|size
operator|=
name|kt
operator|->
name|pfrkt_cnt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|pfrw_op
operator|=
name|PFRW_GET_ASTATS
expr_stmt|;
name|w
operator|.
name|pfrw_astats
operator|=
name|addr
expr_stmt|;
name|w
operator|.
name|pfrw_free
operator|=
name|kt
operator|->
name|pfrkt_cnt
expr_stmt|;
name|rv
operator|=
name|kt
operator|->
name|pfrkt_ip4
operator|->
name|rnh_walktree
argument_list|(
name|kt
operator|->
name|pfrkt_ip4
argument_list|,
name|pfr_walktree
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
name|rv
operator|=
name|kt
operator|->
name|pfrkt_ip6
operator|->
name|rnh_walktree
argument_list|(
name|kt
operator|->
name|pfrkt_ip6
argument_list|,
name|pfr_walktree
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rv
operator|&&
operator|(
name|flags
operator|&
name|PFR_FLAG_CLSTATS
operator|)
condition|)
block|{
name|pfr_enqueue_addrs
argument_list|(
name|kt
argument_list|,
operator|&
name|workq
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfr_clstats_kentries
argument_list|(
operator|&
name|workq
argument_list|,
name|tzero
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rv
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
name|w
operator|.
name|pfrw_free
condition|)
block|{
name|printf
argument_list|(
literal|"pfr_get_astats: corruption detected (%d).\n"
argument_list|,
name|w
operator|.
name|pfrw_free
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
operator|*
name|size
operator|=
name|kt
operator|->
name|pfrkt_cnt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_clr_astats
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|struct
name|pfr_addr
modifier|*
name|addr
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|nzero
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|kt
decl_stmt|;
name|struct
name|pfr_kentryworkq
name|workq
decl_stmt|;
name|struct
name|pfr_kentry
modifier|*
name|p
decl_stmt|;
name|struct
name|pfr_addr
modifier|*
name|ad
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|,
name|xzero
init|=
literal|0
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_DUMMY
operator||
name|PFR_FLAG_FEEDBACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_validate_table
argument_list|(
name|tbl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|kt
operator|=
name|pfr_lookup_table
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
operator|||
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|SLIST_INIT
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ad
operator|=
name|addr
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|ad
operator|++
control|)
block|{
if|if
condition|(
name|pfr_validate_addr
argument_list|(
name|ad
argument_list|)
condition|)
name|senderr
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|p
operator|=
name|pfr_lookup_addr
argument_list|(
name|kt
argument_list|,
name|ad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_FLAG_FEEDBACK
condition|)
block|{
name|ad
operator|->
name|pfra_fback
operator|=
operator|(
name|p
operator|!=
name|NULL
operator|)
condition|?
name|PFR_FB_CLEARED
else|:
name|PFR_FB_NONE
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|workq
argument_list|,
name|p
argument_list|,
name|pfrke_workq
argument_list|)
expr_stmt|;
name|xzero
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_FLAG_DUMMY
operator|)
condition|)
name|pfr_clstats_kentries
argument_list|(
operator|&
name|workq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nzero
operator|!=
name|NULL
condition|)
operator|*
name|nzero
operator|=
name|xzero
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|_bad
label|:
if|if
condition|(
name|flags
operator|&
name|PFR_FLAG_FEEDBACK
condition|)
name|pfr_reset_feedback
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pfr_validate_addr
parameter_list|(
name|struct
name|pfr_addr
modifier|*
name|ad
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|ad
operator|->
name|pfra_af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|ad
operator|->
name|pfra_net
operator|>
literal|32
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|ad
operator|->
name|pfra_net
operator|>
literal|128
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ad
operator|->
name|pfra_net
operator|<
literal|128
operator|&&
operator|(
operator|(
operator|(
name|caddr_t
operator|)
name|ad
operator|)
index|[
name|ad
operator|->
name|pfra_net
operator|/
literal|8
index|]
operator|&
operator|(
literal|0xFF
operator|>>
operator|(
name|ad
operator|->
name|pfra_net
operator|%
literal|8
operator|)
operator|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
operator|(
name|ad
operator|->
name|pfra_net
operator|+
literal|7
operator|)
operator|/
literal|8
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ad
operator|->
name|pfra_u
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|caddr_t
operator|)
name|ad
operator|)
index|[
name|i
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ad
operator|->
name|pfra_not
operator|&&
name|ad
operator|->
name|pfra_not
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ad
operator|->
name|pfra_fback
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_enqueue_addrs
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|struct
name|pfr_kentryworkq
modifier|*
name|workq
parameter_list|,
name|int
modifier|*
name|naddr
parameter_list|,
name|int
name|sweep
parameter_list|)
block|{
name|struct
name|pfr_walktree
name|w
decl_stmt|;
name|SLIST_INIT
argument_list|(
name|workq
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|pfrw_op
operator|=
name|sweep
condition|?
name|PFRW_SWEEP
else|:
name|PFRW_ENQUEUE
expr_stmt|;
name|w
operator|.
name|pfrw_workq
operator|=
name|workq
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|pfrkt_ip4
operator|!=
name|NULL
condition|)
if|if
condition|(
name|kt
operator|->
name|pfrkt_ip4
operator|->
name|rnh_walktree
argument_list|(
name|kt
operator|->
name|pfrkt_ip4
argument_list|,
name|pfr_walktree
argument_list|,
operator|&
name|w
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pfr_enqueue_addrs: IPv4 walktree failed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|pfrkt_ip6
operator|!=
name|NULL
condition|)
if|if
condition|(
name|kt
operator|->
name|pfrkt_ip6
operator|->
name|rnh_walktree
argument_list|(
name|kt
operator|->
name|pfrkt_ip6
argument_list|,
name|pfr_walktree
argument_list|,
operator|&
name|w
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pfr_enqueue_addrs: IPv6 walktree failed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|naddr
operator|!=
name|NULL
condition|)
operator|*
name|naddr
operator|=
name|w
operator|.
name|pfrw_cnt
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_mark_addrs
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|)
block|{
name|struct
name|pfr_walktree
name|w
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|pfrw_op
operator|=
name|PFRW_MARK
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|pfrkt_ip4
operator|->
name|rnh_walktree
argument_list|(
name|kt
operator|->
name|pfrkt_ip4
argument_list|,
name|pfr_walktree
argument_list|,
operator|&
name|w
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pfr_mark_addrs: IPv4 walktree failed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|pfrkt_ip6
operator|->
name|rnh_walktree
argument_list|(
name|kt
operator|->
name|pfrkt_ip6
argument_list|,
name|pfr_walktree
argument_list|,
operator|&
name|w
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pfr_mark_addrs: IPv6 walktree failed.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pfr_kentry
modifier|*
name|pfr_lookup_addr
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|struct
name|pfr_addr
modifier|*
name|ad
parameter_list|,
name|int
name|exact
parameter_list|)
block|{
name|union
name|sockaddr_union
name|sa
decl_stmt|,
name|mask
decl_stmt|;
name|struct
name|radix_node_head
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
name|struct
name|pfr_kentry
modifier|*
name|ke
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|->
name|pfra_af
operator|==
name|AF_INET
condition|)
block|{
name|FILLIN_SIN
argument_list|(
name|sa
operator|.
name|sin
argument_list|,
name|ad
operator|->
name|pfra_ip4addr
argument_list|)
expr_stmt|;
name|head
operator|=
name|kt
operator|->
name|pfrkt_ip4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ad
operator|->
name|pfra_af
operator|==
name|AF_INET6
condition|)
block|{
name|FILLIN_SIN6
argument_list|(
name|sa
operator|.
name|sin6
argument_list|,
name|ad
operator|->
name|pfra_ip6addr
argument_list|)
expr_stmt|;
name|head
operator|=
name|kt
operator|->
name|pfrkt_ip6
expr_stmt|;
block|}
if|if
condition|(
name|ADDR_NETWORK
argument_list|(
name|ad
argument_list|)
condition|)
block|{
name|pfr_prepare_network
argument_list|(
operator|&
name|mask
argument_list|,
name|ad
operator|->
name|pfra_af
argument_list|,
name|ad
operator|->
name|pfra_net
argument_list|)
expr_stmt|;
name|ke
operator|=
operator|(
expr|struct
name|pfr_kentry
operator|*
operator|)
name|rn_lookup
argument_list|(
operator|&
name|sa
argument_list|,
operator|&
name|mask
argument_list|,
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|&&
name|KENTRY_RNF_ROOT
argument_list|(
name|ke
argument_list|)
condition|)
name|ke
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ke
operator|=
operator|(
expr|struct
name|pfr_kentry
operator|*
operator|)
name|rn_match
argument_list|(
operator|&
name|sa
argument_list|,
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|&&
name|KENTRY_RNF_ROOT
argument_list|(
name|ke
argument_list|)
condition|)
name|ke
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|exact
operator|&&
name|ke
operator|&&
name|KENTRY_NETWORK
argument_list|(
name|ke
argument_list|)
condition|)
name|ke
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ke
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pfr_kentry
modifier|*
name|pfr_create_kentry
parameter_list|(
name|struct
name|pfr_addr
modifier|*
name|ad
parameter_list|)
block|{
name|struct
name|pfr_kentry
modifier|*
name|ke
decl_stmt|;
name|ke
operator|=
name|uma_zalloc
argument_list|(
name|V_pfr_kentry_z
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ad
operator|->
name|pfra_af
operator|==
name|AF_INET
condition|)
name|FILLIN_SIN
argument_list|(
name|ke
operator|->
name|pfrke_sa
operator|.
name|sin
argument_list|,
name|ad
operator|->
name|pfra_ip4addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ad
operator|->
name|pfra_af
operator|==
name|AF_INET6
condition|)
name|FILLIN_SIN6
argument_list|(
name|ke
operator|->
name|pfrke_sa
operator|.
name|sin6
argument_list|,
name|ad
operator|->
name|pfra_ip6addr
argument_list|)
expr_stmt|;
name|ke
operator|->
name|pfrke_af
operator|=
name|ad
operator|->
name|pfra_af
expr_stmt|;
name|ke
operator|->
name|pfrke_net
operator|=
name|ad
operator|->
name|pfra_net
expr_stmt|;
name|ke
operator|->
name|pfrke_not
operator|=
name|ad
operator|->
name|pfra_not
expr_stmt|;
return|return
operator|(
name|ke
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_destroy_kentries
parameter_list|(
name|struct
name|pfr_kentryworkq
modifier|*
name|workq
parameter_list|)
block|{
name|struct
name|pfr_kentry
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|SLIST_FIRST
argument_list|(
name|workq
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|q
control|)
block|{
name|q
operator|=
name|SLIST_NEXT
argument_list|(
name|p
argument_list|,
name|pfrke_workq
argument_list|)
expr_stmt|;
name|pfr_destroy_kentry
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_destroy_kentry
parameter_list|(
name|struct
name|pfr_kentry
modifier|*
name|ke
parameter_list|)
block|{
if|if
condition|(
name|ke
operator|->
name|pfrke_counters
condition|)
name|uma_zfree
argument_list|(
name|V_pfr_kcounters_z
argument_list|,
name|ke
operator|->
name|pfrke_counters
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_pfr_kentry_z
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_insert_kentries
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|struct
name|pfr_kentryworkq
modifier|*
name|workq
parameter_list|,
name|long
name|tzero
parameter_list|)
block|{
name|struct
name|pfr_kentry
modifier|*
name|p
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|p
argument_list|,
argument|workq
argument_list|,
argument|pfrke_workq
argument_list|)
block|{
name|rv
operator|=
name|pfr_route_kentry
argument_list|(
name|kt
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|printf
argument_list|(
literal|"pfr_insert_kentries: cannot route entry "
literal|"(code=%d).\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|pfrke_tzero
operator|=
name|tzero
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|kt
operator|->
name|pfrkt_cnt
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pfr_insert_kentry
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|struct
name|pfr_addr
modifier|*
name|ad
parameter_list|,
name|long
name|tzero
parameter_list|)
block|{
name|struct
name|pfr_kentry
modifier|*
name|p
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|p
operator|=
name|pfr_lookup_addr
argument_list|(
name|kt
argument_list|,
name|ad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|pfr_create_kentry
argument_list|(
name|ad
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rv
operator|=
name|pfr_route_kentry
argument_list|(
name|kt
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|p
operator|->
name|pfrke_tzero
operator|=
name|tzero
expr_stmt|;
name|kt
operator|->
name|pfrkt_cnt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_remove_kentries
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|struct
name|pfr_kentryworkq
modifier|*
name|workq
parameter_list|)
block|{
name|struct
name|pfr_kentry
modifier|*
name|p
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|p
argument_list|,
argument|workq
argument_list|,
argument|pfrke_workq
argument_list|)
block|{
name|pfr_unroute_kentry
argument_list|(
name|kt
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|kt
operator|->
name|pfrkt_cnt
operator|-=
name|n
expr_stmt|;
name|pfr_destroy_kentries
argument_list|(
name|workq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_clean_node_mask
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|struct
name|pfr_kentryworkq
modifier|*
name|workq
parameter_list|)
block|{
name|struct
name|pfr_kentry
modifier|*
name|p
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|p
argument_list|,
argument|workq
argument_list|,
argument|pfrke_workq
argument_list|)
name|pfr_unroute_kentry
argument_list|(
name|kt
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_clstats_kentries
parameter_list|(
name|struct
name|pfr_kentryworkq
modifier|*
name|workq
parameter_list|,
name|long
name|tzero
parameter_list|,
name|int
name|negchange
parameter_list|)
block|{
name|struct
name|pfr_kentry
modifier|*
name|p
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|p
argument_list|,
argument|workq
argument_list|,
argument|pfrke_workq
argument_list|)
block|{
if|if
condition|(
name|negchange
condition|)
name|p
operator|->
name|pfrke_not
operator|=
operator|!
name|p
operator|->
name|pfrke_not
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pfrke_counters
condition|)
block|{
name|uma_zfree
argument_list|(
name|V_pfr_kcounters_z
argument_list|,
name|p
operator|->
name|pfrke_counters
argument_list|)
expr_stmt|;
name|p
operator|->
name|pfrke_counters
operator|=
name|NULL
expr_stmt|;
block|}
name|p
operator|->
name|pfrke_tzero
operator|=
name|tzero
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_reset_feedback
parameter_list|(
name|struct
name|pfr_addr
modifier|*
name|addr
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|pfr_addr
modifier|*
name|ad
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ad
operator|=
name|addr
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|ad
operator|++
control|)
name|ad
operator|->
name|pfra_fback
operator|=
name|PFR_FB_NONE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_prepare_network
parameter_list|(
name|union
name|sockaddr_union
modifier|*
name|sa
parameter_list|,
name|int
name|af
parameter_list|,
name|int
name|net
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|af
operator|==
name|AF_INET
condition|)
block|{
name|sa
operator|->
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|sin
argument_list|)
expr_stmt|;
name|sa
operator|->
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sa
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|net
condition|?
name|htonl
argument_list|(
operator|-
literal|1
operator|<<
operator|(
literal|32
operator|-
name|net
operator|)
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|sa
operator|->
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|sin6
argument_list|)
expr_stmt|;
name|sa
operator|->
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|net
operator|<=
literal|32
condition|)
block|{
name|sa
operator|->
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr32
index|[
name|i
index|]
operator|=
name|net
condition|?
name|htonl
argument_list|(
operator|-
literal|1
operator|<<
operator|(
literal|32
operator|-
name|net
operator|)
argument_list|)
else|:
literal|0
expr_stmt|;
break|break;
block|}
name|sa
operator|->
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr32
index|[
name|i
index|]
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|net
operator|-=
literal|32
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pfr_route_kentry
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|struct
name|pfr_kentry
modifier|*
name|ke
parameter_list|)
block|{
name|union
name|sockaddr_union
name|mask
decl_stmt|;
name|struct
name|radix_node
modifier|*
name|rn
decl_stmt|;
name|struct
name|radix_node_head
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
name|bzero
argument_list|(
name|ke
operator|->
name|pfrke_node
argument_list|,
sizeof|sizeof
argument_list|(
name|ke
operator|->
name|pfrke_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|pfrke_af
operator|==
name|AF_INET
condition|)
name|head
operator|=
name|kt
operator|->
name|pfrkt_ip4
expr_stmt|;
elseif|else
if|if
condition|(
name|ke
operator|->
name|pfrke_af
operator|==
name|AF_INET6
condition|)
name|head
operator|=
name|kt
operator|->
name|pfrkt_ip6
expr_stmt|;
if|if
condition|(
name|KENTRY_NETWORK
argument_list|(
name|ke
argument_list|)
condition|)
block|{
name|pfr_prepare_network
argument_list|(
operator|&
name|mask
argument_list|,
name|ke
operator|->
name|pfrke_af
argument_list|,
name|ke
operator|->
name|pfrke_net
argument_list|)
expr_stmt|;
name|rn
operator|=
name|rn_addroute
argument_list|(
operator|&
name|ke
operator|->
name|pfrke_sa
argument_list|,
operator|&
name|mask
argument_list|,
name|head
argument_list|,
name|ke
operator|->
name|pfrke_node
argument_list|)
expr_stmt|;
block|}
else|else
name|rn
operator|=
name|rn_addroute
argument_list|(
operator|&
name|ke
operator|->
name|pfrke_sa
argument_list|,
name|NULL
argument_list|,
name|head
argument_list|,
name|ke
operator|->
name|pfrke_node
argument_list|)
expr_stmt|;
return|return
operator|(
name|rn
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pfr_unroute_kentry
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|struct
name|pfr_kentry
modifier|*
name|ke
parameter_list|)
block|{
name|union
name|sockaddr_union
name|mask
decl_stmt|;
name|struct
name|radix_node
modifier|*
name|rn
decl_stmt|;
name|struct
name|radix_node_head
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ke
operator|->
name|pfrke_af
operator|==
name|AF_INET
condition|)
name|head
operator|=
name|kt
operator|->
name|pfrkt_ip4
expr_stmt|;
elseif|else
if|if
condition|(
name|ke
operator|->
name|pfrke_af
operator|==
name|AF_INET6
condition|)
name|head
operator|=
name|kt
operator|->
name|pfrkt_ip6
expr_stmt|;
if|if
condition|(
name|KENTRY_NETWORK
argument_list|(
name|ke
argument_list|)
condition|)
block|{
name|pfr_prepare_network
argument_list|(
operator|&
name|mask
argument_list|,
name|ke
operator|->
name|pfrke_af
argument_list|,
name|ke
operator|->
name|pfrke_net
argument_list|)
expr_stmt|;
name|rn
operator|=
name|rn_delete
argument_list|(
operator|&
name|ke
operator|->
name|pfrke_sa
argument_list|,
operator|&
name|mask
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
else|else
name|rn
operator|=
name|rn_delete
argument_list|(
operator|&
name|ke
operator|->
name|pfrke_sa
argument_list|,
name|NULL
argument_list|,
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|rn
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"pfr_unroute_kentry: delete failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_copyout_addr
parameter_list|(
name|struct
name|pfr_addr
modifier|*
name|ad
parameter_list|,
name|struct
name|pfr_kentry
modifier|*
name|ke
parameter_list|)
block|{
name|bzero
argument_list|(
name|ad
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ad
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|==
name|NULL
condition|)
return|return;
name|ad
operator|->
name|pfra_af
operator|=
name|ke
operator|->
name|pfrke_af
expr_stmt|;
name|ad
operator|->
name|pfra_net
operator|=
name|ke
operator|->
name|pfrke_net
expr_stmt|;
name|ad
operator|->
name|pfra_not
operator|=
name|ke
operator|->
name|pfrke_not
expr_stmt|;
if|if
condition|(
name|ad
operator|->
name|pfra_af
operator|==
name|AF_INET
condition|)
name|ad
operator|->
name|pfra_ip4addr
operator|=
name|ke
operator|->
name|pfrke_sa
operator|.
name|sin
operator|.
name|sin_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|ad
operator|->
name|pfra_af
operator|==
name|AF_INET6
condition|)
name|ad
operator|->
name|pfra_ip6addr
operator|=
name|ke
operator|->
name|pfrke_sa
operator|.
name|sin6
operator|.
name|sin6_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pfr_walktree
parameter_list|(
name|struct
name|radix_node
modifier|*
name|rn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pfr_kentry
modifier|*
name|ke
init|=
operator|(
expr|struct
name|pfr_kentry
operator|*
operator|)
name|rn
decl_stmt|;
name|struct
name|pfr_walktree
modifier|*
name|w
init|=
name|arg
decl_stmt|;
switch|switch
condition|(
name|w
operator|->
name|pfrw_op
condition|)
block|{
case|case
name|PFRW_MARK
case|:
name|ke
operator|->
name|pfrke_mark
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PFRW_SWEEP
case|:
if|if
condition|(
name|ke
operator|->
name|pfrke_mark
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|PFRW_ENQUEUE
case|:
name|SLIST_INSERT_HEAD
argument_list|(
name|w
operator|->
name|pfrw_workq
argument_list|,
name|ke
argument_list|,
name|pfrke_workq
argument_list|)
expr_stmt|;
name|w
operator|->
name|pfrw_cnt
operator|++
expr_stmt|;
break|break;
case|case
name|PFRW_GET_ADDRS
case|:
if|if
condition|(
name|w
operator|->
name|pfrw_free
operator|--
operator|>
literal|0
condition|)
block|{
name|pfr_copyout_addr
argument_list|(
name|w
operator|->
name|pfrw_addr
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|w
operator|->
name|pfrw_addr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|PFRW_GET_ASTATS
case|:
if|if
condition|(
name|w
operator|->
name|pfrw_free
operator|--
operator|>
literal|0
condition|)
block|{
name|struct
name|pfr_astats
name|as
decl_stmt|;
name|pfr_copyout_addr
argument_list|(
operator|&
name|as
operator|.
name|pfras_a
argument_list|,
name|ke
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|pfrke_counters
condition|)
block|{
name|bcopy
argument_list|(
name|ke
operator|->
name|pfrke_counters
operator|->
name|pfrkc_packets
argument_list|,
name|as
operator|.
name|pfras_packets
argument_list|,
sizeof|sizeof
argument_list|(
name|as
operator|.
name|pfras_packets
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ke
operator|->
name|pfrke_counters
operator|->
name|pfrkc_bytes
argument_list|,
name|as
operator|.
name|pfras_bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|as
operator|.
name|pfras_bytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|as
operator|.
name|pfras_packets
argument_list|,
sizeof|sizeof
argument_list|(
name|as
operator|.
name|pfras_packets
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|as
operator|.
name|pfras_bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|as
operator|.
name|pfras_bytes
argument_list|)
argument_list|)
expr_stmt|;
name|as
operator|.
name|pfras_a
operator|.
name|pfra_fback
operator|=
name|PFR_FB_NOCOUNT
expr_stmt|;
block|}
name|as
operator|.
name|pfras_tzero
operator|=
name|ke
operator|->
name|pfrke_tzero
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|as
argument_list|,
name|w
operator|->
name|pfrw_astats
argument_list|,
sizeof|sizeof
argument_list|(
name|as
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|pfrw_astats
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|PFRW_POOL_GET
case|:
if|if
condition|(
name|ke
operator|->
name|pfrke_not
condition|)
break|break;
comment|/* negative entries are ignored */
if|if
condition|(
operator|!
name|w
operator|->
name|pfrw_cnt
operator|--
condition|)
block|{
name|w
operator|->
name|pfrw_kentry
operator|=
name|ke
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* finish search */
block|}
break|break;
case|case
name|PFRW_DYNADDR_UPDATE
case|:
block|{
name|union
name|sockaddr_union
name|pfr_mask
decl_stmt|;
if|if
condition|(
name|ke
operator|->
name|pfrke_af
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|pfrw_dyn
operator|->
name|pfid_acnt4
operator|++
operator|>
literal|0
condition|)
break|break;
name|pfr_prepare_network
argument_list|(
operator|&
name|pfr_mask
argument_list|,
name|AF_INET
argument_list|,
name|ke
operator|->
name|pfrke_net
argument_list|)
expr_stmt|;
name|w
operator|->
name|pfrw_dyn
operator|->
name|pfid_addr4
operator|=
operator|*
name|SUNION2PF
argument_list|(
operator|&
name|ke
operator|->
name|pfrke_sa
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
name|w
operator|->
name|pfrw_dyn
operator|->
name|pfid_mask4
operator|=
operator|*
name|SUNION2PF
argument_list|(
operator|&
name|pfr_mask
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ke
operator|->
name|pfrke_af
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|pfrw_dyn
operator|->
name|pfid_acnt6
operator|++
operator|>
literal|0
condition|)
break|break;
name|pfr_prepare_network
argument_list|(
operator|&
name|pfr_mask
argument_list|,
name|AF_INET6
argument_list|,
name|ke
operator|->
name|pfrke_net
argument_list|)
expr_stmt|;
name|w
operator|->
name|pfrw_dyn
operator|->
name|pfid_addr6
operator|=
operator|*
name|SUNION2PF
argument_list|(
operator|&
name|ke
operator|->
name|pfrke_sa
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
name|w
operator|->
name|pfrw_dyn
operator|->
name|pfid_mask6
operator|=
operator|*
name|SUNION2PF
argument_list|(
operator|&
name|pfr_mask
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_clr_tables
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|filter
parameter_list|,
name|int
modifier|*
name|ndel
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktableworkq
name|workq
decl_stmt|;
name|struct
name|pfr_ktable
modifier|*
name|p
decl_stmt|;
name|int
name|xdel
init|=
literal|0
decl_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_DUMMY
operator||
name|PFR_FLAG_ALLRSETS
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_fix_anchor
argument_list|(
name|filter
operator|->
name|pfrt_anchor
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|pfr_table_count
argument_list|(
name|filter
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|SLIST_INIT
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|p
argument_list|,
argument|pfr_ktablehead
argument_list|,
argument|&pfr_ktables
argument_list|)
block|{
if|if
condition|(
name|pfr_skip_table
argument_list|(
name|filter
argument_list|,
name|p
argument_list|,
name|flags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|pfrkt_anchor
argument_list|,
name|PF_RESERVED_ANCHOR
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
continue|continue;
name|p
operator|->
name|pfrkt_nflags
operator|=
name|p
operator|->
name|pfrkt_flags
operator|&
operator|~
name|PFR_TFLAG_ACTIVE
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|workq
argument_list|,
name|p
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
name|xdel
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_FLAG_DUMMY
operator|)
condition|)
name|pfr_setflags_ktables
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndel
operator|!=
name|NULL
condition|)
operator|*
name|ndel
operator|=
name|xdel
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_add_tables
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|nadd
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktableworkq
name|addq
decl_stmt|,
name|changeq
decl_stmt|;
name|struct
name|pfr_ktable
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|,
name|key
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|,
name|xadd
init|=
literal|0
decl_stmt|;
name|long
name|tzero
init|=
name|time_second
decl_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_DUMMY
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|addq
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|changeq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|bcopy
argument_list|(
name|tbl
operator|+
name|i
argument_list|,
operator|&
name|key
operator|.
name|pfrkt_t
argument_list|,
sizeof|sizeof
argument_list|(
name|key
operator|.
name|pfrkt_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_validate_table
argument_list|(
operator|&
name|key
operator|.
name|pfrkt_t
argument_list|,
name|PFR_TFLAG_USRMASK
argument_list|,
name|flags
operator|&
name|PFR_FLAG_USERIOCTL
argument_list|)
condition|)
name|senderr
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|key
operator|.
name|pfrkt_flags
operator||=
name|PFR_TFLAG_ACTIVE
expr_stmt|;
name|p
operator|=
name|RB_FIND
argument_list|(
name|pfr_ktablehead
argument_list|,
operator|&
name|pfr_ktables
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|pfr_create_ktable
argument_list|(
operator|&
name|key
operator|.
name|pfrkt_t
argument_list|,
name|tzero
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|q
argument_list|,
argument|&addq
argument_list|,
argument|pfrkt_workq
argument_list|)
block|{
if|if
condition|(
operator|!
name|pfr_ktable_compare
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
condition|)
goto|goto
name|_skip
goto|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|addq
argument_list|,
name|p
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
name|xadd
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|key
operator|.
name|pfrkt_anchor
index|[
literal|0
index|]
condition|)
goto|goto
name|_skip
goto|;
comment|/* find or create root table */
name|bzero
argument_list|(
name|key
operator|.
name|pfrkt_anchor
argument_list|,
sizeof|sizeof
argument_list|(
name|key
operator|.
name|pfrkt_anchor
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|RB_FIND
argument_list|(
name|pfr_ktablehead
argument_list|,
operator|&
name|pfr_ktables
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|pfrkt_root
operator|=
name|r
expr_stmt|;
goto|goto
name|_skip
goto|;
block|}
name|SLIST_FOREACH
argument_list|(
argument|q
argument_list|,
argument|&addq
argument_list|,
argument|pfrkt_workq
argument_list|)
block|{
if|if
condition|(
operator|!
name|pfr_ktable_compare
argument_list|(
operator|&
name|key
argument_list|,
name|q
argument_list|)
condition|)
block|{
name|p
operator|->
name|pfrkt_root
operator|=
name|q
expr_stmt|;
goto|goto
name|_skip
goto|;
block|}
block|}
name|key
operator|.
name|pfrkt_flags
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|pfr_create_ktable
argument_list|(
operator|&
name|key
operator|.
name|pfrkt_t
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|addq
argument_list|,
name|r
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
name|p
operator|->
name|pfrkt_root
operator|=
name|r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|q
argument_list|,
argument|&changeq
argument_list|,
argument|pfrkt_workq
argument_list|)
if|if
condition|(
operator|!
name|pfr_ktable_compare
argument_list|(
operator|&
name|key
argument_list|,
name|q
argument_list|)
condition|)
goto|goto
name|_skip
goto|;
name|p
operator|->
name|pfrkt_nflags
operator|=
operator|(
name|p
operator|->
name|pfrkt_flags
operator|&
operator|~
name|PFR_TFLAG_USRMASK
operator|)
operator||
name|key
operator|.
name|pfrkt_flags
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|changeq
argument_list|,
name|p
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
name|xadd
operator|++
expr_stmt|;
block|}
name|_skip
label|:
empty_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_FLAG_DUMMY
operator|)
condition|)
block|{
name|pfr_insert_ktables
argument_list|(
operator|&
name|addq
argument_list|)
expr_stmt|;
name|pfr_setflags_ktables
argument_list|(
operator|&
name|changeq
argument_list|)
expr_stmt|;
block|}
else|else
name|pfr_destroy_ktables
argument_list|(
operator|&
name|addq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nadd
operator|!=
name|NULL
condition|)
operator|*
name|nadd
operator|=
name|xadd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|_bad
label|:
name|pfr_destroy_ktables
argument_list|(
operator|&
name|addq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_del_tables
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|ndel
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktableworkq
name|workq
decl_stmt|;
name|struct
name|pfr_ktable
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
name|key
decl_stmt|;
name|int
name|i
decl_stmt|,
name|xdel
init|=
literal|0
decl_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_DUMMY
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|bcopy
argument_list|(
name|tbl
operator|+
name|i
argument_list|,
operator|&
name|key
operator|.
name|pfrkt_t
argument_list|,
sizeof|sizeof
argument_list|(
name|key
operator|.
name|pfrkt_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_validate_table
argument_list|(
operator|&
name|key
operator|.
name|pfrkt_t
argument_list|,
literal|0
argument_list|,
name|flags
operator|&
name|PFR_FLAG_USERIOCTL
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|p
operator|=
name|RB_FIND
argument_list|(
name|pfr_ktablehead
argument_list|,
operator|&
name|pfr_ktables
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|q
argument_list|,
argument|&workq
argument_list|,
argument|pfrkt_workq
argument_list|)
if|if
condition|(
operator|!
name|pfr_ktable_compare
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
condition|)
goto|goto
name|_skip
goto|;
name|p
operator|->
name|pfrkt_nflags
operator|=
name|p
operator|->
name|pfrkt_flags
operator|&
operator|~
name|PFR_TFLAG_ACTIVE
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|workq
argument_list|,
name|p
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
name|xdel
operator|++
expr_stmt|;
block|}
name|_skip
label|:
empty_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_FLAG_DUMMY
operator|)
condition|)
name|pfr_setflags_ktables
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndel
operator|!=
name|NULL
condition|)
operator|*
name|ndel
operator|=
name|xdel
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_get_tables
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|filter
parameter_list|,
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|int
modifier|*
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|,
name|nn
decl_stmt|;
name|PF_RULES_RASSERT
argument_list|()
expr_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_ALLRSETS
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_fix_anchor
argument_list|(
name|filter
operator|->
name|pfrt_anchor
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|n
operator|=
name|nn
operator|=
name|pfr_table_count
argument_list|(
name|filter
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|n
operator|>
operator|*
name|size
condition|)
block|{
operator|*
name|size
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|RB_FOREACH
argument_list|(
argument|p
argument_list|,
argument|pfr_ktablehead
argument_list|,
argument|&pfr_ktables
argument_list|)
block|{
if|if
condition|(
name|pfr_skip_table
argument_list|(
name|filter
argument_list|,
name|p
argument_list|,
name|flags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|n
operator|--
operator|<=
literal|0
condition|)
continue|continue;
name|bcopy
argument_list|(
operator|&
name|p
operator|->
name|pfrkt_t
argument_list|,
name|tbl
operator|++
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tbl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|n
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: corruption detected (%d)"
operator|,
name|__func__
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|nn
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_get_tstats
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|filter
parameter_list|,
name|struct
name|pfr_tstats
modifier|*
name|tbl
parameter_list|,
name|int
modifier|*
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|p
decl_stmt|;
name|struct
name|pfr_ktableworkq
name|workq
decl_stmt|;
name|int
name|n
decl_stmt|,
name|nn
decl_stmt|;
name|long
name|tzero
init|=
name|time_second
decl_stmt|;
comment|/* XXX PFR_FLAG_CLSTATS disabled */
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_ALLRSETS
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_fix_anchor
argument_list|(
name|filter
operator|->
name|pfrt_anchor
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|n
operator|=
name|nn
operator|=
name|pfr_table_count
argument_list|(
name|filter
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|n
operator|>
operator|*
name|size
condition|)
block|{
operator|*
name|size
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SLIST_INIT
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|p
argument_list|,
argument|pfr_ktablehead
argument_list|,
argument|&pfr_ktables
argument_list|)
block|{
if|if
condition|(
name|pfr_skip_table
argument_list|(
name|filter
argument_list|,
name|p
argument_list|,
name|flags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|n
operator|--
operator|<=
literal|0
condition|)
continue|continue;
name|bcopy
argument_list|(
operator|&
name|p
operator|->
name|pfrkt_ts
argument_list|,
name|tbl
operator|++
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tbl
argument_list|)
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|workq
argument_list|,
name|p
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|PFR_FLAG_CLSTATS
condition|)
name|pfr_clstats_ktables
argument_list|(
operator|&
name|workq
argument_list|,
name|tzero
argument_list|,
name|flags
operator|&
name|PFR_FLAG_ADDRSTOO
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|n
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: corruption detected (%d)"
operator|,
name|__func__
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|nn
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_clr_tstats
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|nzero
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktableworkq
name|workq
decl_stmt|;
name|struct
name|pfr_ktable
modifier|*
name|p
decl_stmt|,
name|key
decl_stmt|;
name|int
name|i
decl_stmt|,
name|xzero
init|=
literal|0
decl_stmt|;
name|long
name|tzero
init|=
name|time_second
decl_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_DUMMY
operator||
name|PFR_FLAG_ADDRSTOO
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|bcopy
argument_list|(
name|tbl
operator|+
name|i
argument_list|,
operator|&
name|key
operator|.
name|pfrkt_t
argument_list|,
sizeof|sizeof
argument_list|(
name|key
operator|.
name|pfrkt_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_validate_table
argument_list|(
operator|&
name|key
operator|.
name|pfrkt_t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|p
operator|=
name|RB_FIND
argument_list|(
name|pfr_ktablehead
argument_list|,
operator|&
name|pfr_ktables
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|workq
argument_list|,
name|p
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
name|xzero
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_FLAG_DUMMY
operator|)
condition|)
name|pfr_clstats_ktables
argument_list|(
operator|&
name|workq
argument_list|,
name|tzero
argument_list|,
name|flags
operator|&
name|PFR_FLAG_ADDRSTOO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nzero
operator|!=
name|NULL
condition|)
operator|*
name|nzero
operator|=
name|xzero
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_set_tflags
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|setflag
parameter_list|,
name|int
name|clrflag
parameter_list|,
name|int
modifier|*
name|nchange
parameter_list|,
name|int
modifier|*
name|ndel
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktableworkq
name|workq
decl_stmt|;
name|struct
name|pfr_ktable
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
name|key
decl_stmt|;
name|int
name|i
decl_stmt|,
name|xchange
init|=
literal|0
decl_stmt|,
name|xdel
init|=
literal|0
decl_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_DUMMY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|setflag
operator|&
operator|~
name|PFR_TFLAG_USRMASK
operator|)
operator|||
operator|(
name|clrflag
operator|&
operator|~
name|PFR_TFLAG_USRMASK
operator|)
operator|||
operator|(
name|setflag
operator|&
name|clrflag
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|SLIST_INIT
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|bcopy
argument_list|(
name|tbl
operator|+
name|i
argument_list|,
operator|&
name|key
operator|.
name|pfrkt_t
argument_list|,
sizeof|sizeof
argument_list|(
name|key
operator|.
name|pfrkt_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_validate_table
argument_list|(
operator|&
name|key
operator|.
name|pfrkt_t
argument_list|,
literal|0
argument_list|,
name|flags
operator|&
name|PFR_FLAG_USERIOCTL
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|p
operator|=
name|RB_FIND
argument_list|(
name|pfr_ktablehead
argument_list|,
operator|&
name|pfr_ktables
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
block|{
name|p
operator|->
name|pfrkt_nflags
operator|=
operator|(
name|p
operator|->
name|pfrkt_flags
operator||
name|setflag
operator|)
operator|&
operator|~
name|clrflag
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pfrkt_nflags
operator|==
name|p
operator|->
name|pfrkt_flags
condition|)
goto|goto
name|_skip
goto|;
name|SLIST_FOREACH
argument_list|(
argument|q
argument_list|,
argument|&workq
argument_list|,
argument|pfrkt_workq
argument_list|)
if|if
condition|(
operator|!
name|pfr_ktable_compare
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
condition|)
goto|goto
name|_skip
goto|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|workq
argument_list|,
name|p
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_PERSIST
operator|)
operator|&&
operator|(
name|clrflag
operator|&
name|PFR_TFLAG_PERSIST
operator|)
operator|&&
operator|!
operator|(
name|p
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_REFERENCED
operator|)
condition|)
name|xdel
operator|++
expr_stmt|;
else|else
name|xchange
operator|++
expr_stmt|;
block|}
name|_skip
label|:
empty_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_FLAG_DUMMY
operator|)
condition|)
name|pfr_setflags_ktables
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchange
operator|!=
name|NULL
condition|)
operator|*
name|nchange
operator|=
name|xchange
expr_stmt|;
if|if
condition|(
name|ndel
operator|!=
name|NULL
condition|)
operator|*
name|ndel
operator|=
name|xdel
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_ina_begin
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|trs
parameter_list|,
name|u_int32_t
modifier|*
name|ticket
parameter_list|,
name|int
modifier|*
name|ndel
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktableworkq
name|workq
decl_stmt|;
name|struct
name|pfr_ktable
modifier|*
name|p
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|int
name|xdel
init|=
literal|0
decl_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_DUMMY
argument_list|)
expr_stmt|;
name|rs
operator|=
name|pf_find_or_create_ruleset
argument_list|(
name|trs
operator|->
name|pfrt_anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|SLIST_INIT
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|p
argument_list|,
argument|pfr_ktablehead
argument_list|,
argument|&pfr_ktables
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_INACTIVE
operator|)
operator|||
name|pfr_skip_table
argument_list|(
name|trs
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
name|p
operator|->
name|pfrkt_nflags
operator|=
name|p
operator|->
name|pfrkt_flags
operator|&
operator|~
name|PFR_TFLAG_INACTIVE
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|workq
argument_list|,
name|p
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
name|xdel
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_FLAG_DUMMY
operator|)
condition|)
block|{
name|pfr_setflags_ktables
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ticket
operator|!=
name|NULL
condition|)
operator|*
name|ticket
operator|=
operator|++
name|rs
operator|->
name|tticket
expr_stmt|;
name|rs
operator|->
name|topen
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|pf_remove_if_empty_ruleset
argument_list|(
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndel
operator|!=
name|NULL
condition|)
operator|*
name|ndel
operator|=
name|xdel
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_ina_define
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|struct
name|pfr_addr
modifier|*
name|addr
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|nadd
parameter_list|,
name|int
modifier|*
name|naddr
parameter_list|,
name|u_int32_t
name|ticket
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktableworkq
name|tableq
decl_stmt|;
name|struct
name|pfr_kentryworkq
name|addrq
decl_stmt|;
name|struct
name|pfr_ktable
modifier|*
name|kt
decl_stmt|,
modifier|*
name|rt
decl_stmt|,
modifier|*
name|shadow
decl_stmt|,
name|key
decl_stmt|;
name|struct
name|pfr_kentry
modifier|*
name|p
decl_stmt|;
name|struct
name|pfr_addr
modifier|*
name|ad
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|,
name|xadd
init|=
literal|0
decl_stmt|,
name|xaddr
init|=
literal|0
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_DUMMY
operator||
name|PFR_FLAG_ADDRSTOO
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|&&
operator|!
operator|(
name|flags
operator|&
name|PFR_FLAG_ADDRSTOO
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|pfr_validate_table
argument_list|(
name|tbl
argument_list|,
name|PFR_TFLAG_USRMASK
argument_list|,
name|flags
operator|&
name|PFR_FLAG_USERIOCTL
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rs
operator|=
name|pf_find_ruleset
argument_list|(
name|tbl
operator|->
name|pfrt_anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NULL
operator|||
operator|!
name|rs
operator|->
name|topen
operator|||
name|ticket
operator|!=
name|rs
operator|->
name|tticket
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|tbl
operator|->
name|pfrt_flags
operator||=
name|PFR_TFLAG_INACTIVE
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|tableq
argument_list|)
expr_stmt|;
name|kt
operator|=
name|RB_FIND
argument_list|(
name|pfr_ktablehead
argument_list|,
operator|&
name|pfr_ktables
argument_list|,
operator|(
expr|struct
name|pfr_ktable
operator|*
operator|)
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
condition|)
block|{
name|kt
operator|=
name|pfr_create_ktable
argument_list|(
name|tbl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|tableq
argument_list|,
name|kt
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
name|xadd
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|tbl
operator|->
name|pfrt_anchor
index|[
literal|0
index|]
condition|)
goto|goto
name|_skip
goto|;
comment|/* find or create root table */
name|bzero
argument_list|(
operator|&
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|key
operator|.
name|pfrkt_name
argument_list|,
name|tbl
operator|->
name|pfrt_name
argument_list|,
sizeof|sizeof
argument_list|(
name|key
operator|.
name|pfrkt_name
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|=
name|RB_FIND
argument_list|(
name|pfr_ktablehead
argument_list|,
operator|&
name|pfr_ktables
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
name|kt
operator|->
name|pfrkt_root
operator|=
name|rt
expr_stmt|;
goto|goto
name|_skip
goto|;
block|}
name|rt
operator|=
name|pfr_create_ktable
argument_list|(
operator|&
name|key
operator|.
name|pfrkt_t
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|pfr_destroy_ktables
argument_list|(
operator|&
name|tableq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|tableq
argument_list|,
name|rt
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
name|kt
operator|->
name|pfrkt_root
operator|=
name|rt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_INACTIVE
operator|)
condition|)
name|xadd
operator|++
expr_stmt|;
name|_skip
label|:
name|shadow
operator|=
name|pfr_create_ktable
argument_list|(
name|tbl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadow
operator|==
name|NULL
condition|)
block|{
name|pfr_destroy_ktables
argument_list|(
operator|&
name|tableq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|SLIST_INIT
argument_list|(
operator|&
name|addrq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ad
operator|=
name|addr
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|ad
operator|++
control|)
block|{
if|if
condition|(
name|pfr_validate_addr
argument_list|(
name|ad
argument_list|)
condition|)
name|senderr
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_lookup_addr
argument_list|(
name|shadow
argument_list|,
name|ad
argument_list|,
literal|1
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
name|p
operator|=
name|pfr_create_kentry
argument_list|(
name|ad
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfr_route_kentry
argument_list|(
name|shadow
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|pfr_destroy_kentry
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|addrq
argument_list|,
name|p
argument_list|,
name|pfrke_workq
argument_list|)
expr_stmt|;
name|xaddr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_FLAG_DUMMY
operator|)
condition|)
block|{
if|if
condition|(
name|kt
operator|->
name|pfrkt_shadow
operator|!=
name|NULL
condition|)
name|pfr_destroy_ktable
argument_list|(
name|kt
operator|->
name|pfrkt_shadow
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kt
operator|->
name|pfrkt_flags
operator||=
name|PFR_TFLAG_INACTIVE
expr_stmt|;
name|pfr_insert_ktables
argument_list|(
operator|&
name|tableq
argument_list|)
expr_stmt|;
name|shadow
operator|->
name|pfrkt_cnt
operator|=
operator|(
name|flags
operator|&
name|PFR_FLAG_ADDRSTOO
operator|)
condition|?
name|xaddr
else|:
name|NO_ADDRESSES
expr_stmt|;
name|kt
operator|->
name|pfrkt_shadow
operator|=
name|shadow
expr_stmt|;
block|}
else|else
block|{
name|pfr_clean_node_mask
argument_list|(
name|shadow
argument_list|,
operator|&
name|addrq
argument_list|)
expr_stmt|;
name|pfr_destroy_ktable
argument_list|(
name|shadow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfr_destroy_ktables
argument_list|(
operator|&
name|tableq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfr_destroy_kentries
argument_list|(
operator|&
name|addrq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nadd
operator|!=
name|NULL
condition|)
operator|*
name|nadd
operator|=
name|xadd
expr_stmt|;
if|if
condition|(
name|naddr
operator|!=
name|NULL
condition|)
operator|*
name|naddr
operator|=
name|xaddr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|_bad
label|:
name|pfr_destroy_ktable
argument_list|(
name|shadow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfr_destroy_ktables
argument_list|(
operator|&
name|tableq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfr_destroy_kentries
argument_list|(
operator|&
name|addrq
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_ina_rollback
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|trs
parameter_list|,
name|u_int32_t
name|ticket
parameter_list|,
name|int
modifier|*
name|ndel
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktableworkq
name|workq
decl_stmt|;
name|struct
name|pfr_ktable
modifier|*
name|p
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|int
name|xdel
init|=
literal|0
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_DUMMY
argument_list|)
expr_stmt|;
name|rs
operator|=
name|pf_find_ruleset
argument_list|(
name|trs
operator|->
name|pfrt_anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NULL
operator|||
operator|!
name|rs
operator|->
name|topen
operator|||
name|ticket
operator|!=
name|rs
operator|->
name|tticket
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|SLIST_INIT
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|p
argument_list|,
argument|pfr_ktablehead
argument_list|,
argument|&pfr_ktables
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_INACTIVE
operator|)
operator|||
name|pfr_skip_table
argument_list|(
name|trs
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
name|p
operator|->
name|pfrkt_nflags
operator|=
name|p
operator|->
name|pfrkt_flags
operator|&
operator|~
name|PFR_TFLAG_INACTIVE
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|workq
argument_list|,
name|p
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
name|xdel
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_FLAG_DUMMY
operator|)
condition|)
block|{
name|pfr_setflags_ktables
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
name|rs
operator|->
name|topen
operator|=
literal|0
expr_stmt|;
name|pf_remove_if_empty_ruleset
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ndel
operator|!=
name|NULL
condition|)
operator|*
name|ndel
operator|=
name|xdel
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_ina_commit
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|trs
parameter_list|,
name|u_int32_t
name|ticket
parameter_list|,
name|int
modifier|*
name|nadd
parameter_list|,
name|int
modifier|*
name|nchange
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|pfr_ktableworkq
name|workq
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|int
name|xadd
init|=
literal|0
decl_stmt|,
name|xchange
init|=
literal|0
decl_stmt|;
name|long
name|tzero
init|=
name|time_second
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
name|ACCEPT_FLAGS
argument_list|(
name|flags
argument_list|,
name|PFR_FLAG_DUMMY
argument_list|)
expr_stmt|;
name|rs
operator|=
name|pf_find_ruleset
argument_list|(
name|trs
operator|->
name|pfrt_anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NULL
operator|||
operator|!
name|rs
operator|->
name|topen
operator|||
name|ticket
operator|!=
name|rs
operator|->
name|tticket
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|SLIST_INIT
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|p
argument_list|,
argument|pfr_ktablehead
argument_list|,
argument|&pfr_ktables
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_INACTIVE
operator|)
operator|||
name|pfr_skip_table
argument_list|(
name|trs
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|workq
argument_list|,
name|p
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
condition|)
name|xchange
operator|++
expr_stmt|;
else|else
name|xadd
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_FLAG_DUMMY
operator|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|workq
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|q
control|)
block|{
name|q
operator|=
name|SLIST_NEXT
argument_list|(
name|p
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
name|pfr_commit_ktable
argument_list|(
name|p
argument_list|,
name|tzero
argument_list|)
expr_stmt|;
block|}
name|rs
operator|->
name|topen
operator|=
literal|0
expr_stmt|;
name|pf_remove_if_empty_ruleset
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nadd
operator|!=
name|NULL
condition|)
operator|*
name|nadd
operator|=
name|xadd
expr_stmt|;
if|if
condition|(
name|nchange
operator|!=
name|NULL
condition|)
operator|*
name|nchange
operator|=
name|xchange
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_commit_ktable
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|long
name|tzero
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|shadow
init|=
name|kt
operator|->
name|pfrkt_shadow
decl_stmt|;
name|int
name|nflags
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|shadow
operator|->
name|pfrkt_cnt
operator|==
name|NO_ADDRESSES
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
name|pfr_clstats_ktable
argument_list|(
name|kt
argument_list|,
name|tzero
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
condition|)
block|{
comment|/* kt might contain addresses */
name|struct
name|pfr_kentryworkq
name|addrq
decl_stmt|,
name|addq
decl_stmt|,
name|changeq
decl_stmt|,
name|delq
decl_stmt|,
name|garbageq
decl_stmt|;
name|struct
name|pfr_kentry
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|pfr_addr
name|ad
decl_stmt|;
name|pfr_enqueue_addrs
argument_list|(
name|shadow
argument_list|,
operator|&
name|addrq
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfr_mark_addrs
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|addq
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|changeq
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|delq
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|garbageq
argument_list|)
expr_stmt|;
name|pfr_clean_node_mask
argument_list|(
name|shadow
argument_list|,
operator|&
name|addrq
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|addrq
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|SLIST_NEXT
argument_list|(
name|p
argument_list|,
name|pfrke_workq
argument_list|)
expr_stmt|;
comment|/* XXX */
name|pfr_copyout_addr
argument_list|(
operator|&
name|ad
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
name|pfr_lookup_addr
argument_list|(
name|kt
argument_list|,
operator|&
name|ad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|pfrke_not
operator|!=
name|p
operator|->
name|pfrke_not
condition|)
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|changeq
argument_list|,
name|q
argument_list|,
name|pfrke_workq
argument_list|)
expr_stmt|;
name|q
operator|->
name|pfrke_mark
operator|=
literal|1
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|garbageq
argument_list|,
name|p
argument_list|,
name|pfrke_workq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|pfrke_tzero
operator|=
name|tzero
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|addq
argument_list|,
name|p
argument_list|,
name|pfrke_workq
argument_list|)
expr_stmt|;
block|}
block|}
name|pfr_enqueue_addrs
argument_list|(
name|kt
argument_list|,
operator|&
name|delq
argument_list|,
name|NULL
argument_list|,
name|ENQUEUE_UNMARKED_ONLY
argument_list|)
expr_stmt|;
name|pfr_insert_kentries
argument_list|(
name|kt
argument_list|,
operator|&
name|addq
argument_list|,
name|tzero
argument_list|)
expr_stmt|;
name|pfr_remove_kentries
argument_list|(
name|kt
argument_list|,
operator|&
name|delq
argument_list|)
expr_stmt|;
name|pfr_clstats_kentries
argument_list|(
operator|&
name|changeq
argument_list|,
name|tzero
argument_list|,
name|INVERT_NEG_FLAG
argument_list|)
expr_stmt|;
name|pfr_destroy_kentries
argument_list|(
operator|&
name|garbageq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* kt cannot contain addresses */
name|SWAP
argument_list|(
expr|struct
name|radix_node_head
operator|*
argument_list|,
name|kt
operator|->
name|pfrkt_ip4
argument_list|,
name|shadow
operator|->
name|pfrkt_ip4
argument_list|)
expr_stmt|;
name|SWAP
argument_list|(
expr|struct
name|radix_node_head
operator|*
argument_list|,
name|kt
operator|->
name|pfrkt_ip6
argument_list|,
name|shadow
operator|->
name|pfrkt_ip6
argument_list|)
expr_stmt|;
name|SWAP
argument_list|(
name|int
argument_list|,
name|kt
operator|->
name|pfrkt_cnt
argument_list|,
name|shadow
operator|->
name|pfrkt_cnt
argument_list|)
expr_stmt|;
name|pfr_clstats_ktable
argument_list|(
name|kt
argument_list|,
name|tzero
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|nflags
operator|=
operator|(
operator|(
name|shadow
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_USRMASK
operator|)
operator||
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_SETMASK
operator|)
operator||
name|PFR_TFLAG_ACTIVE
operator|)
operator|&
operator|~
name|PFR_TFLAG_INACTIVE
expr_stmt|;
name|pfr_destroy_ktable
argument_list|(
name|shadow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kt
operator|->
name|pfrkt_shadow
operator|=
name|NULL
expr_stmt|;
name|pfr_setflags_ktable
argument_list|(
name|kt
argument_list|,
name|nflags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pfr_validate_table
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|int
name|allowedflags
parameter_list|,
name|int
name|no_reserved
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|tbl
operator|->
name|pfrt_name
index|[
literal|0
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|no_reserved
operator|&&
operator|!
name|strcmp
argument_list|(
name|tbl
operator|->
name|pfrt_anchor
argument_list|,
name|PF_RESERVED_ANCHOR
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|tbl
operator|->
name|pfrt_name
index|[
name|PF_TABLE_NAME_SIZE
operator|-
literal|1
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|tbl
operator|->
name|pfrt_name
argument_list|)
init|;
name|i
operator|<
name|PF_TABLE_NAME_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tbl
operator|->
name|pfrt_name
index|[
name|i
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|pfr_fix_anchor
argument_list|(
name|tbl
operator|->
name|pfrt_anchor
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|tbl
operator|->
name|pfrt_flags
operator|&
operator|~
name|allowedflags
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rewrite anchors referenced by tables to remove slashes  * and check for validity.  */
end_comment

begin_function
specifier|static
name|int
name|pfr_fix_anchor
parameter_list|(
name|char
modifier|*
name|anchor
parameter_list|)
block|{
name|size_t
name|siz
init|=
name|MAXPATHLEN
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|anchor
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|off
decl_stmt|;
name|path
operator|=
name|anchor
expr_stmt|;
name|off
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|path
operator|==
literal|'/'
condition|)
name|off
operator|++
expr_stmt|;
name|bcopy
argument_list|(
name|path
argument_list|,
name|anchor
argument_list|,
name|siz
operator|-
name|off
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|anchor
operator|+
name|siz
operator|-
name|off
argument_list|,
literal|0
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|anchor
index|[
name|siz
operator|-
literal|1
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|anchor
argument_list|)
init|;
name|i
operator|<
name|siz
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|anchor
index|[
name|i
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pfr_table_count
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|filter
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|PF_RULES_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_FLAG_ALLRSETS
condition|)
return|return
operator|(
name|pfr_ktable_cnt
operator|)
return|;
if|if
condition|(
name|filter
operator|->
name|pfrt_anchor
index|[
literal|0
index|]
condition|)
block|{
name|rs
operator|=
name|pf_find_ruleset
argument_list|(
name|filter
operator|->
name|pfrt_anchor
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|rs
operator|!=
name|NULL
operator|)
condition|?
name|rs
operator|->
name|tables
else|:
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|pf_main_ruleset
operator|.
name|tables
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pfr_skip_table
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|filter
parameter_list|,
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|PFR_FLAG_ALLRSETS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|filter
operator|->
name|pfrt_anchor
argument_list|,
name|kt
operator|->
name|pfrkt_anchor
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_insert_ktables
parameter_list|(
name|struct
name|pfr_ktableworkq
modifier|*
name|workq
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|p
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|p
argument_list|,
argument|workq
argument_list|,
argument|pfrkt_workq
argument_list|)
name|pfr_insert_ktable
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_insert_ktable
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|)
block|{
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
name|RB_INSERT
argument_list|(
name|pfr_ktablehead
argument_list|,
operator|&
name|pfr_ktables
argument_list|,
name|kt
argument_list|)
expr_stmt|;
name|pfr_ktable_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|pfrkt_root
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|kt
operator|->
name|pfrkt_root
operator|->
name|pfrkt_refcnt
index|[
name|PFR_REFCNT_ANCHOR
index|]
operator|++
condition|)
name|pfr_setflags_ktable
argument_list|(
name|kt
operator|->
name|pfrkt_root
argument_list|,
name|kt
operator|->
name|pfrkt_root
operator|->
name|pfrkt_flags
operator||
name|PFR_TFLAG_REFDANCHOR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_setflags_ktables
parameter_list|(
name|struct
name|pfr_ktableworkq
modifier|*
name|workq
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|SLIST_FIRST
argument_list|(
name|workq
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|q
control|)
block|{
name|q
operator|=
name|SLIST_NEXT
argument_list|(
name|p
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
name|pfr_setflags_ktable
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|pfrkt_nflags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_setflags_ktable
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|int
name|newf
parameter_list|)
block|{
name|struct
name|pfr_kentryworkq
name|addrq
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|newf
operator|&
name|PFR_TFLAG_REFERENCED
operator|)
operator|&&
operator|!
operator|(
name|newf
operator|&
name|PFR_TFLAG_PERSIST
operator|)
condition|)
name|newf
operator|&=
operator|~
name|PFR_TFLAG_ACTIVE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|newf
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
name|newf
operator|&=
operator|~
name|PFR_TFLAG_USRMASK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|newf
operator|&
name|PFR_TFLAG_SETMASK
operator|)
condition|)
block|{
name|RB_REMOVE
argument_list|(
name|pfr_ktablehead
argument_list|,
operator|&
name|pfr_ktables
argument_list|,
name|kt
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|pfrkt_root
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
operator|--
name|kt
operator|->
name|pfrkt_root
operator|->
name|pfrkt_refcnt
index|[
name|PFR_REFCNT_ANCHOR
index|]
condition|)
name|pfr_setflags_ktable
argument_list|(
name|kt
operator|->
name|pfrkt_root
argument_list|,
name|kt
operator|->
name|pfrkt_root
operator|->
name|pfrkt_flags
operator|&
operator|~
name|PFR_TFLAG_REFDANCHOR
argument_list|)
expr_stmt|;
name|pfr_destroy_ktable
argument_list|(
name|kt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pfr_ktable_cnt
operator|--
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|newf
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
operator|&&
name|kt
operator|->
name|pfrkt_cnt
condition|)
block|{
name|pfr_enqueue_addrs
argument_list|(
name|kt
argument_list|,
operator|&
name|addrq
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfr_remove_kentries
argument_list|(
name|kt
argument_list|,
operator|&
name|addrq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|newf
operator|&
name|PFR_TFLAG_INACTIVE
operator|)
operator|&&
name|kt
operator|->
name|pfrkt_shadow
operator|!=
name|NULL
condition|)
block|{
name|pfr_destroy_ktable
argument_list|(
name|kt
operator|->
name|pfrkt_shadow
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kt
operator|->
name|pfrkt_shadow
operator|=
name|NULL
expr_stmt|;
block|}
name|kt
operator|->
name|pfrkt_flags
operator|=
name|newf
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_clstats_ktables
parameter_list|(
name|struct
name|pfr_ktableworkq
modifier|*
name|workq
parameter_list|,
name|long
name|tzero
parameter_list|,
name|int
name|recurse
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|p
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|p
argument_list|,
argument|workq
argument_list|,
argument|pfrkt_workq
argument_list|)
name|pfr_clstats_ktable
argument_list|(
name|p
argument_list|,
name|tzero
argument_list|,
name|recurse
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_clstats_ktable
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|long
name|tzero
parameter_list|,
name|int
name|recurse
parameter_list|)
block|{
name|struct
name|pfr_kentryworkq
name|addrq
decl_stmt|;
if|if
condition|(
name|recurse
condition|)
block|{
name|pfr_enqueue_addrs
argument_list|(
name|kt
argument_list|,
operator|&
name|addrq
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfr_clstats_kentries
argument_list|(
operator|&
name|addrq
argument_list|,
name|tzero
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|kt
operator|->
name|pfrkt_packets
argument_list|,
sizeof|sizeof
argument_list|(
name|kt
operator|->
name|pfrkt_packets
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|kt
operator|->
name|pfrkt_bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|kt
operator|->
name|pfrkt_bytes
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|->
name|pfrkt_match
operator|=
name|kt
operator|->
name|pfrkt_nomatch
operator|=
literal|0
expr_stmt|;
name|kt
operator|->
name|pfrkt_tzero
operator|=
name|tzero
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pfr_ktable
modifier|*
name|pfr_create_ktable
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|,
name|long
name|tzero
parameter_list|,
name|int
name|attachruleset
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|kt
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
name|kt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|kt
argument_list|)
argument_list|,
name|M_PFTABLE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|kt
operator|->
name|pfrkt_t
operator|=
operator|*
name|tbl
expr_stmt|;
if|if
condition|(
name|attachruleset
condition|)
block|{
name|rs
operator|=
name|pf_find_or_create_ruleset
argument_list|(
name|tbl
operator|->
name|pfrt_anchor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
condition|)
block|{
name|pfr_destroy_ktable
argument_list|(
name|kt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|kt
operator|->
name|pfrkt_rs
operator|=
name|rs
expr_stmt|;
name|rs
operator|->
name|tables
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rn_inithead
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|kt
operator|->
name|pfrkt_ip4
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|,
name|sin_addr
argument_list|)
operator|*
literal|8
argument_list|)
operator|||
operator|!
name|rn_inithead
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|kt
operator|->
name|pfrkt_ip6
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|,
name|sin6_addr
argument_list|)
operator|*
literal|8
argument_list|)
condition|)
block|{
name|pfr_destroy_ktable
argument_list|(
name|kt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|kt
operator|->
name|pfrkt_tzero
operator|=
name|tzero
expr_stmt|;
return|return
operator|(
name|kt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_destroy_ktables
parameter_list|(
name|struct
name|pfr_ktableworkq
modifier|*
name|workq
parameter_list|,
name|int
name|flushaddr
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|SLIST_FIRST
argument_list|(
name|workq
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|q
control|)
block|{
name|q
operator|=
name|SLIST_NEXT
argument_list|(
name|p
argument_list|,
name|pfrkt_workq
argument_list|)
expr_stmt|;
name|pfr_destroy_ktable
argument_list|(
name|p
argument_list|,
name|flushaddr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pfr_destroy_ktable
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|int
name|flushaddr
parameter_list|)
block|{
name|struct
name|pfr_kentryworkq
name|addrq
decl_stmt|;
if|if
condition|(
name|flushaddr
condition|)
block|{
name|pfr_enqueue_addrs
argument_list|(
name|kt
argument_list|,
operator|&
name|addrq
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfr_clean_node_mask
argument_list|(
name|kt
argument_list|,
operator|&
name|addrq
argument_list|)
expr_stmt|;
name|pfr_destroy_kentries
argument_list|(
operator|&
name|addrq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kt
operator|->
name|pfrkt_ip4
operator|!=
name|NULL
condition|)
block|{
name|RADIX_NODE_HEAD_DESTROY
argument_list|(
name|kt
operator|->
name|pfrkt_ip4
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|kt
operator|->
name|pfrkt_ip4
argument_list|,
name|M_RTABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kt
operator|->
name|pfrkt_ip6
operator|!=
name|NULL
condition|)
block|{
name|RADIX_NODE_HEAD_DESTROY
argument_list|(
name|kt
operator|->
name|pfrkt_ip6
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|kt
operator|->
name|pfrkt_ip6
argument_list|,
name|M_RTABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kt
operator|->
name|pfrkt_shadow
operator|!=
name|NULL
condition|)
name|pfr_destroy_ktable
argument_list|(
name|kt
operator|->
name|pfrkt_shadow
argument_list|,
name|flushaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|pfrkt_rs
operator|!=
name|NULL
condition|)
block|{
name|kt
operator|->
name|pfrkt_rs
operator|->
name|tables
operator|--
expr_stmt|;
name|pf_remove_if_empty_ruleset
argument_list|(
name|kt
operator|->
name|pfrkt_rs
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|kt
argument_list|,
name|M_PFTABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pfr_ktable_compare
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|p
parameter_list|,
name|struct
name|pfr_ktable
modifier|*
name|q
parameter_list|)
block|{
name|int
name|d
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|strncmp
argument_list|(
name|p
operator|->
name|pfrkt_name
argument_list|,
name|q
operator|->
name|pfrkt_name
argument_list|,
name|PF_TABLE_NAME_SIZE
argument_list|)
operator|)
condition|)
return|return
operator|(
name|d
operator|)
return|;
return|return
operator|(
name|strcmp
argument_list|(
name|p
operator|->
name|pfrkt_anchor
argument_list|,
name|q
operator|->
name|pfrkt_anchor
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pfr_ktable
modifier|*
name|pfr_lookup_table
parameter_list|(
name|struct
name|pfr_table
modifier|*
name|tbl
parameter_list|)
block|{
comment|/* struct pfr_ktable start like a struct pfr_table */
return|return
operator|(
name|RB_FIND
argument_list|(
name|pfr_ktablehead
argument_list|,
operator|&
name|pfr_ktables
argument_list|,
operator|(
expr|struct
name|pfr_ktable
operator|*
operator|)
name|tbl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfr_match_addr
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|a
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|struct
name|pfr_kentry
modifier|*
name|ke
init|=
name|NULL
decl_stmt|;
name|int
name|match
decl_stmt|;
name|PF_RULES_RASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
operator|&&
name|kt
operator|->
name|pfrkt_root
operator|!=
name|NULL
condition|)
name|kt
operator|=
name|kt
operator|->
name|pfrkt_root
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|a
operator|->
name|addr32
index|[
literal|0
index|]
expr_stmt|;
name|ke
operator|=
operator|(
expr|struct
name|pfr_kentry
operator|*
operator|)
name|rn_match
argument_list|(
operator|&
name|sin
argument_list|,
name|kt
operator|->
name|pfrkt_ip4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|&&
name|KENTRY_RNF_ROOT
argument_list|(
name|ke
argument_list|)
condition|)
name|ke
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|bcopy
argument_list|(
name|a
argument_list|,
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ke
operator|=
operator|(
expr|struct
name|pfr_kentry
operator|*
operator|)
name|rn_match
argument_list|(
operator|&
name|sin6
argument_list|,
name|kt
operator|->
name|pfrkt_ip6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|&&
name|KENTRY_RNF_ROOT
argument_list|(
name|ke
argument_list|)
condition|)
name|ke
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
block|}
name|match
operator|=
operator|(
name|ke
operator|&&
operator|!
name|ke
operator|->
name|pfrke_not
operator|)
expr_stmt|;
if|if
condition|(
name|match
condition|)
name|kt
operator|->
name|pfrkt_match
operator|++
expr_stmt|;
else|else
name|kt
operator|->
name|pfrkt_nomatch
operator|++
expr_stmt|;
return|return
operator|(
name|match
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pfr_update_stats
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|a
parameter_list|,
name|sa_family_t
name|af
parameter_list|,
name|u_int64_t
name|len
parameter_list|,
name|int
name|dir_out
parameter_list|,
name|int
name|op_pass
parameter_list|,
name|int
name|notrule
parameter_list|)
block|{
name|struct
name|pfr_kentry
modifier|*
name|ke
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
operator|&&
name|kt
operator|->
name|pfrkt_root
operator|!=
name|NULL
condition|)
name|kt
operator|=
name|kt
operator|->
name|pfrkt_root
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
return|return;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|a
operator|->
name|addr32
index|[
literal|0
index|]
expr_stmt|;
name|ke
operator|=
operator|(
expr|struct
name|pfr_kentry
operator|*
operator|)
name|rn_match
argument_list|(
operator|&
name|sin
argument_list|,
name|kt
operator|->
name|pfrkt_ip4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|&&
name|KENTRY_RNF_ROOT
argument_list|(
name|ke
argument_list|)
condition|)
name|ke
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|bcopy
argument_list|(
name|a
argument_list|,
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ke
operator|=
operator|(
expr|struct
name|pfr_kentry
operator|*
operator|)
name|rn_match
argument_list|(
operator|&
name|sin6
argument_list|,
name|kt
operator|->
name|pfrkt_ip6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|&&
name|KENTRY_RNF_ROOT
argument_list|(
name|ke
argument_list|)
condition|)
name|ke
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
default|default:
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|ke
operator|==
name|NULL
operator|||
name|ke
operator|->
name|pfrke_not
operator|)
operator|!=
name|notrule
condition|)
block|{
if|if
condition|(
name|op_pass
operator|!=
name|PFR_OP_PASS
condition|)
name|printf
argument_list|(
literal|"pfr_update_stats: assertion failed.\n"
argument_list|)
expr_stmt|;
name|op_pass
operator|=
name|PFR_OP_XPASS
expr_stmt|;
block|}
name|kt
operator|->
name|pfrkt_packets
index|[
name|dir_out
index|]
index|[
name|op_pass
index|]
operator|++
expr_stmt|;
name|kt
operator|->
name|pfrkt_bytes
index|[
name|dir_out
index|]
index|[
name|op_pass
index|]
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|ke
operator|!=
name|NULL
operator|&&
name|op_pass
operator|!=
name|PFR_OP_XPASS
operator|&&
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_COUNTERS
operator|)
condition|)
block|{
if|if
condition|(
name|ke
operator|->
name|pfrke_counters
operator|==
name|NULL
condition|)
name|ke
operator|->
name|pfrke_counters
operator|=
name|uma_zalloc
argument_list|(
name|V_pfr_kcounters_z
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|pfrke_counters
operator|!=
name|NULL
condition|)
block|{
name|ke
operator|->
name|pfrke_counters
operator|->
name|pfrkc_packets
index|[
name|dir_out
index|]
index|[
name|op_pass
index|]
operator|++
expr_stmt|;
name|ke
operator|->
name|pfrke_counters
operator|->
name|pfrkc_bytes
index|[
name|dir_out
index|]
index|[
name|op_pass
index|]
operator|+=
name|len
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|struct
name|pfr_ktable
modifier|*
name|pfr_attach_table
parameter_list|(
name|struct
name|pf_ruleset
modifier|*
name|rs
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|pfr_ktable
modifier|*
name|kt
decl_stmt|,
modifier|*
name|rt
decl_stmt|;
name|struct
name|pfr_table
name|tbl
decl_stmt|;
name|struct
name|pf_anchor
modifier|*
name|ac
init|=
name|rs
operator|->
name|anchor
decl_stmt|;
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|tbl
argument_list|,
sizeof|sizeof
argument_list|(
name|tbl
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|tbl
operator|.
name|pfrt_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|tbl
operator|.
name|pfrt_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|!=
name|NULL
condition|)
name|strlcpy
argument_list|(
name|tbl
operator|.
name|pfrt_anchor
argument_list|,
name|ac
operator|->
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|tbl
operator|.
name|pfrt_anchor
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|pfr_lookup_table
argument_list|(
operator|&
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
condition|)
block|{
name|kt
operator|=
name|pfr_create_ktable
argument_list|(
operator|&
name|tbl
argument_list|,
name|time_second
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|tbl
operator|.
name|pfrt_anchor
argument_list|,
sizeof|sizeof
argument_list|(
name|tbl
operator|.
name|pfrt_anchor
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|=
name|pfr_lookup_table
argument_list|(
operator|&
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|rt
operator|=
name|pfr_create_ktable
argument_list|(
operator|&
name|tbl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|pfr_destroy_ktable
argument_list|(
name|kt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|pfr_insert_ktable
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
name|kt
operator|->
name|pfrkt_root
operator|=
name|rt
expr_stmt|;
block|}
name|pfr_insert_ktable
argument_list|(
name|kt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|kt
operator|->
name|pfrkt_refcnt
index|[
name|PFR_REFCNT_RULE
index|]
operator|++
condition|)
name|pfr_setflags_ktable
argument_list|(
name|kt
argument_list|,
name|kt
operator|->
name|pfrkt_flags
operator||
name|PFR_TFLAG_REFERENCED
argument_list|)
expr_stmt|;
return|return
operator|(
name|kt
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pfr_detach_table
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|)
block|{
name|PF_RULES_WASSERT
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|kt
operator|->
name|pfrkt_refcnt
index|[
name|PFR_REFCNT_RULE
index|]
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: refcount %d\n"
operator|,
name|__func__
operator|,
name|kt
operator|->
name|pfrkt_refcnt
index|[
name|PFR_REFCNT_RULE
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|kt
operator|->
name|pfrkt_refcnt
index|[
name|PFR_REFCNT_RULE
index|]
condition|)
name|pfr_setflags_ktable
argument_list|(
name|kt
argument_list|,
name|kt
operator|->
name|pfrkt_flags
operator|&
operator|~
name|PFR_TFLAG_REFERENCED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pfr_pool_get
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|int
modifier|*
name|pidx
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|counter
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|struct
name|pf_addr
modifier|*
name|addr
decl_stmt|,
modifier|*
name|cur
decl_stmt|,
modifier|*
name|mask
decl_stmt|;
name|union
name|sockaddr_union
name|uaddr
decl_stmt|,
name|umask
decl_stmt|;
name|struct
name|pfr_kentry
modifier|*
name|ke
decl_stmt|,
modifier|*
name|ke2
init|=
name|NULL
decl_stmt|;
name|int
name|idx
init|=
operator|-
literal|1
decl_stmt|,
name|use_counter
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
name|uaddr
operator|.
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|uaddr
operator|.
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|uaddr
operator|.
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|uaddr
operator|.
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
break|break;
block|}
name|addr
operator|=
name|SUNION2PF
argument_list|(
operator|&
name|uaddr
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
operator|&&
name|kt
operator|->
name|pfrkt_root
operator|!=
name|NULL
condition|)
name|kt
operator|=
name|kt
operator|->
name|pfrkt_root
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kt
operator|->
name|pfrkt_flags
operator|&
name|PFR_TFLAG_ACTIVE
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|pidx
operator|!=
name|NULL
condition|)
name|idx
operator|=
operator|*
name|pidx
expr_stmt|;
if|if
condition|(
name|counter
operator|!=
name|NULL
operator|&&
name|idx
operator|>=
literal|0
condition|)
name|use_counter
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
name|_next_block
label|:
name|ke
operator|=
name|pfr_kentry_byidx
argument_list|(
name|kt
argument_list|,
name|idx
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|==
name|NULL
condition|)
block|{
name|kt
operator|->
name|pfrkt_nomatch
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|pfr_prepare_network
argument_list|(
operator|&
name|umask
argument_list|,
name|af
argument_list|,
name|ke
operator|->
name|pfrke_net
argument_list|)
expr_stmt|;
name|cur
operator|=
name|SUNION2PF
argument_list|(
operator|&
name|ke
operator|->
name|pfrke_sa
argument_list|,
name|af
argument_list|)
expr_stmt|;
name|mask
operator|=
name|SUNION2PF
argument_list|(
operator|&
name|umask
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_counter
condition|)
block|{
comment|/* is supplied address within block? */
if|if
condition|(
operator|!
name|PF_MATCHA
argument_list|(
literal|0
argument_list|,
name|cur
argument_list|,
name|mask
argument_list|,
name|counter
argument_list|,
name|af
argument_list|)
condition|)
block|{
comment|/* no, go to next block in table */
name|idx
operator|++
expr_stmt|;
name|use_counter
operator|=
literal|0
expr_stmt|;
goto|goto
name|_next_block
goto|;
block|}
name|PF_ACPY
argument_list|(
name|addr
argument_list|,
name|counter
argument_list|,
name|af
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use first address of block */
name|PF_ACPY
argument_list|(
name|addr
argument_list|,
name|cur
argument_list|,
name|af
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|KENTRY_NETWORK
argument_list|(
name|ke
argument_list|)
condition|)
block|{
comment|/* this is a single IP address - no possible nested block */
name|PF_ACPY
argument_list|(
name|counter
argument_list|,
name|addr
argument_list|,
name|af
argument_list|)
expr_stmt|;
operator|*
name|pidx
operator|=
name|idx
expr_stmt|;
name|kt
operator|->
name|pfrkt_match
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* we don't want to use a nested block */
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
name|ke2
operator|=
operator|(
expr|struct
name|pfr_kentry
operator|*
operator|)
name|rn_match
argument_list|(
operator|&
name|uaddr
argument_list|,
name|kt
operator|->
name|pfrkt_ip4
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|ke2
operator|=
operator|(
expr|struct
name|pfr_kentry
operator|*
operator|)
name|rn_match
argument_list|(
operator|&
name|uaddr
argument_list|,
name|kt
operator|->
name|pfrkt_ip6
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* no need to check KENTRY_RNF_ROOT() here */
if|if
condition|(
name|ke2
operator|==
name|ke
condition|)
block|{
comment|/* lookup return the same block - perfect */
name|PF_ACPY
argument_list|(
name|counter
argument_list|,
name|addr
argument_list|,
name|af
argument_list|)
expr_stmt|;
operator|*
name|pidx
operator|=
name|idx
expr_stmt|;
name|kt
operator|->
name|pfrkt_match
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* we need to increase the counter past the nested block */
name|pfr_prepare_network
argument_list|(
operator|&
name|umask
argument_list|,
name|AF_INET
argument_list|,
name|ke2
operator|->
name|pfrke_net
argument_list|)
expr_stmt|;
name|PF_POOLMASK
argument_list|(
name|addr
argument_list|,
name|addr
argument_list|,
name|SUNION2PF
argument_list|(
operator|&
name|umask
argument_list|,
name|af
argument_list|)
argument_list|,
operator|&
name|pfr_ffaddr
argument_list|,
name|af
argument_list|)
expr_stmt|;
name|PF_AINC
argument_list|(
name|addr
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PF_MATCHA
argument_list|(
literal|0
argument_list|,
name|cur
argument_list|,
name|mask
argument_list|,
name|addr
argument_list|,
name|af
argument_list|)
condition|)
block|{
comment|/* ok, we reached the end of our main block */
comment|/* go to next block in table */
name|idx
operator|++
expr_stmt|;
name|use_counter
operator|=
literal|0
expr_stmt|;
goto|goto
name|_next_block
goto|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|pfr_kentry
modifier|*
name|pfr_kentry_byidx
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|af
parameter_list|)
block|{
name|struct
name|pfr_walktree
name|w
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|pfrw_op
operator|=
name|PFRW_POOL_GET
expr_stmt|;
name|w
operator|.
name|pfrw_cnt
operator|=
name|idx
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|kt
operator|->
name|pfrkt_ip4
operator|->
name|rnh_walktree
argument_list|(
name|kt
operator|->
name|pfrkt_ip4
argument_list|,
name|pfr_walktree
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
return|return
operator|(
name|w
operator|.
name|pfrw_kentry
operator|)
return|;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|kt
operator|->
name|pfrkt_ip6
operator|->
name|rnh_walktree
argument_list|(
name|kt
operator|->
name|pfrkt_ip6
argument_list|,
name|pfr_walktree
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
return|return
operator|(
name|w
operator|.
name|pfrw_kentry
operator|)
return|;
endif|#
directive|endif
comment|/* INET6 */
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|pfr_dynaddr_update
parameter_list|(
name|struct
name|pfr_ktable
modifier|*
name|kt
parameter_list|,
name|struct
name|pfi_dynaddr
modifier|*
name|dyn
parameter_list|)
block|{
name|struct
name|pfr_walktree
name|w
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|pfrw_op
operator|=
name|PFRW_DYNADDR_UPDATE
expr_stmt|;
name|w
operator|.
name|pfrw_dyn
operator|=
name|dyn
expr_stmt|;
name|dyn
operator|->
name|pfid_acnt4
operator|=
literal|0
expr_stmt|;
name|dyn
operator|->
name|pfid_acnt6
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|dyn
operator|->
name|pfid_af
operator|||
name|dyn
operator|->
name|pfid_af
operator|==
name|AF_INET
condition|)
name|kt
operator|->
name|pfrkt_ip4
operator|->
name|rnh_walktree
argument_list|(
name|kt
operator|->
name|pfrkt_ip4
argument_list|,
name|pfr_walktree
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dyn
operator|->
name|pfid_af
operator|||
name|dyn
operator|->
name|pfid_af
operator|==
name|AF_INET6
condition|)
name|kt
operator|->
name|pfrkt_ip6
operator|->
name|rnh_walktree
argument_list|(
name|kt
operator|->
name|pfrkt_ip6
argument_list|,
name|pfr_walktree
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

