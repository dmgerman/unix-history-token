begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2017 Ruslan Bukin<br@bsdpad.com>  * All rights reserved.  *  * This software was developed by BAE Systems, the University of Cambridge  * Computer Laboratory, and Memorial University under DARPA/AFRL contract  * FA8650-15-C-7558 ("CADETS"), as part of the DARPA Transparent Computing  * (TC) research program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Design overview.  *  * The driver provides character device for mmap(2) and ioctl(2) system calls  * allowing user to manage isolated compartments ("enclaves") in user VA space.  *  * The driver duties is EPC pages management, enclave management, user data  * validation.  *  * This driver requires Intel SGX support from hardware.  *  * /dev/sgx:  *    .mmap:  *        sgx_mmap_single() allocates VM object with following pager  *        operations:  *              a) sgx_pg_ctor():  *                  VM object constructor does nothing  *              b) sgx_pg_dtor():  *                  VM object destructor destroys the SGX enclave associated  *                  with the object: it frees all the EPC pages allocated for  *                  enclave and removes the enclave.  *              c) sgx_pg_fault():  *                  VM object fault handler does nothing  *  *    .ioctl:  *        sgx_ioctl():  *               a) SGX_IOC_ENCLAVE_CREATE  *                   Adds Enclave SECS page: initial step of enclave creation.  *               b) SGX_IOC_ENCLAVE_ADD_PAGE  *                   Adds TCS, REG pages to the enclave.  *               c) SGX_IOC_ENCLAVE_INIT  *                   Finalizes enclave creation.  *  * Enclave lifecycle:  *          .-- ECREATE  -- Add SECS page  *   Kernel |   EADD     -- Add TCS, REG pages  *    space |   EEXTEND  -- Measure the page (take unique hash)  *    ENCLS |   EPA      -- Allocate version array page  *          '-- EINIT    -- Finalize enclave creation  *   User   .-- EENTER   -- Go to entry point of enclave  *    space |   EEXIT    -- Exit back to main application  *    ENCLU '-- ERESUME  -- Resume enclave execution (e.g. after exception)  *    * Enclave lifecycle from driver point of view:  *  1) User calls mmap() on /dev/sgx: we allocate a VM object  *  2) User calls ioctl SGX_IOC_ENCLAVE_CREATE: we look for the VM object  *     associated with user process created on step 1, create SECS physical  *     page and store it in enclave's VM object queue by special index  *     SGX_SECS_VM_OBJECT_INDEX.  *  3) User calls ioctl SGX_IOC_ENCLAVE_ADD_PAGE: we look for enclave created  *     on step 2, create TCS or REG physical page and map it to specified by  *     user address of enclave VM object.  *  4) User finalizes enclave creation with ioctl SGX_IOC_ENCLAVE_INIT call.  *  5) User can freely enter to and exit from enclave using ENCLU instructions  *     from userspace: the driver does nothing here.  *  6) User proceed munmap(2) system call (or the process with enclave dies):  *     we destroy the enclave associated with the object.  *  * EPC page types and their indexes in VM object queue:  *   - PT_SECS index is special and equals SGX_SECS_VM_OBJECT_INDEX (-1);  *   - PT_TCS and PT_REG indexes are specified by user in addr field of ioctl  *     request data and determined as follows:  *       pidx = OFF_TO_IDX(addp->addr - vmh->base);  *   - PT_VA index is special, created for PT_REG, PT_TCS and PT_SECS pages  *     and determined by formula:  *       va_page_idx = - SGX_VA_PAGES_OFFS - (page_idx / SGX_VA_PAGE_SLOTS);  *     PT_VA page can hold versions of up to 512 pages, and slot for each  *     page in PT_VA page is determined as follows:  *       va_slot_idx = page_idx % SGX_VA_PAGE_SLOTS;  *   - PT_TRIM is unused.  *  * Locking:  *    SGX ENCLS set of instructions have limitations on concurrency:  *    some instructions can't be executed same time on different CPUs.  *    We use sc->mtx_encls lock around them to prevent concurrent execution.  *    sc->mtx lock is used to manage list of created enclaves and the state of  *    SGX driver.  *  * Eviction of EPC pages:  *    Eviction support is not implemented in this driver, however the driver  *    manages VA (version array) pages: it allocates a VA slot for each EPC  *    page. This will be required for eviction support in future.  *    VA pages and slots are currently unused.  *  * IntelÂ® 64 and IA-32 Architectures Software Developer's Manual  * https://software.intel.com/en-us/articles/intel-sdm  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_phys.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_radix.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/sgx.h>
end_include

begin_include
include|#
directive|include
file|<machine/sgxreg.h>
end_include

begin_include
include|#
directive|include
file|<amd64/sgx/sgxvar.h>
end_include

begin_define
define|#
directive|define
name|SGX_DEBUG
end_define

begin_undef
undef|#
directive|undef
name|SGX_DEBUG
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|SGX_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|printf(fmt, ##__VA_ARGS__)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|cdev_pager_ops
name|sgx_pg_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sgx_softc
name|sgx_sc
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sgx_get_epc_page
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|epc_page
modifier|*
modifier|*
name|epc
parameter_list|)
block|{
name|vmem_addr_t
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|vmem_alloc
argument_list|(
name|sc
operator|->
name|vmem_epc
argument_list|,
name|PAGE_SIZE
argument_list|,
name|M_FIRSTFIT
operator||
name|M_NOWAIT
argument_list|,
operator|&
name|addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
operator|(
name|addr
operator|-
name|sc
operator|->
name|epc_base
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
operator|*
name|epc
operator|=
operator|&
name|sc
operator|->
name|epc_pages
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sgx_put_epc_page
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|epc_page
modifier|*
name|epc
parameter_list|)
block|{
name|vmem_addr_t
name|addr
decl_stmt|;
if|if
condition|(
name|epc
operator|==
name|NULL
condition|)
return|return;
name|addr
operator|=
operator|(
name|epc
operator|->
name|index
operator|*
name|PAGE_SIZE
operator|)
operator|+
name|sc
operator|->
name|epc_base
expr_stmt|;
name|vmem_free
argument_list|(
name|sc
operator|->
name|vmem_epc
argument_list|,
name|addr
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_va_slot_init_by_index
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|uint64_t
name|idx
parameter_list|)
block|{
name|struct
name|epc_page
modifier|*
name|epc
decl_stmt|;
name|vm_page_t
name|page
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|p
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|sgx_get_epc_page
argument_list|(
name|sc
argument_list|,
operator|&
name|epc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: No free EPC pages available.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|)
expr_stmt|;
name|sgx_epa
argument_list|(
operator|(
name|void
operator|*
operator|)
name|epc
operator|->
name|base
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|)
expr_stmt|;
name|page
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|epc
operator|->
name|phys
argument_list|)
expr_stmt|;
name|vm_page_insert
argument_list|(
name|page
argument_list|,
name|object
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|page
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_va_slot_init
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|sgx_enclave
modifier|*
name|enclave
parameter_list|,
name|uint64_t
name|addr
parameter_list|)
block|{
name|vm_pindex_t
name|pidx
decl_stmt|;
name|uint64_t
name|va_page_idx
decl_stmt|;
name|uint64_t
name|idx
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|int
name|va_slot
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|object
operator|=
name|enclave
operator|->
name|object
expr_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|pidx
operator|=
name|OFF_TO_IDX
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|va_slot
operator|=
name|pidx
operator|%
name|SGX_VA_PAGE_SLOTS
expr_stmt|;
name|va_page_idx
operator|=
name|pidx
operator|/
name|SGX_VA_PAGE_SLOTS
expr_stmt|;
name|idx
operator|=
operator|-
name|SGX_VA_PAGES_OFFS
operator|-
name|va_page_idx
expr_stmt|;
name|ret
operator|=
name|sgx_va_slot_init_by_index
argument_list|(
name|sc
argument_list|,
name|object
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_mem_find
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|vm_map_entry_t
modifier|*
name|entry0
parameter_list|,
name|vm_object_t
modifier|*
name|object0
parameter_list|)
block|{
name|vm_map_t
name|map
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|map
operator|=
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|addr
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: Can't find enclave.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|object
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|NULL
operator|||
name|object
operator|->
name|handle
operator|==
name|NULL
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_MGTDEVICE
operator|||
name|object
operator|->
name|un_pager
operator|.
name|devp
operator|.
name|ops
operator|!=
operator|&
name|sgx_pg_ops
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|vm_object_reference
argument_list|(
name|object
argument_list|)
expr_stmt|;
operator|*
name|object0
operator|=
name|object
expr_stmt|;
operator|*
name|entry0
operator|=
name|entry
expr_stmt|;
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_enclave_find
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|struct
name|sgx_enclave
modifier|*
modifier|*
name|encl
parameter_list|)
block|{
name|struct
name|sgx_vm_handle
modifier|*
name|vmh
decl_stmt|;
name|struct
name|sgx_enclave
modifier|*
name|enclave
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|sgx_mem_find
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|vmh
operator|=
name|object
operator|->
name|handle
expr_stmt|;
if|if
condition|(
name|vmh
operator|==
name|NULL
condition|)
block|{
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|enclave
operator|=
name|vmh
operator|->
name|enclave
expr_stmt|;
if|if
condition|(
name|enclave
operator|==
name|NULL
operator|||
name|enclave
operator|->
name|object
operator|==
name|NULL
condition|)
block|{
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|encl
operator|=
name|enclave
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_enclave_alloc
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|secs
modifier|*
name|secs
parameter_list|,
name|struct
name|sgx_enclave
modifier|*
modifier|*
name|enclave0
parameter_list|)
block|{
name|struct
name|sgx_enclave
modifier|*
name|enclave
decl_stmt|;
name|enclave
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sgx_enclave
argument_list|)
argument_list|,
name|M_SGX
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|enclave
operator|->
name|base
operator|=
name|secs
operator|->
name|base
expr_stmt|;
name|enclave
operator|->
name|size
operator|=
name|secs
operator|->
name|size
expr_stmt|;
operator|*
name|enclave0
operator|=
name|enclave
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sgx_epc_page_remove
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|epc_page
modifier|*
name|epc
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|)
expr_stmt|;
name|sgx_eremove
argument_list|(
operator|(
name|void
operator|*
operator|)
name|epc
operator|->
name|base
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sgx_page_remove
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|vm_page_t
name|p
parameter_list|)
block|{
name|struct
name|epc_page
modifier|*
name|epc
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|uint64_t
name|offs
decl_stmt|;
name|vm_page_lock
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_remove
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: p->pidx %ld\n"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|pindex
argument_list|)
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|epc
operator|=
operator|&
name|sc
operator|->
name|epc_pages
index|[
literal|0
index|]
expr_stmt|;
name|offs
operator|=
operator|(
name|pa
operator|-
name|epc
operator|->
name|phys
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
name|epc
operator|=
operator|&
name|sc
operator|->
name|epc_pages
index|[
name|offs
index|]
expr_stmt|;
name|sgx_epc_page_remove
argument_list|(
name|sc
argument_list|,
name|epc
argument_list|)
expr_stmt|;
name|sgx_put_epc_page
argument_list|(
name|sc
argument_list|,
name|epc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sgx_enclave_remove
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|sgx_enclave
modifier|*
name|enclave
parameter_list|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|,
name|p_secs
decl_stmt|,
name|p_next
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|enclaves
argument_list|,
name|enclave
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|object
operator|=
name|enclave
operator|->
name|object
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 	 * First remove all the pages except SECS, 	 * then remove SECS page. 	 */
name|p_secs
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|p
argument_list|,
argument|&object->memq
argument_list|,
argument|listq
argument_list|,
argument|p_next
argument_list|)
block|{
if|if
condition|(
name|p
operator|->
name|pindex
operator|==
name|SGX_SECS_VM_OBJECT_INDEX
condition|)
block|{
name|p_secs
operator|=
name|p
expr_stmt|;
continue|continue;
block|}
name|sgx_page_remove
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Now remove SECS page */
if|if
condition|(
name|p_secs
operator|!=
name|NULL
condition|)
name|sgx_page_remove
argument_list|(
name|sc
argument_list|,
name|p_secs
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|object
operator|->
name|memq
argument_list|)
operator|==
literal|1
argument_list|,
operator|(
literal|"not empty"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|resident_page_count
operator|==
literal|0
argument_list|,
operator|(
literal|"count"
operator|)
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_measure_page
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|epc_page
modifier|*
name|secs
parameter_list|,
name|struct
name|epc_page
modifier|*
name|epc
parameter_list|,
name|uint16_t
name|mrmask
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|1
init|;
name|i
operator|<
name|PAGE_SIZE
condition|;
name|i
operator|+=
literal|0x100
operator|,
name|j
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|j
operator|&
name|mrmask
operator|)
condition|)
continue|continue;
name|ret
operator|=
name|sgx_eextend
argument_list|(
operator|(
name|void
operator|*
operator|)
name|secs
operator|->
name|base
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|epc
operator|->
name|base
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|SGX_EFAULT
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_secs_validate
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|secs
modifier|*
name|secs
parameter_list|)
block|{
name|struct
name|secs_attr
modifier|*
name|attr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|secs
operator|->
name|size
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* BASEADDR must be naturally aligned on an SECS.SIZE boundary. */
if|if
condition|(
name|secs
operator|->
name|base
operator|&
operator|(
name|secs
operator|->
name|size
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* SECS.SIZE must be at least 2 pages. */
if|if
condition|(
name|secs
operator|->
name|size
operator|<
literal|2
operator|*
name|PAGE_SIZE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|secs
operator|->
name|size
operator|&
operator|(
name|secs
operator|->
name|size
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|attr
operator|=
operator|&
name|secs
operator|->
name|attributes
expr_stmt|;
if|if
condition|(
name|attr
operator|->
name|reserved1
operator|!=
literal|0
operator|||
name|attr
operator|->
name|reserved2
operator|!=
literal|0
operator|||
name|attr
operator|->
name|reserved3
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECS_ATTR_RSV4_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|attr
operator|->
name|reserved4
index|[
name|i
index|]
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * IntelÂ® Software Guard Extensions Programming Reference 	 * 6.7.2 Relevant Fields in Various Data Structures 	 * 6.7.2.1 SECS.ATTRIBUTES.XFRM 	 * XFRM[1:0] must be set to 0x3. 	 */
if|if
condition|(
operator|(
name|attr
operator|->
name|xfrm
operator|&
literal|0x3
operator|)
operator|!=
literal|0x3
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|attr
operator|->
name|mode64bit
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|secs
operator|->
name|size
operator|>
name|sc
operator|->
name|enclave_size_max
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECS_RSV1_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|secs
operator|->
name|reserved1
index|[
name|i
index|]
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECS_RSV2_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|secs
operator|->
name|reserved2
index|[
name|i
index|]
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECS_RSV3_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|secs
operator|->
name|reserved3
index|[
name|i
index|]
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECS_RSV4_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|secs
operator|->
name|reserved4
index|[
name|i
index|]
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_tcs_validate
parameter_list|(
name|struct
name|tcs
modifier|*
name|tcs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|tcs
operator|->
name|flags
operator|)
operator|||
operator|(
name|tcs
operator|->
name|ossa
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|tcs
operator|->
name|ofsbasgx
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|tcs
operator|->
name|ogsbasgx
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|tcs
operator|->
name|fslimit
operator|&
literal|0xfff
operator|)
operator|!=
literal|0xfff
operator|)
operator|||
operator|(
operator|(
name|tcs
operator|->
name|gslimit
operator|&
literal|0xfff
operator|)
operator|!=
literal|0xfff
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|tcs
operator|->
name|reserved3
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tcs
operator|->
name|reserved3
index|[
name|i
index|]
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sgx_tcs_dump
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tcs
modifier|*
name|t
parameter_list|)
block|{
name|dprintf
argument_list|(
literal|"t->flags %lx\n"
argument_list|,
name|t
operator|->
name|flags
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"t->ossa %lx\n"
argument_list|,
name|t
operator|->
name|ossa
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"t->cssa %x\n"
argument_list|,
name|t
operator|->
name|cssa
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"t->nssa %x\n"
argument_list|,
name|t
operator|->
name|nssa
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"t->oentry %lx\n"
argument_list|,
name|t
operator|->
name|oentry
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"t->ofsbasgx %lx\n"
argument_list|,
name|t
operator|->
name|ofsbasgx
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"t->ogsbasgx %lx\n"
argument_list|,
name|t
operator|->
name|ogsbasgx
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"t->fslimit %x\n"
argument_list|,
name|t
operator|->
name|fslimit
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"t->gslimit %x\n"
argument_list|,
name|t
operator|->
name|gslimit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_pg_ctor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|vm_ooffset_t
name|size
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_ooffset_t
name|foff
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|u_short
modifier|*
name|color
parameter_list|)
block|{
name|struct
name|sgx_vm_handle
modifier|*
name|vmh
decl_stmt|;
name|vmh
operator|=
name|handle
expr_stmt|;
if|if
condition|(
name|vmh
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: vmh not found.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dprintf
argument_list|(
literal|"%s: vmh->base %lx foff 0x%lx size 0x%lx\n"
argument_list|,
name|__func__
argument_list|,
name|vmh
operator|->
name|base
argument_list|,
name|foff
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sgx_pg_dtor
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|sgx_vm_handle
modifier|*
name|vmh
decl_stmt|;
name|struct
name|sgx_softc
modifier|*
name|sc
decl_stmt|;
name|vmh
operator|=
name|handle
expr_stmt|;
if|if
condition|(
name|vmh
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: vmh not found.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|=
name|vmh
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: sc is NULL\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vmh
operator|->
name|enclave
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: Enclave not found.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|sgx_enclave_remove
argument_list|(
name|sc
argument_list|,
name|vmh
operator|->
name|enclave
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vmh
operator|->
name|enclave
argument_list|,
name|M_SGX
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vmh
argument_list|,
name|M_SGX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_pg_fault
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|int
name|prot
parameter_list|,
name|vm_page_t
modifier|*
name|mres
parameter_list|)
block|{
comment|/* 	 * The purpose of this trivial handler is to handle the race 	 * when user tries to access mmaped region before or during 	 * enclave creation ioctl calls. 	 */
name|dprintf
argument_list|(
literal|"%s: offset 0x%lx\n"
argument_list|,
name|__func__
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cdev_pager_ops
name|sgx_pg_ops
init|=
block|{
operator|.
name|cdev_pg_ctor
operator|=
name|sgx_pg_ctor
block|,
operator|.
name|cdev_pg_dtor
operator|=
name|sgx_pg_dtor
block|,
operator|.
name|cdev_pg_fault
operator|=
name|sgx_pg_fault
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sgx_insert_epc_page_by_index
parameter_list|(
name|vm_page_t
name|page
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pidx
parameter_list|)
block|{
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_page_insert
argument_list|(
name|page
argument_list|,
name|object
argument_list|,
name|pidx
argument_list|)
expr_stmt|;
name|page
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sgx_insert_epc_page
parameter_list|(
name|struct
name|sgx_enclave
modifier|*
name|enclave
parameter_list|,
name|struct
name|epc_page
modifier|*
name|epc
parameter_list|,
name|uint64_t
name|addr
parameter_list|)
block|{
name|vm_pindex_t
name|pidx
decl_stmt|;
name|vm_page_t
name|page
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|enclave
operator|->
name|object
argument_list|)
expr_stmt|;
name|pidx
operator|=
name|OFF_TO_IDX
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|page
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|epc
operator|->
name|phys
argument_list|)
expr_stmt|;
name|sgx_insert_epc_page_by_index
argument_list|(
name|page
argument_list|,
name|enclave
operator|->
name|object
argument_list|,
name|pidx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_ioctl_create
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|sgx_enclave_create
modifier|*
name|param
parameter_list|)
block|{
name|struct
name|sgx_vm_handle
modifier|*
name|vmh
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
name|struct
name|page_info
name|pginfo
decl_stmt|;
name|struct
name|secinfo
name|secinfo
decl_stmt|;
name|struct
name|sgx_enclave
modifier|*
name|enclave
decl_stmt|;
name|struct
name|epc_page
modifier|*
name|epc
decl_stmt|;
name|struct
name|secs
modifier|*
name|secs
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_page_t
name|page
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|epc
operator|=
name|NULL
expr_stmt|;
name|secs
operator|=
name|NULL
expr_stmt|;
name|enclave
operator|=
name|NULL
expr_stmt|;
name|object
operator|=
name|NULL
expr_stmt|;
comment|/* SGX Enclave Control Structure (SECS) */
name|secs
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_SGX
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ret
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|param
operator|->
name|src
argument_list|,
name|secs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: Can't copy SECS.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ret
operator|=
name|sgx_secs_validate
argument_list|(
name|sc
argument_list|,
name|secs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: SECS validation failed.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ret
operator|=
name|sgx_mem_find
argument_list|(
name|sc
argument_list|,
name|secs
operator|->
name|base
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: Can't find vm_map.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|vmh
operator|=
name|object
operator|->
name|handle
expr_stmt|;
if|if
condition|(
operator|!
name|vmh
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: Can't find vmh.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|dprintf
argument_list|(
literal|"%s: entry start %lx offset %lx\n"
argument_list|,
name|__func__
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|offset
argument_list|)
expr_stmt|;
name|vmh
operator|->
name|base
operator|=
operator|(
name|entry
operator|->
name|start
operator|-
name|entry
operator|->
name|offset
operator|)
expr_stmt|;
name|ret
operator|=
name|sgx_enclave_alloc
argument_list|(
name|sc
argument_list|,
name|secs
argument_list|,
operator|&
name|enclave
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: Can't alloc enclave.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|enclave
operator|->
name|object
operator|=
name|object
expr_stmt|;
name|enclave
operator|->
name|vmh
operator|=
name|vmh
expr_stmt|;
name|memset
argument_list|(
operator|&
name|secinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secinfo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|page_info
argument_list|)
argument_list|)
expr_stmt|;
name|pginfo
operator|.
name|linaddr
operator|=
literal|0
expr_stmt|;
name|pginfo
operator|.
name|srcpge
operator|=
operator|(
name|uint64_t
operator|)
name|secs
expr_stmt|;
name|pginfo
operator|.
name|secinfo
operator|=
operator|&
name|secinfo
expr_stmt|;
name|pginfo
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|sgx_get_epc_page
argument_list|(
name|sc
argument_list|,
operator|&
name|epc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: Failed to get free epc page.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|enclave
operator|->
name|secs_epc_page
operator|=
name|epc
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|p
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|SGX_SECS_VM_OBJECT_INDEX
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* SECS page already added. */
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ret
operator|=
name|sgx_va_slot_init_by_index
argument_list|(
name|sc
argument_list|,
name|object
argument_list|,
operator|-
name|SGX_VA_PAGES_OFFS
operator|-
name|SGX_SECS_VM_OBJECT_INDEX
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: Can't init va slot.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|SGX_STATE_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* Remove VA page that was just created for SECS page. */
name|p
operator|=
name|vm_page_lookup
argument_list|(
name|enclave
operator|->
name|object
argument_list|,
operator|-
name|SGX_VA_PAGES_OFFS
operator|-
name|SGX_SECS_VM_OBJECT_INDEX
argument_list|)
expr_stmt|;
name|sgx_page_remove
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sgx_ecreate
argument_list|(
operator|&
name|pginfo
argument_list|,
operator|(
name|void
operator|*
operator|)
name|epc
operator|->
name|base
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|SGX_EFAULT
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: gp fault\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* Remove VA page that was just created for SECS page. */
name|p
operator|=
name|vm_page_lookup
argument_list|(
name|enclave
operator|->
name|object
argument_list|,
operator|-
name|SGX_VA_PAGES_OFFS
operator|-
name|SGX_SECS_VM_OBJECT_INDEX
argument_list|)
expr_stmt|;
name|sgx_page_remove
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|enclaves
argument_list|,
name|enclave
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|vmh
operator|->
name|enclave
operator|=
name|enclave
expr_stmt|;
name|page
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|epc
operator|->
name|phys
argument_list|)
expr_stmt|;
name|sgx_insert_epc_page_by_index
argument_list|(
name|page
argument_list|,
name|enclave
operator|->
name|object
argument_list|,
name|SGX_SECS_VM_OBJECT_INDEX
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* Release the reference. */
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|secs
argument_list|,
name|M_SGX
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|free
argument_list|(
name|secs
argument_list|,
name|M_SGX
argument_list|)
expr_stmt|;
name|sgx_put_epc_page
argument_list|(
name|sc
argument_list|,
name|epc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|enclave
argument_list|,
name|M_SGX
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_ioctl_add_page
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|sgx_enclave_add_page
modifier|*
name|addp
parameter_list|)
block|{
name|struct
name|epc_page
modifier|*
name|secs_epc_page
decl_stmt|;
name|struct
name|sgx_enclave
modifier|*
name|enclave
decl_stmt|;
name|struct
name|sgx_vm_handle
modifier|*
name|vmh
decl_stmt|;
name|struct
name|epc_page
modifier|*
name|epc
decl_stmt|;
name|struct
name|page_info
name|pginfo
decl_stmt|;
name|struct
name|secinfo
name|secinfo
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|void
modifier|*
name|tmp_vaddr
decl_stmt|;
name|uint64_t
name|page_type
decl_stmt|;
name|struct
name|tcs
modifier|*
name|t
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint64_t
name|pidx
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|tmp_vaddr
operator|=
name|NULL
expr_stmt|;
name|epc
operator|=
name|NULL
expr_stmt|;
name|object
operator|=
name|NULL
expr_stmt|;
comment|/* Find and get reference to VM object. */
name|ret
operator|=
name|sgx_enclave_find
argument_list|(
name|sc
argument_list|,
name|addp
operator|->
name|addr
argument_list|,
operator|&
name|enclave
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: Failed to find enclave.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|object
operator|=
name|enclave
operator|->
name|object
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|!=
name|NULL
argument_list|,
operator|(
literal|"vm object is NULL\n"
operator|)
argument_list|)
expr_stmt|;
name|vmh
operator|=
name|object
operator|->
name|handle
expr_stmt|;
name|ret
operator|=
name|sgx_get_epc_page
argument_list|(
name|sc
argument_list|,
operator|&
name|epc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: Failed to get free epc page.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|memset
argument_list|(
operator|&
name|secinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secinfo
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addp
operator|->
name|secinfo
argument_list|,
operator|&
name|secinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: Failed to copy secinfo.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|tmp_vaddr
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_SGX
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ret
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addp
operator|->
name|src
argument_list|,
name|tmp_vaddr
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: Failed to copy page.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|page_type
operator|=
operator|(
name|secinfo
operator|.
name|flags
operator|&
name|SECINFO_FLAGS_PT_M
operator|)
operator|>>
name|SECINFO_FLAGS_PT_S
expr_stmt|;
if|if
condition|(
name|page_type
operator|!=
name|SGX_PT_TCS
operator|&&
name|page_type
operator|!=
name|SGX_PT_REG
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: page can't be added.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|page_type
operator|==
name|SGX_PT_TCS
condition|)
block|{
name|t
operator|=
operator|(
expr|struct
name|tcs
operator|*
operator|)
name|tmp_vaddr
expr_stmt|;
name|ret
operator|=
name|sgx_tcs_validate
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: TCS page validation failed.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|sgx_tcs_dump
argument_list|(
name|sc
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
operator|(
name|addp
operator|->
name|addr
operator|-
name|vmh
operator|->
name|base
operator|)
expr_stmt|;
name|pidx
operator|=
name|OFF_TO_IDX
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|p
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|pidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* Page already added. */
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ret
operator|=
name|sgx_va_slot_init
argument_list|(
name|sc
argument_list|,
name|enclave
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: Can't init va slot.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|secs_epc_page
operator|=
name|enclave
operator|->
name|secs_epc_page
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|page_info
argument_list|)
argument_list|)
expr_stmt|;
name|pginfo
operator|.
name|linaddr
operator|=
operator|(
name|uint64_t
operator|)
name|addp
operator|->
name|addr
expr_stmt|;
name|pginfo
operator|.
name|srcpge
operator|=
operator|(
name|uint64_t
operator|)
name|tmp_vaddr
expr_stmt|;
name|pginfo
operator|.
name|secinfo
operator|=
operator|&
name|secinfo
expr_stmt|;
name|pginfo
operator|.
name|secs
operator|=
operator|(
name|uint64_t
operator|)
name|secs_epc_page
operator|->
name|base
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sgx_eadd
argument_list|(
operator|&
name|pginfo
argument_list|,
operator|(
name|void
operator|*
operator|)
name|epc
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|SGX_EFAULT
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: gp fault on eadd\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sgx_measure_page
argument_list|(
name|sc
argument_list|,
name|enclave
operator|->
name|secs_epc_page
argument_list|,
name|epc
argument_list|,
name|addp
operator|->
name|mrmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|SGX_EFAULT
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: gp fault on eextend\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sgx_epc_page_remove
argument_list|(
name|sc
argument_list|,
name|epc
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|sgx_insert_epc_page
argument_list|(
name|enclave
argument_list|,
name|epc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* Release the reference. */
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_vaddr
argument_list|,
name|M_SGX
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|free
argument_list|(
name|tmp_vaddr
argument_list|,
name|M_SGX
argument_list|)
expr_stmt|;
name|sgx_put_epc_page
argument_list|(
name|sc
argument_list|,
name|epc
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_ioctl_init
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|sgx_enclave_init
modifier|*
name|initp
parameter_list|)
block|{
name|struct
name|epc_page
modifier|*
name|secs_epc_page
decl_stmt|;
name|struct
name|sgx_enclave
modifier|*
name|enclave
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|void
modifier|*
name|tmp_vaddr
decl_stmt|;
name|void
modifier|*
name|einittoken
decl_stmt|;
name|void
modifier|*
name|sigstruct
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|tmp_vaddr
operator|=
name|NULL
expr_stmt|;
name|object
operator|=
name|NULL
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: addr %lx, sigstruct %lx, einittoken %lx\n"
argument_list|,
name|__func__
argument_list|,
name|initp
operator|->
name|addr
argument_list|,
name|initp
operator|->
name|sigstruct
argument_list|,
name|initp
operator|->
name|einittoken
argument_list|)
expr_stmt|;
comment|/* Find and get reference to VM object. */
name|ret
operator|=
name|sgx_enclave_find
argument_list|(
name|sc
argument_list|,
name|initp
operator|->
name|addr
argument_list|,
operator|&
name|enclave
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: Failed to find enclave.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|object
operator|=
name|enclave
operator|->
name|object
expr_stmt|;
name|tmp_vaddr
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_SGX
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sigstruct
operator|=
name|tmp_vaddr
expr_stmt|;
name|einittoken
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uint64_t
operator|)
name|sigstruct
operator|+
name|PAGE_SIZE
operator|/
literal|2
operator|)
expr_stmt|;
name|ret
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|initp
operator|->
name|sigstruct
argument_list|,
name|sigstruct
argument_list|,
name|SGX_SIGSTRUCT_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: Failed to copy SIGSTRUCT page.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ret
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|initp
operator|->
name|einittoken
argument_list|,
name|einittoken
argument_list|,
name|SGX_EINITTOKEN_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: Failed to copy EINITTOKEN page.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|secs_epc_page
operator|=
name|enclave
operator|->
name|secs_epc_page
expr_stmt|;
name|retry
operator|=
literal|16
expr_stmt|;
do|do
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sgx_einit
argument_list|(
name|sigstruct
argument_list|,
operator|(
name|void
operator|*
operator|)
name|secs_epc_page
operator|->
name|base
argument_list|,
name|einittoken
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: sgx_einit returned %d\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|SGX_UNMASKED_EVENT
operator|&&
name|retry
operator|--
condition|)
do|;
if|if
condition|(
name|ret
condition|)
block|{
name|dprintf
argument_list|(
literal|"%s: Failed init enclave: %d\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|ret
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|error
label|:
name|free
argument_list|(
name|tmp_vaddr
argument_list|,
name|M_SGX
argument_list|)
expr_stmt|;
comment|/* Release the reference. */
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|sgx_enclave_add_page
modifier|*
name|addp
decl_stmt|;
name|struct
name|sgx_enclave_create
modifier|*
name|param
decl_stmt|;
name|struct
name|sgx_enclave_init
modifier|*
name|initp
decl_stmt|;
name|struct
name|sgx_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|len
decl_stmt|;
name|sc
operator|=
operator|&
name|sgx_sc
expr_stmt|;
name|len
operator|=
name|IOCPARM_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: cmd %lx, addr %lx, len %d\n"
argument_list|,
name|__func__
argument_list|,
name|cmd
argument_list|,
operator|(
name|uint64_t
operator|)
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|SGX_IOCTL_MAX_DATA_LEN
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SGX_IOC_ENCLAVE_CREATE
case|:
name|param
operator|=
operator|(
expr|struct
name|sgx_enclave_create
operator|*
operator|)
name|addr
expr_stmt|;
name|ret
operator|=
name|sgx_ioctl_create
argument_list|(
name|sc
argument_list|,
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGX_IOC_ENCLAVE_ADD_PAGE
case|:
name|addp
operator|=
operator|(
expr|struct
name|sgx_enclave_add_page
operator|*
operator|)
name|addr
expr_stmt|;
name|ret
operator|=
name|sgx_ioctl_add_page
argument_list|(
name|sc
argument_list|,
name|addp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGX_IOC_ENCLAVE_INIT
case|:
name|initp
operator|=
operator|(
expr|struct
name|sgx_enclave_init
operator|*
operator|)
name|addr
expr_stmt|;
name|ret
operator|=
name|sgx_ioctl_init
argument_list|(
name|sc
argument_list|,
name|initp
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_mmap_single
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|,
name|vm_ooffset_t
modifier|*
name|offset
parameter_list|,
name|vm_size_t
name|mapsize
parameter_list|,
name|struct
name|vm_object
modifier|*
modifier|*
name|objp
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|struct
name|sgx_vm_handle
modifier|*
name|vmh
decl_stmt|;
name|struct
name|sgx_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|&
name|sgx_sc
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: mapsize 0x%lx, offset %lx\n"
argument_list|,
name|__func__
argument_list|,
name|mapsize
argument_list|,
operator|*
name|offset
argument_list|)
expr_stmt|;
name|vmh
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sgx_vm_handle
argument_list|)
argument_list|,
name|M_SGX
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vmh
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|vmh
operator|->
name|size
operator|=
name|mapsize
expr_stmt|;
name|vmh
operator|->
name|mem
operator|=
name|cdev_pager_allocate
argument_list|(
name|vmh
argument_list|,
name|OBJT_MGTDEVICE
argument_list|,
operator|&
name|sgx_pg_ops
argument_list|,
name|mapsize
argument_list|,
name|nprot
argument_list|,
operator|*
name|offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmh
operator|->
name|mem
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|vmh
argument_list|,
name|M_SGX
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|VM_OBJECT_WLOCK
argument_list|(
name|vmh
operator|->
name|mem
argument_list|)
expr_stmt|;
name|vm_object_set_flag
argument_list|(
name|vmh
operator|->
name|mem
argument_list|,
name|OBJ_PG_DTOR
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vmh
operator|->
name|mem
argument_list|)
expr_stmt|;
operator|*
name|objp
operator|=
name|vmh
operator|->
name|mem
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|sgx_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_ioctl
operator|=
name|sgx_ioctl
block|,
operator|.
name|d_mmap_single
operator|=
name|sgx_mmap_single
block|,
operator|.
name|d_name
operator|=
literal|"Intel SGX"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sgx_get_epc_area
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|)
block|{
name|vm_offset_t
name|epc_base_vaddr
decl_stmt|;
name|u_int
name|cp
index|[
literal|4
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cpuid_count
argument_list|(
name|SGX_CPUID
argument_list|,
literal|0x2
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|epc_base
operator|=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|cp
index|[
literal|1
index|]
operator|&
literal|0xfffff
argument_list|)
operator|<<
literal|32
operator|)
operator|+
operator|(
name|cp
index|[
literal|0
index|]
operator|&
literal|0xfffff000
operator|)
expr_stmt|;
name|sc
operator|->
name|epc_size
operator|=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|cp
index|[
literal|3
index|]
operator|&
literal|0xfffff
argument_list|)
operator|<<
literal|32
operator|)
operator|+
operator|(
name|cp
index|[
literal|2
index|]
operator|&
literal|0xfffff000
operator|)
expr_stmt|;
name|sc
operator|->
name|npages
operator|=
name|sc
operator|->
name|epc_size
operator|/
name|SGX_PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|3
index|]
operator|&
literal|0xffff
condition|)
name|sc
operator|->
name|enclave_size_max
operator|=
operator|(
literal|1
operator|<<
operator|(
operator|(
name|cp
index|[
literal|3
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
else|else
name|sc
operator|->
name|enclave_size_max
operator|=
name|SGX_ENCL_SIZE_MAX_DEF
expr_stmt|;
name|epc_base_vaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|pmap_mapdev_attr
argument_list|(
name|sc
operator|->
name|epc_base
argument_list|,
name|sc
operator|->
name|epc_size
argument_list|,
name|VM_MEMATTR_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|epc_pages
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|epc_page
argument_list|)
operator|*
name|sc
operator|->
name|npages
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|epc_pages
index|[
name|i
index|]
operator|.
name|base
operator|=
name|epc_base_vaddr
operator|+
name|SGX_PAGE_SIZE
operator|*
name|i
expr_stmt|;
name|sc
operator|->
name|epc_pages
index|[
name|i
index|]
operator|.
name|phys
operator|=
name|sc
operator|->
name|epc_base
operator|+
name|SGX_PAGE_SIZE
operator|*
name|i
expr_stmt|;
name|sc
operator|->
name|epc_pages
index|[
name|i
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
name|sc
operator|->
name|vmem_epc
operator|=
name|vmem_create
argument_list|(
literal|"SGX EPC"
argument_list|,
name|sc
operator|->
name|epc_base
argument_list|,
name|sc
operator|->
name|epc_size
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PAGE_SIZE
argument_list|,
name|M_FIRSTFIT
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vmem_epc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Can't create vmem arena.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|epc_pages
argument_list|,
name|M_SGX
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|vm_phys_fictitious_reg_range
argument_list|(
name|sc
operator|->
name|epc_base
argument_list|,
name|sc
operator|->
name|epc_base
operator|+
name|sc
operator|->
name|epc_size
argument_list|,
name|VM_MEMATTR_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Can't register fictitious space.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|epc_pages
argument_list|,
name|M_SGX
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sgx_put_epc_area
parameter_list|(
name|struct
name|sgx_softc
modifier|*
name|sc
parameter_list|)
block|{
name|vm_phys_fictitious_unreg_range
argument_list|(
name|sc
operator|->
name|epc_base
argument_list|,
name|sc
operator|->
name|epc_base
operator|+
name|sc
operator|->
name|epc_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|epc_pages
argument_list|,
name|M_SGX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_load
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sgx_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
operator|&
name|sgx_sc
expr_stmt|;
if|if
condition|(
operator|(
name|cpu_stdext_feature
operator|&
name|CPUID_STDEXT_SGX
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
name|sgx_get_epc_area
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Failed to get Processor Reserved Memory area.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|,
literal|"SGX ENCLS"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
literal|"SGX driver"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|enclaves
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sgx_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|sgx_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"isgx"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator||=
name|SGX_STATE_RUNNING
expr_stmt|;
name|printf
argument_list|(
literal|"SGX initialized: EPC base 0x%lx size %ld (%d pages)\n"
argument_list|,
name|sc
operator|->
name|epc_base
argument_list|,
name|sc
operator|->
name|epc_size
argument_list|,
name|sc
operator|->
name|npages
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_unload
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sgx_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|&
name|sgx_sc
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|SGX_STATE_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|enclaves
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|sc
operator|->
name|state
operator|&=
operator|~
name|SGX_STATE_RUNNING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|sc
operator|->
name|sgx_cdev
argument_list|)
expr_stmt|;
name|vmem_destroy
argument_list|(
name|sc
operator|->
name|vmem_epc
argument_list|)
expr_stmt|;
name|sgx_put_epc_area
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mtx_encls
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgx_handler
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
name|sgx_load
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|error
operator|=
name|sgx_unload
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|sgx_kmod
init|=
block|{
literal|"sgx"
block|,
name|sgx_handler
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|sgx
argument_list|,
name|sgx_kmod
argument_list|,
name|SI_SUB_LAST
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|sgx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

