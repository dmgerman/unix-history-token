begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 John Baldwin<jhb@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Support for PCI Message Signalled Interrupts (MSI).  MSI interrupts on  * x86 are basically APIC messages that the northbridge delivers directly  * to the local APICs as if they had come from an I/O APIC.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/apicvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_comment
comment|/* Fields in address for Intel MSI messages. */
end_comment

begin_define
define|#
directive|define
name|MSI_INTEL_ADDR_DEST
value|0x000ff000
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_ADDR_RH
value|0x00000008
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_ADDR_RH_ON
value|0x00000008
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_ADDR_RH_OFF
value|0x00000000
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_ADDR_DM
value|0x00000004
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_ADDR_DM_PHYSICAL
value|0x00000000
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_ADDR_DM_LOGICAL
value|0x00000004
end_define

begin_comment
comment|/* Fields in data for Intel MSI messages. */
end_comment

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_TRGRMOD
value|IOART_TRGRMOD
end_define

begin_comment
comment|/* Trigger mode. */
end_comment

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_TRGREDG
value|IOART_TRGREDG
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_TRGRLVL
value|IOART_TRGRLVL
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_LEVEL
value|0x00004000
end_define

begin_comment
comment|/* Polarity. */
end_comment

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DEASSERT
value|0x00000000
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_ASSERT
value|0x00004000
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DELMOD
value|IOART_DELMOD
end_define

begin_comment
comment|/* Delivery mode. */
end_comment

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DELFIXED
value|IOART_DELFIXED
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DELLOPRI
value|IOART_DELLOPRI
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DELSMI
value|IOART_DELSMI
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DELNMI
value|IOART_DELNMI
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DELINIT
value|IOART_DELINIT
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DELEXINT
value|IOART_DELEXINT
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_INTVEC
value|IOART_INTVEC
end_define

begin_comment
comment|/* Interrupt vector. */
end_comment

begin_comment
comment|/*  * Build Intel MSI message and data values from a source.  AMD64 systems  * seem to be compatible, so we use the same function for both.  */
end_comment

begin_define
define|#
directive|define
name|INTEL_ADDR
parameter_list|(
name|msi
parameter_list|)
define|\
value|(MSI_INTEL_ADDR_BASE | (msi)->msi_cpu<< 12 |			\ 	    MSI_INTEL_ADDR_RH_OFF | MSI_INTEL_ADDR_DM_PHYSICAL)
end_define

begin_define
define|#
directive|define
name|INTEL_DATA
parameter_list|(
name|msi
parameter_list|)
define|\
value|(MSI_INTEL_DATA_TRGREDG | MSI_INTEL_DATA_DELFIXED | (msi)->msi_vector)
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MSI
argument_list|,
literal|"msi"
argument_list|,
literal|"PCI MSI"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * MSI sources are bunched into groups.  This is because MSI forces  * all of the messages to share the address and data registers and  * thus certain properties (such as the local APIC ID target on x86).  * Each group has a 'first' source that contains information global to  * the group.  These fields are marked with (g) below.  *  * Note that local APIC ID is kind of special.  Each message will be  * assigned an ID by the system; however, a group will use the ID from  * the first message.  *  * For MSI-X, each message is isolated, and msi_index indicates the  * index of this message in the device's MSI-X table.  */
end_comment

begin_struct
struct|struct
name|msi_intsrc
block|{
name|struct
name|intsrc
name|msi_intsrc
decl_stmt|;
name|device_t
name|msi_dev
decl_stmt|;
comment|/* Owning device. (g) */
name|struct
name|msi_intsrc
modifier|*
name|msi_first
decl_stmt|;
comment|/* First source in group. */
name|u_int
name|msi_irq
decl_stmt|;
comment|/* IRQ cookie. */
name|u_int
name|msi_index
decl_stmt|;
comment|/* Index of this message. */
name|u_int
name|msi_msix
decl_stmt|;
comment|/* MSI-X message. */
name|u_int
name|msi_vector
range|:
literal|8
decl_stmt|;
comment|/* IDT vector. */
name|u_int
name|msi_cpu
range|:
literal|8
decl_stmt|;
comment|/* Local APIC ID. (g) */
name|u_int
name|msi_count
range|:
literal|8
decl_stmt|;
comment|/* Messages in this group. (g) */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|msi_enable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msi_disable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|int
name|eoi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msi_eoi_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msi_enable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msi_vector
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msi_source_pending
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msi_config_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msi_assign_cpu
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|u_int
name|apic_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msix_enable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msix_source_pending
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msix_assign_cpu
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|u_int
name|apic_id
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|pic
name|msi_pic
init|=
block|{
name|msi_enable_source
block|,
name|msi_disable_source
block|,
name|msi_eoi_source
block|,
name|msi_enable_intr
block|,
name|msi_vector
block|,
name|msi_source_pending
block|,
name|NULL
block|,
name|NULL
block|,
name|msi_config_intr
block|,
name|msi_assign_cpu
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pic
name|msix_pic
init|=
block|{
name|msi_enable_source
block|,
name|msi_disable_source
block|,
name|msi_eoi_source
block|,
name|msix_enable_intr
block|,
name|msi_vector
block|,
name|msix_source_pending
block|,
name|NULL
block|,
name|NULL
block|,
name|msi_config_intr
block|,
name|msix_assign_cpu
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msi_enabled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|msi_sx
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|msi_enable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|msi_disable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|int
name|eoi
parameter_list|)
block|{
if|if
condition|(
name|eoi
operator|==
name|PIC_EOI
condition|)
name|lapic_eoi
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msi_eoi_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|lapic_eoi
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msi_enable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
init|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
comment|/* 	 * Since we can only enable the entire group at once, go ahead and 	 * enable the messages when the first message is given a handler. 	 * Note that we assume all devices will register a handler for the 	 * first message. 	 */
if|if
condition|(
name|msi
operator|->
name|msi_index
operator|==
literal|0
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
name|pci_enable_msi
argument_list|(
name|msi
operator|->
name|msi_dev
argument_list|,
name|INTEL_ADDR
argument_list|(
name|msi
argument_list|)
argument_list|,
name|INTEL_DATA
argument_list|(
name|msi
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
block|}
name|apic_enable_vector
argument_list|(
name|msi
operator|->
name|msi_vector
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|msi_vector
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
init|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
return|return
operator|(
name|msi
operator|->
name|msi_irq
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msi_source_pending
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msi_config_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msi_assign_cpu
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|u_int
name|apic_id
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
init|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|msi
operator|->
name|msi_cpu
operator|=
name|apic_id
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"msi: Assigning MSI IRQ %d to local APIC %u\n"
argument_list|,
name|msi
operator|->
name|msi_irq
argument_list|,
name|msi
operator|->
name|msi_cpu
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|isrc
operator|->
name|is_enabled
condition|)
name|pci_enable_msi
argument_list|(
name|msi
operator|->
name|msi_dev
argument_list|,
name|INTEL_ADDR
argument_list|(
name|msi
argument_list|)
argument_list|,
name|INTEL_DATA
argument_list|(
name|msi
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msix_enable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
init|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
name|pci_enable_msix
argument_list|(
name|msi
operator|->
name|msi_dev
argument_list|,
name|msi
operator|->
name|msi_index
argument_list|,
name|INTEL_ADDR
argument_list|(
name|msi
argument_list|)
argument_list|,
name|INTEL_DATA
argument_list|(
name|msi
argument_list|)
argument_list|)
expr_stmt|;
name|pci_unmask_msix
argument_list|(
name|msi
operator|->
name|msi_dev
argument_list|,
name|msi
operator|->
name|msi_index
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
name|apic_enable_vector
argument_list|(
name|msi
operator|->
name|msi_vector
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|msix_source_pending
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
init|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
return|return
operator|(
name|pci_pending_msix
argument_list|(
name|msi
operator|->
name|msi_dev
argument_list|,
name|msi
operator|->
name|msi_index
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msix_assign_cpu
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|u_int
name|apic_id
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
init|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|msi
operator|->
name|msi_cpu
operator|=
name|apic_id
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"msi: Assigning MSI-X IRQ %d to local APIC %u\n"
argument_list|,
name|msi
operator|->
name|msi_irq
argument_list|,
name|msi
operator|->
name|msi_cpu
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|isrc
operator|->
name|is_enabled
condition|)
name|pci_enable_msix
argument_list|(
name|msi
operator|->
name|msi_dev
argument_list|,
name|msi
operator|->
name|msi_index
argument_list|,
name|INTEL_ADDR
argument_list|(
name|msi
argument_list|)
argument_list|,
name|INTEL_DATA
argument_list|(
name|msi
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|msi_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Check if we have a supported CPU. */
if|if
condition|(
operator|!
operator|(
name|strcmp
argument_list|(
name|cpu_vendor
argument_list|,
literal|"GenuineIntel"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|cpu_vendor
argument_list|,
literal|"AuthenticAMD"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return;
name|msi_enabled
operator|=
literal|1
expr_stmt|;
name|intr_register_pic
argument_list|(
operator|&
name|msi_pic
argument_list|)
expr_stmt|;
name|intr_register_pic
argument_list|(
operator|&
name|msix_pic
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|msi_sx
argument_list|,
literal|"msi"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to allocate 'count' interrupt sources with contiguous IDT values.  If  * we allocate any new sources, then their IRQ values will be at the end of  * the irqs[] array, with *newirq being the index of the first new IRQ value  * and *newcount being the number of new IRQ values added.  */
end_comment

begin_function
name|int
name|msi_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|maxcount
parameter_list|,
name|int
modifier|*
name|irqs
parameter_list|,
name|int
modifier|*
name|newirq
parameter_list|,
name|int
modifier|*
name|newcount
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
decl_stmt|,
modifier|*
name|fsrc
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|vector
decl_stmt|;
operator|*
name|newirq
operator|=
literal|0
expr_stmt|;
operator|*
name|newcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|msi_enabled
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
comment|/* Try to find 'count' free IRQs. */
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_MSI_INT
init|;
name|i
operator|<
name|FIRST_MSI_INT
operator|+
name|NUM_MSI_INTS
condition|;
name|i
operator|++
control|)
block|{
name|msi
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* End of allocated sources, so break. */
if|if
condition|(
name|msi
operator|==
name|NULL
condition|)
break|break;
comment|/* If this is a free one, save its IRQ in the array. */
if|if
condition|(
name|msi
operator|->
name|msi_dev
operator|==
name|NULL
condition|)
block|{
name|irqs
index|[
name|cnt
index|]
operator|=
name|i
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
name|count
condition|)
break|break;
block|}
block|}
comment|/* Do we need to create some new sources? */
if|if
condition|(
name|cnt
operator|<
name|count
condition|)
block|{
comment|/* If we would exceed the max, give up. */
if|if
condition|(
name|i
operator|+
operator|(
name|count
operator|-
name|cnt
operator|)
operator|>
name|FIRST_MSI_INT
operator|+
name|NUM_MSI_INTS
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* We need count - cnt more sources starting at index 'cnt'. */
operator|*
name|newirq
operator|=
name|cnt
expr_stmt|;
operator|*
name|newcount
operator|=
name|count
operator|-
name|cnt
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|*
name|newcount
condition|;
name|j
operator|++
control|)
block|{
comment|/* Create a new MSI source. */
name|msi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msi_intsrc
argument_list|)
argument_list|,
name|M_MSI
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|msi
operator|->
name|msi_intsrc
operator|.
name|is_pic
operator|=
operator|&
name|msi_pic
expr_stmt|;
name|msi
operator|->
name|msi_irq
operator|=
name|i
operator|+
name|j
expr_stmt|;
name|intr_register_source
argument_list|(
operator|&
name|msi
operator|->
name|msi_intsrc
argument_list|)
expr_stmt|;
comment|/* Add it to our array. */
name|irqs
index|[
name|cnt
index|]
operator|=
name|i
operator|+
name|j
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
block|}
comment|/* Ok, we now have the IRQs allocated. */
name|KASSERT
argument_list|(
name|cnt
operator|==
name|count
argument_list|,
operator|(
literal|"count mismatch"
operator|)
argument_list|)
expr_stmt|;
comment|/* Allocate 'count' IDT vectors. */
name|vector
operator|=
name|apic_alloc_vectors
argument_list|(
name|irqs
argument_list|,
name|count
argument_list|,
name|maxcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|vector
operator|==
literal|0
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
comment|/* Assign IDT vectors and make these messages owned by 'dev'. */
name|fsrc
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|irqs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|msi
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|irqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|msi
operator|->
name|msi_intsrc
operator|.
name|is_pic
operator|=
operator|&
name|msi_pic
expr_stmt|;
name|msi
operator|->
name|msi_dev
operator|=
name|dev
expr_stmt|;
name|msi
operator|->
name|msi_vector
operator|=
name|vector
operator|+
name|i
expr_stmt|;
name|msi
operator|->
name|msi_index
operator|=
name|i
expr_stmt|;
name|msi
operator|->
name|msi_first
operator|=
name|fsrc
expr_stmt|;
comment|/* XXX: Somewhat gross. */
name|msi
operator|->
name|msi_intsrc
operator|.
name|is_enabled
operator|=
literal|0
expr_stmt|;
block|}
name|fsrc
operator|->
name|msi_count
operator|=
name|count
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|msi_release
parameter_list|(
name|int
modifier|*
name|irqs
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
decl_stmt|,
modifier|*
name|first
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
name|first
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|irqs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Make sure this isn't an MSI-X message. */
if|if
condition|(
name|first
operator|->
name|msi_msix
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Make sure this message is allocated to a group. */
if|if
condition|(
name|first
operator|->
name|msi_first
operator|==
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Make sure this is the start of a group and that we are releasing 	 * the entire group. 	 */
if|if
condition|(
name|first
operator|->
name|msi_first
operator|!=
name|first
operator|||
name|first
operator|->
name|msi_count
operator|!=
name|count
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|first
operator|->
name|msi_index
operator|==
literal|0
argument_list|,
operator|(
literal|"index mismatch"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|first
operator|->
name|msi_dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unowned group"
operator|)
argument_list|)
expr_stmt|;
comment|/* Clear all the extra messages in the group. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|msi
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|irqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|msi
operator|->
name|msi_first
operator|==
name|first
argument_list|,
operator|(
literal|"message not in group"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|msi
operator|->
name|msi_dev
operator|==
name|first
operator|->
name|msi_dev
argument_list|,
operator|(
literal|"owner mismatch"
operator|)
argument_list|)
expr_stmt|;
name|msi
operator|->
name|msi_first
operator|=
name|NULL
expr_stmt|;
name|msi
operator|->
name|msi_dev
operator|=
name|NULL
expr_stmt|;
name|apic_free_vector
argument_list|(
name|msi
operator|->
name|msi_vector
argument_list|,
name|msi
operator|->
name|msi_irq
argument_list|)
expr_stmt|;
name|msi
operator|->
name|msi_vector
operator|=
literal|0
expr_stmt|;
name|msi
operator|->
name|msi_index
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Clear out the first message. */
name|first
operator|->
name|msi_first
operator|=
name|NULL
expr_stmt|;
name|first
operator|->
name|msi_dev
operator|=
name|NULL
expr_stmt|;
name|apic_free_vector
argument_list|(
name|first
operator|->
name|msi_vector
argument_list|,
name|first
operator|->
name|msi_irq
argument_list|)
expr_stmt|;
name|first
operator|->
name|msi_vector
operator|=
literal|0
expr_stmt|;
name|first
operator|->
name|msi_count
operator|=
literal|0
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|msix_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|index
parameter_list|,
name|int
modifier|*
name|irq
parameter_list|,
name|int
modifier|*
name|new
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
decl_stmt|;
name|int
name|i
decl_stmt|,
name|vector
decl_stmt|;
operator|*
name|new
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|msi_enabled
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
comment|/* Find a free IRQ. */
for|for
control|(
name|i
operator|=
name|FIRST_MSI_INT
init|;
name|i
operator|<
name|FIRST_MSI_INT
operator|+
name|NUM_MSI_INTS
condition|;
name|i
operator|++
control|)
block|{
name|msi
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* End of allocated sources, so break. */
if|if
condition|(
name|msi
operator|==
name|NULL
condition|)
break|break;
comment|/* If this is a free one, start or continue a run. */
if|if
condition|(
name|msi
operator|->
name|msi_dev
operator|==
name|NULL
condition|)
break|break;
block|}
comment|/* Do we need to create a new source? */
if|if
condition|(
name|msi
operator|==
name|NULL
condition|)
block|{
comment|/* If we would exceed the max, give up. */
if|if
condition|(
name|i
operator|+
literal|1
operator|>
name|FIRST_MSI_INT
operator|+
name|NUM_MSI_INTS
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Create a new source. */
operator|*
name|new
operator|=
literal|1
expr_stmt|;
name|msi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msi_intsrc
argument_list|)
argument_list|,
name|M_MSI
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|msi
operator|->
name|msi_intsrc
operator|.
name|is_pic
operator|=
operator|&
name|msix_pic
expr_stmt|;
name|msi
operator|->
name|msi_irq
operator|=
name|i
expr_stmt|;
name|intr_register_source
argument_list|(
operator|&
name|msi
operator|->
name|msi_intsrc
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate an IDT vector. */
name|vector
operator|=
name|apic_alloc_vector
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Setup source. */
name|msi
operator|->
name|msi_intsrc
operator|.
name|is_pic
operator|=
operator|&
name|msix_pic
expr_stmt|;
name|msi
operator|->
name|msi_dev
operator|=
name|dev
expr_stmt|;
name|msi
operator|->
name|msi_vector
operator|=
name|vector
expr_stmt|;
name|msi
operator|->
name|msi_index
operator|=
name|index
expr_stmt|;
name|msi
operator|->
name|msi_msix
operator|=
literal|1
expr_stmt|;
comment|/* XXX: Somewhat gross. */
name|msi
operator|->
name|msi_intsrc
operator|.
name|is_enabled
operator|=
literal|0
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
operator|*
name|irq
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|msix_remap
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
name|msi
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|msi
operator|==
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Make sure this is an MSI-X message. */
if|if
condition|(
operator|!
name|msi
operator|->
name|msi_msix
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|msi
operator|->
name|msi_dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unowned message"
operator|)
argument_list|)
expr_stmt|;
name|msi
operator|->
name|msi_index
operator|=
name|index
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|msix_release
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
name|msi
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|msi
operator|==
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Make sure this is an MSI-X message. */
if|if
condition|(
operator|!
name|msi
operator|->
name|msi_msix
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|msi
operator|->
name|msi_dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unowned message"
operator|)
argument_list|)
expr_stmt|;
comment|/* Clear out the message. */
name|msi
operator|->
name|msi_dev
operator|=
name|NULL
expr_stmt|;
name|apic_free_vector
argument_list|(
name|msi
operator|->
name|msi_vector
argument_list|,
name|msi
operator|->
name|msi_irq
argument_list|)
expr_stmt|;
name|msi
operator|->
name|msi_vector
operator|=
literal|0
expr_stmt|;
name|msi
operator|->
name|msi_index
operator|=
literal|0
expr_stmt|;
name|msi
operator|->
name|msi_msix
operator|=
literal|0
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|msi_sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

