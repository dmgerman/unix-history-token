begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1994, David Greenman  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the University of Utah, and William Jolitz.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)trap.c	7.4 (Berkeley) 5/13/91  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * AMD64 Trap and System call handling  */
end_comment

begin_include
include|#
directive|include
file|"opt_clock.h"
end_include

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_isa.h"
end_include

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/tss.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_function_decl
specifier|extern
name|void
name|trap
parameter_list|(
name|struct
name|trapframe
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|syscall
parameter_list|(
name|struct
name|trapframe
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trap_pfault
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trap_fatal
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dblfault_handler
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAX_TRAP_MSG
value|28
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|trap_msg
index|[]
init|=
block|{
literal|""
block|,
comment|/*  0 unused */
literal|"privileged instruction fault"
block|,
comment|/*  1 T_PRIVINFLT */
literal|""
block|,
comment|/*  2 unused */
literal|"breakpoint instruction fault"
block|,
comment|/*  3 T_BPTFLT */
literal|""
block|,
comment|/*  4 unused */
literal|""
block|,
comment|/*  5 unused */
literal|"arithmetic trap"
block|,
comment|/*  6 T_ARITHTRAP */
literal|""
block|,
comment|/*  7 unused */
literal|""
block|,
comment|/*  8 unused */
literal|"general protection fault"
block|,
comment|/*  9 T_PROTFLT */
literal|"trace trap"
block|,
comment|/* 10 T_TRCTRAP */
literal|""
block|,
comment|/* 11 unused */
literal|"page fault"
block|,
comment|/* 12 T_PAGEFLT */
literal|""
block|,
comment|/* 13 unused */
literal|"alignment fault"
block|,
comment|/* 14 T_ALIGNFLT */
literal|""
block|,
comment|/* 15 unused */
literal|""
block|,
comment|/* 16 unused */
literal|""
block|,
comment|/* 17 unused */
literal|"integer divide fault"
block|,
comment|/* 18 T_DIVIDE */
literal|"non-maskable interrupt trap"
block|,
comment|/* 19 T_NMI */
literal|"overflow trap"
block|,
comment|/* 20 T_OFLOW */
literal|"FPU bounds check fault"
block|,
comment|/* 21 T_BOUND */
literal|"FPU device not available"
block|,
comment|/* 22 T_DNA */
literal|"double fault"
block|,
comment|/* 23 T_DOUBLEFLT */
literal|"FPU operand fetch fault"
block|,
comment|/* 24 T_FPOPFLT */
literal|"invalid TSS fault"
block|,
comment|/* 25 T_TSSFLT */
literal|"segment not present fault"
block|,
comment|/* 26 T_SEGNPFLT */
literal|"stack fault"
block|,
comment|/* 27 T_STKFLT */
literal|"machine check trap"
block|,
comment|/* 28 T_MCHK */
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ddb_on_nmi
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|ddb_on_nmi
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ddb_on_nmi
argument_list|,
literal|0
argument_list|,
literal|"Go to DDB on NMI"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|panic_on_nmi
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|panic_on_nmi
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|panic_on_nmi
argument_list|,
literal|0
argument_list|,
literal|"Panic on NMI"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|WITNESS
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|syscallnames
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_decl_stmt
specifier|extern
name|u_int32_t
name|poll_in_trap
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|ether_poll
parameter_list|(
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVICE_POLLING */
end_comment

begin_comment
comment|/*  * Exception, fault, and trap interface to the FreeBSD kernel.  * This common code is called from assembly language IDT gate entry  * routines that prepare a suitable stack frame, and restore this  * frame after the exception has been processed.  */
end_comment

begin_function
name|void
name|trap
parameter_list|(
name|frame
parameter_list|)
name|struct
name|trapframe
name|frame
decl_stmt|;
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|u_int
name|sticks
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|ucode
init|=
literal|0
decl_stmt|,
name|type
decl_stmt|,
name|code
decl_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|cnt
operator|.
name|v_trap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|frame
operator|.
name|tf_trapno
expr_stmt|;
ifdef|#
directive|ifdef
name|DDB
if|if
condition|(
name|db_active
condition|)
block|{
name|vm_offset_t
name|eva
decl_stmt|;
name|eva
operator|=
operator|(
name|type
operator|==
name|T_PAGEFLT
condition|?
name|frame
operator|.
name|tf_addr
else|:
literal|0
operator|)
expr_stmt|;
name|trap_fatal
argument_list|(
operator|&
name|frame
argument_list|,
name|eva
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|frame
operator|.
name|tf_rflags
operator|&
name|PSL_I
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Buggy application or kernel code has disabled 		 * interrupts and then trapped.  Enabling interrupts 		 * now is wrong, but it is better than running with 		 * interrupts disabled until they are accidentally 		 * enabled later. 		 */
if|if
condition|(
name|ISPL
argument_list|(
name|frame
operator|.
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
condition|)
name|printf
argument_list|(
literal|"pid %ld (%s): trap %d with interrupts disabled\n"
argument_list|,
operator|(
name|long
operator|)
name|curproc
operator|->
name|p_pid
argument_list|,
name|curproc
operator|->
name|p_comm
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|!=
name|T_BPTFLT
operator|&&
name|type
operator|!=
name|T_TRCTRAP
condition|)
block|{
comment|/* 			 * XXX not quite right, since this may be for a 			 * multiple fault in user mode. 			 */
name|printf
argument_list|(
literal|"kernel trap %d with interrupts disabled\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* 			 * We shouldn't enable interrupts while in a critical 			 * section. 			 */
if|if
condition|(
name|td
operator|->
name|td_critnest
operator|==
literal|0
condition|)
name|enable_intr
argument_list|()
expr_stmt|;
block|}
block|}
name|code
operator|=
name|frame
operator|.
name|tf_err
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_PAGEFLT
condition|)
block|{
comment|/* 		 * If we get a page fault while in a critical section, then 		 * it is most likely a fatal kernel page fault.  The kernel 		 * is already going to panic trying to get a sleep lock to 		 * do the VM lookup, so just consider it a fatal trap so the 		 * kernel can print out a useful trap message and even get 		 * to the debugger. 		 */
if|if
condition|(
name|td
operator|->
name|td_critnest
operator|!=
literal|0
condition|)
name|trap_fatal
argument_list|(
operator|&
name|frame
argument_list|,
name|frame
operator|.
name|tf_addr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|poll_in_trap
condition|)
name|ether_poll
argument_list|(
name|poll_in_trap
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEVICE_POLLING */
if|if
condition|(
name|ISPL
argument_list|(
name|frame
operator|.
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
condition|)
block|{
comment|/* user trap */
name|sticks
operator|=
name|td
operator|->
name|td_sticks
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
operator|&
name|frame
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|!=
name|p
operator|->
name|p_ucred
condition|)
name|cred_update_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_PRIVINFLT
case|:
comment|/* privileged instruction fault */
name|ucode
operator|=
name|type
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
name|T_BPTFLT
case|:
comment|/* bpt instruction fault */
case|case
name|T_TRCTRAP
case|:
comment|/* trace trap */
name|enable_intr
argument_list|()
expr_stmt|;
name|frame
operator|.
name|tf_rflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|T_ARITHTRAP
case|:
comment|/* arithmetic trap */
name|ucode
operator|=
name|fputrap
argument_list|()
expr_stmt|;
if|if
condition|(
name|ucode
operator|==
operator|-
literal|1
condition|)
goto|goto
name|userout
goto|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_PROTFLT
case|:
comment|/* general protection fault */
case|case
name|T_STKFLT
case|:
comment|/* stack fault */
case|case
name|T_SEGNPFLT
case|:
comment|/* segment not present fault */
case|case
name|T_TSSFLT
case|:
comment|/* invalid TSS fault */
case|case
name|T_DOUBLEFLT
case|:
comment|/* double fault */
default|default:
name|ucode
operator|=
name|code
operator|+
name|BUS_SEGM_FAULT
expr_stmt|;
name|i
operator|=
name|SIGBUS
expr_stmt|;
break|break;
case|case
name|T_PAGEFLT
case|:
comment|/* page fault */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_SA
condition|)
name|thread_user_enter
argument_list|(
name|p
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|i
operator|=
name|trap_pfault
argument_list|(
operator|&
name|frame
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
goto|goto
name|userout
goto|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|user
goto|;
name|ucode
operator|=
name|T_PAGEFLT
expr_stmt|;
break|break;
case|case
name|T_DIVIDE
case|:
comment|/* integer divide fault */
name|ucode
operator|=
name|FPE_INTDIV
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEV_ISA
case|case
name|T_NMI
case|:
comment|/* machine/parity/power fail/"kitchen sink" faults */
comment|/* XXX Giant */
if|if
condition|(
name|isa_nmi
argument_list|(
name|code
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DDB
comment|/* 				 * NMI can be hooked up to a pushbutton 				 * for debugging. 				 */
if|if
condition|(
name|ddb_on_nmi
condition|)
block|{
name|printf
argument_list|(
literal|"NMI ... going to debugger\n"
argument_list|)
expr_stmt|;
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|frame
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DDB */
goto|goto
name|userout
goto|;
block|}
elseif|else
if|if
condition|(
name|panic_on_nmi
condition|)
name|panic
argument_list|(
literal|"NMI indicates hardware failure"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* DEV_ISA */
case|case
name|T_OFLOW
case|:
comment|/* integer overflow fault */
name|ucode
operator|=
name|FPE_INTOVF
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_BOUND
case|:
comment|/* bounds check fault */
name|ucode
operator|=
name|FPE_FLTSUB
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_DNA
case|:
comment|/* transparent fault (due to context switch "late") */
if|if
condition|(
name|fpudna
argument_list|()
condition|)
goto|goto
name|userout
goto|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
name|FPE_FPU_NP_TRAP
expr_stmt|;
break|break;
case|case
name|T_FPOPFLT
case|:
comment|/* FPU operand fetch fault */
name|ucode
operator|=
name|T_FPOPFLT
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
name|T_XMMFLT
case|:
comment|/* SIMD floating-point exception */
name|ucode
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* kernel trap */
name|KASSERT
argument_list|(
name|cold
operator|||
name|td
operator|->
name|td_ucred
operator|!=
name|NULL
argument_list|,
operator|(
literal|"kernel trap doesn't have ucred"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_PAGEFLT
case|:
comment|/* page fault */
operator|(
name|void
operator|)
name|trap_pfault
argument_list|(
operator|&
name|frame
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|T_DNA
case|:
comment|/* 			 * The kernel is apparently using fpu for copying. 			 * XXX this should be fatal unless the kernel has 			 * registered such use. 			 */
if|if
condition|(
name|fpudna
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"fpudna in kernel mode!\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|T_STKFLT
case|:
comment|/* stack fault */
break|break;
case|case
name|T_PROTFLT
case|:
comment|/* general protection fault */
case|case
name|T_SEGNPFLT
case|:
comment|/* segment not present fault */
if|if
condition|(
name|td
operator|->
name|td_intr_nesting_level
operator|!=
literal|0
condition|)
break|break;
comment|/* 			 * Invalid segment selectors and out of bounds 			 * %eip's and %esp's can be set up in user mode. 			 * This causes a fault in kernel mode when the 			 * kernel tries to return to user mode.  We want 			 * to get this fault so that we can fix the 			 * problem here and not have to check all the 			 * selectors and pointers when the user changes 			 * them. 			 */
if|if
condition|(
name|frame
operator|.
name|tf_rip
operator|==
operator|(
name|long
operator|)
name|doreti_iret
condition|)
block|{
name|frame
operator|.
name|tf_rip
operator|=
operator|(
name|long
operator|)
name|doreti_iret_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|!=
name|NULL
operator|&&
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|->
name|pcb_onfault
operator|!=
name|NULL
condition|)
block|{
name|frame
operator|.
name|tf_rip
operator|=
operator|(
name|long
operator|)
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|->
name|pcb_onfault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|T_TSSFLT
case|:
comment|/* 			 * PSL_NT can be set in user mode and isn't cleared 			 * automatically when the kernel is entered.  This 			 * causes a TSS fault when the kernel attempts to 			 * `iret' because the TSS link is uninitialized.  We 			 * want to get this fault so that we can fix the 			 * problem here and not every time the kernel is 			 * entered. 			 */
if|if
condition|(
name|frame
operator|.
name|tf_rflags
operator|&
name|PSL_NT
condition|)
block|{
name|frame
operator|.
name|tf_rflags
operator|&=
operator|~
name|PSL_NT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|T_TRCTRAP
case|:
comment|/* trace trap */
comment|/* 			 * Ignore debug register trace traps due to 			 * accesses in the user's address space, which 			 * can happen under several conditions such as 			 * if a user sets a watchpoint on a buffer and 			 * then passes that buffer to a system call. 			 * We still want to get TRCTRAPS for addresses 			 * in kernel space because that is useful when 			 * debugging the kernel. 			 */
if|if
condition|(
name|user_dbreg_trap
argument_list|()
condition|)
block|{
comment|/* 				 * Reset breakpoint bits because the 				 * processor doesn't 				 */
comment|/* XXX check upper bits here */
name|load_dr6
argument_list|(
name|rdr6
argument_list|()
operator|&
literal|0xfffffff0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * FALLTHROUGH (TRCTRAP kernel mode, kernel address) 			 */
case|case
name|T_BPTFLT
case|:
comment|/* 			 * If DDB is enabled, let it handle the debugger trap. 			 * Otherwise, debugger traps "can't happen". 			 */
ifdef|#
directive|ifdef
name|DDB
comment|/* XXX Giant */
if|if
condition|(
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|frame
argument_list|)
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|DEV_ISA
case|case
name|T_NMI
case|:
comment|/* XXX Giant */
comment|/* machine/parity/power fail/"kitchen sink" faults */
if|if
condition|(
name|isa_nmi
argument_list|(
name|code
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DDB
comment|/* 				 * NMI can be hooked up to a pushbutton 				 * for debugging. 				 */
if|if
condition|(
name|ddb_on_nmi
condition|)
block|{
name|printf
argument_list|(
literal|"NMI ... going to debugger\n"
argument_list|)
expr_stmt|;
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|frame
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DDB */
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|panic_on_nmi
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
comment|/* DEV_ISA */
block|}
name|trap_fatal
argument_list|(
operator|&
name|frame
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Translate fault for emulators (e.g. Linux) */
if|if
condition|(
operator|*
name|p
operator|->
name|p_sysent
operator|->
name|sv_transtrap
condition|)
name|i
operator|=
call|(
modifier|*
name|p
operator|->
name|p_sysent
operator|->
name|sv_transtrap
call|)
argument_list|(
name|i
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|trapsignal
argument_list|(
name|td
argument_list|,
name|i
argument_list|,
name|ucode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|type
operator|<=
name|MAX_TRAP_MSG
condition|)
block|{
name|uprintf
argument_list|(
literal|"fatal process exception: %s"
argument_list|,
name|trap_msg
index|[
name|type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|T_PAGEFLT
operator|)
operator|||
operator|(
name|type
operator|==
name|T_PROTFLT
operator|)
condition|)
name|uprintf
argument_list|(
literal|", fault VA = 0x%lx"
argument_list|,
name|frame
operator|.
name|tf_addr
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|user
label|:
name|userret
argument_list|(
name|td
argument_list|,
operator|&
name|frame
argument_list|,
name|sticks
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|userout
label|:
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|cred_free_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
label|:
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|trap_pfault
parameter_list|(
name|frame
parameter_list|,
name|usermode
parameter_list|)
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|int
name|usermode
decl_stmt|;
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|NULL
decl_stmt|;
name|vm_map_t
name|map
init|=
literal|0
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|vm_offset_t
name|eva
init|=
name|frame
operator|->
name|tf_addr
decl_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
name|eva
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|>=
name|KERNBASE
condition|)
block|{
comment|/* 		 * Don't allow user-mode faults in kernel address space. 		 */
if|if
condition|(
name|usermode
condition|)
goto|goto
name|nogo
goto|;
name|map
operator|=
name|kernel_map
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is a fault on non-kernel virtual memory. 		 * vm is initialized above to NULL. If curproc is NULL 		 * or curproc->p_vmspace is NULL the fault is fatal. 		 */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
if|if
condition|(
name|vm
operator|==
name|NULL
condition|)
goto|goto
name|nogo
goto|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
block|}
if|if
condition|(
name|frame
operator|->
name|tf_err
operator|&
name|PGEX_W
condition|)
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
else|else
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|kernel_map
condition|)
block|{
comment|/* 		 * Keep swapout from messing with us during this 		 *	critical time. 		 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Fault in the user page: */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
operator|(
name|ftype
operator|&
name|VM_PROT_WRITE
operator|)
condition|?
name|VM_FAULT_DIRTY
else|:
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Don't have to worry about process locking or stacks in the 		 * kernel. 		 */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nogo
label|:
if|if
condition|(
operator|!
name|usermode
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_intr_nesting_level
operator|==
literal|0
operator|&&
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|!=
name|NULL
operator|&&
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|->
name|pcb_onfault
operator|!=
name|NULL
condition|)
block|{
name|frame
operator|->
name|tf_rip
operator|=
operator|(
name|long
operator|)
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|->
name|pcb_onfault
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|trap_fatal
argument_list|(
name|frame
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trap_fatal
parameter_list|(
name|frame
parameter_list|,
name|eva
parameter_list|)
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|vm_offset_t
name|eva
decl_stmt|;
block|{
name|int
name|code
decl_stmt|,
name|type
decl_stmt|,
name|ss
decl_stmt|;
name|long
name|esp
decl_stmt|;
name|struct
name|soft_segment_descriptor
name|softseg
decl_stmt|;
name|code
operator|=
name|frame
operator|->
name|tf_err
expr_stmt|;
name|type
operator|=
name|frame
operator|->
name|tf_trapno
expr_stmt|;
name|sdtossd
argument_list|(
operator|&
name|gdt
index|[
name|IDXSEL
argument_list|(
name|frame
operator|->
name|tf_cs
operator|&
literal|0xffff
argument_list|)
index|]
argument_list|,
operator|&
name|softseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|MAX_TRAP_MSG
condition|)
name|printf
argument_list|(
literal|"\n\nFatal trap %d: %s while in %s mode\n"
argument_list|,
name|type
argument_list|,
name|trap_msg
index|[
name|type
index|]
argument_list|,
name|ISPL
argument_list|(
name|frame
operator|->
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
condition|?
literal|"user"
else|:
literal|"kernel"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* two separate prints in case of a trap on an unmapped page */
name|printf
argument_list|(
literal|"cpuid = %d; "
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apic id = %02x\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|T_PAGEFLT
condition|)
block|{
name|printf
argument_list|(
literal|"fault virtual address	= 0x%lx\n"
argument_list|,
name|eva
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fault code		= %s %s, %s\n"
argument_list|,
name|code
operator|&
name|PGEX_U
condition|?
literal|"user"
else|:
literal|"supervisor"
argument_list|,
name|code
operator|&
name|PGEX_W
condition|?
literal|"write"
else|:
literal|"read"
argument_list|,
name|code
operator|&
name|PGEX_P
condition|?
literal|"protection violation"
else|:
literal|"page not present"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"instruction pointer	= 0x%lx:0x%lx\n"
argument_list|,
name|frame
operator|->
name|tf_cs
operator|&
literal|0xffff
argument_list|,
name|frame
operator|->
name|tf_rip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISPL
argument_list|(
name|frame
operator|->
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
condition|)
block|{
name|ss
operator|=
name|frame
operator|->
name|tf_ss
operator|&
literal|0xffff
expr_stmt|;
name|esp
operator|=
name|frame
operator|->
name|tf_rsp
expr_stmt|;
block|}
else|else
block|{
name|ss
operator|=
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|esp
operator|=
operator|(
name|long
operator|)
operator|&
name|frame
operator|->
name|tf_rsp
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"stack pointer	        = 0x%x:0x%lx\n"
argument_list|,
name|ss
argument_list|,
name|esp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"frame pointer	        = 0x%x:0x%lx\n"
argument_list|,
name|ss
argument_list|,
name|frame
operator|->
name|tf_rbp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"code segment		= base 0x%lx, limit 0x%lx, type 0x%x\n"
argument_list|,
name|softseg
operator|.
name|ssd_base
argument_list|,
name|softseg
operator|.
name|ssd_limit
argument_list|,
name|softseg
operator|.
name|ssd_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"			= DPL %d, pres %d, long %d, def32 %d, gran %d\n"
argument_list|,
name|softseg
operator|.
name|ssd_dpl
argument_list|,
name|softseg
operator|.
name|ssd_p
argument_list|,
name|softseg
operator|.
name|ssd_long
argument_list|,
name|softseg
operator|.
name|ssd_def32
argument_list|,
name|softseg
operator|.
name|ssd_gran
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"processor eflags	= "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_rflags
operator|&
name|PSL_T
condition|)
name|printf
argument_list|(
literal|"trace trap, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_rflags
operator|&
name|PSL_I
condition|)
name|printf
argument_list|(
literal|"interrupt enabled, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_rflags
operator|&
name|PSL_NT
condition|)
name|printf
argument_list|(
literal|"nested task, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_rflags
operator|&
name|PSL_RF
condition|)
name|printf
argument_list|(
literal|"resume, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"IOPL = %ld\n"
argument_list|,
operator|(
name|frame
operator|->
name|tf_rflags
operator|&
name|PSL_IOPL
operator|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"current process		= "
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
condition|)
block|{
name|printf
argument_list|(
literal|"%lu (%s)\n"
argument_list|,
operator|(
name|u_long
operator|)
name|curproc
operator|->
name|p_pid
argument_list|,
name|curproc
operator|->
name|p_comm
condition|?
name|curproc
operator|->
name|p_comm
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Idle\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|kdb_trap
argument_list|(
operator|&
name|psl
argument_list|)
condition|)
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DDB
if|if
condition|(
operator|(
name|debugger_on_panic
operator|||
name|db_active
operator|)
operator|&&
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|frame
argument_list|)
condition|)
return|return;
endif|#
directive|endif
name|printf
argument_list|(
literal|"trap number		= %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|MAX_TRAP_MSG
condition|)
name|panic
argument_list|(
literal|"%s"
argument_list|,
name|trap_msg
index|[
name|type
index|]
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"unknown/reserved trap"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Double fault handler. Called when a fault occurs while writing  * a frame for a trap/exception onto the stack. This usually occurs  * when the stack overflows (such is the case with infinite recursion,  * for example).  */
end_comment

begin_function
name|void
name|dblfault_handler
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\nFatal double fault\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* two separate prints in case of a trap on an unmapped page */
name|printf
argument_list|(
literal|"cpuid = %d; "
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apic id = %02x\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"double fault"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	syscall -	system call request C handler  *  *	A system call is essentially treated as a trap.  */
end_comment

begin_function
name|void
name|syscall
parameter_list|(
name|frame
parameter_list|)
name|struct
name|trapframe
name|frame
decl_stmt|;
block|{
name|caddr_t
name|params
decl_stmt|;
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|register_t
name|orig_tf_rflags
decl_stmt|;
name|u_int
name|sticks
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|narg
decl_stmt|;
name|register_t
name|args
index|[
literal|8
index|]
decl_stmt|;
name|register_t
modifier|*
name|argp
decl_stmt|;
name|u_int
name|code
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|regcnt
decl_stmt|;
comment|/* 	 * note: PCPU_LAZY_INC() can only be used if we can afford 	 * occassional inaccuracy in the count. 	 */
name|PCPU_LAZY_INC
argument_list|(
name|cnt
operator|.
name|v_syscall
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ISPL
argument_list|(
name|frame
operator|.
name|tf_cs
argument_list|)
operator|!=
name|SEL_UPL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* try to stabilize the system XXX */
name|panic
argument_list|(
literal|"syscall"
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|reg
operator|=
literal|0
expr_stmt|;
name|regcnt
operator|=
literal|6
expr_stmt|;
name|sticks
operator|=
name|td
operator|->
name|td_sticks
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
operator|&
name|frame
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|!=
name|p
operator|->
name|p_ucred
condition|)
name|cred_update_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_SA
condition|)
name|thread_user_enter
argument_list|(
name|p
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|params
operator|=
operator|(
name|caddr_t
operator|)
name|frame
operator|.
name|tf_rsp
operator|+
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
expr_stmt|;
name|code
operator|=
name|frame
operator|.
name|tf_rax
expr_stmt|;
name|orig_tf_rflags
operator|=
name|frame
operator|.
name|tf_rflags
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_prepsyscall
condition|)
block|{
comment|/* 		 * The prep code is MP aware. 		 */
call|(
modifier|*
name|p
operator|->
name|p_sysent
operator|->
name|sv_prepsyscall
call|)
argument_list|(
operator|&
name|frame
argument_list|,
operator|(
name|int
operator|*
operator|)
name|args
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|==
name|SYS_syscall
operator|||
name|code
operator|==
name|SYS___syscall
condition|)
block|{
name|code
operator|=
name|frame
operator|.
name|tf_rdi
expr_stmt|;
name|reg
operator|++
expr_stmt|;
name|regcnt
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
condition|)
name|code
operator|&=
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
literal|0
index|]
expr_stmt|;
else|else
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|code
index|]
expr_stmt|;
name|narg
operator|=
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_ARGMASK
expr_stmt|;
comment|/* 	 * copyin and the ktrsyscall()/ktrsysret() code is MP-aware 	 */
if|if
condition|(
name|narg
operator|<=
name|regcnt
condition|)
block|{
name|argp
operator|=
operator|&
name|frame
operator|.
name|tf_rdi
expr_stmt|;
name|argp
operator|+=
name|reg
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|narg
operator|<=
sizeof|sizeof
argument_list|(
name|args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|(
literal|"Too many syscall arguments!"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|params
operator|!=
name|NULL
argument_list|,
operator|(
literal|"copyin args with no params!"
operator|)
argument_list|)
expr_stmt|;
name|argp
operator|=
operator|&
name|frame
operator|.
name|tf_rdi
expr_stmt|;
name|argp
operator|+=
name|reg
expr_stmt|;
name|bcopy
argument_list|(
name|argp
argument_list|,
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
operator|*
name|regcnt
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|params
argument_list|,
operator|&
name|args
index|[
name|regcnt
index|]
argument_list|,
operator|(
name|narg
operator|-
name|regcnt
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|argp
operator|=
operator|&
name|args
index|[
literal|0
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|code
argument_list|,
name|narg
argument_list|,
name|argp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Try to run the syscall without Giant if the syscall 	 * is MP safe. 	 */
if|if
condition|(
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_MPSAFE
operator|)
operator|==
literal|0
condition|)
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|frame
operator|.
name|tf_rdx
expr_stmt|;
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCE
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|PTRACESTOP_SC
argument_list|(
name|p
argument_list|,
name|td
argument_list|,
name|S_PT_SCE
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|td
argument_list|,
name|argp
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
name|frame
operator|.
name|tf_rax
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
name|frame
operator|.
name|tf_rdx
operator|=
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
expr_stmt|;
name|frame
operator|.
name|tf_rflags
operator|&=
operator|~
name|PSL_C
expr_stmt|;
break|break;
case|case
name|ERESTART
case|:
comment|/* 		 * Reconstruct pc, we know that 'syscall' is 2 bytes. 		 * We have to do a full context restore so that %r10 		 * (which was holding the value of %rcx) is restored for 		 * the next iteration. 		 */
name|frame
operator|.
name|tf_rip
operator|-=
name|frame
operator|.
name|tf_err
expr_stmt|;
name|frame
operator|.
name|tf_r10
operator|=
name|frame
operator|.
name|tf_rcx
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_flags
operator||=
name|PCB_FULLCTX
expr_stmt|;
break|break;
case|case
name|EJUSTRETURN
case|:
break|break;
default|default:
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
block|{
if|if
condition|(
name|error
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
name|error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* XXX */
else|else
name|error
operator|=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errtbl
index|[
name|error
index|]
expr_stmt|;
block|}
name|frame
operator|.
name|tf_rax
operator|=
name|error
expr_stmt|;
name|frame
operator|.
name|tf_rflags
operator||=
name|PSL_C
expr_stmt|;
break|break;
block|}
comment|/* 	 * Release Giant if we previously set it. 	 */
if|if
condition|(
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_MPSAFE
operator|)
operator|==
literal|0
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* 	 * Traced syscall. 	 */
if|if
condition|(
name|orig_tf_rflags
operator|&
name|PSL_T
condition|)
block|{
name|frame
operator|.
name|tf_rflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|trapsignal
argument_list|(
name|td
argument_list|,
name|SIGTRAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Handle reschedule and other end-of-syscall issues 	 */
name|userret
argument_list|(
name|td
argument_list|,
operator|&
name|frame
argument_list|,
name|sticks
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|code
argument_list|,
name|error
argument_list|,
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * This works because errno is findable through the 	 * register set.  If we ever support an emulation where this 	 * is not the case, this code will need to be revisited. 	 */
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCX
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|PTRACESTOP_SC
argument_list|(
name|p
argument_list|,
name|td
argument_list|,
name|S_PT_SCX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|cred_free_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|WITNESS_WARN
argument_list|(
name|WARN_PANIC
argument_list|,
name|NULL
argument_list|,
literal|"System call %s returning"
argument_list|,
operator|(
name|code
operator|>=
literal|0
operator|&&
name|code
operator|<
name|SYS_MAXSYSCALL
operator|)
condition|?
name|syscallnames
index|[
name|code
index|]
else|:
literal|"???"
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

