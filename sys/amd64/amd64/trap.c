begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1994, David Greenman  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the University of Utah, and William Jolitz.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)trap.c	7.4 (Berkeley) 5/13/91  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * 386 Trap and System call handling  */
end_comment

begin_include
include|#
directive|include
file|"opt_clock.h"
end_include

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_isa.h"
end_include

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|"opt_npx.h"
end_include

begin_include
include|#
directive|include
file|"opt_trap.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/tss.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/intr_machdep.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|POWERFAIL_NMI
end_ifdef

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/vm86.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_function_decl
name|int
function_decl|(
modifier|*
name|pmath_emulate
function_decl|)
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|trap
parameter_list|(
name|struct
name|trapframe
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|I386_CPU
end_ifdef

begin_function_decl
specifier|extern
name|int
name|trapwrite
parameter_list|(
name|unsigned
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|void
name|syscall
parameter_list|(
name|struct
name|trapframe
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trap_pfault
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|,
name|int
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trap_fatal
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dblfault_handler
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|inthand_t
name|IDTVEC
parameter_list|(
name|lcall_syscall
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAX_TRAP_MSG
value|28
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|trap_msg
index|[]
init|=
block|{
literal|""
block|,
comment|/*  0 unused */
literal|"privileged instruction fault"
block|,
comment|/*  1 T_PRIVINFLT */
literal|""
block|,
comment|/*  2 unused */
literal|"breakpoint instruction fault"
block|,
comment|/*  3 T_BPTFLT */
literal|""
block|,
comment|/*  4 unused */
literal|""
block|,
comment|/*  5 unused */
literal|"arithmetic trap"
block|,
comment|/*  6 T_ARITHTRAP */
literal|""
block|,
comment|/*  7 unused */
literal|""
block|,
comment|/*  8 unused */
literal|"general protection fault"
block|,
comment|/*  9 T_PROTFLT */
literal|"trace trap"
block|,
comment|/* 10 T_TRCTRAP */
literal|""
block|,
comment|/* 11 unused */
literal|"page fault"
block|,
comment|/* 12 T_PAGEFLT */
literal|""
block|,
comment|/* 13 unused */
literal|"alignment fault"
block|,
comment|/* 14 T_ALIGNFLT */
literal|""
block|,
comment|/* 15 unused */
literal|""
block|,
comment|/* 16 unused */
literal|""
block|,
comment|/* 17 unused */
literal|"integer divide fault"
block|,
comment|/* 18 T_DIVIDE */
literal|"non-maskable interrupt trap"
block|,
comment|/* 19 T_NMI */
literal|"overflow trap"
block|,
comment|/* 20 T_OFLOW */
literal|"FPU bounds check fault"
block|,
comment|/* 21 T_BOUND */
literal|"FPU device not available"
block|,
comment|/* 22 T_DNA */
literal|"double fault"
block|,
comment|/* 23 T_DOUBLEFLT */
literal|"FPU operand fetch fault"
block|,
comment|/* 24 T_FPOPFLT */
literal|"invalid TSS fault"
block|,
comment|/* 25 T_TSSFLT */
literal|"segment not present fault"
block|,
comment|/* 26 T_SEGNPFLT */
literal|"stack fault"
block|,
comment|/* 27 T_STKFLT */
literal|"machine check trap"
block|,
comment|/* 28 T_MCHK */
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_F00F_HACK
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|has_f00f_bug
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ddb_on_nmi
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|ddb_on_nmi
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ddb_on_nmi
argument_list|,
literal|0
argument_list|,
literal|"Go to DDB on NMI"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|panic_on_nmi
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|panic_on_nmi
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|panic_on_nmi
argument_list|,
literal|0
argument_list|,
literal|"Panic on NMI"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|WITNESS
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|syscallnames
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_decl_stmt
specifier|extern
name|u_int32_t
name|poll_in_trap
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|ether_poll
parameter_list|(
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVICE_POLLING */
end_comment

begin_comment
comment|/*  * Exception, fault, and trap interface to the FreeBSD kernel.  * This common code is called from assembly language IDT gate entry  * routines that prepare a suitable stack frame, and restore this  * frame after the exception has been processed.  */
end_comment

begin_function
name|void
name|trap
parameter_list|(
name|frame
parameter_list|)
name|struct
name|trapframe
name|frame
decl_stmt|;
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|u_int
name|sticks
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|ucode
init|=
literal|0
decl_stmt|,
name|type
decl_stmt|,
name|code
decl_stmt|;
name|vm_offset_t
name|eva
decl_stmt|;
ifdef|#
directive|ifdef
name|POWERFAIL_NMI
specifier|static
name|int
name|lastalert
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|atomic_add_int
argument_list|(
operator|&
name|cnt
operator|.
name|v_trap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|frame
operator|.
name|tf_eflags
operator|&
name|PSL_I
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Buggy application or kernel code has disabled 		 * interrupts and then trapped.  Enabling interrupts 		 * now is wrong, but it is better than running with 		 * interrupts disabled until they are accidentally 		 * enabled later. 		 */
name|type
operator|=
name|frame
operator|.
name|tf_trapno
expr_stmt|;
if|if
condition|(
name|ISPL
argument_list|(
name|frame
operator|.
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
operator|||
operator|(
name|frame
operator|.
name|tf_eflags
operator|&
name|PSL_VM
operator|)
condition|)
name|printf
argument_list|(
literal|"pid %ld (%s): trap %d with interrupts disabled\n"
argument_list|,
operator|(
name|long
operator|)
name|curproc
operator|->
name|p_pid
argument_list|,
name|curproc
operator|->
name|p_comm
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|!=
name|T_BPTFLT
operator|&&
name|type
operator|!=
name|T_TRCTRAP
condition|)
block|{
comment|/* 			 * XXX not quite right, since this may be for a 			 * multiple fault in user mode. 			 */
name|printf
argument_list|(
literal|"kernel trap %d with interrupts disabled\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* 			 * Page faults need interrupts diasabled until later, 			 * and we shouldn't enable interrupts while holding a 			 * spin lock. 			 */
if|if
condition|(
name|type
operator|!=
name|T_PAGEFLT
operator|&&
name|PCPU_GET
argument_list|(
name|spinlocks
argument_list|)
operator|==
name|NULL
condition|)
name|enable_intr
argument_list|()
expr_stmt|;
block|}
block|}
name|eva
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|frame
operator|.
name|tf_trapno
expr_stmt|;
name|code
operator|=
name|frame
operator|.
name|tf_err
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_PAGEFLT
condition|)
block|{
comment|/* 		 * For some Cyrix CPUs, %cr2 is clobbered by 		 * interrupts.  This problem is worked around by using 		 * an interrupt gate for the pagefault handler.  We 		 * are finally ready to read %cr2 and then must 		 * reenable interrupts. 		 * 		 * If we get a page fault while holding a spin lock, then 		 * it is most likely a fatal kernel page fault.  The kernel 		 * is already going to panic trying to get a sleep lock to 		 * do the VM lookup, so just consider it a fatal trap so the 		 * kernel can print out a useful trap message and even get 		 * to the debugger. 		 */
name|eva
operator|=
name|rcr2
argument_list|()
expr_stmt|;
if|if
condition|(
name|PCPU_GET
argument_list|(
name|spinlocks
argument_list|)
operator|==
name|NULL
condition|)
name|enable_intr
argument_list|()
expr_stmt|;
else|else
name|trap_fatal
argument_list|(
operator|&
name|frame
argument_list|,
name|eva
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|poll_in_trap
condition|)
name|ether_poll
argument_list|(
name|poll_in_trap
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEVICE_POLLING */
if|if
condition|(
operator|(
name|ISPL
argument_list|(
name|frame
operator|.
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
operator|)
operator|||
operator|(
operator|(
name|frame
operator|.
name|tf_eflags
operator|&
name|PSL_VM
operator|)
operator|&&
operator|!
name|in_vm86call
operator|)
condition|)
block|{
comment|/* user trap */
name|sticks
operator|=
name|td
operator|->
name|td_kse
operator|->
name|ke_sticks
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
operator|&
name|frame
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|!=
name|p
operator|->
name|p_ucred
condition|)
name|cred_update_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_PRIVINFLT
case|:
comment|/* privileged instruction fault */
name|ucode
operator|=
name|type
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
name|T_BPTFLT
case|:
comment|/* bpt instruction fault */
case|case
name|T_TRCTRAP
case|:
comment|/* trace trap */
name|frame
operator|.
name|tf_eflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|T_ARITHTRAP
case|:
comment|/* arithmetic trap */
ifdef|#
directive|ifdef
name|DEV_NPX
name|ucode
operator|=
name|npxtrap
argument_list|()
expr_stmt|;
if|if
condition|(
name|ucode
operator|==
operator|-
literal|1
condition|)
goto|goto
name|userout
goto|;
else|#
directive|else
name|ucode
operator|=
name|code
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
comment|/* 			 * The following two traps can happen in 			 * vm86 mode, and, if so, we want to handle 			 * them specially. 			 */
case|case
name|T_PROTFLT
case|:
comment|/* general protection fault */
case|case
name|T_STKFLT
case|:
comment|/* stack fault */
if|if
condition|(
name|frame
operator|.
name|tf_eflags
operator|&
name|PSL_VM
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|i
operator|=
name|vm86_emulate
argument_list|(
operator|(
expr|struct
name|vm86frame
operator|*
operator|)
operator|&
name|frame
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|user
goto|;
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|T_SEGNPFLT
case|:
comment|/* segment not present fault */
case|case
name|T_TSSFLT
case|:
comment|/* invalid TSS fault */
case|case
name|T_DOUBLEFLT
case|:
comment|/* double fault */
default|default:
name|ucode
operator|=
name|code
operator|+
name|BUS_SEGM_FAULT
expr_stmt|;
name|i
operator|=
name|SIGBUS
expr_stmt|;
break|break;
case|case
name|T_PAGEFLT
case|:
comment|/* page fault */
name|i
operator|=
name|trap_pfault
argument_list|(
operator|&
name|frame
argument_list|,
name|TRUE
argument_list|,
name|eva
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_F00F_HACK
argument_list|)
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* 				 * The f00f hack workaround has triggered, so 				 * treat the fault as an illegal instruction  				 * (T_PRIVINFLT) instead of a page fault. 				 */
name|type
operator|=
name|frame
operator|.
name|tf_trapno
operator|=
name|T_PRIVINFLT
expr_stmt|;
comment|/* Proceed as in that case. */
name|ucode
operator|=
name|type
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
goto|goto
name|userout
goto|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|user
goto|;
name|ucode
operator|=
name|T_PAGEFLT
expr_stmt|;
break|break;
case|case
name|T_DIVIDE
case|:
comment|/* integer divide fault */
name|ucode
operator|=
name|FPE_INTDIV
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEV_ISA
case|case
name|T_NMI
case|:
ifdef|#
directive|ifdef
name|POWERFAIL_NMI
ifndef|#
directive|ifndef
name|TIMER_FREQ
define|#
directive|define
name|TIMER_FREQ
value|1193182
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_second
operator|-
name|lastalert
operator|>
literal|10
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"NMI: power fail\n"
argument_list|)
expr_stmt|;
name|sysbeep
argument_list|(
name|TIMER_FREQ
operator|/
literal|880
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|lastalert
operator|=
name|time_second
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
goto|goto
name|userout
goto|;
else|#
directive|else
comment|/* !POWERFAIL_NMI */
comment|/* machine/parity/power fail/"kitchen sink" faults */
comment|/* XXX Giant */
if|if
condition|(
name|isa_nmi
argument_list|(
name|code
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DDB
comment|/* 				 * NMI can be hooked up to a pushbutton 				 * for debugging. 				 */
if|if
condition|(
name|ddb_on_nmi
condition|)
block|{
name|printf
argument_list|(
literal|"NMI ... going to debugger\n"
argument_list|)
expr_stmt|;
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|frame
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DDB */
goto|goto
name|userout
goto|;
block|}
elseif|else
if|if
condition|(
name|panic_on_nmi
condition|)
name|panic
argument_list|(
literal|"NMI indicates hardware failure"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* POWERFAIL_NMI */
endif|#
directive|endif
comment|/* DEV_ISA */
case|case
name|T_OFLOW
case|:
comment|/* integer overflow fault */
name|ucode
operator|=
name|FPE_INTOVF
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_BOUND
case|:
comment|/* bounds check fault */
name|ucode
operator|=
name|FPE_FLTSUB
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_DNA
case|:
ifdef|#
directive|ifdef
name|DEV_NPX
comment|/* transparent fault (due to context switch "late") */
if|if
condition|(
name|npxdna
argument_list|()
condition|)
goto|goto
name|userout
goto|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pmath_emulate
condition|)
block|{
name|i
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
name|FPE_FPU_NP_TRAP
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|i
operator|=
call|(
modifier|*
name|pmath_emulate
call|)
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|frame
operator|.
name|tf_eflags
operator|&
name|PSL_T
operator|)
condition|)
goto|goto
name|userout
goto|;
name|frame
operator|.
name|tf_eflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
block|}
comment|/* else ucode = emulator_only_knows() XXX */
break|break;
case|case
name|T_FPOPFLT
case|:
comment|/* FPU operand fetch fault */
name|ucode
operator|=
name|T_FPOPFLT
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
name|T_XMMFLT
case|:
comment|/* SIMD floating-point exception */
name|ucode
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* kernel trap */
name|KASSERT
argument_list|(
name|cold
operator|||
name|td
operator|->
name|td_ucred
operator|!=
name|NULL
argument_list|,
operator|(
literal|"kernel trap doesn't have ucred"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_PAGEFLT
case|:
comment|/* page fault */
operator|(
name|void
operator|)
name|trap_pfault
argument_list|(
operator|&
name|frame
argument_list|,
name|FALSE
argument_list|,
name|eva
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|T_DNA
case|:
ifdef|#
directive|ifdef
name|DEV_NPX
comment|/* 			 * The kernel is apparently using npx for copying. 			 * XXX this should be fatal unless the kernel has 			 * registered such use. 			 */
if|if
condition|(
name|npxdna
argument_list|()
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
break|break;
comment|/* 			 * The following two traps can happen in 			 * vm86 mode, and, if so, we want to handle 			 * them specially. 			 */
case|case
name|T_PROTFLT
case|:
comment|/* general protection fault */
case|case
name|T_STKFLT
case|:
comment|/* stack fault */
if|if
condition|(
name|frame
operator|.
name|tf_eflags
operator|&
name|PSL_VM
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|i
operator|=
name|vm86_emulate
argument_list|(
operator|(
expr|struct
name|vm86frame
operator|*
operator|)
operator|&
name|frame
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
comment|/* 					 * returns to original process 					 */
name|vm86_trap
argument_list|(
operator|(
expr|struct
name|vm86frame
operator|*
operator|)
operator|&
name|frame
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|T_STKFLT
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|T_SEGNPFLT
case|:
comment|/* segment not present fault */
if|if
condition|(
name|in_vm86call
condition|)
break|break;
if|if
condition|(
name|td
operator|->
name|td_intr_nesting_level
operator|!=
literal|0
condition|)
break|break;
comment|/* 			 * Invalid %fs's and %gs's can be created using 			 * procfs or PT_SETREGS or by invalidating the 			 * underlying LDT entry.  This causes a fault 			 * in kernel mode when the kernel attempts to 			 * switch contexts.  Lose the bad context 			 * (XXX) so that we can continue, and generate 			 * a signal. 			 */
if|if
condition|(
name|frame
operator|.
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|cpu_switch_load_gs
condition|)
block|{
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|->
name|pcb_gs
operator|=
literal|0
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGBUS
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * Invalid segment selectors and out of bounds 			 * %eip's and %esp's can be set up in user mode. 			 * This causes a fault in kernel mode when the 			 * kernel tries to return to user mode.  We want 			 * to get this fault so that we can fix the 			 * problem here and not have to check all the 			 * selectors and pointers when the user changes 			 * them. 			 */
if|if
condition|(
name|frame
operator|.
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|doreti_iret
condition|)
block|{
name|frame
operator|.
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|doreti_iret_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|frame
operator|.
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|doreti_popl_ds
condition|)
block|{
name|frame
operator|.
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|doreti_popl_ds_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|frame
operator|.
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|doreti_popl_es
condition|)
block|{
name|frame
operator|.
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|doreti_popl_es_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|frame
operator|.
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|doreti_popl_fs
condition|)
block|{
name|frame
operator|.
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|doreti_popl_fs_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|!=
name|NULL
operator|&&
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|->
name|pcb_onfault
operator|!=
name|NULL
condition|)
block|{
name|frame
operator|.
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|->
name|pcb_onfault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|T_TSSFLT
case|:
comment|/* 			 * PSL_NT can be set in user mode and isn't cleared 			 * automatically when the kernel is entered.  This 			 * causes a TSS fault when the kernel attempts to 			 * `iret' because the TSS link is uninitialized.  We 			 * want to get this fault so that we can fix the 			 * problem here and not every time the kernel is 			 * entered. 			 */
if|if
condition|(
name|frame
operator|.
name|tf_eflags
operator|&
name|PSL_NT
condition|)
block|{
name|frame
operator|.
name|tf_eflags
operator|&=
operator|~
name|PSL_NT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|T_TRCTRAP
case|:
comment|/* trace trap */
if|if
condition|(
name|frame
operator|.
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|IDTVEC
argument_list|(
name|lcall_syscall
argument_list|)
condition|)
block|{
comment|/* 				 * We've just entered system mode via the 				 * syscall lcall.  Continue single stepping 				 * silently until the syscall handler has 				 * saved the flags. 				 */
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|frame
operator|.
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|IDTVEC
argument_list|(
name|lcall_syscall
argument_list|)
operator|+
literal|1
condition|)
block|{
comment|/* 				 * The syscall handler has now saved the 				 * flags.  Stop single stepping it. 				 */
name|frame
operator|.
name|tf_eflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * Ignore debug register trace traps due to 			 * accesses in the user's address space, which 			 * can happen under several conditions such as 			 * if a user sets a watchpoint on a buffer and 			 * then passes that buffer to a system call. 			 * We still want to get TRCTRAPS for addresses 			 * in kernel space because that is useful when 			 * debugging the kernel. 			 */
comment|/* XXX Giant */
if|if
condition|(
name|user_dbreg_trap
argument_list|()
operator|&&
operator|!
name|in_vm86call
condition|)
block|{
comment|/* 				 * Reset breakpoint bits because the 				 * processor doesn't 				 */
name|load_dr6
argument_list|(
name|rdr6
argument_list|()
operator|&
literal|0xfffffff0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * Fall through (TRCTRAP kernel mode, kernel address) 			 */
case|case
name|T_BPTFLT
case|:
comment|/* 			 * If DDB is enabled, let it handle the debugger trap. 			 * Otherwise, debugger traps "can't happen". 			 */
ifdef|#
directive|ifdef
name|DDB
comment|/* XXX Giant */
if|if
condition|(
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|frame
argument_list|)
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|DEV_ISA
case|case
name|T_NMI
case|:
ifdef|#
directive|ifdef
name|POWERFAIL_NMI
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_second
operator|-
name|lastalert
operator|>
literal|10
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"NMI: power fail\n"
argument_list|)
expr_stmt|;
name|sysbeep
argument_list|(
name|TIMER_FREQ
operator|/
literal|880
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|lastalert
operator|=
name|time_second
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
else|#
directive|else
comment|/* !POWERFAIL_NMI */
comment|/* XXX Giant */
comment|/* machine/parity/power fail/"kitchen sink" faults */
if|if
condition|(
name|isa_nmi
argument_list|(
name|code
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DDB
comment|/* 				 * NMI can be hooked up to a pushbutton 				 * for debugging. 				 */
if|if
condition|(
name|ddb_on_nmi
condition|)
block|{
name|printf
argument_list|(
literal|"NMI ... going to debugger\n"
argument_list|)
expr_stmt|;
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|frame
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DDB */
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|panic_on_nmi
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* FALL THROUGH */
endif|#
directive|endif
comment|/* POWERFAIL_NMI */
endif|#
directive|endif
comment|/* DEV_ISA */
block|}
name|trap_fatal
argument_list|(
operator|&
name|frame
argument_list|,
name|eva
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Translate fault for emulators (e.g. Linux) */
if|if
condition|(
operator|*
name|p
operator|->
name|p_sysent
operator|->
name|sv_transtrap
condition|)
name|i
operator|=
call|(
modifier|*
name|p
operator|->
name|p_sysent
operator|->
name|sv_transtrap
call|)
argument_list|(
name|i
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|trapsignal
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|ucode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|type
operator|<=
name|MAX_TRAP_MSG
condition|)
block|{
name|uprintf
argument_list|(
literal|"fatal process exception: %s"
argument_list|,
name|trap_msg
index|[
name|type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|T_PAGEFLT
operator|)
operator|||
operator|(
name|type
operator|==
name|T_PROTFLT
operator|)
condition|)
name|uprintf
argument_list|(
literal|", fault VA = 0x%lx"
argument_list|,
operator|(
name|u_long
operator|)
name|eva
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|user
label|:
name|userret
argument_list|(
name|td
argument_list|,
operator|&
name|frame
argument_list|,
name|sticks
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|userout
label|:
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|cred_free_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
label|:
return|return;
block|}
end_function

begin_function
name|int
name|trap_pfault
parameter_list|(
name|frame
parameter_list|,
name|usermode
parameter_list|,
name|eva
parameter_list|)
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|int
name|usermode
decl_stmt|;
name|vm_offset_t
name|eva
decl_stmt|;
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|NULL
decl_stmt|;
name|vm_map_t
name|map
init|=
literal|0
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
name|eva
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|>=
name|KERNBASE
condition|)
block|{
comment|/* 		 * Don't allow user-mode faults in kernel address space. 		 * An exception:  if the faulting address is the invalid 		 * instruction entry in the IDT, then the Intel Pentium 		 * F00F bug workaround was triggered, and we need to 		 * treat it is as an illegal instruction, and not a page 		 * fault. 		 */
if|#
directive|if
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_F00F_HACK
argument_list|)
if|if
condition|(
operator|(
name|eva
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|&
name|idt
index|[
literal|6
index|]
operator|)
operator|&&
name|has_f00f_bug
condition|)
return|return
operator|-
literal|2
return|;
endif|#
directive|endif
if|if
condition|(
name|usermode
condition|)
goto|goto
name|nogo
goto|;
name|map
operator|=
name|kernel_map
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is a fault on non-kernel virtual memory. 		 * vm is initialized above to NULL. If curproc is NULL 		 * or curproc->p_vmspace is NULL the fault is fatal. 		 */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
if|if
condition|(
name|vm
operator|==
name|NULL
condition|)
goto|goto
name|nogo
goto|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
block|}
if|if
condition|(
name|frame
operator|->
name|tf_err
operator|&
name|PGEX_W
condition|)
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
else|else
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|kernel_map
condition|)
block|{
comment|/* 		 * Keep swapout from messing with us during this 		 *	critical time. 		 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * Grow the stack if necessary 		 */
comment|/* grow_stack returns false only if va falls into 		 * a growable stack region and the stack growth 		 * fails.  It returns true if va was not within 		 * a growable stack region, or if the stack  		 * growth succeeded. 		 */
if|if
condition|(
operator|!
name|grow_stack
argument_list|(
name|p
argument_list|,
name|va
argument_list|)
condition|)
name|rv
operator|=
name|KERN_FAILURE
expr_stmt|;
else|else
comment|/* Fault in the user page: */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
operator|(
name|ftype
operator|&
name|VM_PROT_WRITE
operator|)
condition|?
name|VM_FAULT_DIRTY
else|:
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Don't have to worry about process locking or stacks in the 		 * kernel. 		 */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nogo
label|:
if|if
condition|(
operator|!
name|usermode
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_intr_nesting_level
operator|==
literal|0
operator|&&
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|!=
name|NULL
operator|&&
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|->
name|pcb_onfault
operator|!=
name|NULL
condition|)
block|{
name|frame
operator|->
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|->
name|pcb_onfault
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|trap_fatal
argument_list|(
name|frame
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* kludge to pass faulting virtual address to sendsig */
name|frame
operator|->
name|tf_err
operator|=
name|eva
expr_stmt|;
return|return
operator|(
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trap_fatal
parameter_list|(
name|frame
parameter_list|,
name|eva
parameter_list|)
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|vm_offset_t
name|eva
decl_stmt|;
block|{
name|int
name|code
decl_stmt|,
name|type
decl_stmt|,
name|ss
decl_stmt|,
name|esp
decl_stmt|;
name|struct
name|soft_segment_descriptor
name|softseg
decl_stmt|;
name|code
operator|=
name|frame
operator|->
name|tf_err
expr_stmt|;
name|type
operator|=
name|frame
operator|->
name|tf_trapno
expr_stmt|;
name|sdtossd
argument_list|(
operator|&
name|gdt
index|[
name|IDXSEL
argument_list|(
name|frame
operator|->
name|tf_cs
operator|&
literal|0xffff
argument_list|)
index|]
operator|.
name|sd
argument_list|,
operator|&
name|softseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|MAX_TRAP_MSG
condition|)
name|printf
argument_list|(
literal|"\n\nFatal trap %d: %s while in %s mode\n"
argument_list|,
name|type
argument_list|,
name|trap_msg
index|[
name|type
index|]
argument_list|,
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_VM
condition|?
literal|"vm86"
else|:
name|ISPL
argument_list|(
name|frame
operator|->
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
condition|?
literal|"user"
else|:
literal|"kernel"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* two separate prints in case of a trap on an unmapped page */
name|printf
argument_list|(
literal|"cpuid = %d; "
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lapic.id = %08x\n"
argument_list|,
name|lapic
operator|.
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|T_PAGEFLT
condition|)
block|{
name|printf
argument_list|(
literal|"fault virtual address	= 0x%x\n"
argument_list|,
name|eva
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fault code		= %s %s, %s\n"
argument_list|,
name|code
operator|&
name|PGEX_U
condition|?
literal|"user"
else|:
literal|"supervisor"
argument_list|,
name|code
operator|&
name|PGEX_W
condition|?
literal|"write"
else|:
literal|"read"
argument_list|,
name|code
operator|&
name|PGEX_P
condition|?
literal|"protection violation"
else|:
literal|"page not present"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"instruction pointer	= 0x%x:0x%x\n"
argument_list|,
name|frame
operator|->
name|tf_cs
operator|&
literal|0xffff
argument_list|,
name|frame
operator|->
name|tf_eip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ISPL
argument_list|(
name|frame
operator|->
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
operator|)
operator|||
operator|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_VM
operator|)
condition|)
block|{
name|ss
operator|=
name|frame
operator|->
name|tf_ss
operator|&
literal|0xffff
expr_stmt|;
name|esp
operator|=
name|frame
operator|->
name|tf_esp
expr_stmt|;
block|}
else|else
block|{
name|ss
operator|=
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|esp
operator|=
operator|(
name|int
operator|)
operator|&
name|frame
operator|->
name|tf_esp
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"stack pointer	        = 0x%x:0x%x\n"
argument_list|,
name|ss
argument_list|,
name|esp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"frame pointer	        = 0x%x:0x%x\n"
argument_list|,
name|ss
argument_list|,
name|frame
operator|->
name|tf_ebp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"code segment		= base 0x%x, limit 0x%x, type 0x%x\n"
argument_list|,
name|softseg
operator|.
name|ssd_base
argument_list|,
name|softseg
operator|.
name|ssd_limit
argument_list|,
name|softseg
operator|.
name|ssd_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"			= DPL %d, pres %d, def32 %d, gran %d\n"
argument_list|,
name|softseg
operator|.
name|ssd_dpl
argument_list|,
name|softseg
operator|.
name|ssd_p
argument_list|,
name|softseg
operator|.
name|ssd_def32
argument_list|,
name|softseg
operator|.
name|ssd_gran
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"processor eflags	= "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_T
condition|)
name|printf
argument_list|(
literal|"trace trap, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_I
condition|)
name|printf
argument_list|(
literal|"interrupt enabled, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_NT
condition|)
name|printf
argument_list|(
literal|"nested task, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_RF
condition|)
name|printf
argument_list|(
literal|"resume, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_VM
condition|)
name|printf
argument_list|(
literal|"vm86, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"IOPL = %d\n"
argument_list|,
operator|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_IOPL
operator|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"current process		= "
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
condition|)
block|{
name|printf
argument_list|(
literal|"%lu (%s)\n"
argument_list|,
operator|(
name|u_long
operator|)
name|curproc
operator|->
name|p_pid
argument_list|,
name|curproc
operator|->
name|p_comm
condition|?
name|curproc
operator|->
name|p_comm
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Idle\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|kdb_trap
argument_list|(
operator|&
name|psl
argument_list|)
condition|)
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DDB
if|if
condition|(
operator|(
name|debugger_on_panic
operator|||
name|db_active
operator|)
operator|&&
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|frame
argument_list|)
condition|)
return|return;
endif|#
directive|endif
name|printf
argument_list|(
literal|"trap number		= %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|MAX_TRAP_MSG
condition|)
name|panic
argument_list|(
literal|"%s"
argument_list|,
name|trap_msg
index|[
name|type
index|]
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"unknown/reserved trap"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Double fault handler. Called when a fault occurs while writing  * a frame for a trap/exception onto the stack. This usually occurs  * when the stack overflows (such is the case with infinite recursion,  * for example).  *  * XXX Note that the current PTD gets replaced by IdlePTD when the  * task switch occurs. This means that the stack that was active at  * the time of the double fault is not available at<kstack> unless  * the machine was idle when the double fault occurred. The downside  * of this is that "trace<ebp>" in ddb won't work.  */
end_comment

begin_function
name|void
name|dblfault_handler
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\nFatal double fault:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"eip = 0x%x\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|common_tss
operator|.
name|tss_eip
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"esp = 0x%x\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|common_tss
operator|.
name|tss_esp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ebp = 0x%x\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|common_tss
operator|.
name|tss_ebp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* two separate prints in case of a trap on an unmapped page */
name|printf
argument_list|(
literal|"cpuid = %d; "
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lapic.id = %08x\n"
argument_list|,
name|lapic
operator|.
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"double fault"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|I386_CPU
end_ifdef

begin_comment
comment|/*  * Compensate for 386 brain damage (missing URKR).  * This is a little simpler than the pagefault handler in trap() because  * it the page tables have already been faulted in and high addresses  * are thrown out early for other reasons.  */
end_comment

begin_function
name|int
name|trapwrite
parameter_list|(
name|addr
parameter_list|)
name|unsigned
name|addr
decl_stmt|;
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|)
expr_stmt|;
comment|/* 	 * XXX - MAX is END.  Changed> to>= for temp. fix. 	 */
if|if
condition|(
name|va
operator|>=
name|VM_MAXUSER_ADDRESS
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|grow_stack
argument_list|(
name|p
argument_list|,
name|va
argument_list|)
condition|)
name|rv
operator|=
name|KERN_FAILURE
expr_stmt|;
else|else
comment|/* 		 * fault the data page 		 */
name|rv
operator|=
name|vm_fault
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
name|va
argument_list|,
name|VM_PROT_WRITE
argument_list|,
name|VM_FAULT_DIRTY
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
return|return
literal|1
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	syscall -	system call request C handler  *  *	A system call is essentially treated as a trap.  */
end_comment

begin_function
name|void
name|syscall
parameter_list|(
name|frame
parameter_list|)
name|struct
name|trapframe
name|frame
decl_stmt|;
block|{
name|caddr_t
name|params
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|register_t
name|orig_tf_eflags
decl_stmt|;
name|u_int
name|sticks
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|narg
decl_stmt|;
name|int
name|args
index|[
literal|8
index|]
decl_stmt|;
name|u_int
name|code
decl_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|cnt
operator|.
name|v_syscall
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ISPL
argument_list|(
name|frame
operator|.
name|tf_cs
argument_list|)
operator|!=
name|SEL_UPL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* try to stabilize the system XXX */
name|panic
argument_list|(
literal|"syscall"
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sticks
operator|=
name|td
operator|->
name|td_kse
operator|->
name|ke_sticks
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
operator|&
name|frame
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|!=
name|p
operator|->
name|p_ucred
condition|)
name|cred_update_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|params
operator|=
operator|(
name|caddr_t
operator|)
name|frame
operator|.
name|tf_esp
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|code
operator|=
name|frame
operator|.
name|tf_eax
expr_stmt|;
name|orig_tf_eflags
operator|=
name|frame
operator|.
name|tf_eflags
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_prepsyscall
condition|)
block|{
comment|/* 		 * The prep code is MP aware. 		 */
call|(
modifier|*
name|p
operator|->
name|p_sysent
operator|->
name|sv_prepsyscall
call|)
argument_list|(
operator|&
name|frame
argument_list|,
name|args
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Need to check if this is a 32 bit or 64 bit syscall. 		 * fuword is MP aware. 		 */
if|if
condition|(
name|code
operator|==
name|SYS_syscall
condition|)
block|{
comment|/* 			 * Code is first argument, followed by actual args. 			 */
name|code
operator|=
name|fuword
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SYS___syscall
condition|)
block|{
comment|/* 			 * Like syscall, but code is a quad, so as to maintain 			 * quad alignment for the rest of the arguments. 			 */
name|code
operator|=
name|fuword
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|+=
sizeof|sizeof
argument_list|(
name|quad_t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
condition|)
name|code
operator|&=
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
literal|0
index|]
expr_stmt|;
else|else
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|code
index|]
expr_stmt|;
name|narg
operator|=
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_ARGMASK
expr_stmt|;
comment|/* 	 * copyin and the ktrsyscall()/ktrsysret() code is MP-aware 	 */
if|if
condition|(
name|params
operator|&&
operator|(
name|i
operator|=
name|narg
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|params
argument_list|,
operator|(
name|caddr_t
operator|)
name|args
argument_list|,
operator|(
name|u_int
operator|)
name|i
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|narg
argument_list|,
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Try to run the syscall without Giant if the syscall 	 * is MP safe. 	 */
if|if
condition|(
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_MPSAFE
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KTRACE
comment|/* 	 * We have to obtain Giant no matter what if  	 * we are ktracing 	 */
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
block|{
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|narg
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|frame
operator|.
name|tf_edx
expr_stmt|;
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCE
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|td
argument_list|,
name|args
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
name|frame
operator|.
name|tf_eax
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
name|frame
operator|.
name|tf_edx
operator|=
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
expr_stmt|;
name|frame
operator|.
name|tf_eflags
operator|&=
operator|~
name|PSL_C
expr_stmt|;
break|break;
case|case
name|ERESTART
case|:
comment|/* 		 * Reconstruct pc, assuming lcall $X,y is 7 bytes, 		 * int 0x80 is 2 bytes. We saved this in tf_err. 		 */
name|frame
operator|.
name|tf_eip
operator|-=
name|frame
operator|.
name|tf_err
expr_stmt|;
break|break;
case|case
name|EJUSTRETURN
case|:
break|break;
default|default:
name|bad
label|:
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
block|{
if|if
condition|(
name|error
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
name|error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* XXX */
else|else
name|error
operator|=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errtbl
index|[
name|error
index|]
expr_stmt|;
block|}
name|frame
operator|.
name|tf_eax
operator|=
name|error
expr_stmt|;
name|frame
operator|.
name|tf_eflags
operator||=
name|PSL_C
expr_stmt|;
break|break;
block|}
comment|/* 	 * Traced syscall. 	 */
if|if
condition|(
operator|(
name|orig_tf_eflags
operator|&
name|PSL_T
operator|)
operator|&&
operator|!
operator|(
name|orig_tf_eflags
operator|&
name|PSL_VM
operator|)
condition|)
block|{
name|frame
operator|.
name|tf_eflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|trapsignal
argument_list|(
name|p
argument_list|,
name|SIGTRAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Handle reschedule and other end-of-syscall issues 	 */
name|userret
argument_list|(
name|td
argument_list|,
operator|&
name|frame
argument_list|,
name|sticks
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
block|{
name|ktrsysret
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|error
argument_list|,
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Release Giant if we previously set it.  Do not 	 * release based on mtx_owned() - we want to catch 	 * broken syscalls. 	 */
if|if
condition|(
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_MPSAFE
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This works because errno is findable through the 	 * register set.  If we ever support an emulation where this 	 * is not the case, this code will need to be revisited. 	 */
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCX
argument_list|,
name|code
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|cred_free_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WITNESS
if|if
condition|(
name|witness_list
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"system call %s returning with mutex(s) held\n"
argument_list|,
name|syscallnames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

