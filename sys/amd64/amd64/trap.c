begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1994, David Greenman  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the University of Utah, and William Jolitz.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)trap.c	7.4 (Berkeley) 5/13/91  *	$Id: trap.c,v 1.123 1998/03/23 19:52:37 jlemon Exp $  */
end_comment

begin_comment
comment|/*  * 386 Trap and System call handling  */
end_comment

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|"opt_trap.h"
end_include

begin_include
include|#
directive|include
file|"opt_vm86.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/ipl.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/tss.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/intr_machdep.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|POWERFAIL_NMI
end_ifdef

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VM86
end_ifdef

begin_include
include|#
directive|include
file|<machine/vm86.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"isa.h"
end_include

begin_include
include|#
directive|include
file|"npx.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|i386tss
name|common_tss
decl_stmt|;
end_decl_stmt

begin_macro
name|int
argument_list|(
argument|*pmath_emulate
argument_list|)
end_macro

begin_expr_stmt
name|__P
argument_list|(
operator|(
expr|struct
name|trapframe
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|void
name|trap
name|__P
argument_list|(
operator|(
expr|struct
name|trapframe
name|frame
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|trapwrite
name|__P
argument_list|(
operator|(
name|unsigned
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|syscall
name|__P
argument_list|(
operator|(
expr|struct
name|trapframe
name|frame
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|trap_pfault
name|__P
argument_list|(
operator|(
expr|struct
name|trapframe
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trap_fatal
name|__P
argument_list|(
operator|(
expr|struct
name|trapframe
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dblfault_handler
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|inthand_t
name|IDTVEC
parameter_list|(
name|syscall
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAX_TRAP_MSG
value|28
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|trap_msg
index|[]
init|=
block|{
literal|""
block|,
comment|/*  0 unused */
literal|"privileged instruction fault"
block|,
comment|/*  1 T_PRIVINFLT */
literal|""
block|,
comment|/*  2 unused */
literal|"breakpoint instruction fault"
block|,
comment|/*  3 T_BPTFLT */
literal|""
block|,
comment|/*  4 unused */
literal|""
block|,
comment|/*  5 unused */
literal|"arithmetic trap"
block|,
comment|/*  6 T_ARITHTRAP */
literal|"system forced exception"
block|,
comment|/*  7 T_ASTFLT */
literal|""
block|,
comment|/*  8 unused */
literal|"general protection fault"
block|,
comment|/*  9 T_PROTFLT */
literal|"trace trap"
block|,
comment|/* 10 T_TRCTRAP */
literal|""
block|,
comment|/* 11 unused */
literal|"page fault"
block|,
comment|/* 12 T_PAGEFLT */
literal|""
block|,
comment|/* 13 unused */
literal|"alignment fault"
block|,
comment|/* 14 T_ALIGNFLT */
literal|""
block|,
comment|/* 15 unused */
literal|""
block|,
comment|/* 16 unused */
literal|""
block|,
comment|/* 17 unused */
literal|"integer divide fault"
block|,
comment|/* 18 T_DIVIDE */
literal|"non-maskable interrupt trap"
block|,
comment|/* 19 T_NMI */
literal|"overflow trap"
block|,
comment|/* 20 T_OFLOW */
literal|"FPU bounds check fault"
block|,
comment|/* 21 T_BOUND */
literal|"FPU device not available"
block|,
comment|/* 22 T_DNA */
literal|"double fault"
block|,
comment|/* 23 T_DOUBLEFLT */
literal|"FPU operand fetch fault"
block|,
comment|/* 24 T_FPOPFLT */
literal|"invalid TSS fault"
block|,
comment|/* 25 T_TSSFLT */
literal|"segment not present fault"
block|,
comment|/* 26 T_SEGNPFLT */
literal|"stack fault"
block|,
comment|/* 27 T_STKFLT */
literal|"machine check trap"
block|,
comment|/* 28 T_MCHK */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|userret
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
name|p
operator|,
expr|struct
name|trapframe
operator|*
name|frame
operator|,
name|u_quad_t
name|oticks
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_F00F_HACK
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|struct
name|gate_descriptor
modifier|*
name|t_idt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|has_f00f_bug
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|void
name|userret
parameter_list|(
name|p
parameter_list|,
name|frame
parameter_list|,
name|oticks
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|u_quad_t
name|oticks
decl_stmt|;
block|{
name|int
name|sig
decl_stmt|,
name|s
decl_stmt|;
while|while
condition|(
operator|(
name|sig
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|postsig
argument_list|(
name|sig
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (!want_resched&& 		(p->p_priority<= p->p_usrpri)&& 		(p->p_rtprio.type == RTP_PRIO_NORMAL)) { 		 int newpriority; 		 p->p_estcpu += 1; 		 newpriority = PUSER + p->p_estcpu / 4 + 2 * p->p_nice; 		 newpriority = min(newpriority, MAXPRI); 		 p->p_usrpri = newpriority; 	}
endif|#
directive|endif
name|p
operator|->
name|p_priority
operator|=
name|p
operator|->
name|p_usrpri
expr_stmt|;
if|if
condition|(
name|want_resched
condition|)
block|{
comment|/* 		 * Since we are curproc, clock will normally just change 		 * our priority without moving us from one queue to another 		 * (since the running process is not on a queue.) 		 * If that happened after we setrunqueue ourselves but before we 		 * mi_switch()'ed, we might not be on the queue indicated by 		 * our priority. 		 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|setrunqueue
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sig
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|postsig
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Charge system time if profiling. 	 */
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_PROFIL
condition|)
name|addupc_task
argument_list|(
name|p
argument_list|,
name|frame
operator|->
name|tf_eip
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|p
operator|->
name|p_sticks
operator|-
name|oticks
argument_list|)
operator|*
name|psratio
argument_list|)
expr_stmt|;
name|curpriority
operator|=
name|p
operator|->
name|p_priority
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Exception, fault, and trap interface to the FreeBSD kernel.  * This common code is called from assembly language IDT gate entry  * routines that prepare a suitable stack frame, and restore this  * frame after the exception has been processed.  */
end_comment

begin_function
name|void
name|trap
parameter_list|(
name|frame
parameter_list|)
name|struct
name|trapframe
name|frame
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|u_quad_t
name|sticks
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|ucode
init|=
literal|0
decl_stmt|,
name|type
decl_stmt|,
name|code
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|u_long
name|eva
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_F00F_HACK
argument_list|)
name|restart
label|:
endif|#
directive|endif
name|type
operator|=
name|frame
operator|.
name|tf_trapno
expr_stmt|;
name|code
operator|=
name|frame
operator|.
name|tf_err
expr_stmt|;
ifdef|#
directive|ifdef
name|VM86
if|if
condition|(
name|in_vm86call
condition|)
block|{
if|if
condition|(
name|frame
operator|.
name|tf_eflags
operator|&
name|PSL_VM
operator|&&
operator|(
name|type
operator|==
name|T_PROTFLT
operator|||
name|type
operator|==
name|T_STKFLT
operator|)
condition|)
block|{
name|i
operator|=
name|vm86_emulate
argument_list|(
operator|(
expr|struct
name|vm86frame
operator|*
operator|)
operator|&
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
comment|/* 				 * returns to original process 				 */
name|vm86_trap
argument_list|(
operator|(
expr|struct
name|vm86frame
operator|*
operator|)
operator|&
name|frame
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* 			 * these traps want either a process context, or 			 * assume a normal userspace trap. 			 */
case|case
name|T_PROTFLT
case|:
case|case
name|T_SEGNPFLT
case|:
name|trap_fatal
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_TRCTRAP
case|:
name|type
operator|=
name|T_BPTFLT
expr_stmt|;
comment|/* kernel breakpoint */
comment|/* FALL THROUGH */
block|}
goto|goto
name|kernel_trap
goto|;
comment|/* normal kernel trap handling */
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ISPL
argument_list|(
name|frame
operator|.
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
operator|)
operator|||
operator|(
name|frame
operator|.
name|tf_eflags
operator|&
name|PSL_VM
operator|)
condition|)
block|{
comment|/* user trap */
name|sticks
operator|=
name|p
operator|->
name|p_sticks
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_regs
operator|=
operator|&
name|frame
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_PRIVINFLT
case|:
comment|/* privileged instruction fault */
name|ucode
operator|=
name|type
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
name|T_BPTFLT
case|:
comment|/* bpt instruction fault */
case|case
name|T_TRCTRAP
case|:
comment|/* trace trap */
name|frame
operator|.
name|tf_eflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|T_ARITHTRAP
case|:
comment|/* arithmetic trap */
name|ucode
operator|=
name|code
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_ASTFLT
case|:
comment|/* Allow process switch */
name|astoff
argument_list|()
expr_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_OWEUPC
condition|)
block|{
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_OWEUPC
expr_stmt|;
name|addupc_task
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_stats
operator|->
name|p_prof
operator|.
name|pr_addr
argument_list|,
name|p
operator|->
name|p_stats
operator|->
name|p_prof
operator|.
name|pr_ticks
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
comment|/* 			 * The following two traps can happen in 			 * vm86 mode, and, if so, we want to handle 			 * them specially. 			 */
case|case
name|T_PROTFLT
case|:
comment|/* general protection fault */
case|case
name|T_STKFLT
case|:
comment|/* stack fault */
ifdef|#
directive|ifdef
name|VM86
if|if
condition|(
name|frame
operator|.
name|tf_eflags
operator|&
name|PSL_VM
condition|)
block|{
name|i
operator|=
name|vm86_emulate
argument_list|(
operator|(
expr|struct
name|vm86frame
operator|*
operator|)
operator|&
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
endif|#
directive|endif
comment|/* VM86 */
comment|/* FALL THROUGH */
case|case
name|T_SEGNPFLT
case|:
comment|/* segment not present fault */
case|case
name|T_TSSFLT
case|:
comment|/* invalid TSS fault */
case|case
name|T_DOUBLEFLT
case|:
comment|/* double fault */
default|default:
name|ucode
operator|=
name|code
operator|+
name|BUS_SEGM_FAULT
expr_stmt|;
name|i
operator|=
name|SIGBUS
expr_stmt|;
break|break;
case|case
name|T_PAGEFLT
case|:
comment|/* page fault */
name|i
operator|=
name|trap_pfault
argument_list|(
operator|&
name|frame
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_F00F_HACK
argument_list|)
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
goto|goto
name|restart
goto|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|ucode
operator|=
name|T_PAGEFLT
expr_stmt|;
break|break;
case|case
name|T_DIVIDE
case|:
comment|/* integer divide fault */
name|ucode
operator|=
name|FPE_INTDIV_TRAP
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
if|#
directive|if
name|NISA
operator|>
literal|0
case|case
name|T_NMI
case|:
ifdef|#
directive|ifdef
name|POWERFAIL_NMI
goto|goto
name|handle_powerfail
goto|;
else|#
directive|else
comment|/* !POWERFAIL_NMI */
ifdef|#
directive|ifdef
name|DDB
comment|/* NMI can be hooked up to a pushbutton for debugging */
name|printf
argument_list|(
literal|"NMI ... going to debugger\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|frame
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DDB */
comment|/* machine/parity/power fail/"kitchen sink" faults */
if|if
condition|(
name|isa_nmi
argument_list|(
name|code
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|panic
argument_list|(
literal|"NMI indicates hardware failure"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* POWERFAIL_NMI */
endif|#
directive|endif
comment|/* NISA> 0 */
case|case
name|T_OFLOW
case|:
comment|/* integer overflow fault */
name|ucode
operator|=
name|FPE_INTOVF_TRAP
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_BOUND
case|:
comment|/* bounds check fault */
name|ucode
operator|=
name|FPE_SUBRNG_TRAP
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_DNA
case|:
if|#
directive|if
name|NNPX
operator|>
literal|0
comment|/* if a transparent fault (due to context switch "late") */
if|if
condition|(
name|npxdna
argument_list|()
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pmath_emulate
condition|)
block|{
name|i
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
name|FPE_FPU_NP_TRAP
expr_stmt|;
break|break;
block|}
name|i
operator|=
call|(
modifier|*
name|pmath_emulate
call|)
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|frame
operator|.
name|tf_eflags
operator|&
name|PSL_T
operator|)
condition|)
return|return;
name|frame
operator|.
name|tf_eflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
block|}
comment|/* else ucode = emulator_only_knows() XXX */
break|break;
case|case
name|T_FPOPFLT
case|:
comment|/* FPU operand fetch fault */
name|ucode
operator|=
name|T_FPOPFLT
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|VM86
name|kernel_trap
label|:
endif|#
directive|endif
comment|/* kernel trap */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_PAGEFLT
case|:
comment|/* page fault */
operator|(
name|void
operator|)
name|trap_pfault
argument_list|(
operator|&
name|frame
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_DNA
case|:
if|#
directive|if
name|NNPX
operator|>
literal|0
comment|/* 			 * The kernel is apparently using npx for copying. 			 * XXX this should be fatal unless the kernel has 			 * registered such use. 			 */
if|if
condition|(
name|npxdna
argument_list|()
condition|)
return|return;
endif|#
directive|endif
break|break;
case|case
name|T_PROTFLT
case|:
comment|/* general protection fault */
case|case
name|T_SEGNPFLT
case|:
comment|/* segment not present fault */
comment|/* 			 * Invalid segment selectors and out of bounds 			 * %eip's and %esp's can be set up in user mode. 			 * This causes a fault in kernel mode when the 			 * kernel tries to return to user mode.  We want 			 * to get this fault so that we can fix the 			 * problem here and not have to check all the 			 * selectors and pointers when the user changes 			 * them. 			 */
define|#
directive|define
name|MAYBE_DORETI_FAULT
parameter_list|(
name|where
parameter_list|,
name|whereto
parameter_list|)
define|\
value|do {								\ 		if (frame.tf_eip == (int)where) {			\ 			frame.tf_eip = (int)whereto;			\ 			return;						\ 		}							\ 	} while (0)
if|if
condition|(
name|intr_nesting_level
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Invalid %fs's and %gs's can be created using 				 * procfs or PT_SETREGS or by invalidating the 				 * underlying LDT entry.  This causes a fault 				 * in kernel mode when the kernel attempts to 				 * switch contexts.  Lose the bad context 				 * (XXX) so that we can continue, and generate 				 * a signal. 				 */
if|if
condition|(
name|frame
operator|.
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|cpu_switch_load_fs
condition|)
block|{
name|curpcb
operator|->
name|pcb_fs
operator|=
literal|0
expr_stmt|;
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGBUS
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|frame
operator|.
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|cpu_switch_load_gs
condition|)
block|{
name|curpcb
operator|->
name|pcb_gs
operator|=
literal|0
expr_stmt|;
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGBUS
argument_list|)
expr_stmt|;
return|return;
block|}
name|MAYBE_DORETI_FAULT
argument_list|(
name|doreti_iret
argument_list|,
name|doreti_iret_fault
argument_list|)
expr_stmt|;
name|MAYBE_DORETI_FAULT
argument_list|(
name|doreti_popl_ds
argument_list|,
name|doreti_popl_ds_fault
argument_list|)
expr_stmt|;
name|MAYBE_DORETI_FAULT
argument_list|(
name|doreti_popl_es
argument_list|,
name|doreti_popl_es_fault
argument_list|)
expr_stmt|;
if|if
condition|(
name|curpcb
operator|&&
name|curpcb
operator|->
name|pcb_onfault
condition|)
block|{
name|frame
operator|.
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|curpcb
operator|->
name|pcb_onfault
expr_stmt|;
return|return;
block|}
block|}
break|break;
case|case
name|T_TSSFLT
case|:
comment|/* 			 * PSL_NT can be set in user mode and isn't cleared 			 * automatically when the kernel is entered.  This 			 * causes a TSS fault when the kernel attempts to 			 * `iret' because the TSS link is uninitialized.  We 			 * want to get this fault so that we can fix the 			 * problem here and not every time the kernel is 			 * entered. 			 */
if|if
condition|(
name|frame
operator|.
name|tf_eflags
operator|&
name|PSL_NT
condition|)
block|{
name|frame
operator|.
name|tf_eflags
operator|&=
operator|~
name|PSL_NT
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|T_TRCTRAP
case|:
comment|/* trace trap */
if|if
condition|(
name|frame
operator|.
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|IDTVEC
argument_list|(
name|syscall
argument_list|)
condition|)
block|{
comment|/* 				 * We've just entered system mode via the 				 * syscall lcall.  Continue single stepping 				 * silently until the syscall handler has 				 * saved the flags. 				 */
return|return;
block|}
if|if
condition|(
name|frame
operator|.
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|IDTVEC
argument_list|(
name|syscall
argument_list|)
operator|+
literal|1
condition|)
block|{
comment|/* 				 * The syscall handler has now saved the 				 * flags.  Stop single stepping it. 				 */
name|frame
operator|.
name|tf_eflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
return|return;
block|}
comment|/* 			 * Fall through. 			 */
case|case
name|T_BPTFLT
case|:
comment|/* 			 * If DDB is enabled, let it handle the debugger trap. 			 * Otherwise, debugger traps "can't happen". 			 */
ifdef|#
directive|ifdef
name|DDB
if|if
condition|(
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|frame
argument_list|)
condition|)
return|return;
endif|#
directive|endif
break|break;
if|#
directive|if
name|NISA
operator|>
literal|0
case|case
name|T_NMI
case|:
ifdef|#
directive|ifdef
name|POWERFAIL_NMI
ifndef|#
directive|ifndef
name|TIMER_FREQ
define|#
directive|define
name|TIMER_FREQ
value|1193182
endif|#
directive|endif
name|handle_powerfail
label|:
block|{
specifier|static
name|unsigned
name|lastalert
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|time
operator|.
name|tv_sec
operator|-
name|lastalert
operator|>
literal|10
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"NMI: power fail\n"
argument_list|)
expr_stmt|;
name|sysbeep
argument_list|(
name|TIMER_FREQ
operator|/
literal|880
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|lastalert
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
block|}
return|return;
block|}
else|#
directive|else
comment|/* !POWERFAIL_NMI */
ifdef|#
directive|ifdef
name|DDB
comment|/* NMI can be hooked up to a pushbutton for debugging */
name|printf
argument_list|(
literal|"NMI ... going to debugger\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|frame
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DDB */
comment|/* machine/parity/power fail/"kitchen sink" faults */
if|if
condition|(
name|isa_nmi
argument_list|(
name|code
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* FALL THROUGH */
endif|#
directive|endif
comment|/* POWERFAIL_NMI */
endif|#
directive|endif
comment|/* NISA> 0 */
block|}
name|trap_fatal
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
return|return;
block|}
name|trapsignal
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|ucode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|eva
operator|=
name|rcr2
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|MAX_TRAP_MSG
condition|)
block|{
name|uprintf
argument_list|(
literal|"fatal process exception: %s"
argument_list|,
name|trap_msg
index|[
name|type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|T_PAGEFLT
operator|)
operator|||
operator|(
name|type
operator|==
name|T_PROTFLT
operator|)
condition|)
name|uprintf
argument_list|(
literal|", fault VA = 0x%x"
argument_list|,
name|eva
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|out
label|:
name|userret
argument_list|(
name|p
argument_list|,
operator|&
name|frame
argument_list|,
name|sticks
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/*  * This version doesn't allow a page fault to user space while  * in the kernel. The rest of the kernel needs to be made "safe"  * before this can be used. I think the only things remaining  * to be made safe are the iBCS2 code and the process tracing/  * debugging code.  */
end_comment

begin_function
specifier|static
name|int
name|trap_pfault
parameter_list|(
name|frame
parameter_list|,
name|usermode
parameter_list|)
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|int
name|usermode
decl_stmt|;
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|NULL
decl_stmt|;
name|vm_map_t
name|map
init|=
literal|0
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
name|int
name|eva
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_err
operator|&
name|PGEX_W
condition|)
name|ftype
operator|=
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
expr_stmt|;
else|else
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
name|eva
operator|=
name|rcr2
argument_list|()
expr_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|eva
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|<
name|VM_MIN_KERNEL_ADDRESS
condition|)
block|{
name|vm_offset_t
name|v
decl_stmt|;
name|vm_page_t
name|mpte
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|(
operator|!
name|usermode
operator|&&
name|va
operator|<
name|VM_MAXUSER_ADDRESS
operator|&&
operator|(
name|intr_nesting_level
operator|!=
literal|0
operator|||
name|curpcb
operator|==
name|NULL
operator|||
name|curpcb
operator|->
name|pcb_onfault
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
name|trap_fatal
argument_list|(
name|frame
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * This is a fault on non-kernel virtual memory. 		 * vm is initialized above to NULL. If curproc is NULL 		 * or curproc->p_vmspace is NULL the fault is fatal. 		 */
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
if|if
condition|(
name|vm
operator|==
name|NULL
condition|)
goto|goto
name|nogo
goto|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
comment|/* 		 * Keep swapout from messing with us during this 		 *	critical time. 		 */
operator|++
name|p
operator|->
name|p_lock
expr_stmt|;
comment|/* 		 * Grow the stack if necessary 		 */
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|va
operator|>
name|vm
operator|->
name|vm_maxsaddr
operator|&&
operator|(
name|caddr_t
operator|)
name|va
operator|<
operator|(
name|caddr_t
operator|)
name|USRSTACK
condition|)
block|{
if|if
condition|(
operator|!
name|grow
argument_list|(
name|p
argument_list|,
name|va
argument_list|)
condition|)
block|{
name|rv
operator|=
name|KERN_FAILURE
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
goto|goto
name|nogo
goto|;
block|}
block|}
comment|/* Fault in the user page: */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
operator|(
name|ftype
operator|&
name|VM_PROT_WRITE
operator|)
condition|?
name|VM_FAULT_DIRTY
else|:
literal|0
argument_list|)
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Don't allow user-mode faults in kernel address space. 		 */
if|if
condition|(
name|usermode
condition|)
goto|goto
name|nogo
goto|;
comment|/* 		 * Since we know that kernel virtual address addresses 		 * always have pte pages mapped, we just have to fault 		 * the page. 		 */
name|rv
operator|=
name|vm_fault
argument_list|(
name|kernel_map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nogo
label|:
if|if
condition|(
operator|!
name|usermode
condition|)
block|{
if|if
condition|(
name|intr_nesting_level
operator|==
literal|0
operator|&&
name|curpcb
operator|&&
name|curpcb
operator|->
name|pcb_onfault
condition|)
block|{
name|frame
operator|->
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|curpcb
operator|->
name|pcb_onfault
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|trap_fatal
argument_list|(
name|frame
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* kludge to pass faulting virtual address to sendsig */
name|frame
operator|->
name|tf_err
operator|=
name|eva
expr_stmt|;
return|return
operator|(
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|trap_pfault
parameter_list|(
name|frame
parameter_list|,
name|usermode
parameter_list|)
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|int
name|usermode
decl_stmt|;
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|NULL
decl_stmt|;
name|vm_map_t
name|map
init|=
literal|0
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
name|int
name|eva
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|eva
operator|=
name|rcr2
argument_list|()
expr_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|eva
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|>=
name|KERNBASE
condition|)
block|{
comment|/* 		 * Don't allow user-mode faults in kernel address space. 		 * An exception:  if the faulting address is the invalid 		 * instruction entry in the IDT, then the Intel Pentium 		 * F00F bug workaround was triggered, and we need to 		 * treat it is as an illegal instruction, and not a page 		 * fault. 		 */
if|#
directive|if
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_F00F_HACK
argument_list|)
if|if
condition|(
operator|(
name|eva
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|&
name|t_idt
index|[
literal|6
index|]
operator|)
operator|&&
name|has_f00f_bug
condition|)
block|{
name|frame
operator|->
name|tf_trapno
operator|=
name|T_PRIVINFLT
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|usermode
condition|)
goto|goto
name|nogo
goto|;
name|map
operator|=
name|kernel_map
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is a fault on non-kernel virtual memory. 		 * vm is initialized above to NULL. If curproc is NULL 		 * or curproc->p_vmspace is NULL the fault is fatal. 		 */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
if|if
condition|(
name|vm
operator|==
name|NULL
condition|)
goto|goto
name|nogo
goto|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
block|}
if|if
condition|(
name|frame
operator|->
name|tf_err
operator|&
name|PGEX_W
condition|)
name|ftype
operator|=
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
expr_stmt|;
else|else
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|kernel_map
condition|)
block|{
comment|/* 		 * Keep swapout from messing with us during this 		 *	critical time. 		 */
operator|++
name|p
operator|->
name|p_lock
expr_stmt|;
comment|/* 		 * Grow the stack if necessary 		 */
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|va
operator|>
name|vm
operator|->
name|vm_maxsaddr
operator|&&
operator|(
name|caddr_t
operator|)
name|va
operator|<
operator|(
name|caddr_t
operator|)
name|USRSTACK
condition|)
block|{
if|if
condition|(
operator|!
name|grow
argument_list|(
name|p
argument_list|,
name|va
argument_list|)
condition|)
block|{
name|rv
operator|=
name|KERN_FAILURE
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
goto|goto
name|nogo
goto|;
block|}
block|}
comment|/* Fault in the user page: */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
operator|(
name|ftype
operator|&
name|VM_PROT_WRITE
operator|)
condition|?
name|VM_FAULT_DIRTY
else|:
literal|0
argument_list|)
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Don't have to worry about process locking or stacks in the kernel. 		 */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nogo
label|:
if|if
condition|(
operator|!
name|usermode
condition|)
block|{
if|if
condition|(
name|intr_nesting_level
operator|==
literal|0
operator|&&
name|curpcb
operator|&&
name|curpcb
operator|->
name|pcb_onfault
condition|)
block|{
name|frame
operator|->
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|curpcb
operator|->
name|pcb_onfault
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|trap_fatal
argument_list|(
name|frame
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* kludge to pass faulting virtual address to sendsig */
name|frame
operator|->
name|tf_err
operator|=
name|eva
expr_stmt|;
return|return
operator|(
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trap_fatal
parameter_list|(
name|frame
parameter_list|)
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
block|{
name|int
name|code
decl_stmt|,
name|type
decl_stmt|,
name|eva
decl_stmt|,
name|ss
decl_stmt|,
name|esp
decl_stmt|;
name|struct
name|soft_segment_descriptor
name|softseg
decl_stmt|;
name|code
operator|=
name|frame
operator|->
name|tf_err
expr_stmt|;
name|type
operator|=
name|frame
operator|->
name|tf_trapno
expr_stmt|;
name|eva
operator|=
name|rcr2
argument_list|()
expr_stmt|;
name|sdtossd
argument_list|(
operator|&
name|gdt
index|[
name|IDXSEL
argument_list|(
name|frame
operator|->
name|tf_cs
operator|&
literal|0xffff
argument_list|)
index|]
operator|.
name|sd
argument_list|,
operator|&
name|softseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|MAX_TRAP_MSG
condition|)
name|printf
argument_list|(
literal|"\n\nFatal trap %d: %s while in %s mode\n"
argument_list|,
name|type
argument_list|,
name|trap_msg
index|[
name|type
index|]
argument_list|,
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_VM
condition|?
literal|"vm86"
else|:
name|ISPL
argument_list|(
name|frame
operator|->
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
condition|?
literal|"user"
else|:
literal|"kernel"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* three seperate prints in case of a trap on an unmapped page */
name|printf
argument_list|(
literal|"mp_lock = %08x; "
argument_list|,
name|mp_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cpuid = %d; "
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lapic.id = %08x\n"
argument_list|,
name|lapic
operator|.
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|T_PAGEFLT
condition|)
block|{
name|printf
argument_list|(
literal|"fault virtual address	= 0x%x\n"
argument_list|,
name|eva
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fault code		= %s %s, %s\n"
argument_list|,
name|code
operator|&
name|PGEX_U
condition|?
literal|"user"
else|:
literal|"supervisor"
argument_list|,
name|code
operator|&
name|PGEX_W
condition|?
literal|"write"
else|:
literal|"read"
argument_list|,
name|code
operator|&
name|PGEX_P
condition|?
literal|"protection violation"
else|:
literal|"page not present"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"instruction pointer	= 0x%x:0x%x\n"
argument_list|,
name|frame
operator|->
name|tf_cs
operator|&
literal|0xffff
argument_list|,
name|frame
operator|->
name|tf_eip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ISPL
argument_list|(
name|frame
operator|->
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
operator|)
operator|||
operator|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_VM
operator|)
condition|)
block|{
name|ss
operator|=
name|frame
operator|->
name|tf_ss
operator|&
literal|0xffff
expr_stmt|;
name|esp
operator|=
name|frame
operator|->
name|tf_esp
expr_stmt|;
block|}
else|else
block|{
name|ss
operator|=
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|esp
operator|=
operator|(
name|int
operator|)
operator|&
name|frame
operator|->
name|tf_esp
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"stack pointer	        = 0x%x:0x%x\n"
argument_list|,
name|ss
argument_list|,
name|esp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"frame pointer	        = 0x%x:0x%x\n"
argument_list|,
name|ss
argument_list|,
name|frame
operator|->
name|tf_ebp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"code segment		= base 0x%x, limit 0x%x, type 0x%x\n"
argument_list|,
name|softseg
operator|.
name|ssd_base
argument_list|,
name|softseg
operator|.
name|ssd_limit
argument_list|,
name|softseg
operator|.
name|ssd_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"			= DPL %d, pres %d, def32 %d, gran %d\n"
argument_list|,
name|softseg
operator|.
name|ssd_dpl
argument_list|,
name|softseg
operator|.
name|ssd_p
argument_list|,
name|softseg
operator|.
name|ssd_def32
argument_list|,
name|softseg
operator|.
name|ssd_gran
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"processor eflags	= "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_T
condition|)
name|printf
argument_list|(
literal|"trace trap, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_I
condition|)
name|printf
argument_list|(
literal|"interrupt enabled, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_NT
condition|)
name|printf
argument_list|(
literal|"nested task, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_RF
condition|)
name|printf
argument_list|(
literal|"resume, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_VM
condition|)
name|printf
argument_list|(
literal|"vm86, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"IOPL = %d\n"
argument_list|,
operator|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_IOPL
operator|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"current process		= "
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
condition|)
block|{
name|printf
argument_list|(
literal|"%lu (%s)\n"
argument_list|,
operator|(
name|u_long
operator|)
name|curproc
operator|->
name|p_pid
argument_list|,
name|curproc
operator|->
name|p_comm
condition|?
name|curproc
operator|->
name|p_comm
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Idle\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"interrupt mask		= "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpl
operator|&
name|net_imask
operator|)
operator|==
name|net_imask
condition|)
name|printf
argument_list|(
literal|"net "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpl
operator|&
name|tty_imask
operator|)
operator|==
name|tty_imask
condition|)
name|printf
argument_list|(
literal|"tty "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpl
operator|&
name|bio_imask
operator|)
operator|==
name|bio_imask
condition|)
name|printf
argument_list|(
literal|"bio "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpl
operator|&
name|cam_imask
operator|)
operator|==
name|cam_imask
condition|)
name|printf
argument_list|(
literal|"cam "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpl
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/**  *  XXX FIXME:  *	we probably SHOULD have stopped the other CPUs before now!  *	another CPU COULD have been touching cpl at this moment...  */
name|printf
argument_list|(
literal|"<- SMP: XXX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|kdb_trap
argument_list|(
operator|&
name|psl
argument_list|)
condition|)
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DDB
if|if
condition|(
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|frame
argument_list|)
condition|)
return|return;
endif|#
directive|endif
name|printf
argument_list|(
literal|"trap number		= %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|MAX_TRAP_MSG
condition|)
name|panic
argument_list|(
name|trap_msg
index|[
name|type
index|]
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"unknown/reserved trap"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Double fault handler. Called when a fault occurs while writing  * a frame for a trap/exception onto the stack. This usually occurs  * when the stack overflows (such is the case with infinite recursion,  * for example).  *  * XXX Note that the current PTD gets replaced by IdlePTD when the  * task switch occurs. This means that the stack that was active at  * the time of the double fault is not available at<kstack> unless  * the machine was idle when the double fault occurred. The downside  * of this is that "trace<ebp>" in ddb won't work.  */
end_comment

begin_function
name|void
name|dblfault_handler
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\nFatal double fault:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"eip = 0x%x\n"
argument_list|,
name|common_tss
operator|.
name|tss_eip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"esp = 0x%x\n"
argument_list|,
name|common_tss
operator|.
name|tss_esp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ebp = 0x%x\n"
argument_list|,
name|common_tss
operator|.
name|tss_ebp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* three seperate prints in case of a trap on an unmapped page */
name|printf
argument_list|(
literal|"mp_lock = %08x; "
argument_list|,
name|mp_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cpuid = %d; "
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lapic.id = %08x\n"
argument_list|,
name|lapic
operator|.
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"double fault"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compensate for 386 brain damage (missing URKR).  * This is a little simpler than the pagefault handler in trap() because  * it the page tables have already been faulted in and high addresses  * are thrown out early for other reasons.  */
end_comment

begin_function
name|int
name|trapwrite
parameter_list|(
name|addr
parameter_list|)
name|unsigned
name|addr
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|)
expr_stmt|;
comment|/* 	 * XXX - MAX is END.  Changed> to>= for temp. fix. 	 */
if|if
condition|(
name|va
operator|>=
name|VM_MAXUSER_ADDRESS
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|p
operator|=
name|curproc
expr_stmt|;
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
operator|++
name|p
operator|->
name|p_lock
expr_stmt|;
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|va
operator|>=
name|vm
operator|->
name|vm_maxsaddr
operator|&&
operator|(
name|caddr_t
operator|)
name|va
operator|<
operator|(
name|caddr_t
operator|)
name|USRSTACK
condition|)
block|{
if|if
condition|(
operator|!
name|grow
argument_list|(
name|p
argument_list|,
name|va
argument_list|)
condition|)
block|{
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * fault the data page 	 */
name|rv
operator|=
name|vm_fault
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
name|va
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|VM_FAULT_DIRTY
argument_list|)
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
return|return
literal|1
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * System call request from POSIX system call gate interface to kernel.  * Like trap(), argument is call by reference.  */
end_comment

begin_function
name|void
name|syscall
parameter_list|(
name|frame
parameter_list|)
name|struct
name|trapframe
name|frame
decl_stmt|;
block|{
name|caddr_t
name|params
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|u_quad_t
name|sticks
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|args
index|[
literal|8
index|]
decl_stmt|;
name|u_int
name|code
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ISPL
argument_list|(
name|frame
operator|.
name|tf_cs
argument_list|)
operator|!=
name|SEL_UPL
condition|)
name|panic
argument_list|(
literal|"syscall"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sticks
operator|=
name|p
operator|->
name|p_sticks
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_regs
operator|=
operator|&
name|frame
expr_stmt|;
name|params
operator|=
operator|(
name|caddr_t
operator|)
name|frame
operator|.
name|tf_esp
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|code
operator|=
name|frame
operator|.
name|tf_eax
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_prepsyscall
condition|)
block|{
call|(
modifier|*
name|p
operator|->
name|p_sysent
operator|->
name|sv_prepsyscall
call|)
argument_list|(
operator|&
name|frame
argument_list|,
name|args
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Need to check if this is a 32 bit or 64 bit syscall. 		 */
if|if
condition|(
name|code
operator|==
name|SYS_syscall
condition|)
block|{
comment|/* 			 * Code is first argument, followed by actual args. 			 */
name|code
operator|=
name|fuword
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SYS___syscall
condition|)
block|{
comment|/* 			 * Like syscall, but code is a quad, so as to maintain 			 * quad alignment for the rest of the arguments. 			 */
name|code
operator|=
name|fuword
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|+=
sizeof|sizeof
argument_list|(
name|quad_t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
condition|)
name|code
operator|&=
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
literal|0
index|]
expr_stmt|;
else|else
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|code
index|]
expr_stmt|;
if|if
condition|(
name|params
operator|&&
operator|(
name|i
operator|=
name|callp
operator|->
name|sy_narg
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|params
argument_list|,
operator|(
name|caddr_t
operator|)
name|args
argument_list|,
operator|(
name|u_int
operator|)
name|i
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|1
index|]
operator|=
name|frame
operator|.
name|tf_edx
expr_stmt|;
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCE
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
comment|/* 		 * Reinitialize proc pointer `p' as it may be different 		 * if this is a child returning from fork syscall. 		 */
name|p
operator|=
name|curproc
expr_stmt|;
name|frame
operator|.
name|tf_eax
operator|=
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
expr_stmt|;
name|frame
operator|.
name|tf_edx
operator|=
name|p
operator|->
name|p_retval
index|[
literal|1
index|]
expr_stmt|;
name|frame
operator|.
name|tf_eflags
operator|&=
operator|~
name|PSL_C
expr_stmt|;
break|break;
case|case
name|ERESTART
case|:
comment|/* 		 * Reconstruct pc, assuming lcall $X,y is 7 bytes, 		 * int 0x80 is 2 bytes. We saved this in tf_err. 		 */
name|frame
operator|.
name|tf_eip
operator|-=
name|frame
operator|.
name|tf_err
expr_stmt|;
break|break;
case|case
name|EJUSTRETURN
case|:
break|break;
default|default:
name|bad
label|:
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
if|if
condition|(
name|error
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
name|error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* XXX */
else|else
name|error
operator|=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errtbl
index|[
name|error
index|]
expr_stmt|;
name|frame
operator|.
name|tf_eax
operator|=
name|error
expr_stmt|;
name|frame
operator|.
name|tf_eflags
operator||=
name|PSL_C
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|frame
operator|.
name|tf_eflags
operator|&
name|PSL_T
operator|)
operator|&&
operator|!
operator|(
name|frame
operator|.
name|tf_eflags
operator|&
name|PSL_VM
operator|)
condition|)
block|{
comment|/* Traced syscall. */
name|frame
operator|.
name|tf_eflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|trapsignal
argument_list|(
name|p
argument_list|,
name|SIGTRAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|userret
argument_list|(
name|p
argument_list|,
operator|&
name|frame
argument_list|,
name|sticks
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|error
argument_list|,
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * This works because errno is findable through the 	 * register set.  If we ever support an emulation where this 	 * is not the case, this code will need to be revisited. 	 */
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCX
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Simplified back end of syscall(), used when returning from fork()  * directly into user mode.  */
end_comment

begin_function
name|void
name|fork_return
parameter_list|(
name|p
parameter_list|,
name|frame
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|trapframe
name|frame
decl_stmt|;
block|{
name|frame
operator|.
name|tf_eax
operator|=
literal|0
expr_stmt|;
comment|/* Child returns zero */
name|frame
operator|.
name|tf_eflags
operator|&=
operator|~
name|PSL_C
expr_stmt|;
comment|/* success */
name|frame
operator|.
name|tf_edx
operator|=
literal|1
expr_stmt|;
name|userret
argument_list|(
name|p
argument_list|,
operator|&
name|frame
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|SYS_fork
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

