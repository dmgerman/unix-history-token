begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1994, David Greenman  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the University of Utah, and William Jolitz.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)trap.c	7.4 (Berkeley) 5/13/91  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * AMD64 Trap and System call handling  */
end_comment

begin_include
include|#
directive|include
file|"opt_clock.h"
end_include

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_include
include|#
directive|include
file|"opt_hwpmc_hooks.h"
end_include

begin_include
include|#
directive|include
file|"opt_isa.h"
end_include

begin_include
include|#
directive|include
file|"opt_kdb.h"
end_include

begin_include
include|#
directive|include
file|"opt_kdtrace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
end_ifdef

begin_include
include|#
directive|include
file|<sys/pmckern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<x86/mca.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/tss.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
end_ifdef

begin_include
include|#
directive|include
file|<sys/dtrace_bsd.h>
end_include

begin_comment
comment|/*  * This is a hook which is initialised by the dtrace module  * to handle traps which might occur during DTrace probe  * execution.  */
end_comment

begin_decl_stmt
name|dtrace_trap_func_t
name|dtrace_trap_func
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_doubletrap_func_t
name|dtrace_doubletrap_func
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is a hook which is initialised by the systrace module  * when it is loaded. This keeps the DTrace syscall provider  * implementation opaque.   */
end_comment

begin_decl_stmt
name|systrace_probe_func_t
name|systrace_probe_func
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These hooks are necessary for the pid, usdt and fasttrap providers.  */
end_comment

begin_decl_stmt
name|dtrace_fasttrap_probe_ptr_t
name|dtrace_fasttrap_probe_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_pid_probe_ptr_t
name|dtrace_pid_probe_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_return_probe_ptr_t
name|dtrace_return_probe_ptr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|void
name|trap
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|syscall
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dblfault_handler
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trap_pfault
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trap_fatal
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAX_TRAP_MSG
value|30
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|trap_msg
index|[]
init|=
block|{
literal|""
block|,
comment|/*  0 unused */
literal|"privileged instruction fault"
block|,
comment|/*  1 T_PRIVINFLT */
literal|""
block|,
comment|/*  2 unused */
literal|"breakpoint instruction fault"
block|,
comment|/*  3 T_BPTFLT */
literal|""
block|,
comment|/*  4 unused */
literal|""
block|,
comment|/*  5 unused */
literal|"arithmetic trap"
block|,
comment|/*  6 T_ARITHTRAP */
literal|""
block|,
comment|/*  7 unused */
literal|""
block|,
comment|/*  8 unused */
literal|"general protection fault"
block|,
comment|/*  9 T_PROTFLT */
literal|"trace trap"
block|,
comment|/* 10 T_TRCTRAP */
literal|""
block|,
comment|/* 11 unused */
literal|"page fault"
block|,
comment|/* 12 T_PAGEFLT */
literal|""
block|,
comment|/* 13 unused */
literal|"alignment fault"
block|,
comment|/* 14 T_ALIGNFLT */
literal|""
block|,
comment|/* 15 unused */
literal|""
block|,
comment|/* 16 unused */
literal|""
block|,
comment|/* 17 unused */
literal|"integer divide fault"
block|,
comment|/* 18 T_DIVIDE */
literal|"non-maskable interrupt trap"
block|,
comment|/* 19 T_NMI */
literal|"overflow trap"
block|,
comment|/* 20 T_OFLOW */
literal|"FPU bounds check fault"
block|,
comment|/* 21 T_BOUND */
literal|"FPU device not available"
block|,
comment|/* 22 T_DNA */
literal|"double fault"
block|,
comment|/* 23 T_DOUBLEFLT */
literal|"FPU operand fetch fault"
block|,
comment|/* 24 T_FPOPFLT */
literal|"invalid TSS fault"
block|,
comment|/* 25 T_TSSFLT */
literal|"segment not present fault"
block|,
comment|/* 26 T_SEGNPFLT */
literal|"stack fault"
block|,
comment|/* 27 T_STKFLT */
literal|"machine check trap"
block|,
comment|/* 28 T_MCHK */
literal|"SIMD floating-point exception"
block|,
comment|/* 29 T_XMMFLT */
literal|"reserved (unknown) fault"
block|,
comment|/* 30 T_RESERVED */
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KDB
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|kdb_on_nmi
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|kdb_on_nmi
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|kdb_on_nmi
argument_list|,
literal|0
argument_list|,
literal|"Go to KDB on NMI"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|panic_on_nmi
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|panic_on_nmi
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|panic_on_nmi
argument_list|,
literal|0
argument_list|,
literal|"Panic on NMI"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|prot_fault_translation
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|prot_fault_translation
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|prot_fault_translation
argument_list|,
literal|0
argument_list|,
literal|"Select signal to deliver on protection fault"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Exception, fault, and trap interface to the FreeBSD kernel.  * This common code is called from assembly language IDT gate entry  * routines that prepare a suitable stack frame, and restore this  * frame after the exception has been processed.  */
end_comment

begin_function
name|void
name|trap
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|ucode
init|=
literal|0
decl_stmt|,
name|code
decl_stmt|;
name|u_int
name|type
decl_stmt|;
name|register_t
name|addr
init|=
literal|0
decl_stmt|;
name|ksiginfo_t
name|ksi
decl_stmt|;
name|PCPU_INC
argument_list|(
name|cnt
operator|.
name|v_trap
argument_list|)
expr_stmt|;
name|type
operator|=
name|frame
operator|->
name|tf_trapno
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* Handler for NMI IPIs used for stopping CPUs. */
if|if
condition|(
name|type
operator|==
name|T_NMI
condition|)
block|{
if|if
condition|(
name|ipi_nmi_handler
argument_list|()
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
comment|/* SMP */
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|kdb_active
condition|)
block|{
name|kdb_reenter
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|T_RESERVED
condition|)
block|{
name|trap_fatal
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
comment|/* 	 * CPU PMCs interrupt using an NMI.  If the PMC module is 	 * active, pass the 'rip' value to the PMC module's interrupt 	 * handler.  A return value of '1' from the handler means that 	 * the NMI was handled by it and we can return immediately. 	 */
if|if
condition|(
name|type
operator|==
name|T_NMI
operator|&&
name|pmc_intr
operator|&&
call|(
modifier|*
name|pmc_intr
call|)
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
name|frame
argument_list|)
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|T_MCHK
condition|)
block|{
if|if
condition|(
operator|!
name|mca_intr
argument_list|()
condition|)
name|trap_fatal
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
comment|/* 	 * A trap can occur while DTrace executes a probe. Before 	 * executing the probe, DTrace blocks re-scheduling and sets 	 * a flag in it's per-cpu flags to indicate that it doesn't 	 * want to fault. On returning from the the probe, the no-fault 	 * flag is cleared and finally re-scheduling is enabled. 	 * 	 * If the DTrace kernel module has registered a trap handler, 	 * call it and if it returns non-zero, assume that it has 	 * handled the trap and modified the trap frame so that this 	 * function can return normally. 	 */
if|if
condition|(
name|dtrace_trap_func
operator|!=
name|NULL
condition|)
if|if
condition|(
call|(
modifier|*
name|dtrace_trap_func
call|)
argument_list|(
name|frame
argument_list|,
name|type
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|type
operator|==
name|T_DTRACE_PROBE
operator|||
name|type
operator|==
name|T_DTRACE_RET
operator|||
name|type
operator|==
name|T_BPTFLT
condition|)
block|{
name|struct
name|reg
name|regs
decl_stmt|;
name|fill_frame_regs
argument_list|(
name|frame
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_DTRACE_PROBE
operator|&&
name|dtrace_fasttrap_probe_ptr
operator|!=
name|NULL
operator|&&
name|dtrace_fasttrap_probe_ptr
argument_list|(
operator|&
name|regs
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|type
operator|==
name|T_BPTFLT
operator|&&
name|dtrace_pid_probe_ptr
operator|!=
name|NULL
operator|&&
name|dtrace_pid_probe_ptr
argument_list|(
operator|&
name|regs
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|type
operator|==
name|T_DTRACE_RET
operator|&&
name|dtrace_return_probe_ptr
operator|!=
name|NULL
operator|&&
name|dtrace_return_probe_ptr
argument_list|(
operator|&
name|regs
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|frame
operator|->
name|tf_rflags
operator|&
name|PSL_I
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Buggy application or kernel code has disabled 		 * interrupts and then trapped.  Enabling interrupts 		 * now is wrong, but it is better than running with 		 * interrupts disabled until they are accidentally 		 * enabled later. 		 */
if|if
condition|(
name|ISPL
argument_list|(
name|frame
operator|->
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
condition|)
name|uprintf
argument_list|(
literal|"pid %ld (%s): trap %d with interrupts disabled\n"
argument_list|,
operator|(
name|long
operator|)
name|curproc
operator|->
name|p_pid
argument_list|,
name|curthread
operator|->
name|td_name
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|!=
name|T_NMI
operator|&&
name|type
operator|!=
name|T_BPTFLT
operator|&&
name|type
operator|!=
name|T_TRCTRAP
condition|)
block|{
comment|/* 			 * XXX not quite right, since this may be for a 			 * multiple fault in user mode. 			 */
name|printf
argument_list|(
literal|"kernel trap %d with interrupts disabled\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* 			 * We shouldn't enable interrupts while holding a 			 * spin lock. 			 */
if|if
condition|(
name|td
operator|->
name|td_md
operator|.
name|md_spinlock_count
operator|==
literal|0
condition|)
name|enable_intr
argument_list|()
expr_stmt|;
block|}
block|}
name|code
operator|=
name|frame
operator|->
name|tf_err
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_PAGEFLT
condition|)
block|{
comment|/* 		 * If we get a page fault while in a critical section, then 		 * it is most likely a fatal kernel page fault.  The kernel 		 * is already going to panic trying to get a sleep lock to 		 * do the VM lookup, so just consider it a fatal trap so the 		 * kernel can print out a useful trap message and even get 		 * to the debugger. 		 * 		 * If we get a page fault while holding a non-sleepable 		 * lock, then it is most likely a fatal kernel page fault. 		 * If WITNESS is enabled, then it's going to whine about 		 * bogus LORs with various VM locks, so just skip to the 		 * fatal trap handling directly. 		 */
if|if
condition|(
name|td
operator|->
name|td_critnest
operator|!=
literal|0
operator|||
name|WITNESS_CHECK
argument_list|(
name|WARN_SLEEPOK
operator||
name|WARN_GIANTOK
argument_list|,
name|NULL
argument_list|,
literal|"Kernel page fault"
argument_list|)
operator|!=
literal|0
condition|)
name|trap_fatal
argument_list|(
name|frame
argument_list|,
name|frame
operator|->
name|tf_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISPL
argument_list|(
name|frame
operator|->
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
condition|)
block|{
comment|/* user trap */
name|td
operator|->
name|td_pticks
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
name|frame
expr_stmt|;
name|addr
operator|=
name|frame
operator|->
name|tf_rip
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|!=
name|p
operator|->
name|p_ucred
condition|)
name|cred_update_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_PRIVINFLT
case|:
comment|/* privileged instruction fault */
name|i
operator|=
name|SIGILL
expr_stmt|;
name|ucode
operator|=
name|ILL_PRVOPC
expr_stmt|;
break|break;
case|case
name|T_BPTFLT
case|:
comment|/* bpt instruction fault */
case|case
name|T_TRCTRAP
case|:
comment|/* trace trap */
name|enable_intr
argument_list|()
expr_stmt|;
name|frame
operator|->
name|tf_rflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
name|ucode
operator|=
operator|(
name|type
operator|==
name|T_TRCTRAP
condition|?
name|TRAP_TRACE
else|:
name|TRAP_BRKPT
operator|)
expr_stmt|;
break|break;
case|case
name|T_ARITHTRAP
case|:
comment|/* arithmetic trap */
name|ucode
operator|=
name|fputrap
argument_list|()
expr_stmt|;
if|if
condition|(
name|ucode
operator|==
operator|-
literal|1
condition|)
goto|goto
name|userout
goto|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_PROTFLT
case|:
comment|/* general protection fault */
name|i
operator|=
name|SIGBUS
expr_stmt|;
name|ucode
operator|=
name|BUS_OBJERR
expr_stmt|;
break|break;
case|case
name|T_STKFLT
case|:
comment|/* stack fault */
case|case
name|T_SEGNPFLT
case|:
comment|/* segment not present fault */
name|i
operator|=
name|SIGBUS
expr_stmt|;
name|ucode
operator|=
name|BUS_ADRERR
expr_stmt|;
break|break;
case|case
name|T_TSSFLT
case|:
comment|/* invalid TSS fault */
name|i
operator|=
name|SIGBUS
expr_stmt|;
name|ucode
operator|=
name|BUS_OBJERR
expr_stmt|;
break|break;
case|case
name|T_DOUBLEFLT
case|:
comment|/* double fault */
default|default:
name|i
operator|=
name|SIGBUS
expr_stmt|;
name|ucode
operator|=
name|BUS_OBJERR
expr_stmt|;
break|break;
case|case
name|T_PAGEFLT
case|:
comment|/* page fault */
name|addr
operator|=
name|frame
operator|->
name|tf_addr
expr_stmt|;
name|i
operator|=
name|trap_pfault
argument_list|(
name|frame
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
goto|goto
name|userout
goto|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|user
goto|;
if|if
condition|(
name|i
operator|==
name|SIGSEGV
condition|)
name|ucode
operator|=
name|SEGV_MAPERR
expr_stmt|;
else|else
block|{
if|if
condition|(
name|prot_fault_translation
operator|==
literal|0
condition|)
block|{
comment|/* 					 * Autodetect. 					 * This check also covers the images 					 * without the ABI-tag ELF note. 					 */
if|if
condition|(
name|SV_CURPROC_ABI
argument_list|()
operator|==
name|SV_ABI_FREEBSD
operator|&&
name|p
operator|->
name|p_osrel
operator|>=
name|P_OSREL_SIGSEGV
condition|)
block|{
name|i
operator|=
name|SIGSEGV
expr_stmt|;
name|ucode
operator|=
name|SEGV_ACCERR
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|SIGBUS
expr_stmt|;
name|ucode
operator|=
name|BUS_PAGE_FAULT
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|prot_fault_translation
operator|==
literal|1
condition|)
block|{
comment|/* 					 * Always compat mode. 					 */
name|i
operator|=
name|SIGBUS
expr_stmt|;
name|ucode
operator|=
name|BUS_PAGE_FAULT
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Always SIGSEGV mode. 					 */
name|i
operator|=
name|SIGSEGV
expr_stmt|;
name|ucode
operator|=
name|SEGV_ACCERR
expr_stmt|;
block|}
block|}
break|break;
case|case
name|T_DIVIDE
case|:
comment|/* integer divide fault */
name|ucode
operator|=
name|FPE_INTDIV
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEV_ISA
case|case
name|T_NMI
case|:
comment|/* machine/parity/power fail/"kitchen sink" faults */
if|if
condition|(
name|isa_nmi
argument_list|(
name|code
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|KDB
comment|/* 				 * NMI can be hooked up to a pushbutton 				 * for debugging. 				 */
if|if
condition|(
name|kdb_on_nmi
condition|)
block|{
name|printf
argument_list|(
literal|"NMI ... going to debugger\n"
argument_list|)
expr_stmt|;
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* KDB */
goto|goto
name|userout
goto|;
block|}
elseif|else
if|if
condition|(
name|panic_on_nmi
condition|)
name|panic
argument_list|(
literal|"NMI indicates hardware failure"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* DEV_ISA */
case|case
name|T_OFLOW
case|:
comment|/* integer overflow fault */
name|ucode
operator|=
name|FPE_INTOVF
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_BOUND
case|:
comment|/* bounds check fault */
name|ucode
operator|=
name|FPE_FLTSUB
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_DNA
case|:
comment|/* transparent fault (due to context switch "late") */
name|KASSERT
argument_list|(
name|PCB_USER_FPU
argument_list|(
name|td
operator|->
name|td_pcb
argument_list|)
argument_list|,
operator|(
literal|"kernel FPU ctx has leaked"
operator|)
argument_list|)
expr_stmt|;
name|fpudna
argument_list|()
expr_stmt|;
goto|goto
name|userout
goto|;
case|case
name|T_FPOPFLT
case|:
comment|/* FPU operand fetch fault */
name|ucode
operator|=
name|ILL_COPROC
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
name|T_XMMFLT
case|:
comment|/* SIMD floating-point exception */
name|ucode
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* kernel trap */
name|KASSERT
argument_list|(
name|cold
operator|||
name|td
operator|->
name|td_ucred
operator|!=
name|NULL
argument_list|,
operator|(
literal|"kernel trap doesn't have ucred"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_PAGEFLT
case|:
comment|/* page fault */
operator|(
name|void
operator|)
name|trap_pfault
argument_list|(
name|frame
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|T_DNA
case|:
name|KASSERT
argument_list|(
operator|!
name|PCB_USER_FPU
argument_list|(
name|td
operator|->
name|td_pcb
argument_list|)
argument_list|,
operator|(
literal|"Unregistered use of FPU in kernel"
operator|)
argument_list|)
expr_stmt|;
name|fpudna
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|T_ARITHTRAP
case|:
comment|/* arithmetic trap */
case|case
name|T_XMMFLT
case|:
comment|/* SIMD floating-point exception */
case|case
name|T_FPOPFLT
case|:
comment|/* FPU operand fetch fault */
comment|/* 			 * XXXKIB for now disable any FPU traps in kernel 			 * handler registration seems to be overkill 			 */
name|trap_fatal
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|T_STKFLT
case|:
comment|/* stack fault */
break|break;
case|case
name|T_PROTFLT
case|:
comment|/* general protection fault */
case|case
name|T_SEGNPFLT
case|:
comment|/* segment not present fault */
if|if
condition|(
name|td
operator|->
name|td_intr_nesting_level
operator|!=
literal|0
condition|)
break|break;
comment|/* 			 * Invalid segment selectors and out of bounds 			 * %rip's and %rsp's can be set up in user mode. 			 * This causes a fault in kernel mode when the 			 * kernel tries to return to user mode.  We want 			 * to get this fault so that we can fix the 			 * problem here and not have to check all the 			 * selectors and pointers when the user changes 			 * them. 			 */
if|if
condition|(
name|frame
operator|->
name|tf_rip
operator|==
operator|(
name|long
operator|)
name|doreti_iret
condition|)
block|{
name|frame
operator|->
name|tf_rip
operator|=
operator|(
name|long
operator|)
name|doreti_iret_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|frame
operator|->
name|tf_rip
operator|==
operator|(
name|long
operator|)
name|ld_ds
condition|)
block|{
name|frame
operator|->
name|tf_rip
operator|=
operator|(
name|long
operator|)
name|ds_load_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|frame
operator|->
name|tf_rip
operator|==
operator|(
name|long
operator|)
name|ld_es
condition|)
block|{
name|frame
operator|->
name|tf_rip
operator|=
operator|(
name|long
operator|)
name|es_load_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|frame
operator|->
name|tf_rip
operator|==
operator|(
name|long
operator|)
name|ld_fs
condition|)
block|{
name|frame
operator|->
name|tf_rip
operator|=
operator|(
name|long
operator|)
name|fs_load_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|frame
operator|->
name|tf_rip
operator|==
operator|(
name|long
operator|)
name|ld_gs
condition|)
block|{
name|frame
operator|->
name|tf_rip
operator|=
operator|(
name|long
operator|)
name|gs_load_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|frame
operator|->
name|tf_rip
operator|==
operator|(
name|long
operator|)
name|ld_gsbase
condition|)
block|{
name|frame
operator|->
name|tf_rip
operator|=
operator|(
name|long
operator|)
name|gsbase_load_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|frame
operator|->
name|tf_rip
operator|==
operator|(
name|long
operator|)
name|ld_fsbase
condition|)
block|{
name|frame
operator|->
name|tf_rip
operator|=
operator|(
name|long
operator|)
name|fsbase_load_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|->
name|pcb_onfault
operator|!=
name|NULL
condition|)
block|{
name|frame
operator|->
name|tf_rip
operator|=
operator|(
name|long
operator|)
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|->
name|pcb_onfault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|T_TSSFLT
case|:
comment|/* 			 * PSL_NT can be set in user mode and isn't cleared 			 * automatically when the kernel is entered.  This 			 * causes a TSS fault when the kernel attempts to 			 * `iret' because the TSS link is uninitialized.  We 			 * want to get this fault so that we can fix the 			 * problem here and not every time the kernel is 			 * entered. 			 */
if|if
condition|(
name|frame
operator|->
name|tf_rflags
operator|&
name|PSL_NT
condition|)
block|{
name|frame
operator|->
name|tf_rflags
operator|&=
operator|~
name|PSL_NT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|T_TRCTRAP
case|:
comment|/* trace trap */
comment|/* 			 * Ignore debug register trace traps due to 			 * accesses in the user's address space, which 			 * can happen under several conditions such as 			 * if a user sets a watchpoint on a buffer and 			 * then passes that buffer to a system call. 			 * We still want to get TRCTRAPS for addresses 			 * in kernel space because that is useful when 			 * debugging the kernel. 			 */
if|if
condition|(
name|user_dbreg_trap
argument_list|()
condition|)
block|{
comment|/* 				 * Reset breakpoint bits because the 				 * processor doesn't 				 */
comment|/* XXX check upper bits here */
name|load_dr6
argument_list|(
name|rdr6
argument_list|()
operator|&
literal|0xfffffff0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * FALLTHROUGH (TRCTRAP kernel mode, kernel address) 			 */
case|case
name|T_BPTFLT
case|:
comment|/* 			 * If KDB is enabled, let it handle the debugger trap. 			 * Otherwise, debugger traps "can't happen". 			 */
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|frame
argument_list|)
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|DEV_ISA
case|case
name|T_NMI
case|:
comment|/* machine/parity/power fail/"kitchen sink" faults */
if|if
condition|(
name|isa_nmi
argument_list|(
name|code
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|KDB
comment|/* 				 * NMI can be hooked up to a pushbutton 				 * for debugging. 				 */
if|if
condition|(
name|kdb_on_nmi
condition|)
block|{
name|printf
argument_list|(
literal|"NMI ... going to debugger\n"
argument_list|)
expr_stmt|;
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* KDB */
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|panic_on_nmi
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
comment|/* DEV_ISA */
block|}
name|trap_fatal
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Translate fault for emulators (e.g. Linux) */
if|if
condition|(
operator|*
name|p
operator|->
name|p_sysent
operator|->
name|sv_transtrap
condition|)
name|i
operator|=
call|(
modifier|*
name|p
operator|->
name|p_sysent
operator|->
name|sv_transtrap
call|)
argument_list|(
name|i
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ksiginfo_init_trap
argument_list|(
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|ksi_signo
operator|=
name|i
expr_stmt|;
name|ksi
operator|.
name|ksi_code
operator|=
name|ucode
expr_stmt|;
name|ksi
operator|.
name|ksi_trapno
operator|=
name|type
expr_stmt|;
name|ksi
operator|.
name|ksi_addr
operator|=
operator|(
name|void
operator|*
operator|)
name|addr
expr_stmt|;
name|trapsignal
argument_list|(
name|td
argument_list|,
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|user
label|:
name|userret
argument_list|(
name|td
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|PCB_USER_FPU
argument_list|(
name|td
operator|->
name|td_pcb
argument_list|)
argument_list|,
operator|(
literal|"Return from trap with kernel FPU ctx leaked"
operator|)
argument_list|)
expr_stmt|;
name|userout
label|:
name|out
label|:
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|trap_pfault
parameter_list|(
name|frame
parameter_list|,
name|usermode
parameter_list|)
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|int
name|usermode
decl_stmt|;
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|NULL
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|vm_offset_t
name|eva
init|=
name|frame
operator|->
name|tf_addr
decl_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
name|eva
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|>=
name|VM_MIN_KERNEL_ADDRESS
condition|)
block|{
comment|/* 		 * Don't allow user-mode faults in kernel address space. 		 */
if|if
condition|(
name|usermode
condition|)
goto|goto
name|nogo
goto|;
name|map
operator|=
name|kernel_map
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is a fault on non-kernel virtual memory. 		 * vm is initialized above to NULL. If curproc is NULL 		 * or curproc->p_vmspace is NULL the fault is fatal. 		 */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
if|if
condition|(
name|vm
operator|==
name|NULL
condition|)
goto|goto
name|nogo
goto|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
block|}
comment|/* 	 * PGEX_I is defined only if the execute disable bit capability is 	 * supported and enabled. 	 */
if|if
condition|(
name|frame
operator|->
name|tf_err
operator|&
name|PGEX_W
condition|)
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|frame
operator|->
name|tf_err
operator|&
name|PGEX_I
operator|)
operator|&&
name|pg_nx
operator|!=
literal|0
condition|)
name|ftype
operator|=
name|VM_PROT_EXECUTE
expr_stmt|;
else|else
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|kernel_map
condition|)
block|{
comment|/* 		 * Keep swapout from messing with us during this 		 *	critical time. 		 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Fault in the user page: */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Don't have to worry about process locking or stacks in the 		 * kernel. 		 */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nogo
label|:
if|if
condition|(
operator|!
name|usermode
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_intr_nesting_level
operator|==
literal|0
operator|&&
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|->
name|pcb_onfault
operator|!=
name|NULL
condition|)
block|{
name|frame
operator|->
name|tf_rip
operator|=
operator|(
name|long
operator|)
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
operator|->
name|pcb_onfault
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|trap_fatal
argument_list|(
name|frame
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trap_fatal
parameter_list|(
name|frame
parameter_list|,
name|eva
parameter_list|)
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|vm_offset_t
name|eva
decl_stmt|;
block|{
name|int
name|code
decl_stmt|,
name|ss
decl_stmt|;
name|u_int
name|type
decl_stmt|;
name|long
name|esp
decl_stmt|;
name|struct
name|soft_segment_descriptor
name|softseg
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|code
operator|=
name|frame
operator|->
name|tf_err
expr_stmt|;
name|type
operator|=
name|frame
operator|->
name|tf_trapno
expr_stmt|;
name|sdtossd
argument_list|(
operator|&
name|gdt
index|[
name|NGDT
operator|*
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|+
name|IDXSEL
argument_list|(
name|frame
operator|->
name|tf_cs
operator|&
literal|0xffff
argument_list|)
index|]
argument_list|,
operator|&
name|softseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|MAX_TRAP_MSG
condition|)
name|msg
operator|=
name|trap_msg
index|[
name|type
index|]
expr_stmt|;
else|else
name|msg
operator|=
literal|"UNKNOWN"
expr_stmt|;
name|printf
argument_list|(
literal|"\n\nFatal trap %d: %s while in %s mode\n"
argument_list|,
name|type
argument_list|,
name|msg
argument_list|,
name|ISPL
argument_list|(
name|frame
operator|->
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
condition|?
literal|"user"
else|:
literal|"kernel"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* two separate prints in case of a trap on an unmapped page */
name|printf
argument_list|(
literal|"cpuid = %d; "
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apic id = %02x\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|T_PAGEFLT
condition|)
block|{
name|printf
argument_list|(
literal|"fault virtual address	= 0x%lx\n"
argument_list|,
name|eva
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fault code		= %s %s %s, %s\n"
argument_list|,
name|code
operator|&
name|PGEX_U
condition|?
literal|"user"
else|:
literal|"supervisor"
argument_list|,
name|code
operator|&
name|PGEX_W
condition|?
literal|"write"
else|:
literal|"read"
argument_list|,
name|code
operator|&
name|PGEX_I
condition|?
literal|"instruction"
else|:
literal|"data"
argument_list|,
name|code
operator|&
name|PGEX_P
condition|?
literal|"protection violation"
else|:
literal|"page not present"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"instruction pointer	= 0x%lx:0x%lx\n"
argument_list|,
name|frame
operator|->
name|tf_cs
operator|&
literal|0xffff
argument_list|,
name|frame
operator|->
name|tf_rip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISPL
argument_list|(
name|frame
operator|->
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
condition|)
block|{
name|ss
operator|=
name|frame
operator|->
name|tf_ss
operator|&
literal|0xffff
expr_stmt|;
name|esp
operator|=
name|frame
operator|->
name|tf_rsp
expr_stmt|;
block|}
else|else
block|{
name|ss
operator|=
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|esp
operator|=
operator|(
name|long
operator|)
operator|&
name|frame
operator|->
name|tf_rsp
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"stack pointer	        = 0x%x:0x%lx\n"
argument_list|,
name|ss
argument_list|,
name|esp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"frame pointer	        = 0x%x:0x%lx\n"
argument_list|,
name|ss
argument_list|,
name|frame
operator|->
name|tf_rbp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"code segment		= base 0x%lx, limit 0x%lx, type 0x%x\n"
argument_list|,
name|softseg
operator|.
name|ssd_base
argument_list|,
name|softseg
operator|.
name|ssd_limit
argument_list|,
name|softseg
operator|.
name|ssd_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"			= DPL %d, pres %d, long %d, def32 %d, gran %d\n"
argument_list|,
name|softseg
operator|.
name|ssd_dpl
argument_list|,
name|softseg
operator|.
name|ssd_p
argument_list|,
name|softseg
operator|.
name|ssd_long
argument_list|,
name|softseg
operator|.
name|ssd_def32
argument_list|,
name|softseg
operator|.
name|ssd_gran
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"processor eflags	= "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_rflags
operator|&
name|PSL_T
condition|)
name|printf
argument_list|(
literal|"trace trap, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_rflags
operator|&
name|PSL_I
condition|)
name|printf
argument_list|(
literal|"interrupt enabled, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_rflags
operator|&
name|PSL_NT
condition|)
name|printf
argument_list|(
literal|"nested task, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_rflags
operator|&
name|PSL_RF
condition|)
name|printf
argument_list|(
literal|"resume, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"IOPL = %ld\n"
argument_list|,
operator|(
name|frame
operator|->
name|tf_rflags
operator|&
name|PSL_IOPL
operator|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"current process		= "
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
condition|)
block|{
name|printf
argument_list|(
literal|"%lu (%s)\n"
argument_list|,
operator|(
name|u_long
operator|)
name|curproc
operator|->
name|p_pid
argument_list|,
name|curthread
operator|->
name|td_name
condition|?
name|curthread
operator|->
name|td_name
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Idle\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|debugger_on_panic
operator|||
name|kdb_active
condition|)
if|if
condition|(
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|frame
argument_list|)
condition|)
return|return;
endif|#
directive|endif
name|printf
argument_list|(
literal|"trap number		= %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|MAX_TRAP_MSG
condition|)
name|panic
argument_list|(
literal|"%s"
argument_list|,
name|trap_msg
index|[
name|type
index|]
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"unknown/reserved trap"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Double fault handler. Called when a fault occurs while writing  * a frame for a trap/exception onto the stack. This usually occurs  * when the stack overflows (such is the case with infinite recursion,  * for example).  */
end_comment

begin_function
name|void
name|dblfault_handler
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
if|if
condition|(
name|dtrace_doubletrap_func
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|dtrace_doubletrap_func
call|)
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"\nFatal double fault\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rip = 0x%lx\n"
argument_list|,
name|frame
operator|->
name|tf_rip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rsp = 0x%lx\n"
argument_list|,
name|frame
operator|->
name|tf_rsp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rbp = 0x%lx\n"
argument_list|,
name|frame
operator|->
name|tf_rbp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* two separate prints in case of a trap on an unmapped page */
name|printf
argument_list|(
literal|"cpuid = %d; "
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apic id = %02x\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"double fault"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cpu_fetch_syscall_args
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|syscall_args
modifier|*
name|sa
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|register_t
modifier|*
name|argp
decl_stmt|;
name|caddr_t
name|params
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|regcnt
decl_stmt|,
name|error
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|frame
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
name|reg
operator|=
literal|0
expr_stmt|;
name|regcnt
operator|=
literal|6
expr_stmt|;
name|params
operator|=
operator|(
name|caddr_t
operator|)
name|frame
operator|->
name|tf_rsp
operator|+
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
expr_stmt|;
name|sa
operator|->
name|code
operator|=
name|frame
operator|->
name|tf_rax
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|code
operator|==
name|SYS_syscall
operator|||
name|sa
operator|->
name|code
operator|==
name|SYS___syscall
condition|)
block|{
name|sa
operator|->
name|code
operator|=
name|frame
operator|->
name|tf_rdi
expr_stmt|;
name|reg
operator|++
expr_stmt|;
name|regcnt
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
condition|)
name|sa
operator|->
name|code
operator|&=
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|code
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
name|sa
operator|->
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
literal|0
index|]
expr_stmt|;
else|else
name|sa
operator|->
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|sa
operator|->
name|code
index|]
expr_stmt|;
name|sa
operator|->
name|narg
operator|=
name|sa
operator|->
name|callp
operator|->
name|sy_narg
expr_stmt|;
name|KASSERT
argument_list|(
name|sa
operator|->
name|narg
operator|<=
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|(
literal|"Too many syscall arguments!"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|argp
operator|=
operator|&
name|frame
operator|->
name|tf_rdi
expr_stmt|;
name|argp
operator|+=
name|reg
expr_stmt|;
name|bcopy
argument_list|(
name|argp
argument_list|,
name|sa
operator|->
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|args
index|[
literal|0
index|]
argument_list|)
operator|*
name|regcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|narg
operator|>
name|regcnt
condition|)
block|{
name|KASSERT
argument_list|(
name|params
operator|!=
name|NULL
argument_list|,
operator|(
literal|"copyin args with no params!"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|params
argument_list|,
operator|&
name|sa
operator|->
name|args
index|[
name|regcnt
index|]
argument_list|,
operator|(
name|sa
operator|->
name|narg
operator|-
name|regcnt
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|frame
operator|->
name|tf_rdx
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	syscall -	system call request C handler  *  *	A system call is essentially treated as a trap.  */
end_comment

begin_function
name|void
name|syscall
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|syscall_args
name|sa
decl_stmt|;
name|register_t
name|orig_tf_rflags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ksiginfo_t
name|ksi
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ISPL
argument_list|(
name|frame
operator|->
name|tf_cs
argument_list|)
operator|!=
name|SEL_UPL
condition|)
block|{
name|panic
argument_list|(
literal|"syscall"
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
endif|#
directive|endif
name|orig_tf_rflags
operator|=
name|frame
operator|->
name|tf_rflags
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
name|frame
expr_stmt|;
name|error
operator|=
name|syscallenter
argument_list|(
name|td
argument_list|,
operator|&
name|sa
argument_list|)
expr_stmt|;
comment|/* 	 * Traced syscall. 	 */
if|if
condition|(
name|orig_tf_rflags
operator|&
name|PSL_T
condition|)
block|{
name|frame
operator|->
name|tf_rflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|ksiginfo_init_trap
argument_list|(
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|ksi_signo
operator|=
name|SIGTRAP
expr_stmt|;
name|ksi
operator|.
name|ksi_code
operator|=
name|TRAP_TRACE
expr_stmt|;
name|ksi
operator|.
name|ksi_addr
operator|=
operator|(
name|void
operator|*
operator|)
name|frame
operator|->
name|tf_rip
expr_stmt|;
name|trapsignal
argument_list|(
name|td
argument_list|,
operator|&
name|ksi
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|PCB_USER_FPU
argument_list|(
name|td
operator|->
name|td_pcb
argument_list|)
argument_list|,
operator|(
literal|"System call %s returing with kernel FPU ctx leaked"
operator|,
name|syscallname
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|sa
operator|.
name|code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|td
operator|->
name|td_pcb
operator|->
name|pcb_save
operator|==
operator|&
name|td
operator|->
name|td_pcb
operator|->
name|pcb_user_save
argument_list|,
operator|(
literal|"System call %s returning with mangled pcb_save"
operator|,
name|syscallname
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|sa
operator|.
name|code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|syscallret
argument_list|(
name|td
argument_list|,
name|error
argument_list|,
operator|&
name|sa
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

