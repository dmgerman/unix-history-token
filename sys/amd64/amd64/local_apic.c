begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 John Baldwin<jhb@FreeBSD.org>  * Copyright (c) 1996, by Steve Passe  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the developer may NOT be used to endorse or promote products  *    derived from this software without specific prior written permission.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Local APIC support on Pentium and later processors.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/cputypes.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/apicvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_comment
comment|/*  * We can handle up to 60 APICs via our logical cluster IDs, but currently  * the physical IDs on Intel processors up to the Pentium 4 are limited to  * 16.  */
end_comment

begin_define
define|#
directive|define
name|MAX_APICID
value|16
end_define

begin_comment
comment|/* Sanity checks on IDT vectors. */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|APIC_IO_INTS
operator|+
name|APIC_NUM_IOINTS
operator|<=
name|APIC_LOCAL_INTS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|IPI_STOP
operator|<
name|APIC_SPURIOUS_INT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Support for local APICs.  Local APICs manage interrupts on each  * individual processor as opposed to I/O APICs which receive interrupts  * from I/O devices and then forward them on to the local APICs.  *  * Local APICs can also send interrupts to each other thus providing the  * mechanism for IPIs.  */
end_comment

begin_struct
struct|struct
name|lvt
block|{
name|u_int
name|lvt_edgetrigger
range|:
literal|1
decl_stmt|;
name|u_int
name|lvt_activehi
range|:
literal|1
decl_stmt|;
name|u_int
name|lvt_masked
range|:
literal|1
decl_stmt|;
name|u_int
name|lvt_active
range|:
literal|1
decl_stmt|;
name|u_int
name|lvt_mode
range|:
literal|16
decl_stmt|;
name|u_int
name|lvt_vector
range|:
literal|8
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lapic
block|{
name|struct
name|lvt
name|la_lvts
index|[
name|LVT_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|u_int
name|la_id
range|:
literal|8
decl_stmt|;
name|u_int
name|la_cluster
range|:
literal|4
decl_stmt|;
name|u_int
name|la_cluster_id
range|:
literal|2
decl_stmt|;
name|u_int
name|la_present
range|:
literal|1
decl_stmt|;
block|}
decl|static
name|lapics
index|[
name|MAX_APICID
index|]
struct|;
end_struct

begin_comment
comment|/* XXX: should thermal be an NMI? */
end_comment

begin_comment
comment|/* Global defaults for local APIC LVT entries. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|lvt
name|lvts
index|[
name|LVT_MAX
operator|+
literal|1
index|]
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|APIC_LVT_DM_EXTINT
block|,
literal|0
block|}
block|,
comment|/* LINT0: masked ExtINT */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
name|APIC_LVT_DM_NMI
block|,
literal|0
block|}
block|,
comment|/* LINT1: NMI */
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|APIC_LVT_DM_FIXED
block|,
literal|0
block|}
block|,
comment|/* Timer: needs a vector */
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|APIC_LVT_DM_FIXED
block|,
literal|0
block|}
block|,
comment|/* Error: needs a vector */
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|APIC_LVT_DM_FIXED
block|,
literal|0
block|}
block|,
comment|/* PMC */
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|APIC_LVT_DM_FIXED
block|,
literal|0
block|}
block|,
comment|/* Thermal: needs a vector */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|inthand_t
modifier|*
name|ioint_handlers
index|[]
init|=
block|{
name|NULL
block|,
comment|/* 0 - 31 */
name|IDTVEC
argument_list|(
name|apic_isr1
argument_list|)
block|,
comment|/* 32 - 63 */
name|IDTVEC
argument_list|(
name|apic_isr2
argument_list|)
block|,
comment|/* 64 - 95 */
name|IDTVEC
argument_list|(
name|apic_isr3
argument_list|)
block|,
comment|/* 96 - 127 */
name|IDTVEC
argument_list|(
name|apic_isr4
argument_list|)
block|,
comment|/* 128 - 159 */
name|IDTVEC
argument_list|(
name|apic_isr5
argument_list|)
block|,
comment|/* 160 - 191 */
name|IDTVEC
argument_list|(
name|apic_isr6
argument_list|)
block|,
comment|/* 192 - 223 */
name|IDTVEC
argument_list|(
name|apic_isr7
argument_list|)
block|,
comment|/* 224 - 255 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|lapic_t
modifier|*
name|lapic
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint32_t
name|lvt_mode
parameter_list|(
name|struct
name|lapic
modifier|*
name|la
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|struct
name|lvt
modifier|*
name|lvt
decl_stmt|;
name|KASSERT
argument_list|(
name|pin
operator|<=
name|LVT_MAX
argument_list|,
operator|(
literal|"%s: pin %u out of range"
operator|,
name|__func__
operator|,
name|pin
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_active
condition|)
name|lvt
operator|=
operator|&
name|la
operator|->
name|la_lvts
index|[
name|pin
index|]
expr_stmt|;
else|else
name|lvt
operator|=
operator|&
name|lvts
index|[
name|pin
index|]
expr_stmt|;
name|value
operator|&=
operator|~
operator|(
name|APIC_LVT_M
operator||
name|APIC_LVT_TM
operator||
name|APIC_LVT_IIPP
operator||
name|APIC_LVT_DM
operator||
name|APIC_LVT_VECTOR
operator|)
expr_stmt|;
if|if
condition|(
name|lvt
operator|->
name|lvt_edgetrigger
operator|==
literal|0
condition|)
name|value
operator||=
name|APIC_LVT_TM
expr_stmt|;
if|if
condition|(
name|lvt
operator|->
name|lvt_activehi
operator|==
literal|0
condition|)
name|value
operator||=
name|APIC_LVT_IIPP_INTALO
expr_stmt|;
if|if
condition|(
name|lvt
operator|->
name|lvt_masked
condition|)
name|value
operator||=
name|APIC_LVT_M
expr_stmt|;
name|value
operator||=
name|lvt
operator|->
name|lvt_mode
expr_stmt|;
switch|switch
condition|(
name|lvt
operator|->
name|lvt_mode
condition|)
block|{
case|case
name|APIC_LVT_DM_NMI
case|:
case|case
name|APIC_LVT_DM_SMI
case|:
case|case
name|APIC_LVT_DM_INIT
case|:
case|case
name|APIC_LVT_DM_EXTINT
case|:
if|if
condition|(
operator|!
name|lvt
operator|->
name|lvt_edgetrigger
condition|)
block|{
name|printf
argument_list|(
literal|"lapic%u: Forcing LINT%u to edge trigger\n"
argument_list|,
name|la
operator|->
name|la_id
argument_list|,
name|pin
argument_list|)
expr_stmt|;
name|value
operator||=
name|APIC_LVT_TM
expr_stmt|;
block|}
comment|/* Use a vector of 0. */
break|break;
case|case
name|APIC_LVT_DM_FIXED
case|:
if|#
directive|if
literal|0
block|value |= lvt->lvt_vector;
else|#
directive|else
name|panic
argument_list|(
literal|"Fixed LINT pins not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|panic
argument_list|(
literal|"bad APIC LVT delivery mode: %#x\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map the local APIC and setup necessary interrupt vectors.  */
end_comment

begin_function
name|void
name|lapic_init
parameter_list|(
name|uintptr_t
name|addr
parameter_list|)
block|{
name|u_int32_t
name|value
decl_stmt|;
comment|/* Map the local APIC and setup the spurious interrupt handler. */
name|KASSERT
argument_list|(
name|trunc_page
argument_list|(
name|addr
argument_list|)
operator|==
name|addr
argument_list|,
operator|(
literal|"local APIC not aligned on a page boundary"
operator|)
argument_list|)
expr_stmt|;
name|lapic
operator|=
operator|(
name|lapic_t
operator|*
operator|)
name|pmap_mapdev
argument_list|(
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|lapic_t
argument_list|)
argument_list|)
expr_stmt|;
name|setidt
argument_list|(
name|APIC_SPURIOUS_INT
argument_list|,
name|IDTVEC
argument_list|(
name|spuriousint
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Perform basic initialization of the BSP's local APIC. */
name|value
operator|=
name|lapic
operator|->
name|svr
expr_stmt|;
name|value
operator|&=
operator|~
operator|(
name|APIC_SVR_VECTOR
operator||
name|APIC_SVR_FOCUS
operator|)
expr_stmt|;
name|value
operator||=
operator|(
name|APIC_SVR_FEN
operator||
name|APIC_SVR_SWEN
operator||
name|APIC_SPURIOUS_INT
operator|)
expr_stmt|;
name|lapic
operator|->
name|svr
operator|=
name|value
expr_stmt|;
comment|/* Set BSP's per-CPU local APIC ID. */
name|PCPU_SET
argument_list|(
name|apic_id
argument_list|,
name|lapic_id
argument_list|()
argument_list|)
expr_stmt|;
comment|/* XXX: timer/error/thermal interrupts */
block|}
end_function

begin_comment
comment|/*  * Create a local APIC instance.  */
end_comment

begin_function
name|void
name|lapic_create
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|int
name|boot_cpu
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|apic_id
operator|>
name|MAX_APICID
condition|)
block|{
name|printf
argument_list|(
literal|"APIC: Ignoring local APIC with ID %d\n"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|boot_cpu
condition|)
name|panic
argument_list|(
literal|"Can't ignore BSP"
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
operator|!
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"duplicate local APIC %u"
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Assume no local LVT overrides and a cluster of 0 and 	 * intra-cluster ID of 0. 	 */
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
operator|=
literal|1
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_id
operator|=
name|apic_id
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LVT_MAX
condition|;
name|i
operator|++
control|)
block|{
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|i
index|]
operator|=
name|lvts
index|[
name|i
index|]
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|i
index|]
operator|.
name|lvt_active
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SMP
name|cpu_add
argument_list|(
name|apic_id
argument_list|,
name|boot_cpu
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Dump contents of local APIC registers  */
end_comment

begin_function
name|void
name|lapic_dump
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|printf
argument_list|(
literal|"cpu%d %s:\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     ID: 0x%08x   VER: 0x%08x LDR: 0x%08x DFR: 0x%08x\n"
argument_list|,
name|lapic
operator|->
name|id
argument_list|,
name|lapic
operator|->
name|version
argument_list|,
name|lapic
operator|->
name|ldr
argument_list|,
name|lapic
operator|->
name|dfr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  lint0: 0x%08x lint1: 0x%08x TPR: 0x%08x SVR: 0x%08x\n"
argument_list|,
name|lapic
operator|->
name|lvt_lint0
argument_list|,
name|lapic
operator|->
name|lvt_lint1
argument_list|,
name|lapic
operator|->
name|tpr
argument_list|,
name|lapic
operator|->
name|svr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lapic_enable_intr
parameter_list|(
name|u_int
name|irq
parameter_list|)
block|{
name|u_int
name|vector
decl_stmt|;
name|vector
operator|=
name|apic_irq_to_idt
argument_list|(
name|irq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vector
operator|!=
name|IDT_SYSCALL
argument_list|,
operator|(
literal|"Attempt to overwrite syscall entry"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ioint_handlers
index|[
name|vector
operator|/
literal|32
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No ISR handler for IRQ %u"
operator|,
name|irq
operator|)
argument_list|)
expr_stmt|;
name|setidt
argument_list|(
name|vector
argument_list|,
name|ioint_handlers
index|[
name|vector
operator|/
literal|32
index|]
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lapic_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|lapic
modifier|*
name|la
decl_stmt|;
name|u_int32_t
name|value
decl_stmt|,
name|maxlvt
decl_stmt|;
name|register_t
name|eflags
decl_stmt|;
name|la
operator|=
operator|&
name|lapics
index|[
name|lapic_id
argument_list|()
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|la
operator|->
name|la_present
argument_list|,
operator|(
literal|"missing APIC structure"
operator|)
argument_list|)
expr_stmt|;
name|eflags
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|maxlvt
operator|=
operator|(
name|lapic
operator|->
name|version
operator|&
name|APIC_VER_MAXLVT
operator|)
operator|>>
name|MAXLVTSHIFT
expr_stmt|;
comment|/* Program LINT[01] LVT entries. */
name|lapic
operator|->
name|lvt_lint0
operator|=
name|lvt_mode
argument_list|(
name|la
argument_list|,
name|LVT_LINT0
argument_list|,
name|lapic
operator|->
name|lvt_lint0
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|lvt_lint1
operator|=
name|lvt_mode
argument_list|(
name|la
argument_list|,
name|LVT_LINT1
argument_list|,
name|lapic
operator|->
name|lvt_lint1
argument_list|)
expr_stmt|;
comment|/* XXX: more LVT entries */
comment|/* Clear the TPR. */
name|value
operator|=
name|lapic
operator|->
name|tpr
expr_stmt|;
name|value
operator|&=
operator|~
name|APIC_TPR_PRIO
expr_stmt|;
name|lapic
operator|->
name|tpr
operator|=
name|value
expr_stmt|;
comment|/* Use the cluster model for logical IDs. */
name|value
operator|=
name|lapic
operator|->
name|dfr
expr_stmt|;
name|value
operator|&=
operator|~
name|APIC_DFR_MODEL_MASK
expr_stmt|;
name|value
operator||=
name|APIC_DFR_MODEL_CLUSTER
expr_stmt|;
name|lapic
operator|->
name|dfr
operator|=
name|value
expr_stmt|;
comment|/* Set this APIC's logical ID. */
name|value
operator|=
name|lapic
operator|->
name|ldr
expr_stmt|;
name|value
operator|&=
operator|~
name|APIC_ID_MASK
expr_stmt|;
name|value
operator||=
operator|(
name|la
operator|->
name|la_cluster
operator|<<
name|APIC_ID_CLUSTER_SHIFT
operator||
literal|1
operator|<<
name|la
operator|->
name|la_cluster_id
operator|)
operator|<<
name|APIC_ID_SHIFT
expr_stmt|;
name|lapic
operator|->
name|ldr
operator|=
name|value
expr_stmt|;
comment|/* Setup spurious vector and enable the local APIC. */
name|value
operator|=
name|lapic
operator|->
name|svr
expr_stmt|;
name|value
operator|&=
operator|~
operator|(
name|APIC_SVR_VECTOR
operator||
name|APIC_SVR_FOCUS
operator|)
expr_stmt|;
name|value
operator||=
operator|(
name|APIC_SVR_FEN
operator||
name|APIC_SVR_SWEN
operator||
name|APIC_SPURIOUS_INT
operator|)
expr_stmt|;
name|lapic
operator|->
name|svr
operator|=
name|value
expr_stmt|;
name|intr_restore
argument_list|(
name|eflags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lapic_disable
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|value
decl_stmt|;
comment|/* Software disable the local APIC. */
name|value
operator|=
name|lapic
operator|->
name|svr
expr_stmt|;
name|value
operator|&=
operator|~
name|APIC_SVR_SWEN
expr_stmt|;
name|lapic
operator|->
name|svr
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lapic_id
parameter_list|(
name|void
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|lapic
operator|!=
name|NULL
argument_list|,
operator|(
literal|"local APIC is not mapped"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|lapic
operator|->
name|id
operator|>>
name|APIC_ID_SHIFT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lapic_intr_pending
parameter_list|(
name|u_int
name|vector
parameter_list|)
block|{
specifier|volatile
name|u_int32_t
modifier|*
name|irr
decl_stmt|;
comment|/* 	 * The IRR registers are an array of 128-bit registers each of 	 * which only describes 32 interrupts in the low 32 bits..  Thus, 	 * we divide the vector by 32 to get the 128-bit index.  We then 	 * multiply that index by 4 to get the equivalent index from 	 * treating the IRR as an array of 32-bit registers.  Finally, we 	 * modulus the vector by 32 to determine the individual bit to 	 * test. 	 */
name|irr
operator|=
operator|&
name|lapic
operator|->
name|irr0
expr_stmt|;
return|return
operator|(
name|irr
index|[
operator|(
name|vector
operator|/
literal|32
operator|)
operator|*
literal|4
index|]
operator|&
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lapic_set_logical_id
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|cluster
parameter_list|,
name|u_int
name|cluster_id
parameter_list|)
block|{
name|struct
name|lapic
modifier|*
name|la
decl_stmt|;
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: APIC %u doesn't exist"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cluster
operator|<=
name|APIC_MAX_CLUSTER
argument_list|,
operator|(
literal|"%s: cluster %u too big"
operator|,
name|__func__
operator|,
name|cluster
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cluster_id
operator|<=
name|APIC_MAX_INTRACLUSTER_ID
argument_list|,
operator|(
literal|"%s: intra cluster id %u too big"
operator|,
name|__func__
operator|,
name|cluster_id
operator|)
argument_list|)
expr_stmt|;
name|la
operator|=
operator|&
name|lapics
index|[
name|apic_id
index|]
expr_stmt|;
name|la
operator|->
name|la_cluster
operator|=
name|cluster
expr_stmt|;
name|la
operator|->
name|la_cluster_id
operator|=
name|cluster_id
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lapic_set_lvt_mask
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|u_char
name|masked
parameter_list|)
block|{
if|if
condition|(
name|pin
operator|>
name|LVT_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|apic_id
operator|==
name|APIC_ID_ALL
condition|)
block|{
name|lvts
index|[
name|pin
index|]
operator|.
name|lvt_masked
operator|=
name|masked
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: missing APIC %u"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_masked
operator|=
name|masked
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic%u:"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" LINT%u %s\n"
argument_list|,
name|pin
argument_list|,
name|masked
condition|?
literal|"masked"
else|:
literal|"unmasked"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lapic_set_lvt_mode
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|u_int32_t
name|mode
parameter_list|)
block|{
name|struct
name|lvt
modifier|*
name|lvt
decl_stmt|;
if|if
condition|(
name|pin
operator|>
name|LVT_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|apic_id
operator|==
name|APIC_ID_ALL
condition|)
block|{
name|lvt
operator|=
operator|&
name|lvts
index|[
name|pin
index|]
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: missing APIC %u"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|lvt
operator|=
operator|&
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
expr_stmt|;
name|lvt
operator|->
name|lvt_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic%u:"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
block|}
name|lvt
operator|->
name|lvt_mode
operator|=
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|APIC_LVT_DM_NMI
case|:
case|case
name|APIC_LVT_DM_SMI
case|:
case|case
name|APIC_LVT_DM_INIT
case|:
case|case
name|APIC_LVT_DM_EXTINT
case|:
name|lvt
operator|->
name|lvt_edgetrigger
operator|=
literal|1
expr_stmt|;
name|lvt
operator|->
name|lvt_activehi
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|APIC_LVT_DM_EXTINT
condition|)
name|lvt
operator|->
name|lvt_masked
operator|=
literal|1
expr_stmt|;
else|else
name|lvt
operator|->
name|lvt_masked
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unsupported delivery mode: 0x%x\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|" Routing "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|APIC_LVT_DM_NMI
case|:
name|printf
argument_list|(
literal|"NMI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_DM_SMI
case|:
name|printf
argument_list|(
literal|"SMI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_DM_INIT
case|:
name|printf
argument_list|(
literal|"INIT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_DM_EXTINT
case|:
name|printf
argument_list|(
literal|"ExtINT"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|" -> LINT%u\n"
argument_list|,
name|pin
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lapic_set_lvt_polarity
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|u_char
name|activehi
parameter_list|)
block|{
if|if
condition|(
name|pin
operator|>
name|LVT_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|apic_id
operator|==
name|APIC_ID_ALL
condition|)
block|{
name|lvts
index|[
name|pin
index|]
operator|.
name|lvt_activehi
operator|=
name|activehi
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: missing APIC %u"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_active
operator|=
literal|1
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_activehi
operator|=
name|activehi
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic%u:"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" LINT%u polarity: active-%s\n"
argument_list|,
name|pin
argument_list|,
name|activehi
condition|?
literal|"hi"
else|:
literal|"lo"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lapic_set_lvt_triggermode
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|u_char
name|edgetrigger
parameter_list|)
block|{
if|if
condition|(
name|pin
operator|>
name|LVT_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|apic_id
operator|==
name|APIC_ID_ALL
condition|)
block|{
name|lvts
index|[
name|pin
index|]
operator|.
name|lvt_edgetrigger
operator|=
name|edgetrigger
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: missing APIC %u"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_edgetrigger
operator|=
name|edgetrigger
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic%u:"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" LINT%u trigger: %s\n"
argument_list|,
name|pin
argument_list|,
name|edgetrigger
condition|?
literal|"edge"
else|:
literal|"level"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lapic_eoi
parameter_list|(
name|void
parameter_list|)
block|{
name|lapic
operator|->
name|eoi
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lapic_handle_intr
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|,
name|struct
name|intrframe
name|frame
parameter_list|)
block|{
name|struct
name|intsrc
modifier|*
name|isrc
decl_stmt|;
name|int
name|vec
init|=
operator|(
name|uintptr_t
operator|)
name|cookie
decl_stmt|;
if|if
condition|(
name|vec
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"Couldn't get vector from ISR!"
argument_list|)
expr_stmt|;
name|isrc
operator|=
name|intr_lookup_source
argument_list|(
name|apic_idt_to_irq
argument_list|(
name|vec
argument_list|)
argument_list|)
expr_stmt|;
name|intr_execute_handlers
argument_list|(
name|isrc
argument_list|,
operator|&
name|frame
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate between IDT vectors and IRQ vectors. */
end_comment

begin_function
name|u_int
name|apic_irq_to_idt
parameter_list|(
name|u_int
name|irq
parameter_list|)
block|{
name|u_int
name|vector
decl_stmt|;
name|KASSERT
argument_list|(
name|irq
operator|<
name|NUM_IO_INTS
argument_list|,
operator|(
literal|"Invalid IRQ %u"
operator|,
name|irq
operator|)
argument_list|)
expr_stmt|;
name|vector
operator|=
name|irq
operator|+
name|APIC_IO_INTS
expr_stmt|;
if|if
condition|(
name|vector
operator|>=
name|IDT_SYSCALL
condition|)
name|vector
operator|++
expr_stmt|;
return|return
operator|(
name|vector
operator|)
return|;
block|}
end_function

begin_function
name|u_int
name|apic_idt_to_irq
parameter_list|(
name|u_int
name|vector
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|vector
operator|>=
name|APIC_IO_INTS
operator|&&
name|vector
operator|!=
name|IDT_SYSCALL
operator|&&
name|vector
operator|<=
name|APIC_IO_INTS
operator|+
name|NUM_IO_INTS
argument_list|,
operator|(
literal|"Vector %u does not map to an IRQ line"
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vector
operator|>
name|IDT_SYSCALL
condition|)
name|vector
operator|--
expr_stmt|;
return|return
operator|(
name|vector
operator|-
name|APIC_IO_INTS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * APIC probing support code.  This includes code to manage enumerators.  */
end_comment

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|apic_enumerator
argument_list|)
name|enumerators
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|enumerators
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|apic_enumerator
modifier|*
name|best_enum
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|apic_register_enumerator
parameter_list|(
name|struct
name|apic_enumerator
modifier|*
name|enumerator
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|apic_enumerator
modifier|*
name|apic_enum
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|apic_enum
argument_list|,
argument|&enumerators
argument_list|,
argument|apic_next
argument_list|)
block|{
if|if
condition|(
name|apic_enum
operator|==
name|enumerator
condition|)
name|panic
argument_list|(
literal|"%s: Duplicate register of %s"
argument_list|,
name|__func__
argument_list|,
name|enumerator
operator|->
name|apic_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|enumerators
argument_list|,
name|enumerator
argument_list|,
name|apic_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We have to look for CPU's very, very early because certain subsystems  * want to know how many CPU's we have extremely early on in the boot  * process.  */
end_comment

begin_function
specifier|static
name|void
name|apic_init
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|struct
name|apic_enumerator
modifier|*
name|enumerator
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|best
decl_stmt|;
comment|/* We only support built in local APICs. */
if|if
condition|(
operator|!
operator|(
name|cpu_feature
operator|&
name|CPUID_APIC
operator|)
condition|)
return|return;
comment|/* First, probe all the enumerators to find the best match. */
name|best_enum
operator|=
name|NULL
expr_stmt|;
name|best
operator|=
literal|0
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|enumerator
argument_list|,
argument|&enumerators
argument_list|,
argument|apic_next
argument_list|)
block|{
name|retval
operator|=
name|enumerator
operator|->
name|apic_probe
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|>
literal|0
condition|)
continue|continue;
if|if
condition|(
name|best_enum
operator|==
name|NULL
operator|||
name|best
operator|<
name|retval
condition|)
block|{
name|best_enum
operator|=
name|enumerator
expr_stmt|;
name|best
operator|=
name|retval
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_enum
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"APIC: Could not find any APICs.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"APIC: Using the %s enumerator.\n"
argument_list|,
name|best_enum
operator|->
name|apic_name
argument_list|)
expr_stmt|;
comment|/* Second, probe the CPU's in the system. */
name|retval
operator|=
name|best_enum
operator|->
name|apic_probe_cpus
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Failed to probe CPUs: returned %d\n"
argument_list|,
name|best_enum
operator|->
name|apic_name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|apic_init
argument_list|,
argument|SI_SUB_TUNABLES -
literal|1
argument_list|,
argument|SI_ORDER_SECOND
argument_list|,
argument|apic_init
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_comment
comment|/*  * Setup the local APIC.  We have to do this prior to starting up the APs  * in the SMP case.  */
end_comment

begin_function
specifier|static
name|void
name|apic_setup_local
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|best_enum
operator|==
name|NULL
condition|)
return|return;
name|retval
operator|=
name|best_enum
operator|->
name|apic_setup_local
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Failed to setup the local APIC: returned %d\n"
argument_list|,
name|best_enum
operator|->
name|apic_name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|apic_setup_local
argument_list|,
argument|SI_SUB_CPU
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|apic_setup_local
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_comment
comment|/*  * Setup the I/O APICs.  */
end_comment

begin_function
specifier|static
name|void
name|apic_setup_io
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|best_enum
operator|==
name|NULL
condition|)
return|return;
name|retval
operator|=
name|best_enum
operator|->
name|apic_setup_io
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Failed to setup I/O APICs: returned %d\n"
argument_list|,
name|best_enum
operator|->
name|apic_name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* 	 * Finish setting up the local APIC on the BSP once we know how to 	 * properly program the LINT pins. 	 */
name|lapic_setup
argument_list|()
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|lapic_dump
argument_list|(
literal|"BSP"
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|apic_setup_io
argument_list|,
argument|SI_SUB_INTR
argument_list|,
argument|SI_ORDER_SECOND
argument_list|,
argument|apic_setup_io
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_comment
comment|/*  * Inter Processor Interrupt functions.  The lapic_ipi_*() functions are  * private the sys/i386 code.  The public interface for the rest of the  * kernel is defined in mp_machdep.c.  */
end_comment

begin_define
define|#
directive|define
name|DETECT_DEADLOCK
end_define

begin_function
name|int
name|lapic_ipi_wait
parameter_list|(
name|int
name|delay
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|incr
decl_stmt|;
comment|/* 	 * Wait delay loops for IPI to be sent.  This is highly bogus 	 * since this is sensitive to CPU clock speed.  If delay is 	 * -1, we wait forever. 	 */
if|if
condition|(
name|delay
operator|==
operator|-
literal|1
condition|)
block|{
name|incr
operator|=
literal|0
expr_stmt|;
name|delay
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|incr
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|delay
condition|;
name|x
operator|+=
name|incr
control|)
block|{
if|if
condition|(
operator|(
name|lapic
operator|->
name|icr_lo
operator|&
name|APIC_DELSTAT_MASK
operator|)
operator|==
name|APIC_DELSTAT_IDLE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ia32_pause
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lapic_ipi_raw
parameter_list|(
name|register_t
name|icrlo
parameter_list|,
name|u_int
name|dest
parameter_list|)
block|{
name|register_t
name|value
decl_stmt|,
name|eflags
decl_stmt|;
comment|/* XXX: Need more sanity checking of icrlo? */
name|KASSERT
argument_list|(
name|lapic
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s called too early"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|dest
operator|&
operator|~
operator|(
name|APIC_ID_MASK
operator|>>
name|APIC_ID_SHIFT
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: invalid dest field"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|icrlo
operator|&
name|APIC_ICRLO_RESV_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: reserved bits set in ICR LO register"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Set destination in ICR HI register if it is being used. */
name|eflags
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|icrlo
operator|&
name|APIC_DEST_MASK
operator|)
operator|==
name|APIC_DEST_DESTFLD
condition|)
block|{
name|value
operator|=
name|lapic
operator|->
name|icr_hi
expr_stmt|;
name|value
operator|&=
operator|~
name|APIC_ID_MASK
expr_stmt|;
name|value
operator||=
name|dest
operator|<<
name|APIC_ID_SHIFT
expr_stmt|;
name|lapic
operator|->
name|icr_hi
operator|=
name|value
expr_stmt|;
block|}
comment|/* Program the contents of the IPI and dispatch it. */
name|value
operator|=
name|lapic
operator|->
name|icr_lo
expr_stmt|;
name|value
operator|&=
name|APIC_ICRLO_RESV_MASK
expr_stmt|;
name|value
operator||=
name|icrlo
expr_stmt|;
name|lapic
operator|->
name|icr_lo
operator|=
name|value
expr_stmt|;
name|intr_restore
argument_list|(
name|eflags
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DETECT_DEADLOCK
end_ifdef

begin_define
define|#
directive|define
name|BEFORE_SPIN
value|1000000
end_define

begin_define
define|#
directive|define
name|AFTER_SPIN
value|1000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|lapic_ipi_vectored
parameter_list|(
name|u_int
name|vector
parameter_list|,
name|int
name|dest
parameter_list|)
block|{
name|register_t
name|icrlo
decl_stmt|,
name|destfield
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|vector
operator|&
operator|~
name|APIC_VECTOR_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: invalid vector %d"
operator|,
name|__func__
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
name|icrlo
operator|=
name|vector
operator||
name|APIC_DELMODE_FIXED
operator||
name|APIC_DESTMODE_PHY
operator||
name|APIC_LEVEL_DEASSERT
operator||
name|APIC_TRIGMOD_EDGE
expr_stmt|;
name|destfield
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|dest
condition|)
block|{
case|case
name|APIC_IPI_DEST_SELF
case|:
name|icrlo
operator||=
name|APIC_DEST_SELF
expr_stmt|;
break|break;
case|case
name|APIC_IPI_DEST_ALL
case|:
name|icrlo
operator||=
name|APIC_DEST_ALLISELF
expr_stmt|;
break|break;
case|case
name|APIC_IPI_DEST_OTHERS
case|:
name|icrlo
operator||=
name|APIC_DEST_ALLESELF
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
operator|(
name|dest
operator|&
operator|~
operator|(
name|APIC_ID_MASK
operator|>>
name|APIC_ID_SHIFT
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: invalid destination 0x%x"
operator|,
name|__func__
operator|,
name|dest
operator|)
argument_list|)
expr_stmt|;
name|destfield
operator|=
name|dest
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DETECT_DEADLOCK
comment|/* Check for an earlier stuck IPI. */
if|if
condition|(
operator|!
name|lapic_ipi_wait
argument_list|(
name|BEFORE_SPIN
argument_list|)
condition|)
name|panic
argument_list|(
literal|"APIC: Previous IPI is stuck"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lapic_ipi_raw
argument_list|(
name|icrlo
argument_list|,
name|destfield
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DETECT_DEADLOCK
comment|/* Wait for IPI to be delivered. */
if|if
condition|(
operator|!
name|lapic_ipi_wait
argument_list|(
name|AFTER_SPIN
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|needsattention
comment|/* 		 * XXX FIXME: 		 * 		 * The above function waits for the message to actually be 		 * delivered.  It breaks out after an arbitrary timeout 		 * since the message should eventually be delivered (at 		 * least in theory) and that if it wasn't we would catch 		 * the failure with the check above when the next IPI is 		 * sent. 		 * 		 * We could skiip this wait entirely, EXCEPT it probably 		 * protects us from other routines that assume that the 		 * message was delivered and acted upon when this function 		 * returns. 		 */
name|printf
argument_list|(
literal|"APIC: IPI might be stuck\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !needsattention */
comment|/* Wait until mesage is sent without a timeout. */
while|while
condition|(
name|lapic
operator|->
name|icr_lo
operator|&
name|APIC_DELSTAT_PEND
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* needsattention */
block|}
endif|#
directive|endif
comment|/* DETECT_DEADLOCK */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP */
end_comment

end_unit

