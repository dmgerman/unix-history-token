begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1996, by Steve Passe  * Copyright (c) 2003, by Peter Wemm  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the developer may NOT be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_kstack_pages.h"
end_include

begin_include
include|#
directive|include
file|"opt_sched.h"
end_include

begin_include
include|#
directive|include
file|"opt_smp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GPROF
end_ifdef

begin_include
include|#
directive|include
file|<sys/gmon.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/memrange.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<x86/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cputypes.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<x86/mca.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/tss.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<x86/init.h>
end_include

begin_define
define|#
directive|define
name|WARMBOOT_TARGET
value|0
end_define

begin_define
define|#
directive|define
name|WARMBOOT_OFF
value|(KERNBASE + 0x0467)
end_define

begin_define
define|#
directive|define
name|WARMBOOT_SEG
value|(KERNBASE + 0x0469)
end_define

begin_define
define|#
directive|define
name|CMOS_REG
value|(0x70)
end_define

begin_define
define|#
directive|define
name|CMOS_DATA
value|(0x71)
end_define

begin_define
define|#
directive|define
name|BIOS_RESET
value|(0x0f)
end_define

begin_define
define|#
directive|define
name|BIOS_WARM
value|(0x0a)
end_define

begin_decl_stmt
specifier|extern
name|struct
name|pcpu
name|__pcpu
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary variables for init_secondary()  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|doublefault_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|nmi_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|inthand_t
name|IDTVEC
argument_list|(
name|fast_syscall
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|fast_syscall32
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local data and functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|start_ap
parameter_list|(
name|int
name|apic_id
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_int
name|bootMP_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|boot_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Calculate usable address in base memory for AP trampoline code.  */
end_comment

begin_function
name|u_int
name|mp_bootaddress
parameter_list|(
name|u_int
name|basemem
parameter_list|)
block|{
name|bootMP_size
operator|=
name|mptramp_end
operator|-
name|mptramp_start
expr_stmt|;
name|boot_address
operator|=
name|trunc_page
argument_list|(
name|basemem
operator|*
literal|1024
argument_list|)
expr_stmt|;
comment|/* round down to 4k boundary */
if|if
condition|(
operator|(
operator|(
name|basemem
operator|*
literal|1024
operator|)
operator|-
name|boot_address
operator|)
operator|<
name|bootMP_size
condition|)
name|boot_address
operator|-=
name|PAGE_SIZE
expr_stmt|;
comment|/* not enough, lower by 4k */
comment|/* 3 levels of page table pages */
name|mptramp_pagetables
operator|=
name|boot_address
operator|-
operator|(
name|PAGE_SIZE
operator|*
literal|3
operator|)
expr_stmt|;
return|return
name|mptramp_pagetables
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the IPI handlers and start up the AP's.  */
end_comment

begin_function
name|void
name|cpu_mp_start
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Initialize the logical ID to APIC ID table. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|cpu_apic_ids
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|cpu_ipi_pending
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Install an inter-CPU IPI for TLB invalidation */
if|if
condition|(
name|pmap_pcid_enabled
condition|)
block|{
if|if
condition|(
name|invpcid_works
condition|)
block|{
name|setidt
argument_list|(
name|IPI_INVLTLB
argument_list|,
name|IDTVEC
argument_list|(
name|invltlb_invpcid
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setidt
argument_list|(
name|IPI_INVLTLB
argument_list|,
name|IDTVEC
argument_list|(
name|invltlb_pcid
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|setidt
argument_list|(
name|IPI_INVLTLB
argument_list|,
name|IDTVEC
argument_list|(
name|invltlb
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|setidt
argument_list|(
name|IPI_INVLPG
argument_list|,
name|IDTVEC
argument_list|(
name|invlpg
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setidt
argument_list|(
name|IPI_INVLRNG
argument_list|,
name|IDTVEC
argument_list|(
name|invlrng
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Install an inter-CPU IPI for cache invalidation. */
name|setidt
argument_list|(
name|IPI_INVLCACHE
argument_list|,
name|IDTVEC
argument_list|(
name|invlcache
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Install an inter-CPU IPI for all-CPU rendezvous */
name|setidt
argument_list|(
name|IPI_RENDEZVOUS
argument_list|,
name|IDTVEC
argument_list|(
name|rendezvous
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Install generic inter-CPU IPI handler */
name|setidt
argument_list|(
name|IPI_BITMAP_VECTOR
argument_list|,
name|IDTVEC
argument_list|(
name|ipi_intr_bitmap_handler
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Install an inter-CPU IPI for CPU stop/restart */
name|setidt
argument_list|(
name|IPI_STOP
argument_list|,
name|IDTVEC
argument_list|(
name|cpustop
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Install an inter-CPU IPI for CPU suspend/resume */
name|setidt
argument_list|(
name|IPI_SUSPEND
argument_list|,
name|IDTVEC
argument_list|(
name|cpususpend
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set boot_cpu_id if needed. */
if|if
condition|(
name|boot_cpu_id
operator|==
operator|-
literal|1
condition|)
block|{
name|boot_cpu_id
operator|=
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
expr_stmt|;
name|cpu_info
index|[
name|boot_cpu_id
index|]
operator|.
name|cpu_bsp
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|KASSERT
argument_list|(
name|boot_cpu_id
operator|==
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
argument_list|,
operator|(
literal|"BSP's APIC ID doesn't match boot_cpu_id"
operator|)
argument_list|)
expr_stmt|;
comment|/* Probe logical/physical core configuration. */
name|topo_probe
argument_list|()
expr_stmt|;
name|assign_cpu_ids
argument_list|()
expr_stmt|;
comment|/* Start each Application Processor */
name|init_ops
operator|.
name|start_all_aps
argument_list|()
expr_stmt|;
name|set_interrupt_apic_ids
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * AP CPU's call this to initialize themselves.  */
end_comment

begin_function
name|void
name|init_secondary
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pcpu
modifier|*
name|pc
decl_stmt|;
name|struct
name|nmi_pcpu
modifier|*
name|np
decl_stmt|;
name|u_int64_t
name|msr
decl_stmt|,
name|cr0
decl_stmt|;
name|int
name|cpu
decl_stmt|,
name|gsel_tss
decl_stmt|,
name|x
decl_stmt|;
name|struct
name|region_descriptor
name|ap_gdt
decl_stmt|;
comment|/* Set by the startup code for us to use */
name|cpu
operator|=
name|bootAP
expr_stmt|;
comment|/* Init tss */
name|common_tss
index|[
name|cpu
index|]
operator|=
name|common_tss
index|[
literal|0
index|]
expr_stmt|;
name|common_tss
index|[
name|cpu
index|]
operator|.
name|tss_rsp0
operator|=
literal|0
expr_stmt|;
comment|/* not used until after switch */
name|common_tss
index|[
name|cpu
index|]
operator|.
name|tss_iobase
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|amd64tss
argument_list|)
operator|+
name|IOPERM_BITMAP_SIZE
expr_stmt|;
name|common_tss
index|[
name|cpu
index|]
operator|.
name|tss_ist1
operator|=
operator|(
name|long
operator|)
operator|&
name|doublefault_stack
index|[
name|PAGE_SIZE
index|]
expr_stmt|;
comment|/* The NMI stack runs on IST2. */
name|np
operator|=
operator|(
operator|(
expr|struct
name|nmi_pcpu
operator|*
operator|)
operator|&
name|nmi_stack
index|[
name|PAGE_SIZE
index|]
operator|)
operator|-
literal|1
expr_stmt|;
name|common_tss
index|[
name|cpu
index|]
operator|.
name|tss_ist2
operator|=
operator|(
name|long
operator|)
name|np
expr_stmt|;
comment|/* Prepare private GDT */
name|gdt_segs
index|[
name|GPROC0_SEL
index|]
operator|.
name|ssd_base
operator|=
operator|(
name|long
operator|)
operator|&
name|common_tss
index|[
name|cpu
index|]
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NGDT
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|x
operator|!=
name|GPROC0_SEL
operator|&&
name|x
operator|!=
operator|(
name|GPROC0_SEL
operator|+
literal|1
operator|)
operator|&&
name|x
operator|!=
name|GUSERLDT_SEL
operator|&&
name|x
operator|!=
operator|(
name|GUSERLDT_SEL
operator|+
literal|1
operator|)
condition|)
name|ssdtosd
argument_list|(
operator|&
name|gdt_segs
index|[
name|x
index|]
argument_list|,
operator|&
name|gdt
index|[
name|NGDT
operator|*
name|cpu
operator|+
name|x
index|]
argument_list|)
expr_stmt|;
block|}
name|ssdtosyssd
argument_list|(
operator|&
name|gdt_segs
index|[
name|GPROC0_SEL
index|]
argument_list|,
operator|(
expr|struct
name|system_segment_descriptor
operator|*
operator|)
operator|&
name|gdt
index|[
name|NGDT
operator|*
name|cpu
operator|+
name|GPROC0_SEL
index|]
argument_list|)
expr_stmt|;
name|ap_gdt
operator|.
name|rd_limit
operator|=
name|NGDT
operator|*
sizeof|sizeof
argument_list|(
name|gdt
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ap_gdt
operator|.
name|rd_base
operator|=
operator|(
name|long
operator|)
operator|&
name|gdt
index|[
name|NGDT
operator|*
name|cpu
index|]
expr_stmt|;
name|lgdt
argument_list|(
operator|&
name|ap_gdt
argument_list|)
expr_stmt|;
comment|/* does magic intra-segment return */
comment|/* Get per-cpu data */
name|pc
operator|=
operator|&
name|__pcpu
index|[
name|cpu
index|]
expr_stmt|;
comment|/* prime data page for it to use */
name|pcpu_init
argument_list|(
name|pc
argument_list|,
name|cpu
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcpu
argument_list|)
argument_list|)
expr_stmt|;
name|dpcpu_init
argument_list|(
name|dpcpu
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_apic_id
operator|=
name|cpu_apic_ids
index|[
name|cpu
index|]
expr_stmt|;
name|pc
operator|->
name|pc_prvspace
operator|=
name|pc
expr_stmt|;
name|pc
operator|->
name|pc_curthread
operator|=
literal|0
expr_stmt|;
name|pc
operator|->
name|pc_tssp
operator|=
operator|&
name|common_tss
index|[
name|cpu
index|]
expr_stmt|;
name|pc
operator|->
name|pc_commontssp
operator|=
operator|&
name|common_tss
index|[
name|cpu
index|]
expr_stmt|;
name|pc
operator|->
name|pc_rsp0
operator|=
literal|0
expr_stmt|;
name|pc
operator|->
name|pc_tss
operator|=
operator|(
expr|struct
name|system_segment_descriptor
operator|*
operator|)
operator|&
name|gdt
index|[
name|NGDT
operator|*
name|cpu
operator|+
name|GPROC0_SEL
index|]
expr_stmt|;
name|pc
operator|->
name|pc_fs32p
operator|=
operator|&
name|gdt
index|[
name|NGDT
operator|*
name|cpu
operator|+
name|GUFS32_SEL
index|]
expr_stmt|;
name|pc
operator|->
name|pc_gs32p
operator|=
operator|&
name|gdt
index|[
name|NGDT
operator|*
name|cpu
operator|+
name|GUGS32_SEL
index|]
expr_stmt|;
name|pc
operator|->
name|pc_ldt
operator|=
operator|(
expr|struct
name|system_segment_descriptor
operator|*
operator|)
operator|&
name|gdt
index|[
name|NGDT
operator|*
name|cpu
operator|+
name|GUSERLDT_SEL
index|]
expr_stmt|;
name|pc
operator|->
name|pc_curpmap
operator|=
name|kernel_pmap
expr_stmt|;
name|pc
operator|->
name|pc_pcid_gen
operator|=
literal|1
expr_stmt|;
name|pc
operator|->
name|pc_pcid_next
operator|=
name|PMAP_PCID_KERN
operator|+
literal|1
expr_stmt|;
comment|/* Save the per-cpu pointer for use by the NMI handler. */
name|np
operator|->
name|np_pcpu
operator|=
operator|(
name|register_t
operator|)
name|pc
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_FSBASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* User value */
name|wrmsr
argument_list|(
name|MSR_GSBASE
argument_list|,
operator|(
name|u_int64_t
operator|)
name|pc
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_KGSBASE
argument_list|,
operator|(
name|u_int64_t
operator|)
name|pc
argument_list|)
expr_stmt|;
comment|/* XXX User value while we're in the kernel */
name|fix_cpuid
argument_list|()
expr_stmt|;
name|lidt
argument_list|(
operator|&
name|r_idt
argument_list|)
expr_stmt|;
name|gsel_tss
operator|=
name|GSEL
argument_list|(
name|GPROC0_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|ltr
argument_list|(
name|gsel_tss
argument_list|)
expr_stmt|;
comment|/* 	 * Set to a known state: 	 * Set by mpboot.s: CR0_PG, CR0_PE 	 * Set by cpu_setregs: CR0_NE, CR0_MP, CR0_TS, CR0_WP, CR0_AM 	 */
name|cr0
operator|=
name|rcr0
argument_list|()
expr_stmt|;
name|cr0
operator|&=
operator|~
operator|(
name|CR0_CD
operator||
name|CR0_NW
operator||
name|CR0_EM
operator|)
expr_stmt|;
name|load_cr0
argument_list|(
name|cr0
argument_list|)
expr_stmt|;
comment|/* Set up the fast syscall stuff */
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_EFER
argument_list|)
operator||
name|EFER_SCE
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_EFER
argument_list|,
name|msr
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_LSTAR
argument_list|,
operator|(
name|u_int64_t
operator|)
name|IDTVEC
argument_list|(
name|fast_syscall
argument_list|)
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_CSTAR
argument_list|,
operator|(
name|u_int64_t
operator|)
name|IDTVEC
argument_list|(
name|fast_syscall32
argument_list|)
argument_list|)
expr_stmt|;
name|msr
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|u_int64_t
operator|)
name|GSEL
argument_list|(
name|GUCODE32_SEL
argument_list|,
name|SEL_UPL
argument_list|)
operator|<<
literal|48
operator|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_STAR
argument_list|,
name|msr
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_SF_MASK
argument_list|,
name|PSL_NT
operator||
name|PSL_T
operator||
name|PSL_I
operator||
name|PSL_C
operator||
name|PSL_D
argument_list|)
expr_stmt|;
comment|/* signal our startup to the BSP. */
name|mp_naps
operator|++
expr_stmt|;
comment|/* Spin until the BSP releases the AP's. */
while|while
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|aps_ready
argument_list|)
operator|==
literal|0
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
name|init_secondary_tail
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************  * local functions and data  */
end_comment

begin_comment
comment|/*  * start each AP in our list  */
end_comment

begin_function
name|int
name|native_start_all_aps
parameter_list|(
name|void
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|boot_address
operator|+
name|KERNBASE
decl_stmt|;
name|u_int64_t
modifier|*
name|pt4
decl_stmt|,
modifier|*
name|pt3
decl_stmt|,
modifier|*
name|pt2
decl_stmt|;
name|u_int32_t
name|mpbioswarmvec
decl_stmt|;
name|int
name|apic_id
decl_stmt|,
name|cpu
decl_stmt|,
name|i
decl_stmt|;
name|u_char
name|mpbiosreason
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ap_boot_mtx
argument_list|,
literal|"ap boot"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* install the AP 1st level boot code */
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|boot_address
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mptramp_start
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va
argument_list|,
name|bootMP_size
argument_list|)
expr_stmt|;
comment|/* Locate the page tables, they'll be below the trampoline */
name|pt4
operator|=
operator|(
name|u_int64_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|mptramp_pagetables
operator|+
name|KERNBASE
argument_list|)
expr_stmt|;
name|pt3
operator|=
name|pt4
operator|+
operator|(
name|PAGE_SIZE
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
expr_stmt|;
name|pt2
operator|=
name|pt3
operator|+
operator|(
name|PAGE_SIZE
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
expr_stmt|;
comment|/* Create the initial 1GB replicated page tables */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|512
condition|;
name|i
operator|++
control|)
block|{
comment|/* Each slot of the level 4 pages points to the same level 3 page */
name|pt4
index|[
name|i
index|]
operator|=
call|(
name|u_int64_t
call|)
argument_list|(
name|uintptr_t
argument_list|)
argument_list|(
name|mptramp_pagetables
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pt4
index|[
name|i
index|]
operator||=
name|PG_V
operator||
name|PG_RW
operator||
name|PG_U
expr_stmt|;
comment|/* Each slot of the level 3 pages points to the same level 2 page */
name|pt3
index|[
name|i
index|]
operator|=
call|(
name|u_int64_t
call|)
argument_list|(
name|uintptr_t
argument_list|)
argument_list|(
name|mptramp_pagetables
operator|+
operator|(
literal|2
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
name|pt3
index|[
name|i
index|]
operator||=
name|PG_V
operator||
name|PG_RW
operator||
name|PG_U
expr_stmt|;
comment|/* The level 2 page slots are mapped with 2MB pages for 1GB. */
name|pt2
index|[
name|i
index|]
operator|=
name|i
operator|*
operator|(
literal|2
operator|*
literal|1024
operator|*
literal|1024
operator|)
expr_stmt|;
name|pt2
index|[
name|i
index|]
operator||=
name|PG_V
operator||
name|PG_RW
operator||
name|PG_PS
operator||
name|PG_U
expr_stmt|;
block|}
comment|/* save the current value of the warm-start vector */
name|mpbioswarmvec
operator|=
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|WARMBOOT_OFF
operator|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_REG
argument_list|,
name|BIOS_RESET
argument_list|)
expr_stmt|;
name|mpbiosreason
operator|=
name|inb
argument_list|(
name|CMOS_DATA
argument_list|)
expr_stmt|;
comment|/* setup a vector to our boot code */
operator|*
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|WARMBOOT_OFF
operator|)
operator|=
name|WARMBOOT_TARGET
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|WARMBOOT_SEG
operator|)
operator|=
operator|(
name|boot_address
operator|>>
literal|4
operator|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_REG
argument_list|,
name|BIOS_RESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_DATA
argument_list|,
name|BIOS_WARM
argument_list|)
expr_stmt|;
comment|/* 'warm-start' */
comment|/* start each AP */
for|for
control|(
name|cpu
operator|=
literal|1
init|;
name|cpu
operator|<
name|mp_ncpus
condition|;
name|cpu
operator|++
control|)
block|{
name|apic_id
operator|=
name|cpu_apic_ids
index|[
name|cpu
index|]
expr_stmt|;
comment|/* allocate and set up an idle stack data page */
name|bootstacks
index|[
name|cpu
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|kmem_malloc
argument_list|(
name|kernel_arena
argument_list|,
name|kstack_pages
operator|*
name|PAGE_SIZE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|doublefault_stack
operator|=
operator|(
name|char
operator|*
operator|)
name|kmem_malloc
argument_list|(
name|kernel_arena
argument_list|,
name|PAGE_SIZE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|nmi_stack
operator|=
operator|(
name|char
operator|*
operator|)
name|kmem_malloc
argument_list|(
name|kernel_arena
argument_list|,
name|PAGE_SIZE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|dpcpu
operator|=
operator|(
name|void
operator|*
operator|)
name|kmem_malloc
argument_list|(
name|kernel_arena
argument_list|,
name|DPCPU_SIZE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|bootSTK
operator|=
operator|(
name|char
operator|*
operator|)
name|bootstacks
index|[
name|cpu
index|]
operator|+
name|kstack_pages
operator|*
name|PAGE_SIZE
operator|-
literal|8
expr_stmt|;
name|bootAP
operator|=
name|cpu
expr_stmt|;
comment|/* attempt to start the Application Processor */
if|if
condition|(
operator|!
name|start_ap
argument_list|(
name|apic_id
argument_list|)
condition|)
block|{
comment|/* restore the warmstart vector */
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|WARMBOOT_OFF
operator|=
name|mpbioswarmvec
expr_stmt|;
name|panic
argument_list|(
literal|"AP #%d (PHY# %d) failed!"
argument_list|,
name|cpu
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
block|}
name|CPU_SET
argument_list|(
name|cpu
argument_list|,
operator|&
name|all_cpus
argument_list|)
expr_stmt|;
comment|/* record AP in CPU map */
block|}
comment|/* restore the warmstart vector */
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|WARMBOOT_OFF
operator|=
name|mpbioswarmvec
expr_stmt|;
name|outb
argument_list|(
name|CMOS_REG
argument_list|,
name|BIOS_RESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_DATA
argument_list|,
name|mpbiosreason
argument_list|)
expr_stmt|;
comment|/* number of APs actually started */
return|return
name|mp_naps
return|;
block|}
end_function

begin_comment
comment|/*  * This function starts the AP (application processor) identified  * by the APIC ID 'physicalCpu'.  It does quite a "song and dance"  * to accomplish this.  This is necessary because of the nuances  * of the different hardware we might encounter.  It isn't pretty,  * but it seems to work.  */
end_comment

begin_function
specifier|static
name|int
name|start_ap
parameter_list|(
name|int
name|apic_id
parameter_list|)
block|{
name|int
name|vector
decl_stmt|,
name|ms
decl_stmt|;
name|int
name|cpus
decl_stmt|;
comment|/* calculate the vector */
name|vector
operator|=
operator|(
name|boot_address
operator|>>
literal|12
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* used as a watchpoint to signal AP startup */
name|cpus
operator|=
name|mp_naps
expr_stmt|;
name|ipi_startup
argument_list|(
name|apic_id
argument_list|,
name|vector
argument_list|)
expr_stmt|;
comment|/* Wait up to 5 seconds for it to start. */
for|for
control|(
name|ms
operator|=
literal|0
init|;
name|ms
operator|<
literal|5000
condition|;
name|ms
operator|++
control|)
block|{
if|if
condition|(
name|mp_naps
operator|>
name|cpus
condition|)
return|return
literal|1
return|;
comment|/* return SUCCESS */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* return FAILURE */
block|}
end_function

begin_function
name|void
name|invltlb_invpcid_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|invpcid_descr
name|d
decl_stmt|;
ifdef|#
directive|ifdef
name|COUNT_XINVLTLB_HITS
name|xhits_gbl
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* COUNT_XINVLTLB_HITS */
ifdef|#
directive|ifdef
name|COUNT_IPIS
operator|(
operator|*
name|ipi_invltlb_counts
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|)
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* COUNT_IPIS */
name|d
operator|.
name|pcid
operator|=
name|smp_tlb_pmap
operator|->
name|pm_pcids
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|.
name|pm_pcid
expr_stmt|;
name|d
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
name|invpcid
argument_list|(
operator|&
name|d
argument_list|,
name|smp_tlb_pmap
operator|==
name|kernel_pmap
condition|?
name|INVPCID_CTXGLOB
else|:
name|INVPCID_CTX
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|smp_tlb_wait
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|invltlb_pcid_handler
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|COUNT_XINVLTLB_HITS
name|xhits_gbl
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* COUNT_XINVLTLB_HITS */
ifdef|#
directive|ifdef
name|COUNT_IPIS
operator|(
operator|*
name|ipi_invltlb_counts
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|)
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* COUNT_IPIS */
if|if
condition|(
name|smp_tlb_pmap
operator|==
name|kernel_pmap
condition|)
block|{
name|invltlb_glob
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The current pmap might not be equal to 		 * smp_tlb_pmap.  The clearing of the pm_gen in 		 * pmap_invalidate_all() takes care of TLB 		 * invalidation when switching to the pmap on this 		 * CPU. 		 */
if|if
condition|(
name|PCPU_GET
argument_list|(
name|curpmap
argument_list|)
operator|==
name|smp_tlb_pmap
condition|)
block|{
name|load_cr3
argument_list|(
name|smp_tlb_pmap
operator|->
name|pm_cr3
operator||
name|smp_tlb_pmap
operator|->
name|pm_pcids
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|.
name|pm_pcid
argument_list|)
expr_stmt|;
block|}
block|}
name|atomic_add_int
argument_list|(
operator|&
name|smp_tlb_wait
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

