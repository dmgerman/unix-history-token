begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1996, by Steve Passe  * Copyright (c) 2003, by Peter Wemm  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the developer may NOT be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_include
include|#
directive|include
file|"opt_kstack_pages.h"
end_include

begin_include
include|#
directive|include
file|"opt_mp_watchdog.h"
end_include

begin_include
include|#
directive|include
file|"opt_sched.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GPROF
end_ifdef

begin_include
include|#
directive|include
file|<sys/gmon.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/memrange.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/mp_watchdog.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/tss.h>
end_include

begin_define
define|#
directive|define
name|WARMBOOT_TARGET
value|0
end_define

begin_define
define|#
directive|define
name|WARMBOOT_OFF
value|(KERNBASE + 0x0467)
end_define

begin_define
define|#
directive|define
name|WARMBOOT_SEG
value|(KERNBASE + 0x0469)
end_define

begin_define
define|#
directive|define
name|CMOS_REG
value|(0x70)
end_define

begin_define
define|#
directive|define
name|CMOS_DATA
value|(0x71)
end_define

begin_define
define|#
directive|define
name|BIOS_RESET
value|(0x0f)
end_define

begin_define
define|#
directive|define
name|BIOS_WARM
value|(0x0a)
end_define

begin_comment
comment|/* lock region used by kernel profiling */
end_comment

begin_decl_stmt
name|int
name|mcount_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mp_naps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of Applications processors */
end_comment

begin_decl_stmt
name|int
name|boot_cpu_id
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* designated BSP */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nkpt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * CPU topology map datastructures for HTT.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cpu_group
name|mp_groups
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cpu_top
name|mp_top
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AP uses this during bootstrap.  Do not staticize.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bootSTK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bootAP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Free these after use */
end_comment

begin_decl_stmt
name|void
modifier|*
name|bootstacks
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary holder for double fault stack */
end_comment

begin_decl_stmt
name|char
modifier|*
name|doublefault_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hotwire a 0->4MB V==P mapping */
end_comment

begin_decl_stmt
specifier|extern
name|pt_entry_t
modifier|*
name|KPTphys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SMP page table page */
end_comment

begin_decl_stmt
specifier|extern
name|pt_entry_t
modifier|*
name|SMPpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pcb
name|stoppcbs
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables needed for SMP tlb shootdown. */
end_comment

begin_decl_stmt
name|vm_offset_t
name|smp_tlb_addr1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|smp_tlb_addr2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|int
name|smp_tlb_wait
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|inthand_t
name|IDTVEC
argument_list|(
name|fast_syscall
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|fast_syscall32
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|STOP_NMI
end_ifdef

begin_decl_stmt
specifier|volatile
name|cpumask_t
name|ipi_nmi_pending
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ipi_nmi_selected
parameter_list|(
name|u_int32_t
name|cpus
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local data and functions.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STOP_NMI
end_ifdef

begin_comment
comment|/*   * Provide an alternate method of stopping other CPUs. If another CPU has  * disabled interrupts the conventional STOP IPI will be blocked. This   * NMI-based stop should get through in that case.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stop_cpus_with_nmi
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|stop_cpus_with_nmi
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|stop_cpus_with_nmi
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.stop_cpus_with_nmi"
argument_list|,
operator|&
name|stop_cpus_with_nmi
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|stop_cpus_with_nmi
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_int
name|logical_cpus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to hold the AP's until we are ready to release them */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ap_boot_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 once we're ready to let the APs out of the pen. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|aps_ready
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Store data from cpu_add() until later in the boot when we actually setup  * the APs.  */
end_comment

begin_struct
struct|struct
name|cpu_info
block|{
name|int
name|cpu_present
range|:
literal|1
decl_stmt|;
name|int
name|cpu_bsp
range|:
literal|1
decl_stmt|;
name|int
name|cpu_disabled
range|:
literal|1
decl_stmt|;
block|}
decl|static
name|cpu_info
index|[
name|MAXCPU
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|cpu_apic_ids
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds pending bitmap based IPIs per CPU */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|u_int
name|cpu_ipi_pending
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|boot_address
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|set_interrupt_apic_ids
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|start_all_aps
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|start_ap
parameter_list|(
name|int
name|apic_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_aps
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|hlt_logical_cpus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|hyperthreading_cpus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpumask_t
name|hyperthreading_cpus_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hyperthreading_allowed
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sysctl_ctx_list
name|logical_cpu_clist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|bootMP_size
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mem_range_AP_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mem_range_softc
operator|.
name|mr_op
operator|&&
name|mem_range_softc
operator|.
name|mr_op
operator|->
name|initAP
condition|)
name|mem_range_softc
operator|.
name|mr_op
operator|->
name|initAP
argument_list|(
operator|&
name|mem_range_softc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mp_topology
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cpu_group
modifier|*
name|group
decl_stmt|;
name|u_int
name|regs
index|[
literal|4
index|]
decl_stmt|;
name|int
name|logical_cpus
decl_stmt|;
name|int
name|apic_id
decl_stmt|;
name|int
name|groups
decl_stmt|;
name|int
name|cpu
decl_stmt|;
comment|/* Build the smp_topology map. */
comment|/* Nothing to do if there is no HTT support. */
if|if
condition|(
operator|(
name|cpu_feature
operator|&
name|CPUID_HTT
operator|)
operator|==
literal|0
condition|)
return|return;
name|logical_cpus
operator|=
operator|(
name|cpu_procinfo
operator|&
name|CPUID_HTT_CORES
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|logical_cpus
operator|<=
literal|1
condition|)
return|return;
comment|/* Nothing to do if reported cores are physical cores. */
if|if
condition|(
name|strcmp
argument_list|(
name|cpu_vendor
argument_list|,
literal|"GenuineIntel"
argument_list|)
operator|==
literal|0
operator|&&
name|cpu_high
operator|>=
literal|4
condition|)
block|{
name|cpuid_count
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regs
index|[
literal|0
index|]
operator|&
literal|0x1f
operator|)
operator|!=
literal|0
operator|&&
name|logical_cpus
operator|<=
operator|(
operator|(
name|regs
index|[
literal|0
index|]
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|+
literal|1
condition|)
return|return;
block|}
name|group
operator|=
operator|&
name|mp_groups
index|[
literal|0
index|]
expr_stmt|;
name|groups
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|cpu
operator|=
literal|0
operator|,
name|apic_id
operator|=
literal|0
init|;
name|apic_id
operator|<
name|MAXCPU
condition|;
name|apic_id
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_present
condition|)
continue|continue;
comment|/* 		 * If the current group has members and we're not a logical 		 * cpu, create a new group. 		 */
if|if
condition|(
name|group
operator|->
name|cg_count
operator|!=
literal|0
operator|&&
operator|(
name|apic_id
operator|%
name|logical_cpus
operator|)
operator|==
literal|0
condition|)
block|{
name|group
operator|++
expr_stmt|;
name|groups
operator|++
expr_stmt|;
block|}
name|group
operator|->
name|cg_count
operator|++
expr_stmt|;
name|group
operator|->
name|cg_mask
operator||=
literal|1
operator|<<
name|cpu
expr_stmt|;
name|cpu
operator|++
expr_stmt|;
block|}
name|mp_top
operator|.
name|ct_count
operator|=
name|groups
expr_stmt|;
name|mp_top
operator|.
name|ct_group
operator|=
name|mp_groups
expr_stmt|;
name|smp_topology
operator|=
operator|&
name|mp_top
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Calculate usable address in base memory for AP trampoline code.  */
end_comment

begin_function
name|u_int
name|mp_bootaddress
parameter_list|(
name|u_int
name|basemem
parameter_list|)
block|{
name|bootMP_size
operator|=
name|mptramp_end
operator|-
name|mptramp_start
expr_stmt|;
name|boot_address
operator|=
name|trunc_page
argument_list|(
name|basemem
operator|*
literal|1024
argument_list|)
expr_stmt|;
comment|/* round down to 4k boundary */
if|if
condition|(
operator|(
operator|(
name|basemem
operator|*
literal|1024
operator|)
operator|-
name|boot_address
operator|)
operator|<
name|bootMP_size
condition|)
name|boot_address
operator|-=
name|PAGE_SIZE
expr_stmt|;
comment|/* not enough, lower by 4k */
comment|/* 3 levels of page table pages */
name|mptramp_pagetables
operator|=
name|boot_address
operator|-
operator|(
name|PAGE_SIZE
operator|*
literal|3
operator|)
expr_stmt|;
return|return
name|mptramp_pagetables
return|;
block|}
end_function

begin_function
name|void
name|cpu_add
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|char
name|boot_cpu
parameter_list|)
block|{
if|if
condition|(
name|apic_id
operator|>=
name|MAXCPU
condition|)
block|{
name|printf
argument_list|(
literal|"SMP: CPU %d exceeds maximum CPU %d, ignoring\n"
argument_list|,
name|apic_id
argument_list|,
name|MAXCPU
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_present
operator|==
literal|0
argument_list|,
operator|(
literal|"CPU %d added twice"
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|boot_cpu
condition|)
block|{
name|KASSERT
argument_list|(
name|boot_cpu_id
operator|==
operator|-
literal|1
argument_list|,
operator|(
literal|"CPU %d claims to be BSP, but CPU %d already is"
operator|,
name|apic_id
operator|,
name|boot_cpu_id
operator|)
argument_list|)
expr_stmt|;
name|boot_cpu_id
operator|=
name|apic_id
expr_stmt|;
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_bsp
operator|=
literal|1
expr_stmt|;
block|}
name|mp_ncpus
operator|++
expr_stmt|;
if|if
condition|(
name|apic_id
operator|>
name|mp_maxid
condition|)
name|mp_maxid
operator|=
name|apic_id
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"SMP: Added CPU %d (%s)\n"
argument_list|,
name|apic_id
argument_list|,
name|boot_cpu
condition|?
literal|"BSP"
else|:
literal|"AP"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cpu_mp_setmaxid
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * mp_maxid should be already set by calls to cpu_add(). 	 * Just sanity check its value here. 	 */
if|if
condition|(
name|mp_ncpus
operator|==
literal|0
condition|)
name|KASSERT
argument_list|(
name|mp_maxid
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: mp_ncpus is zero, but mp_maxid is not"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mp_ncpus
operator|==
literal|1
condition|)
name|mp_maxid
operator|=
literal|0
expr_stmt|;
else|else
name|KASSERT
argument_list|(
name|mp_maxid
operator|>=
name|mp_ncpus
operator|-
literal|1
argument_list|,
operator|(
literal|"%s: counters out of sync: max %d, count %d"
operator|,
name|__func__
operator|,
name|mp_maxid
operator|,
name|mp_ncpus
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cpu_mp_probe
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Always record BSP in CPU map so that the mbuf init code works 	 * correctly. 	 */
name|all_cpus
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mp_ncpus
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No CPUs were found, so this must be a UP system.  Setup 		 * the variables to represent a system with a single CPU 		 * with an id of 0. 		 */
name|mp_ncpus
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* At least one CPU was found. */
if|if
condition|(
name|mp_ncpus
operator|==
literal|1
condition|)
block|{
comment|/* 		 * One CPU was found, so this must be a UP system with 		 * an I/O APIC. 		 */
name|mp_maxid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* At least two CPUs were found. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the IPI handlers and start up the AP's.  */
end_comment

begin_function
name|void
name|cpu_mp_start
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|threads_per_cache
decl_stmt|,
name|p
index|[
literal|4
index|]
decl_stmt|;
comment|/* Initialize the logical ID to APIC ID table. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|cpu_apic_ids
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|cpu_ipi_pending
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Install an inter-CPU IPI for TLB invalidation */
name|setidt
argument_list|(
name|IPI_INVLTLB
argument_list|,
name|IDTVEC
argument_list|(
name|invltlb
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setidt
argument_list|(
name|IPI_INVLPG
argument_list|,
name|IDTVEC
argument_list|(
name|invlpg
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setidt
argument_list|(
name|IPI_INVLRNG
argument_list|,
name|IDTVEC
argument_list|(
name|invlrng
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Install an inter-CPU IPI for cache invalidation. */
name|setidt
argument_list|(
name|IPI_INVLCACHE
argument_list|,
name|IDTVEC
argument_list|(
name|invlcache
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Install an inter-CPU IPI for all-CPU rendezvous */
name|setidt
argument_list|(
name|IPI_RENDEZVOUS
argument_list|,
name|IDTVEC
argument_list|(
name|rendezvous
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Install generic inter-CPU IPI handler */
name|setidt
argument_list|(
name|IPI_BITMAP_VECTOR
argument_list|,
name|IDTVEC
argument_list|(
name|ipi_intr_bitmap_handler
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Install an inter-CPU IPI for CPU stop/restart */
name|setidt
argument_list|(
name|IPI_STOP
argument_list|,
name|IDTVEC
argument_list|(
name|cpustop
argument_list|)
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set boot_cpu_id if needed. */
if|if
condition|(
name|boot_cpu_id
operator|==
operator|-
literal|1
condition|)
block|{
name|boot_cpu_id
operator|=
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
expr_stmt|;
name|cpu_info
index|[
name|boot_cpu_id
index|]
operator|.
name|cpu_bsp
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|KASSERT
argument_list|(
name|boot_cpu_id
operator|==
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
argument_list|,
operator|(
literal|"BSP's APIC ID doesn't match boot_cpu_id"
operator|)
argument_list|)
expr_stmt|;
name|cpu_apic_ids
index|[
literal|0
index|]
operator|=
name|boot_cpu_id
expr_stmt|;
comment|/* Start each Application Processor */
name|start_all_aps
argument_list|()
expr_stmt|;
comment|/* Setup the initial logical CPUs info. */
name|logical_cpus
operator|=
name|logical_cpus_mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cpu_feature
operator|&
name|CPUID_HTT
condition|)
name|logical_cpus
operator|=
operator|(
name|cpu_procinfo
operator|&
name|CPUID_HTT_CORES
operator|)
operator|>>
literal|16
expr_stmt|;
comment|/* 	 * Work out if hyperthreading is *really* enabled.  This 	 * is made really ugly by the fact that processors lie: Dual 	 * core processors claim to be hyperthreaded even when they're 	 * not, presumably because they want to be treated the same 	 * way as HTT with respect to per-cpu software licensing. 	 * At the time of writing (May 12, 2005) the only hyperthreaded 	 * cpus are from Intel, and Intel's dual-core processors can be 	 * identified via the "deterministic cache parameters" cpuid 	 * calls. 	 */
comment|/* 	 * First determine if this is an Intel processor which claims 	 * to have hyperthreading support. 	 */
if|if
condition|(
operator|(
name|cpu_feature
operator|&
name|CPUID_HTT
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cpu_vendor
argument_list|,
literal|"GenuineIntel"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * If the "deterministic cache parameters" cpuid calls 		 * are available, use them. 		 */
if|if
condition|(
name|cpu_high
operator|>=
literal|4
condition|)
block|{
comment|/* Ask the processor about the L1 cache. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|cpuid_count
argument_list|(
literal|4
argument_list|,
name|i
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|threads_per_cache
operator|=
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|&
literal|0x3ffc000
operator|)
operator|>>
literal|14
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|hyperthreading_cpus
operator|<
name|threads_per_cache
condition|)
name|hyperthreading_cpus
operator|=
name|threads_per_cache
expr_stmt|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|&
literal|0x1f
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
comment|/* 		 * If the deterministic cache parameters are not 		 * available, or if no caches were reported to exist, 		 * just accept what the HTT flag indicated. 		 */
if|if
condition|(
name|hyperthreading_cpus
operator|==
literal|0
condition|)
name|hyperthreading_cpus
operator|=
name|logical_cpus
expr_stmt|;
block|}
name|set_interrupt_apic_ids
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print various information about the SMP system hardware and setup.  */
end_comment

begin_function
name|void
name|cpu_mp_announce
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
comment|/* List CPUs */
name|printf
argument_list|(
literal|" cpu0 (BSP): APIC ID: %2d\n"
argument_list|,
name|boot_cpu_id
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|MAXCPU
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cpu_info
index|[
name|x
index|]
operator|.
name|cpu_present
operator|||
name|cpu_info
index|[
name|x
index|]
operator|.
name|cpu_bsp
condition|)
continue|continue;
if|if
condition|(
name|cpu_info
index|[
name|x
index|]
operator|.
name|cpu_disabled
condition|)
name|printf
argument_list|(
literal|"  cpu (AP): APIC ID: %2d (disabled)\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
block|{
name|KASSERT
argument_list|(
name|i
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"mp_ncpus and actual cpus are out of whack"
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" cpu%d (AP): APIC ID: %2d\n"
argument_list|,
name|i
operator|++
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * AP CPU's call this to initialize themselves.  */
end_comment

begin_function
name|void
name|init_secondary
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pcpu
modifier|*
name|pc
decl_stmt|;
name|u_int64_t
name|msr
decl_stmt|,
name|cr0
decl_stmt|;
name|int
name|cpu
decl_stmt|,
name|gsel_tss
decl_stmt|;
comment|/* Set by the startup code for us to use */
name|cpu
operator|=
name|bootAP
expr_stmt|;
comment|/* Init tss */
name|common_tss
index|[
name|cpu
index|]
operator|=
name|common_tss
index|[
literal|0
index|]
expr_stmt|;
name|common_tss
index|[
name|cpu
index|]
operator|.
name|tss_rsp0
operator|=
literal|0
expr_stmt|;
comment|/* not used until after switch */
name|common_tss
index|[
name|cpu
index|]
operator|.
name|tss_iobase
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|amd64tss
argument_list|)
expr_stmt|;
name|common_tss
index|[
name|cpu
index|]
operator|.
name|tss_ist1
operator|=
operator|(
name|long
operator|)
operator|&
name|doublefault_stack
index|[
name|PAGE_SIZE
index|]
expr_stmt|;
name|gdt_segs
index|[
name|GPROC0_SEL
index|]
operator|.
name|ssd_base
operator|=
operator|(
name|long
operator|)
operator|&
name|common_tss
index|[
name|cpu
index|]
expr_stmt|;
name|ssdtosyssd
argument_list|(
operator|&
name|gdt_segs
index|[
name|GPROC0_SEL
index|]
argument_list|,
operator|(
expr|struct
name|system_segment_descriptor
operator|*
operator|)
operator|&
name|gdt
index|[
name|GPROC0_SEL
index|]
argument_list|)
expr_stmt|;
name|lgdt
argument_list|(
operator|&
name|r_gdt
argument_list|)
expr_stmt|;
comment|/* does magic intra-segment return */
comment|/* Get per-cpu data */
name|pc
operator|=
operator|&
name|__pcpu
index|[
name|cpu
index|]
expr_stmt|;
comment|/* prime data page for it to use */
name|pcpu_init
argument_list|(
name|pc
argument_list|,
name|cpu
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcpu
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_apic_id
operator|=
name|cpu_apic_ids
index|[
name|cpu
index|]
expr_stmt|;
name|pc
operator|->
name|pc_prvspace
operator|=
name|pc
expr_stmt|;
name|pc
operator|->
name|pc_curthread
operator|=
literal|0
expr_stmt|;
name|pc
operator|->
name|pc_tssp
operator|=
operator|&
name|common_tss
index|[
name|cpu
index|]
expr_stmt|;
name|pc
operator|->
name|pc_rsp0
operator|=
literal|0
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_FSBASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* User value */
name|wrmsr
argument_list|(
name|MSR_GSBASE
argument_list|,
operator|(
name|u_int64_t
operator|)
name|pc
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_KGSBASE
argument_list|,
operator|(
name|u_int64_t
operator|)
name|pc
argument_list|)
expr_stmt|;
comment|/* XXX User value while we're in the kernel */
name|lidt
argument_list|(
operator|&
name|r_idt
argument_list|)
expr_stmt|;
name|gsel_tss
operator|=
name|GSEL
argument_list|(
name|GPROC0_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|ltr
argument_list|(
name|gsel_tss
argument_list|)
expr_stmt|;
comment|/* 	 * Set to a known state: 	 * Set by mpboot.s: CR0_PG, CR0_PE 	 * Set by cpu_setregs: CR0_NE, CR0_MP, CR0_TS, CR0_WP, CR0_AM 	 */
name|cr0
operator|=
name|rcr0
argument_list|()
expr_stmt|;
name|cr0
operator|&=
operator|~
operator|(
name|CR0_CD
operator||
name|CR0_NW
operator||
name|CR0_EM
operator|)
expr_stmt|;
name|load_cr0
argument_list|(
name|cr0
argument_list|)
expr_stmt|;
comment|/* Set up the fast syscall stuff */
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_EFER
argument_list|)
operator||
name|EFER_SCE
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_EFER
argument_list|,
name|msr
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_LSTAR
argument_list|,
operator|(
name|u_int64_t
operator|)
name|IDTVEC
argument_list|(
name|fast_syscall
argument_list|)
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_CSTAR
argument_list|,
operator|(
name|u_int64_t
operator|)
name|IDTVEC
argument_list|(
name|fast_syscall32
argument_list|)
argument_list|)
expr_stmt|;
name|msr
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|u_int64_t
operator|)
name|GSEL
argument_list|(
name|GUCODE32_SEL
argument_list|,
name|SEL_UPL
argument_list|)
operator|<<
literal|48
operator|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_STAR
argument_list|,
name|msr
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_SF_MASK
argument_list|,
name|PSL_NT
operator||
name|PSL_T
operator||
name|PSL_I
operator||
name|PSL_C
operator||
name|PSL_D
argument_list|)
expr_stmt|;
comment|/* Disable local APIC just to be sure. */
name|lapic_disable
argument_list|()
expr_stmt|;
comment|/* signal our startup to the BSP. */
name|mp_naps
operator|++
expr_stmt|;
comment|/* Spin until the BSP releases the AP's. */
while|while
condition|(
operator|!
name|aps_ready
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
comment|/* Initialize the PAT MSR. */
name|pmap_init_pat
argument_list|()
expr_stmt|;
comment|/* set up CPU registers and state */
name|cpu_setregs
argument_list|()
expr_stmt|;
comment|/* set up SSE/NX registers */
name|initializecpu
argument_list|()
expr_stmt|;
comment|/* set up FPU state on the AP */
name|fpuinit
argument_list|()
expr_stmt|;
comment|/* A quick check from sanity claus */
if|if
condition|(
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
operator|!=
name|lapic_id
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"SMP: cpuid = %d\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: actual apic_id = %d\n"
argument_list|,
name|lapic_id
argument_list|()
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: correct apic_id = %d\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"cpuid mismatch! boom!!"
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize curthread. */
name|KASSERT
argument_list|(
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no idle thread"
operator|)
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|curthread
argument_list|,
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|ap_boot_mtx
argument_list|)
expr_stmt|;
comment|/* Init local apic for irq's */
name|lapic_setup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Set memory range attributes for this CPU to match the BSP */
name|mem_range_AP_init
argument_list|()
expr_stmt|;
name|smp_cpus
operator|++
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_SMP
argument_list|,
literal|"SMP: AP CPU #%d Launched"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: AP CPU #%d Launched!\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine if we are a logical CPU. */
if|if
condition|(
name|logical_cpus
operator|>
literal|1
operator|&&
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
operator|%
name|logical_cpus
operator|!=
literal|0
condition|)
name|logical_cpus_mask
operator||=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
comment|/* Determine if we are a hyperthread. */
if|if
condition|(
name|hyperthreading_cpus
operator|>
literal|1
operator|&&
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
operator|%
name|hyperthreading_cpus
operator|!=
literal|0
condition|)
name|hyperthreading_cpus_mask
operator||=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
comment|/* Build our map of 'other' CPUs. */
name|PCPU_SET
argument_list|(
name|other_cpus
argument_list|,
name|all_cpus
operator|&
operator|~
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|lapic_dump
argument_list|(
literal|"AP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp_cpus
operator|==
name|mp_ncpus
condition|)
block|{
comment|/* enable IPI's, tlb shootdown, freezes etc */
name|atomic_store_rel_int
argument_list|(
operator|&
name|smp_started
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|smp_active
operator|=
literal|1
expr_stmt|;
comment|/* historic */
block|}
comment|/* 	 * Enable global pages TLB extension 	 * This also implicitly flushes the TLB  	 */
name|load_cr4
argument_list|(
name|rcr4
argument_list|()
operator||
name|CR4_PGE
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|ap_boot_mtx
argument_list|)
expr_stmt|;
comment|/* wait until all the AP's are up */
while|while
condition|(
name|smp_started
operator|==
literal|0
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
comment|/* ok, now grab sched_lock and enter the scheduler */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Correct spinlock nesting.  The idle thread context that we are 	 * borrowing was created so that it would start out with a single 	 * spin lock (sched_lock) held in fork_trampoline().  Since we've 	 * explicitly acquired locks in this function, the nesting count 	 * is now 2 rather than 1.  Since we are nested, calling 	 * spinlock_exit() will simply adjust the counts without allowing 	 * spin lock using code to interrupt us. 	 */
name|spinlock_exit
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|curthread
operator|->
name|td_md
operator|.
name|md_spinlock_count
operator|==
literal|1
argument_list|,
operator|(
literal|"invalid count"
operator|)
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|switchtime
argument_list|,
name|cpu_ticks
argument_list|()
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|switchticks
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
name|cpu_throw
argument_list|(
name|NULL
argument_list|,
name|choosethread
argument_list|()
argument_list|)
expr_stmt|;
comment|/* doesn't return */
name|panic
argument_list|(
literal|"scheduler returned us to %s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*******************************************************************  * local functions and data  */
end_comment

begin_comment
comment|/*  * We tell the I/O APIC code about all the CPUs we want to receive  * interrupts.  If we don't want certain CPUs to receive IRQs we  * can simply not tell the I/O APIC code about them in this function.  * We also do not tell it about the BSP since it tells itself about  * the BSP internally to work with UP kernels and on UP machines.  */
end_comment

begin_function
specifier|static
name|void
name|set_interrupt_apic_ids
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|apic_id
decl_stmt|;
for|for
control|(
name|apic_id
operator|=
literal|0
init|;
name|apic_id
operator|<
name|MAXCPU
condition|;
name|apic_id
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_present
condition|)
continue|continue;
if|if
condition|(
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_bsp
condition|)
continue|continue;
comment|/* Don't let hyperthreads service interrupts. */
if|if
condition|(
name|hyperthreading_cpus
operator|>
literal|1
operator|&&
name|apic_id
operator|%
name|hyperthreading_cpus
operator|!=
literal|0
condition|)
continue|continue;
name|intr_add_cpu
argument_list|(
name|apic_id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * start each AP in our list  */
end_comment

begin_function
specifier|static
name|int
name|start_all_aps
parameter_list|(
name|void
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|boot_address
operator|+
name|KERNBASE
decl_stmt|;
name|u_int64_t
modifier|*
name|pt4
decl_stmt|,
modifier|*
name|pt3
decl_stmt|,
modifier|*
name|pt2
decl_stmt|;
name|u_int32_t
name|mpbioswarmvec
decl_stmt|;
name|int
name|apic_id
decl_stmt|,
name|cpu
decl_stmt|,
name|i
decl_stmt|;
name|u_char
name|mpbiosreason
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ap_boot_mtx
argument_list|,
literal|"ap boot"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* install the AP 1st level boot code */
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|boot_address
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mptramp_start
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va
argument_list|,
name|bootMP_size
argument_list|)
expr_stmt|;
comment|/* Locate the page tables, they'll be below the trampoline */
name|pt4
operator|=
operator|(
name|u_int64_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|mptramp_pagetables
operator|+
name|KERNBASE
argument_list|)
expr_stmt|;
name|pt3
operator|=
name|pt4
operator|+
operator|(
name|PAGE_SIZE
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
expr_stmt|;
name|pt2
operator|=
name|pt3
operator|+
operator|(
name|PAGE_SIZE
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
expr_stmt|;
comment|/* Create the initial 1GB replicated page tables */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|512
condition|;
name|i
operator|++
control|)
block|{
comment|/* Each slot of the level 4 pages points to the same level 3 page */
name|pt4
index|[
name|i
index|]
operator|=
call|(
name|u_int64_t
call|)
argument_list|(
name|uintptr_t
argument_list|)
argument_list|(
name|mptramp_pagetables
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pt4
index|[
name|i
index|]
operator||=
name|PG_V
operator||
name|PG_RW
operator||
name|PG_U
expr_stmt|;
comment|/* Each slot of the level 3 pages points to the same level 2 page */
name|pt3
index|[
name|i
index|]
operator|=
call|(
name|u_int64_t
call|)
argument_list|(
name|uintptr_t
argument_list|)
argument_list|(
name|mptramp_pagetables
operator|+
operator|(
literal|2
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
name|pt3
index|[
name|i
index|]
operator||=
name|PG_V
operator||
name|PG_RW
operator||
name|PG_U
expr_stmt|;
comment|/* The level 2 page slots are mapped with 2MB pages for 1GB. */
name|pt2
index|[
name|i
index|]
operator|=
name|i
operator|*
operator|(
literal|2
operator|*
literal|1024
operator|*
literal|1024
operator|)
expr_stmt|;
name|pt2
index|[
name|i
index|]
operator||=
name|PG_V
operator||
name|PG_RW
operator||
name|PG_PS
operator||
name|PG_U
expr_stmt|;
block|}
comment|/* save the current value of the warm-start vector */
name|mpbioswarmvec
operator|=
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|WARMBOOT_OFF
operator|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_REG
argument_list|,
name|BIOS_RESET
argument_list|)
expr_stmt|;
name|mpbiosreason
operator|=
name|inb
argument_list|(
name|CMOS_DATA
argument_list|)
expr_stmt|;
comment|/* setup a vector to our boot code */
operator|*
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|WARMBOOT_OFF
operator|)
operator|=
name|WARMBOOT_TARGET
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|WARMBOOT_SEG
operator|)
operator|=
operator|(
name|boot_address
operator|>>
literal|4
operator|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_REG
argument_list|,
name|BIOS_RESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_DATA
argument_list|,
name|BIOS_WARM
argument_list|)
expr_stmt|;
comment|/* 'warm-start' */
comment|/* start each AP */
for|for
control|(
name|cpu
operator|=
literal|0
operator|,
name|apic_id
operator|=
literal|0
init|;
name|apic_id
operator|<
name|MAXCPU
condition|;
name|apic_id
operator|++
control|)
block|{
comment|/* Ignore non-existent CPUs and the BSP. */
if|if
condition|(
operator|!
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_present
operator|||
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_bsp
condition|)
continue|continue;
comment|/* Don't use this CPU if it has been disabled by a tunable. */
if|if
condition|(
name|resource_disabled
argument_list|(
literal|"lapic"
argument_list|,
name|apic_id
argument_list|)
condition|)
block|{
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_disabled
operator|=
literal|1
expr_stmt|;
name|mp_ncpus
operator|--
expr_stmt|;
continue|continue;
block|}
name|cpu
operator|++
expr_stmt|;
comment|/* save APIC ID for this logical ID */
name|cpu_apic_ids
index|[
name|cpu
index|]
operator|=
name|apic_id
expr_stmt|;
comment|/* allocate and set up an idle stack data page */
name|bootstacks
index|[
name|cpu
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|KSTACK_PAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|doublefault_stack
operator|=
operator|(
name|char
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|bootSTK
operator|=
operator|(
name|char
operator|*
operator|)
name|bootstacks
index|[
name|cpu
index|]
operator|+
name|KSTACK_PAGES
operator|*
name|PAGE_SIZE
operator|-
literal|8
expr_stmt|;
name|bootAP
operator|=
name|cpu
expr_stmt|;
comment|/* attempt to start the Application Processor */
if|if
condition|(
operator|!
name|start_ap
argument_list|(
name|apic_id
argument_list|)
condition|)
block|{
comment|/* restore the warmstart vector */
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|WARMBOOT_OFF
operator|=
name|mpbioswarmvec
expr_stmt|;
name|panic
argument_list|(
literal|"AP #%d (PHY# %d) failed!"
argument_list|,
name|cpu
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
block|}
name|all_cpus
operator||=
operator|(
literal|1
operator|<<
name|cpu
operator|)
expr_stmt|;
comment|/* record AP in CPU map */
block|}
comment|/* build our map of 'other' CPUs */
name|PCPU_SET
argument_list|(
name|other_cpus
argument_list|,
name|all_cpus
operator|&
operator|~
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restore the warmstart vector */
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|WARMBOOT_OFF
operator|=
name|mpbioswarmvec
expr_stmt|;
name|outb
argument_list|(
name|CMOS_REG
argument_list|,
name|BIOS_RESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_DATA
argument_list|,
name|mpbiosreason
argument_list|)
expr_stmt|;
comment|/* number of APs actually started */
return|return
name|mp_naps
return|;
block|}
end_function

begin_comment
comment|/*  * This function starts the AP (application processor) identified  * by the APIC ID 'physicalCpu'.  It does quite a "song and dance"  * to accomplish this.  This is necessary because of the nuances  * of the different hardware we might encounter.  It isn't pretty,  * but it seems to work.  */
end_comment

begin_function
specifier|static
name|int
name|start_ap
parameter_list|(
name|int
name|apic_id
parameter_list|)
block|{
name|int
name|vector
decl_stmt|,
name|ms
decl_stmt|;
name|int
name|cpus
decl_stmt|;
comment|/* calculate the vector */
name|vector
operator|=
operator|(
name|boot_address
operator|>>
literal|12
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* used as a watchpoint to signal AP startup */
name|cpus
operator|=
name|mp_naps
expr_stmt|;
comment|/* 	 * first we do an INIT/RESET IPI this INIT IPI might be run, reseting 	 * and running the target CPU. OR this INIT IPI might be latched (P5 	 * bug), CPU waiting for STARTUP IPI. OR this INIT IPI might be 	 * ignored. 	 */
comment|/* do an INIT IPI: assert RESET */
name|lapic_ipi_raw
argument_list|(
name|APIC_DEST_DESTFLD
operator||
name|APIC_TRIGMOD_EDGE
operator||
name|APIC_LEVEL_ASSERT
operator||
name|APIC_DESTMODE_PHY
operator||
name|APIC_DELMODE_INIT
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
comment|/* wait for pending status end */
name|lapic_ipi_wait
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* do an INIT IPI: deassert RESET */
name|lapic_ipi_raw
argument_list|(
name|APIC_DEST_ALLESELF
operator||
name|APIC_TRIGMOD_LEVEL
operator||
name|APIC_LEVEL_DEASSERT
operator||
name|APIC_DESTMODE_PHY
operator||
name|APIC_DELMODE_INIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* wait for pending status end */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* wait ~10mS */
name|lapic_ipi_wait
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * next we do a STARTUP IPI: the previous INIT IPI might still be 	 * latched, (P5 bug) this 1st STARTUP would then terminate 	 * immediately, and the previously started INIT IPI would continue. OR 	 * the previous INIT IPI has already run. and this STARTUP IPI will 	 * run. OR the previous INIT IPI was ignored. and this STARTUP IPI 	 * will run. 	 */
comment|/* do a STARTUP IPI */
name|lapic_ipi_raw
argument_list|(
name|APIC_DEST_DESTFLD
operator||
name|APIC_TRIGMOD_EDGE
operator||
name|APIC_LEVEL_DEASSERT
operator||
name|APIC_DESTMODE_PHY
operator||
name|APIC_DELMODE_STARTUP
operator||
name|vector
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
name|lapic_ipi_wait
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* wait ~200uS */
comment|/* 	 * finally we do a 2nd STARTUP IPI: this 2nd STARTUP IPI should run IF 	 * the previous STARTUP IPI was cancelled by a latched INIT IPI. OR 	 * this STARTUP IPI will be ignored, as only ONE STARTUP IPI is 	 * recognized after hardware RESET or INIT IPI. 	 */
name|lapic_ipi_raw
argument_list|(
name|APIC_DEST_DESTFLD
operator||
name|APIC_TRIGMOD_EDGE
operator||
name|APIC_LEVEL_DEASSERT
operator||
name|APIC_DESTMODE_PHY
operator||
name|APIC_DELMODE_STARTUP
operator||
name|vector
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
name|lapic_ipi_wait
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* wait ~200uS */
comment|/* Wait up to 5 seconds for it to start. */
for|for
control|(
name|ms
operator|=
literal|0
init|;
name|ms
operator|<
literal|5000
condition|;
name|ms
operator|++
control|)
block|{
if|if
condition|(
name|mp_naps
operator|>
name|cpus
condition|)
return|return
literal|1
return|;
comment|/* return SUCCESS */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* return FAILURE */
block|}
end_function

begin_comment
comment|/*  * Flush the TLB on all other CPU's  */
end_comment

begin_function
specifier|static
name|void
name|smp_tlb_shootdown
parameter_list|(
name|u_int
name|vector
parameter_list|,
name|vm_offset_t
name|addr1
parameter_list|,
name|vm_offset_t
name|addr2
parameter_list|)
block|{
name|u_int
name|ncpu
decl_stmt|;
name|ncpu
operator|=
name|mp_ncpus
operator|-
literal|1
expr_stmt|;
comment|/* does not shootdown self */
if|if
condition|(
name|ncpu
operator|<
literal|1
condition|)
return|return;
comment|/* no other cpus */
name|mtx_assert
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|smp_tlb_addr1
operator|=
name|addr1
expr_stmt|;
name|smp_tlb_addr2
operator|=
name|addr2
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|smp_tlb_wait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ipi_all_but_self
argument_list|(
name|vector
argument_list|)
expr_stmt|;
while|while
condition|(
name|smp_tlb_wait
operator|<
name|ncpu
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smp_targeted_tlb_shootdown
parameter_list|(
name|u_int
name|mask
parameter_list|,
name|u_int
name|vector
parameter_list|,
name|vm_offset_t
name|addr1
parameter_list|,
name|vm_offset_t
name|addr2
parameter_list|)
block|{
name|int
name|ncpu
decl_stmt|,
name|othercpus
decl_stmt|;
name|othercpus
operator|=
name|mp_ncpus
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|mask
operator|==
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
block|{
name|ncpu
operator|=
name|othercpus
expr_stmt|;
if|if
condition|(
name|ncpu
operator|<
literal|1
condition|)
return|return;
block|}
else|else
block|{
name|mask
operator|&=
operator|~
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return;
name|ncpu
operator|=
name|bitcount32
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncpu
operator|>
name|othercpus
condition|)
block|{
comment|/* XXX this should be a panic offence */
name|printf
argument_list|(
literal|"SMP: tlb shootdown to %d other cpus (only have %d)\n"
argument_list|,
name|ncpu
argument_list|,
name|othercpus
argument_list|)
expr_stmt|;
name|ncpu
operator|=
name|othercpus
expr_stmt|;
block|}
comment|/* XXX should be a panic, implied by mask == 0 above */
if|if
condition|(
name|ncpu
operator|<
literal|1
condition|)
return|return;
block|}
name|mtx_assert
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|smp_tlb_addr1
operator|=
name|addr1
expr_stmt|;
name|smp_tlb_addr2
operator|=
name|addr2
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|smp_tlb_wait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ipi_all_but_self
argument_list|(
name|vector
argument_list|)
expr_stmt|;
else|else
name|ipi_selected
argument_list|(
name|mask
argument_list|,
name|vector
argument_list|)
expr_stmt|;
while|while
condition|(
name|smp_tlb_wait
operator|<
name|ncpu
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smp_cache_flush
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
name|smp_tlb_shootdown
argument_list|(
name|IPI_INVLCACHE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smp_invltlb
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
block|{
name|smp_tlb_shootdown
argument_list|(
name|IPI_INVLTLB
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|smp_invlpg
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
name|smp_tlb_shootdown
argument_list|(
name|IPI_INVLPG
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smp_invlpg_range
parameter_list|(
name|vm_offset_t
name|addr1
parameter_list|,
name|vm_offset_t
name|addr2
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
block|{
name|smp_tlb_shootdown
argument_list|(
name|IPI_INVLRNG
argument_list|,
name|addr1
argument_list|,
name|addr2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|smp_masked_invltlb
parameter_list|(
name|u_int
name|mask
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
block|{
name|smp_targeted_tlb_shootdown
argument_list|(
name|mask
argument_list|,
name|IPI_INVLTLB
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|smp_masked_invlpg
parameter_list|(
name|u_int
name|mask
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
block|{
name|smp_targeted_tlb_shootdown
argument_list|(
name|mask
argument_list|,
name|IPI_INVLPG
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|smp_masked_invlpg_range
parameter_list|(
name|u_int
name|mask
parameter_list|,
name|vm_offset_t
name|addr1
parameter_list|,
name|vm_offset_t
name|addr2
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
block|{
name|smp_targeted_tlb_shootdown
argument_list|(
name|mask
argument_list|,
name|IPI_INVLRNG
argument_list|,
name|addr1
argument_list|,
name|addr2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ipi_bitmap_handler
parameter_list|(
name|struct
name|trapframe
name|frame
parameter_list|)
block|{
name|int
name|cpu
init|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
decl_stmt|;
name|u_int
name|ipi_bitmap
decl_stmt|;
name|ipi_bitmap
operator|=
name|atomic_readandclear_int
argument_list|(
operator|&
name|cpu_ipi_pending
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipi_bitmap
operator|&
operator|(
literal|1
operator|<<
name|IPI_PREEMPT
operator|)
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
comment|/* Don't preempt the idle thread */
if|if
condition|(
name|curthread
operator|!=
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
condition|)
block|{
name|struct
name|thread
modifier|*
name|running_thread
init|=
name|curthread
decl_stmt|;
if|if
condition|(
name|running_thread
operator|->
name|td_critnest
operator|>
literal|1
condition|)
name|running_thread
operator|->
name|td_owepreempt
operator|=
literal|1
expr_stmt|;
else|else
name|mi_switch
argument_list|(
name|SW_INVOL
operator||
name|SW_PREEMPT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
comment|/* Nothing to do for AST */
block|}
end_function

begin_comment
comment|/*  * send an IPI to a set of cpus.  */
end_comment

begin_function
name|void
name|ipi_selected
parameter_list|(
name|u_int32_t
name|cpus
parameter_list|,
name|u_int
name|ipi
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
name|u_int
name|bitmap
init|=
literal|0
decl_stmt|;
name|u_int
name|old_pending
decl_stmt|;
name|u_int
name|new_pending
decl_stmt|;
if|if
condition|(
name|IPI_IS_BITMAPED
argument_list|(
name|ipi
argument_list|)
condition|)
block|{
name|bitmap
operator|=
literal|1
operator|<<
name|ipi
expr_stmt|;
name|ipi
operator|=
name|IPI_BITMAP_VECTOR
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STOP_NMI
if|if
condition|(
name|ipi
operator|==
name|IPI_STOP
operator|&&
name|stop_cpus_with_nmi
condition|)
block|{
name|ipi_nmi_selected
argument_list|(
name|cpus
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|CTR3
argument_list|(
name|KTR_SMP
argument_list|,
literal|"%s: cpus: %x ipi: %x"
argument_list|,
name|__func__
argument_list|,
name|cpus
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cpu
operator|=
name|ffs
argument_list|(
name|cpus
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cpu
operator|--
expr_stmt|;
name|cpus
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|cpu
operator|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cpu_apic_ids
index|[
name|cpu
index|]
operator|!=
operator|-
literal|1
argument_list|,
operator|(
literal|"IPI to non-existent CPU %d"
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap
condition|)
block|{
do|do
block|{
name|old_pending
operator|=
name|cpu_ipi_pending
index|[
name|cpu
index|]
expr_stmt|;
name|new_pending
operator|=
name|old_pending
operator||
name|bitmap
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|cpu_ipi_pending
index|[
name|cpu
index|]
argument_list|,
name|old_pending
argument_list|,
name|new_pending
argument_list|)
condition|)
do|;
if|if
condition|(
name|old_pending
condition|)
continue|continue;
block|}
name|lapic_ipi_vectored
argument_list|(
name|ipi
argument_list|,
name|cpu_apic_ids
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * send an IPI INTerrupt containing 'vector' to all CPUs, including myself  */
end_comment

begin_function
name|void
name|ipi_all
parameter_list|(
name|u_int
name|ipi
parameter_list|)
block|{
if|if
condition|(
name|IPI_IS_BITMAPED
argument_list|(
name|ipi
argument_list|)
operator|||
operator|(
name|ipi
operator|==
name|IPI_STOP
operator|&&
name|stop_cpus_with_nmi
operator|)
condition|)
block|{
name|ipi_selected
argument_list|(
name|all_cpus
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
return|return;
block|}
name|CTR2
argument_list|(
name|KTR_SMP
argument_list|,
literal|"%s: ipi: %x"
argument_list|,
name|__func__
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
name|lapic_ipi_vectored
argument_list|(
name|ipi
argument_list|,
name|APIC_IPI_DEST_ALL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * send an IPI to all CPUs EXCEPT myself  */
end_comment

begin_function
name|void
name|ipi_all_but_self
parameter_list|(
name|u_int
name|ipi
parameter_list|)
block|{
if|if
condition|(
name|IPI_IS_BITMAPED
argument_list|(
name|ipi
argument_list|)
operator|||
operator|(
name|ipi
operator|==
name|IPI_STOP
operator|&&
name|stop_cpus_with_nmi
operator|)
condition|)
block|{
name|ipi_selected
argument_list|(
name|PCPU_GET
argument_list|(
name|other_cpus
argument_list|)
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
return|return;
block|}
name|CTR2
argument_list|(
name|KTR_SMP
argument_list|,
literal|"%s: ipi: %x"
argument_list|,
name|__func__
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
name|lapic_ipi_vectored
argument_list|(
name|ipi
argument_list|,
name|APIC_IPI_DEST_OTHERS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * send an IPI to myself  */
end_comment

begin_function
name|void
name|ipi_self
parameter_list|(
name|u_int
name|ipi
parameter_list|)
block|{
if|if
condition|(
name|IPI_IS_BITMAPED
argument_list|(
name|ipi
argument_list|)
operator|||
operator|(
name|ipi
operator|==
name|IPI_STOP
operator|&&
name|stop_cpus_with_nmi
operator|)
condition|)
block|{
name|ipi_selected
argument_list|(
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
return|return;
block|}
name|CTR2
argument_list|(
name|KTR_SMP
argument_list|,
literal|"%s: ipi: %x"
argument_list|,
name|__func__
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
name|lapic_ipi_vectored
argument_list|(
name|ipi
argument_list|,
name|APIC_IPI_DEST_SELF
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|STOP_NMI
end_ifdef

begin_comment
comment|/*  * send NMI IPI to selected CPUs  */
end_comment

begin_define
define|#
directive|define
name|BEFORE_SPIN
value|1000000
end_define

begin_function
name|void
name|ipi_nmi_selected
parameter_list|(
name|u_int32_t
name|cpus
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
name|register_t
name|icrlo
decl_stmt|;
name|icrlo
operator|=
name|APIC_DELMODE_NMI
operator||
name|APIC_DESTMODE_PHY
operator||
name|APIC_LEVEL_ASSERT
operator||
name|APIC_TRIGMOD_EDGE
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_SMP
argument_list|,
literal|"%s: cpus: %x nmi"
argument_list|,
name|__func__
argument_list|,
name|cpus
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|ipi_nmi_pending
argument_list|,
name|cpus
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cpu
operator|=
name|ffs
argument_list|(
name|cpus
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cpu
operator|--
expr_stmt|;
name|cpus
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|cpu
operator|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cpu_apic_ids
index|[
name|cpu
index|]
operator|!=
operator|-
literal|1
argument_list|,
operator|(
literal|"IPI NMI to non-existent CPU %d"
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
comment|/* Wait for an earlier IPI to finish. */
if|if
condition|(
operator|!
name|lapic_ipi_wait
argument_list|(
name|BEFORE_SPIN
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ipi_nmi_selected: previous IPI has not cleared"
argument_list|)
expr_stmt|;
name|lapic_ipi_raw
argument_list|(
name|icrlo
argument_list|,
name|cpu_apic_ids
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ipi_nmi_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|cpumask
init|=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ipi_nmi_pending
operator|&
name|cpumask
operator|)
condition|)
return|return
literal|1
return|;
name|atomic_clear_int
argument_list|(
operator|&
name|ipi_nmi_pending
argument_list|,
name|cpumask
argument_list|)
expr_stmt|;
name|cpustop_handler
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STOP_NMI */
end_comment

begin_comment
comment|/*  * Handle an IPI_STOP by saving our current context and spinning until we  * are resumed.  */
end_comment

begin_function
name|void
name|cpustop_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|cpu
init|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
decl_stmt|;
name|int
name|cpumask
init|=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
decl_stmt|;
name|savectx
argument_list|(
operator|&
name|stoppcbs
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
comment|/* Indicate that we are stopped */
name|atomic_set_int
argument_list|(
operator|&
name|stopped_cpus
argument_list|,
name|cpumask
argument_list|)
expr_stmt|;
comment|/* Wait for restart */
while|while
condition|(
operator|!
operator|(
name|started_cpus
operator|&
name|cpumask
operator|)
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|started_cpus
argument_list|,
name|cpumask
argument_list|)
expr_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|stopped_cpus
argument_list|,
name|cpumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu
operator|==
literal|0
operator|&&
name|cpustop_restartfunc
operator|!=
name|NULL
condition|)
block|{
name|cpustop_restartfunc
argument_list|()
expr_stmt|;
name|cpustop_restartfunc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called once the rest of the system is up and running and we're  * ready to let the AP's out of the pen.  */
end_comment

begin_function
specifier|static
name|void
name|release_aps
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|mp_ncpus
operator|==
literal|1
condition|)
return|return;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|aps_ready
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|smp_started
operator|==
literal|0
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|start_aps
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|release_aps
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_hlt_cpus
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|mask
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mask
operator|=
name|hlt_cpus_mask
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|mask
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|logical_cpus_mask
operator|!=
literal|0
operator|&&
operator|(
name|mask
operator|&
name|logical_cpus_mask
operator|)
operator|==
name|logical_cpus_mask
condition|)
name|hlt_logical_cpus
operator|=
literal|1
expr_stmt|;
else|else
name|hlt_logical_cpus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hyperthreading_allowed
condition|)
name|mask
operator||=
name|hyperthreading_cpus_mask
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|all_cpus
operator|)
operator|==
name|all_cpus
condition|)
name|mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
name|hlt_cpus_mask
operator|=
name|mask
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|hlt_cpus
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_hlt_cpus
argument_list|,
literal|"IU"
argument_list|,
literal|"Bitmap of CPUs to halt.  101 (binary) will halt CPUs 0 and 2."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_hlt_logical_cpus
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|disable
decl_stmt|,
name|error
decl_stmt|;
name|disable
operator|=
name|hlt_logical_cpus
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|disable
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|disable
condition|)
name|hlt_cpus_mask
operator||=
name|logical_cpus_mask
expr_stmt|;
else|else
name|hlt_cpus_mask
operator|&=
operator|~
name|logical_cpus_mask
expr_stmt|;
if|if
condition|(
operator|!
name|hyperthreading_allowed
condition|)
name|hlt_cpus_mask
operator||=
name|hyperthreading_cpus_mask
expr_stmt|;
if|if
condition|(
operator|(
name|hlt_cpus_mask
operator|&
name|all_cpus
operator|)
operator|==
name|all_cpus
condition|)
name|hlt_cpus_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
name|hlt_logical_cpus
operator|=
name|disable
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hyperthreading_allowed
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|allowed
decl_stmt|,
name|error
decl_stmt|;
name|allowed
operator|=
name|hyperthreading_allowed
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|allowed
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|allowed
condition|)
name|hlt_cpus_mask
operator|&=
operator|~
name|hyperthreading_cpus_mask
expr_stmt|;
else|else
name|hlt_cpus_mask
operator||=
name|hyperthreading_cpus_mask
expr_stmt|;
if|if
condition|(
name|logical_cpus_mask
operator|!=
literal|0
operator|&&
operator|(
name|hlt_cpus_mask
operator|&
name|logical_cpus_mask
operator|)
operator|==
name|logical_cpus_mask
condition|)
name|hlt_logical_cpus
operator|=
literal|1
expr_stmt|;
else|else
name|hlt_logical_cpus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|hlt_cpus_mask
operator|&
name|all_cpus
operator|)
operator|==
name|all_cpus
condition|)
name|hlt_cpus_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
name|hyperthreading_allowed
operator|=
name|allowed
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cpu_hlt_setup
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|logical_cpus_mask
operator|!=
literal|0
condition|)
block|{
name|TUNABLE_INT_FETCH
argument_list|(
literal|"machdep.hlt_logical_cpus"
argument_list|,
operator|&
name|hlt_logical_cpus
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|logical_cpu_clist
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|logical_cpu_clist
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_machdep
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hlt_logical_cpus"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_hlt_logical_cpus
argument_list|,
literal|"IU"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|logical_cpu_clist
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_machdep
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"logical_cpus_mask"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|logical_cpus_mask
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|hlt_logical_cpus
condition|)
name|hlt_cpus_mask
operator||=
name|logical_cpus_mask
expr_stmt|;
comment|/* 		 * If necessary for security purposes, force 		 * hyperthreading off, regardless of the value 		 * of hlt_logical_cpus. 		 */
if|if
condition|(
name|hyperthreading_cpus_mask
condition|)
block|{
name|TUNABLE_INT_FETCH
argument_list|(
literal|"machdep.hyperthreading_allowed"
argument_list|,
operator|&
name|hyperthreading_allowed
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|logical_cpu_clist
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_machdep
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hyperthreading_allowed"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_hyperthreading_allowed
argument_list|,
literal|"IU"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hyperthreading_allowed
condition|)
name|hlt_cpus_mask
operator||=
name|hyperthreading_cpus_mask
expr_stmt|;
block|}
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|cpu_hlt
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|cpu_hlt_setup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mp_grab_cpu_hlt
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|mask
init|=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|MP_WATCHDOG
name|u_int
name|cpuid
init|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|int
name|retval
decl_stmt|;
ifdef|#
directive|ifdef
name|MP_WATCHDOG
name|ap_watchdog
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|retval
operator|=
name|mask
operator|&
name|hlt_cpus_mask
expr_stmt|;
while|while
condition|(
name|mask
operator|&
name|hlt_cpus_mask
condition|)
asm|__asm __volatile("sti; hlt" : : : "memory");
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

end_unit

