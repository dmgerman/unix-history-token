begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  		THIS SOFTWARE IS NOT COPYRIGHTED     HP offers the following for use in the public domain.  HP makes no    warranty with regard to the software or its performance and the    user accepts the software "AS IS" with all faults.     HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD    TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $  *  *  Module name: remcom.c $  *  Revision: 1.34 $  *  Date: 91/03/09 12:29:49 $  *  Contributor:     Lake Stevens Instrument Division$  *  *  Description:     low level support for gdb debugger. $  *  *  Considerations:  only works on target hardware $  *  *  Written by:      Glenn Engel $  *  ModuleState:     Experimental $  *  *  NOTES:           See Below $  *  *  Modified for FreeBSD by Stu Grossman.  *  *  To enable debugger support, two things need to happen.  One, a  *  call to set_debug_traps() is necessary in order to allow any breakpoints  *  or error conditions to be properly intercepted and reported to gdb.  *  Two, a breakpoint needs to be generated to begin communication.  This  *  is most easily accomplished by a call to breakpoint().  Breakpoint()  *  simulates a breakpoint by executing a trap #1.  *  *  The external function exceptionHandler() is  *  used to attach a specific handler to a specific 386 vector number.  *  It should use the same privilege level it runs at.  It should  *  install it as an interrupt gate so that interrupts are masked  *  while the handler runs.  *  Also, need to assign exceptionHook and oldExceptionHook.  *  *  Because gdb will sometimes write to the stack area to execute function  *  calls, this program cannot rely on using the supervisor stack so it  *  uses its own stack area reserved in the int array remcomStack.  *  *************  *  *    The following gdb commands are supported:  *  * command          function                               Return value  *  *    g             return the value of the CPU registers  hex data or ENN  *    G             set the value of the CPU registers     OK or ENN  *  *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN  *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN  *  *    c             Resume at current address              SNN   ( signal NN)  *    cAA..AA       Continue at address AA..AA             SNN  *  *    s             Step one instruction                   SNN  *    sAA..AA       Step one instruction from AA..AA       SNN  *  *    k             kill  *  *    ?             What was the last sigval ?             SNN   (signal NN)  *  *    D             detach                                 OK  *  * All commands and responses are sent with a packet which includes a  * checksum.  A packet consists of  *  * $<packet info>#<checksum>.  *  * where  *<packet info> ::<characters representing the command or response>  *<checksum>    ::< two hex digits computed as modulo 256 sum of<packetinfo>>  *  * When a packet is received, it is first acknowledged with either '+' or '-'.  * '+' indicates a successful transfer.  '-' indicates a failed transfer.  *  * Example:  *  * Host:                  Reply:  * $m0,10#2a               +$00010203040506070809101112131415#42  *  ****************************************************************************/
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"sio.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_function_decl
name|int
name|gdb_handle_exception
parameter_list|(
name|db_regs_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|NSIO
operator|==
literal|0
end_if

begin_function
name|int
name|gdb_handle_exception
parameter_list|(
name|db_regs_t
modifier|*
name|raw_regs
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|code
parameter_list|)
block|{ }
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/************************************************************************/
end_comment

begin_decl_stmt
specifier|extern
name|jmp_buf
name|db_jmpbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* BUFMAX defines the maximum number of characters in inbound/outbound buffers*/
end_comment

begin_comment
comment|/* at least NUMREGBYTES*2 are needed for register packets */
end_comment

begin_define
define|#
directive|define
name|BUFMAX
value|400
end_define

begin_comment
comment|/* Create private copies of common functions used by the stub.  This prevents    nasty interactions between app code and the stub (for instance if user steps    into strlen, etc..) */
end_comment

begin_define
define|#
directive|define
name|strlen
value|gdb_strlen
end_define

begin_define
define|#
directive|define
name|strcpy
value|gdb_strcpy
end_define

begin_function
specifier|static
name|int
name|strlen
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s1
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|s1
operator|++
operator|!=
literal|'\000'
condition|)
empty_stmt|;
return|return
name|s1
operator|-
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|strcpy
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
modifier|*
name|retval
init|=
name|dst
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|'\000'
condition|)
empty_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|putDebugChar
parameter_list|(
name|int
name|c
parameter_list|)
comment|/* write a single character      */
block|{
if|if
condition|(
name|gdbdev
operator|==
name|NODEV
condition|)
return|return
literal|0
return|;
call|(
modifier|*
name|gdb_putc
call|)
argument_list|(
name|gdbdev
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getDebugChar
parameter_list|(
name|void
parameter_list|)
comment|/* read and return a single char */
block|{
if|if
condition|(
name|gdbdev
operator|==
name|NODEV
condition|)
return|return
operator|-
literal|1
return|;
return|return
call|(
modifier|*
name|gdb_getc
call|)
argument_list|(
name|gdbdev
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|hexchars
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|hex
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'f'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'F'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* scan for the sequence $<data>#<checksum>     */
end_comment

begin_function
specifier|static
name|void
name|getpacket
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|unsigned
name|char
name|xmitcsum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|read_eflags
argument_list|()
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
do|do
block|{
comment|/* wait around for the start character, ignore all other characters */
while|while
condition|(
operator|(
name|ch
operator|=
operator|(
name|getDebugChar
argument_list|()
operator|&
literal|0x7f
operator|)
operator|)
operator|!=
literal|'$'
condition|)
empty_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|xmitcsum
operator|=
operator|-
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* now, read until a # or end of buffer is found */
while|while
condition|(
name|count
operator|<
name|BUFMAX
condition|)
block|{
name|ch
operator|=
name|getDebugChar
argument_list|()
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
break|break;
name|checksum
operator|=
name|checksum
operator|+
name|ch
expr_stmt|;
name|buffer
index|[
name|count
index|]
operator|=
name|ch
expr_stmt|;
name|count
operator|=
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|buffer
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
block|{
name|xmitcsum
operator|=
name|hex
argument_list|(
name|getDebugChar
argument_list|()
operator|&
literal|0x7f
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|xmitcsum
operator|+=
name|hex
argument_list|(
name|getDebugChar
argument_list|()
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|xmitcsum
condition|)
name|putDebugChar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
comment|/* failed checksum */
else|else
block|{
name|putDebugChar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
comment|/* successful transfer */
comment|/* if a sequence char is present, reply the sequence ID */
if|if
condition|(
name|buffer
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* remove sequence chars from buffer */
name|count
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
control|)
name|buffer
index|[
name|i
operator|-
literal|3
index|]
operator|=
name|buffer
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|checksum
operator|!=
name|xmitcsum
condition|)
do|;
name|write_eflags
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* send the packet in buffer.  */
end_comment

begin_function
specifier|static
name|void
name|putpacket
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/*  $<packet info>#<checksum>. */
name|s
operator|=
name|read_eflags
argument_list|()
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
do|do
block|{
comment|/*  * This is a non-standard hack to allow use of the serial console for  * operation as well as debugging.  Simply turn on 'remotechat' in gdb.  *  * This extension is not part of the Cygnus protocol, is kinda gross,  * but gets the job done.  */
ifdef|#
directive|ifdef
name|GDB_REMOTE_CHAT
name|putDebugChar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putDebugChar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|buffer
index|[
name|count
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|putDebugChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
name|count
operator|+=
literal|1
expr_stmt|;
block|}
name|putDebugChar
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|getDebugChar
argument_list|()
operator|&
literal|0x7f
operator|)
operator|!=
literal|'+'
condition|)
do|;
name|write_eflags
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|remcomInBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|remcomOutBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|get_char
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|char
name|data
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|db_jmpbuf
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|db_read_bytes
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
name|data
operator|&
literal|0xff
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_char
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|char
name|data
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|db_jmpbuf
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|data
operator|=
name|val
expr_stmt|;
name|db_write_bytes
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* convert the memory pointed to by mem into hex, placing result in buf */
end_comment

begin_comment
comment|/* return a pointer to the last char put in buf (null) */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mem2hex
parameter_list|(
name|vm_offset_t
name|mem
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ch
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|get_char
argument_list|(
name|mem
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|%
literal|16
index|]
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convert the hex array pointed to by buf into binary to be placed in mem */
end_comment

begin_comment
comment|/* return a pointer to the character AFTER the last byte written */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|hex2mem
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|vm_offset_t
name|mem
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|rv
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|ch
operator|=
name|ch
operator|+
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
name|rv
operator|=
name|set_char
argument_list|(
name|mem
operator|++
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* this function takes the 386 exception vector and attempts to    translate this number into a unix compatible signal value */
end_comment

begin_function
specifier|static
name|int
name|computeSignal
parameter_list|(
name|int
name|exceptionVector
parameter_list|)
block|{
name|int
name|sigval
decl_stmt|;
switch|switch
condition|(
name|exceptionVector
operator|&
operator|~
name|T_USER
condition|)
block|{
case|case
literal|0
case|:
name|sigval
operator|=
literal|8
expr_stmt|;
break|break;
comment|/* divide by zero */
case|case
literal|1
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* debug exception */
case|case
literal|3
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* breakpoint */
case|case
literal|4
case|:
name|sigval
operator|=
literal|16
expr_stmt|;
break|break;
comment|/* into instruction (overflow) */
case|case
literal|5
case|:
name|sigval
operator|=
literal|16
expr_stmt|;
break|break;
comment|/* bound instruction */
case|case
literal|6
case|:
name|sigval
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* Invalid opcode */
case|case
literal|7
case|:
name|sigval
operator|=
literal|8
expr_stmt|;
break|break;
comment|/* coprocessor not available */
case|case
literal|8
case|:
name|sigval
operator|=
literal|7
expr_stmt|;
break|break;
comment|/* double fault */
case|case
literal|9
case|:
name|sigval
operator|=
literal|11
expr_stmt|;
break|break;
comment|/* coprocessor segment overrun */
case|case
literal|10
case|:
name|sigval
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* Invalid TSS (also single-step) */
case|case
literal|11
case|:
name|sigval
operator|=
literal|11
expr_stmt|;
break|break;
comment|/* Segment not present */
case|case
literal|12
case|:
name|sigval
operator|=
literal|11
expr_stmt|;
break|break;
comment|/* stack exception */
case|case
literal|13
case|:
name|sigval
operator|=
literal|11
expr_stmt|;
break|break;
comment|/* general protection */
case|case
literal|14
case|:
name|sigval
operator|=
literal|11
expr_stmt|;
break|break;
comment|/* page fault */
case|case
literal|16
case|:
name|sigval
operator|=
literal|7
expr_stmt|;
break|break;
comment|/* coprocessor error */
default|default:
name|sigval
operator|=
literal|7
expr_stmt|;
comment|/* "software generated"*/
block|}
return|return
operator|(
name|sigval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * While we find nice hex chars, build an int.  * Return number of chars processed.  */
end_comment

begin_function
specifier|static
name|int
name|hexToInt
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|intValue
parameter_list|)
block|{
name|int
name|numChars
init|=
literal|0
decl_stmt|;
name|int
name|hexValue
decl_stmt|;
operator|*
name|intValue
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|ptr
condition|)
block|{
name|hexValue
operator|=
name|hex
argument_list|(
operator|*
operator|*
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hexValue
operator|>=
literal|0
condition|)
block|{
operator|*
name|intValue
operator|=
operator|(
operator|*
name|intValue
operator|<<
literal|4
operator|)
operator||
name|hexValue
expr_stmt|;
name|numChars
operator|++
expr_stmt|;
block|}
else|else
break|break;
operator|(
operator|*
name|ptr
operator|)
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|numChars
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NUMREGBYTES
value|(sizeof registers)
end_define

begin_define
define|#
directive|define
name|PC
value|8
end_define

begin_define
define|#
directive|define
name|SP
value|4
end_define

begin_define
define|#
directive|define
name|FP
value|5
end_define

begin_define
define|#
directive|define
name|NUM_REGS
value|14
end_define

begin_comment
comment|/*  * This function does all command procesing for interfacing to gdb.  */
end_comment

begin_function
name|int
name|gdb_handle_exception
parameter_list|(
name|db_regs_t
modifier|*
name|raw_regs
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|int
name|sigval
decl_stmt|;
name|int
name|addr
decl_stmt|,
name|length
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
struct|struct
name|i386regs
block|{
name|unsigned
name|int
name|eax
decl_stmt|;
name|unsigned
name|int
name|ecx
decl_stmt|;
name|unsigned
name|int
name|edx
decl_stmt|;
name|unsigned
name|int
name|ebx
decl_stmt|;
name|unsigned
name|int
name|esp
decl_stmt|;
name|unsigned
name|int
name|ebp
decl_stmt|;
name|unsigned
name|int
name|esi
decl_stmt|;
name|unsigned
name|int
name|edi
decl_stmt|;
name|unsigned
name|int
name|eip
decl_stmt|;
name|unsigned
name|int
name|eflags
decl_stmt|;
name|unsigned
name|int
name|cs
decl_stmt|;
name|unsigned
name|int
name|ss
decl_stmt|;
name|unsigned
name|int
name|ds
decl_stmt|;
name|unsigned
name|int
name|es
decl_stmt|;
block|}
struct|;
name|struct
name|i386regs
name|registers
decl_stmt|;
name|registers
operator|.
name|eax
operator|=
name|raw_regs
operator|->
name|tf_eax
expr_stmt|;
name|registers
operator|.
name|ebx
operator|=
name|raw_regs
operator|->
name|tf_ebx
expr_stmt|;
name|registers
operator|.
name|ecx
operator|=
name|raw_regs
operator|->
name|tf_ecx
expr_stmt|;
name|registers
operator|.
name|edx
operator|=
name|raw_regs
operator|->
name|tf_edx
expr_stmt|;
name|registers
operator|.
name|esp
operator|=
name|raw_regs
operator|->
name|tf_esp
expr_stmt|;
name|registers
operator|.
name|ebp
operator|=
name|raw_regs
operator|->
name|tf_ebp
expr_stmt|;
name|registers
operator|.
name|esi
operator|=
name|raw_regs
operator|->
name|tf_esi
expr_stmt|;
name|registers
operator|.
name|edi
operator|=
name|raw_regs
operator|->
name|tf_edi
expr_stmt|;
name|registers
operator|.
name|eip
operator|=
name|raw_regs
operator|->
name|tf_eip
expr_stmt|;
name|registers
operator|.
name|eflags
operator|=
name|raw_regs
operator|->
name|tf_eflags
expr_stmt|;
name|registers
operator|.
name|cs
operator|=
name|raw_regs
operator|->
name|tf_cs
expr_stmt|;
name|registers
operator|.
name|ss
operator|=
name|raw_regs
operator|->
name|tf_ss
expr_stmt|;
name|registers
operator|.
name|ds
operator|=
name|raw_regs
operator|->
name|tf_ds
expr_stmt|;
name|registers
operator|.
name|es
operator|=
name|raw_regs
operator|->
name|tf_es
expr_stmt|;
comment|/* reply to host that an exception has occurred */
name|sigval
operator|=
name|computeSignal
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|remcomOutBuffer
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'T'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|sigval
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|sigval
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|PC
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|PC
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|registers
operator|.
name|eip
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|FP
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|FP
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|registers
operator|.
name|ebp
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|SP
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|SP
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|registers
operator|.
name|esp
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|gdbdev
operator|==
name|NODEV
condition|)
comment|/* somebody's removed it */
return|return
literal|1
return|;
comment|/* get out of here */
name|remcomOutBuffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|getpacket
argument_list|(
name|remcomInBuffer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|remcomInBuffer
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'?'
case|:
name|remcomOutBuffer
index|[
literal|0
index|]
operator|=
literal|'S'
expr_stmt|;
name|remcomOutBuffer
index|[
literal|1
index|]
operator|=
name|hexchars
index|[
name|sigval
operator|>>
literal|4
index|]
expr_stmt|;
name|remcomOutBuffer
index|[
literal|2
index|]
operator|=
name|hexchars
index|[
name|sigval
operator|%
literal|16
index|]
expr_stmt|;
name|remcomOutBuffer
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* detach; say OK and turn off gdb */
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
expr_stmt|;
name|boothowto
operator|&=
operator|~
name|RB_GDB
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'g'
case|:
comment|/* return the value of the CPU registers */
name|mem2hex
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|registers
argument_list|,
name|remcomOutBuffer
argument_list|,
name|NUMREGBYTES
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* set the value of the CPU registers - return OK */
name|hex2mem
argument_list|(
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
argument_list|,
operator|(
name|vm_offset_t
operator|)
operator|&
name|registers
argument_list|,
name|NUMREGBYTES
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Set the value of one register */
block|{
name|int
name|regno
decl_stmt|;
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|regno
argument_list|)
operator|&&
operator|*
name|ptr
operator|++
operator|==
literal|'='
operator|&&
name|regno
operator|<
name|NUM_REGS
condition|)
block|{
name|hex2mem
argument_list|(
name|ptr
argument_list|,
operator|(
name|vm_offset_t
operator|)
operator|&
name|registers
operator|+
name|regno
operator|*
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"P01"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'m'
case|:
comment|/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
comment|/* Try to read %x,%x.  */
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|==
literal|','
operator|&&
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|)
condition|)
block|{
if|if
condition|(
name|mem2hex
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|,
name|remcomOutBuffer
argument_list|,
name|length
argument_list|)
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E03"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E01"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
comment|/* Try to read '%x,%x:'.  */
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|==
literal|','
operator|&&
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|)
operator|&&
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|hex2mem
argument_list|(
name|ptr
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|,
name|length
argument_list|)
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E03"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E02"
argument_list|)
expr_stmt|;
break|break;
comment|/* cAA..AA    Continue at address AA..AA(optional) */
comment|/* sAA..AA   Step one instruction from AA..AA(optional) */
case|case
literal|'c'
case|:
case|case
literal|'s'
case|:
comment|/* try to read optional parameter, pc unchanged if no parm */
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
name|registers
operator|.
name|eip
operator|=
name|addr
expr_stmt|;
comment|/* set the trace bit if we're stepping */
if|if
condition|(
name|remcomInBuffer
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
name|registers
operator|.
name|eflags
operator||=
name|PSL_T
expr_stmt|;
else|else
name|registers
operator|.
name|eflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|raw_regs
operator|->
name|tf_eax
operator|=
name|registers
operator|.
name|eax
expr_stmt|;
name|raw_regs
operator|->
name|tf_ebx
operator|=
name|registers
operator|.
name|ebx
expr_stmt|;
name|raw_regs
operator|->
name|tf_ecx
operator|=
name|registers
operator|.
name|ecx
expr_stmt|;
name|raw_regs
operator|->
name|tf_edx
operator|=
name|registers
operator|.
name|edx
expr_stmt|;
name|raw_regs
operator|->
name|tf_esp
operator|=
name|registers
operator|.
name|esp
expr_stmt|;
name|raw_regs
operator|->
name|tf_ebp
operator|=
name|registers
operator|.
name|ebp
expr_stmt|;
name|raw_regs
operator|->
name|tf_esi
operator|=
name|registers
operator|.
name|esi
expr_stmt|;
name|raw_regs
operator|->
name|tf_edi
operator|=
name|registers
operator|.
name|edi
expr_stmt|;
name|raw_regs
operator|->
name|tf_eip
operator|=
name|registers
operator|.
name|eip
expr_stmt|;
name|raw_regs
operator|->
name|tf_eflags
operator|=
name|registers
operator|.
name|eflags
expr_stmt|;
name|raw_regs
operator|->
name|tf_cs
operator|=
name|registers
operator|.
name|cs
expr_stmt|;
name|raw_regs
operator|->
name|tf_ss
operator|=
name|registers
operator|.
name|ss
expr_stmt|;
name|raw_regs
operator|->
name|tf_ds
operator|=
name|registers
operator|.
name|ds
expr_stmt|;
name|raw_regs
operator|->
name|tf_es
operator|=
name|registers
operator|.
name|es
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* switch */
comment|/* reply to the request */
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSIO> 0 */
end_comment

end_unit

