begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  * Copyright (c) 1994 John S. Dyson  * All rights reserved.  * Copyright (c) 1994 David Greenman  * All rights reserved.  * Copyright (c) 2003 Peter Wemm  * All rights reserved.  * Copyright (c) 2005 Alan L. Cox<alc@cs.rice.edu>  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and William Jolitz of UUNET Technologies Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from:	@(#)pmap.c	7.7 (Berkeley)	5/12/91  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2003 Networks Associates Technology, Inc.  * All rights reserved.  *  * This software was developed for the FreeBSD Project by Jake Burkholder,  * Safeport Network Services, and Network Associates Laboratories, the  * Security Research Division of Network Associates, Inc. under  * DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA  * CHATS research program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *	Manages physical address maps.  *  *	In addition to hardware address maps, this  *	module is called upon to provide software-use-only  *	maps which may or may not be stored in the same  *	form as hardware maps.  These pseudo-maps are  *	used to store intermediate results from copy  *	operations to and from address spaces.  *  *	Since the information managed by this module is  *	also stored by the logical address mapping module,  *	this module may throw away valid virtual-to-physical  *	mappings at almost any time.  However, invalidations  *	of virtual-to-physical mappings must be done as  *	requested.  *  *	In order to cope with hardware architectures which  *	make virtual-to-physical map invalidates expensive,  *	this module may delay invalidate or reduced protection  *	operations until such time as they are actually  *	necessary.  This module is given full information as  *	to which processors are currently using which maps,  *	and to when physical maps must be made correct.  */
end_comment

begin_include
include|#
directive|include
file|"opt_msgbuf.h"
end_include

begin_include
include|#
directive|include
file|"opt_pmap.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cputypes.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PMAP_SHPGPERPROC
end_ifndef

begin_define
define|#
directive|define
name|PMAP_SHPGPERPROC
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
end_if

begin_define
define|#
directive|define
name|PMAP_DIAGNOSTIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PMAP_DIAGNOSTIC
argument_list|)
end_if

begin_define
define|#
directive|define
name|PMAP_INLINE
value|__inline
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PMAP_INLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PV_STATS
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PV_STATS
end_ifdef

begin_define
define|#
directive|define
name|PV_STAT
parameter_list|(
name|x
parameter_list|)
value|do { x ; } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PV_STAT
parameter_list|(
name|x
parameter_list|)
value|do { } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of first avail page (after kernel bss) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of last avail page (end of kernel AS) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nkpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ndmpdp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_paddr_t
name|dmaplimit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|kernel_vm_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pg_nx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int64_t
name|KPTphys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* phys addr of kernel level 1 */
end_comment

begin_decl_stmt
specifier|static
name|u_int64_t
name|KPDphys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* phys addr of kernel level 2 */
end_comment

begin_decl_stmt
name|u_int64_t
name|KPDPphys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* phys addr of kernel level 3 */
end_comment

begin_decl_stmt
name|u_int64_t
name|KPML4phys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* phys addr of kernel level 4 */
end_comment

begin_decl_stmt
specifier|static
name|u_int64_t
name|DMPDphys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* phys addr of direct mapped level 2 */
end_comment

begin_decl_stmt
specifier|static
name|u_int64_t
name|DMPDPphys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* phys addr of direct mapped level 3 */
end_comment

begin_comment
comment|/*  * Data for the pv entry allocation mechanism  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pv_entry_count
init|=
literal|0
decl_stmt|,
name|pv_entry_max
init|=
literal|0
decl_stmt|,
name|pv_entry_high_water
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|shpgperproc
init|=
name|PMAP_SHPGPERPROC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * All those kernel PT submaps that BSD is so fond of  */
end_comment

begin_decl_stmt
name|pt_entry_t
modifier|*
name|CMAP1
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|CADDR1
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|msgbuf
modifier|*
name|msgbufp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Crashdump maps.  */
end_comment

begin_decl_stmt
specifier|static
name|caddr_t
name|crashdumpmap
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|free_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pv_entry_t
name|pv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pv_entry_t
name|get_pv_entry
parameter_list|(
name|pmap_t
name|locked_pmap
parameter_list|,
name|int
name|try
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|pmap_enter_quick_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_remove_pte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pt_entry_t
modifier|*
name|ptq
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|pd_entry_t
name|ptepde
parameter_list|,
name|vm_page_t
modifier|*
name|free
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_remove_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
modifier|*
name|pde
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_remove_entry
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_insert_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|pmap_try_insert_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|pmap_allocpde
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|pmap_allocpte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|_pmap_allocpte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_pindex_t
name|ptepindex
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_pmap_unwire_pte_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_page_t
modifier|*
name|free
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_unuse_pt
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|pd_entry_t
parameter_list|,
name|vm_page_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|pmap_kmem_choose
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|CTASSERT
argument_list|(
literal|1
operator|<<
name|PDESHIFT
operator|==
sizeof|sizeof
argument_list|(
name|pd_entry_t
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
literal|1
operator|<<
name|PTESHIFT
operator|==
sizeof|sizeof
argument_list|(
name|pt_entry_t
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Move the kernel virtual free pointer to the next  * 2MB.  This is used to help improve performance  * by using a large (2MB) page for much of the kernel  * (.text, .data, .bss)  */
end_comment

begin_function
specifier|static
name|vm_offset_t
name|pmap_kmem_choose
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|vm_offset_t
name|newaddr
init|=
name|addr
decl_stmt|;
name|newaddr
operator|=
operator|(
name|addr
operator|+
operator|(
name|NBPDR
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|NBPDR
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|newaddr
return|;
block|}
end_function

begin_comment
comment|/********************/
end_comment

begin_comment
comment|/* Inline functions */
end_comment

begin_comment
comment|/********************/
end_comment

begin_comment
comment|/* Return a non-clipped PD index for a given VA */
end_comment

begin_function
specifier|static
name|__inline
name|vm_pindex_t
name|pmap_pde_pindex
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
name|va
operator|>>
name|PDRSHIFT
return|;
block|}
end_function

begin_comment
comment|/* Return various clipped indexes for a given VA */
end_comment

begin_function
specifier|static
name|__inline
name|vm_pindex_t
name|pmap_pte_index
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
operator|(
name|va
operator|>>
name|PAGE_SHIFT
operator|)
operator|&
operator|(
operator|(
literal|1ul
operator|<<
name|NPTEPGSHIFT
operator|)
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|vm_pindex_t
name|pmap_pde_index
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
operator|(
name|va
operator|>>
name|PDRSHIFT
operator|)
operator|&
operator|(
operator|(
literal|1ul
operator|<<
name|NPDEPGSHIFT
operator|)
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|vm_pindex_t
name|pmap_pdpe_index
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
operator|(
name|va
operator|>>
name|PDPSHIFT
operator|)
operator|&
operator|(
operator|(
literal|1ul
operator|<<
name|NPDPEPGSHIFT
operator|)
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|vm_pindex_t
name|pmap_pml4e_index
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
operator|(
name|va
operator|>>
name|PML4SHIFT
operator|)
operator|&
operator|(
operator|(
literal|1ul
operator|<<
name|NPML4EPGSHIFT
operator|)
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the PML4 slot that corresponds to a VA */
end_comment

begin_function
specifier|static
name|__inline
name|pml4_entry_t
modifier|*
name|pmap_pml4e
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pmap
condition|)
return|return
name|NULL
return|;
return|return
operator|(
operator|&
name|pmap
operator|->
name|pm_pml4
index|[
name|pmap_pml4e_index
argument_list|(
name|va
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the PDP slot that corresponds to a VA */
end_comment

begin_function
specifier|static
name|__inline
name|pdp_entry_t
modifier|*
name|pmap_pml4e_to_pdpe
parameter_list|(
name|pml4_entry_t
modifier|*
name|pml4e
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pdp_entry_t
modifier|*
name|pdpe
decl_stmt|;
name|pdpe
operator|=
operator|(
name|pdp_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
operator|*
name|pml4e
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|pdpe
index|[
name|pmap_pdpe_index
argument_list|(
name|va
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the PDP slot that corresponds to a VA */
end_comment

begin_function
specifier|static
name|__inline
name|pdp_entry_t
modifier|*
name|pmap_pdpe
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pml4_entry_t
modifier|*
name|pml4e
decl_stmt|;
name|pml4e
operator|=
name|pmap_pml4e
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pml4e
operator|==
name|NULL
operator|||
operator|(
operator|*
name|pml4e
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|pmap_pml4e_to_pdpe
argument_list|(
name|pml4e
argument_list|,
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the PD slot that corresponds to a VA */
end_comment

begin_function
specifier|static
name|__inline
name|pd_entry_t
modifier|*
name|pmap_pdpe_to_pde
parameter_list|(
name|pdp_entry_t
modifier|*
name|pdpe
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pde
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
operator|*
name|pdpe
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|pde
index|[
name|pmap_pde_index
argument_list|(
name|va
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the PD slot that corresponds to a VA */
end_comment

begin_function
specifier|static
name|__inline
name|pd_entry_t
modifier|*
name|pmap_pde
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pdp_entry_t
modifier|*
name|pdpe
decl_stmt|;
name|pdpe
operator|=
name|pmap_pdpe
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdpe
operator|==
name|NULL
operator|||
operator|(
operator|*
name|pdpe
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|pmap_pdpe_to_pde
argument_list|(
name|pdpe
argument_list|,
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the PT slot that corresponds to a VA */
end_comment

begin_function
specifier|static
name|__inline
name|pt_entry_t
modifier|*
name|pmap_pde_to_pte
parameter_list|(
name|pd_entry_t
modifier|*
name|pde
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pte
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
operator|*
name|pde
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|pte
index|[
name|pmap_pte_index
argument_list|(
name|va
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the PT slot that corresponds to a VA */
end_comment

begin_function
specifier|static
name|__inline
name|pt_entry_t
modifier|*
name|pmap_pte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde
operator|==
name|NULL
operator|||
operator|(
operator|*
name|pde
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
operator|*
name|pde
operator|&
name|PG_PS
operator|)
operator|!=
literal|0
condition|)
comment|/* compat with i386 pmap_pte() */
return|return
operator|(
operator|(
name|pt_entry_t
operator|*
operator|)
name|pde
operator|)
return|;
return|return
operator|(
name|pmap_pde_to_pte
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pt_entry_t
modifier|*
name|pmap_pte_pde
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
modifier|*
name|ptepde
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde
operator|==
name|NULL
operator|||
operator|(
operator|*
name|pde
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
operator|*
name|ptepde
operator|=
operator|*
name|pde
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pde
operator|&
name|PG_PS
operator|)
operator|!=
literal|0
condition|)
comment|/* compat with i386 pmap_pte() */
return|return
operator|(
operator|(
name|pt_entry_t
operator|*
operator|)
name|pde
operator|)
return|;
return|return
operator|(
name|pmap_pde_to_pte
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|PMAP_INLINE
name|pt_entry_t
modifier|*
name|vtopte
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|u_int64_t
name|mask
init|=
operator|(
operator|(
literal|1ul
operator|<<
operator|(
name|NPTEPGSHIFT
operator|+
name|NPDEPGSHIFT
operator|+
name|NPDPEPGSHIFT
operator|+
name|NPML4EPGSHIFT
operator|)
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
return|return
operator|(
name|PTmap
operator|+
operator|(
operator|(
name|va
operator|>>
name|PAGE_SHIFT
operator|)
operator|&
name|mask
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pd_entry_t
modifier|*
name|vtopde
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|u_int64_t
name|mask
init|=
operator|(
operator|(
literal|1ul
operator|<<
operator|(
name|NPDEPGSHIFT
operator|+
name|NPDPEPGSHIFT
operator|+
name|NPML4EPGSHIFT
operator|)
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
return|return
operator|(
name|PDmap
operator|+
operator|(
operator|(
name|va
operator|>>
name|PDRSHIFT
operator|)
operator|&
name|mask
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int64_t
name|allocpages
parameter_list|(
name|vm_paddr_t
modifier|*
name|firstaddr
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|u_int64_t
name|ret
decl_stmt|;
name|ret
operator|=
operator|*
name|firstaddr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ret
argument_list|,
name|n
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
operator|*
name|firstaddr
operator|+=
name|n
operator|*
name|PAGE_SIZE
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_pagetables
parameter_list|(
name|vm_paddr_t
modifier|*
name|firstaddr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Allocate pages */
name|KPTphys
operator|=
name|allocpages
argument_list|(
name|firstaddr
argument_list|,
name|NKPT
argument_list|)
expr_stmt|;
name|KPML4phys
operator|=
name|allocpages
argument_list|(
name|firstaddr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|KPDPphys
operator|=
name|allocpages
argument_list|(
name|firstaddr
argument_list|,
name|NKPML4E
argument_list|)
expr_stmt|;
name|KPDphys
operator|=
name|allocpages
argument_list|(
name|firstaddr
argument_list|,
name|NKPDPE
argument_list|)
expr_stmt|;
name|ndmpdp
operator|=
operator|(
name|ptoa
argument_list|(
name|Maxmem
argument_list|)
operator|+
name|NBPDP
operator|-
literal|1
operator|)
operator|>>
name|PDPSHIFT
expr_stmt|;
if|if
condition|(
name|ndmpdp
operator|<
literal|4
condition|)
comment|/* Minimum 4GB of dirmap */
name|ndmpdp
operator|=
literal|4
expr_stmt|;
name|DMPDPphys
operator|=
name|allocpages
argument_list|(
name|firstaddr
argument_list|,
name|NDMPML4E
argument_list|)
expr_stmt|;
name|DMPDphys
operator|=
name|allocpages
argument_list|(
name|firstaddr
argument_list|,
name|ndmpdp
argument_list|)
expr_stmt|;
name|dmaplimit
operator|=
operator|(
name|vm_paddr_t
operator|)
name|ndmpdp
operator|<<
name|PDPSHIFT
expr_stmt|;
comment|/* Fill in the underlying page table pages */
comment|/* Read-only from zero to physfree */
comment|/* XXX not fully used, underneath 2M pages */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<<
name|PAGE_SHIFT
operator|)
operator|<
operator|*
name|firstaddr
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|pt_entry_t
operator|*
operator|)
name|KPTphys
operator|)
index|[
name|i
index|]
operator|=
name|i
operator|<<
name|PAGE_SHIFT
expr_stmt|;
operator|(
operator|(
name|pt_entry_t
operator|*
operator|)
name|KPTphys
operator|)
index|[
name|i
index|]
operator||=
name|PG_RW
operator||
name|PG_V
operator||
name|PG_G
expr_stmt|;
block|}
comment|/* Now map the page tables at their location within PTmap */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NKPT
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|pd_entry_t
operator|*
operator|)
name|KPDphys
operator|)
index|[
name|i
index|]
operator|=
name|KPTphys
operator|+
operator|(
name|i
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
operator|(
operator|(
name|pd_entry_t
operator|*
operator|)
name|KPDphys
operator|)
index|[
name|i
index|]
operator||=
name|PG_RW
operator||
name|PG_V
expr_stmt|;
block|}
comment|/* Map from zero to end of allocations under 2M pages */
comment|/* This replaces some of the KPTphys entries above */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<<
name|PDRSHIFT
operator|)
operator|<
operator|*
name|firstaddr
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|pd_entry_t
operator|*
operator|)
name|KPDphys
operator|)
index|[
name|i
index|]
operator|=
name|i
operator|<<
name|PDRSHIFT
expr_stmt|;
operator|(
operator|(
name|pd_entry_t
operator|*
operator|)
name|KPDphys
operator|)
index|[
name|i
index|]
operator||=
name|PG_RW
operator||
name|PG_V
operator||
name|PG_PS
operator||
name|PG_G
expr_stmt|;
block|}
comment|/* And connect up the PD to the PDP */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NKPDPE
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|pdp_entry_t
operator|*
operator|)
name|KPDPphys
operator|)
index|[
name|i
operator|+
name|KPDPI
index|]
operator|=
name|KPDphys
operator|+
operator|(
name|i
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
operator|(
operator|(
name|pdp_entry_t
operator|*
operator|)
name|KPDPphys
operator|)
index|[
name|i
operator|+
name|KPDPI
index|]
operator||=
name|PG_RW
operator||
name|PG_V
operator||
name|PG_U
expr_stmt|;
block|}
comment|/* Now set up the direct map space using 2MB pages */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPDEPG
operator|*
name|ndmpdp
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|pd_entry_t
operator|*
operator|)
name|DMPDphys
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|vm_paddr_t
operator|)
name|i
operator|<<
name|PDRSHIFT
expr_stmt|;
operator|(
operator|(
name|pd_entry_t
operator|*
operator|)
name|DMPDphys
operator|)
index|[
name|i
index|]
operator||=
name|PG_RW
operator||
name|PG_V
operator||
name|PG_PS
operator||
name|PG_G
expr_stmt|;
block|}
comment|/* And the direct map space's PDP */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndmpdp
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|pdp_entry_t
operator|*
operator|)
name|DMPDPphys
operator|)
index|[
name|i
index|]
operator|=
name|DMPDphys
operator|+
operator|(
name|i
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
operator|(
operator|(
name|pdp_entry_t
operator|*
operator|)
name|DMPDPphys
operator|)
index|[
name|i
index|]
operator||=
name|PG_RW
operator||
name|PG_V
operator||
name|PG_U
expr_stmt|;
block|}
comment|/* And recursively map PML4 to itself in order to get PTmap */
operator|(
operator|(
name|pdp_entry_t
operator|*
operator|)
name|KPML4phys
operator|)
index|[
name|PML4PML4I
index|]
operator|=
name|KPML4phys
expr_stmt|;
operator|(
operator|(
name|pdp_entry_t
operator|*
operator|)
name|KPML4phys
operator|)
index|[
name|PML4PML4I
index|]
operator||=
name|PG_RW
operator||
name|PG_V
operator||
name|PG_U
expr_stmt|;
comment|/* Connect the Direct Map slot up to the PML4 */
operator|(
operator|(
name|pdp_entry_t
operator|*
operator|)
name|KPML4phys
operator|)
index|[
name|DMPML4I
index|]
operator|=
name|DMPDPphys
expr_stmt|;
operator|(
operator|(
name|pdp_entry_t
operator|*
operator|)
name|KPML4phys
operator|)
index|[
name|DMPML4I
index|]
operator||=
name|PG_RW
operator||
name|PG_V
operator||
name|PG_U
expr_stmt|;
comment|/* Connect the KVA slot up to the PML4 */
operator|(
operator|(
name|pdp_entry_t
operator|*
operator|)
name|KPML4phys
operator|)
index|[
name|KPML4I
index|]
operator|=
name|KPDPphys
expr_stmt|;
operator|(
operator|(
name|pdp_entry_t
operator|*
operator|)
name|KPML4phys
operator|)
index|[
name|KPML4I
index|]
operator||=
name|PG_RW
operator||
name|PG_V
operator||
name|PG_U
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Bootstrap the system enough to run with virtual memory.  *  *	On amd64 this is called after mapping has already been enabled  *	and just syncs the pmap module with what has already been done.  *	[We can't call it easily with mapping off since the kernel is not  *	mapped with PA == VA, hence we would have to relocate every address  *	from the linked base (virtual) address "KERNBASE" to the actual  *	(physical) address starting relative to 0]  */
end_comment

begin_function
name|void
name|pmap_bootstrap
parameter_list|(
name|vm_paddr_t
modifier|*
name|firstaddr
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
modifier|*
name|unused
decl_stmt|;
comment|/* 	 * Create an initial set of page tables to run the kernel in. 	 */
name|create_pagetables
argument_list|(
name|firstaddr
argument_list|)
expr_stmt|;
name|virtual_avail
operator|=
operator|(
name|vm_offset_t
operator|)
name|KERNBASE
operator|+
operator|*
name|firstaddr
expr_stmt|;
name|virtual_avail
operator|=
name|pmap_kmem_choose
argument_list|(
name|virtual_avail
argument_list|)
expr_stmt|;
name|virtual_end
operator|=
name|VM_MAX_KERNEL_ADDRESS
expr_stmt|;
comment|/* XXX do %cr0 as well */
name|load_cr4
argument_list|(
name|rcr4
argument_list|()
operator||
name|CR4_PGE
operator||
name|CR4_PSE
argument_list|)
expr_stmt|;
name|load_cr3
argument_list|(
name|KPML4phys
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the kernel pmap (which is statically allocated). 	 */
name|PMAP_LOCK_INIT
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_pml4
operator|=
operator|(
name|pdp_entry_t
operator|*
operator|)
operator|(
name|KERNBASE
operator|+
name|KPML4phys
operator|)
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_active
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* don't allow deactivation */
name|TAILQ_INIT
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
name|nkpt
operator|=
name|NKPT
expr_stmt|;
comment|/* 	 * Reserve some special page table entries/VA space for temporary 	 * mapping of pages. 	 */
define|#
directive|define
name|SYSMAP
parameter_list|(
name|c
parameter_list|,
name|p
parameter_list|,
name|v
parameter_list|,
name|n
parameter_list|)
define|\
value|v = (c)va; va += ((n)*PAGE_SIZE); p = pte; pte += (n);
name|va
operator|=
name|virtual_avail
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * CMAP1 is only used for the memory test. 	 */
name|SYSMAP
argument_list|(
argument|caddr_t
argument_list|,
argument|CMAP1
argument_list|,
argument|CADDR1
argument_list|,
literal|1
argument_list|)
comment|/* 	 * Crashdump maps. 	 */
name|SYSMAP
argument_list|(
argument|caddr_t
argument_list|,
argument|unused
argument_list|,
argument|crashdumpmap
argument_list|,
argument|MAXDUMPPGS
argument_list|)
comment|/* 	 * msgbufp is used to map the system message buffer. 	 */
name|SYSMAP
argument_list|(
argument|struct msgbuf *
argument_list|,
argument|unused
argument_list|,
argument|msgbufp
argument_list|,
argument|atop(round_page(MSGBUF_SIZE))
argument_list|)
name|virtual_avail
operator|=
name|va
expr_stmt|;
operator|*
name|CMAP1
operator|=
literal|0
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
comment|/* Initialize the PAT MSR. */
name|pmap_init_pat
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup the PAT MSR.  */
end_comment

begin_function
name|void
name|pmap_init_pat
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|pat_msr
decl_stmt|;
comment|/* Bail if this CPU doesn't implement PAT. */
if|if
condition|(
operator|!
operator|(
name|cpu_feature
operator|&
name|CPUID_PAT
operator|)
condition|)
name|panic
argument_list|(
literal|"no PAT??"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PAT_WORKS
comment|/* 	 * Leave the indices 0-3 at the default of WB, WT, UC, and UC-. 	 * Program 4 and 5 as WP and WC. 	 * Leave 6 and 7 as UC and UC-. 	 */
name|pat_msr
operator|=
name|rdmsr
argument_list|(
name|MSR_PAT
argument_list|)
expr_stmt|;
name|pat_msr
operator|&=
operator|~
operator|(
name|PAT_MASK
argument_list|(
literal|4
argument_list|)
operator||
name|PAT_MASK
argument_list|(
literal|5
argument_list|)
operator|)
expr_stmt|;
name|pat_msr
operator||=
name|PAT_VALUE
argument_list|(
literal|4
argument_list|,
name|PAT_WRITE_PROTECTED
argument_list|)
operator||
name|PAT_VALUE
argument_list|(
literal|5
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * Due to some Intel errata, we can only safely use the lower 4 	 * PAT entries.  Thus, just replace PAT Index 2 with WC instead 	 * of UC-. 	 * 	 *   Intel Pentium III Processor Specification Update 	 * Errata E.27 (Upper Four PAT Entries Not Usable With Mode B 	 * or Mode C Paging) 	 * 	 *   Intel Pentium IV  Processor Specification Update 	 * Errata N46 (PAT Index MSB May Be Calculated Incorrectly) 	 */
name|pat_msr
operator|=
name|rdmsr
argument_list|(
name|MSR_PAT
argument_list|)
expr_stmt|;
name|pat_msr
operator|&=
operator|~
name|PAT_MASK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|pat_msr
operator||=
name|PAT_VALUE
argument_list|(
literal|2
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wrmsr
argument_list|(
name|MSR_PAT
argument_list|,
name|pat_msr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Initialize a vm_page's machine-dependent fields.  */
end_comment

begin_function
name|void
name|pmap_page_init
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Initialize the pmap module.  *	Called by vm_init, to initialize any structures that the pmap  *	system needs to map virtual memory.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Initialize the address space (zone) for the pv entries.  Set a 	 * high water mark so that the system can recover from excessive 	 * numbers of pv entries. 	 */
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.shpgperproc"
argument_list|,
operator|&
name|shpgperproc
argument_list|)
expr_stmt|;
name|pv_entry_max
operator|=
name|shpgperproc
operator|*
name|maxproc
operator|+
name|cnt
operator|.
name|v_page_count
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.pv_entries"
argument_list|,
operator|&
name|pv_entry_max
argument_list|)
expr_stmt|;
name|pv_entry_high_water
operator|=
literal|9
operator|*
operator|(
name|pv_entry_max
operator|/
literal|10
operator|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"VM/pmap parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|pmap_pventry_proc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|oidp
operator|->
name|oid_arg1
argument_list|,
name|oidp
operator|->
name|oid_arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
condition|)
block|{
name|shpgperproc
operator|=
operator|(
name|pv_entry_max
operator|-
name|cnt
operator|.
name|v_page_count
operator|)
operator|/
name|maxproc
expr_stmt|;
name|pv_entry_high_water
operator|=
literal|9
operator|*
operator|(
name|pv_entry_max
operator|/
literal|10
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_max
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|pv_entry_max
argument_list|,
literal|0
argument_list|,
name|pmap_pventry_proc
argument_list|,
literal|"IU"
argument_list|,
literal|"Max number of PV entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|pmap_shpgperproc_proc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|oidp
operator|->
name|oid_arg1
argument_list|,
name|oidp
operator|->
name|oid_arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
condition|)
block|{
name|pv_entry_max
operator|=
name|shpgperproc
operator|*
name|maxproc
operator|+
name|cnt
operator|.
name|v_page_count
expr_stmt|;
name|pv_entry_high_water
operator|=
literal|9
operator|*
operator|(
name|pv_entry_max
operator|/
literal|10
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|shpgperproc
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|shpgperproc
argument_list|,
literal|0
argument_list|,
name|pmap_shpgperproc_proc
argument_list|,
literal|"IU"
argument_list|,
literal|"Page share factor per proc"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/***************************************************  * Low level helper routines.....  ***************************************************/
end_comment

begin_comment
comment|/*  * Determine the appropriate bits to set in a PTE or PDE for a specified  * caching mode.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_cache_bits
parameter_list|(
name|int
name|mode
parameter_list|,
name|boolean_t
name|is_pde
parameter_list|)
block|{
name|int
name|pat_flag
decl_stmt|,
name|pat_index
decl_stmt|,
name|cache_bits
decl_stmt|;
comment|/* The PAT bit is different for PTE's and PDE's. */
name|pat_flag
operator|=
name|is_pde
condition|?
name|PG_PDE_PAT
else|:
name|PG_PTE_PAT
expr_stmt|;
comment|/* If we don't support PAT, map extended modes to older ones. */
if|if
condition|(
operator|!
operator|(
name|cpu_feature
operator|&
name|CPUID_PAT
operator|)
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|PAT_UNCACHEABLE
case|:
case|case
name|PAT_WRITE_THROUGH
case|:
case|case
name|PAT_WRITE_BACK
case|:
break|break;
case|case
name|PAT_UNCACHED
case|:
case|case
name|PAT_WRITE_COMBINING
case|:
case|case
name|PAT_WRITE_PROTECTED
case|:
name|mode
operator|=
name|PAT_UNCACHEABLE
expr_stmt|;
break|break;
block|}
block|}
comment|/* Map the caching mode to a PAT index. */
switch|switch
condition|(
name|mode
condition|)
block|{
ifdef|#
directive|ifdef
name|PAT_WORKS
case|case
name|PAT_UNCACHEABLE
case|:
name|pat_index
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|PAT_WRITE_THROUGH
case|:
name|pat_index
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PAT_WRITE_BACK
case|:
name|pat_index
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PAT_UNCACHED
case|:
name|pat_index
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|PAT_WRITE_COMBINING
case|:
name|pat_index
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|PAT_WRITE_PROTECTED
case|:
name|pat_index
operator|=
literal|4
expr_stmt|;
break|break;
else|#
directive|else
case|case
name|PAT_UNCACHED
case|:
case|case
name|PAT_UNCACHEABLE
case|:
case|case
name|PAT_WRITE_PROTECTED
case|:
name|pat_index
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|PAT_WRITE_THROUGH
case|:
name|pat_index
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PAT_WRITE_BACK
case|:
name|pat_index
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PAT_WRITE_COMBINING
case|:
name|pat_index
operator|=
literal|2
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"Unknown caching mode %d\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Map the 3-bit index value into the PAT, PCD, and PWT bits. */
name|cache_bits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pat_index
operator|&
literal|0x4
condition|)
name|cache_bits
operator||=
name|pat_flag
expr_stmt|;
if|if
condition|(
name|pat_index
operator|&
literal|0x2
condition|)
name|cache_bits
operator||=
name|PG_NC_PCD
expr_stmt|;
if|if
condition|(
name|pat_index
operator|&
literal|0x1
condition|)
name|cache_bits
operator||=
name|PG_NC_PWT
expr_stmt|;
return|return
operator|(
name|cache_bits
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_comment
comment|/*  * For SMP, these functions have to use the IPI mechanism for coherence.  */
end_comment

begin_function
name|void
name|pmap_invalidate_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|u_int
name|cpumask
decl_stmt|;
name|u_int
name|other_cpus
decl_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
operator|||
name|pmap
operator|->
name|pm_active
operator|==
name|all_cpus
condition|)
block|{
name|invlpg
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|smp_invlpg
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cpumask
operator|=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
name|other_cpus
operator|=
name|PCPU_GET
argument_list|(
name|other_cpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_active
operator|&
name|cpumask
condition|)
name|invlpg
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_active
operator|&
name|other_cpus
condition|)
name|smp_masked_invlpg
argument_list|(
name|pmap
operator|->
name|pm_active
operator|&
name|other_cpus
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|sched_unpin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_invalidate_range
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|u_int
name|cpumask
decl_stmt|;
name|u_int
name|other_cpus
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
operator|||
name|pmap
operator|->
name|pm_active
operator|==
name|all_cpus
condition|)
block|{
for|for
control|(
name|addr
operator|=
name|sva
init|;
name|addr
operator|<
name|eva
condition|;
name|addr
operator|+=
name|PAGE_SIZE
control|)
name|invlpg
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|smp_invlpg_range
argument_list|(
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cpumask
operator|=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
name|other_cpus
operator|=
name|PCPU_GET
argument_list|(
name|other_cpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_active
operator|&
name|cpumask
condition|)
for|for
control|(
name|addr
operator|=
name|sva
init|;
name|addr
operator|<
name|eva
condition|;
name|addr
operator|+=
name|PAGE_SIZE
control|)
name|invlpg
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_active
operator|&
name|other_cpus
condition|)
name|smp_masked_invlpg_range
argument_list|(
name|pmap
operator|->
name|pm_active
operator|&
name|other_cpus
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
block|}
name|sched_unpin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_invalidate_all
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|u_int
name|cpumask
decl_stmt|;
name|u_int
name|other_cpus
decl_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
operator|||
name|pmap
operator|->
name|pm_active
operator|==
name|all_cpus
condition|)
block|{
name|invltlb
argument_list|()
expr_stmt|;
name|smp_invltlb
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|cpumask
operator|=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
name|other_cpus
operator|=
name|PCPU_GET
argument_list|(
name|other_cpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_active
operator|&
name|cpumask
condition|)
name|invltlb
argument_list|()
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_active
operator|&
name|other_cpus
condition|)
name|smp_masked_invltlb
argument_list|(
name|pmap
operator|->
name|pm_active
operator|&
name|other_cpus
argument_list|)
expr_stmt|;
block|}
name|sched_unpin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_invalidate_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|sched_pin
argument_list|()
expr_stmt|;
name|wbinvd
argument_list|()
expr_stmt|;
name|smp_cache_flush
argument_list|()
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !SMP */
end_comment

begin_comment
comment|/*  * Normal, non-SMP, invalidation functions.  * We inline these within pmap.c for speed.  */
end_comment

begin_function
name|PMAP_INLINE
name|void
name|pmap_invalidate_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
operator|||
name|pmap
operator|->
name|pm_active
condition|)
name|invlpg
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PMAP_INLINE
name|void
name|pmap_invalidate_range
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|vm_offset_t
name|addr
decl_stmt|;
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
operator|||
name|pmap
operator|->
name|pm_active
condition|)
for|for
control|(
name|addr
operator|=
name|sva
init|;
name|addr
operator|<
name|eva
condition|;
name|addr
operator|+=
name|PAGE_SIZE
control|)
name|invlpg
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PMAP_INLINE
name|void
name|pmap_invalidate_all
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
operator|||
name|pmap
operator|->
name|pm_active
condition|)
name|invltlb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|PMAP_INLINE
name|void
name|pmap_invalidate_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|wbinvd
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SMP */
end_comment

begin_comment
comment|/*  * Are we current address space or kernel?  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|pmap_is_current
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
return|return
operator|(
name|pmap
operator|==
name|kernel_pmap
operator|||
operator|(
name|pmap
operator|->
name|pm_pml4
index|[
name|PML4PML4I
index|]
operator|&
name|PG_FRAME
operator|)
operator|==
operator|(
name|PML4pml4e
index|[
literal|0
index|]
operator|&
name|PG_FRAME
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract  *	Function:  *		Extract the physical page address associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
name|vm_paddr_t
name|pmap_extract
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|vm_paddr_t
name|rtval
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pd_entry_t
name|pde
decl_stmt|,
modifier|*
name|pdep
decl_stmt|;
name|rtval
operator|=
literal|0
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pdep
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdep
operator|!=
name|NULL
condition|)
block|{
name|pde
operator|=
operator|*
name|pdep
expr_stmt|;
if|if
condition|(
name|pde
condition|)
block|{
if|if
condition|(
operator|(
name|pde
operator|&
name|PG_PS
operator|)
operator|!=
literal|0
condition|)
block|{
name|rtval
operator|=
operator|(
name|pde
operator|&
name|PG_PS_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|PDRMASK
operator|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
name|rtval
return|;
block|}
name|pte
operator|=
name|pmap_pde_to_pte
argument_list|(
name|pdep
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|rtval
operator|=
operator|(
operator|*
name|pte
operator|&
name|PG_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|rtval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract_and_hold  *	Function:  *		Atomically extract and hold the physical page  *		with the given pmap and virtual address pair  *		if that mapping permits the given protection.  */
end_comment

begin_function
name|vm_page_t
name|pmap_extract_and_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|pd_entry_t
name|pde
decl_stmt|,
modifier|*
name|pdep
decl_stmt|;
name|pt_entry_t
name|pte
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pdep
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdep
operator|!=
name|NULL
operator|&&
operator|(
name|pde
operator|=
operator|*
name|pdep
operator|)
condition|)
block|{
if|if
condition|(
name|pde
operator|&
name|PG_PS
condition|)
block|{
if|if
condition|(
operator|(
name|pde
operator|&
name|PG_RW
operator|)
operator|||
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
operator|(
name|pde
operator|&
name|PG_PS_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|PDRMASK
operator|)
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pte
operator|=
operator|*
name|pmap_pde_to_pte
argument_list|(
name|pdep
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|&
name|PG_V
operator|)
operator|&&
operator|(
operator|(
name|pte
operator|&
name|PG_RW
operator|)
operator|||
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pte
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|vm_paddr_t
name|pmap_kextract
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
if|if
condition|(
name|va
operator|>=
name|DMAP_MIN_ADDRESS
operator|&&
name|va
operator|<
name|DMAP_MAX_ADDRESS
condition|)
block|{
name|pa
operator|=
name|DMAP_TO_PHYS
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pde
operator|=
name|vtopde
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pde
operator|&
name|PG_PS
condition|)
block|{
name|pa
operator|=
operator|(
operator|*
name|pde
operator|&
name|PG_PS_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|PDRMASK
operator|)
expr_stmt|;
block|}
else|else
block|{
name|pa
operator|=
operator|*
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pa
operator|=
operator|(
name|pa
operator|&
name|PG_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
block|}
block|}
return|return
name|pa
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * Low level mapping routines.....  ***************************************************/
end_comment

begin_comment
comment|/*  * Add a wired page to the kva.  * Note: not SMP coherent.  */
end_comment

begin_function
name|PMAP_INLINE
name|void
name|pmap_kenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pte_store
argument_list|(
name|pte
argument_list|,
name|pa
operator||
name|PG_RW
operator||
name|PG_V
operator||
name|PG_G
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PMAP_INLINE
name|void
name|pmap_kenter_attr
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pte_store
argument_list|(
name|pte
argument_list|,
name|pa
operator||
name|PG_RW
operator||
name|PG_V
operator||
name|PG_G
operator||
name|pmap_cache_bits
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a page from the kernel pagetables.  * Note: not SMP coherent.  */
end_comment

begin_function
name|PMAP_INLINE
name|void
name|pmap_kremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pte_clear
argument_list|(
name|pte
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Used to map a range of physical addresses into kernel  *	virtual address space.  *  *	The value passed in '*virt' is a suggested virtual address for  *	the mapping. Architectures which can support a direct-mapped  *	physical to virtual region can return the appropriate address  *	within that region, leaving '*virt' unchanged. Other  *	architectures should map the pages starting at '*virt' and  *	update '*virt' with the first usable address after the mapped  *	region.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_paddr_t
name|start
parameter_list|,
name|vm_paddr_t
name|end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
return|return
name|PHYS_TO_DMAP
argument_list|(
name|start
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a list of wired pages to the kva  * this routine is only used for temporary  * kernel mappings that do not need to have  * page modification or references recorded.  * Note that old mappings are simply written  * over.  The page *must* be wired.  * Note: SMP coherent.  Uses a ranged shootdown IPI.  */
end_comment

begin_function
name|void
name|pmap_qenter
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|endpte
decl_stmt|,
name|oldpte
decl_stmt|,
modifier|*
name|pte
decl_stmt|;
name|oldpte
operator|=
literal|0
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|sva
argument_list|)
expr_stmt|;
name|endpte
operator|=
name|pte
operator|+
name|count
expr_stmt|;
while|while
condition|(
name|pte
operator|<
name|endpte
condition|)
block|{
name|oldpte
operator||=
operator|*
name|pte
expr_stmt|;
name|pte_store
argument_list|(
name|pte
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
operator|*
name|ma
argument_list|)
operator||
name|PG_G
operator||
name|PG_RW
operator||
name|PG_V
argument_list|)
expr_stmt|;
name|pte
operator|++
expr_stmt|;
name|ma
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|oldpte
operator|&
name|PG_V
operator|)
operator|!=
literal|0
condition|)
name|pmap_invalidate_range
argument_list|(
name|kernel_pmap
argument_list|,
name|sva
argument_list|,
name|sva
operator|+
name|count
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine tears out page mappings from the  * kernel -- it is meant only for temporary mappings.  * Note: SMP coherent.  Uses a ranged shootdown IPI.  */
end_comment

begin_function
name|void
name|pmap_qremove
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|pmap_kremove
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|pmap_invalidate_range
argument_list|(
name|kernel_pmap
argument_list|,
name|sva
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  * Page table page management routines.....  ***************************************************/
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_free_zero_pages
parameter_list|(
name|vm_page_t
name|free
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
while|while
condition|(
name|free
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|free
expr_stmt|;
name|free
operator|=
name|m
operator|->
name|right
expr_stmt|;
name|vm_page_free_zero
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This routine unholds page table pages, and if the hold count  * drops to zero, then it decrements the wire count.  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|int
name|pmap_unwire_pte_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_page_t
modifier|*
name|free
parameter_list|)
block|{
operator|--
name|m
operator|->
name|wire_count
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
return|return
name|_pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|free
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_pmap_unwire_pte_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_page_t
modifier|*
name|free
parameter_list|)
block|{
name|vm_offset_t
name|pteva
decl_stmt|;
comment|/* 	 * unmap the page table page 	 */
if|if
condition|(
name|m
operator|->
name|pindex
operator|>=
operator|(
name|NUPDE
operator|+
name|NUPDPE
operator|)
condition|)
block|{
comment|/* PDP page */
name|pml4_entry_t
modifier|*
name|pml4
decl_stmt|;
name|pml4
operator|=
name|pmap_pml4e
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pteva
operator|=
operator|(
name|vm_offset_t
operator|)
name|PDPmap
operator|+
name|amd64_ptob
argument_list|(
name|m
operator|->
name|pindex
operator|-
operator|(
name|NUPDE
operator|+
name|NUPDPE
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pml4
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|pindex
operator|>=
name|NUPDE
condition|)
block|{
comment|/* PD page */
name|pdp_entry_t
modifier|*
name|pdp
decl_stmt|;
name|pdp
operator|=
name|pmap_pdpe
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pteva
operator|=
operator|(
name|vm_offset_t
operator|)
name|PDmap
operator|+
name|amd64_ptob
argument_list|(
name|m
operator|->
name|pindex
operator|-
name|NUPDE
argument_list|)
expr_stmt|;
operator|*
name|pdp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* PTE page */
name|pd_entry_t
modifier|*
name|pd
decl_stmt|;
name|pd
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pteva
operator|=
operator|(
name|vm_offset_t
operator|)
name|PTmap
operator|+
name|amd64_ptob
argument_list|(
name|m
operator|->
name|pindex
argument_list|)
expr_stmt|;
operator|*
name|pd
operator|=
literal|0
expr_stmt|;
block|}
operator|--
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|pindex
operator|<
name|NUPDE
condition|)
block|{
comment|/* We just released a PT, unhold the matching PD */
name|vm_page_t
name|pdpg
decl_stmt|;
name|pdpg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
operator|*
name|pmap_pdpe
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|pdpg
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|pindex
operator|>=
name|NUPDE
operator|&&
name|m
operator|->
name|pindex
operator|<
operator|(
name|NUPDE
operator|+
name|NUPDPE
operator|)
condition|)
block|{
comment|/* We just released a PD, unhold the matching PDP */
name|vm_page_t
name|pdppg
decl_stmt|;
name|pdppg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
operator|*
name|pmap_pml4e
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|pdppg
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Do an invltlb to make the invalidated mapping 	 * take effect immediately. 	 */
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|pteva
argument_list|)
expr_stmt|;
comment|/*  	 * Put page on a list so that it is released after 	 * *ALL* TLB shootdown is done 	 */
name|m
operator|->
name|right
operator|=
operator|*
name|free
expr_stmt|;
operator|*
name|free
operator|=
name|m
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * After removing a page table entry, this routine is used to  * conditionally free the page, and manage the hold/wire counts.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_unuse_pt
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
name|ptepde
parameter_list|,
name|vm_page_t
modifier|*
name|free
parameter_list|)
block|{
name|vm_page_t
name|mpte
decl_stmt|;
if|if
condition|(
name|va
operator|>=
name|VM_MAXUSER_ADDRESS
condition|)
return|return
literal|0
return|;
name|KASSERT
argument_list|(
name|ptepde
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_unuse_pt: ptepde != 0"
operator|)
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|ptepde
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
return|return
name|pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|mpte
argument_list|,
name|free
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_pinit0
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|PMAP_LOCK_INIT
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_pml4
operator|=
operator|(
name|pml4_entry_t
operator|*
operator|)
operator|(
name|KERNBASE
operator|+
name|KPML4phys
operator|)
expr_stmt|;
name|pmap
operator|->
name|pm_active
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
name|pmap
operator|->
name|pm_stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure,  * such as one in a vmspace structure.  */
end_comment

begin_function
name|void
name|pmap_pinit
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|vm_page_t
name|pml4pg
decl_stmt|;
specifier|static
name|vm_pindex_t
name|color
decl_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 	 * allocate the page directory page 	 */
while|while
condition|(
operator|(
name|pml4pg
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|color
operator|++
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|VM_WAIT
expr_stmt|;
name|pmap
operator|->
name|pm_pml4
operator|=
operator|(
name|pml4_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|pml4pg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pml4pg
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|pagezero
argument_list|(
name|pmap
operator|->
name|pm_pml4
argument_list|)
expr_stmt|;
comment|/* Wire in kernel global address entries. */
name|pmap
operator|->
name|pm_pml4
index|[
name|KPML4I
index|]
operator|=
name|KPDPphys
operator||
name|PG_RW
operator||
name|PG_V
operator||
name|PG_U
expr_stmt|;
name|pmap
operator|->
name|pm_pml4
index|[
name|DMPML4I
index|]
operator|=
name|DMPDPphys
operator||
name|PG_RW
operator||
name|PG_V
operator||
name|PG_U
expr_stmt|;
comment|/* install self-referential address mapping entry(s) */
name|pmap
operator|->
name|pm_pml4
index|[
name|PML4PML4I
index|]
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|pml4pg
argument_list|)
operator||
name|PG_V
operator||
name|PG_RW
operator||
name|PG_A
operator||
name|PG_M
expr_stmt|;
name|pmap
operator|->
name|pm_active
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
name|pmap
operator|->
name|pm_stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this routine is called if the page table page is not  * mapped correctly.  *  * Note: If a page allocation fails at page table level two or three,  * one or two pages may be held during the wait, only to be released  * afterwards.  This conservative approach is easily argued to avoid  * race conditions.  */
end_comment

begin_function
specifier|static
name|vm_page_t
name|_pmap_allocpte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_pindex_t
name|ptepindex
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|,
name|pdppg
decl_stmt|,
name|pdpg
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_WAITOK
operator|)
operator|)
operator|==
name|M_NOWAIT
operator|||
operator|(
name|flags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_WAITOK
operator|)
operator|)
operator|==
name|M_WAITOK
argument_list|,
operator|(
literal|"_pmap_allocpte: flags is neither M_NOWAIT nor M_WAITOK"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a page table page. 	 */
if|if
condition|(
operator|(
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|ptepindex
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|M_WAITOK
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|VM_WAIT
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Indicate the need to retry.  While waiting, the page table 		 * page may have been allocated. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|pmap_zero_page
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Map the pagetable page into the process address space, if 	 * it isn't already there. 	 */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
if|if
condition|(
name|ptepindex
operator|>=
operator|(
name|NUPDE
operator|+
name|NUPDPE
operator|)
condition|)
block|{
name|pml4_entry_t
modifier|*
name|pml4
decl_stmt|;
name|vm_pindex_t
name|pml4index
decl_stmt|;
comment|/* Wire up a new PDPE page */
name|pml4index
operator|=
name|ptepindex
operator|-
operator|(
name|NUPDE
operator|+
name|NUPDPE
operator|)
expr_stmt|;
name|pml4
operator|=
operator|&
name|pmap
operator|->
name|pm_pml4
index|[
name|pml4index
index|]
expr_stmt|;
operator|*
name|pml4
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator||
name|PG_U
operator||
name|PG_RW
operator||
name|PG_V
operator||
name|PG_A
operator||
name|PG_M
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptepindex
operator|>=
name|NUPDE
condition|)
block|{
name|vm_pindex_t
name|pml4index
decl_stmt|;
name|vm_pindex_t
name|pdpindex
decl_stmt|;
name|pml4_entry_t
modifier|*
name|pml4
decl_stmt|;
name|pdp_entry_t
modifier|*
name|pdp
decl_stmt|;
comment|/* Wire up a new PDE page */
name|pdpindex
operator|=
name|ptepindex
operator|-
name|NUPDE
expr_stmt|;
name|pml4index
operator|=
name|pdpindex
operator|>>
name|NPML4EPGSHIFT
expr_stmt|;
name|pml4
operator|=
operator|&
name|pmap
operator|->
name|pm_pml4
index|[
name|pml4index
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pml4
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Have to allocate a new pdp, recurse */
if|if
condition|(
name|_pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|NUPDE
operator|+
name|NUPDPE
operator|+
name|pml4index
argument_list|,
name|flags
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|--
name|m
operator|->
name|wire_count
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Add reference to pdp page */
name|pdppg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
operator|*
name|pml4
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|pdppg
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
name|pdp
operator|=
operator|(
name|pdp_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
operator|*
name|pml4
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
comment|/* Now find the pdp page */
name|pdp
operator|=
operator|&
name|pdp
index|[
name|pdpindex
operator|&
operator|(
operator|(
literal|1ul
operator|<<
name|NPDPEPGSHIFT
operator|)
operator|-
literal|1
operator|)
index|]
expr_stmt|;
operator|*
name|pdp
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator||
name|PG_U
operator||
name|PG_RW
operator||
name|PG_V
operator||
name|PG_A
operator||
name|PG_M
expr_stmt|;
block|}
else|else
block|{
name|vm_pindex_t
name|pml4index
decl_stmt|;
name|vm_pindex_t
name|pdpindex
decl_stmt|;
name|pml4_entry_t
modifier|*
name|pml4
decl_stmt|;
name|pdp_entry_t
modifier|*
name|pdp
decl_stmt|;
name|pd_entry_t
modifier|*
name|pd
decl_stmt|;
comment|/* Wire up a new PTE page */
name|pdpindex
operator|=
name|ptepindex
operator|>>
name|NPDPEPGSHIFT
expr_stmt|;
name|pml4index
operator|=
name|pdpindex
operator|>>
name|NPML4EPGSHIFT
expr_stmt|;
comment|/* First, find the pdp and check that its valid. */
name|pml4
operator|=
operator|&
name|pmap
operator|->
name|pm_pml4
index|[
name|pml4index
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pml4
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Have to allocate a new pd, recurse */
if|if
condition|(
name|_pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|NUPDE
operator|+
name|pdpindex
argument_list|,
name|flags
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|--
name|m
operator|->
name|wire_count
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|pdp
operator|=
operator|(
name|pdp_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
operator|*
name|pml4
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|pdp
operator|=
operator|&
name|pdp
index|[
name|pdpindex
operator|&
operator|(
operator|(
literal|1ul
operator|<<
name|NPDPEPGSHIFT
operator|)
operator|-
literal|1
operator|)
index|]
expr_stmt|;
block|}
else|else
block|{
name|pdp
operator|=
operator|(
name|pdp_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
operator|*
name|pml4
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|pdp
operator|=
operator|&
name|pdp
index|[
name|pdpindex
operator|&
operator|(
operator|(
literal|1ul
operator|<<
name|NPDPEPGSHIFT
operator|)
operator|-
literal|1
operator|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pdp
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Have to allocate a new pd, recurse */
if|if
condition|(
name|_pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|NUPDE
operator|+
name|pdpindex
argument_list|,
name|flags
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|--
name|m
operator|->
name|wire_count
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Add reference to the pd page */
name|pdpg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
operator|*
name|pdp
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|pdpg
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
block|}
name|pd
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
operator|*
name|pdp
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
comment|/* Now we know where the page directory page is */
name|pd
operator|=
operator|&
name|pd
index|[
name|ptepindex
operator|&
operator|(
operator|(
literal|1ul
operator|<<
name|NPDEPGSHIFT
operator|)
operator|-
literal|1
operator|)
index|]
expr_stmt|;
operator|*
name|pd
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator||
name|PG_U
operator||
name|PG_RW
operator||
name|PG_V
operator||
name|PG_A
operator||
name|PG_M
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|pmap_allocpde
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_pindex_t
name|pdpindex
decl_stmt|,
name|ptepindex
decl_stmt|;
name|pdp_entry_t
modifier|*
name|pdpe
decl_stmt|;
name|vm_page_t
name|pdpg
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_WAITOK
operator|)
operator|)
operator|==
name|M_NOWAIT
operator|||
operator|(
name|flags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_WAITOK
operator|)
operator|)
operator|==
name|M_WAITOK
argument_list|,
operator|(
literal|"pmap_allocpde: flags is neither M_NOWAIT nor M_WAITOK"
operator|)
argument_list|)
expr_stmt|;
name|retry
label|:
name|pdpe
operator|=
name|pmap_pdpe
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdpe
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|pdpe
operator|&
name|PG_V
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Add a reference to the pd page. */
name|pdpg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
operator|*
name|pdpe
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|pdpg
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Allocate a pd page. */
name|ptepindex
operator|=
name|pmap_pde_pindex
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pdpindex
operator|=
name|ptepindex
operator|>>
name|NPDPEPGSHIFT
expr_stmt|;
name|pdpg
operator|=
name|_pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|NUPDE
operator|+
name|pdpindex
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdpg
operator|==
name|NULL
operator|&&
operator|(
name|flags
operator|&
name|M_WAITOK
operator|)
condition|)
goto|goto
name|retry
goto|;
block|}
return|return
operator|(
name|pdpg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|pmap_allocpte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_pindex_t
name|ptepindex
decl_stmt|;
name|pd_entry_t
modifier|*
name|pd
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
name|free
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_WAITOK
operator|)
operator|)
operator|==
name|M_NOWAIT
operator|||
operator|(
name|flags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_WAITOK
operator|)
operator|)
operator|==
name|M_WAITOK
argument_list|,
operator|(
literal|"pmap_allocpte: flags is neither M_NOWAIT nor M_WAITOK"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate pagetable page index 	 */
name|ptepindex
operator|=
name|pmap_pde_pindex
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|retry
label|:
comment|/* 	 * Get the page directory entry 	 */
name|pd
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * This supports switching from a 2MB page to a 	 * normal 4K page. 	 */
if|if
condition|(
name|pd
operator|!=
literal|0
operator|&&
operator|(
operator|*
name|pd
operator|&
operator|(
name|PG_PS
operator||
name|PG_V
operator|)
operator|)
operator|==
operator|(
name|PG_PS
operator||
name|PG_V
operator|)
condition|)
block|{
operator|*
name|pd
operator|=
literal|0
expr_stmt|;
name|pd
operator|=
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
name|NBPDR
operator|/
name|PAGE_SIZE
expr_stmt|;
name|free
operator|=
name|NULL
expr_stmt|;
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
operator|*
name|pmap_pdpe
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
argument_list|,
operator|&
name|free
argument_list|)
expr_stmt|;
name|pmap_invalidate_all
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|pmap_free_zero_pages
argument_list|(
name|free
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the page table page is mapped, we just increment the 	 * hold count, and activate it. 	 */
if|if
condition|(
name|pd
operator|!=
literal|0
operator|&&
operator|(
operator|*
name|pd
operator|&
name|PG_V
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
operator|*
name|pd
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|m
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Here if the pte page isn't mapped, or if it has been 		 * deallocated. 		 */
name|m
operator|=
name|_pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|ptepindex
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|&&
operator|(
name|flags
operator|&
name|M_WAITOK
operator|)
condition|)
goto|goto
name|retry
goto|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * Pmap allocation/deallocation routines.  ***************************************************/
end_comment

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|KASSERT
argument_list|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_release: pmap resident count %ld != 0"
operator|,
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap
operator|->
name|pm_pml4
index|[
name|PML4PML4I
index|]
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_pml4
index|[
name|KPML4I
index|]
operator|=
literal|0
expr_stmt|;
comment|/* KVA */
name|pmap
operator|->
name|pm_pml4
index|[
name|DMPML4I
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Direct Map */
name|pmap
operator|->
name|pm_pml4
index|[
name|PML4PML4I
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Recursive Mapping */
name|m
operator|->
name|wire_count
operator|--
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_free_zero
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|PMAP_LOCK_DESTROY
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|kvm_size
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|unsigned
name|long
name|ksize
init|=
name|VM_MAX_KERNEL_ADDRESS
operator|-
name|KERNBASE
decl_stmt|;
return|return
name|sysctl_handle_long
argument_list|(
name|oidp
argument_list|,
operator|&
name|ksize
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|kvm_size
argument_list|,
name|CTLTYPE_LONG
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|kvm_size
argument_list|,
literal|"LU"
argument_list|,
literal|"Size of KVM"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|kvm_free
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|unsigned
name|long
name|kfree
init|=
name|VM_MAX_KERNEL_ADDRESS
operator|-
name|kernel_vm_end
decl_stmt|;
return|return
name|sysctl_handle_long
argument_list|(
name|oidp
argument_list|,
operator|&
name|kfree
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|kvm_free
argument_list|,
name|CTLTYPE_LONG
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|kvm_free
argument_list|,
literal|"LU"
argument_list|,
literal|"Amount of KVM free"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * grow the number of kernel page table entries, if needed  */
end_comment

begin_function
name|void
name|pmap_growkernel
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|vm_paddr_t
name|paddr
decl_stmt|;
name|vm_page_t
name|nkpg
decl_stmt|;
name|pd_entry_t
modifier|*
name|pde
decl_stmt|,
name|newpdir
decl_stmt|;
name|pdp_entry_t
name|newpdp
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|kernel_map
operator|->
name|system_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|kernel_vm_end
operator|==
literal|0
condition|)
block|{
name|kernel_vm_end
operator|=
name|KERNBASE
expr_stmt|;
name|nkpt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|pmap_pde
argument_list|(
name|kernel_pmap
argument_list|,
name|kernel_vm_end
argument_list|)
operator|&
name|PG_V
operator|)
operator|!=
literal|0
condition|)
block|{
name|kernel_vm_end
operator|=
operator|(
name|kernel_vm_end
operator|+
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
name|nkpt
operator|++
expr_stmt|;
if|if
condition|(
name|kernel_vm_end
operator|-
literal|1
operator|>=
name|kernel_map
operator|->
name|max_offset
condition|)
block|{
name|kernel_vm_end
operator|=
name|kernel_map
operator|->
name|max_offset
expr_stmt|;
break|break;
block|}
block|}
block|}
name|addr
operator|=
name|roundup2
argument_list|(
name|addr
argument_list|,
name|PAGE_SIZE
operator|*
name|NPTEPG
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|-
literal|1
operator|>=
name|kernel_map
operator|->
name|max_offset
condition|)
name|addr
operator|=
name|kernel_map
operator|->
name|max_offset
expr_stmt|;
while|while
condition|(
name|kernel_vm_end
operator|<
name|addr
condition|)
block|{
name|pde
operator|=
name|pmap_pde
argument_list|(
name|kernel_pmap
argument_list|,
name|kernel_vm_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde
operator|==
name|NULL
condition|)
block|{
comment|/* We need a new PDP entry */
name|nkpg
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|nkpt
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_SYSTEM
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nkpg
condition|)
name|panic
argument_list|(
literal|"pmap_growkernel: no memory to grow kernel"
argument_list|)
expr_stmt|;
name|pmap_zero_page
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|paddr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|newpdp
operator|=
call|(
name|pdp_entry_t
call|)
argument_list|(
name|paddr
operator||
name|PG_V
operator||
name|PG_RW
operator||
name|PG_A
operator||
name|PG_M
argument_list|)
expr_stmt|;
operator|*
name|pmap_pdpe
argument_list|(
name|kernel_pmap
argument_list|,
name|kernel_vm_end
argument_list|)
operator|=
name|newpdp
expr_stmt|;
continue|continue;
comment|/* try again */
block|}
if|if
condition|(
operator|(
operator|*
name|pde
operator|&
name|PG_V
operator|)
operator|!=
literal|0
condition|)
block|{
name|kernel_vm_end
operator|=
operator|(
name|kernel_vm_end
operator|+
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|kernel_vm_end
operator|-
literal|1
operator|>=
name|kernel_map
operator|->
name|max_offset
condition|)
block|{
name|kernel_vm_end
operator|=
name|kernel_map
operator|->
name|max_offset
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
comment|/* 		 * This index is bogus, but out of the way 		 */
name|nkpg
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|nkpt
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_SYSTEM
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nkpg
condition|)
name|panic
argument_list|(
literal|"pmap_growkernel: no memory to grow kernel"
argument_list|)
expr_stmt|;
name|nkpt
operator|++
expr_stmt|;
name|pmap_zero_page
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|paddr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|newpdir
operator|=
call|(
name|pd_entry_t
call|)
argument_list|(
name|paddr
operator||
name|PG_V
operator||
name|PG_RW
operator||
name|PG_A
operator||
name|PG_M
argument_list|)
expr_stmt|;
operator|*
name|pmap_pde
argument_list|(
name|kernel_pmap
argument_list|,
name|kernel_vm_end
argument_list|)
operator|=
name|newpdir
expr_stmt|;
name|kernel_vm_end
operator|=
operator|(
name|kernel_vm_end
operator|+
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|kernel_vm_end
operator|-
literal|1
operator|>=
name|kernel_map
operator|->
name|max_offset
condition|)
block|{
name|kernel_vm_end
operator|=
name|kernel_map
operator|->
name|max_offset
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/***************************************************  * page management routines.  ***************************************************/
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pv_chunk
argument_list|)
operator|==
name|PAGE_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|_NPCM
operator|==
literal|3
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|_NPCPV
operator|==
literal|168
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|pv_chunk
operator|*
name|pv_to_chunk
argument_list|(
argument|pv_entry_t pv
argument_list|)
block|{
return|return
operator|(
expr|struct
name|pv_chunk
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|pv
operator|&
operator|~
operator|(
name|uintptr_t
operator|)
name|PAGE_MASK
operator|)
return|;
block|}
end_expr_stmt

begin_define
define|#
directive|define
name|PV_PMAP
parameter_list|(
name|pv
parameter_list|)
value|(pv_to_chunk(pv)->pc_pmap)
end_define

begin_define
define|#
directive|define
name|PC_FREE0
value|0xfffffffffffffffful
end_define

begin_define
define|#
directive|define
name|PC_FREE1
value|0xfffffffffffffffful
end_define

begin_define
define|#
directive|define
name|PC_FREE2
value|0x000000fffffffffful
end_define

begin_decl_stmt
specifier|static
name|uint64_t
name|pc_freemask
index|[
name|_NPCM
index|]
init|=
block|{
name|PC_FREE0
block|,
name|PC_FREE1
block|,
name|PC_FREE2
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_count
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PV_STATS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|pc_chunk_count
decl_stmt|,
name|pc_chunk_allocs
decl_stmt|,
name|pc_chunk_frees
decl_stmt|,
name|pc_chunk_tryfail
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_count
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry chunks"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_allocs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_allocs
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry chunks allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_frees
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_frees
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry chunks frees"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_tryfail
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_tryfail
argument_list|,
literal|0
argument_list|,
literal|"Number of times tried to get a chunk page but failed."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|long
name|pv_entry_frees
decl_stmt|,
name|pv_entry_allocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pv_entry_spare
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_frees
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_frees
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry frees"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_allocs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_allocs
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry allocs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_spare
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_spare
argument_list|,
literal|0
argument_list|,
literal|"Current number of spare pv entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_collect_inactive
decl_stmt|,
name|pmap_collect_active
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_collect_inactive
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_collect_inactive
argument_list|,
literal|0
argument_list|,
literal|"Current number times pmap_collect called on inactive queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_collect_active
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_collect_active
argument_list|,
literal|0
argument_list|,
literal|"Current number times pmap_collect called on active queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * We are in a serious low memory condition.  Resort to  * drastic measures to free some pages so we can allocate  * another pv entry chunk.  This is normally called to  * unmap inactive pages, and if necessary, active pages.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_collect
parameter_list|(
name|pmap_t
name|locked_pmap
parameter_list|,
name|struct
name|vpgqueues
modifier|*
name|vpq
parameter_list|)
block|{
name|pd_entry_t
name|ptepde
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|pv_entry_t
name|next_pv
decl_stmt|,
name|pv
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
name|free
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&vpq->pl
argument_list|,
argument|pageq
argument_list|)
block|{
if|if
condition|(
name|m
operator|->
name|hold_count
operator|||
name|m
operator|->
name|busy
condition|)
continue|continue;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|,
argument|next_pv
argument_list|)
block|{
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
comment|/* Avoid deadlock and lock recursion. */
if|if
condition|(
name|pmap
operator|>
name|locked_pmap
condition|)
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pmap
operator|!=
name|locked_pmap
operator|&&
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
continue|continue;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|pte
operator|=
name|pmap_pte_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
operator|&
name|ptepde
argument_list|)
expr_stmt|;
name|tpte
operator|=
name|pte_load_clear
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|tpte
operator|&
name|PG_W
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_collect: wired pte %#lx"
operator|,
name|tpte
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpte
operator|&
name|PG_A
condition|)
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpte
operator|&
name|PG_M
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|tpte
operator|&
name|PG_RW
operator|)
argument_list|,
operator|(
literal|"pmap_collect: modified page not writable: va: %#lx, pte: %#lx"
operator|,
name|va
operator|,
name|tpte
operator|)
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|free
operator|=
name|NULL
expr_stmt|;
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|ptepde
argument_list|,
operator|&
name|free
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_free_zero_pages
argument_list|(
name|free
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|--
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pmap
argument_list|,
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|locked_pmap
condition|)
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * free the pv_entry back to the free list  */
end_comment

begin_function
specifier|static
name|void
name|free_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pv_entry_t
name|pv
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|field
decl_stmt|,
name|bit
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_frees
operator|++
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|++
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|--
expr_stmt|;
name|pc
operator|=
name|pv_to_chunk
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|idx
operator|=
name|pv
operator|-
operator|&
name|pc
operator|->
name|pc_pventry
index|[
literal|0
index|]
expr_stmt|;
name|field
operator|=
name|idx
operator|/
literal|64
expr_stmt|;
name|bit
operator|=
name|idx
operator|%
literal|64
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator||=
literal|1ul
operator|<<
name|bit
expr_stmt|;
comment|/* move to head of list */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
literal|0
index|]
operator|!=
name|PC_FREE0
operator|||
name|pc
operator|->
name|pc_map
index|[
literal|1
index|]
operator|!=
name|PC_FREE1
operator|||
name|pc
operator|->
name|pc_map
index|[
literal|2
index|]
operator|!=
name|PC_FREE2
condition|)
return|return;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|-=
name|_NPCPV
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_count
operator|--
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_frees
operator|++
argument_list|)
expr_stmt|;
comment|/* entire chunk is free, return it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|DMAP_TO_PHYS
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|dump_drop_page
argument_list|(
name|m
operator|->
name|phys_addr
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a new pv_entry, allocating a block from the system  * when needed.  */
end_comment

begin_function
specifier|static
name|pv_entry_t
name|get_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|int
name|try
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|timeval
name|printinterval
init|=
block|{
literal|60
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|struct
name|timeval
name|lastprint
decl_stmt|;
specifier|static
name|vm_pindex_t
name|colour
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|field
decl_stmt|,
name|page_req
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_allocs
operator|++
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|++
expr_stmt|;
if|if
condition|(
name|pv_entry_count
operator|>
name|pv_entry_high_water
condition|)
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
name|pc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
block|{
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
condition|)
block|{
name|bit
operator|=
name|bsfq
argument_list|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|field
operator|<
name|_NPCM
condition|)
block|{
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
name|field
operator|*
literal|64
operator|+
name|bit
index|]
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|&=
operator|~
operator|(
literal|1ul
operator|<<
name|bit
operator|)
expr_stmt|;
comment|/* If this was the last item, move it to tail */
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|pc
operator|->
name|pc_map
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|pc
operator|->
name|pc_map
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
block|}
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|--
argument_list|)
expr_stmt|;
return|return
operator|(
name|pv
operator|)
return|;
block|}
block|}
comment|/* No free items, allocate another chunk */
name|page_req
operator|=
name|try
condition|?
name|VM_ALLOC_NORMAL
else|:
name|VM_ALLOC_SYSTEM
expr_stmt|;
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|colour
argument_list|,
name|page_req
operator||
name|VM_ALLOC_NOOBJ
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|try
condition|)
block|{
name|pv_entry_count
operator|--
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_tryfail
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 * Reclaim pv entries: At first, destroy mappings to inactive 		 * pages.  After that, if a pv chunk entry is still needed, 		 * destroy mappings to active pages. 		 */
if|if
condition|(
name|ratecheck
argument_list|(
operator|&
name|lastprint
argument_list|,
operator|&
name|printinterval
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Approaching the limit on PV entries, consider "
literal|"increasing sysctl vm.pmap.shpgperproc or "
literal|"vm.pmap.pv_entry_max\n"
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pmap_collect_inactive
operator|++
argument_list|)
expr_stmt|;
name|pmap_collect
argument_list|(
name|pmap
argument_list|,
operator|&
name|vm_page_queues
index|[
name|PQ_INACTIVE
index|]
argument_list|)
expr_stmt|;
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|colour
argument_list|,
name|VM_ALLOC_SYSTEM
operator||
name|VM_ALLOC_NOOBJ
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|PV_STAT
argument_list|(
name|pmap_collect_active
operator|++
argument_list|)
expr_stmt|;
name|pmap_collect
argument_list|(
name|pmap
argument_list|,
operator|&
name|vm_page_queues
index|[
name|PQ_ACTIVE
index|]
argument_list|)
expr_stmt|;
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|colour
argument_list|,
name|VM_ALLOC_SYSTEM
operator||
name|VM_ALLOC_NOOBJ
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"get_pv_entry: increase vm.pmap.shpgperproc"
argument_list|)
expr_stmt|;
block|}
block|}
name|PV_STAT
argument_list|(
name|pc_chunk_count
operator|++
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_allocs
operator|++
argument_list|)
expr_stmt|;
name|colour
operator|++
expr_stmt|;
name|dump_add_page
argument_list|(
name|m
operator|->
name|phys_addr
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
name|void
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|m
operator|->
name|phys_addr
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_pmap
operator|=
name|pmap
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
literal|0
index|]
operator|=
name|PC_FREE0
operator|&
operator|~
literal|1ul
expr_stmt|;
comment|/* preallocated bit 0 */
name|pc
operator|->
name|pc_map
index|[
literal|1
index|]
operator|=
name|PC_FREE1
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
literal|2
index|]
operator|=
name|PC_FREE2
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
literal|0
index|]
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|+=
name|_NPCPV
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|pv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_remove_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|pmap
operator|==
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
break|break;
block|}
name|KASSERT
argument_list|(
name|pv
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_remove_entry: pv not found"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|--
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pmap
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a pv entry for page at pa for  * (pmap, va).  */
end_comment

begin_function
specifier|static
name|void
name|pmap_insert_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pv
operator|=
name|get_pv_entry
argument_list|(
name|pmap
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Conditionally create a pv entry.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|pmap_try_insert_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv_entry_count
operator|<
name|pv_entry_high_water
operator|&&
operator|(
name|pv
operator|=
name|get_pv_entry
argument_list|(
name|pmap
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|++
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pmap_remove_pte: do the things to unmap a page in a process  */
end_comment

begin_function
specifier|static
name|int
name|pmap_remove_pte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pt_entry_t
modifier|*
name|ptq
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
name|ptepde
parameter_list|,
name|vm_page_t
modifier|*
name|free
parameter_list|)
block|{
name|pt_entry_t
name|oldpte
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|oldpte
operator|=
name|pte_load_clear
argument_list|(
name|ptq
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldpte
operator|&
name|PG_W
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|-=
literal|1
expr_stmt|;
comment|/* 	 * Machines that don't support invlpg, also don't support 	 * PG_G. 	 */
if|if
condition|(
name|oldpte
operator|&
name|PG_G
condition|)
name|pmap_invalidate_page
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|oldpte
operator|&
name|PG_MANAGED
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|oldpte
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldpte
operator|&
name|PG_M
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|oldpte
operator|&
name|PG_RW
operator|)
argument_list|,
operator|(
literal|"pmap_remove_pte: modified page not writable: va: %#lx, pte: %#lx"
operator|,
name|va
operator|,
name|oldpte
operator|)
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldpte
operator|&
name|PG_A
condition|)
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
name|pmap_remove_entry
argument_list|(
name|pmap
argument_list|,
name|m
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|ptepde
argument_list|,
name|free
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a single page from a process address space  */
end_comment

begin_function
specifier|static
name|void
name|pmap_remove_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
modifier|*
name|pde
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_page_t
name|free
init|=
name|NULL
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pde
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
return|return;
name|pte
operator|=
name|pmap_pde_to_pte
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pte
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
return|return;
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|va
argument_list|,
operator|*
name|pde
argument_list|,
operator|&
name|free
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_free_zero_pages
argument_list|(
name|free
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Remove the given range of addresses from the specified map.  *  *	It is assumed that the start and end are properly  *	rounded to the page size.  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|vm_offset_t
name|va_next
decl_stmt|;
name|pml4_entry_t
modifier|*
name|pml4e
decl_stmt|;
name|pdp_entry_t
modifier|*
name|pdpe
decl_stmt|;
name|pd_entry_t
name|ptpaddr
decl_stmt|,
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_page_t
name|free
init|=
name|NULL
decl_stmt|;
name|int
name|anyvalid
decl_stmt|;
comment|/* 	 * Perform an unsynchronized read.  This is, however, safe. 	 */
if|if
condition|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
condition|)
return|return;
name|anyvalid
operator|=
literal|0
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 	 * special handling of removing one page.  a very 	 * common operation and easy to short circuit some 	 * code. 	 */
if|if
condition|(
name|sva
operator|+
name|PAGE_SIZE
operator|==
name|eva
condition|)
block|{
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde
operator|&&
operator|(
operator|*
name|pde
operator|&
name|PG_PS
operator|)
operator|==
literal|0
condition|)
block|{
name|pmap_remove_page
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|pde
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
for|for
control|(
init|;
name|sva
operator|<
name|eva
condition|;
name|sva
operator|=
name|va_next
control|)
block|{
if|if
condition|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
condition|)
break|break;
name|pml4e
operator|=
name|pmap_pml4e
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pml4e
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
block|{
name|va_next
operator|=
operator|(
name|sva
operator|+
name|NBPML4
operator|)
operator|&
operator|~
name|PML4MASK
expr_stmt|;
continue|continue;
block|}
name|pdpe
operator|=
name|pmap_pml4e_to_pdpe
argument_list|(
name|pml4e
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pdpe
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
block|{
name|va_next
operator|=
operator|(
name|sva
operator|+
name|NBPDP
operator|)
operator|&
operator|~
name|PDPMASK
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Calculate index for next page table. 		 */
name|va_next
operator|=
operator|(
name|sva
operator|+
name|NBPDR
operator|)
operator|&
operator|~
name|PDRMASK
expr_stmt|;
name|pde
operator|=
name|pmap_pdpe_to_pde
argument_list|(
name|pdpe
argument_list|,
name|sva
argument_list|)
expr_stmt|;
name|ptpaddr
operator|=
operator|*
name|pde
expr_stmt|;
comment|/* 		 * Weed out invalid mappings. 		 */
if|if
condition|(
name|ptpaddr
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Check for large page. 		 */
if|if
condition|(
operator|(
name|ptpaddr
operator|&
name|PG_PS
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|pde
operator|=
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
name|NBPDR
operator|/
name|PAGE_SIZE
expr_stmt|;
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
operator|*
name|pdpe
argument_list|,
operator|&
name|free
argument_list|)
expr_stmt|;
name|anyvalid
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Limit our scan to either the end of the va represented 		 * by the current page table page, or to the end of the 		 * range being removed. 		 */
if|if
condition|(
name|va_next
operator|>
name|eva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
for|for
control|(
name|pte
operator|=
name|pmap_pde_to_pte
argument_list|(
name|pde
argument_list|,
name|sva
argument_list|)
init|;
name|sva
operator|!=
name|va_next
condition|;
name|pte
operator|++
operator|,
name|sva
operator|+=
name|PAGE_SIZE
control|)
block|{
if|if
condition|(
operator|*
name|pte
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * The TLB entry for a PG_G mapping is invalidated 			 * by pmap_remove_pte(). 			 */
if|if
condition|(
operator|(
operator|*
name|pte
operator|&
name|PG_G
operator|)
operator|==
literal|0
condition|)
name|anyvalid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|sva
argument_list|,
name|ptpaddr
argument_list|,
operator|&
name|free
argument_list|)
condition|)
break|break;
block|}
block|}
name|out
label|:
if|if
condition|(
name|anyvalid
condition|)
block|{
name|pmap_invalidate_all
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap_free_zero_pages
argument_list|(
name|free
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_remove_all  *	Function:  *		Removes this physical page from  *		all physical maps in which it resides.  *		Reflects back modify bits to the pager.  *  *	Notes:  *		Original versions of this routine were very  *		inefficient because they iteratively called  *		pmap_remove (slow...)  */
end_comment

begin_function
name|void
name|pmap_remove_all
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|pd_entry_t
name|ptepde
decl_stmt|;
name|vm_page_t
name|free
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PMAP_DIAGNOSTIC
argument_list|)
comment|/* 	 * XXX This makes pmap_remove_all() illegal for non-managed pages! 	 */
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_remove_all: illegal for unmanaged page, va: 0x%lx"
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|pte
operator|=
name|pmap_pte_pde
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|&
name|ptepde
argument_list|)
expr_stmt|;
name|tpte
operator|=
name|pte_load_clear
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpte
operator|&
name|PG_W
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
if|if
condition|(
name|tpte
operator|&
name|PG_A
condition|)
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
comment|/* 		 * Update the vm_page_t clean and reference bits. 		 */
if|if
condition|(
name|tpte
operator|&
name|PG_M
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|tpte
operator|&
name|PG_RW
operator|)
argument_list|,
operator|(
literal|"pmap_remove_all: modified page not writable: va: %#lx, pte: %#lx"
operator|,
name|pv
operator|->
name|pv_va
operator|,
name|tpte
operator|)
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|free
operator|=
name|NULL
expr_stmt|;
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|ptepde
argument_list|,
operator|&
name|free
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|pmap_free_zero_pages
argument_list|(
name|free
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|--
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pmap
argument_list|,
name|pv
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Set the physical protection on the  *	specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|va_next
decl_stmt|;
name|pml4_entry_t
modifier|*
name|pml4e
decl_stmt|;
name|pdp_entry_t
modifier|*
name|pdpe
decl_stmt|;
name|pd_entry_t
name|ptpaddr
decl_stmt|,
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|int
name|anychanged
decl_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|prot
operator|&
operator|(
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
operator|)
operator|)
operator|==
operator|(
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
operator|)
condition|)
return|return;
name|anychanged
operator|=
literal|0
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sva
operator|<
name|eva
condition|;
name|sva
operator|=
name|va_next
control|)
block|{
name|pml4e
operator|=
name|pmap_pml4e
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pml4e
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
block|{
name|va_next
operator|=
operator|(
name|sva
operator|+
name|NBPML4
operator|)
operator|&
operator|~
name|PML4MASK
expr_stmt|;
continue|continue;
block|}
name|pdpe
operator|=
name|pmap_pml4e_to_pdpe
argument_list|(
name|pml4e
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pdpe
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
block|{
name|va_next
operator|=
operator|(
name|sva
operator|+
name|NBPDP
operator|)
operator|&
operator|~
name|PDPMASK
expr_stmt|;
continue|continue;
block|}
name|va_next
operator|=
operator|(
name|sva
operator|+
name|NBPDR
operator|)
operator|&
operator|~
name|PDRMASK
expr_stmt|;
name|pde
operator|=
name|pmap_pdpe_to_pde
argument_list|(
name|pdpe
argument_list|,
name|sva
argument_list|)
expr_stmt|;
name|ptpaddr
operator|=
operator|*
name|pde
expr_stmt|;
comment|/* 		 * Weed out invalid mappings. 		 */
if|if
condition|(
name|ptpaddr
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Check for large page. 		 */
if|if
condition|(
operator|(
name|ptpaddr
operator|&
name|PG_PS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
operator|*
name|pde
operator|&=
operator|~
operator|(
name|PG_M
operator||
name|PG_RW
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
operator|==
literal|0
condition|)
operator|*
name|pde
operator||=
name|pg_nx
expr_stmt|;
name|anychanged
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|va_next
operator|>
name|eva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
for|for
control|(
name|pte
operator|=
name|pmap_pde_to_pte
argument_list|(
name|pde
argument_list|,
name|sva
argument_list|)
init|;
name|sva
operator|!=
name|va_next
condition|;
name|pte
operator|++
operator|,
name|sva
operator|+=
name|PAGE_SIZE
control|)
block|{
name|pt_entry_t
name|obits
decl_stmt|,
name|pbits
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|retry
label|:
name|obits
operator|=
name|pbits
operator|=
operator|*
name|pte
expr_stmt|;
if|if
condition|(
operator|(
name|pbits
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|pbits
operator|&
name|PG_MANAGED
condition|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pbits
operator|&
name|PG_A
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pbits
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
name|pbits
operator|&=
operator|~
name|PG_A
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pbits
operator|&
name|PG_M
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pbits
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
name|pbits
operator|&=
operator|~
operator|(
name|PG_RW
operator||
name|PG_M
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
operator|==
literal|0
condition|)
name|pbits
operator||=
name|pg_nx
expr_stmt|;
if|if
condition|(
name|pbits
operator|!=
name|obits
condition|)
block|{
if|if
condition|(
operator|!
name|atomic_cmpset_long
argument_list|(
name|pte
argument_list|,
name|obits
argument_list|,
name|pbits
argument_list|)
condition|)
goto|goto
name|retry
goto|;
if|if
condition|(
name|obits
operator|&
name|PG_G
condition|)
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
else|else
name|anychanged
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|anychanged
condition|)
name|pmap_invalidate_all
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Insert the given physical page (p) at  *	the specified virtual address (v) in the  *	target physical map with the protection requested.  *  *	If specified, the page will be wired down, meaning  *	that the related pte can not be reclaimed.  *  *	NB:  This is the only routine which MAY NOT lazy-evaluate  *	or lose information.  That is, this routine must actually  *	insert this page into the given map NOW.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_paddr_t
name|opa
decl_stmt|;
name|pt_entry_t
name|origpte
decl_stmt|,
name|newpte
decl_stmt|;
name|vm_page_t
name|mpte
decl_stmt|,
name|om
decl_stmt|;
name|boolean_t
name|invlva
decl_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAP_DIAGNOSTIC
if|if
condition|(
name|va
operator|>
name|VM_MAX_KERNEL_ADDRESS
condition|)
name|panic
argument_list|(
literal|"pmap_enter: toobig"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|va
operator|>=
name|UPT_MIN_ADDRESS
operator|)
operator|&&
operator|(
name|va
operator|<
name|UPT_MAX_ADDRESS
operator|)
condition|)
name|panic
argument_list|(
literal|"pmap_enter: invalid to pmap_enter page table pages (va: 0x%lx)"
argument_list|,
name|va
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mpte
operator|=
name|NULL
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 	 * In the case that a page table page is not 	 * resident, we are creating it here. 	 */
if|if
condition|(
name|va
operator|<
name|VM_MAXUSER_ADDRESS
condition|)
block|{
name|mpte
operator|=
name|pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|PMAP_DIAGNOSTIC
argument_list|)
block|else { 		pd_entry_t *pdeaddr = pmap_pde(pmap, va); 		origpte = *pdeaddr; 		if ((origpte& PG_V) == 0) {  			panic("pmap_enter: invalid kernel page table page, pde=%p, va=%p\n", 				origpte, va); 		} 	}
endif|#
directive|endif
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|pde
operator|&
name|PG_PS
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_enter: attempted pmap_enter on 2MB page"
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pde_to_pte
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
else|else
name|pte
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Page Directory table entry not valid, we need a new PT page 	 */
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_enter: invalid page directory va=%#lx\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|om
operator|=
name|NULL
expr_stmt|;
name|origpte
operator|=
operator|*
name|pte
expr_stmt|;
name|opa
operator|=
name|origpte
operator|&
name|PG_FRAME
expr_stmt|;
comment|/* 	 * Mapping has not changed, must be protection or wiring change. 	 */
if|if
condition|(
name|origpte
operator|&&
operator|(
name|opa
operator|==
name|pa
operator|)
condition|)
block|{
comment|/* 		 * Wiring change, just update stats. We don't worry about 		 * wiring PT pages as they remain resident as long as there 		 * are valid mappings in them. Hence, if a user page is wired, 		 * the PT page will be also. 		 */
if|if
condition|(
name|wired
operator|&&
operator|(
operator|(
name|origpte
operator|&
name|PG_W
operator|)
operator|==
literal|0
operator|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wired
operator|&&
operator|(
name|origpte
operator|&
name|PG_W
operator|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
comment|/* 		 * Remove extra pte reference 		 */
if|if
condition|(
name|mpte
condition|)
name|mpte
operator|->
name|wire_count
operator|--
expr_stmt|;
comment|/* 		 * We might be turning off write access to the page, 		 * so we go ahead and sense modify status. 		 */
if|if
condition|(
name|origpte
operator|&
name|PG_MANAGED
condition|)
block|{
name|om
operator|=
name|m
expr_stmt|;
name|pa
operator||=
name|PG_MANAGED
expr_stmt|;
block|}
goto|goto
name|validate
goto|;
block|}
comment|/* 	 * Mapping has changed, invalidate old range and fall through to 	 * handle validating new mapping. 	 */
if|if
condition|(
name|opa
condition|)
block|{
if|if
condition|(
name|origpte
operator|&
name|PG_W
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
if|if
condition|(
name|origpte
operator|&
name|PG_MANAGED
condition|)
block|{
name|om
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|opa
argument_list|)
expr_stmt|;
name|pmap_remove_entry
argument_list|(
name|pmap
argument_list|,
name|om
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mpte
operator|!=
name|NULL
condition|)
block|{
name|mpte
operator|->
name|wire_count
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|mpte
operator|->
name|wire_count
operator|>
literal|0
argument_list|,
operator|(
literal|"pmap_enter: missing reference to page table page,"
literal|" va: 0x%lx"
operator|,
name|va
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
comment|/* 	 * Enter on the PV list if part of our managed memory. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|va
operator|<
name|kmi
operator|.
name|clean_sva
operator|||
name|va
operator|>=
name|kmi
operator|.
name|clean_eva
argument_list|,
operator|(
literal|"pmap_enter: managed mapping within the clean submap"
operator|)
argument_list|)
expr_stmt|;
name|pmap_insert_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|pa
operator||=
name|PG_MANAGED
expr_stmt|;
block|}
comment|/* 	 * Increment counters 	 */
if|if
condition|(
name|wired
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|validate
label|:
comment|/* 	 * Now validate mapping with desired protection/wiring. 	 */
name|newpte
operator|=
call|(
name|pt_entry_t
call|)
argument_list|(
name|pa
operator||
name|PG_V
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
condition|)
block|{
name|newpte
operator||=
name|PG_RW
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
operator|==
literal|0
condition|)
name|newpte
operator||=
name|pg_nx
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|newpte
operator||=
name|PG_W
expr_stmt|;
if|if
condition|(
name|va
operator|<
name|VM_MAXUSER_ADDRESS
condition|)
name|newpte
operator||=
name|PG_U
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
name|newpte
operator||=
name|PG_G
expr_stmt|;
comment|/* 	 * if the mapping or permission bits are different, we need 	 * to update the pte. 	 */
if|if
condition|(
operator|(
name|origpte
operator|&
operator|~
operator|(
name|PG_M
operator||
name|PG_A
operator|)
operator|)
operator|!=
name|newpte
condition|)
block|{
if|if
condition|(
name|origpte
operator|&
name|PG_V
condition|)
block|{
name|invlva
operator|=
name|FALSE
expr_stmt|;
name|origpte
operator|=
name|pte_load_store
argument_list|(
name|pte
argument_list|,
name|newpte
operator||
name|PG_A
argument_list|)
expr_stmt|;
if|if
condition|(
name|origpte
operator|&
name|PG_A
condition|)
block|{
if|if
condition|(
name|origpte
operator|&
name|PG_MANAGED
condition|)
name|vm_page_flag_set
argument_list|(
name|om
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
if|if
condition|(
name|opa
operator|!=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|||
operator|(
operator|(
name|origpte
operator|&
name|PG_NX
operator|)
operator|==
literal|0
operator|&&
operator|(
name|newpte
operator|&
name|PG_NX
operator|)
operator|)
condition|)
name|invlva
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|origpte
operator|&
name|PG_M
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|origpte
operator|&
name|PG_RW
operator|)
argument_list|,
operator|(
literal|"pmap_enter: modified page not writable: va: %#lx, pte: %#lx"
operator|,
name|va
operator|,
name|origpte
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|origpte
operator|&
name|PG_MANAGED
operator|)
operator|!=
literal|0
condition|)
name|vm_page_dirty
argument_list|(
name|om
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newpte
operator|&
name|PG_RW
operator|)
operator|==
literal|0
condition|)
name|invlva
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|invlva
condition|)
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
else|else
name|pte_store
argument_list|(
name|pte
argument_list|,
name|newpte
operator||
name|PG_A
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Maps a sequence of resident pages belonging to the same object.  * The sequence begins with the given page m_start.  This page is  * mapped at the given virtual address start.  Each subsequent page is  * mapped at a virtual address that is offset from start by the same  * amount as the page is offset from m_start within the object.  The  * last page in the sequence is the page with the largest offset from  * m_start that can be mapped at a virtual address less than the given  * virtual address end.  Not every virtual page between start and end  * is mapped; only those for which a resident page exists with the  * corresponding offset from m_start are mapped.  */
end_comment

begin_function
name|void
name|pmap_enter_object
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_page_t
name|m_start
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|,
name|mpte
decl_stmt|;
name|vm_pindex_t
name|diff
decl_stmt|,
name|psize
decl_stmt|;
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|m_start
operator|->
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|psize
operator|=
name|atop
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
name|m_start
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|diff
operator|=
name|m
operator|->
name|pindex
operator|-
name|m_start
operator|->
name|pindex
operator|)
operator|<
name|psize
condition|)
block|{
name|mpte
operator|=
name|pmap_enter_quick_locked
argument_list|(
name|pmap
argument_list|,
name|start
operator|+
name|ptoa
argument_list|(
name|diff
argument_list|)
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|mpte
argument_list|)
expr_stmt|;
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this code makes some *MAJOR* assumptions:  * 1. Current pmap& pmap exists.  * 2. Not wired.  * 3. Read access.  * 4. No page table pages.  * but is *MUCH* faster than pmap_enter...  */
end_comment

begin_function
name|void
name|pmap_enter_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pmap_enter_quick_locked
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|pmap_enter_quick_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|)
block|{
name|vm_page_t
name|free
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|KASSERT
argument_list|(
name|va
operator|<
name|kmi
operator|.
name|clean_sva
operator|||
name|va
operator|>=
name|kmi
operator|.
name|clean_eva
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_enter_quick_locked: managed mapping within the clean submap"
operator|)
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * In the case that a page table page is not 	 * resident, we are creating it here. 	 */
if|if
condition|(
name|va
operator|<
name|VM_MAXUSER_ADDRESS
condition|)
block|{
name|vm_pindex_t
name|ptepindex
decl_stmt|;
name|pd_entry_t
modifier|*
name|ptepa
decl_stmt|;
comment|/* 		 * Calculate pagetable page index 		 */
name|ptepindex
operator|=
name|pmap_pde_pindex
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpte
operator|&&
operator|(
name|mpte
operator|->
name|pindex
operator|==
name|ptepindex
operator|)
condition|)
block|{
name|mpte
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Get the page directory entry 			 */
name|ptepa
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 			 * If the page table page is mapped, we just increment 			 * the hold count, and activate it. 			 */
if|if
condition|(
name|ptepa
operator|&&
operator|(
operator|*
name|ptepa
operator|&
name|PG_V
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|ptepa
operator|&
name|PG_PS
condition|)
name|panic
argument_list|(
literal|"pmap_enter_quick: unexpected mapping into 2MB page"
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
operator|*
name|ptepa
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|mpte
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|mpte
operator|=
name|_pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|ptepindex
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpte
operator|==
name|NULL
condition|)
return|return
operator|(
name|mpte
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
name|mpte
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * This call to vtopte makes the assumption that we are 	 * entering the page into the current pmap.  In order to support 	 * quick entry into any pmap, one would likely use pmap_pte. 	 * But that isn't as quick as vtopte. 	 */
name|pte
operator|=
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pte
condition|)
block|{
if|if
condition|(
name|mpte
operator|!=
name|NULL
condition|)
block|{
name|mpte
operator|->
name|wire_count
operator|--
expr_stmt|;
name|mpte
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|mpte
operator|)
return|;
block|}
comment|/* 	 * Enter on the PV list if part of our managed memory. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|!
name|pmap_try_insert_pv_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|)
condition|)
block|{
if|if
condition|(
name|mpte
operator|!=
name|NULL
condition|)
block|{
name|free
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|mpte
argument_list|,
operator|&
name|free
argument_list|)
condition|)
block|{
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_free_zero_pages
argument_list|(
name|free
argument_list|)
expr_stmt|;
block|}
name|mpte
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|mpte
operator|)
return|;
block|}
comment|/* 	 * Increment counters 	 */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
operator|==
literal|0
condition|)
name|pa
operator||=
name|pg_nx
expr_stmt|;
comment|/* 	 * Now validate mapping with RO protection 	 */
if|if
condition|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
condition|)
name|pte_store
argument_list|(
name|pte
argument_list|,
name|pa
operator||
name|PG_V
operator||
name|PG_U
argument_list|)
expr_stmt|;
else|else
name|pte_store
argument_list|(
name|pte
argument_list|,
name|pa
operator||
name|PG_V
operator||
name|PG_U
operator||
name|PG_MANAGED
argument_list|)
expr_stmt|;
return|return
name|mpte
return|;
block|}
end_function

begin_comment
comment|/*  * Make a temporary mapping for a physical address.  This is only intended  * to be used for panic dumps.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_kenter_temporary
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|crashdumpmap
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|invlpg
argument_list|(
name|va
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|crashdumpmap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This code maps large physical mmap regions into the  * processor address space.  Note that some shortcuts  * are taken, but the code works.  */
end_comment

begin_function
name|void
name|pmap_object_init_pt
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|,
name|pdpg
decl_stmt|;
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
argument_list|,
operator|(
literal|"pmap_object_init_pt: non-device object"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|addr
operator|&
operator|(
name|NBPDR
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|size
operator|&
operator|(
name|NBPDR
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|vm_page_t
name|m
index|[
literal|1
index|]
decl_stmt|;
name|pd_entry_t
name|ptepa
decl_stmt|,
modifier|*
name|pde
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde
operator|!=
literal|0
operator|&&
operator|(
operator|*
name|pde
operator|&
name|PG_V
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|retry
label|:
name|p
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vm_page_sleep_if_busy
argument_list|(
name|p
argument_list|,
name|FALSE
argument_list|,
literal|"init4p"
argument_list|)
condition|)
goto|goto
name|retry
goto|;
block|}
else|else
block|{
name|p
operator|=
name|vm_page_alloc
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
name|m
index|[
literal|0
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|vm_pager_get_pages
argument_list|(
name|object
argument_list|,
name|m
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|!=
name|VM_PAGER_OK
condition|)
block|{
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
name|ptepa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptepa
operator|&
operator|(
name|NBPDR
operator|-
literal|1
operator|)
condition|)
return|return;
name|p
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
for|for
control|(
name|va
operator|=
name|addr
init|;
name|va
operator|<
name|addr
operator|+
name|size
condition|;
name|va
operator|+=
name|NBPDR
control|)
block|{
while|while
condition|(
operator|(
name|pdpg
operator|=
name|pmap_allocpde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_busy
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|VM_WAIT
expr_stmt|;
name|VM_OBJECT_LOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|pde
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|pdpg
argument_list|)
argument_list|)
expr_stmt|;
name|pde
operator|=
operator|&
name|pde
index|[
name|pmap_pde_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pde
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
block|{
name|pde_store
argument_list|(
name|pde
argument_list|,
name|ptepa
operator||
name|PG_PS
operator||
name|PG_M
operator||
name|PG_A
operator||
name|PG_U
operator||
name|PG_RW
operator||
name|PG_V
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|+=
name|NBPDR
operator|/
name|PAGE_SIZE
expr_stmt|;
block|}
else|else
block|{
name|pdpg
operator|->
name|wire_count
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|pdpg
operator|->
name|wire_count
operator|>
literal|0
argument_list|,
operator|(
literal|"pmap_object_init_pt: missing reference "
literal|"to page directory page, va: 0x%lx"
operator|,
name|va
operator|)
argument_list|)
expr_stmt|;
block|}
name|ptepa
operator|+=
name|NBPDR
expr_stmt|;
block|}
name|pmap_invalidate_all
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|out
label|:
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_change_wiring  *	Function:	Change the wiring attribute for a map/virtual-address  *			pair.  *	In/out conditions:  *			The mapping must already exist in the pmap.  */
end_comment

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
comment|/* 	 * Wiring is not a hardware characteristic so there is no need to 	 * invalidate TLB. 	 */
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|wired
operator|&&
operator|(
operator|*
name|pte
operator|&
name|PG_W
operator|)
operator|==
literal|0
condition|)
block|{
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|atomic_set_long
argument_list|(
name|pte
argument_list|,
name|PG_W
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|wired
operator|&&
operator|(
operator|*
name|pte
operator|&
name|PG_W
operator|)
operator|!=
literal|0
condition|)
block|{
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|atomic_clear_long
argument_list|(
name|pte
argument_list|,
name|PG_W
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Copy the range specified by src_addr/len  *	from the source map to the range dst_addr/len  *	in the destination map.  *  *	This routine is only advisory and need not do anything.  */
end_comment

begin_function
name|void
name|pmap_copy
parameter_list|(
name|pmap_t
name|dst_pmap
parameter_list|,
name|pmap_t
name|src_pmap
parameter_list|,
name|vm_offset_t
name|dst_addr
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|vm_offset_t
name|src_addr
parameter_list|)
block|{
name|vm_page_t
name|free
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_offset_t
name|end_addr
init|=
name|src_addr
operator|+
name|len
decl_stmt|;
name|vm_offset_t
name|va_next
decl_stmt|;
if|if
condition|(
name|dst_addr
operator|!=
name|src_addr
condition|)
return|return;
if|if
condition|(
operator|!
name|pmap_is_current
argument_list|(
name|src_pmap
argument_list|)
condition|)
return|return;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
name|dst_pmap
operator|<
name|src_pmap
condition|)
block|{
name|PMAP_LOCK
argument_list|(
name|dst_pmap
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|src_pmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PMAP_LOCK
argument_list|(
name|src_pmap
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|dst_pmap
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|addr
operator|=
name|src_addr
init|;
name|addr
operator|<
name|end_addr
condition|;
name|addr
operator|=
name|va_next
control|)
block|{
name|pt_entry_t
modifier|*
name|src_pte
decl_stmt|,
modifier|*
name|dst_pte
decl_stmt|;
name|vm_page_t
name|dstmpde
decl_stmt|,
name|dstmpte
decl_stmt|,
name|srcmpte
decl_stmt|;
name|pml4_entry_t
modifier|*
name|pml4e
decl_stmt|;
name|pdp_entry_t
modifier|*
name|pdpe
decl_stmt|;
name|pd_entry_t
name|srcptepaddr
decl_stmt|,
modifier|*
name|pde
decl_stmt|;
if|if
condition|(
name|addr
operator|>=
name|UPT_MIN_ADDRESS
condition|)
name|panic
argument_list|(
literal|"pmap_copy: invalid to pmap_copy page tables"
argument_list|)
expr_stmt|;
name|pml4e
operator|=
name|pmap_pml4e
argument_list|(
name|src_pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pml4e
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
block|{
name|va_next
operator|=
operator|(
name|addr
operator|+
name|NBPML4
operator|)
operator|&
operator|~
name|PML4MASK
expr_stmt|;
continue|continue;
block|}
name|pdpe
operator|=
name|pmap_pml4e_to_pdpe
argument_list|(
name|pml4e
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pdpe
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
block|{
name|va_next
operator|=
operator|(
name|addr
operator|+
name|NBPDP
operator|)
operator|&
operator|~
name|PDPMASK
expr_stmt|;
continue|continue;
block|}
name|va_next
operator|=
operator|(
name|addr
operator|+
name|NBPDR
operator|)
operator|&
operator|~
name|PDRMASK
expr_stmt|;
name|pde
operator|=
name|pmap_pdpe_to_pde
argument_list|(
name|pdpe
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|srcptepaddr
operator|=
operator|*
name|pde
expr_stmt|;
if|if
condition|(
name|srcptepaddr
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|srcptepaddr
operator|&
name|PG_PS
condition|)
block|{
name|dstmpde
operator|=
name|pmap_allocpde
argument_list|(
name|dst_pmap
argument_list|,
name|addr
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstmpde
operator|==
name|NULL
condition|)
break|break;
name|pde
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|dstmpde
argument_list|)
argument_list|)
expr_stmt|;
name|pde
operator|=
operator|&
name|pde
index|[
name|pmap_pde_index
argument_list|(
name|addr
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|pde
operator|==
literal|0
condition|)
block|{
operator|*
name|pde
operator|=
name|srcptepaddr
operator|&
operator|~
name|PG_W
expr_stmt|;
name|dst_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|+=
name|NBPDR
operator|/
name|PAGE_SIZE
expr_stmt|;
block|}
else|else
name|dstmpde
operator|->
name|wire_count
operator|--
expr_stmt|;
continue|continue;
block|}
name|srcmpte
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|srcptepaddr
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcmpte
operator|->
name|wire_count
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_copy: source page table page is unused"
argument_list|)
expr_stmt|;
if|if
condition|(
name|va_next
operator|>
name|end_addr
condition|)
name|va_next
operator|=
name|end_addr
expr_stmt|;
name|src_pte
operator|=
name|vtopte
argument_list|(
name|addr
argument_list|)
expr_stmt|;
while|while
condition|(
name|addr
operator|<
name|va_next
condition|)
block|{
name|pt_entry_t
name|ptetemp
decl_stmt|;
name|ptetemp
operator|=
operator|*
name|src_pte
expr_stmt|;
comment|/* 			 * we only virtual copy managed pages 			 */
if|if
condition|(
operator|(
name|ptetemp
operator|&
name|PG_MANAGED
operator|)
operator|!=
literal|0
condition|)
block|{
name|dstmpte
operator|=
name|pmap_allocpte
argument_list|(
name|dst_pmap
argument_list|,
name|addr
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstmpte
operator|==
name|NULL
condition|)
break|break;
name|dst_pte
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|dstmpte
argument_list|)
argument_list|)
expr_stmt|;
name|dst_pte
operator|=
operator|&
name|dst_pte
index|[
name|pmap_pte_index
argument_list|(
name|addr
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|dst_pte
operator|==
literal|0
operator|&&
name|pmap_try_insert_pv_entry
argument_list|(
name|dst_pmap
argument_list|,
name|addr
argument_list|,
name|PHYS_TO_VM_PAGE
argument_list|(
name|ptetemp
operator|&
name|PG_FRAME
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 					 * Clear the wired, modified, and 					 * accessed (referenced) bits 					 * during the copy. 					 */
operator|*
name|dst_pte
operator|=
name|ptetemp
operator|&
operator|~
operator|(
name|PG_W
operator||
name|PG_M
operator||
name|PG_A
operator|)
expr_stmt|;
name|dst_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|free
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pmap_unwire_pte_hold
argument_list|(
name|dst_pmap
argument_list|,
name|addr
argument_list|,
name|dstmpte
argument_list|,
operator|&
name|free
argument_list|)
condition|)
block|{
name|pmap_invalidate_page
argument_list|(
name|dst_pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|pmap_free_zero_pages
argument_list|(
name|free
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dstmpte
operator|->
name|wire_count
operator|>=
name|srcmpte
operator|->
name|wire_count
condition|)
break|break;
block|}
name|addr
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|src_pte
operator|++
expr_stmt|;
block|}
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|src_pmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|dst_pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page zeros the specified hardware page by mapping   *	the page into KVM and using bzero to clear its contents.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
name|pagezero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_area zeros the specified hardware page by mapping   *	the page into KVM and using bzero to clear its contents.  *  *	off and size may not cover an area beyond a single hardware page.  */
end_comment

begin_function
name|void
name|pmap_zero_page_area
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
operator|&&
name|size
operator|==
name|PAGE_SIZE
condition|)
name|pagezero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|va
argument_list|)
expr_stmt|;
else|else
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|va
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_idle zeros the specified hardware page by mapping   *	the page into KVM and using bzero to clear its contents.  This  *	is intended to be called from the vm_pagezero process only and  *	outside of Giant.  */
end_comment

begin_function
name|void
name|pmap_zero_page_idle
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
name|pagezero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_copy_page copies the specified (machine independent)  *	page by mapping the page into virtual memory and using  *	bcopy to copy the page, one machine dependent page at a  *	time.  */
end_comment

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|vm_page_t
name|msrc
parameter_list|,
name|vm_page_t
name|mdst
parameter_list|)
block|{
name|vm_offset_t
name|src
init|=
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|msrc
argument_list|)
argument_list|)
decl_stmt|;
name|vm_offset_t
name|dst
init|=
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|mdst
argument_list|)
argument_list|)
decl_stmt|;
name|pagecopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|src
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the pmap's pv is one of the first  * 16 pvs linked to from this page.  This count may  * be changed upwards or downwards in the future; it  * is only necessary that true be returned for a small  * subset of pmaps for proper page aging.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_exists_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|loops
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return
name|FALSE
return|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
operator|==
name|pmap
condition|)
block|{
return|return
name|TRUE
return|;
block|}
name|loops
operator|++
expr_stmt|;
if|if
condition|(
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove all pages from specified address space  * this aids process exit speeds.  Also, this code  * is special cased for current process only, but  * can have the more generic (and slightly slower)  * mode enabled.  This is much faster than pmap_remove  * in the case of running down an entire address space.  */
end_comment

begin_function
name|void
name|pmap_remove_pages
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
name|free
init|=
name|NULL
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|,
modifier|*
name|npc
decl_stmt|;
name|int
name|field
decl_stmt|,
name|idx
decl_stmt|;
name|int64_t
name|bit
decl_stmt|;
name|uint64_t
name|inuse
decl_stmt|,
name|bitmask
decl_stmt|;
name|int
name|allfree
decl_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|vmspace_pmap
argument_list|(
name|curthread
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"warning: pmap_remove_pages called with non-current pmap\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|pc
argument_list|,
argument|&pmap->pm_pvchunk
argument_list|,
argument|pc_list
argument_list|,
argument|npc
argument_list|)
block|{
name|allfree
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
block|{
name|inuse
operator|=
operator|(
operator|~
operator|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|)
operator|)
operator|&
name|pc_freemask
index|[
name|field
index|]
expr_stmt|;
while|while
condition|(
name|inuse
operator|!=
literal|0
condition|)
block|{
name|bit
operator|=
name|bsfq
argument_list|(
name|inuse
argument_list|)
expr_stmt|;
name|bitmask
operator|=
literal|1UL
operator|<<
name|bit
expr_stmt|;
name|idx
operator|=
name|field
operator|*
literal|64
operator|+
name|bit
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
name|idx
index|]
expr_stmt|;
name|inuse
operator|&=
operator|~
name|bitmask
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|tpte
operator|=
operator|*
name|pte
expr_stmt|;
if|if
condition|(
name|tpte
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"TPTE at %p  IS ZERO @ VA %08lx\n"
argument_list|,
name|pte
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"bad pte"
argument_list|)
expr_stmt|;
block|}
comment|/*  * We cannot remove wired pages from a process' mapping at this time  */
if|if
condition|(
name|tpte
operator|&
name|PG_W
condition|)
block|{
name|allfree
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|tpte
operator|&
name|PG_FRAME
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|phys_addr
operator|==
operator|(
name|tpte
operator|&
name|PG_FRAME
operator|)
argument_list|,
operator|(
literal|"vm_page_t %p phys_addr mismatch %016jx %016jx"
operator|,
name|m
operator|,
operator|(
name|uintmax_t
operator|)
name|m
operator|->
name|phys_addr
operator|,
operator|(
name|uintmax_t
operator|)
name|tpte
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|<
operator|&
name|vm_page_array
index|[
name|vm_page_array_size
index|]
argument_list|,
operator|(
literal|"pmap_remove_pages: bad tpte %#jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|tpte
operator|)
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|pte_clear
argument_list|(
name|pte
argument_list|)
expr_stmt|;
comment|/* 				 * Update the vm_page_t clean/reference bits. 				 */
if|if
condition|(
name|tpte
operator|&
name|PG_M
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Mark free */
name|PV_STAT
argument_list|(
name|pv_entry_frees
operator|++
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|++
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|--
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator||=
name|bitmask
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|*
name|vtopde
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
argument_list|,
operator|&
name|free
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allfree
condition|)
block|{
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|-=
name|_NPCPV
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_count
operator|--
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_frees
operator|++
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|DMAP_TO_PHYS
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|dump_drop_page
argument_list|(
name|m
operator|->
name|phys_addr
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|pmap_invalidate_all
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap_free_zero_pages
argument_list|(
name|free
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_modified:  *  *	Return whether or not the specified physical page was modified  *	in any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|rv
operator|=
operator|(
operator|*
name|pte
operator|&
name|PG_M
operator|)
operator|!=
literal|0
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
break|break;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_prefaultable:  *  *	Return whether or not the specified virtual address is elgible  *	for prefault.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_prefaultable
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|pde
operator|&
name|PG_V
operator|)
condition|)
block|{
name|pte
operator|=
name|vtopte
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|rv
operator|=
operator|(
operator|*
name|pte
operator|&
name|PG_V
operator|)
operator|==
literal|0
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the write and modified bits in each of the given page's mappings.  */
end_comment

begin_function
name|void
name|pmap_remove_write
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pt_entry_t
name|oldpte
decl_stmt|,
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|retry
label|:
name|oldpte
operator|=
operator|*
name|pte
expr_stmt|;
if|if
condition|(
name|oldpte
operator|&
name|PG_RW
condition|)
block|{
if|if
condition|(
operator|!
name|atomic_cmpset_long
argument_list|(
name|pte
argument_list|,
name|oldpte
argument_list|,
name|oldpte
operator|&
operator|~
operator|(
name|PG_RW
operator||
name|PG_M
operator|)
argument_list|)
condition|)
goto|goto
name|retry
goto|;
if|if
condition|(
operator|(
name|oldpte
operator|&
name|PG_M
operator|)
operator|!=
literal|0
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_ts_referenced:  *  *	Return a count of reference bits for a page, clearing those bits.  *	It is not necessary for every reference bit to be cleared, but it  *	is necessary that 0 only be returned when there are truly no  *	reference bits set.  *  *	XXX: The exact number of bits to check and clear is a matter that  *	should be tested and standardized at some point in the future for  *	optimal aging of shared pages.  */
end_comment

begin_function
name|int
name|pmap_ts_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|,
name|pvf
decl_stmt|,
name|pvn
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|int
name|rtval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return
operator|(
name|rtval
operator|)
return|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pvf
operator|=
name|pv
expr_stmt|;
do|do
block|{
name|pvn
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pte
operator|&
name|PG_A
operator|)
operator|!=
literal|0
condition|)
block|{
name|atomic_clear_long
argument_list|(
name|pte
argument_list|,
name|PG_A
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|rtval
operator|++
expr_stmt|;
if|if
condition|(
name|rtval
operator|>
literal|4
condition|)
name|pvn
operator|=
name|NULL
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|pv
operator|=
name|pvn
operator|)
operator|!=
name|NULL
operator|&&
name|pv
operator|!=
name|pvf
condition|)
do|;
block|}
return|return
operator|(
name|rtval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Clear the modify bits on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
condition|)
return|return;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pte
operator|&
name|PG_M
condition|)
block|{
name|atomic_clear_long
argument_list|(
name|pte
argument_list|,
name|PG_M
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	pmap_clear_reference:  *  *	Clear the reference bit on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_reference
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
condition|)
return|return;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pte
operator|&
name|PG_A
condition|)
block|{
name|atomic_clear_long
argument_list|(
name|pte
argument_list|,
name|PG_A
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Miscellaneous support routines follow  */
end_comment

begin_comment
comment|/* Adjust the cache mode for a 4KB page mapped via a PTE. */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pmap_pte_attr
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|u_int
name|opte
decl_stmt|,
name|npte
decl_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * The cache mode bits are all in the low 32-bits of the 	 * PTE, so we can just spin on updating the low 32-bits. 	 */
do|do
block|{
name|opte
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|pte
expr_stmt|;
name|npte
operator|=
name|opte
operator|&
operator|~
operator|(
name|PG_PTE_PAT
operator||
name|PG_NC_PCD
operator||
name|PG_NC_PWT
operator|)
expr_stmt|;
name|npte
operator||=
name|pmap_cache_bits
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|npte
operator|!=
name|opte
operator|&&
operator|!
name|atomic_cmpset_int
argument_list|(
operator|(
name|u_int
operator|*
operator|)
name|pte
argument_list|,
name|opte
argument_list|,
name|npte
argument_list|)
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Adjust the cache mode for a 2MB page mapped via a PDE. */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pmap_pde_attr
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|u_int
name|opde
decl_stmt|,
name|npde
decl_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * The cache mode bits are all in the low 32-bits of the 	 * PDE, so we can just spin on updating the low 32-bits. 	 */
do|do
block|{
name|opde
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|pde
expr_stmt|;
name|npde
operator|=
name|opde
operator|&
operator|~
operator|(
name|PG_PDE_PAT
operator||
name|PG_NC_PCD
operator||
name|PG_NC_PWT
operator|)
expr_stmt|;
name|npde
operator||=
name|pmap_cache_bits
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|npde
operator|!=
name|opde
operator|&&
operator|!
name|atomic_cmpset_int
argument_list|(
operator|(
name|u_int
operator|*
operator|)
name|pde
argument_list|,
name|opde
argument_list|,
name|npde
argument_list|)
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Map a set of physical memory pages into the kernel virtual  * address space. Return a pointer to where it is mapped. This  * routine is intended to be used for mapping device memory,  * NOT real memory.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_mapdev_attr
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|,
name|tmpva
decl_stmt|,
name|offset
decl_stmt|;
comment|/* 	 * If this fits within the direct map window and use WB caching 	 * mode, use the direct map. 	 */
if|if
condition|(
name|pa
operator|<
name|dmaplimit
operator|&&
operator|(
name|pa
operator|+
name|size
operator|)
operator|<
name|dmaplimit
operator|&&
name|mode
operator|==
name|PAT_WRITE_BACK
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|pa
argument_list|)
operator|)
return|;
name|offset
operator|=
name|pa
operator|&
name|PAGE_MASK
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|offset
operator|+
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|va
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|va
condition|)
name|panic
argument_list|(
literal|"pmap_mapdev: Couldn't alloc kernel virtual memory"
argument_list|)
expr_stmt|;
name|pa
operator|=
name|trunc_page
argument_list|(
name|pa
argument_list|)
expr_stmt|;
for|for
control|(
name|tmpva
operator|=
name|va
init|;
name|size
operator|>
literal|0
condition|;
control|)
block|{
name|pmap_kenter_attr
argument_list|(
name|tmpva
argument_list|,
name|pa
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|size
operator|-=
name|PAGE_SIZE
expr_stmt|;
name|tmpva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|pmap_invalidate_range
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|,
name|tmpva
argument_list|)
expr_stmt|;
name|pmap_invalidate_cache
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|va
operator|+
name|offset
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|pmap_mapdev
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|pmap_mapdev_attr
argument_list|(
name|pa
argument_list|,
name|size
argument_list|,
name|PAT_UNCACHEABLE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|pmap_mapbios
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|pmap_mapdev_attr
argument_list|(
name|pa
argument_list|,
name|size
argument_list|,
name|PAT_WRITE_BACK
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_unmapdev
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_offset_t
name|base
decl_stmt|,
name|offset
decl_stmt|,
name|tmpva
decl_stmt|;
comment|/* If we gave a direct map region in pmap_mapdev, do nothing */
if|if
condition|(
name|va
operator|>=
name|DMAP_MIN_ADDRESS
operator|&&
name|va
operator|<
name|DMAP_MAX_ADDRESS
condition|)
return|return;
name|base
operator|=
name|trunc_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|offset
operator|=
name|va
operator|&
name|PAGE_MASK
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|offset
operator|+
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|tmpva
operator|=
name|base
init|;
name|tmpva
operator|<
operator|(
name|base
operator|+
name|size
operator|)
condition|;
name|tmpva
operator|+=
name|PAGE_SIZE
control|)
name|pmap_kremove
argument_list|(
name|tmpva
argument_list|)
expr_stmt|;
name|pmap_invalidate_range
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|,
name|tmpva
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pmap_change_attr
parameter_list|(
name|va
parameter_list|,
name|size
parameter_list|,
name|mode
parameter_list|)
name|vm_offset_t
name|va
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|vm_offset_t
name|base
decl_stmt|,
name|offset
decl_stmt|,
name|tmpva
decl_stmt|;
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|base
operator|=
name|trunc_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|offset
operator|=
name|va
operator|&
name|PAGE_MASK
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|offset
operator|+
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* Only supported on kernel virtual addresses. */
if|if
condition|(
name|base
operator|<=
name|VM_MAXUSER_ADDRESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * XXX: We have to support tearing 2MB pages down into 4k pages if 	 * needed here. 	 */
comment|/* Pages that aren't mapped aren't supported. */
for|for
control|(
name|tmpva
operator|=
name|base
init|;
name|tmpva
operator|<
operator|(
name|base
operator|+
name|size
operator|)
condition|;
control|)
block|{
name|pde
operator|=
name|pmap_pde
argument_list|(
name|kernel_pmap
argument_list|,
name|tmpva
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pde
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|*
name|pde
operator|&
name|PG_PS
condition|)
block|{
comment|/* Handle 2MB pages that are completely contained. */
if|if
condition|(
name|size
operator|>=
name|NBPDR
condition|)
block|{
name|tmpva
operator|+=
name|NBPDR
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pte
operator|=
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pte
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tmpva
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
comment|/* 	 * Ok, all the pages exist, so run through them updating their 	 * cache mode. 	 */
for|for
control|(
name|tmpva
operator|=
name|base
init|;
name|size
operator|>
literal|0
condition|;
control|)
block|{
name|pde
operator|=
name|pmap_pde
argument_list|(
name|kernel_pmap
argument_list|,
name|tmpva
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pde
operator|&
name|PG_PS
condition|)
block|{
name|pmap_pde_attr
argument_list|(
name|tmpva
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|tmpva
operator|+=
name|NBPDR
expr_stmt|;
name|size
operator|-=
name|NBPDR
expr_stmt|;
block|}
else|else
block|{
name|pmap_pte_attr
argument_list|(
name|tmpva
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|tmpva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|size
operator|-=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
comment|/* 	 * Flush CPU caches to make sure any data isn't cached that shouldn't 	 * be, etc. 	 */
name|pmap_invalidate_range
argument_list|(
name|kernel_pmap
argument_list|,
name|base
argument_list|,
name|tmpva
argument_list|)
expr_stmt|;
name|pmap_invalidate_cache
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * perform the pmap work for mincore  */
end_comment

begin_function
name|int
name|pmap_mincore
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|ptep
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|pte
operator|=
operator|(
name|ptep
operator|!=
name|NULL
operator|)
condition|?
operator|*
name|ptep
else|:
literal|0
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
literal|0
condition|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|val
operator|=
name|MINCORE_INCORE
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|&
name|PG_MANAGED
operator|)
operator|==
literal|0
condition|)
return|return
name|val
return|;
name|pa
operator|=
name|pte
operator|&
name|PG_FRAME
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
comment|/* 		 * Modified by us 		 */
if|if
condition|(
name|pte
operator|&
name|PG_M
condition|)
name|val
operator||=
name|MINCORE_MODIFIED
operator||
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
else|else
block|{
comment|/* 			 * Modified by someone else 			 */
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|dirty
operator|||
name|pmap_is_modified
argument_list|(
name|m
argument_list|)
condition|)
name|val
operator||=
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * Referenced by us 		 */
if|if
condition|(
name|pte
operator|&
name|PG_A
condition|)
name|val
operator||=
name|MINCORE_REFERENCED
operator||
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
else|else
block|{
comment|/* 			 * Referenced by someone else 			 */
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_REFERENCED
operator|)
operator|||
name|pmap_ts_referenced
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|val
operator||=
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
name|void
name|pmap_activate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|pmap_t
name|pmap
decl_stmt|,
name|oldpmap
decl_stmt|;
name|u_int64_t
name|cr3
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|pmap
operator|=
name|vmspace_pmap
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|PCPU_GET
argument_list|(
name|curpmap
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|oldpmap
condition|)
comment|/* XXX FIXME */
name|atomic_clear_int
argument_list|(
operator|&
name|oldpmap
operator|->
name|pm_active
argument_list|,
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|pmap
operator|->
name|pm_active
argument_list|,
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|oldpmap
condition|)
comment|/* XXX FIXME */
name|oldpmap
operator|->
name|pm_active
operator|&=
operator|~
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_active
operator||=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cr3
operator|=
name|vtophys
argument_list|(
name|pmap
operator|->
name|pm_pml4
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_cr3
operator|=
name|cr3
expr_stmt|;
name|load_cr3
argument_list|(
name|cr3
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_addr_hint
parameter_list|(
name|vm_object_t
name|obj
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
if|if
condition|(
operator|(
name|obj
operator|==
name|NULL
operator|)
operator|||
operator|(
name|size
operator|<
name|NBPDR
operator|)
operator|||
operator|(
name|obj
operator|->
name|type
operator|!=
name|OBJT_DEVICE
operator|)
condition|)
block|{
return|return
name|addr
return|;
block|}
name|addr
operator|=
operator|(
name|addr
operator|+
operator|(
name|NBPDR
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|NBPDR
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

end_unit

