begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  * Copyright (c) 1994 John S. Dyson  * All rights reserved.  * Copyright (c) 1994 David Greenman  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and William Jolitz of UUNET Technologies Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from:	@(#)pmap.c	7.7 (Berkeley)	5/12/91  *	$Id: pmap.c,v 1.147 1997/06/25 20:07:50 tegge Exp $  */
end_comment

begin_comment
comment|/*  *	Manages physical address maps.  *  *	In addition to hardware address maps, this  *	module is called upon to provide software-use-only  *	maps which may or may not be stored in the same  *	form as hardware maps.  These pseudo-maps are  *	used to store intermediate results from copy  *	operations to and from address spaces.  *  *	Since the information managed by this module is  *	also stored by the logical address mapping module,  *	this module may throw away valid virtual-to-physical  *	mappings at almost any time.  However, invalidations  *	of virtual-to-physical mappings must be done as  *	requested.  *  *	In order to cope with hardware architectures which  *	make virtual-to-physical map invalidates expensive,  *	this module may delay invalidate or reduced protection  *	operations until such time as they are actually  *	necessary.  This module is given full information as  *	to which processors are currently using which maps,  *	and to when physical maps must be made correct.  */
end_comment

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_define
define|#
directive|define
name|PMAP_LOCK
value|1
end_define

begin_define
define|#
directive|define
name|PMAP_PVLIST
value|1
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/cputypes.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SMP
argument_list|)
operator|||
name|defined
argument_list|(
name|APIC_IO
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/apic.h>
end_include

begin_include
include|#
directive|include
file|<machine/smptests.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP || APIC_IO */
end_comment

begin_define
define|#
directive|define
name|PMAP_KEEP_PDIRS
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PMAP_SHPGPERPROC
end_ifndef

begin_define
define|#
directive|define
name|PMAP_SHPGPERPROC
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
end_if

begin_define
define|#
directive|define
name|PMAP_DIAGNOSTIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PMAP_DIAGNOSTIC
argument_list|)
end_if

begin_define
define|#
directive|define
name|PMAP_INLINE
value|__inline
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PMAP_INLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PTPHINT
end_define

begin_decl_stmt
specifier|static
name|void
name|init_pv_entries
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get PDEs and PTEs for user/kernel address space  */
end_comment

begin_define
define|#
directive|define
name|pmap_pde
parameter_list|(
name|m
parameter_list|,
name|v
parameter_list|)
value|(&((m)->pm_pdir[(vm_offset_t)(v)>> PDRSHIFT]))
end_define

begin_define
define|#
directive|define
name|pdir_pde
parameter_list|(
name|m
parameter_list|,
name|v
parameter_list|)
value|(m[(vm_offset_t)(v)>> PDRSHIFT])
end_define

begin_define
define|#
directive|define
name|pmap_pde_v
parameter_list|(
name|pte
parameter_list|)
value|((*(int *)pte& PG_V) != 0)
end_define

begin_define
define|#
directive|define
name|pmap_pte_w
parameter_list|(
name|pte
parameter_list|)
value|((*(int *)pte& PG_W) != 0)
end_define

begin_define
define|#
directive|define
name|pmap_pte_m
parameter_list|(
name|pte
parameter_list|)
value|((*(int *)pte& PG_M) != 0)
end_define

begin_define
define|#
directive|define
name|pmap_pte_u
parameter_list|(
name|pte
parameter_list|)
value|((*(int *)pte& PG_A) != 0)
end_define

begin_define
define|#
directive|define
name|pmap_pte_v
parameter_list|(
name|pte
parameter_list|)
value|((*(int *)pte& PG_V) != 0)
end_define

begin_define
define|#
directive|define
name|pmap_pte_set_w
parameter_list|(
name|pte
parameter_list|,
name|v
parameter_list|)
value|((v)?(*(int *)pte |= PG_W):(*(int *)pte&= ~PG_W))
end_define

begin_define
define|#
directive|define
name|pmap_pte_set_prot
parameter_list|(
name|pte
parameter_list|,
name|v
parameter_list|)
value|((*(int *)pte&= ~PG_PROT), (*(int *)pte |= (v)))
end_define

begin_comment
comment|/*  * Given a map and a machine independent protection code,  * convert to a vax protection code.  */
end_comment

begin_define
define|#
directive|define
name|pte_prot
parameter_list|(
name|m
parameter_list|,
name|p
parameter_list|)
value|(protection_codes[p])
end_define

begin_decl_stmt
specifier|static
name|int
name|protection_codes
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|pa_index
parameter_list|(
name|pa
parameter_list|)
value|atop((pa) - vm_first_phys)
end_define

begin_define
define|#
directive|define
name|pa_to_pvh
parameter_list|(
name|pa
parameter_list|)
value|(&pv_table[pa_index(pa)])
end_define

begin_decl_stmt
specifier|static
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pmap_t
name|kernel_pmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|avail_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA of first available physical page */
end_comment

begin_decl_stmt
name|vm_offset_t
name|avail_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA of last available physical page */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of first avail page (after kernel bss) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of last avail page (end of kernel AS) */
end_comment

begin_decl_stmt
specifier|static
name|boolean_t
name|pmap_initialized
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Has pmap_init completed? */
end_comment

begin_decl_stmt
specifier|static
name|vm_offset_t
name|vm_first_phys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pgeflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PG_G or-in */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pseflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PG_PS or-in */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nkpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_page_t
name|nkpg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|kernel_vm_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|vm_offset_t
name|clean_sva
decl_stmt|,
name|clean_eva
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PV_FREELIST_MIN
value|((PAGE_SIZE / sizeof (struct pv_entry)) / 2)
end_define

begin_comment
comment|/*  * Data for the pv entry allocation mechanism  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pv_freelistcnt
decl_stmt|;
end_decl_stmt

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pv_entry
argument_list|)
end_macro

begin_expr_stmt
name|pv_freelist
operator|=
block|{
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|pvva
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|npvvapg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * All those kernel PT submaps that BSD is so fond of  */
end_comment

begin_decl_stmt
name|pt_entry_t
modifier|*
name|CMAP1
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pt_entry_t
modifier|*
name|CMAP2
decl_stmt|,
modifier|*
name|ptmmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pv_table_t
modifier|*
name|pv_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|CADDR1
init|=
literal|0
decl_stmt|,
name|ptvmmap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|caddr_t
name|CADDR2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pt_entry_t
modifier|*
name|msgbufmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|msgbuf
modifier|*
name|msgbufp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
modifier|*
name|PMAP1
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
modifier|*
name|PADDR1
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PMAP_INLINE
name|void
name|free_pv_entry
name|__P
argument_list|(
operator|(
name|pv_entry_t
name|pv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
modifier|*
name|get_ptbase
name|__P
argument_list|(
operator|(
name|pmap_t
name|pmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pv_entry_t
name|get_pv_entry
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|i386_protection_init
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pmap_alloc_pv_entry
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pmap_changebit
name|__P
argument_list|(
operator|(
name|vm_offset_t
name|pa
operator|,
name|int
name|bit
operator|,
name|boolean_t
name|setem
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PMAP_INLINE
name|int
name|pmap_is_managed
name|__P
argument_list|(
operator|(
name|vm_offset_t
name|pa
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pmap_remove_all
name|__P
argument_list|(
operator|(
name|vm_offset_t
name|pa
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_page_t
name|pmap_enter_quick
name|__P
argument_list|(
operator|(
name|pmap_t
name|pmap
operator|,
name|vm_offset_t
name|va
operator|,
name|vm_offset_t
name|pa
operator|,
name|vm_page_t
name|mpte
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_remove_pte
name|__P
argument_list|(
operator|(
expr|struct
name|pmap
operator|*
name|pmap
operator|,
name|unsigned
operator|*
name|ptq
operator|,
name|vm_offset_t
name|sva
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pmap_remove_page
name|__P
argument_list|(
operator|(
expr|struct
name|pmap
operator|*
name|pmap
operator|,
name|vm_offset_t
name|va
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_remove_entry
name|__P
argument_list|(
operator|(
expr|struct
name|pmap
operator|*
name|pmap
operator|,
name|pv_table_t
operator|*
name|pv
operator|,
name|vm_offset_t
name|va
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean_t
name|pmap_testbit
name|__P
argument_list|(
operator|(
name|vm_offset_t
name|pa
operator|,
name|int
name|bit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pmap_insert_entry
name|__P
argument_list|(
operator|(
name|pmap_t
name|pmap
operator|,
name|vm_offset_t
name|va
operator|,
name|vm_page_t
name|mpte
operator|,
name|vm_offset_t
name|pa
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_page_t
name|pmap_allocpte
name|__P
argument_list|(
operator|(
name|pmap_t
name|pmap
operator|,
name|vm_offset_t
name|va
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_release_free_page
name|__P
argument_list|(
operator|(
name|pmap_t
name|pmap
operator|,
name|vm_page_t
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_page_t
name|_pmap_allocpte
name|__P
argument_list|(
operator|(
name|pmap_t
name|pmap
operator|,
name|unsigned
name|ptepindex
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
modifier|*
name|pmap_pte_quick
name|__P
argument_list|(
operator|(
name|pmap_t
name|pmap
operator|,
name|vm_offset_t
name|va
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_page_t
name|pmap_page_alloc
name|__P
argument_list|(
operator|(
name|vm_object_t
name|object
operator|,
name|vm_pindex_t
name|pindex
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_page_t
name|pmap_page_lookup
name|__P
argument_list|(
operator|(
name|vm_object_t
name|object
operator|,
name|vm_pindex_t
name|pindex
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_unuse_pt
name|__P
argument_list|(
operator|(
name|pmap_t
operator|,
name|vm_offset_t
operator|,
name|vm_page_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|vm_offset_t
name|pmap_kmem_choose
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|PDSTACKMAX
value|6
end_define

begin_decl_stmt
specifier|static
name|vm_offset_t
name|pdstack
index|[
name|PDSTACKMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pdstackptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pdir4mb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Routine:	pmap_pte  *	Function:  *		Extract the page table entry associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
name|PMAP_INLINE
name|unsigned
modifier|*
name|pmap_pte
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
block|{
if|if
condition|(
name|pmap
operator|&&
operator|*
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
condition|)
block|{
return|return
name|get_ptbase
argument_list|(
name|pmap
argument_list|)
operator|+
name|i386_btop
argument_list|(
name|va
argument_list|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move the kernel virtual free pointer to the next  * 4MB.  This is used to help improve performance  * by using a large (4MB) page for much of the kernel  * (.text, .data, .bss)  */
end_comment

begin_function
name|vm_offset_t
name|pmap_kmem_choose
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|vm_offset_t
name|newaddr
init|=
name|addr
decl_stmt|;
if|if
condition|(
name|cpu_feature
operator|&
name|CPUID_PSE
condition|)
block|{
name|newaddr
operator|=
operator|(
name|addr
operator|+
operator|(
name|NBPDR
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|NBPDR
operator|-
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|newaddr
return|;
block|}
end_function

begin_comment
comment|/*  *	Bootstrap the system enough to run with virtual memory.  *  *	On the i386 this is called after mapping has already been enabled  *	and just syncs the pmap module with what has already been done.  *	[We can't call it easily with mapping off since the kernel is not  *	mapped with PA == VA, hence we would have to relocate every address  *	from the linked base (virtual) address "KERNBASE" to the actual  *	(physical) address starting relative to 0]  */
end_comment

begin_function
name|void
name|pmap_bootstrap
parameter_list|(
name|firstaddr
parameter_list|,
name|loadaddr
parameter_list|)
name|vm_offset_t
name|firstaddr
decl_stmt|;
name|vm_offset_t
name|loadaddr
decl_stmt|;
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|avail_start
operator|=
name|firstaddr
expr_stmt|;
comment|/* 	 * XXX The calculation of virtual_avail is wrong. It's NKPT*PAGE_SIZE too 	 * large. It should instead be correctly calculated in locore.s and 	 * not based on 'first' (which is a physical address, not a virtual 	 * address, for the start of unused physical memory). The kernel 	 * page tables are NOT double mapped and thus should not be included 	 * in this calculation. 	 */
name|virtual_avail
operator|=
operator|(
name|vm_offset_t
operator|)
name|KERNBASE
operator|+
name|firstaddr
expr_stmt|;
name|virtual_avail
operator|=
name|pmap_kmem_choose
argument_list|(
name|virtual_avail
argument_list|)
expr_stmt|;
name|virtual_end
operator|=
name|VM_MAX_KERNEL_ADDRESS
expr_stmt|;
comment|/* 	 * Initialize protection array. 	 */
name|i386_protection_init
argument_list|()
expr_stmt|;
comment|/* 	 * The kernel's pmap is statically allocated so we don't have to use 	 * pmap_create, which is unlikely to work correctly at this part of 	 * the boot sequence (XXX and which no longer exists). 	 */
name|kernel_pmap
operator|=
operator|&
name|kernel_pmap_store
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_pdir
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
operator|(
name|KERNBASE
operator|+
operator|(
name|u_int
operator|)
name|IdlePTD
operator|)
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_count
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|PMAP_PVLIST
name|TAILQ_INIT
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nkpt
operator|=
name|NKPT
expr_stmt|;
comment|/* 	 * Reserve some special page table entries/VA space for temporary 	 * mapping of pages. 	 */
define|#
directive|define
name|SYSMAP
parameter_list|(
name|c
parameter_list|,
name|p
parameter_list|,
name|v
parameter_list|,
name|n
parameter_list|)
define|\
value|v = (c)va; va += ((n)*PAGE_SIZE); p = pte; pte += (n);
name|va
operator|=
name|virtual_avail
expr_stmt|;
name|pte
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * CMAP1/CMAP2 are used for zeroing and copying pages. 	 */
name|SYSMAP
argument_list|(
argument|caddr_t
argument_list|,
argument|CMAP1
argument_list|,
argument|CADDR1
argument_list|,
literal|1
argument_list|)
name|SYSMAP
argument_list|(
argument|caddr_t
argument_list|,
argument|CMAP2
argument_list|,
argument|CADDR2
argument_list|,
literal|1
argument_list|)
comment|/* 	 * ptvmmap is used for reading arbitrary physical pages via /dev/mem. 	 * XXX ptmmap is not used. 	 */
name|SYSMAP
argument_list|(
argument|caddr_t
argument_list|,
argument|ptmmap
argument_list|,
argument|ptvmmap
argument_list|,
literal|1
argument_list|)
comment|/* 	 * msgbufp is used to map the system message buffer. 	 * XXX msgbufmap is not used. 	 */
name|SYSMAP
argument_list|(
argument|struct msgbuf *
argument_list|,
argument|msgbufmap
argument_list|,
argument|msgbufp
argument_list|,
argument|atop(round_page(sizeof(struct msgbuf)))
argument_list|)
comment|/* 	 * ptemap is used for pmap_pte_quick 	 */
name|SYSMAP
argument_list|(
name|unsigned
operator|*
argument_list|,
name|PMAP1
argument_list|,
name|PADDR1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|virtual_avail
operator|=
name|va
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|CMAP1
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|CMAP2
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|PTD
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|cpu_apic_address
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: no local apic!"
argument_list|)
expr_stmt|;
comment|/* 0 = private page */
comment|/* 1 = page table page */
comment|/* 2 = local apic */
comment|/* 16-31 = io apics */
name|SMP_prvpt
index|[
literal|2
index|]
operator|=
name|PG_V
operator||
name|PG_RW
operator||
operator|(
operator|(
name|u_long
operator|)
name|cpu_apic_address
operator|&
name|PG_FRAME
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_napics
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
comment|/* same page frame as a previous IO apic? */
if|if
condition|(
operator|(
operator|(
name|u_long
operator|)
name|SMP_prvpt
index|[
name|j
operator|+
literal|16
index|]
operator|&
name|PG_FRAME
operator|)
operator|==
operator|(
operator|(
name|u_long
operator|)
name|io_apic_address
index|[
literal|0
index|]
operator|&
name|PG_FRAME
operator|)
condition|)
block|{
name|ioapic
index|[
name|i
index|]
operator|=
operator|(
name|ioapic_t
operator|*
operator|)
operator|&
name|SMP_ioapic
index|[
name|j
operator|*
name|PAGE_SIZE
index|]
expr_stmt|;
break|break;
block|}
comment|/* use this slot if available */
if|if
condition|(
operator|(
operator|(
name|u_long
operator|)
name|SMP_prvpt
index|[
name|j
operator|+
literal|16
index|]
operator|&
name|PG_FRAME
operator|)
operator|==
literal|0
condition|)
block|{
name|SMP_prvpt
index|[
name|j
operator|+
literal|16
index|]
operator|=
name|PG_V
operator||
name|PG_RW
operator||
operator|(
operator|(
name|u_long
operator|)
name|io_apic_address
index|[
name|i
index|]
operator|&
name|PG_FRAME
operator|)
expr_stmt|;
name|ioapic
index|[
name|i
index|]
operator|=
operator|(
name|ioapic_t
operator|*
operator|)
operator|&
name|SMP_ioapic
index|[
name|j
operator|*
name|PAGE_SIZE
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|j
operator|==
literal|16
condition|)
name|panic
argument_list|(
literal|"no space to map IO apic %d!"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|invltlb
argument_list|()
expr_stmt|;
name|pgeflag
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
if|if
condition|(
name|cpu_feature
operator|&
name|CPUID_PGE
condition|)
name|pgeflag
operator|=
name|PG_G
expr_stmt|;
endif|#
directive|endif
comment|/* !SMP */
comment|/*  * Initialize the 4MB page size flag  */
name|pseflag
operator|=
literal|0
expr_stmt|;
comment|/*  * The 4MB page version of the initial  * kernel page mapping.  */
name|pdir4mb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cpu_feature
operator|&
name|CPUID_PSE
condition|)
block|{
name|unsigned
name|ptditmp
decl_stmt|;
comment|/* 		 * Enable the PSE mode 		 */
name|load_cr4
argument_list|(
name|rcr4
argument_list|()
operator||
name|CR4_PSE
argument_list|)
expr_stmt|;
comment|/* 		 * Note that we have enabled PSE mode 		 */
name|pseflag
operator|=
name|PG_PS
expr_stmt|;
name|ptditmp
operator|=
operator|(
name|unsigned
operator|)
name|kernel_pmap
operator|->
name|pm_pdir
index|[
name|KPTDI
index|]
expr_stmt|;
name|ptditmp
operator|&=
operator|~
operator|(
name|NBPDR
operator|-
literal|1
operator|)
expr_stmt|;
name|ptditmp
operator||=
name|PG_V
operator||
name|PG_RW
operator||
name|PG_PS
operator||
name|PG_U
operator||
name|pgeflag
expr_stmt|;
name|pdir4mb
operator|=
name|ptditmp
expr_stmt|;
comment|/* 		 * We can do the mapping here for the single processor 		 * case.  We simply ignore the old page table page from 		 * now on. 		 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
name|PTD
index|[
name|KPTDI
index|]
operator|=
operator|(
name|pd_entry_t
operator|)
name|ptditmp
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_pdir
index|[
name|KPTDI
index|]
operator|=
operator|(
name|pd_entry_t
operator|)
name|ptditmp
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SMP
argument_list|)
end_if

begin_comment
comment|/*  * Set 4mb pdir for mp startup, and global flags  */
end_comment

begin_function
name|void
name|pmap_set_opt
parameter_list|(
name|unsigned
modifier|*
name|pdir
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pseflag
operator|&&
operator|(
name|cpu_feature
operator|&
name|CPUID_PSE
operator|)
condition|)
block|{
name|load_cr4
argument_list|(
name|rcr4
argument_list|()
operator||
name|CR4_PSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdir4mb
condition|)
block|{
operator|(
name|unsigned
operator|)
name|pdir
index|[
name|KPTDI
index|]
operator|=
name|pdir4mb
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cpu_feature
operator|&
name|CPUID_PGE
condition|)
block|{
name|load_cr4
argument_list|(
name|rcr4
argument_list|()
operator||
name|CR4_PGE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|KPTDI
init|;
name|i
operator|<
name|KPTDI
operator|+
name|nkpt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pdir
index|[
name|i
index|]
condition|)
block|{
name|pdir
index|[
name|i
index|]
operator||=
name|PG_G
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Setup the PTD for the boot processor  */
end_comment

begin_function
name|void
name|pmap_set_opt_bsp
parameter_list|(
name|void
parameter_list|)
block|{
name|pmap_set_opt
argument_list|(
operator|(
name|unsigned
operator|*
operator|)
name|kernel_pmap
operator|->
name|pm_pdir
argument_list|)
expr_stmt|;
name|pmap_set_opt
argument_list|(
operator|(
name|unsigned
operator|*
operator|)
name|PTD
argument_list|)
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	Initialize the pmap module.  *	Called by vm_init, to initialize any structures that the pmap  *	system needs to map virtual memory.  *	pmap_init has been enhanced to support in a fairly consistant  *	way, discontiguous physical memory.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|phys_start
parameter_list|,
name|phys_end
parameter_list|)
name|vm_offset_t
name|phys_start
decl_stmt|,
name|phys_end
decl_stmt|;
block|{
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_size_t
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|npg
decl_stmt|;
comment|/* 	 * calculate the number of pv_entries needed 	 */
name|vm_first_phys
operator|=
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|+=
literal|2
control|)
empty_stmt|;
name|npg
operator|=
operator|(
name|phys_avail
index|[
operator|(
name|i
operator|-
literal|2
operator|)
operator|+
literal|1
index|]
operator|-
name|vm_first_phys
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 * Allocate memory for random pmap data structures.  Includes the 	 * pv_head_table. 	 */
name|s
operator|=
call|(
name|vm_size_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|pv_table_t
argument_list|)
operator|*
name|npg
argument_list|)
expr_stmt|;
name|s
operator|=
name|round_page
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|pv_table
operator|=
operator|(
name|pv_table_t
operator|*
operator|)
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npg
condition|;
name|i
operator|++
control|)
block|{
name|vm_offset_t
name|pa
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pv_table
index|[
name|i
index|]
operator|.
name|pv_list
argument_list|)
expr_stmt|;
name|pv_table
index|[
name|i
index|]
operator|.
name|pv_list_count
operator|=
literal|0
expr_stmt|;
name|pa
operator|=
name|vm_first_phys
operator|+
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|pv_table
index|[
name|i
index|]
operator|.
name|pv_vm_page
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|pv_freelist
argument_list|)
expr_stmt|;
comment|/* 	 * init the pv free list 	 */
name|init_pv_entries
argument_list|(
name|npg
argument_list|)
expr_stmt|;
comment|/* 	 * Now it is safe to enable pv_table recording. 	 */
name|pmap_initialized
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Used to map a range of physical addresses into kernel  *	virtual address space.  *  *	For now, VM is already on, we only need to map the  *	specified memory.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|virt
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|prot
parameter_list|)
name|vm_offset_t
name|virt
decl_stmt|;
name|vm_offset_t
name|start
decl_stmt|;
name|vm_offset_t
name|end
decl_stmt|;
name|int
name|prot
decl_stmt|;
block|{
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
name|virt
argument_list|,
name|start
argument_list|,
name|prot
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|virt
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|start
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
return|return
operator|(
name|virt
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * Low level helper routines.....  ***************************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PMAP_DIAGNOSTIC
argument_list|)
end_if

begin_comment
comment|/*  * This code checks for non-writeable/modified pages.  * This should be an invalid condition.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_nw_modified
parameter_list|(
name|pt_entry_t
name|ptea
parameter_list|)
block|{
name|int
name|pte
decl_stmt|;
name|pte
operator|=
operator|(
name|int
operator|)
name|ptea
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|&
operator|(
name|PG_M
operator||
name|PG_RW
operator|)
operator|)
operator|==
name|PG_M
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * this routine defines the region(s) of memory that should  * not be tested for the modified bit.  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|int
name|pmap_track_modified
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
if|if
condition|(
operator|(
name|va
operator|<
name|clean_sva
operator|)
operator|||
operator|(
name|va
operator|>=
name|clean_eva
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|invltlb_1pg
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|I386_CPU
argument_list|)
if|if
condition|(
name|cpu_class
operator|==
name|CPUCLASS_386
condition|)
block|{
name|invltlb
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|invlpg
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|invltlb_2pg
parameter_list|(
name|vm_offset_t
name|va1
parameter_list|,
name|vm_offset_t
name|va2
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|I386_CPU
argument_list|)
if|if
condition|(
name|cpu_class
operator|==
name|CPUCLASS_386
condition|)
block|{
name|invltlb
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|invlpg
argument_list|(
name|va1
argument_list|)
expr_stmt|;
name|invlpg
argument_list|(
name|va2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
modifier|*
name|get_ptbase
parameter_list|(
name|pmap
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
block|{
name|unsigned
name|frame
init|=
operator|(
name|unsigned
operator|)
name|pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
operator|&
name|PG_FRAME
decl_stmt|;
comment|/* are we current address space or kernel? */
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
operator|||
name|frame
operator|==
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|PTDpde
operator|)
operator|&
name|PG_FRAME
operator|)
condition|)
block|{
return|return
operator|(
name|unsigned
operator|*
operator|)
name|PTmap
return|;
block|}
comment|/* otherwise, we are alternate address space */
if|if
condition|(
name|frame
operator|!=
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|APTDpde
operator|)
operator|&
name|PG_FRAME
operator|)
condition|)
block|{
name|APTDpde
operator|=
call|(
name|pd_entry_t
call|)
argument_list|(
name|frame
operator||
name|PG_RW
operator||
name|PG_V
argument_list|)
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|unsigned
operator|*
operator|)
name|APTmap
return|;
block|}
end_function

begin_comment
comment|/*  * Super fast pmap_pte routine best used when scanning  * the pv lists.  This eliminates many coarse-grained  * invltlb calls.  Note that many of the pv list  * scans are across different pmaps.  It is very wasteful  * to do an entire invltlb for checking a single mapping.  */
end_comment

begin_function
specifier|static
name|unsigned
modifier|*
name|pmap_pte_quick
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
block|{
name|unsigned
name|pde
decl_stmt|,
name|newpf
decl_stmt|;
if|if
condition|(
name|pde
operator|=
operator|(
name|unsigned
operator|)
name|pmap
operator|->
name|pm_pdir
index|[
name|va
operator|>>
name|PDRSHIFT
index|]
condition|)
block|{
name|unsigned
name|frame
init|=
operator|(
name|unsigned
operator|)
name|pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
operator|&
name|PG_FRAME
decl_stmt|;
name|unsigned
name|index
init|=
name|i386_btop
argument_list|(
name|va
argument_list|)
decl_stmt|;
comment|/* are we current address space or kernel? */
if|if
condition|(
operator|(
name|pmap
operator|==
name|kernel_pmap
operator|)
operator|||
operator|(
name|frame
operator|==
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|PTDpde
operator|)
operator|&
name|PG_FRAME
operator|)
operator|)
condition|)
block|{
return|return
operator|(
name|unsigned
operator|*
operator|)
name|PTmap
operator|+
name|index
return|;
block|}
name|newpf
operator|=
name|pde
operator|&
name|PG_FRAME
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|PMAP1
operator|)
operator|&
name|PG_FRAME
operator|)
operator|!=
name|newpf
condition|)
block|{
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|PMAP1
operator|=
name|newpf
operator||
name|PG_RW
operator||
name|PG_V
expr_stmt|;
name|invltlb_1pg
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|PADDR1
argument_list|)
expr_stmt|;
block|}
return|return
name|PADDR1
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|index
operator|&
operator|(
name|NPTEPG
operator|-
literal|1
operator|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract  *	Function:  *		Extract the physical page address associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_extract
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
block|{
name|vm_offset_t
name|rtval
decl_stmt|;
name|vm_offset_t
name|pdirindex
decl_stmt|;
name|pdirindex
operator|=
name|va
operator|>>
name|PDRSHIFT
expr_stmt|;
if|if
condition|(
name|pmap
condition|)
block|{
name|unsigned
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|rtval
operator|=
operator|(
name|unsigned
operator|)
name|pmap
operator|->
name|pm_pdir
index|[
name|pdirindex
index|]
operator|)
operator|&
name|PG_PS
operator|)
operator|!=
literal|0
condition|)
block|{
name|rtval
operator|&=
operator|~
operator|(
name|NBPDR
operator|-
literal|1
operator|)
expr_stmt|;
name|rtval
operator||=
name|va
operator|&
operator|(
name|NBPDR
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|rtval
return|;
block|}
name|pte
operator|=
name|get_ptbase
argument_list|(
name|pmap
argument_list|)
operator|+
name|i386_btop
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|rtval
operator|=
operator|(
operator|(
operator|*
name|pte
operator|&
name|PG_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|PAGE_MASK
operator|)
operator|)
expr_stmt|;
return|return
name|rtval
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * determine if a page is managed (memory vs. device)  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|int
name|pmap_is_managed
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_initialized
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|pa
operator|<
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|&&
name|pa
operator|>=
name|phys_avail
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * Low level mapping routines.....  ***************************************************/
end_comment

begin_comment
comment|/*  * Add a list of wired pages to the kva  * this routine is only used for temporary  * kernel mappings that do not need to have  * page modification or references recorded.  * Note that old mappings are simply written  * over.  The page *must* be wired.  */
end_comment

begin_function
name|void
name|pmap_qenter
parameter_list|(
name|va
parameter_list|,
name|m
parameter_list|,
name|count
parameter_list|)
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
modifier|*
name|m
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|pte
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|vm_offset_t
name|tva
init|=
name|va
operator|+
name|i
operator|*
name|PAGE_SIZE
decl_stmt|;
name|unsigned
name|npte
init|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
operator||
name|PG_RW
operator||
name|PG_V
operator||
name|pgeflag
decl_stmt|;
name|unsigned
name|opte
decl_stmt|;
name|pte
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|vtopte
argument_list|(
name|tva
argument_list|)
expr_stmt|;
name|opte
operator|=
operator|*
name|pte
expr_stmt|;
operator|*
name|pte
operator|=
name|npte
expr_stmt|;
if|if
condition|(
name|opte
condition|)
name|invltlb_1pg
argument_list|(
name|tva
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * this routine jerks page mappings from the  * kernel -- it is meant only for temporary mappings.  */
end_comment

begin_function
name|void
name|pmap_qremove
parameter_list|(
name|va
parameter_list|,
name|count
parameter_list|)
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|pte
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|pte
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
name|invltlb_1pg
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * add a wired page to the kva  * note that in order for the mapping to take effect -- you  * should do a invltlb after doing the pmap_kenter...  */
end_comment

begin_function
name|PMAP_INLINE
name|void
name|pmap_kenter
parameter_list|(
name|va
parameter_list|,
name|pa
parameter_list|)
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
block|{
specifier|register
name|unsigned
modifier|*
name|pte
decl_stmt|;
name|unsigned
name|npte
decl_stmt|,
name|opte
decl_stmt|;
name|npte
operator|=
name|pa
operator||
name|PG_RW
operator||
name|PG_V
operator||
name|pgeflag
expr_stmt|;
name|pte
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|opte
operator|=
operator|*
name|pte
expr_stmt|;
operator|*
name|pte
operator|=
name|npte
expr_stmt|;
if|if
condition|(
name|opte
condition|)
name|invltlb_1pg
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove a page from the kernel pagetables  */
end_comment

begin_function
name|PMAP_INLINE
name|void
name|pmap_kremove
parameter_list|(
name|va
parameter_list|)
name|vm_offset_t
name|va
decl_stmt|;
block|{
specifier|register
name|unsigned
modifier|*
name|pte
decl_stmt|;
name|pte
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
name|invltlb_1pg
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|pmap_page_alloc
parameter_list|(
name|object
parameter_list|,
name|pindex
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
block|{
name|vm_page_t
name|m
decl_stmt|;
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
name|VM_ALLOC_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|VM_WAIT
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|pmap_page_lookup
parameter_list|(
name|object
parameter_list|,
name|pindex
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
block|{
name|vm_page_t
name|m
decl_stmt|;
name|retry
label|:
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|PG_WANTED
expr_stmt|;
name|tsleep
argument_list|(
name|m
argument_list|,
name|PVM
argument_list|,
literal|"pplookp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Create the UPAGES for a new process.  * This routine directly affects the fork perf for a process.  */
end_comment

begin_function
name|void
name|pmap_new_proc
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|vm_object_t
name|upobj
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|struct
name|user
modifier|*
name|up
decl_stmt|;
name|unsigned
modifier|*
name|ptek
decl_stmt|;
comment|/* 	 * allocate object for the upages 	 */
name|upobj
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|UPAGES
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_upages_obj
operator|=
name|upobj
expr_stmt|;
comment|/* get a kernel virtual address for the UPAGES for this proc */
name|up
operator|=
operator|(
expr|struct
name|user
operator|*
operator|)
name|kmem_alloc_pageable
argument_list|(
name|u_map
argument_list|,
name|UPAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_new_proc: u_map allocation failed"
argument_list|)
expr_stmt|;
name|ptek
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|vtopte
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|up
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Get a kernel stack page 		 */
while|while
condition|(
operator|(
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|upobj
argument_list|,
name|i
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|VM_WAIT
expr_stmt|;
block|}
comment|/* 		 * Wire the page 		 */
name|m
operator|->
name|wire_count
operator|++
expr_stmt|;
operator|++
name|cnt
operator|.
name|v_wire_count
expr_stmt|;
comment|/* 		 * Enter the page into the kernel address space. 		 */
operator|*
operator|(
name|ptek
operator|+
name|i
operator|)
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator||
name|PG_RW
operator||
name|PG_V
operator||
name|pgeflag
expr_stmt|;
name|m
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PG_ZERO
operator||
name|PG_BUSY
operator|)
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_MAPPED
operator||
name|PG_WRITEABLE
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
name|p
operator|->
name|p_addr
operator|=
name|up
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispose the UPAGES for a process that has exited.  * This routine directly impacts the exit perf of a process.  */
end_comment

begin_function
name|void
name|pmap_dispose_proc
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|vm_object_t
name|upobj
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|unsigned
modifier|*
name|ptek
decl_stmt|;
name|ptek
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|vtopte
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|p
operator|->
name|p_addr
argument_list|)
expr_stmt|;
name|upobj
operator|=
name|p
operator|->
name|p_upages_obj
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|oldpte
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|upobj
argument_list|,
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_dispose_proc: upage already missing???"
argument_list|)
expr_stmt|;
name|oldpte
operator|=
operator|*
operator|(
name|ptek
operator|+
name|i
operator|)
expr_stmt|;
operator|*
operator|(
name|ptek
operator|+
name|i
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|oldpte
operator|&
name|PG_G
condition|)
name|invlpg
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|p
operator|->
name|p_addr
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|vm_object_deallocate
argument_list|(
name|upobj
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|u_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|p
operator|->
name|p_addr
argument_list|,
name|ctob
argument_list|(
name|UPAGES
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allow the UPAGES for a process to be prejudicially paged out.  */
end_comment

begin_function
name|void
name|pmap_swapout_proc
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|vm_object_t
name|upobj
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|upobj
operator|=
name|p
operator|->
name|p_upages_obj
expr_stmt|;
comment|/* 	 * let the upages be paged 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|upobj
argument_list|,
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_swapout_proc: upage already missing???"
argument_list|)
expr_stmt|;
name|m
operator|->
name|dirty
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_deactivate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmap_kremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|p
operator|->
name|p_addr
operator|+
name|PAGE_SIZE
operator|*
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Bring the UPAGES for a specified process back in.  */
end_comment

begin_function
name|void
name|pmap_swapin_proc
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|vm_object_t
name|upobj
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|unsigned
modifier|*
name|pte
decl_stmt|;
name|upobj
operator|=
name|p
operator|->
name|p_upages_obj
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|retry
label|:
if|if
condition|(
operator|(
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|upobj
argument_list|,
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|upobj
argument_list|,
name|i
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|VM_WAIT
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
operator|||
name|m
operator|->
name|busy
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|PG_WANTED
expr_stmt|;
name|tsleep
argument_list|(
name|m
argument_list|,
name|PVM
argument_list|,
literal|"swinuw"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|m
operator|->
name|flags
operator||=
name|PG_BUSY
expr_stmt|;
block|}
name|vm_page_wire
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pmap_kenter
argument_list|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|p
operator|->
name|p_addr
operator|)
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|valid
operator|!=
name|VM_PAGE_BITS_ALL
condition|)
block|{
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|vm_pager_get_pages
argument_list|(
name|upobj
argument_list|,
operator|&
name|m
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|VM_PAGER_OK
condition|)
name|panic
argument_list|(
literal|"pmap_swapin_proc: cannot get upages for proc: %d\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
name|PAGE_WAKEUP
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_MAPPED
operator||
name|PG_WRITEABLE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***************************************************  * Page table page management routines.....  ***************************************************/
end_comment

begin_comment
comment|/*  * This routine unholds page table pages, and if the hold count  * drops to zero, then it decrements the wire count.  */
end_comment

begin_function
specifier|static
name|int
name|_pmap_unwire_pte_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
condition|)
block|{
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
while|while
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|PG_WANTED
expr_stmt|;
name|tsleep
argument_list|(
name|m
argument_list|,
name|PVM
argument_list|,
literal|"pmuwpt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|hold_count
operator|==
literal|0
condition|)
block|{
name|vm_offset_t
name|pteva
decl_stmt|;
comment|/* 		 * unmap the page table page 		 */
name|pmap
operator|->
name|pm_pdir
index|[
name|m
operator|->
name|pindex
index|]
operator|=
literal|0
expr_stmt|;
operator|--
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
operator|)
operator|&
name|PG_FRAME
operator|)
operator|==
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|PTDpde
operator|)
operator|&
name|PG_FRAME
operator|)
condition|)
block|{
comment|/* 			 * Do a invltlb to make the invalidated mapping 			 * take effect immediately. 			 */
name|pteva
operator|=
name|UPT_MIN_ADDRESS
operator|+
name|i386_ptob
argument_list|(
name|m
operator|->
name|pindex
argument_list|)
expr_stmt|;
name|invltlb_1pg
argument_list|(
name|pteva
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PTPHINT
argument_list|)
if|if
condition|(
name|pmap
operator|->
name|pm_ptphint
operator|==
name|m
condition|)
name|pmap
operator|->
name|pm_ptphint
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If the page is finally unwired, simply free it. 		 */
operator|--
name|m
operator|->
name|wire_count
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_WANTED
condition|)
block|{
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|vm_page_free_zero
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|--
name|cnt
operator|.
name|v_wire_count
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|__inline
specifier|static
name|int
name|pmap_unwire_pte_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_page_unhold
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|hold_count
operator|==
literal|0
condition|)
return|return
name|_pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|m
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * After removing a page table entry, this routine is used to  * conditionally free the page, and manage the hold/wire counts.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_unuse_pt
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|mpte
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
name|mpte
decl_stmt|;
block|{
name|unsigned
name|ptepindex
decl_stmt|;
if|if
condition|(
name|va
operator|>=
name|UPT_MIN_ADDRESS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mpte
operator|==
name|NULL
condition|)
block|{
name|ptepindex
operator|=
operator|(
name|va
operator|>>
name|PDRSHIFT
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PTPHINT
argument_list|)
if|if
condition|(
name|pmap
operator|->
name|pm_ptphint
operator|&&
operator|(
name|pmap
operator|->
name|pm_ptphint
operator|->
name|pindex
operator|==
name|ptepindex
operator|)
condition|)
block|{
name|mpte
operator|=
name|pmap
operator|->
name|pm_ptphint
expr_stmt|;
block|}
else|else
block|{
name|mpte
operator|=
name|pmap_page_lookup
argument_list|(
name|pmap
operator|->
name|pm_pteobj
argument_list|,
name|ptepindex
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_ptphint
operator|=
name|mpte
expr_stmt|;
block|}
else|#
directive|else
name|mpte
operator|=
name|pmap_page_lookup
argument_list|(
name|pmap
operator|->
name|pm_pteobj
argument_list|,
name|ptepindex
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|mpte
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure,  * such as one in a vmspace structure.  */
end_comment

begin_function
name|void
name|pmap_pinit
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
block|{
name|vm_page_t
name|ptdpg
decl_stmt|;
comment|/* 	 * No need to allocate page table space yet but we do need a valid 	 * page directory table. 	 */
if|if
condition|(
name|pdstackptr
operator|>
literal|0
condition|)
block|{
operator|--
name|pdstackptr
expr_stmt|;
name|pmap
operator|->
name|pm_pdir
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|pdstack
index|[
name|pdstackptr
index|]
expr_stmt|;
block|}
else|else
block|{
name|pmap
operator|->
name|pm_pdir
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * allocate object for the ptes 	 */
name|pmap
operator|->
name|pm_pteobj
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|PTDPTDI
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * allocate the page directory page 	 */
name|retry
label|:
name|ptdpg
operator|=
name|pmap_page_alloc
argument_list|(
name|pmap
operator|->
name|pm_pteobj
argument_list|,
name|PTDPTDI
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptdpg
operator|==
name|NULL
condition|)
goto|goto
name|retry
goto|;
name|ptdpg
operator|->
name|wire_count
operator|=
literal|1
expr_stmt|;
operator|++
name|cnt
operator|.
name|v_wire_count
expr_stmt|;
name|ptdpg
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PG_MAPPED
operator||
name|PG_BUSY
operator|)
expr_stmt|;
comment|/* not mapped normally */
name|ptdpg
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|pmap_kenter
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_pdir
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|ptdpg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptdpg
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|bzero
argument_list|(
name|pmap
operator|->
name|pm_pdir
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* wire in kernel global address entries */
comment|/* XXX copies current process, does not fill in MPPTDI */
name|bcopy
argument_list|(
name|PTD
operator|+
name|KPTDI
argument_list|,
name|pmap
operator|->
name|pm_pdir
operator|+
name|KPTDI
argument_list|,
name|nkpt
operator|*
name|PTESIZE
argument_list|)
expr_stmt|;
comment|/* install self-referential address mapping entry */
operator|*
operator|(
name|unsigned
operator|*
operator|)
operator|(
name|pmap
operator|->
name|pm_pdir
operator|+
name|PTDPTDI
operator|)
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|ptdpg
argument_list|)
operator||
name|PG_V
operator||
name|PG_RW
expr_stmt|;
name|pmap
operator|->
name|pm_flags
operator|=
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_count
operator|=
literal|1
expr_stmt|;
name|pmap
operator|->
name|pm_ptphint
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|PMAP_PVLIST
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|pmap_release_free_page
parameter_list|(
name|pmap
parameter_list|,
name|p
parameter_list|)
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|unsigned
modifier|*
name|pde
init|=
operator|(
name|unsigned
operator|*
operator|)
name|pmap
operator|->
name|pm_pdir
decl_stmt|;
comment|/* 	 * This code optimizes the case of freeing non-busy 	 * page-table pages.  Those pages are zero now, and 	 * might as well be placed directly into the zero queue. 	 */
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|PG_BUSY
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|PG_WANTED
expr_stmt|;
name|tsleep
argument_list|(
name|p
argument_list|,
name|PVM
argument_list|,
literal|"pmaprl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|PG_WANTED
condition|)
block|{
name|p
operator|->
name|flags
operator|&=
operator|~
name|PG_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Remove the page table page from the processes address space. 	 */
name|pde
index|[
name|p
operator|->
name|pindex
index|]
operator|=
literal|0
expr_stmt|;
operator|--
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|hold_count
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_release: freeing held page table page"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Page directory pages need to have the kernel 	 * stuff cleared, so they can go into the zero queue also. 	 */
if|if
condition|(
name|p
operator|->
name|pindex
operator|==
name|PTDPTDI
condition|)
block|{
name|bzero
argument_list|(
name|pde
operator|+
name|KPTDI
argument_list|,
name|nkpt
operator|*
name|PTESIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|pde
index|[
name|MPPTDI
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|pde
index|[
name|APTDPTDI
index|]
operator|=
literal|0
expr_stmt|;
name|pmap_kremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_pdir
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PTPHINT
argument_list|)
if|if
condition|(
name|pmap
operator|->
name|pm_ptphint
operator|&&
operator|(
name|pmap
operator|->
name|pm_ptphint
operator|->
name|pindex
operator|==
name|p
operator|->
name|pindex
operator|)
condition|)
name|pmap
operator|->
name|pm_ptphint
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|vm_page_free_zero
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * this routine is called if the page table page is not  * mapped correctly.  */
end_comment

begin_function
specifier|static
name|vm_page_t
name|_pmap_allocpte
parameter_list|(
name|pmap
parameter_list|,
name|ptepindex
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|unsigned
name|ptepindex
decl_stmt|;
block|{
name|vm_offset_t
name|pteva
decl_stmt|,
name|ptepa
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|needszero
init|=
literal|0
decl_stmt|;
comment|/* 	 * Find or fabricate a new pagetable page 	 */
name|retry
label|:
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|pmap
operator|->
name|pm_pteobj
argument_list|,
name|ptepindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|pmap_page_alloc
argument_list|(
name|pmap
operator|->
name|pm_pteobj
argument_list|,
name|ptepindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|retry
goto|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|needszero
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PG_ZERO
operator||
name|PG_BUSY
operator|)
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
operator|||
name|m
operator|->
name|busy
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|PG_WANTED
expr_stmt|;
name|tsleep
argument_list|(
name|m
argument_list|,
name|PVM
argument_list|,
literal|"ptewai"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
if|if
condition|(
name|m
operator|->
name|queue
operator|!=
name|PQ_NONE
condition|)
block|{
name|int
name|s
init|=
name|splvm
argument_list|()
decl_stmt|;
name|vm_page_unqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
operator|++
name|cnt
operator|.
name|v_wire_count
expr_stmt|;
operator|++
name|m
operator|->
name|wire_count
expr_stmt|;
comment|/* 	 * Increment the hold count for the page table page 	 * (denoting a new mapping.) 	 */
operator|++
name|m
operator|->
name|hold_count
expr_stmt|;
comment|/* 	 * Map the pagetable page into the process address space, if 	 * it isn't already there. 	 */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
name|ptepa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_pdir
index|[
name|ptepindex
index|]
operator|=
call|(
name|pd_entry_t
call|)
argument_list|(
name|ptepa
operator||
name|PG_U
operator||
name|PG_RW
operator||
name|PG_V
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PTPHINT
argument_list|)
comment|/* 	 * Set the page table hint 	 */
name|pmap
operator|->
name|pm_ptphint
operator|=
name|m
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Try to use the new mapping, but if we cannot, then 	 * do it with the routine that maps the page explicitly. 	 */
if|if
condition|(
name|needszero
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
operator|)
operator|&
name|PG_FRAME
operator|)
operator|==
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|PTDpde
operator|)
operator|&
name|PG_FRAME
operator|)
condition|)
block|{
name|pteva
operator|=
name|UPT_MIN_ADDRESS
operator|+
name|i386_ptob
argument_list|(
name|ptepindex
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|pteva
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pmap_zero_page
argument_list|(
name|ptepa
argument_list|)
expr_stmt|;
block|}
block|}
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_MAPPED
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|pmap_allocpte
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
block|{
name|unsigned
name|ptepindex
decl_stmt|;
name|vm_offset_t
name|ptepa
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
comment|/* 	 * Calculate pagetable page index 	 */
name|ptepindex
operator|=
name|va
operator|>>
name|PDRSHIFT
expr_stmt|;
comment|/* 	 * Get the page directory entry 	 */
name|ptepa
operator|=
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_pdir
index|[
name|ptepindex
index|]
expr_stmt|;
comment|/* 	 * This supports switching from a 4MB page to a 	 * normal 4K page. 	 */
if|if
condition|(
name|ptepa
operator|&
name|PG_PS
condition|)
block|{
name|pmap
operator|->
name|pm_pdir
index|[
name|ptepindex
index|]
operator|=
literal|0
expr_stmt|;
name|ptepa
operator|=
literal|0
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * If the page table page is mapped, we just increment the 	 * hold count, and activate it. 	 */
if|if
condition|(
name|ptepa
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PTPHINT
argument_list|)
comment|/* 		 * In order to get the page table page, try the 		 * hint first. 		 */
if|if
condition|(
name|pmap
operator|->
name|pm_ptphint
operator|&&
operator|(
name|pmap
operator|->
name|pm_ptphint
operator|->
name|pindex
operator|==
name|ptepindex
operator|)
condition|)
block|{
name|m
operator|=
name|pmap
operator|->
name|pm_ptphint
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|pmap_page_lookup
argument_list|(
name|pmap
operator|->
name|pm_pteobj
argument_list|,
name|ptepindex
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_ptphint
operator|=
name|m
expr_stmt|;
block|}
else|#
directive|else
name|m
operator|=
name|pmap_page_lookup
argument_list|(
name|pmap
operator|->
name|pm_pteobj
argument_list|,
name|ptepindex
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|m
operator|->
name|hold_count
expr_stmt|;
return|return
name|m
return|;
block|}
comment|/* 	 * Here if the pte page isn't mapped, or if it has been deallocated. 	 */
return|return
name|_pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|ptepindex
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************** * Pmap allocation/deallocation routines.  ***************************************************/
end_comment

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
block|{
name|vm_page_t
name|p
decl_stmt|,
name|n
decl_stmt|,
name|ptdpg
decl_stmt|;
name|vm_object_t
name|object
init|=
name|pmap
operator|->
name|pm_pteobj
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
if|if
condition|(
name|object
operator|->
name|ref_count
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_release: pteobj reference count != 1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptdpg
operator|=
name|NULL
expr_stmt|;
name|retry
label|:
for|for
control|(
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|object
operator|->
name|memq
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|n
control|)
block|{
name|n
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|listq
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pindex
operator|==
name|PTDPTDI
condition|)
block|{
name|ptdpg
operator|=
name|p
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|pmap_release_free_page
argument_list|(
name|pmap
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|ptdpg
operator|&&
operator|!
name|pmap_release_free_page
argument_list|(
name|pmap
argument_list|,
name|ptdpg
argument_list|)
condition|)
goto|goto
name|retry
goto|;
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdstackptr
operator|<
name|PDSTACKMAX
condition|)
block|{
name|pdstack
index|[
name|pdstackptr
index|]
operator|=
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_pdir
expr_stmt|;
operator|++
name|pdstackptr
expr_stmt|;
block|}
else|else
block|{
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_pdir
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
name|pmap
operator|->
name|pm_pdir
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * grow the number of kernel page table entries, if needed  */
end_comment

begin_function
name|void
name|pmap_growkernel
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|kernel_vm_end
operator|==
literal|0
condition|)
block|{
name|kernel_vm_end
operator|=
name|KERNBASE
expr_stmt|;
name|nkpt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pdir_pde
argument_list|(
name|PTD
argument_list|,
name|kernel_vm_end
argument_list|)
condition|)
block|{
name|kernel_vm_end
operator|=
operator|(
name|kernel_vm_end
operator|+
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
operator|++
name|nkpt
expr_stmt|;
block|}
block|}
name|addr
operator|=
operator|(
name|addr
operator|+
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|kernel_vm_end
operator|<
name|addr
condition|)
block|{
if|if
condition|(
name|pdir_pde
argument_list|(
name|PTD
argument_list|,
name|kernel_vm_end
argument_list|)
condition|)
block|{
name|kernel_vm_end
operator|=
operator|(
name|kernel_vm_end
operator|+
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
continue|continue;
block|}
operator|++
name|nkpt
expr_stmt|;
if|if
condition|(
operator|!
name|nkpg
condition|)
block|{
name|vm_offset_t
name|ptpkva
init|=
operator|(
name|vm_offset_t
operator|)
name|vtopte
argument_list|(
name|addr
argument_list|)
decl_stmt|;
comment|/* 			 * This index is bogus, but out of the way 			 */
name|vm_pindex_t
name|ptpidx
init|=
operator|(
name|ptpkva
operator|>>
name|PAGE_SHIFT
operator|)
decl_stmt|;
name|nkpg
operator|=
name|vm_page_alloc
argument_list|(
name|kernel_object
argument_list|,
name|ptpidx
argument_list|,
name|VM_ALLOC_SYSTEM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nkpg
condition|)
name|panic
argument_list|(
literal|"pmap_growkernel: no memory to grow kernel"
argument_list|)
expr_stmt|;
name|vm_page_wire
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|vm_page_remove
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|pmap_zero_page
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|nkpg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pdir_pde
argument_list|(
name|PTD
argument_list|,
name|kernel_vm_end
argument_list|)
operator|=
call|(
name|pd_entry_t
call|)
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|nkpg
argument_list|)
operator||
name|PG_V
operator||
name|PG_RW
operator||
name|pgeflag
argument_list|)
expr_stmt|;
name|nkpg
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|allproc
operator|.
name|lh_first
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|p_list
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|p_vmspace
condition|)
block|{
name|pmap
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
operator|*
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|kernel_vm_end
argument_list|)
operator|=
name|pdir_pde
argument_list|(
name|PTD
argument_list|,
name|kernel_vm_end
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|pmap_pde
argument_list|(
name|kernel_pmap
argument_list|,
name|kernel_vm_end
argument_list|)
operator|=
name|pdir_pde
argument_list|(
name|PTD
argument_list|,
name|kernel_vm_end
argument_list|)
expr_stmt|;
name|kernel_vm_end
operator|=
operator|(
name|kernel_vm_end
operator|+
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Retire the given physical map from service.  *	Should only be called if the map contains  *	no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_destroy
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
name|count
operator|=
operator|--
name|pmap
operator|->
name|pm_count
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|pmap_release
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pmap
argument_list|,
name|M_VMPMAP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Add a reference to the specified pmap.  */
end_comment

begin_function
name|void
name|pmap_reference
parameter_list|(
name|pmap
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
block|{
if|if
condition|(
name|pmap
operator|!=
name|NULL
condition|)
block|{
name|pmap
operator|->
name|pm_count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*************************************************** * page management routines.  ***************************************************/
end_comment

begin_comment
comment|/*  * free the pv_entry back to the free list  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|free_pv_entry
parameter_list|(
name|pv
parameter_list|)
name|pv_entry_t
name|pv
decl_stmt|;
block|{
operator|++
name|pv_freelistcnt
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pv_freelist
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a new pv_entry, allocating a block from the system  * when needed.  * the memory allocation is performed bypassing the malloc code  * because of the possibility of allocations at interrupt time.  */
end_comment

begin_function
specifier|static
name|pv_entry_t
name|get_pv_entry
parameter_list|()
block|{
name|pv_entry_t
name|tmp
decl_stmt|;
comment|/* 	 * get more pv_entry pages if needed 	 */
if|if
condition|(
name|pv_freelistcnt
operator|<
name|PV_FREELIST_MIN
operator|||
operator|!
name|TAILQ_FIRST
argument_list|(
operator|&
name|pv_freelist
argument_list|)
condition|)
block|{
name|pmap_alloc_pv_entry
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * get a pv_entry off of the free list 	 */
operator|--
name|pv_freelistcnt
expr_stmt|;
name|tmp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pv_freelist
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pv_freelist
argument_list|,
name|tmp
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/*  * This *strange* allocation routine eliminates the possibility of a malloc  * failure (*FATAL*) for a pv_entry_t data structure.  * also -- this code is MUCH MUCH faster than the malloc equiv...  * We really need to do the slab allocator thingie here.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_alloc_pv_entry
parameter_list|()
block|{
comment|/* 	 * do we have any pre-allocated map-pages left? 	 */
if|if
condition|(
name|npvvapg
condition|)
block|{
name|vm_page_t
name|m
decl_stmt|;
comment|/* 		 * allocate a physical page out of the vm system 		 */
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|kernel_object
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|pvva
operator|-
name|vm_map_min
argument_list|(
name|kernel_map
argument_list|)
argument_list|)
argument_list|,
name|VM_ALLOC_INTERRUPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|int
name|newentries
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pv_entry_t
name|entry
decl_stmt|;
name|newentries
operator|=
operator|(
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
operator|)
expr_stmt|;
comment|/* 			 * wire the page 			 */
name|vm_page_wire
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_BUSY
expr_stmt|;
comment|/* 			 * let the kernel see it 			 */
name|pmap_kenter
argument_list|(
name|pvva
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
name|pv_entry_t
operator|)
name|pvva
expr_stmt|;
comment|/* 			 * update the allocation pointers 			 */
name|pvva
operator|+=
name|PAGE_SIZE
expr_stmt|;
operator|--
name|npvvapg
expr_stmt|;
comment|/* 			 * free the entries into the free list 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newentries
condition|;
name|i
operator|++
control|)
block|{
name|free_pv_entry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|TAILQ_FIRST
argument_list|(
operator|&
name|pv_freelist
argument_list|)
condition|)
name|panic
argument_list|(
literal|"get_pv_entry: cannot get a pv_entry_t"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * init the pv_entry allocation system  */
end_comment

begin_function
name|void
name|init_pv_entries
parameter_list|(
name|npg
parameter_list|)
name|int
name|npg
decl_stmt|;
block|{
comment|/* 	 * Allocate enough kvm space for one entry per page, and 	 * each process having PMAP_SHPGPERPROC pages shared with other 	 * processes.  (The system can panic if this is too small, but also 	 * can fail on bootup if this is too big.) 	 * XXX The pv management mechanism needs to be fixed so that systems 	 * with lots of shared mappings amongst lots of processes will still 	 * work.  The fix will likely be that once we run out of pv entries 	 * we will free other entries (and the associated mappings), with 	 * some policy yet to be determined. 	 */
name|npvvapg
operator|=
operator|(
operator|(
name|PMAP_SHPGPERPROC
operator|*
name|maxproc
operator|+
name|npg
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
operator|+
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
name|pvva
operator|=
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|npvvapg
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * get the first batch of entries 	 */
name|pmap_alloc_pv_entry
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If it is the first entry on the list, it is actually  * in the header and we must copy the following entry up  * to the header.  Otherwise we must search the list for  * the entry.  In either case we free the now unused entry.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_remove_entry
parameter_list|(
name|pmap
parameter_list|,
name|ppv
parameter_list|,
name|va
parameter_list|)
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
name|pv_table_t
modifier|*
name|ppv
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|rtval
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
if|#
directive|if
name|PMAP_PVLIST
if|if
condition|(
name|ppv
operator|->
name|pv_list_count
operator|<
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
condition|)
block|{
endif|#
directive|endif
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ppv
operator|->
name|pv_list
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_list
argument_list|)
control|)
block|{
if|if
condition|(
name|pmap
operator|==
name|pv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
break|break;
block|}
if|#
directive|if
name|PMAP_PVLIST
block|}
else|else
block|{
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_plist
argument_list|)
control|)
block|{
if|if
condition|(
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
break|break;
block|}
block|}
endif|#
directive|endif
name|rtval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pv
condition|)
block|{
name|rtval
operator|=
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|pv
operator|->
name|pv_ptem
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ppv
operator|->
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
operator|--
name|ppv
operator|->
name|pv_list_count
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ppv
operator|->
name|pv_list
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ppv
operator|->
name|pv_vm_page
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PG_MAPPED
operator||
name|PG_WRITEABLE
operator|)
expr_stmt|;
block|}
if|#
directive|if
name|PMAP_PVLIST
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|rtval
return|;
block|}
end_function

begin_comment
comment|/*  * Create a pv entry for page at pa for  * (pmap, va).  */
end_comment

begin_function
specifier|static
name|void
name|pmap_insert_entry
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|mpte
parameter_list|,
name|pa
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
name|mpte
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|pv_table_t
modifier|*
name|ppv
decl_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|pv
operator|=
name|get_pv_entry
argument_list|()
expr_stmt|;
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|=
name|pmap
expr_stmt|;
name|pv
operator|->
name|pv_ptem
operator|=
name|mpte
expr_stmt|;
if|#
directive|if
name|PMAP_PVLIST
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ppv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ppv
operator|->
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
operator|++
name|ppv
operator|->
name|pv_list_count
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_remove_pte: do the things to unmap a page in a process  */
end_comment

begin_function
specifier|static
name|int
name|pmap_remove_pte
parameter_list|(
name|pmap
parameter_list|,
name|ptq
parameter_list|,
name|va
parameter_list|)
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
name|unsigned
modifier|*
name|ptq
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
block|{
name|unsigned
name|oldpte
decl_stmt|;
name|pv_table_t
modifier|*
name|ppv
decl_stmt|;
name|oldpte
operator|=
operator|*
name|ptq
expr_stmt|;
operator|*
name|ptq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|oldpte
operator|&
name|PG_W
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|-=
literal|1
expr_stmt|;
comment|/* 	 * Machines that don't support invlpg, also don't support 	 * PG_G. 	 */
if|if
condition|(
name|oldpte
operator|&
name|PG_G
condition|)
name|invlpg
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|oldpte
operator|&
name|PG_MANAGED
condition|)
block|{
name|ppv
operator|=
name|pa_to_pvh
argument_list|(
name|oldpte
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldpte
operator|&
name|PG_M
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PMAP_DIAGNOSTIC
argument_list|)
if|if
condition|(
name|pmap_nw_modified
argument_list|(
operator|(
name|pt_entry_t
operator|)
name|oldpte
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"pmap_remove: modified page not writable: va: 0x%lx, pte: 0x%lx\n"
argument_list|,
name|va
argument_list|,
operator|(
name|int
operator|)
name|oldpte
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pmap_track_modified
argument_list|(
name|va
argument_list|)
condition|)
name|ppv
operator|->
name|pv_vm_page
operator|->
name|dirty
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
return|return
name|pmap_remove_entry
argument_list|(
name|pmap
argument_list|,
name|ppv
argument_list|,
name|va
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a single page from a process address space  */
end_comment

begin_function
specifier|static
name|void
name|pmap_remove_page
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|)
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
block|{
specifier|register
name|unsigned
modifier|*
name|ptq
decl_stmt|;
comment|/* 	 * if there is no pte for this address, just skip it!!! 	 */
if|if
condition|(
operator|*
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|/* 	 * get a local va for mappings for this pmap. 	 */
name|ptq
operator|=
name|get_ptbase
argument_list|(
name|pmap
argument_list|)
operator|+
name|i386_btop
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptq
condition|)
block|{
operator|(
name|void
operator|)
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|ptq
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|invltlb_1pg
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  *	Remove the given range of addresses from the specified map.  *  *	It is assumed that the start and end are properly  *	rounded to the page size.  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|)
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
specifier|register
name|vm_offset_t
name|sva
decl_stmt|;
specifier|register
name|vm_offset_t
name|eva
decl_stmt|;
block|{
specifier|register
name|unsigned
modifier|*
name|ptbase
decl_stmt|;
name|vm_offset_t
name|pdnxt
decl_stmt|;
name|vm_offset_t
name|ptpaddr
decl_stmt|;
name|vm_offset_t
name|sindex
decl_stmt|,
name|eindex
decl_stmt|;
name|int
name|anyvalid
decl_stmt|;
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * special handling of removing one page.  a very 	 * common operation and easy to short circuit some 	 * code. 	 */
if|if
condition|(
operator|(
operator|(
name|sva
operator|+
name|PAGE_SIZE
operator|)
operator|==
name|eva
operator|)
operator|&&
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|pmap
operator|->
name|pm_pdir
index|[
operator|(
name|sva
operator|>>
name|PDRSHIFT
operator|)
index|]
operator|&
name|PG_PS
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|pmap_remove_page
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
return|return;
block|}
name|anyvalid
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get a local virtual address for the mappings that are being 	 * worked with. 	 */
name|ptbase
operator|=
name|get_ptbase
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|sindex
operator|=
name|i386_btop
argument_list|(
name|sva
argument_list|)
expr_stmt|;
name|eindex
operator|=
name|i386_btop
argument_list|(
name|eva
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sindex
operator|<
name|eindex
condition|;
name|sindex
operator|=
name|pdnxt
control|)
block|{
name|unsigned
name|pdirindex
decl_stmt|;
comment|/* 		 * Calculate index for next page table. 		 */
name|pdnxt
operator|=
operator|(
operator|(
name|sindex
operator|+
name|NPTEPG
operator|)
operator|&
operator|~
operator|(
name|NPTEPG
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
condition|)
break|break;
name|pdirindex
operator|=
name|sindex
operator|/
name|NPDEPG
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ptpaddr
operator|=
operator|(
name|unsigned
operator|)
name|pmap
operator|->
name|pm_pdir
index|[
name|pdirindex
index|]
operator|)
operator|&
name|PG_PS
operator|)
operator|!=
literal|0
condition|)
block|{
name|pmap
operator|->
name|pm_pdir
index|[
name|pdirindex
index|]
operator|=
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
name|NBPDR
operator|/
name|PAGE_SIZE
expr_stmt|;
name|anyvalid
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Weed out invalid mappings. Note: we assume that the page 		 * directory table is always allocated, and in kernel virtual. 		 */
if|if
condition|(
name|ptpaddr
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Limit our scan to either the end of the va represented 		 * by the current page table page, or to the end of the 		 * range being removed. 		 */
if|if
condition|(
name|pdnxt
operator|>
name|eindex
condition|)
block|{
name|pdnxt
operator|=
name|eindex
expr_stmt|;
block|}
for|for
control|(
init|;
name|sindex
operator|!=
name|pdnxt
condition|;
name|sindex
operator|++
control|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
if|if
condition|(
name|ptbase
index|[
name|sindex
index|]
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|va
operator|=
name|i386_ptob
argument_list|(
name|sindex
argument_list|)
expr_stmt|;
name|anyvalid
operator|++
expr_stmt|;
if|if
condition|(
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|ptbase
operator|+
name|sindex
argument_list|,
name|va
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|anyvalid
condition|)
block|{
name|invltlb
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_remove_all  *	Function:  *		Removes this physical page from  *		all physical maps in which it resides.  *		Reflects back modify bits to the pager.  *  *	Notes:  *		Original versions of this routine were very  *		inefficient because they iteratively called  *		pmap_remove (slow...)  */
end_comment

begin_function
specifier|static
name|void
name|pmap_remove_all
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
name|pv_table_t
modifier|*
name|ppv
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|int
name|nmodify
decl_stmt|;
name|int
name|update_needed
decl_stmt|;
name|int
name|s
decl_stmt|;
name|nmodify
operator|=
literal|0
expr_stmt|;
name|update_needed
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PMAP_DIAGNOSTIC
argument_list|)
comment|/* 	 * XXX this makes pmap_page_protect(NONE) illegal for non-managed 	 * pages! 	 */
if|if
condition|(
operator|!
name|pmap_is_managed
argument_list|(
name|pa
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_page_protect: illegal for unmanaged page, va: 0x%lx"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|ppv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ppv
operator|->
name|pv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pte
operator|=
name|pmap_pte_quick
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|tpte
operator|=
operator|*
name|pte
expr_stmt|;
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tpte
operator|&
name|PG_W
condition|)
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
comment|/* 		 * Update the vm_page_t clean and reference bits. 		 */
if|if
condition|(
name|tpte
operator|&
name|PG_M
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PMAP_DIAGNOSTIC
argument_list|)
if|if
condition|(
name|pmap_nw_modified
argument_list|(
operator|(
name|pt_entry_t
operator|)
name|tpte
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"pmap_remove_all: modified page not writable: va: 0x%lx, pte: 0x%lx\n"
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|tpte
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pmap_track_modified
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
condition|)
name|ppv
operator|->
name|pv_vm_page
operator|->
name|dirty
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|update_needed
operator|&&
operator|(
operator|(
operator|!
name|curproc
operator|||
operator|(
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|==
name|pv
operator|->
name|pv_pmap
operator|)
operator|)
operator|||
operator|(
name|pv
operator|->
name|pv_pmap
operator|==
name|kernel_pmap
operator|)
operator|)
condition|)
block|{
name|update_needed
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|PMAP_PVLIST
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ppv
operator|->
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
operator|--
name|ppv
operator|->
name|pv_list_count
expr_stmt|;
name|pmap_unuse_pt
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_ptem
argument_list|)
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
name|ppv
operator|->
name|pv_vm_page
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PG_MAPPED
operator||
name|PG_WRITEABLE
operator|)
expr_stmt|;
if|if
condition|(
name|update_needed
condition|)
name|invltlb
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  *	Set the physical protection on the  *	specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|,
name|prot
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|sva
decl_stmt|,
name|eva
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
block|{
specifier|register
name|unsigned
modifier|*
name|ptbase
decl_stmt|;
name|vm_offset_t
name|pdnxt
decl_stmt|;
name|vm_offset_t
name|ptpaddr
decl_stmt|;
name|vm_offset_t
name|sindex
decl_stmt|,
name|eindex
decl_stmt|;
name|int
name|anychanged
decl_stmt|;
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
name|anychanged
operator|=
literal|0
expr_stmt|;
name|ptbase
operator|=
name|get_ptbase
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|sindex
operator|=
name|i386_btop
argument_list|(
name|sva
argument_list|)
expr_stmt|;
name|eindex
operator|=
name|i386_btop
argument_list|(
name|eva
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sindex
operator|<
name|eindex
condition|;
name|sindex
operator|=
name|pdnxt
control|)
block|{
name|unsigned
name|pdirindex
decl_stmt|;
name|pdnxt
operator|=
operator|(
operator|(
name|sindex
operator|+
name|NPTEPG
operator|)
operator|&
operator|~
operator|(
name|NPTEPG
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|pdirindex
operator|=
name|sindex
operator|/
name|NPDEPG
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ptpaddr
operator|=
operator|(
name|unsigned
operator|)
name|pmap
operator|->
name|pm_pdir
index|[
name|pdirindex
index|]
operator|)
operator|&
name|PG_PS
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|unsigned
operator|)
name|pmap
operator|->
name|pm_pdir
index|[
name|pdirindex
index|]
operator|&=
operator|~
operator|(
name|PG_M
operator||
name|PG_RW
operator|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
name|NBPDR
operator|/
name|PAGE_SIZE
expr_stmt|;
name|anychanged
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Weed out invalid mappings. Note: we assume that the page 		 * directory table is always allocated, and in kernel virtual. 		 */
if|if
condition|(
name|ptpaddr
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|pdnxt
operator|>
name|eindex
condition|)
block|{
name|pdnxt
operator|=
name|eindex
expr_stmt|;
block|}
for|for
control|(
init|;
name|sindex
operator|!=
name|pdnxt
condition|;
name|sindex
operator|++
control|)
block|{
name|unsigned
name|pbits
init|=
name|ptbase
index|[
name|sindex
index|]
decl_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
block|{
if|if
condition|(
operator|(
name|pbits
operator|&
operator|(
name|PG_RW
operator||
name|PG_V
operator|)
operator|)
operator|==
name|PG_V
condition|)
block|{
if|if
condition|(
name|pbits
operator|&
name|PG_MANAGED
condition|)
block|{
name|vm_page_t
name|m
init|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pbits
argument_list|)
decl_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_WRITEABLE
expr_stmt|;
name|m
operator|->
name|object
operator|->
name|flags
operator||=
name|OBJ_WRITEABLE
operator||
name|OBJ_MIGHTBEDIRTY
expr_stmt|;
block|}
name|ptbase
index|[
name|sindex
index|]
operator|=
name|pbits
operator||
name|PG_RW
expr_stmt|;
name|anychanged
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pbits
operator|&
name|PG_RW
condition|)
block|{
if|if
condition|(
name|pbits
operator|&
name|PG_M
condition|)
block|{
name|vm_offset_t
name|sva
init|=
name|i386_ptob
argument_list|(
name|sindex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|pbits
operator|&
name|PG_MANAGED
operator|)
operator|&&
name|pmap_track_modified
argument_list|(
name|sva
argument_list|)
condition|)
block|{
name|vm_page_t
name|m
init|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pbits
argument_list|)
decl_stmt|;
name|m
operator|->
name|dirty
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
block|}
name|ptbase
index|[
name|sindex
index|]
operator|=
name|pbits
operator|&
operator|~
operator|(
name|PG_M
operator||
name|PG_RW
operator|)
expr_stmt|;
name|anychanged
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|anychanged
condition|)
name|invltlb
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Insert the given physical page (p) at  *	the specified virtual address (v) in the  *	target physical map with the protection requested.  *  *	If specified, the page will be wired down, meaning  *	that the related pte can not be reclaimed.  *  *	NB:  This is the only routine which MAY NOT lazy-evaluate  *	or lose information.  That is, this routine must actually  *	insert this page into the given map NOW.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|pa
parameter_list|,
name|prot
parameter_list|,
name|wired
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
block|{
specifier|register
name|unsigned
modifier|*
name|pte
decl_stmt|;
name|vm_offset_t
name|opa
decl_stmt|;
name|vm_offset_t
name|origpte
decl_stmt|,
name|newpte
decl_stmt|;
name|vm_page_t
name|mpte
decl_stmt|;
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
name|va
operator|&=
name|PG_FRAME
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAP_DIAGNOSTIC
if|if
condition|(
name|va
operator|>
name|VM_MAX_KERNEL_ADDRESS
condition|)
name|panic
argument_list|(
literal|"pmap_enter: toobig"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|va
operator|>=
name|UPT_MIN_ADDRESS
operator|)
operator|&&
operator|(
name|va
operator|<
name|UPT_MAX_ADDRESS
operator|)
condition|)
name|panic
argument_list|(
literal|"pmap_enter: invalid to pmap_enter page table pages (va: 0x%x)"
argument_list|,
name|va
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mpte
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * In the case that a page table page is not 	 * resident, we are creating it here. 	 */
if|if
condition|(
name|va
operator|<
name|UPT_MIN_ADDRESS
condition|)
name|mpte
operator|=
name|pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * Page Directory table entry not valid, we need a new PT page 	 */
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_enter: invalid page directory, pdir=%p, va=0x%lx\n"
argument_list|,
name|pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|origpte
operator|=
operator|*
operator|(
name|vm_offset_t
operator|*
operator|)
name|pte
expr_stmt|;
name|pa
operator|&=
name|PG_FRAME
expr_stmt|;
name|opa
operator|=
name|origpte
operator|&
name|PG_FRAME
expr_stmt|;
if|if
condition|(
name|origpte
operator|&
name|PG_PS
condition|)
name|panic
argument_list|(
literal|"pmap_enter: attempted pmap_enter on 4MB page"
argument_list|)
expr_stmt|;
comment|/* 	 * Mapping has not changed, must be protection or wiring change. 	 */
if|if
condition|(
name|origpte
operator|&&
operator|(
name|opa
operator|==
name|pa
operator|)
condition|)
block|{
comment|/* 		 * Wiring change, just update stats. We don't worry about 		 * wiring PT pages as they remain resident as long as there 		 * are valid mappings in them. Hence, if a user page is wired, 		 * the PT page will be also. 		 */
if|if
condition|(
name|wired
operator|&&
operator|(
operator|(
name|origpte
operator|&
name|PG_W
operator|)
operator|==
literal|0
operator|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wired
operator|&&
operator|(
name|origpte
operator|&
name|PG_W
operator|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PMAP_DIAGNOSTIC
argument_list|)
if|if
condition|(
name|pmap_nw_modified
argument_list|(
operator|(
name|pt_entry_t
operator|)
name|origpte
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"pmap_enter: modified page not writable: va: 0x%lx, pte: 0x%lx\n"
argument_list|,
name|va
argument_list|,
name|origpte
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * We might be turning off write access to the page, 		 * so we go ahead and sense modify status. 		 */
if|if
condition|(
name|origpte
operator|&
name|PG_MANAGED
condition|)
block|{
name|vm_page_t
name|m
decl_stmt|;
if|if
condition|(
name|origpte
operator|&
name|PG_M
condition|)
block|{
if|if
condition|(
name|pmap_track_modified
argument_list|(
name|va
argument_list|)
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|m
operator|->
name|dirty
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
block|}
name|pa
operator||=
name|PG_MANAGED
expr_stmt|;
block|}
if|if
condition|(
name|mpte
condition|)
operator|--
name|mpte
operator|->
name|hold_count
expr_stmt|;
goto|goto
name|validate
goto|;
block|}
comment|/* 	 * Mapping has changed, invalidate old range and fall through to 	 * handle validating new mapping. 	 */
if|if
condition|(
name|opa
condition|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|panic
argument_list|(
literal|"pmap_enter: pte vanished, va: 0x%x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Enter on the PV list if part of our managed memory Note that we 	 * raise IPL while manipulating pv_table since pmap_enter can be 	 * called at interrupt time. 	 */
if|if
condition|(
name|pmap_is_managed
argument_list|(
name|pa
argument_list|)
condition|)
block|{
name|pmap_insert_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|mpte
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|pa
operator||=
name|PG_MANAGED
expr_stmt|;
block|}
comment|/* 	 * Increment counters 	 */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|validate
label|:
comment|/* 	 * Now validate mapping with desired protection/wiring. 	 */
name|newpte
operator|=
call|(
name|vm_offset_t
call|)
argument_list|(
name|pa
operator||
name|pte_prot
argument_list|(
name|pmap
argument_list|,
name|prot
argument_list|)
operator||
name|PG_V
argument_list|)
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|newpte
operator||=
name|PG_W
expr_stmt|;
if|if
condition|(
name|va
operator|<
name|UPT_MIN_ADDRESS
condition|)
name|newpte
operator||=
name|PG_U
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
name|newpte
operator||=
name|pgeflag
expr_stmt|;
comment|/* 	 * if the mapping or permission bits are different, we need 	 * to update the pte. 	 */
if|if
condition|(
operator|(
name|origpte
operator|&
operator|~
operator|(
name|PG_M
operator||
name|PG_A
operator|)
operator|)
operator|!=
name|newpte
condition|)
block|{
operator|*
name|pte
operator|=
name|newpte
expr_stmt|;
if|if
condition|(
name|origpte
condition|)
name|invltlb_1pg
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * this code makes some *MAJOR* assumptions:  * 1. Current pmap& pmap exists.  * 2. Not wired.  * 3. Read access.  * 4. No page table pages.  * 5. Tlbflush is deferred to calling procedure.  * 6. Page IS managed.  * but is *MUCH* faster than pmap_enter...  */
end_comment

begin_function
specifier|static
name|vm_page_t
name|pmap_enter_quick
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|pa
parameter_list|,
name|mpte
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_page_t
name|mpte
decl_stmt|;
block|{
specifier|register
name|unsigned
modifier|*
name|pte
decl_stmt|;
comment|/* 	 * In the case that a page table page is not 	 * resident, we are creating it here. 	 */
if|if
condition|(
name|va
operator|<
name|UPT_MIN_ADDRESS
condition|)
block|{
name|unsigned
name|ptepindex
decl_stmt|;
name|vm_offset_t
name|ptepa
decl_stmt|;
comment|/* 		 * Calculate pagetable page index 		 */
name|ptepindex
operator|=
name|va
operator|>>
name|PDRSHIFT
expr_stmt|;
if|if
condition|(
name|mpte
operator|&&
operator|(
name|mpte
operator|->
name|pindex
operator|==
name|ptepindex
operator|)
condition|)
block|{
operator|++
name|mpte
operator|->
name|hold_count
expr_stmt|;
block|}
else|else
block|{
name|retry
label|:
comment|/* 			 * Get the page directory entry 			 */
name|ptepa
operator|=
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_pdir
index|[
name|ptepindex
index|]
expr_stmt|;
comment|/* 			 * If the page table page is mapped, we just increment 			 * the hold count, and activate it. 			 */
if|if
condition|(
name|ptepa
condition|)
block|{
if|if
condition|(
name|ptepa
operator|&
name|PG_PS
condition|)
name|panic
argument_list|(
literal|"pmap_enter_quick: unexpected mapping into 4MB page"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PTPHINT
argument_list|)
if|if
condition|(
name|pmap
operator|->
name|pm_ptphint
operator|&&
operator|(
name|pmap
operator|->
name|pm_ptphint
operator|->
name|pindex
operator|==
name|ptepindex
operator|)
condition|)
block|{
name|mpte
operator|=
name|pmap
operator|->
name|pm_ptphint
expr_stmt|;
block|}
else|else
block|{
name|mpte
operator|=
name|pmap_page_lookup
argument_list|(
name|pmap
operator|->
name|pm_pteobj
argument_list|,
name|ptepindex
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_ptphint
operator|=
name|mpte
expr_stmt|;
block|}
else|#
directive|else
name|mpte
operator|=
name|pmap_page_lookup
argument_list|(
name|pmap
operator|->
name|pm_pteobj
argument_list|,
name|ptepindex
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mpte
operator|==
name|NULL
condition|)
goto|goto
name|retry
goto|;
operator|++
name|mpte
operator|->
name|hold_count
expr_stmt|;
block|}
else|else
block|{
name|mpte
operator|=
name|_pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|ptepindex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|mpte
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * This call to vtopte makes the assumption that we are 	 * entering the page into the current pmap.  In order to support 	 * quick entry into any pmap, one would likely use pmap_pte_quick. 	 * But that isn't as quick as vtopte. 	 */
name|pte
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pte
condition|)
block|{
if|if
condition|(
name|mpte
condition|)
name|pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|mpte
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Enter on the PV list if part of our managed memory Note that we 	 * raise IPL while manipulating pv_table since pmap_enter can be 	 * called at interrupt time. 	 */
name|pmap_insert_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|mpte
argument_list|,
name|pa
argument_list|)
expr_stmt|;
comment|/* 	 * Increment counters 	 */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
comment|/* 	 * Now validate mapping with RO protection 	 */
operator|*
name|pte
operator|=
name|pa
operator||
name|PG_V
operator||
name|PG_U
operator||
name|PG_MANAGED
expr_stmt|;
return|return
name|mpte
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_INIT_PT
value|(96)
end_define

begin_comment
comment|/*  * pmap_object_init_pt preloads the ptes for a given object  * into the specified pmap.  This eliminates the blast of soft  * faults on process startup and immediately after an mmap.  */
end_comment

begin_function
name|void
name|pmap_object_init_pt
parameter_list|(
name|pmap
parameter_list|,
name|addr
parameter_list|,
name|object
parameter_list|,
name|pindex
parameter_list|,
name|size
parameter_list|,
name|limit
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|int
name|limit
decl_stmt|;
block|{
name|vm_offset_t
name|tmpidx
decl_stmt|;
name|int
name|psize
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|,
name|mpte
decl_stmt|;
name|int
name|objpgs
decl_stmt|;
if|if
condition|(
operator|!
name|pmap
condition|)
return|return;
comment|/* 	 * This code maps large physical mmap regions into the 	 * processor address space.  Note that some shortcuts 	 * are taken, but the code works. 	 */
if|if
condition|(
name|pseflag
operator|&&
operator|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
operator|)
operator|&&
operator|(
operator|(
name|size
operator|&
operator|(
name|NBPDR
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|vm_page_t
name|m
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|int
name|ptepindex
decl_stmt|;
name|int
name|npdes
decl_stmt|;
name|vm_offset_t
name|ptepa
decl_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_pdir
index|[
name|ptepindex
operator|=
operator|(
name|addr
operator|>>
name|PDRSHIFT
operator|)
index|]
condition|)
return|return;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|retry
label|:
name|p
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|(
name|p
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
condition|)
block|{
name|tsleep
argument_list|(
name|p
argument_list|,
name|PVM
argument_list|,
literal|"init4p"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|vm_page_alloc
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
name|m
index|[
literal|0
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|vm_pager_get_pages
argument_list|(
name|object
argument_list|,
name|m
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|!=
name|VM_PAGER_OK
condition|)
block|{
name|PAGE_WAKEUP
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
name|PAGE_WAKEUP
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|ptepa
operator|=
operator|(
name|vm_offset_t
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptepa
operator|&
operator|(
name|NBPDR
operator|-
literal|1
operator|)
condition|)
block|{
return|return;
block|}
name|p
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|+=
name|size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|npdes
operator|=
name|size
operator|>>
name|PDRSHIFT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npdes
condition|;
name|i
operator|++
control|)
block|{
name|pmap
operator|->
name|pm_pdir
index|[
name|ptepindex
index|]
operator|=
call|(
name|pd_entry_t
call|)
argument_list|(
name|ptepa
operator||
name|PG_U
operator||
name|PG_RW
operator||
name|PG_V
operator||
name|PG_PS
argument_list|)
expr_stmt|;
name|ptepa
operator|+=
name|NBPDR
expr_stmt|;
name|ptepindex
operator|+=
literal|1
expr_stmt|;
block|}
name|p
operator|->
name|flags
operator||=
name|PG_MAPPED
expr_stmt|;
if|#
directive|if
literal|0
block|invltlb();
endif|#
directive|endif
return|return;
block|}
name|psize
operator|=
name|i386_btop
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|object
operator|->
name|type
operator|!=
name|OBJT_VNODE
operator|)
operator|||
operator|(
name|limit
operator|&&
operator|(
name|psize
operator|>
name|MAX_INIT_PT
operator|)
operator|&&
operator|(
name|object
operator|->
name|resident_page_count
operator|>
name|MAX_INIT_PT
operator|)
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|psize
operator|+
name|pindex
operator|>
name|object
operator|->
name|size
condition|)
name|psize
operator|=
name|object
operator|->
name|size
operator|-
name|pindex
expr_stmt|;
name|mpte
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * if we are processing a major portion of the object, then scan the 	 * entire thing. 	 */
if|if
condition|(
name|psize
operator|>
operator|(
name|object
operator|->
name|size
operator|>>
literal|2
operator|)
condition|)
block|{
name|objpgs
operator|=
name|psize
expr_stmt|;
for|for
control|(
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|object
operator|->
name|memq
argument_list|)
init|;
operator|(
operator|(
name|objpgs
operator|>
literal|0
operator|)
operator|&&
operator|(
name|p
operator|!=
name|NULL
operator|)
operator|)
condition|;
name|p
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|listq
argument_list|)
control|)
block|{
name|tmpidx
operator|=
name|p
operator|->
name|pindex
expr_stmt|;
if|if
condition|(
name|tmpidx
operator|<
name|pindex
condition|)
block|{
continue|continue;
block|}
name|tmpidx
operator|-=
name|pindex
expr_stmt|;
if|if
condition|(
name|tmpidx
operator|>=
name|psize
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|p
operator|->
name|valid
operator|&
name|VM_PAGE_BITS_ALL
operator|)
operator|==
name|VM_PAGE_BITS_ALL
operator|)
operator|&&
operator|(
name|p
operator|->
name|busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p
operator|->
name|flags
operator|&
operator|(
name|PG_BUSY
operator||
name|PG_FICTITIOUS
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|queue
operator|-
name|p
operator|->
name|pc
operator|)
operator|==
name|PQ_CACHE
condition|)
name|vm_page_deactivate
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|PG_BUSY
expr_stmt|;
name|mpte
operator|=
name|pmap_enter_quick
argument_list|(
name|pmap
argument_list|,
name|addr
operator|+
name|i386_ptob
argument_list|(
name|tmpidx
argument_list|)
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|p
argument_list|)
argument_list|,
name|mpte
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|PG_MAPPED
expr_stmt|;
name|PAGE_WAKEUP
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|objpgs
operator|-=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * else lookup the pages one-by-one. 		 */
for|for
control|(
name|tmpidx
operator|=
literal|0
init|;
name|tmpidx
operator|<
name|psize
condition|;
name|tmpidx
operator|+=
literal|1
control|)
block|{
name|p
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|tmpidx
operator|+
name|pindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|(
operator|(
name|p
operator|->
name|valid
operator|&
name|VM_PAGE_BITS_ALL
operator|)
operator|==
name|VM_PAGE_BITS_ALL
operator|)
operator|&&
operator|(
name|p
operator|->
name|busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p
operator|->
name|flags
operator|&
operator|(
name|PG_BUSY
operator||
name|PG_FICTITIOUS
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|queue
operator|-
name|p
operator|->
name|pc
operator|)
operator|==
name|PQ_CACHE
condition|)
name|vm_page_deactivate
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|PG_BUSY
expr_stmt|;
name|mpte
operator|=
name|pmap_enter_quick
argument_list|(
name|pmap
argument_list|,
name|addr
operator|+
name|i386_ptob
argument_list|(
name|tmpidx
argument_list|)
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|p
argument_list|)
argument_list|,
name|mpte
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|PG_MAPPED
expr_stmt|;
name|PAGE_WAKEUP
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * pmap_prefault provides a quick way of clustering  * pagefaults into a processes address space.  It is a "cousin"  * of pmap_object_init_pt, except it runs at page fault time instead  * of mmap time.  */
end_comment

begin_define
define|#
directive|define
name|PFBAK
value|2
end_define

begin_define
define|#
directive|define
name|PFFOR
value|2
end_define

begin_define
define|#
directive|define
name|PAGEORDER_SIZE
value|(PFBAK+PFFOR)
end_define

begin_decl_stmt
specifier|static
name|int
name|pmap_prefault_pageorder
index|[]
init|=
block|{
operator|-
name|PAGE_SIZE
block|,
name|PAGE_SIZE
block|,
operator|-
literal|2
operator|*
name|PAGE_SIZE
block|,
literal|2
operator|*
name|PAGE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pmap_prefault
parameter_list|(
name|pmap
parameter_list|,
name|addra
parameter_list|,
name|entry
parameter_list|,
name|object
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|addra
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|starta
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
name|mpte
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|!=
name|object
condition|)
return|return;
if|if
condition|(
operator|!
name|curproc
operator|||
operator|(
name|pmap
operator|!=
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|)
condition|)
return|return;
name|starta
operator|=
name|addra
operator|-
name|PFBAK
operator|*
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|starta
operator|<
name|entry
operator|->
name|start
condition|)
block|{
name|starta
operator|=
name|entry
operator|->
name|start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|starta
operator|>
name|addra
condition|)
block|{
name|starta
operator|=
literal|0
expr_stmt|;
block|}
name|mpte
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PAGEORDER_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|vm_object_t
name|lobject
decl_stmt|;
name|unsigned
modifier|*
name|pte
decl_stmt|;
name|addr
operator|=
name|addra
operator|+
name|pmap_prefault_pageorder
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|starta
operator|||
name|addr
operator|>=
name|entry
operator|->
name|end
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|*
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|pte
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|vtopte
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pte
condition|)
continue|continue;
name|pindex
operator|=
operator|(
operator|(
name|addr
operator|-
name|entry
operator|->
name|start
operator|)
operator|+
name|entry
operator|->
name|offset
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|lobject
operator|=
name|object
expr_stmt|;
for|for
control|(
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|lobject
argument_list|,
name|pindex
argument_list|)
init|;
operator|(
operator|!
name|m
operator|&&
operator|(
name|lobject
operator|->
name|type
operator|==
name|OBJT_DEFAULT
operator|)
operator|&&
operator|(
name|lobject
operator|->
name|backing_object
operator|)
operator|)
condition|;
name|lobject
operator|=
name|lobject
operator|->
name|backing_object
control|)
block|{
if|if
condition|(
name|lobject
operator|->
name|backing_object_offset
operator|&
name|PAGE_MASK
condition|)
break|break;
name|pindex
operator|+=
operator|(
name|lobject
operator|->
name|backing_object_offset
operator|>>
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|lobject
operator|->
name|backing_object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * give-up when a page is not in memory 		 */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
operator|(
name|m
operator|->
name|valid
operator|&
name|VM_PAGE_BITS_ALL
operator|)
operator|==
name|VM_PAGE_BITS_ALL
operator|)
operator|&&
operator|(
name|m
operator|->
name|busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_BUSY
operator||
name|PG_FICTITIOUS
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|queue
operator|-
name|m
operator|->
name|pc
operator|)
operator|==
name|PQ_CACHE
condition|)
block|{
name|vm_page_deactivate
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|flags
operator||=
name|PG_BUSY
expr_stmt|;
name|mpte
operator|=
name|pmap_enter_quick
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|mpte
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_MAPPED
expr_stmt|;
name|PAGE_WAKEUP
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_change_wiring  *	Function:	Change the wiring attribute for a map/virtual-address  *			pair.  *	In/out conditions:  *			The mapping must already exist in the pmap.  */
end_comment

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|wired
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
block|{
specifier|register
name|unsigned
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|wired
operator|&&
operator|!
name|pmap_pte_w
argument_list|(
name|pte
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wired
operator|&&
name|pmap_pte_w
argument_list|(
name|pte
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
comment|/* 	 * Wiring is not a hardware characteristic so there is no need to 	 * invalidate TLB. 	 */
name|pmap_pte_set_w
argument_list|(
name|pte
argument_list|,
name|wired
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Copy the range specified by src_addr/len  *	from the source map to the range dst_addr/len  *	in the destination map.  *  *	This routine is only advisory and need not do anything.  */
end_comment

begin_function
name|void
name|pmap_copy
parameter_list|(
name|dst_pmap
parameter_list|,
name|src_pmap
parameter_list|,
name|dst_addr
parameter_list|,
name|len
parameter_list|,
name|src_addr
parameter_list|)
name|pmap_t
name|dst_pmap
decl_stmt|,
name|src_pmap
decl_stmt|;
name|vm_offset_t
name|dst_addr
decl_stmt|;
name|vm_size_t
name|len
decl_stmt|;
name|vm_offset_t
name|src_addr
decl_stmt|;
block|{
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_offset_t
name|end_addr
init|=
name|src_addr
operator|+
name|len
decl_stmt|;
name|vm_offset_t
name|pdnxt
decl_stmt|;
name|unsigned
name|src_frame
decl_stmt|,
name|dst_frame
decl_stmt|;
if|if
condition|(
name|dst_addr
operator|!=
name|src_addr
condition|)
return|return;
name|src_frame
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|src_pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
operator|)
operator|&
name|PG_FRAME
expr_stmt|;
if|if
condition|(
name|src_frame
operator|!=
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|PTDpde
operator|)
operator|&
name|PG_FRAME
operator|)
condition|)
block|{
return|return;
block|}
name|dst_frame
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|dst_pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
operator|)
operator|&
name|PG_FRAME
expr_stmt|;
if|if
condition|(
name|dst_frame
operator|!=
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|APTDpde
operator|)
operator|&
name|PG_FRAME
operator|)
condition|)
block|{
name|APTDpde
operator|=
call|(
name|pd_entry_t
call|)
argument_list|(
name|dst_frame
operator||
name|PG_RW
operator||
name|PG_V
argument_list|)
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|addr
operator|=
name|src_addr
init|;
name|addr
operator|<
name|end_addr
condition|;
name|addr
operator|=
name|pdnxt
control|)
block|{
name|unsigned
modifier|*
name|src_pte
decl_stmt|,
modifier|*
name|dst_pte
decl_stmt|;
name|vm_page_t
name|dstmpte
decl_stmt|,
name|srcmpte
decl_stmt|;
name|vm_offset_t
name|srcptepaddr
decl_stmt|;
name|unsigned
name|ptepindex
decl_stmt|;
if|if
condition|(
name|addr
operator|>=
name|UPT_MIN_ADDRESS
condition|)
name|panic
argument_list|(
literal|"pmap_copy: invalid to pmap_copy page tables\n"
argument_list|)
expr_stmt|;
name|pdnxt
operator|=
operator|(
operator|(
name|addr
operator|+
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|*
name|NPTEPG
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|ptepindex
operator|=
name|addr
operator|>>
name|PDRSHIFT
expr_stmt|;
name|srcptepaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|src_pmap
operator|->
name|pm_pdir
index|[
name|ptepindex
index|]
expr_stmt|;
if|if
condition|(
name|srcptepaddr
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|srcptepaddr
operator|&
name|PG_PS
condition|)
block|{
if|if
condition|(
name|dst_pmap
operator|->
name|pm_pdir
index|[
name|ptepindex
index|]
operator|==
literal|0
condition|)
block|{
name|dst_pmap
operator|->
name|pm_pdir
index|[
name|ptepindex
index|]
operator|=
operator|(
name|pd_entry_t
operator|)
name|srcptepaddr
expr_stmt|;
name|dst_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|+=
name|NBPDR
expr_stmt|;
block|}
continue|continue;
block|}
name|srcmpte
operator|=
name|vm_page_lookup
argument_list|(
name|src_pmap
operator|->
name|pm_pteobj
argument_list|,
name|ptepindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|srcmpte
operator|->
name|hold_count
operator|==
literal|0
operator|)
operator|||
operator|(
name|srcmpte
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
condition|)
continue|continue;
if|if
condition|(
name|pdnxt
operator|>
name|end_addr
condition|)
name|pdnxt
operator|=
name|end_addr
expr_stmt|;
name|src_pte
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|vtopte
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|dst_pte
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|avtopte
argument_list|(
name|addr
argument_list|)
expr_stmt|;
while|while
condition|(
name|addr
operator|<
name|pdnxt
condition|)
block|{
name|unsigned
name|ptetemp
decl_stmt|;
name|ptetemp
operator|=
operator|*
name|src_pte
expr_stmt|;
comment|/* 			 * we only virtual copy managed pages 			 */
if|if
condition|(
operator|(
name|ptetemp
operator|&
name|PG_MANAGED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * We have to check after allocpte for the 				 * pte still being around...  allocpte can 				 * block. 				 */
name|dstmpte
operator|=
name|pmap_allocpte
argument_list|(
name|dst_pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|dst_pte
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ptetemp
operator|=
operator|*
name|src_pte
operator|)
condition|)
block|{
comment|/* 					 * Clear the modified and 					 * accessed (referenced) bits 					 * during the copy. 					 */
operator|*
name|dst_pte
operator|=
name|ptetemp
operator|&
operator|~
operator|(
name|PG_M
operator||
name|PG_A
operator|)
expr_stmt|;
name|dst_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
name|pmap_insert_entry
argument_list|(
name|dst_pmap
argument_list|,
name|addr
argument_list|,
name|dstmpte
argument_list|,
operator|(
name|ptetemp
operator|&
name|PG_FRAME
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pmap_unwire_pte_hold
argument_list|(
name|dst_pmap
argument_list|,
name|dstmpte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dstmpte
operator|->
name|hold_count
operator|>=
name|srcmpte
operator|->
name|hold_count
condition|)
break|break;
block|}
name|addr
operator|+=
name|PAGE_SIZE
expr_stmt|;
operator|++
name|src_pte
expr_stmt|;
operator|++
name|dst_pte
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_kernel  *	Function:  *		Returns the physical map handle for the kernel.  */
end_comment

begin_function
name|pmap_t
name|pmap_kernel
parameter_list|()
block|{
return|return
operator|(
name|kernel_pmap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page zeros the specified (machine independent)  *	page by mapping the page into virtual memory and using  *	bzero to clear its contents, one machine dependent page  *	at a time.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|phys
parameter_list|)
name|vm_offset_t
name|phys
decl_stmt|;
block|{
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|CMAP2
condition|)
name|panic
argument_list|(
literal|"pmap_zero_page: CMAP busy"
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|CMAP2
operator|=
name|PG_V
operator||
name|PG_RW
operator||
operator|(
name|phys
operator|&
name|PG_FRAME
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|CADDR2
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|CMAP2
operator|=
literal|0
expr_stmt|;
name|invltlb_1pg
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|CADDR2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_copy_page copies the specified (machine independent)  *	page by mapping the page into virtual memory and using  *	bcopy to copy the page, one machine dependent page at a  *	time.  */
end_comment

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|vm_offset_t
name|src
decl_stmt|;
name|vm_offset_t
name|dst
decl_stmt|;
block|{
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|CMAP1
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|CMAP2
condition|)
name|panic
argument_list|(
literal|"pmap_copy_page: CMAP busy"
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|CMAP1
operator|=
name|PG_V
operator||
name|PG_RW
operator||
operator|(
name|src
operator|&
name|PG_FRAME
operator|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|CMAP2
operator|=
name|PG_V
operator||
name|PG_RW
operator||
operator|(
name|dst
operator|&
name|PG_FRAME
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|CADDR1
argument_list|,
name|CADDR2
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|CMAP1
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|CMAP2
operator|=
literal|0
expr_stmt|;
name|invltlb_2pg
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|CADDR1
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|CADDR2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_pageable  *	Function:  *		Make the specified pages (by pmap, offset)  *		pageable (or not) as requested.  *  *		A page which is not pageable may not take  *		a fault; therefore, its page table entry  *		must remain valid for the duration.  *  *		This routine is merely advisory; pmap_enter  *		will specify that these pages are to be wired  *		down (or not) as appropriate.  */
end_comment

begin_function
name|void
name|pmap_pageable
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|,
name|pageable
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|sva
decl_stmt|,
name|eva
decl_stmt|;
name|boolean_t
name|pageable
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/*  * this routine returns true if a physical page resides  * in the given pmap.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_exists
parameter_list|(
name|pmap
parameter_list|,
name|pa
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
name|pv_table_t
modifier|*
name|ppv
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_is_managed
argument_list|(
name|pa
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|ppv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
comment|/* 	 * Not found, check current mappings returning immediately if found. 	 */
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ppv
operator|->
name|pv_list
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_list
argument_list|)
control|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|==
name|pmap
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PMAP_REMOVE_PAGES_CURPROC_ONLY
end_define

begin_comment
comment|/*  * Remove all pages from specified address space  * this aids process exit speeds.  Also, this code  * is special cased for current process only, but  * can have the more generic (and slightly slower)  * mode enabled.  This is much faster than pmap_remove  * in the case of running down an entire address space.  */
end_comment

begin_function
name|void
name|pmap_remove_pages
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|sva
decl_stmt|,
name|eva
decl_stmt|;
block|{
name|unsigned
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|pv_table_t
modifier|*
name|ppv
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|,
name|npv
decl_stmt|;
name|int
name|s
decl_stmt|;
if|#
directive|if
name|PMAP_PVLIST
ifdef|#
directive|ifdef
name|PMAP_REMOVE_PAGES_CURPROC_ONLY
if|if
condition|(
operator|!
name|curproc
operator|||
operator|(
name|pmap
operator|!=
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"warning: pmap_remove_pages called with non-current pmap\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|npv
control|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_va
operator|>=
name|eva
operator|||
name|pv
operator|->
name|pv_va
operator|<
name|sva
condition|)
block|{
name|npv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|PMAP_REMOVE_PAGES_CURPROC_ONLY
name|pte
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|vtopte
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
else|#
directive|else
name|pte
operator|=
name|pmap_pte_quick
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tpte
operator|=
operator|*
name|pte
expr_stmt|;
comment|/*  * We cannot remove wired pages from a process' mapping at this time  */
if|if
condition|(
name|tpte
operator|&
name|PG_W
condition|)
block|{
name|npv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
name|ppv
operator|=
name|pa_to_pvh
argument_list|(
name|tpte
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
comment|/* 		 * Update the vm_page_t clean and reference bits. 		 */
if|if
condition|(
name|tpte
operator|&
name|PG_M
condition|)
block|{
name|ppv
operator|->
name|pv_vm_page
operator|->
name|dirty
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
name|npv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
operator|--
name|ppv
operator|->
name|pv_list_count
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ppv
operator|->
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ppv
operator|->
name|pv_list
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ppv
operator|->
name|pv_vm_page
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PG_MAPPED
operator||
name|PG_WRITEABLE
operator|)
expr_stmt|;
block|}
name|pmap_unuse_pt
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_ptem
argument_list|)
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * pmap_testbit tests bits in pte's  * note that the testbit/changebit routines are inline,  * and a lot of things compile-time evaluate.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|pmap_testbit
parameter_list|(
name|pa
parameter_list|,
name|bit
parameter_list|)
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
name|int
name|bit
decl_stmt|;
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
name|pv_table_t
modifier|*
name|ppv
decl_stmt|;
name|unsigned
modifier|*
name|pte
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_is_managed
argument_list|(
name|pa
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ppv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ppv
operator|->
name|pv_list
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ppv
operator|->
name|pv_list
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_list
argument_list|)
control|)
block|{
comment|/* 		 * if the bit being tested is the modified bit, then 		 * mark clean_map and ptes as never 		 * modified. 		 */
if|if
condition|(
name|bit
operator|&
operator|(
name|PG_A
operator||
name|PG_M
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|pmap_track_modified
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
condition|)
continue|continue;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PMAP_DIAGNOSTIC
argument_list|)
if|if
condition|(
operator|!
name|pv
operator|->
name|pv_pmap
condition|)
block|{
name|printf
argument_list|(
literal|"Null pmap (tb) at va: 0x%lx\n"
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|pte
operator|=
name|pmap_pte_quick
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pte
operator|&
name|bit
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this routine is used to modify bits in ptes  */
end_comment

begin_function
specifier|static
name|void
name|pmap_changebit
parameter_list|(
name|pa
parameter_list|,
name|bit
parameter_list|,
name|setem
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|boolean_t
name|setem
decl_stmt|;
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
name|pv_table_t
modifier|*
name|ppv
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|pte
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_is_managed
argument_list|(
name|pa
argument_list|)
condition|)
return|return;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
name|ppv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
comment|/* 	 * Loop over all current mappings setting/clearing as appropos If 	 * setting RO do we need to clear the VAC? 	 */
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ppv
operator|->
name|pv_list
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_list
argument_list|)
control|)
block|{
comment|/* 		 * don't write protect pager mappings 		 */
if|if
condition|(
operator|!
name|setem
operator|&&
operator|(
name|bit
operator|==
name|PG_RW
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|pmap_track_modified
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
condition|)
continue|continue;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PMAP_DIAGNOSTIC
argument_list|)
if|if
condition|(
operator|!
name|pv
operator|->
name|pv_pmap
condition|)
block|{
name|printf
argument_list|(
literal|"Null pmap (cb) at va: 0x%lx\n"
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|pte
operator|=
name|pmap_pte_quick
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
name|setem
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator||=
name|bit
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|vm_offset_t
name|pbits
init|=
operator|*
operator|(
name|vm_offset_t
operator|*
operator|)
name|pte
decl_stmt|;
if|if
condition|(
name|pbits
operator|&
name|bit
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bit
operator|==
name|PG_RW
condition|)
block|{
if|if
condition|(
name|pbits
operator|&
name|PG_M
condition|)
block|{
name|ppv
operator|->
name|pv_vm_page
operator|->
name|dirty
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|=
name|pbits
operator|&
operator|~
operator|(
name|PG_M
operator||
name|PG_RW
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|=
name|pbits
operator|&
operator|~
name|bit
expr_stmt|;
block|}
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
name|invltlb
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *      pmap_page_protect:  *  *      Lower the permission for all mappings to a given page.  */
end_comment

begin_function
name|void
name|pmap_page_protect
parameter_list|(
name|phys
parameter_list|,
name|prot
parameter_list|)
name|vm_offset_t
name|phys
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
condition|)
block|{
name|pmap_changebit
argument_list|(
name|phys
argument_list|,
name|PG_RW
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pmap_remove_all
argument_list|(
name|phys
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_phys_address
parameter_list|(
name|ppn
parameter_list|)
name|int
name|ppn
decl_stmt|;
block|{
return|return
operator|(
name|i386_ptob
argument_list|(
name|ppn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_ts_referenced:  *  *	Return the count of reference bits for a page, clearing all of them.  *	  */
end_comment

begin_function
name|int
name|pmap_ts_referenced
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|)
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
name|pv_table_t
modifier|*
name|ppv
decl_stmt|;
name|unsigned
modifier|*
name|pte
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|rtval
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_is_managed
argument_list|(
name|pa
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|ppv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ppv
operator|->
name|pv_list
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Not found, check current mappings returning immediately if found. 	 */
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ppv
operator|->
name|pv_list
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_list
argument_list|)
control|)
block|{
comment|/* 		 * if the bit being tested is the modified bit, then 		 * mark clean_map and ptes as never 		 * modified. 		 */
if|if
condition|(
operator|!
name|pmap_track_modified
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
condition|)
continue|continue;
name|pte
operator|=
name|pmap_pte_quick
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|*
name|pte
operator|&
name|PG_A
condition|)
block|{
name|rtval
operator|++
expr_stmt|;
operator|*
name|pte
operator|&=
operator|~
name|PG_A
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtval
condition|)
block|{
name|invltlb
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|rtval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_modified:  *  *	Return whether or not the specified physical page was modified  *	in any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|)
block|{
return|return
name|pmap_testbit
argument_list|(
operator|(
name|pa
operator|)
argument_list|,
name|PG_M
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Clear the modify bits on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|)
block|{
name|pmap_changebit
argument_list|(
operator|(
name|pa
operator|)
argument_list|,
name|PG_M
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_clear_reference:  *  *	Clear the reference bit on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_reference
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|)
block|{
name|pmap_changebit
argument_list|(
operator|(
name|pa
operator|)
argument_list|,
name|PG_A
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Miscellaneous support routines follow  */
end_comment

begin_function
specifier|static
name|void
name|i386_protection_init
parameter_list|()
block|{
specifier|register
name|int
modifier|*
name|kp
decl_stmt|,
name|prot
decl_stmt|;
name|kp
operator|=
name|protection_codes
expr_stmt|;
for|for
control|(
name|prot
operator|=
literal|0
init|;
name|prot
operator|<
literal|8
condition|;
name|prot
operator|++
control|)
block|{
switch|switch
condition|(
name|prot
condition|)
block|{
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
case|:
comment|/* 			 * Read access is also 0. There isn't any execute bit, 			 * so just make it readable. 			 */
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
case|:
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_EXECUTE
case|:
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_EXECUTE
case|:
operator|*
name|kp
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_NONE
case|:
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
case|:
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_NONE
case|:
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
case|:
operator|*
name|kp
operator|++
operator|=
name|PG_RW
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Map a set of physical memory pages into the kernel virtual  * address space. Return a pointer to where it is mapped. This  * routine is intended to be used for mapping device memory,  * NOT real memory. The non-cacheable bits are set on each  * mapped page.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_mapdev
parameter_list|(
name|pa
parameter_list|,
name|size
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
block|{
name|vm_offset_t
name|va
decl_stmt|,
name|tmpva
decl_stmt|;
name|unsigned
modifier|*
name|pte
decl_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|va
operator|=
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|va
condition|)
name|panic
argument_list|(
literal|"pmap_mapdev: Couldn't alloc kernel virtual memory"
argument_list|)
expr_stmt|;
name|pa
operator|=
name|pa
operator|&
name|PG_FRAME
expr_stmt|;
for|for
control|(
name|tmpva
operator|=
name|va
init|;
name|size
operator|>
literal|0
condition|;
control|)
block|{
name|pte
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|vtopte
argument_list|(
name|tmpva
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
name|pa
operator||
name|PG_RW
operator||
name|PG_V
operator||
name|pgeflag
expr_stmt|;
name|size
operator|-=
name|PAGE_SIZE
expr_stmt|;
name|tmpva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|invltlb
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|va
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * perform the pmap work for mincore  */
end_comment

begin_function
name|int
name|pmap_mincore
parameter_list|(
name|pmap
parameter_list|,
name|addr
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
block|{
name|unsigned
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
name|ptep
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptep
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|pte
operator|=
operator|*
name|ptep
condition|)
block|{
name|vm_offset_t
name|pa
decl_stmt|;
name|val
operator|=
name|MINCORE_INCORE
expr_stmt|;
name|pa
operator|=
name|pte
operator|&
name|PG_FRAME
expr_stmt|;
comment|/* 		 * Modified by us 		 */
if|if
condition|(
name|pte
operator|&
name|PG_M
condition|)
name|val
operator||=
name|MINCORE_MODIFIED
operator||
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
comment|/* 		 * Modified by someone 		 */
elseif|else
if|if
condition|(
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|->
name|dirty
operator|||
name|pmap_is_modified
argument_list|(
name|pa
argument_list|)
condition|)
name|val
operator||=
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
comment|/* 		 * Referenced by us 		 */
if|if
condition|(
name|pte
operator|&
name|PG_U
condition|)
name|val
operator||=
name|MINCORE_REFERENCED
operator||
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
comment|/* 		 * Referenced by someone 		 */
elseif|else
if|if
condition|(
operator|(
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|->
name|flags
operator|&
name|PG_REFERENCED
operator|)
operator|||
name|pmap_ts_referenced
argument_list|(
name|pa
argument_list|)
condition|)
block|{
name|val
operator||=
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|->
name|flags
operator||=
name|PG_REFERENCED
expr_stmt|;
block|}
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
name|void
name|pmap_activate
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|load_cr3
argument_list|(
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_cr3
operator|=
name|vtophys
argument_list|(
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|.
name|pm_pdir
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_addr_hint
parameter_list|(
name|vm_object_t
name|obj
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
if|if
condition|(
operator|(
name|size
operator|<
name|NBPDR
operator|)
operator|||
operator|(
name|obj
operator|->
name|type
operator|!=
name|OBJT_DEVICE
operator|)
condition|)
block|{
return|return
name|addr
return|;
block|}
name|addr
operator|=
operator|(
name|addr
operator|+
operator|(
name|NBPDR
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|NBPDR
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PMAP_DEBUG
argument_list|)
end_if

begin_macro
name|pmap_pid_dump
argument_list|(
argument|int pid
argument_list|)
end_macro

begin_block
block|{
name|pmap_t
name|pmap
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|npte
init|=
literal|0
decl_stmt|;
name|int
name|index
decl_stmt|;
for|for
control|(
name|p
operator|=
name|allproc
operator|.
name|lh_first
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|p_list
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|p_pid
operator|!=
name|pid
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|p_vmspace
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
name|pmap
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|unsigned
modifier|*
name|pte
decl_stmt|;
name|unsigned
name|base
init|=
name|i
operator|<<
name|PDRSHIFT
decl_stmt|;
name|pde
operator|=
operator|&
name|pmap
operator|->
name|pm_pdir
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pde
operator|&&
name|pmap_pde_v
argument_list|(
name|pde
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|1024
condition|;
name|j
operator|++
control|)
block|{
name|unsigned
name|va
init|=
name|base
operator|+
operator|(
name|j
operator|<<
name|PAGE_SHIFT
operator|)
decl_stmt|;
if|if
condition|(
name|va
operator|>=
operator|(
name|vm_offset_t
operator|)
name|VM_MIN_KERNEL_ADDRESS
condition|)
block|{
if|if
condition|(
name|index
condition|)
block|{
name|index
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|npte
return|;
block|}
name|pte
operator|=
name|pmap_pte_quick
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|&&
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|pa
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
operator|(
name|pa
operator|&
name|PG_FRAME
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"va: 0x%x, pt: 0x%x, h: %d, w: %d, f: 0x%x"
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|m
operator|->
name|hold_count
argument_list|,
name|m
operator|->
name|wire_count
argument_list|,
name|m
operator|->
name|flags
argument_list|)
expr_stmt|;
name|npte
operator|++
expr_stmt|;
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|2
condition|)
block|{
name|index
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|npte
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|pads
name|__P
argument_list|(
operator|(
name|pmap_t
name|pm
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pmap_pvdump
name|__P
argument_list|(
operator|(
name|vm_offset_t
name|pa
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print address space of pmap*/
end_comment

begin_function
specifier|static
name|void
name|pads
parameter_list|(
name|pm
parameter_list|)
name|pmap_t
name|pm
decl_stmt|;
block|{
name|unsigned
name|va
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
modifier|*
name|ptep
decl_stmt|;
if|if
condition|(
name|pm
operator|==
name|kernel_pmap
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pm
operator|->
name|pm_pdir
index|[
name|i
index|]
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|1024
condition|;
name|j
operator|++
control|)
block|{
name|va
operator|=
operator|(
name|i
operator|<<
name|PDRSHIFT
operator|)
operator|+
operator|(
name|j
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|kernel_pmap
operator|&&
name|va
operator|<
name|KERNBASE
condition|)
continue|continue;
if|if
condition|(
name|pm
operator|!=
name|kernel_pmap
operator|&&
name|va
operator|>
name|UPT_MAX_ADDRESS
condition|)
continue|continue;
name|ptep
operator|=
name|pmap_pte_quick
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_pte_v
argument_list|(
name|ptep
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%x:%x "
argument_list|,
name|va
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|ptep
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_pvdump
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
name|pv_table_t
modifier|*
name|ppv
decl_stmt|;
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
name|printf
argument_list|(
literal|"pa %x"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|ppv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ppv
operator|->
name|pv_list
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_list
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|used_to_be
name|printf
argument_list|(
literal|" -> pmap %x, va %x, flags %x"
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|" -> pmap %x, va %x"
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|pads
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

