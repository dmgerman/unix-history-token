begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996, by Steve Passe  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the developer may NOT be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<machine/smptests.h>
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_comment
comment|/* cngetc() */
end_comment

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GPROF
end_ifdef

begin_include
include|#
directive|include
file|<sys/gmon.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/memrange.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<machine/apic.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/mpapic.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/smptests.h>
end_include

begin_comment
comment|/** TEST_DEFAULT_CONFIG, TEST_TEST1 */
end_comment

begin_include
include|#
directive|include
file|<machine/tss.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/globaldata.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_comment
comment|/* setidt() */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_comment
comment|/* IPIs */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/intr_machdep.h>
end_include

begin_comment
comment|/* IPIs */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APIC_IO */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TEST_DEFAULT_CONFIG
argument_list|)
end_if

begin_define
define|#
directive|define
name|MPFPS_MPFB1
value|TEST_DEFAULT_CONFIG
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MPFPS_MPFB1
value|mpfps->mpfb1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST_DEFAULT_CONFIG */
end_comment

begin_define
define|#
directive|define
name|WARMBOOT_TARGET
value|0
end_define

begin_define
define|#
directive|define
name|WARMBOOT_OFF
value|(KERNBASE + 0x0467)
end_define

begin_define
define|#
directive|define
name|WARMBOOT_SEG
value|(KERNBASE + 0x0469)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_define
define|#
directive|define
name|BIOS_BASE
value|(0xe8000)
end_define

begin_define
define|#
directive|define
name|BIOS_SIZE
value|(0x18000)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BIOS_BASE
value|(0xf0000)
end_define

begin_define
define|#
directive|define
name|BIOS_SIZE
value|(0x10000)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BIOS_COUNT
value|(BIOS_SIZE/4)
end_define

begin_define
define|#
directive|define
name|CMOS_REG
value|(0x70)
end_define

begin_define
define|#
directive|define
name|CMOS_DATA
value|(0x71)
end_define

begin_define
define|#
directive|define
name|BIOS_RESET
value|(0x0f)
end_define

begin_define
define|#
directive|define
name|BIOS_WARM
value|(0x0a)
end_define

begin_define
define|#
directive|define
name|PROCENTRY_FLAG_EN
value|0x01
end_define

begin_define
define|#
directive|define
name|PROCENTRY_FLAG_BP
value|0x02
end_define

begin_define
define|#
directive|define
name|IOAPICENTRY_FLAG_EN
value|0x01
end_define

begin_comment
comment|/* MP Floating Pointer Structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|MPFPS
block|{
name|char
name|signature
index|[
literal|4
index|]
decl_stmt|;
name|void
modifier|*
name|pap
decl_stmt|;
name|u_char
name|length
decl_stmt|;
name|u_char
name|spec_rev
decl_stmt|;
name|u_char
name|checksum
decl_stmt|;
name|u_char
name|mpfb1
decl_stmt|;
name|u_char
name|mpfb2
decl_stmt|;
name|u_char
name|mpfb3
decl_stmt|;
name|u_char
name|mpfb4
decl_stmt|;
name|u_char
name|mpfb5
decl_stmt|;
block|}
typedef|*
name|mpfps_t
typedef|;
end_typedef

begin_comment
comment|/* MP Configuration Table Header */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|MPCTH
block|{
name|char
name|signature
index|[
literal|4
index|]
decl_stmt|;
name|u_short
name|base_table_length
decl_stmt|;
name|u_char
name|spec_rev
decl_stmt|;
name|u_char
name|checksum
decl_stmt|;
name|u_char
name|oem_id
index|[
literal|8
index|]
decl_stmt|;
name|u_char
name|product_id
index|[
literal|12
index|]
decl_stmt|;
name|void
modifier|*
name|oem_table_pointer
decl_stmt|;
name|u_short
name|oem_table_size
decl_stmt|;
name|u_short
name|entry_count
decl_stmt|;
name|void
modifier|*
name|apic_address
decl_stmt|;
name|u_short
name|extended_table_length
decl_stmt|;
name|u_char
name|extended_table_checksum
decl_stmt|;
name|u_char
name|reserved
decl_stmt|;
block|}
typedef|*
name|mpcth_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|PROCENTRY
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|apic_id
decl_stmt|;
name|u_char
name|apic_version
decl_stmt|;
name|u_char
name|cpu_flags
decl_stmt|;
name|u_long
name|cpu_signature
decl_stmt|;
name|u_long
name|feature_flags
decl_stmt|;
name|u_long
name|reserved1
decl_stmt|;
name|u_long
name|reserved2
decl_stmt|;
block|}
typedef|*
name|proc_entry_ptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|BUSENTRY
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|bus_id
decl_stmt|;
name|char
name|bus_type
index|[
literal|6
index|]
decl_stmt|;
block|}
typedef|*
name|bus_entry_ptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|IOAPICENTRY
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|apic_id
decl_stmt|;
name|u_char
name|apic_version
decl_stmt|;
name|u_char
name|apic_flags
decl_stmt|;
name|void
modifier|*
name|apic_address
decl_stmt|;
block|}
typedef|*
name|io_apic_entry_ptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|INTENTRY
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|int_type
decl_stmt|;
name|u_short
name|int_flags
decl_stmt|;
name|u_char
name|src_bus_id
decl_stmt|;
name|u_char
name|src_bus_irq
decl_stmt|;
name|u_char
name|dst_apic_id
decl_stmt|;
name|u_char
name|dst_apic_int
decl_stmt|;
block|}
typedef|*
name|int_entry_ptr
typedef|;
end_typedef

begin_comment
comment|/* descriptions of MP basetable entries */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|BASETABLE_ENTRY
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|length
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
block|}
name|basetable_entry
typedef|;
end_typedef

begin_comment
comment|/*  * this code MUST be enabled here and in mpboot.s.  * it follows the very early stages of AP boot by placing values in CMOS ram.  * it NORMALLY will never be needed and thus the primitive method for enabling.  * #define CHECK_POINTS  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHECK_POINTS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PC98
argument_list|)
end_if

begin_define
define|#
directive|define
name|CHECK_READ
parameter_list|(
name|A
parameter_list|)
value|(outb(CMOS_REG, (A)), inb(CMOS_DATA))
end_define

begin_define
define|#
directive|define
name|CHECK_WRITE
parameter_list|(
name|A
parameter_list|,
name|D
parameter_list|)
value|(outb(CMOS_REG, (A)), outb(CMOS_DATA, (D)))
end_define

begin_define
define|#
directive|define
name|CHECK_INIT
parameter_list|(
name|D
parameter_list|)
value|;				\ 	CHECK_WRITE(0x34, (D));			\ 	CHECK_WRITE(0x35, (D));			\ 	CHECK_WRITE(0x36, (D));			\ 	CHECK_WRITE(0x37, (D));			\ 	CHECK_WRITE(0x38, (D));			\ 	CHECK_WRITE(0x39, (D));
end_define

begin_define
define|#
directive|define
name|CHECK_PRINT
parameter_list|(
name|S
parameter_list|)
value|;				\ 	printf("%s: %d, %d, %d, %d, %d, %d\n",	\ 	   (S),					\ 	   CHECK_READ(0x34),			\ 	   CHECK_READ(0x35),			\ 	   CHECK_READ(0x36),			\ 	   CHECK_READ(0x37),			\ 	   CHECK_READ(0x38),			\ 	   CHECK_READ(0x39));
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* CHECK_POINTS */
end_comment

begin_define
define|#
directive|define
name|CHECK_INIT
parameter_list|(
name|D
parameter_list|)
end_define

begin_define
define|#
directive|define
name|CHECK_PRINT
parameter_list|(
name|S
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CHECK_POINTS */
end_comment

begin_comment
comment|/*  * Values to send to the POST hardware.  */
end_comment

begin_define
define|#
directive|define
name|MP_BOOTADDRESS_POST
value|0x10
end_define

begin_define
define|#
directive|define
name|MP_PROBE_POST
value|0x11
end_define

begin_define
define|#
directive|define
name|MPTABLE_PASS1_POST
value|0x12
end_define

begin_define
define|#
directive|define
name|MP_START_POST
value|0x13
end_define

begin_define
define|#
directive|define
name|MP_ENABLE_POST
value|0x14
end_define

begin_define
define|#
directive|define
name|MPTABLE_PASS2_POST
value|0x15
end_define

begin_define
define|#
directive|define
name|START_ALL_APS_POST
value|0x16
end_define

begin_define
define|#
directive|define
name|INSTALL_AP_TRAMP_POST
value|0x17
end_define

begin_define
define|#
directive|define
name|START_AP_POST
value|0x18
end_define

begin_define
define|#
directive|define
name|MP_ANNOUNCE_POST
value|0x19
end_define

begin_comment
comment|/* used to hold the AP's until we are ready to release them */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ap_boot_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** XXX FIXME: where does this really belong, isa.h/isa.c perhaps? */
end_comment

begin_decl_stmt
name|int
name|current_postcode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** XXX FIXME: what system files declare these??? */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|region_descriptor
name|r_gdt
decl_stmt|,
name|r_idt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bsp_apic_ready
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flags useability of BSP apic */
end_comment

begin_decl_stmt
name|int
name|mp_naps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of Applications processors */
end_comment

begin_decl_stmt
name|int
name|mp_nbusses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of busses */
end_comment

begin_decl_stmt
name|int
name|mp_napics
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of IO APICs */
end_comment

begin_decl_stmt
name|int
name|boot_cpu_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* designated BSP */
end_comment

begin_decl_stmt
name|vm_offset_t
name|cpu_apic_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|io_apic_address
index|[
name|NAPICID
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NAPICID is more than enough */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nkpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|cpu_apic_versions
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
modifier|*
name|io_apic_versions
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|APIC_INTR_REORDER
end_ifdef

begin_struct
struct|struct
block|{
specifier|volatile
name|int
modifier|*
name|location
decl_stmt|;
name|int
name|bit
decl_stmt|;
block|}
name|apic_isrbit_location
index|[
literal|32
index|]
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|apic_intmapinfo
name|int_to_apicintpin
index|[
name|APIC_INTMAPSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * APIC ID logical/physical mapping structures.  * We oversize these to simplify boot-time config.  */
end_comment

begin_decl_stmt
name|int
name|cpu_num_to_apic_id
index|[
name|NAPICID
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|io_num_to_apic_id
index|[
name|NAPICID
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_id_to_logical
index|[
name|NAPICID
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AP uses this during bootstrap.  Do not staticize.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bootSTK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bootAP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hotwire a 0->4MB V==P mapping */
end_comment

begin_decl_stmt
specifier|extern
name|pt_entry_t
modifier|*
name|KPTphys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SMP page table page */
end_comment

begin_decl_stmt
specifier|extern
name|pt_entry_t
modifier|*
name|SMPpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pcb
name|stoppcbs
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|invltlb_ok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* throttle smp_invltlb() till safe */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|invltlb_ok
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|invltlb_ok
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Local data and functions.  */
end_comment

begin_comment
comment|/* Set to 1 once we're ready to let the APs out of the pen. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|aps_ready
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mp_capable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|boot_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|base_memory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|picmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0: virtual wire mode, 1: PIC mode */
end_comment

begin_decl_stmt
specifier|static
name|mpfps_t
name|mpfps
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|search_for_sig
parameter_list|(
name|u_int32_t
name|target
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mp_enable
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_pass1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mptable_pass2
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_mp_table
parameter_list|(
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_mp_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_apic_irq_mapping
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_locks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|start_all_aps
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|install_ap_tramp
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|start_ap
parameter_list|(
name|int
name|logicalCpu
parameter_list|,
name|u_int
name|boot_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ap_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|apic_int_is_bus_type
parameter_list|(
name|int
name|intr
parameter_list|,
name|int
name|bus_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_aps
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * initialize all the SMP locks  */
end_comment

begin_comment
comment|/* critical region around IO APIC, apic_imen */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|imen_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lock region used by kernel profiling */
end_comment

begin_decl_stmt
name|int
name|mcount_lock
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_COMLOCK
end_ifdef

begin_comment
comment|/* locks com (tty) data/hardware accesses: a FASTINTR() */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|com_mtx
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_COMLOCK */
end_comment

begin_function
specifier|static
name|void
name|init_locks
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_COMLOCK
name|mtx_init
argument_list|(
operator|&
name|com_mtx
argument_list|,
literal|"com"
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_COMLOCK */
block|}
end_function

begin_comment
comment|/*  * Calculate usable address in base memory for AP trampoline code.  */
end_comment

begin_function
name|u_int
name|mp_bootaddress
parameter_list|(
name|u_int
name|basemem
parameter_list|)
block|{
name|POSTCODE
argument_list|(
name|MP_BOOTADDRESS_POST
argument_list|)
expr_stmt|;
name|base_memory
operator|=
name|basemem
operator|*
literal|1024
expr_stmt|;
comment|/* convert to bytes */
name|boot_address
operator|=
name|base_memory
operator|&
operator|~
literal|0xfff
expr_stmt|;
comment|/* round down to 4k boundary */
if|if
condition|(
operator|(
name|base_memory
operator|-
name|boot_address
operator|)
operator|<
name|bootMP_size
condition|)
name|boot_address
operator|-=
literal|4096
expr_stmt|;
comment|/* not enough, lower by 4k */
return|return
name|boot_address
return|;
block|}
end_function

begin_comment
comment|/*  * Look for an Intel MP spec table (ie, SMP capable hardware).  */
end_comment

begin_function
name|void
name|i386_mp_probe
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|u_long
name|segment
decl_stmt|;
name|u_int32_t
name|target
decl_stmt|;
name|POSTCODE
argument_list|(
name|MP_PROBE_POST
argument_list|)
expr_stmt|;
comment|/* see if EBDA exists */
if|if
condition|(
operator|(
name|segment
operator|=
operator|(
name|u_long
operator|)
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|KERNBASE
operator|+
literal|0x40e
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* search first 1K of EBDA */
name|target
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|segment
operator|<<
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|search_for_sig
argument_list|(
name|target
argument_list|,
literal|1024
operator|/
literal|4
argument_list|)
operator|)
operator|>=
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
else|else
block|{
comment|/* last 1K of base memory, effective 'top of base' passed in */
name|target
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|base_memory
operator|-
literal|0x400
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|search_for_sig
argument_list|(
name|target
argument_list|,
literal|1024
operator|/
literal|4
argument_list|)
operator|)
operator|>=
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
comment|/* search the BIOS */
name|target
operator|=
operator|(
name|u_int32_t
operator|)
name|BIOS_BASE
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|search_for_sig
argument_list|(
name|target
argument_list|,
name|BIOS_COUNT
argument_list|)
operator|)
operator|>=
literal|0
condition|)
goto|goto
name|found
goto|;
comment|/* nothing found */
name|mpfps
operator|=
operator|(
name|mpfps_t
operator|)
literal|0
expr_stmt|;
name|mp_capable
operator|=
literal|0
expr_stmt|;
return|return;
name|found
label|:
comment|/* calculate needed resources */
name|mpfps
operator|=
operator|(
name|mpfps_t
operator|)
name|x
expr_stmt|;
name|mptable_pass1
argument_list|()
expr_stmt|;
comment|/* flag fact that we are running multiple processors */
name|mp_capable
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cpu_mp_probe
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|mp_capable
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the SMP hardware and the APIC and start up the AP's.  */
end_comment

begin_function
name|void
name|cpu_mp_start
parameter_list|(
name|void
parameter_list|)
block|{
name|POSTCODE
argument_list|(
name|MP_START_POST
argument_list|)
expr_stmt|;
comment|/* look for MP capable motherboard */
if|if
condition|(
name|mp_capable
condition|)
name|mp_enable
argument_list|(
name|boot_address
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"MP hardware not found!"
argument_list|)
expr_stmt|;
name|cpu_setregs
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print various information about the SMP system hardware and setup.  */
end_comment

begin_function
name|void
name|cpu_mp_announce
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|POSTCODE
argument_list|(
name|MP_ANNOUNCE_POST
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" cpu0 (BSP): apic id: %2d"
argument_list|,
name|CPU_TO_ID
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", version: 0x%08x"
argument_list|,
name|cpu_apic_versions
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", at 0x%08x\n"
argument_list|,
name|cpu_apic_address
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<=
name|mp_naps
condition|;
operator|++
name|x
control|)
block|{
name|printf
argument_list|(
literal|" cpu%d (AP):  apic id: %2d"
argument_list|,
name|x
argument_list|,
name|CPU_TO_ID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", version: 0x%08x"
argument_list|,
name|cpu_apic_versions
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", at 0x%08x\n"
argument_list|,
name|cpu_apic_address
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_napics
condition|;
operator|++
name|x
control|)
block|{
name|printf
argument_list|(
literal|" io%d (APIC): apic id: %2d"
argument_list|,
name|x
argument_list|,
name|IO_TO_ID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", version: 0x%08x"
argument_list|,
name|io_apic_versions
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", at 0x%08x\n"
argument_list|,
name|io_apic_address
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|printf
argument_list|(
literal|" Warning: APIC I/O disabled\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
block|}
end_function

begin_comment
comment|/*  * AP cpu's call this to sync up protected mode.  */
end_comment

begin_function
name|void
name|init_secondary
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|gsel_tss
decl_stmt|;
name|int
name|x
decl_stmt|,
name|myid
init|=
name|bootAP
decl_stmt|;
name|gdt_segs
index|[
name|GPRIV_SEL
index|]
operator|.
name|ssd_base
operator|=
operator|(
name|int
operator|)
operator|&
name|SMP_prvspace
index|[
name|myid
index|]
expr_stmt|;
name|gdt_segs
index|[
name|GPROC0_SEL
index|]
operator|.
name|ssd_base
operator|=
operator|(
name|int
operator|)
operator|&
name|SMP_prvspace
index|[
name|myid
index|]
operator|.
name|globaldata
operator|.
name|gd_common_tss
expr_stmt|;
name|SMP_prvspace
index|[
name|myid
index|]
operator|.
name|globaldata
operator|.
name|gd_prvspace
operator|=
operator|&
name|SMP_prvspace
index|[
name|myid
index|]
operator|.
name|globaldata
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NGDT
condition|;
name|x
operator|++
control|)
block|{
name|ssdtosd
argument_list|(
operator|&
name|gdt_segs
index|[
name|x
index|]
argument_list|,
operator|&
name|gdt
index|[
name|myid
operator|*
name|NGDT
operator|+
name|x
index|]
operator|.
name|sd
argument_list|)
expr_stmt|;
block|}
name|r_gdt
operator|.
name|rd_limit
operator|=
name|NGDT
operator|*
sizeof|sizeof
argument_list|(
name|gdt
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|r_gdt
operator|.
name|rd_base
operator|=
operator|(
name|int
operator|)
operator|&
name|gdt
index|[
name|myid
operator|*
name|NGDT
index|]
expr_stmt|;
name|lgdt
argument_list|(
operator|&
name|r_gdt
argument_list|)
expr_stmt|;
comment|/* does magic intra-segment return */
name|lidt
argument_list|(
operator|&
name|r_idt
argument_list|)
expr_stmt|;
name|lldt
argument_list|(
name|_default_ldt
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|currentldt
argument_list|,
name|_default_ldt
argument_list|)
expr_stmt|;
name|gsel_tss
operator|=
name|GSEL
argument_list|(
name|GPROC0_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|gdt
index|[
name|myid
operator|*
name|NGDT
operator|+
name|GPROC0_SEL
index|]
operator|.
name|sd
operator|.
name|sd_type
operator|=
name|SDT_SYS386TSS
expr_stmt|;
name|PCPU_SET
argument_list|(
name|common_tss
operator|.
name|tss_esp0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* not used until after switch */
name|PCPU_SET
argument_list|(
name|common_tss
operator|.
name|tss_ss0
argument_list|,
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|common_tss
operator|.
name|tss_ioopt
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|i386tss
argument_list|)
operator|)
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|tss_gdt
argument_list|,
operator|&
name|gdt
index|[
name|myid
operator|*
name|NGDT
operator|+
name|GPROC0_SEL
index|]
operator|.
name|sd
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|common_tssd
argument_list|,
operator|*
name|PCPU_GET
argument_list|(
name|tss_gdt
argument_list|)
argument_list|)
expr_stmt|;
name|ltr
argument_list|(
name|gsel_tss
argument_list|)
expr_stmt|;
name|pmap_set_opt
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
end_if

begin_comment
comment|/*  * Final configuration of the BSP's local APIC:  *  - disable 'pic mode'.  *  - disable 'virtual wire mode'.  *  - enable NMI.  */
end_comment

begin_function
name|void
name|bsp_apic_configure
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|byte
decl_stmt|;
name|u_int32_t
name|temp
decl_stmt|;
comment|/* leave 'pic mode' if necessary */
if|if
condition|(
name|picmode
condition|)
block|{
name|outb
argument_list|(
literal|0x22
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
comment|/* select IMCR */
name|byte
operator|=
name|inb
argument_list|(
literal|0x23
argument_list|)
expr_stmt|;
comment|/* current contents */
name|byte
operator||=
literal|0x01
expr_stmt|;
comment|/* mask external INTR */
name|outb
argument_list|(
literal|0x23
argument_list|,
name|byte
argument_list|)
expr_stmt|;
comment|/* disconnect 8259s/NMI */
block|}
comment|/* mask lint0 (the 8259 'virtual wire' connection) */
name|temp
operator|=
name|lapic
operator|.
name|lvt_lint0
expr_stmt|;
name|temp
operator||=
name|APIC_LVT_M
expr_stmt|;
comment|/* set the mask */
name|lapic
operator|.
name|lvt_lint0
operator|=
name|temp
expr_stmt|;
comment|/* setup lint1 to handle NMI */
name|temp
operator|=
name|lapic
operator|.
name|lvt_lint1
expr_stmt|;
name|temp
operator|&=
operator|~
name|APIC_LVT_M
expr_stmt|;
comment|/* clear the mask */
name|lapic
operator|.
name|lvt_lint1
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|apic_dump
argument_list|(
literal|"bsp_apic_configure()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APIC_IO */
end_comment

begin_comment
comment|/*******************************************************************  * local functions and data  */
end_comment

begin_comment
comment|/*  * start the SMP system  */
end_comment

begin_function
specifier|static
name|void
name|mp_enable
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
name|int
name|apic
decl_stmt|;
name|u_int
name|ux
decl_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
name|POSTCODE
argument_list|(
name|MP_ENABLE_POST
argument_list|)
expr_stmt|;
comment|/* turn on 4MB of V == P addressing so we can get to MP table */
operator|*
operator|(
name|int
operator|*
operator|)
name|PTD
operator|=
name|PG_V
operator||
name|PG_RW
operator||
operator|(
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|KPTphys
operator|&
name|PG_FRAME
operator|)
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
comment|/* examine the MP table for needed info, uses physical addresses */
name|x
operator|=
name|mptable_pass2
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|PTD
operator|=
literal|0
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
comment|/* can't process default configs till the CPU APIC is pmapped */
if|if
condition|(
name|x
condition|)
name|default_mp_table
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* post scan cleanup */
name|fix_mp_table
argument_list|()
expr_stmt|;
name|setup_apic_irq_mapping
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
comment|/* fill the LOGICAL io_apic_versions table */
for|for
control|(
name|apic
operator|=
literal|0
init|;
name|apic
operator|<
name|mp_napics
condition|;
operator|++
name|apic
control|)
block|{
name|ux
operator|=
name|io_apic_read
argument_list|(
name|apic
argument_list|,
name|IOAPIC_VER
argument_list|)
expr_stmt|;
name|io_apic_versions
index|[
name|apic
index|]
operator|=
name|ux
expr_stmt|;
name|io_apic_set_id
argument_list|(
name|apic
argument_list|,
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* program each IO APIC in the system */
for|for
control|(
name|apic
operator|=
literal|0
init|;
name|apic
operator|<
name|mp_napics
condition|;
operator|++
name|apic
control|)
if|if
condition|(
name|io_apic_setup
argument_list|(
name|apic
argument_list|)
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"IO APIC setup failure"
argument_list|)
expr_stmt|;
comment|/* install a 'Spurious INTerrupt' vector */
name|setidt
argument_list|(
name|XSPURIOUSINT_OFFSET
argument_list|,
name|Xspuriousint
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install an inter-CPU IPI for TLB invalidation */
name|setidt
argument_list|(
name|XINVLTLB_OFFSET
argument_list|,
name|Xinvltlb
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install an inter-CPU IPI for forwarding hardclock() */
name|setidt
argument_list|(
name|XHARDCLOCK_OFFSET
argument_list|,
name|Xhardclock
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install an inter-CPU IPI for forwarding statclock() */
name|setidt
argument_list|(
name|XSTATCLOCK_OFFSET
argument_list|,
name|Xstatclock
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install an inter-CPU IPI for all-CPU rendezvous */
name|setidt
argument_list|(
name|XRENDEZVOUS_OFFSET
argument_list|,
name|Xrendezvous
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install an inter-CPU IPI for forcing an additional software trap */
name|setidt
argument_list|(
name|XCPUAST_OFFSET
argument_list|,
name|Xcpuast
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install an inter-CPU IPI for CPU stop/restart */
name|setidt
argument_list|(
name|XCPUSTOP_OFFSET
argument_list|,
name|Xcpustop
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TEST_TEST1
argument_list|)
comment|/* install a "fake hardware INTerrupt" vector */
name|setidt
argument_list|(
name|XTEST1_OFFSET
argument_list|,
name|Xtest1
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/** TEST_TEST1 */
endif|#
directive|endif
comment|/* APIC_IO */
comment|/* initialize all SMP locks */
name|init_locks
argument_list|()
expr_stmt|;
comment|/* start each Application Processor */
name|start_all_aps
argument_list|(
name|boot_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * look for the MP spec signature  */
end_comment

begin_comment
comment|/* string defined by the Intel MP Spec as identifying the MP table */
end_comment

begin_define
define|#
directive|define
name|MP_SIG
value|0x5f504d5f
end_define

begin_comment
comment|/* _MP_ */
end_comment

begin_define
define|#
directive|define
name|NEXT
parameter_list|(
name|X
parameter_list|)
value|((X) += 4)
end_define

begin_function
specifier|static
name|int
name|search_for_sig
parameter_list|(
name|u_int32_t
name|target
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|u_int32_t
modifier|*
name|addr
init|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|KERNBASE
operator|+
name|target
operator|)
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
name|NEXT
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|addr
index|[
name|x
index|]
operator|==
name|MP_SIG
condition|)
comment|/* make array index a byte index */
return|return
operator|(
name|target
operator|+
operator|(
name|x
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|basetable_entry
name|basetable_entry_types
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|20
block|,
literal|"Processor"
block|}
block|,
block|{
literal|1
block|,
literal|8
block|,
literal|"Bus"
block|}
block|,
block|{
literal|2
block|,
literal|8
block|,
literal|"I/O APIC"
block|}
block|,
block|{
literal|3
block|,
literal|8
block|,
literal|"I/O INT"
block|}
block|,
block|{
literal|4
block|,
literal|8
block|,
literal|"Local INT"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|BUSDATA
block|{
name|u_char
name|bus_id
decl_stmt|;
name|enum
name|busTypes
name|bus_type
decl_stmt|;
block|}
name|bus_datum
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|INTDATA
block|{
name|u_char
name|int_type
decl_stmt|;
name|u_short
name|int_flags
decl_stmt|;
name|u_char
name|src_bus_id
decl_stmt|;
name|u_char
name|src_bus_irq
decl_stmt|;
name|u_char
name|dst_apic_id
decl_stmt|;
name|u_char
name|dst_apic_int
decl_stmt|;
name|u_char
name|int_vector
decl_stmt|;
block|}
name|io_int
operator|,
name|local_int
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|BUSTYPENAME
block|{
name|u_char
name|type
decl_stmt|;
name|char
name|name
index|[
literal|7
index|]
decl_stmt|;
block|}
name|bus_type_name
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|bus_type_name
name|bus_type_table
index|[]
init|=
block|{
block|{
name|CBUS
block|,
literal|"CBUS"
block|}
block|,
block|{
name|CBUSII
block|,
literal|"CBUSII"
block|}
block|,
block|{
name|EISA
block|,
literal|"EISA"
block|}
block|,
block|{
name|MCA
block|,
literal|"MCA"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|ISA
block|,
literal|"ISA"
block|}
block|,
block|{
name|MCA
block|,
literal|"MCA"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|PCI
block|,
literal|"PCI"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|XPRESS
block|,
literal|"XPRESS"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from MP spec v1.4, table 5-1 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|default_data
index|[
literal|7
index|]
index|[
literal|5
index|]
init|=
block|{
comment|/*   nbus, id0, type0, id1, type1 */
block|{
literal|1
block|,
literal|0
block|,
name|ISA
block|,
literal|255
block|,
literal|255
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
name|EISA
block|,
literal|255
block|,
literal|255
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
name|EISA
block|,
literal|255
block|,
literal|255
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
name|MCA
block|,
literal|255
block|,
literal|255
block|}
block|,
block|{
literal|2
block|,
literal|0
block|,
name|ISA
block|,
literal|1
block|,
name|PCI
block|}
block|,
block|{
literal|2
block|,
literal|0
block|,
name|EISA
block|,
literal|1
block|,
name|PCI
block|}
block|,
block|{
literal|2
block|,
literal|0
block|,
name|MCA
block|,
literal|1
block|,
name|PCI
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the bus data */
end_comment

begin_decl_stmt
specifier|static
name|bus_datum
modifier|*
name|bus_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the IO INT data, one entry per possible APIC INTerrupt */
end_comment

begin_decl_stmt
specifier|static
name|io_int
modifier|*
name|io_apic_ints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nintrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|processor_entry
name|__P
argument_list|(
operator|(
name|proc_entry_ptr
name|entry
operator|,
name|int
name|cpu
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bus_entry
name|__P
argument_list|(
operator|(
name|bus_entry_ptr
name|entry
operator|,
name|int
name|bus
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|io_apic_entry
name|__P
argument_list|(
operator|(
name|io_apic_entry_ptr
name|entry
operator|,
name|int
name|apic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|int_entry
name|__P
argument_list|(
operator|(
name|int_entry_ptr
name|entry
operator|,
name|int
name|intr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lookup_bus_type
name|__P
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * 1st pass on motherboard's Intel MP specification table.  *  * initializes:  *	mp_ncpus = 1  *  * determines:  *	cpu_apic_address (common to all CPUs)  *	io_apic_address[N]  *	mp_naps  *	mp_nbusses  *	mp_napics  *	nintrs  */
end_comment

begin_function
specifier|static
name|void
name|mptable_pass1
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|mpcth_t
name|cth
decl_stmt|;
name|int
name|totalSize
decl_stmt|;
name|void
modifier|*
name|position
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|type
decl_stmt|;
name|POSTCODE
argument_list|(
name|MPTABLE_PASS1_POST
argument_list|)
expr_stmt|;
comment|/* clear various tables */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NAPICID
condition|;
operator|++
name|x
control|)
block|{
name|io_apic_address
index|[
name|x
index|]
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* IO APIC address table */
block|}
comment|/* init everything to empty */
name|mp_naps
operator|=
literal|0
expr_stmt|;
name|mp_nbusses
operator|=
literal|0
expr_stmt|;
name|mp_napics
operator|=
literal|0
expr_stmt|;
name|nintrs
operator|=
literal|0
expr_stmt|;
comment|/* check for use of 'default' configuration */
if|if
condition|(
name|MPFPS_MPFB1
operator|!=
literal|0
condition|)
block|{
comment|/* use default addresses */
name|cpu_apic_address
operator|=
name|DEFAULT_APIC_BASE
expr_stmt|;
name|io_apic_address
index|[
literal|0
index|]
operator|=
name|DEFAULT_IO_APIC_BASE
expr_stmt|;
comment|/* fill in with defaults */
name|mp_naps
operator|=
literal|2
expr_stmt|;
comment|/* includes BSP */
name|mp_nbusses
operator|=
name|default_data
index|[
name|MPFPS_MPFB1
operator|-
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
name|mp_napics
operator|=
literal|1
expr_stmt|;
name|nintrs
operator|=
literal|16
expr_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cth
operator|=
name|mpfps
operator|->
name|pap
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"MP Configuration Table Header MISSING!"
argument_list|)
expr_stmt|;
name|cpu_apic_address
operator|=
operator|(
name|vm_offset_t
operator|)
name|cth
operator|->
name|apic_address
expr_stmt|;
comment|/* walk the table, recording info of interest */
name|totalSize
operator|=
name|cth
operator|->
name|base_table_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|MPCTH
argument_list|)
expr_stmt|;
name|position
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cth
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|MPCTH
argument_list|)
expr_stmt|;
name|count
operator|=
name|cth
operator|->
name|entry_count
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
switch|switch
condition|(
name|type
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|position
condition|)
block|{
case|case
literal|0
case|:
comment|/* processor_entry */
if|if
condition|(
operator|(
operator|(
name|proc_entry_ptr
operator|)
name|position
operator|)
operator|->
name|cpu_flags
operator|&
name|PROCENTRY_FLAG_EN
condition|)
operator|++
name|mp_naps
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* bus_entry */
operator|++
name|mp_nbusses
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* io_apic_entry */
if|if
condition|(
operator|(
operator|(
name|io_apic_entry_ptr
operator|)
name|position
operator|)
operator|->
name|apic_flags
operator|&
name|IOAPICENTRY_FLAG_EN
condition|)
name|io_apic_address
index|[
name|mp_napics
operator|++
index|]
operator|=
call|(
name|vm_offset_t
call|)
argument_list|(
operator|(
name|io_apic_entry_ptr
operator|)
name|position
argument_list|)
operator|->
name|apic_address
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* int_entry */
operator|++
name|nintrs
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* int_entry */
break|break;
default|default:
name|panic
argument_list|(
literal|"mpfps Base Table HOSED!"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|totalSize
operator|-=
name|basetable_entry_types
index|[
name|type
index|]
operator|.
name|length
expr_stmt|;
operator|(
name|u_char
operator|*
operator|)
name|position
operator|+=
name|basetable_entry_types
index|[
name|type
index|]
operator|.
name|length
expr_stmt|;
block|}
block|}
comment|/* qualify the numbers */
if|if
condition|(
name|mp_naps
operator|>
name|MAXCPU
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: only using %d of %d available CPUs!\n"
argument_list|,
name|MAXCPU
argument_list|,
name|mp_naps
argument_list|)
expr_stmt|;
name|mp_naps
operator|=
name|MAXCPU
expr_stmt|;
block|}
comment|/* 	 * Count the BSP. 	 * This is also used as a counter while starting the APs. 	 */
name|mp_ncpus
operator|=
literal|1
expr_stmt|;
operator|--
name|mp_naps
expr_stmt|;
comment|/* subtract the BSP */
block|}
end_function

begin_comment
comment|/*  * 2nd pass on motherboard's Intel MP specification table.  *  * sets:  *	boot_cpu_id  *	ID_TO_IO(N), phy APIC ID to log CPU/IO table  *	CPU_TO_ID(N), logical CPU to APIC ID table  *	IO_TO_ID(N), logical IO to APIC ID table  *	bus_data[N]  *	io_apic_ints[N]  */
end_comment

begin_function
specifier|static
name|int
name|mptable_pass2
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|mpcth_t
name|cth
decl_stmt|;
name|int
name|totalSize
decl_stmt|;
name|void
modifier|*
name|position
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|apic
decl_stmt|,
name|bus
decl_stmt|,
name|cpu
decl_stmt|,
name|intr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|pgeflag
decl_stmt|;
name|POSTCODE
argument_list|(
name|MPTABLE_PASS2_POST
argument_list|)
expr_stmt|;
name|pgeflag
operator|=
literal|0
expr_stmt|;
comment|/* XXX - Not used under SMP yet.  */
name|MALLOC
argument_list|(
name|io_apic_versions
argument_list|,
name|u_int32_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|*
name|mp_napics
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|ioapic
argument_list|,
specifier|volatile
name|ioapic_t
operator|*
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|ioapic_t
operator|*
argument_list|)
operator|*
name|mp_napics
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|io_apic_ints
argument_list|,
name|io_int
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|io_int
argument_list|)
operator|*
operator|(
name|nintrs
operator|+
literal|1
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|bus_data
argument_list|,
name|bus_datum
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|bus_datum
argument_list|)
operator|*
name|mp_nbusses
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ioapic
argument_list|,
sizeof|sizeof
argument_list|(
name|ioapic_t
operator|*
argument_list|)
operator|*
name|mp_napics
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_napics
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|mp_napics
condition|;
name|j
operator|++
control|)
block|{
comment|/* same page frame as a previous IO apic? */
if|if
condition|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|SMPpt
index|[
name|NPTEPG
operator|-
literal|2
operator|-
name|j
index|]
operator|&
name|PG_FRAME
operator|)
operator|==
operator|(
name|io_apic_address
index|[
name|i
index|]
operator|&
name|PG_FRAME
operator|)
condition|)
block|{
name|ioapic
index|[
name|i
index|]
operator|=
operator|(
name|ioapic_t
operator|*
operator|)
operator|(
operator|(
name|u_int
operator|)
name|SMP_prvspace
operator|+
operator|(
name|NPTEPG
operator|-
literal|2
operator|-
name|j
operator|)
operator|*
name|PAGE_SIZE
operator|+
operator|(
name|io_apic_address
index|[
name|i
index|]
operator|&
name|PAGE_MASK
operator|)
operator|)
expr_stmt|;
break|break;
block|}
comment|/* use this slot if available */
if|if
condition|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|SMPpt
index|[
name|NPTEPG
operator|-
literal|2
operator|-
name|j
index|]
operator|&
name|PG_FRAME
operator|)
operator|==
literal|0
condition|)
block|{
name|SMPpt
index|[
name|NPTEPG
operator|-
literal|2
operator|-
name|j
index|]
operator|=
call|(
name|pt_entry_t
call|)
argument_list|(
name|PG_V
operator||
name|PG_RW
operator||
name|pgeflag
operator||
operator|(
name|io_apic_address
index|[
name|i
index|]
operator|&
name|PG_FRAME
operator|)
argument_list|)
expr_stmt|;
name|ioapic
index|[
name|i
index|]
operator|=
operator|(
name|ioapic_t
operator|*
operator|)
operator|(
operator|(
name|u_int
operator|)
name|SMP_prvspace
operator|+
operator|(
name|NPTEPG
operator|-
literal|2
operator|-
name|j
operator|)
operator|*
name|PAGE_SIZE
operator|+
operator|(
name|io_apic_address
index|[
name|i
index|]
operator|&
name|PAGE_MASK
operator|)
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* clear various tables */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NAPICID
condition|;
operator|++
name|x
control|)
block|{
name|ID_TO_IO
argument_list|(
name|x
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* phy APIC ID to log CPU/IO table */
name|CPU_TO_ID
argument_list|(
name|x
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* logical CPU to APIC ID table */
name|IO_TO_ID
argument_list|(
name|x
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* logical IO to APIC ID table */
block|}
comment|/* clear bus data table */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_nbusses
condition|;
operator|++
name|x
control|)
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_id
operator|=
literal|0xff
expr_stmt|;
comment|/* clear IO APIC INT table */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
operator|(
name|nintrs
operator|+
literal|1
operator|)
condition|;
operator|++
name|x
control|)
block|{
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|=
literal|0xff
expr_stmt|;
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
operator|=
literal|0xff
expr_stmt|;
block|}
comment|/* setup the cpu/apic mapping arrays */
name|boot_cpu_id
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* record whether PIC or virtual-wire mode */
name|picmode
operator|=
operator|(
name|mpfps
operator|->
name|mpfb2
operator|&
literal|0x80
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* check for use of 'default' configuration */
if|if
condition|(
name|MPFPS_MPFB1
operator|!=
literal|0
condition|)
return|return
name|MPFPS_MPFB1
return|;
comment|/* return default configuration type */
if|if
condition|(
operator|(
name|cth
operator|=
name|mpfps
operator|->
name|pap
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"MP Configuration Table Header MISSING!"
argument_list|)
expr_stmt|;
comment|/* walk the table, recording info of interest */
name|totalSize
operator|=
name|cth
operator|->
name|base_table_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|MPCTH
argument_list|)
expr_stmt|;
name|position
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cth
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|MPCTH
argument_list|)
expr_stmt|;
name|count
operator|=
name|cth
operator|->
name|entry_count
expr_stmt|;
name|apic
operator|=
name|bus
operator|=
name|intr
operator|=
literal|0
expr_stmt|;
name|cpu
operator|=
literal|1
expr_stmt|;
comment|/* pre-count the BSP */
while|while
condition|(
name|count
operator|--
condition|)
block|{
switch|switch
condition|(
name|type
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|position
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|processor_entry
argument_list|(
name|position
argument_list|,
name|cpu
argument_list|)
condition|)
operator|++
name|cpu
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|bus_entry
argument_list|(
name|position
argument_list|,
name|bus
argument_list|)
condition|)
operator|++
name|bus
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|io_apic_entry
argument_list|(
name|position
argument_list|,
name|apic
argument_list|)
condition|)
operator|++
name|apic
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|int_entry
argument_list|(
name|position
argument_list|,
name|intr
argument_list|)
condition|)
operator|++
name|intr
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* int_entry(position); */
break|break;
default|default:
name|panic
argument_list|(
literal|"mpfps Base Table HOSED!"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|totalSize
operator|-=
name|basetable_entry_types
index|[
name|type
index|]
operator|.
name|length
expr_stmt|;
operator|(
name|u_char
operator|*
operator|)
name|position
operator|+=
name|basetable_entry_types
index|[
name|type
index|]
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|boot_cpu_id
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"NO BSP found!"
argument_list|)
expr_stmt|;
comment|/* report fact that its NOT a default configuration */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|assign_apic_irq
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|intpin
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|ioapic
operator|!=
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"assign_apic_irq: inconsistent table"
argument_list|)
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|ioapic
operator|=
name|apic
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|int_pin
operator|=
name|intpin
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|apic_address
operator|=
name|ioapic
index|[
name|apic
index|]
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|redirindex
operator|=
name|IOAPIC_REDTBL
operator|+
literal|2
operator|*
name|intpin
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|==
literal|0
operator|||
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|==
literal|3
operator|)
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
operator|==
literal|0xff
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
operator|==
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|==
name|intpin
condition|)
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
operator|=
name|irq
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|revoke_apic_irq
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|oldapic
decl_stmt|;
name|int
name|oldintpin
decl_stmt|;
if|if
condition|(
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|ioapic
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"assign_apic_irq: inconsistent table"
argument_list|)
expr_stmt|;
name|oldapic
operator|=
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|ioapic
expr_stmt|;
name|oldintpin
operator|=
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|int_pin
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|ioapic
operator|=
operator|-
literal|1
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|int_pin
operator|=
literal|0
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|apic_address
operator|=
name|NULL
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|redirindex
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|==
literal|0
operator|||
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|==
literal|3
operator|)
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
operator|==
literal|0xff
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
operator|==
name|IO_TO_ID
argument_list|(
name|oldapic
argument_list|)
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|==
name|oldintpin
condition|)
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
operator|=
literal|0xff
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|allocate_apic_irq
parameter_list|(
name|int
name|intr
parameter_list|)
block|{
name|int
name|apic
decl_stmt|;
name|int
name|intpin
decl_stmt|;
name|int
name|irq
decl_stmt|;
if|if
condition|(
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|int_vector
operator|!=
literal|0xff
condition|)
return|return;
comment|/* Interrupt handler already assigned */
if|if
condition|(
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|int_type
operator|!=
literal|0
operator|&&
operator|(
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|int_type
operator|!=
literal|3
operator|||
operator|(
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_id
operator|==
name|IO_TO_ID
argument_list|(
literal|0
argument_list|)
operator|&&
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_int
operator|==
literal|0
operator|)
operator|)
condition|)
return|return;
comment|/* Not INT or ExtInt on != (0, 0) */
name|irq
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|irq
operator|<
name|APIC_INTMAPSIZE
operator|&&
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|ioapic
operator|!=
operator|-
literal|1
condition|)
name|irq
operator|++
expr_stmt|;
if|if
condition|(
name|irq
operator|>=
name|APIC_INTMAPSIZE
condition|)
return|return;
comment|/* No free interrupt handlers */
name|apic
operator|=
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_id
argument_list|)
expr_stmt|;
name|intpin
operator|=
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_int
expr_stmt|;
name|assign_apic_irq
argument_list|(
name|apic
argument_list|,
name|intpin
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|io_apic_setup_intpin
argument_list|(
name|apic
argument_list|,
name|intpin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|swap_apic_id
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|oldid
parameter_list|,
name|int
name|newid
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|oapic
decl_stmt|;
if|if
condition|(
name|oldid
operator|==
name|newid
condition|)
return|return;
comment|/* Nothing to do */
name|printf
argument_list|(
literal|"Changing APIC ID for IO APIC #%d from %d to %d in MP table\n"
argument_list|,
name|apic
argument_list|,
name|oldid
argument_list|,
name|newid
argument_list|)
expr_stmt|;
comment|/* Swap physical APIC IDs in interrupt entries */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
operator|==
name|oldid
condition|)
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
operator|=
name|newid
expr_stmt|;
elseif|else
if|if
condition|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
operator|==
name|newid
condition|)
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
operator|=
name|oldid
expr_stmt|;
block|}
comment|/* Swap physical APIC IDs in IO_TO_ID mappings */
for|for
control|(
name|oapic
operator|=
literal|0
init|;
name|oapic
operator|<
name|mp_napics
condition|;
name|oapic
operator|++
control|)
if|if
condition|(
name|IO_TO_ID
argument_list|(
name|oapic
argument_list|)
operator|==
name|newid
condition|)
break|break;
if|if
condition|(
name|oapic
operator|<
name|mp_napics
condition|)
block|{
name|printf
argument_list|(
literal|"Changing APIC ID for IO APIC #%d from "
literal|"%d to %d in MP table\n"
argument_list|,
name|oapic
argument_list|,
name|newid
argument_list|,
name|oldid
argument_list|)
expr_stmt|;
name|IO_TO_ID
argument_list|(
name|oapic
argument_list|)
operator|=
name|oldid
expr_stmt|;
block|}
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
operator|=
name|newid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fix_id_to_io_mapping
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NAPICID
condition|;
name|x
operator|++
control|)
name|ID_TO_IO
argument_list|(
name|x
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|mp_naps
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|CPU_TO_ID
argument_list|(
name|x
argument_list|)
operator|<
name|NAPICID
condition|)
name|ID_TO_IO
argument_list|(
name|CPU_TO_ID
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_napics
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|IO_TO_ID
argument_list|(
name|x
argument_list|)
operator|<
name|NAPICID
condition|)
name|ID_TO_IO
argument_list|(
name|IO_TO_ID
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|first_free_apic_id
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|freeid
decl_stmt|,
name|x
decl_stmt|;
for|for
control|(
name|freeid
operator|=
literal|0
init|;
name|freeid
operator|<
name|NAPICID
condition|;
name|freeid
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|mp_naps
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|CPU_TO_ID
argument_list|(
name|x
argument_list|)
operator|==
name|freeid
condition|)
break|break;
if|if
condition|(
name|x
operator|<=
name|mp_naps
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_napics
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|IO_TO_ID
argument_list|(
name|x
argument_list|)
operator|==
name|freeid
condition|)
break|break;
if|if
condition|(
name|x
operator|<
name|mp_napics
condition|)
continue|continue;
return|return
name|freeid
return|;
block|}
return|return
name|freeid
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|io_apic_id_acceptable
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
comment|/* Logical CPU number */
name|int
name|oapic
decl_stmt|;
comment|/* Logical IO APIC number for other IO APIC */
if|if
condition|(
name|id
operator|>=
name|NAPICID
condition|)
return|return
literal|0
return|;
comment|/* Out of range */
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<=
name|mp_naps
condition|;
name|cpu
operator|++
control|)
if|if
condition|(
name|CPU_TO_ID
argument_list|(
name|cpu
argument_list|)
operator|==
name|id
condition|)
return|return
literal|0
return|;
comment|/* Conflict with CPU */
for|for
control|(
name|oapic
operator|=
literal|0
init|;
name|oapic
operator|<
name|mp_napics
operator|&&
name|oapic
operator|<
name|apic
condition|;
name|oapic
operator|++
control|)
if|if
condition|(
name|IO_TO_ID
argument_list|(
name|oapic
argument_list|)
operator|==
name|id
condition|)
return|return
literal|0
return|;
comment|/* Conflict with other APIC */
return|return
literal|1
return|;
comment|/* ID is acceptable for IO APIC */
block|}
end_function

begin_comment
comment|/*  * parse an Intel MP specification table  */
end_comment

begin_function
specifier|static
name|void
name|fix_mp_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|bus_0
init|=
literal|0
decl_stmt|;
comment|/* Stop GCC warning */
name|int
name|bus_pci
init|=
literal|0
decl_stmt|;
comment|/* Stop GCC warning */
name|int
name|num_pci_bus
decl_stmt|;
name|int
name|apic
decl_stmt|;
comment|/* IO APIC unit number */
name|int
name|freeid
decl_stmt|;
comment|/* Free physical APIC ID */
name|int
name|physid
decl_stmt|;
comment|/* Current physical IO APIC ID */
comment|/* 	 * Fix mis-numbering of the PCI bus and its INT entries if the BIOS 	 * did it wrong.  The MP spec says that when more than 1 PCI bus 	 * exists the BIOS must begin with bus entries for the PCI bus and use 	 * actual PCI bus numbering.  This implies that when only 1 PCI bus 	 * exists the BIOS can choose to ignore this ordering, and indeed many 	 * MP motherboards do ignore it.  This causes a problem when the PCI 	 * sub-system makes requests of the MP sub-system based on PCI bus 	 * numbers.	So here we look for the situation and renumber the 	 * busses and associated INTs in an effort to "make it right". 	 */
comment|/* find bus 0, PCI bus, count the number of PCI busses */
for|for
control|(
name|num_pci_bus
operator|=
literal|0
operator|,
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_nbusses
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_id
operator|==
literal|0
condition|)
block|{
name|bus_0
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_type
operator|==
name|PCI
condition|)
block|{
operator|++
name|num_pci_bus
expr_stmt|;
name|bus_pci
operator|=
name|x
expr_stmt|;
block|}
block|}
comment|/* 	 * bus_0 == slot of bus with ID of 0 	 * bus_pci == slot of last PCI bus encountered 	 */
comment|/* check the 1 PCI bus case for sanity */
comment|/* if it is number 0 all is well */
if|if
condition|(
name|num_pci_bus
operator|==
literal|1
operator|&&
name|bus_data
index|[
name|bus_pci
index|]
operator|.
name|bus_id
operator|!=
literal|0
condition|)
block|{
comment|/* mis-numbered, swap with whichever bus uses slot 0 */
comment|/* swap the bus entry types */
name|bus_data
index|[
name|bus_pci
index|]
operator|.
name|bus_type
operator|=
name|bus_data
index|[
name|bus_0
index|]
operator|.
name|bus_type
expr_stmt|;
name|bus_data
index|[
name|bus_0
index|]
operator|.
name|bus_type
operator|=
name|PCI
expr_stmt|;
comment|/* swap each relavant INTerrupt entry */
name|id
operator|=
name|bus_data
index|[
name|bus_pci
index|]
operator|.
name|bus_id
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_id
operator|==
name|id
condition|)
block|{
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_id
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_id
operator|==
literal|0
condition|)
block|{
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_id
operator|=
name|id
expr_stmt|;
block|}
block|}
block|}
comment|/* Assign IO APIC IDs. 	 *  	 * First try the existing ID. If a conflict is detected, try 	 * the ID in the MP table.  If a conflict is still detected, find 	 * a free id. 	 * 	 * We cannot use the ID_TO_IO table before all conflicts has been 	 * resolved and the table has been corrected. 	 */
for|for
control|(
name|apic
operator|=
literal|0
init|;
name|apic
operator|<
name|mp_napics
condition|;
operator|++
name|apic
control|)
block|{
comment|/* For all IO APICs */
comment|/* First try to use the value set by the BIOS */
name|physid
operator|=
name|io_apic_get_id
argument_list|(
name|apic
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_apic_id_acceptable
argument_list|(
name|apic
argument_list|,
name|physid
argument_list|)
condition|)
block|{
if|if
condition|(
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
operator|!=
name|physid
condition|)
name|swap_apic_id
argument_list|(
name|apic
argument_list|,
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
argument_list|,
name|physid
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Then check if the value in the MP table is acceptable */
if|if
condition|(
name|io_apic_id_acceptable
argument_list|(
name|apic
argument_list|,
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Last resort, find a free APIC ID and use it */
name|freeid
operator|=
name|first_free_apic_id
argument_list|()
expr_stmt|;
if|if
condition|(
name|freeid
operator|>=
name|NAPICID
condition|)
name|panic
argument_list|(
literal|"No free physical APIC IDs found"
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_apic_id_acceptable
argument_list|(
name|apic
argument_list|,
name|freeid
argument_list|)
condition|)
block|{
name|swap_apic_id
argument_list|(
name|apic
argument_list|,
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
argument_list|,
name|freeid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|panic
argument_list|(
literal|"Free physical APIC ID not usable"
argument_list|)
expr_stmt|;
block|}
name|fix_id_to_io_mapping
argument_list|()
expr_stmt|;
comment|/* detect and fix broken Compaq MP table */
if|if
condition|(
name|apic_int_type
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"APIC_IO: MP table broken: 8259->APIC entry missing!\n"
argument_list|)
expr_stmt|;
name|io_apic_ints
index|[
name|nintrs
index|]
operator|.
name|int_type
operator|=
literal|3
expr_stmt|;
comment|/* ExtInt */
name|io_apic_ints
index|[
name|nintrs
index|]
operator|.
name|int_vector
operator|=
literal|0xff
expr_stmt|;
comment|/* Unassigned */
comment|/* XXX fixme, set src bus id etc, but it doesn't seem to hurt */
name|io_apic_ints
index|[
name|nintrs
index|]
operator|.
name|dst_apic_id
operator|=
name|IO_TO_ID
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|io_apic_ints
index|[
name|nintrs
index|]
operator|.
name|dst_apic_int
operator|=
literal|0
expr_stmt|;
comment|/* Pin 0 */
name|nintrs
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assign low level interrupt handlers */
end_comment

begin_function
specifier|static
name|void
name|setup_apic_irq_mapping
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|int_vector
decl_stmt|;
comment|/* Clear array */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|APIC_INTMAPSIZE
condition|;
name|x
operator|++
control|)
block|{
name|int_to_apicintpin
index|[
name|x
index|]
operator|.
name|ioapic
operator|=
operator|-
literal|1
expr_stmt|;
name|int_to_apicintpin
index|[
name|x
index|]
operator|.
name|int_pin
operator|=
literal|0
expr_stmt|;
name|int_to_apicintpin
index|[
name|x
index|]
operator|.
name|apic_address
operator|=
name|NULL
expr_stmt|;
name|int_to_apicintpin
index|[
name|x
index|]
operator|.
name|redirindex
operator|=
literal|0
expr_stmt|;
block|}
comment|/* First assign ISA/EISA interrupts */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
name|x
operator|++
control|)
block|{
name|int_vector
operator|=
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_irq
expr_stmt|;
if|if
condition|(
name|int_vector
operator|<
name|APIC_INTMAPSIZE
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
operator|==
literal|0xff
operator|&&
name|int_to_apicintpin
index|[
name|int_vector
index|]
operator|.
name|ioapic
operator|==
operator|-
literal|1
operator|&&
operator|(
name|apic_int_is_bus_type
argument_list|(
name|x
argument_list|,
name|ISA
argument_list|)
operator|||
name|apic_int_is_bus_type
argument_list|(
name|x
argument_list|,
name|EISA
argument_list|)
operator|)
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|==
literal|0
condition|)
block|{
name|assign_apic_irq
argument_list|(
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
argument_list|,
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
argument_list|,
name|int_vector
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Assign ExtInt entry if no ISA/EISA interrupt 0 entry */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|==
literal|0
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
operator|==
name|IO_TO_ID
argument_list|(
literal|0
argument_list|)
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
operator|==
literal|0xff
operator|&&
name|int_to_apicintpin
index|[
literal|0
index|]
operator|.
name|ioapic
operator|==
operator|-
literal|1
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|==
literal|3
condition|)
block|{
name|assign_apic_irq
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* PCI interrupt assignment is deferred */
block|}
end_function

begin_function
specifier|static
name|int
name|processor_entry
parameter_list|(
name|proc_entry_ptr
name|entry
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
comment|/* check for usability */
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|cpu_flags
operator|&
name|PROCENTRY_FLAG_EN
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|entry
operator|->
name|apic_id
operator|>=
name|NAPICID
condition|)
name|panic
argument_list|(
literal|"CPU APIC ID out of range (0..%d)"
argument_list|,
name|NAPICID
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* check for BSP flag */
if|if
condition|(
name|entry
operator|->
name|cpu_flags
operator|&
name|PROCENTRY_FLAG_BP
condition|)
block|{
name|boot_cpu_id
operator|=
name|entry
operator|->
name|apic_id
expr_stmt|;
name|CPU_TO_ID
argument_list|(
literal|0
argument_list|)
operator|=
name|entry
operator|->
name|apic_id
expr_stmt|;
name|ID_TO_CPU
argument_list|(
name|entry
operator|->
name|apic_id
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
comment|/* its already been counted */
block|}
comment|/* add another AP to list, if less than max number of CPUs */
elseif|else
if|if
condition|(
name|cpu
operator|<
name|MAXCPU
condition|)
block|{
name|CPU_TO_ID
argument_list|(
name|cpu
argument_list|)
operator|=
name|entry
operator|->
name|apic_id
expr_stmt|;
name|ID_TO_CPU
argument_list|(
name|entry
operator|->
name|apic_id
argument_list|)
operator|=
name|cpu
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bus_entry
parameter_list|(
name|bus_entry_ptr
name|entry
parameter_list|,
name|int
name|bus
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|char
name|c
decl_stmt|,
name|name
index|[
literal|8
index|]
decl_stmt|;
comment|/* encode the name into an index */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|6
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|entry
operator|->
name|bus_type
index|[
name|x
index|]
operator|)
operator|==
literal|' '
condition|)
break|break;
name|name
index|[
name|x
index|]
operator|=
name|c
expr_stmt|;
block|}
name|name
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|lookup_bus_type
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|UNKNOWN_BUSTYPE
condition|)
name|panic
argument_list|(
literal|"unknown bus type: '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bus_data
index|[
name|bus
index|]
operator|.
name|bus_id
operator|=
name|entry
operator|->
name|bus_id
expr_stmt|;
name|bus_data
index|[
name|bus
index|]
operator|.
name|bus_type
operator|=
name|x
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|io_apic_entry
parameter_list|(
name|io_apic_entry_ptr
name|entry
parameter_list|,
name|int
name|apic
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|apic_flags
operator|&
name|IOAPICENTRY_FLAG_EN
operator|)
condition|)
return|return
literal|0
return|;
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
operator|=
name|entry
operator|->
name|apic_id
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|apic_id
operator|<
name|NAPICID
condition|)
name|ID_TO_IO
argument_list|(
name|entry
operator|->
name|apic_id
argument_list|)
operator|=
name|apic
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lookup_bus_type
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|MAX_BUSTYPE
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|bus_type_table
index|[
name|x
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bus_type_table
index|[
name|x
index|]
operator|.
name|type
return|;
return|return
name|UNKNOWN_BUSTYPE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|int_entry
parameter_list|(
name|int_entry_ptr
name|entry
parameter_list|,
name|int
name|intr
parameter_list|)
block|{
name|int
name|apic
decl_stmt|;
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|int_type
operator|=
name|entry
operator|->
name|int_type
expr_stmt|;
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|int_flags
operator|=
name|entry
operator|->
name|int_flags
expr_stmt|;
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|src_bus_id
operator|=
name|entry
operator|->
name|src_bus_id
expr_stmt|;
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|src_bus_irq
operator|=
name|entry
operator|->
name|src_bus_irq
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|dst_apic_id
operator|==
literal|255
condition|)
block|{
comment|/* This signal goes to all IO APICS.  Select an IO APIC 		   with sufficient number of interrupt pins */
for|for
control|(
name|apic
operator|=
literal|0
init|;
name|apic
operator|<
name|mp_napics
condition|;
name|apic
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|io_apic_read
argument_list|(
name|apic
argument_list|,
name|IOAPIC_VER
argument_list|)
operator|&
name|IOART_VER_MAXREDIR
operator|)
operator|>>
name|MAXREDIRSHIFT
operator|)
operator|>=
name|entry
operator|->
name|dst_apic_int
condition|)
break|break;
if|if
condition|(
name|apic
operator|<
name|mp_napics
condition|)
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_id
operator|=
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
expr_stmt|;
else|else
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_id
operator|=
name|entry
operator|->
name|dst_apic_id
expr_stmt|;
block|}
else|else
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_id
operator|=
name|entry
operator|->
name|dst_apic_id
expr_stmt|;
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_int
operator|=
name|entry
operator|->
name|dst_apic_int
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apic_int_is_bus_type
parameter_list|(
name|int
name|intr
parameter_list|,
name|int
name|bus_type
parameter_list|)
block|{
name|int
name|bus
decl_stmt|;
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|bus
operator|<
name|mp_nbusses
condition|;
operator|++
name|bus
control|)
if|if
condition|(
operator|(
name|bus_data
index|[
name|bus
index|]
operator|.
name|bus_id
operator|==
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|src_bus_id
operator|)
operator|&&
operator|(
operator|(
name|int
operator|)
name|bus_data
index|[
name|bus
index|]
operator|.
name|bus_type
operator|==
name|bus_type
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Given a traditional ISA INT mask, return an APIC mask.  */
end_comment

begin_function
name|u_int
name|isa_apic_mask
parameter_list|(
name|u_int
name|isa_mask
parameter_list|)
block|{
name|int
name|isa_irq
decl_stmt|;
name|int
name|apic_pin
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SKIP_IRQ15_REDIRECT
argument_list|)
if|if
condition|(
name|isa_mask
operator|==
operator|(
literal|1
operator|<<
literal|15
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"skipping ISA IRQ15 redirect\n"
argument_list|)
expr_stmt|;
return|return
name|isa_mask
return|;
block|}
endif|#
directive|endif
comment|/* SKIP_IRQ15_REDIRECT */
name|isa_irq
operator|=
name|ffs
argument_list|(
name|isa_mask
argument_list|)
expr_stmt|;
comment|/* find its bit position */
if|if
condition|(
name|isa_irq
operator|==
literal|0
condition|)
comment|/* doesn't exist */
return|return
literal|0
return|;
operator|--
name|isa_irq
expr_stmt|;
comment|/* make it zero based */
name|apic_pin
operator|=
name|isa_apic_irq
argument_list|(
name|isa_irq
argument_list|)
expr_stmt|;
comment|/* look for APIC connection */
if|if
condition|(
name|apic_pin
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
operator|(
literal|1
operator|<<
name|apic_pin
operator|)
return|;
comment|/* convert pin# to a mask */
block|}
end_function

begin_comment
comment|/*  * Determine which APIC pin an ISA/EISA INT is attached to.  */
end_comment

begin_define
define|#
directive|define
name|INTTYPE
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].int_type)
end_define

begin_define
define|#
directive|define
name|INTPIN
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].dst_apic_int)
end_define

begin_define
define|#
directive|define
name|INTIRQ
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].int_vector)
end_define

begin_define
define|#
directive|define
name|INTAPIC
parameter_list|(
name|I
parameter_list|)
value|(ID_TO_IO(io_apic_ints[(I)].dst_apic_id))
end_define

begin_define
define|#
directive|define
name|SRCBUSIRQ
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].src_bus_irq)
end_define

begin_function
name|int
name|isa_apic_irq
parameter_list|(
name|int
name|isa_irq
parameter_list|)
block|{
name|int
name|intr
decl_stmt|;
for|for
control|(
name|intr
operator|=
literal|0
init|;
name|intr
operator|<
name|nintrs
condition|;
operator|++
name|intr
control|)
block|{
comment|/* check each record */
if|if
condition|(
name|INTTYPE
argument_list|(
name|intr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* standard INT */
if|if
condition|(
name|SRCBUSIRQ
argument_list|(
name|intr
argument_list|)
operator|==
name|isa_irq
condition|)
block|{
if|if
condition|(
name|apic_int_is_bus_type
argument_list|(
name|intr
argument_list|,
name|ISA
argument_list|)
operator|||
name|apic_int_is_bus_type
argument_list|(
name|intr
argument_list|,
name|EISA
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTIRQ
argument_list|(
name|intr
argument_list|)
operator|==
literal|0xff
condition|)
return|return
operator|-
literal|1
return|;
comment|/* unassigned */
return|return
name|INTIRQ
argument_list|(
name|intr
argument_list|)
return|;
comment|/* found */
block|}
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_comment
comment|/*  * Determine which APIC pin a PCI INT is attached to.  */
end_comment

begin_define
define|#
directive|define
name|SRCBUSID
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].src_bus_id)
end_define

begin_define
define|#
directive|define
name|SRCBUSDEVICE
parameter_list|(
name|I
parameter_list|)
value|((io_apic_ints[(I)].src_bus_irq>> 2)& 0x1f)
end_define

begin_define
define|#
directive|define
name|SRCBUSLINE
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].src_bus_irq& 0x03)
end_define

begin_function
name|int
name|pci_apic_irq
parameter_list|(
name|int
name|pciBus
parameter_list|,
name|int
name|pciDevice
parameter_list|,
name|int
name|pciInt
parameter_list|)
block|{
name|int
name|intr
decl_stmt|;
operator|--
name|pciInt
expr_stmt|;
comment|/* zero based */
for|for
control|(
name|intr
operator|=
literal|0
init|;
name|intr
operator|<
name|nintrs
condition|;
operator|++
name|intr
control|)
comment|/* check each record */
if|if
condition|(
operator|(
name|INTTYPE
argument_list|(
name|intr
argument_list|)
operator|==
literal|0
operator|)
comment|/* standard INT */
operator|&&
operator|(
name|SRCBUSID
argument_list|(
name|intr
argument_list|)
operator|==
name|pciBus
operator|)
operator|&&
operator|(
name|SRCBUSDEVICE
argument_list|(
name|intr
argument_list|)
operator|==
name|pciDevice
operator|)
operator|&&
operator|(
name|SRCBUSLINE
argument_list|(
name|intr
argument_list|)
operator|==
name|pciInt
operator|)
condition|)
comment|/* a candidate IRQ */
if|if
condition|(
name|apic_int_is_bus_type
argument_list|(
name|intr
argument_list|,
name|PCI
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTIRQ
argument_list|(
name|intr
argument_list|)
operator|==
literal|0xff
condition|)
name|allocate_apic_irq
argument_list|(
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTIRQ
argument_list|(
name|intr
argument_list|)
operator|==
literal|0xff
condition|)
return|return
operator|-
literal|1
return|;
comment|/* unassigned */
return|return
name|INTIRQ
argument_list|(
name|intr
argument_list|)
return|;
comment|/* exact match */
block|}
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_function
name|int
name|next_apic_irq
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|int
name|intr
decl_stmt|,
name|ointr
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|bustype
decl_stmt|;
name|bus
operator|=
literal|0
expr_stmt|;
name|bustype
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|intr
operator|=
literal|0
init|;
name|intr
operator|<
name|nintrs
condition|;
name|intr
operator|++
control|)
block|{
if|if
condition|(
name|INTIRQ
argument_list|(
name|intr
argument_list|)
operator|!=
name|irq
operator|||
name|INTTYPE
argument_list|(
name|intr
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|bus
operator|=
name|SRCBUSID
argument_list|(
name|intr
argument_list|)
expr_stmt|;
name|bustype
operator|=
name|apic_bus_type
argument_list|(
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|bustype
operator|!=
name|ISA
operator|&&
name|bustype
operator|!=
name|EISA
operator|&&
name|bustype
operator|!=
name|PCI
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|intr
operator|>=
name|nintrs
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|ointr
operator|=
name|intr
operator|+
literal|1
init|;
name|ointr
operator|<
name|nintrs
condition|;
name|ointr
operator|++
control|)
block|{
if|if
condition|(
name|INTTYPE
argument_list|(
name|ointr
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|bus
operator|!=
name|SRCBUSID
argument_list|(
name|ointr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|bustype
operator|==
name|PCI
condition|)
block|{
if|if
condition|(
name|SRCBUSDEVICE
argument_list|(
name|intr
argument_list|)
operator|!=
name|SRCBUSDEVICE
argument_list|(
name|ointr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|SRCBUSLINE
argument_list|(
name|intr
argument_list|)
operator|!=
name|SRCBUSLINE
argument_list|(
name|ointr
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|bustype
operator|==
name|ISA
operator|||
name|bustype
operator|==
name|EISA
condition|)
block|{
if|if
condition|(
name|SRCBUSIRQ
argument_list|(
name|intr
argument_list|)
operator|!=
name|SRCBUSIRQ
argument_list|(
name|ointr
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|INTPIN
argument_list|(
name|intr
argument_list|)
operator|==
name|INTPIN
argument_list|(
name|ointr
argument_list|)
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|ointr
operator|>=
name|nintrs
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|INTIRQ
argument_list|(
name|ointr
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|SRCBUSLINE
end_undef

begin_undef
undef|#
directive|undef
name|SRCBUSDEVICE
end_undef

begin_undef
undef|#
directive|undef
name|SRCBUSID
end_undef

begin_undef
undef|#
directive|undef
name|SRCBUSIRQ
end_undef

begin_undef
undef|#
directive|undef
name|INTPIN
end_undef

begin_undef
undef|#
directive|undef
name|INTIRQ
end_undef

begin_undef
undef|#
directive|undef
name|INTAPIC
end_undef

begin_undef
undef|#
directive|undef
name|INTTYPE
end_undef

begin_comment
comment|/*  * Reprogram the MB chipset to NOT redirect an ISA INTerrupt.  *  * XXX FIXME:  *  Exactly what this means is unclear at this point.  It is a solution  *  for motherboards that redirect the MBIRQ0 pin.  Generically a motherboard  *  could route any of the ISA INTs to upper (>15) IRQ values.  But most would  *  NOT be redirected via MBIRQ0, thus "undirect()ing" them would NOT be an  *  option.  */
end_comment

begin_function
name|int
name|undirect_isa_irq
parameter_list|(
name|int
name|rirq
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|READY
argument_list|)
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Freeing redirected ISA irq %d.\n"
argument_list|,
name|rirq
argument_list|)
expr_stmt|;
comment|/** FIXME: tickle the MB redirector chip */
return|return
operator|-
literal|1
return|;
else|#
directive|else
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Freeing (NOT implemented) redirected ISA irq %d.\n"
argument_list|,
name|rirq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* READY */
block|}
end_function

begin_comment
comment|/*  * Reprogram the MB chipset to NOT redirect a PCI INTerrupt  */
end_comment

begin_function
name|int
name|undirect_pci_irq
parameter_list|(
name|int
name|rirq
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|READY
argument_list|)
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Freeing redirected PCI irq %d.\n"
argument_list|,
name|rirq
argument_list|)
expr_stmt|;
comment|/** FIXME: tickle the MB redirector chip */
return|return
operator|-
literal|1
return|;
else|#
directive|else
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Freeing (NOT implemented) redirected PCI irq %d.\n"
argument_list|,
name|rirq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* READY */
block|}
end_function

begin_comment
comment|/*  * given a bus ID, return:  *  the bus type if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_bus_type
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_nbusses
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_id
operator|==
name|id
condition|)
return|return
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_type
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * given a LOGICAL APIC# and pin#, return:  *  the associated src bus ID if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_src_bus_id
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* search each of the possible INTerrupt sources */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
return|return
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_id
operator|)
return|;
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_comment
comment|/*  * given a LOGICAL APIC# and pin#, return:  *  the associated src bus IRQ if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_src_bus_irq
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
name|x
operator|++
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
return|return
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_irq
operator|)
return|;
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_comment
comment|/*  * given a LOGICAL APIC# and pin#, return:  *  the associated INTerrupt type if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_int_type
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* search each of the possible INTerrupt sources */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
return|return
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|)
return|;
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_function
name|int
name|apic_irq
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|res
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
block|{
name|res
operator|=
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0xff
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|apic
operator|!=
name|int_to_apicintpin
index|[
name|res
index|]
operator|.
name|ioapic
condition|)
name|panic
argument_list|(
literal|"apic_irq: inconsistent table"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pin
operator|!=
name|int_to_apicintpin
index|[
name|res
index|]
operator|.
name|int_pin
condition|)
name|panic
argument_list|(
literal|"apic_irq inconsistent table (2)"
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * given a LOGICAL APIC# and pin#, return:  *  the associated trigger mode if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_trigger
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* search each of the possible INTerrupt sources */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
return|return
operator|(
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_flags
operator|>>
literal|2
operator|)
operator|&
literal|0x03
operator|)
return|;
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_comment
comment|/*  * given a LOGICAL APIC# and pin#, return:  *  the associated 'active' level if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_polarity
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* search each of the possible INTerrupt sources */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
return|return
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_flags
operator|&
literal|0x03
operator|)
return|;
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_comment
comment|/*  * set data according to MP defaults  * FIXME: probably not complete yet...  */
end_comment

begin_function
specifier|static
name|void
name|default_mp_table
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|int
name|ap_cpu_id
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
name|int
name|io_apic_id
decl_stmt|;
name|int
name|pin
decl_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
if|#
directive|if
literal|0
block|printf("  MP default config type: %d\n", type); 	switch (type) { 	case 1: 		printf("   bus: ISA, APIC: 82489DX\n"); 		break; 	case 2: 		printf("   bus: EISA, APIC: 82489DX\n"); 		break; 	case 3: 		printf("   bus: EISA, APIC: 82489DX\n"); 		break; 	case 4: 		printf("   bus: MCA, APIC: 82489DX\n"); 		break; 	case 5: 		printf("   bus: ISA+PCI, APIC: Integrated\n"); 		break; 	case 6: 		printf("   bus: EISA+PCI, APIC: Integrated\n"); 		break; 	case 7: 		printf("   bus: MCA+PCI, APIC: Integrated\n"); 		break; 	default: 		printf("   future type\n"); 		break;
comment|/* NOTREACHED */
block|}
endif|#
directive|endif
comment|/* 0 */
name|boot_cpu_id
operator|=
operator|(
name|lapic
operator|.
name|id
operator|&
name|APIC_ID_MASK
operator|)
operator|>>
literal|24
expr_stmt|;
name|ap_cpu_id
operator|=
operator|(
name|boot_cpu_id
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* BSP */
name|CPU_TO_ID
argument_list|(
literal|0
argument_list|)
operator|=
name|boot_cpu_id
expr_stmt|;
name|ID_TO_CPU
argument_list|(
name|boot_cpu_id
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* one and only AP */
name|CPU_TO_ID
argument_list|(
literal|1
argument_list|)
operator|=
name|ap_cpu_id
expr_stmt|;
name|ID_TO_CPU
argument_list|(
name|ap_cpu_id
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
comment|/* one and only IO APIC */
name|io_apic_id
operator|=
operator|(
name|io_apic_read
argument_list|(
literal|0
argument_list|,
name|IOAPIC_ID
argument_list|)
operator|&
name|APIC_ID_MASK
operator|)
operator|>>
literal|24
expr_stmt|;
comment|/* 	 * sanity check, refer to MP spec section 3.6.6, last paragraph 	 * necessary as some hardware isn't properly setting up the IO APIC 	 */
if|#
directive|if
name|defined
argument_list|(
name|REALLY_ANAL_IOAPICID_VALUE
argument_list|)
if|if
condition|(
name|io_apic_id
operator|!=
literal|2
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|io_apic_id
operator|==
literal|0
operator|)
operator|||
operator|(
name|io_apic_id
operator|==
literal|1
operator|)
operator|||
operator|(
name|io_apic_id
operator|==
literal|15
operator|)
condition|)
block|{
endif|#
directive|endif
comment|/* REALLY_ANAL_IOAPICID_VALUE */
name|io_apic_set_id
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|io_apic_id
operator|=
literal|2
expr_stmt|;
block|}
name|IO_TO_ID
argument_list|(
literal|0
argument_list|)
operator|=
name|io_apic_id
expr_stmt|;
name|ID_TO_IO
argument_list|(
name|io_apic_id
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
comment|/* fill out bus entries */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
name|bus_data
index|[
literal|0
index|]
operator|.
name|bus_id
operator|=
name|default_data
index|[
name|type
operator|-
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|bus_data
index|[
literal|0
index|]
operator|.
name|bus_type
operator|=
name|default_data
index|[
name|type
operator|-
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|bus_data
index|[
literal|1
index|]
operator|.
name|bus_id
operator|=
name|default_data
index|[
name|type
operator|-
literal|1
index|]
index|[
literal|3
index|]
expr_stmt|;
name|bus_data
index|[
literal|1
index|]
operator|.
name|bus_type
operator|=
name|default_data
index|[
name|type
operator|-
literal|1
index|]
index|[
literal|4
index|]
expr_stmt|;
break|break;
comment|/* case 4: case 7:		   MCA NOT supported */
default|default:
comment|/* illegal/reserved */
name|panic
argument_list|(
literal|"BAD default MP config: %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
comment|/* general cases from MP v1.4, table 5-2 */
for|for
control|(
name|pin
operator|=
literal|0
init|;
name|pin
operator|<
literal|16
condition|;
operator|++
name|pin
control|)
block|{
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|int_type
operator|=
literal|0
expr_stmt|;
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|int_flags
operator|=
literal|0x05
expr_stmt|;
comment|/* edge/active-hi */
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|src_bus_id
operator|=
literal|0
expr_stmt|;
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|src_bus_irq
operator|=
name|pin
expr_stmt|;
comment|/* IRQ2 caught below */
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|dst_apic_id
operator|=
name|io_apic_id
expr_stmt|;
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|dst_apic_int
operator|=
name|pin
expr_stmt|;
comment|/* 1-to-1 */
block|}
comment|/* special cases from MP v1.4, table 5-2 */
if|if
condition|(
name|type
operator|==
literal|2
condition|)
block|{
name|io_apic_ints
index|[
literal|2
index|]
operator|.
name|int_type
operator|=
literal|0xff
expr_stmt|;
comment|/* N/C */
name|io_apic_ints
index|[
literal|13
index|]
operator|.
name|int_type
operator|=
literal|0xff
expr_stmt|;
comment|/* N/C */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|APIC_MIXED_MODE
argument_list|)
comment|/** FIXME: ??? */
name|panic
argument_list|(
literal|"sorry, can't support type 2 default yet"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APIC_MIXED_MODE */
block|}
else|else
name|io_apic_ints
index|[
literal|2
index|]
operator|.
name|src_bus_irq
operator|=
literal|0
expr_stmt|;
comment|/* ISA IRQ0 is on APIC INT 2 */
if|if
condition|(
name|type
operator|==
literal|7
condition|)
name|io_apic_ints
index|[
literal|0
index|]
operator|.
name|int_type
operator|=
literal|0xff
expr_stmt|;
comment|/* N/C */
else|else
name|io_apic_ints
index|[
literal|0
index|]
operator|.
name|int_type
operator|=
literal|3
expr_stmt|;
comment|/* vectored 8259 */
endif|#
directive|endif
comment|/* APIC_IO */
block|}
comment|/*  * start each AP in our list  */
specifier|static
name|int
name|start_all_aps
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|i
decl_stmt|,
name|pg
decl_stmt|;
name|u_char
name|mpbiosreason
decl_stmt|;
name|u_long
name|mpbioswarmvec
decl_stmt|;
name|struct
name|globaldata
modifier|*
name|gd
decl_stmt|;
name|char
modifier|*
name|stack
decl_stmt|;
name|uintptr_t
name|kptbase
decl_stmt|;
name|POSTCODE
argument_list|(
name|START_ALL_APS_POST
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ap_boot_mtx
argument_list|,
literal|"ap boot"
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* initialize BSP's local APIC */
name|apic_initialize
argument_list|()
expr_stmt|;
name|bsp_apic_ready
operator|=
literal|1
expr_stmt|;
comment|/* install the AP 1st level boot code */
name|install_ap_tramp
argument_list|(
name|boot_addr
argument_list|)
expr_stmt|;
comment|/* save the current value of the warm-start vector */
name|mpbioswarmvec
operator|=
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
name|WARMBOOT_OFF
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
name|outb
argument_list|(
name|CMOS_REG
argument_list|,
name|BIOS_RESET
argument_list|)
expr_stmt|;
name|mpbiosreason
operator|=
name|inb
argument_list|(
name|CMOS_DATA
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* record BSP in CPU map */
name|all_cpus
operator|=
literal|1
expr_stmt|;
comment|/* set up temporary P==V mapping for AP boot */
comment|/* XXX this is a hack, we should boot the AP on its own stack/PTD */
name|kptbase
operator|=
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|KPTphys
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NKPT
condition|;
name|x
operator|++
control|)
name|PTD
index|[
name|x
index|]
operator|=
call|(
name|pd_entry_t
call|)
argument_list|(
name|PG_V
operator||
name|PG_RW
operator||
operator|(
operator|(
name|kptbase
operator|+
name|x
operator|*
name|PAGE_SIZE
operator|)
operator|&
name|PG_FRAME
operator|)
argument_list|)
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
comment|/* start each AP */
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<=
name|mp_naps
condition|;
operator|++
name|x
control|)
block|{
comment|/* This is a bit verbose, it will go away soon.  */
comment|/* first page of AP's private space */
name|pg
operator|=
name|x
operator|*
name|i386_btop
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|privatespace
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allocate a new private data page */
name|gd
operator|=
operator|(
expr|struct
name|globaldata
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* wire it into the private page table page */
name|SMPpt
index|[
name|pg
index|]
operator|=
call|(
name|pt_entry_t
call|)
argument_list|(
name|PG_V
operator||
name|PG_RW
operator||
name|vtophys
argument_list|(
name|gd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allocate and set up an idle stack data page */
name|stack
operator|=
operator|(
name|char
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|UPAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
name|SMPpt
index|[
name|pg
operator|+
literal|1
operator|+
name|i
index|]
operator|=
call|(
name|pt_entry_t
call|)
argument_list|(
name|PG_V
operator||
name|PG_RW
operator||
name|vtophys
argument_list|(
name|PAGE_SIZE
operator|*
name|i
operator|+
name|stack
argument_list|)
argument_list|)
expr_stmt|;
comment|/* prime data page for it to use */
name|gd
operator|->
name|gd_cpuid
operator|=
name|x
expr_stmt|;
name|globaldata_register
argument_list|(
name|gd
argument_list|)
expr_stmt|;
comment|/* setup a vector to our boot code */
operator|*
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|WARMBOOT_OFF
operator|)
operator|=
name|WARMBOOT_TARGET
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|WARMBOOT_SEG
operator|)
operator|=
operator|(
name|boot_addr
operator|>>
literal|4
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
name|outb
argument_list|(
name|CMOS_REG
argument_list|,
name|BIOS_RESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_DATA
argument_list|,
name|BIOS_WARM
argument_list|)
expr_stmt|;
comment|/* 'warm-start' */
endif|#
directive|endif
name|bootSTK
operator|=
operator|&
name|SMP_prvspace
index|[
name|x
index|]
operator|.
name|idlestack
index|[
name|UPAGES
operator|*
name|PAGE_SIZE
index|]
expr_stmt|;
name|bootAP
operator|=
name|x
expr_stmt|;
comment|/* attempt to start the Application Processor */
name|CHECK_INIT
argument_list|(
literal|99
argument_list|)
expr_stmt|;
comment|/* setup checkpoints */
if|if
condition|(
operator|!
name|start_ap
argument_list|(
name|x
argument_list|,
name|boot_addr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"AP #%d (PHY# %d) failed!\n"
argument_list|,
name|x
argument_list|,
name|CPU_TO_ID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_PRINT
argument_list|(
literal|"trace"
argument_list|)
expr_stmt|;
comment|/* show checkpoints */
comment|/* better panic as the AP may be running loose */
name|printf
argument_list|(
literal|"panic y/n? [y] "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cngetc
argument_list|()
operator|!=
literal|'n'
condition|)
name|panic
argument_list|(
literal|"bye-bye"
argument_list|)
expr_stmt|;
block|}
name|CHECK_PRINT
argument_list|(
literal|"trace"
argument_list|)
expr_stmt|;
comment|/* show checkpoints */
comment|/* record its version info */
name|cpu_apic_versions
index|[
name|x
index|]
operator|=
name|cpu_apic_versions
index|[
literal|0
index|]
expr_stmt|;
name|all_cpus
operator||=
operator|(
literal|1
operator|<<
name|x
operator|)
expr_stmt|;
comment|/* record AP in CPU map */
block|}
comment|/* build our map of 'other' CPUs */
name|PCPU_SET
argument_list|(
name|other_cpus
argument_list|,
name|all_cpus
operator|&
operator|~
operator|(
literal|1
operator|<<
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* fill in our (BSP) APIC version */
name|cpu_apic_versions
index|[
literal|0
index|]
operator|=
name|lapic
operator|.
name|version
expr_stmt|;
comment|/* restore the warmstart vector */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|WARMBOOT_OFF
operator|=
name|mpbioswarmvec
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
name|outb
argument_list|(
name|CMOS_REG
argument_list|,
name|BIOS_RESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_DATA
argument_list|,
name|mpbiosreason
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set up the idle context for the BSP.  Similar to above except 	 * that some was done by locore, some by pmap.c and some is implicit 	 * because the BSP is cpu#0 and the page is initially zero, and also 	 * because we can refer to variables by name on the BSP.. 	 */
comment|/* Allocate and setup BSP idle stack */
name|stack
operator|=
operator|(
name|char
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|UPAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
name|SMPpt
index|[
literal|1
operator|+
name|i
index|]
operator|=
call|(
name|pt_entry_t
call|)
argument_list|(
name|PG_V
operator||
name|PG_RW
operator||
name|vtophys
argument_list|(
name|PAGE_SIZE
operator|*
name|i
operator|+
name|stack
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NKPT
condition|;
name|x
operator|++
control|)
name|PTD
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
name|pmap_set_opt
argument_list|()
expr_stmt|;
comment|/* number of APs actually started */
return|return
name|mp_ncpus
operator|-
literal|1
return|;
block|}
comment|/*  * load the 1st level AP boot code into base memory.  */
comment|/* targets for relocation */
specifier|extern
name|void
name|bigJump
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|bootCodeSeg
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|bootDataSeg
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|MPentry
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|extern
name|u_int
name|MP_GDT
decl_stmt|;
specifier|extern
name|u_int
name|mp_gdtbase
decl_stmt|;
specifier|static
name|void
name|install_ap_tramp
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|size
init|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|u_long
operator|)
operator|&
name|bootMP_size
operator|)
decl_stmt|;
name|u_char
modifier|*
name|src
init|=
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|(
name|u_long
operator|)
name|bootMP
operator|)
decl_stmt|;
name|u_char
modifier|*
name|dst
init|=
operator|(
name|u_char
operator|*
operator|)
name|boot_addr
operator|+
name|KERNBASE
decl_stmt|;
name|u_int
name|boot_base
init|=
operator|(
name|u_int
operator|)
name|bootMP
decl_stmt|;
name|u_int8_t
modifier|*
name|dst8
decl_stmt|;
name|u_int16_t
modifier|*
name|dst16
decl_stmt|;
name|u_int32_t
modifier|*
name|dst32
decl_stmt|;
name|POSTCODE
argument_list|(
name|INSTALL_AP_TRAMP_POST
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|size
condition|;
operator|++
name|x
control|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
comment|/* 	 * modify addresses in code we just moved to basemem. unfortunately we 	 * need fairly detailed info about mpboot.s for this to work.  changes 	 * to mpboot.s might require changes here. 	 */
comment|/* boot code is located in KERNEL space */
name|dst
operator|=
operator|(
name|u_char
operator|*
operator|)
name|boot_addr
operator|+
name|KERNBASE
expr_stmt|;
comment|/* modify the lgdt arg */
name|dst32
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|dst
operator|+
operator|(
operator|(
name|u_int
operator|)
operator|&
name|mp_gdtbase
operator|-
name|boot_base
operator|)
operator|)
expr_stmt|;
operator|*
name|dst32
operator|=
name|boot_addr
operator|+
operator|(
operator|(
name|u_int
operator|)
operator|&
name|MP_GDT
operator|-
name|boot_base
operator|)
expr_stmt|;
comment|/* modify the ljmp target for MPentry() */
name|dst32
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|dst
operator|+
operator|(
operator|(
name|u_int
operator|)
name|bigJump
operator|-
name|boot_base
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|dst32
operator|=
operator|(
operator|(
name|u_int
operator|)
name|MPentry
operator|-
name|KERNBASE
operator|)
expr_stmt|;
comment|/* modify the target for boot code segment */
name|dst16
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|dst
operator|+
operator|(
operator|(
name|u_int
operator|)
name|bootCodeSeg
operator|-
name|boot_base
operator|)
operator|)
expr_stmt|;
name|dst8
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|dst16
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|dst16
operator|=
operator|(
name|u_int
operator|)
name|boot_addr
operator|&
literal|0xffff
expr_stmt|;
operator|*
name|dst8
operator|=
operator|(
operator|(
name|u_int
operator|)
name|boot_addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* modify the target for boot data segment */
name|dst16
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|dst
operator|+
operator|(
operator|(
name|u_int
operator|)
name|bootDataSeg
operator|-
name|boot_base
operator|)
operator|)
expr_stmt|;
name|dst8
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|dst16
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|dst16
operator|=
operator|(
name|u_int
operator|)
name|boot_addr
operator|&
literal|0xffff
expr_stmt|;
operator|*
name|dst8
operator|=
operator|(
operator|(
name|u_int
operator|)
name|boot_addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/*  * this function starts the AP (application processor) identified  * by the APIC ID 'physicalCpu'.  It does quite a "song and dance"  * to accomplish this.  This is necessary because of the nuances  * of the different hardware we might encounter.  It ain't pretty,  * but it seems to work.  */
specifier|static
name|int
name|start_ap
parameter_list|(
name|int
name|logical_cpu
parameter_list|,
name|u_int
name|boot_addr
parameter_list|)
block|{
name|int
name|physical_cpu
decl_stmt|;
name|int
name|vector
decl_stmt|;
name|int
name|cpus
decl_stmt|;
name|u_long
name|icr_lo
decl_stmt|,
name|icr_hi
decl_stmt|;
name|POSTCODE
argument_list|(
name|START_AP_POST
argument_list|)
expr_stmt|;
comment|/* get the PHYSICAL APIC ID# */
name|physical_cpu
operator|=
name|CPU_TO_ID
argument_list|(
name|logical_cpu
argument_list|)
expr_stmt|;
comment|/* calculate the vector */
name|vector
operator|=
operator|(
name|boot_addr
operator|>>
literal|12
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* used as a watchpoint to signal AP startup */
name|cpus
operator|=
name|mp_ncpus
expr_stmt|;
comment|/* 	 * first we do an INIT/RESET IPI this INIT IPI might be run, reseting 	 * and running the target CPU. OR this INIT IPI might be latched (P5 	 * bug), CPU waiting for STARTUP IPI. OR this INIT IPI might be 	 * ignored. 	 */
comment|/* setup the address for the target AP */
name|icr_hi
operator|=
name|lapic
operator|.
name|icr_hi
operator|&
operator|~
name|APIC_ID_MASK
expr_stmt|;
name|icr_hi
operator||=
operator|(
name|physical_cpu
operator|<<
literal|24
operator|)
expr_stmt|;
name|lapic
operator|.
name|icr_hi
operator|=
name|icr_hi
expr_stmt|;
comment|/* do an INIT IPI: assert RESET */
name|icr_lo
operator|=
name|lapic
operator|.
name|icr_lo
operator|&
literal|0xfff00000
expr_stmt|;
name|lapic
operator|.
name|icr_lo
operator|=
name|icr_lo
operator||
literal|0x0000c500
expr_stmt|;
comment|/* wait for pending status end */
while|while
condition|(
name|lapic
operator|.
name|icr_lo
operator|&
name|APIC_DELSTAT_MASK
condition|)
comment|/* spin */
empty_stmt|;
comment|/* do an INIT IPI: deassert RESET */
name|lapic
operator|.
name|icr_lo
operator|=
name|icr_lo
operator||
literal|0x00008500
expr_stmt|;
comment|/* wait for pending status end */
name|u_sleep
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* wait ~10mS */
while|while
condition|(
name|lapic
operator|.
name|icr_lo
operator|&
name|APIC_DELSTAT_MASK
condition|)
comment|/* spin */
empty_stmt|;
comment|/* 	 * next we do a STARTUP IPI: the previous INIT IPI might still be 	 * latched, (P5 bug) this 1st STARTUP would then terminate 	 * immediately, and the previously started INIT IPI would continue. OR 	 * the previous INIT IPI has already run. and this STARTUP IPI will 	 * run. OR the previous INIT IPI was ignored. and this STARTUP IPI 	 * will run. 	 */
comment|/* do a STARTUP IPI */
name|lapic
operator|.
name|icr_lo
operator|=
name|icr_lo
operator||
literal|0x00000600
operator||
name|vector
expr_stmt|;
while|while
condition|(
name|lapic
operator|.
name|icr_lo
operator|&
name|APIC_DELSTAT_MASK
condition|)
comment|/* spin */
empty_stmt|;
name|u_sleep
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* wait ~200uS */
comment|/* 	 * finally we do a 2nd STARTUP IPI: this 2nd STARTUP IPI should run IF 	 * the previous STARTUP IPI was cancelled by a latched INIT IPI. OR 	 * this STARTUP IPI will be ignored, as only ONE STARTUP IPI is 	 * recognized after hardware RESET or INIT IPI. 	 */
name|lapic
operator|.
name|icr_lo
operator|=
name|icr_lo
operator||
literal|0x00000600
operator||
name|vector
expr_stmt|;
while|while
condition|(
name|lapic
operator|.
name|icr_lo
operator|&
name|APIC_DELSTAT_MASK
condition|)
comment|/* spin */
empty_stmt|;
name|u_sleep
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* wait ~200uS */
comment|/* wait for it to start */
name|set_apic_timer
argument_list|(
literal|5000000
argument_list|)
expr_stmt|;
comment|/* == 5 seconds */
while|while
condition|(
name|read_apic_timer
argument_list|()
condition|)
if|if
condition|(
name|mp_ncpus
operator|>
name|cpus
condition|)
return|return
literal|1
return|;
comment|/* return SUCCESS */
return|return
literal|0
return|;
comment|/* return FAILURE */
block|}
comment|/*  * Flush the TLB on all other CPU's  *  * XXX: Needs to handshake and wait for completion before proceding.  */
name|void
name|smp_invltlb
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
if|if
condition|(
name|smp_started
operator|&&
name|invltlb_ok
condition|)
name|ipi_all_but_self
argument_list|(
name|IPI_INVLTLB
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
block|}
name|void
name|invlpg
parameter_list|(
name|u_int
name|addr
parameter_list|)
block|{
asm|__asm   __volatile("invlpg (%0)"::"r"(addr):"memory");
comment|/* send a message to the other CPUs */
name|smp_invltlb
argument_list|()
expr_stmt|;
block|}
name|void
name|invltlb
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|temp
decl_stmt|;
comment|/* 	 * This should be implemented as load_cr3(rcr3()) when load_cr3() is 	 * inlined. 	 */
asm|__asm __volatile("movl %%cr3, %0; movl %0, %%cr3":"=r"(temp) :: "memory");
comment|/* send a message to the other CPUs */
name|smp_invltlb
argument_list|()
expr_stmt|;
block|}
comment|/*  * This is called once the rest of the system is up and running and we're  * ready to let the AP's out of the pen.  */
name|void
name|ap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|apic_id
decl_stmt|;
comment|/* spin until all the AP's are ready */
while|while
condition|(
operator|!
name|aps_ready
condition|)
comment|/* spin */
empty_stmt|;
comment|/* 	 * Set curproc to our per-cpu idleproc so that mutexes have 	 * something unique to lock with. 	 */
name|PCPU_SET
argument_list|(
name|curproc
argument_list|,
name|PCPU_GET
argument_list|(
name|idleproc
argument_list|)
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|spinlocks
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* lock against other AP's that are waking up */
name|mtx_lock_spin
argument_list|(
operator|&
name|ap_boot_mtx
argument_list|)
expr_stmt|;
comment|/* BSP may have changed PTD while we're waiting for the lock */
name|cpu_invltlb
argument_list|()
expr_stmt|;
name|smp_cpus
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_F00F_HACK
argument_list|)
name|lidt
argument_list|(
operator|&
name|r_idt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Build our map of 'other' CPUs. */
name|PCPU_SET
argument_list|(
name|other_cpus
argument_list|,
name|all_cpus
operator|&
operator|~
operator|(
literal|1
operator|<<
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: AP CPU #%d Launched!\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set up CPU registers and state */
name|cpu_setregs
argument_list|()
expr_stmt|;
comment|/* set up FPU state on the AP */
name|npxinit
argument_list|(
name|__INITIAL_NPXCW__
argument_list|)
expr_stmt|;
comment|/* A quick check from sanity claus */
name|apic_id
operator|=
operator|(
name|apic_id_to_logical
index|[
operator|(
name|lapic
operator|.
name|id
operator|&
literal|0x0f000000
operator|)
operator|>>
literal|24
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|!=
name|apic_id
condition|)
block|{
name|printf
argument_list|(
literal|"SMP: cpuid = %d\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: apic_id = %d\n"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PTD[MPPTDI] = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|PTD
index|[
name|MPPTDI
index|]
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"cpuid mismatch! boom!!"
argument_list|)
expr_stmt|;
block|}
comment|/* Init local apic for irq's */
name|apic_initialize
argument_list|()
expr_stmt|;
comment|/* Set memory range attributes for this CPU to match the BSP */
name|mem_range_AP_init
argument_list|()
expr_stmt|;
comment|/* 	 * Activate smp_invltlb, although strictly speaking, this isn't 	 * quite correct yet.  We should have a bitfield for cpus willing 	 * to accept TLB flush IPI's or something and sync them. 	 */
if|if
condition|(
name|smp_cpus
operator|==
name|mp_ncpus
condition|)
block|{
name|invltlb_ok
operator|=
literal|1
expr_stmt|;
name|smp_started
operator|=
literal|1
expr_stmt|;
comment|/* enable IPI's, tlb shootdown, freezes etc */
name|smp_active
operator|=
literal|1
expr_stmt|;
comment|/* historic */
block|}
comment|/* let other AP's wake up now */
name|mtx_unlock_spin
argument_list|(
operator|&
name|ap_boot_mtx
argument_list|)
expr_stmt|;
comment|/* wait until all the AP's are up */
while|while
condition|(
name|smp_started
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* nothing */
name|microuptime
argument_list|(
name|PCPU_PTR
argument_list|(
name|switchtime
argument_list|)
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|switchticks
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
comment|/* ok, now grab sched_lock and enter the scheduler */
name|enable_intr
argument_list|()
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|cpu_throw
argument_list|()
expr_stmt|;
comment|/* doesn't return */
name|panic
argument_list|(
literal|"scheduler returned us to ap_init"
argument_list|)
expr_stmt|;
block|}
comment|/*  * For statclock, we send an IPI to all CPU's to have them call this  * function.  */
name|void
name|forwarded_statclock
parameter_list|(
name|struct
name|trapframe
name|frame
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|statclock_process
argument_list|(
name|curproc
argument_list|,
name|TRAPF_PC
argument_list|(
operator|&
name|frame
argument_list|)
argument_list|,
name|TRAPF_USERMODE
argument_list|(
operator|&
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
name|void
name|forward_statclock
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|map
decl_stmt|;
name|CTR0
argument_list|(
name|KTR_SMP
argument_list|,
literal|"forward_statclock"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smp_started
operator|||
operator|!
name|invltlb_ok
operator|||
name|cold
operator|||
name|panicstr
condition|)
return|return;
name|map
operator|=
name|PCPU_GET
argument_list|(
name|other_cpus
argument_list|)
operator|&
operator|~
name|stopped_cpus
expr_stmt|;
if|if
condition|(
name|map
operator|!=
literal|0
condition|)
name|ipi_selected
argument_list|(
name|map
argument_list|,
name|IPI_STATCLOCK
argument_list|)
expr_stmt|;
block|}
comment|/*  * For each hardclock(), we send an IPI to all other CPU's to have them  * execute this function.  It would be nice to reduce contention on  * sched_lock if we could simply peek at the CPU to determine the user/kernel  * state and call hardclock_process() on the CPU receiving the clock interrupt  * and then just use a simple IPI to handle any ast's if needed.  */
name|void
name|forwarded_hardclock
parameter_list|(
name|struct
name|trapframe
name|frame
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|hardclock_process
argument_list|(
name|curproc
argument_list|,
name|TRAPF_USERMODE
argument_list|(
operator|&
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
name|void
name|forward_hardclock
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|map
decl_stmt|;
name|CTR0
argument_list|(
name|KTR_SMP
argument_list|,
literal|"forward_hardclock"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smp_started
operator|||
operator|!
name|invltlb_ok
operator|||
name|cold
operator|||
name|panicstr
condition|)
return|return;
name|map
operator|=
name|PCPU_GET
argument_list|(
name|other_cpus
argument_list|)
operator|&
operator|~
name|stopped_cpus
expr_stmt|;
if|if
condition|(
name|map
operator|!=
literal|0
condition|)
name|ipi_selected
argument_list|(
name|map
argument_list|,
name|IPI_HARDCLOCK
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|APIC_INTR_REORDER
comment|/*  *	Maintain mapping from softintr vector to isr bit in local apic.  */
name|void
name|set_lapic_isrloc
parameter_list|(
name|int
name|intr
parameter_list|,
name|int
name|vector
parameter_list|)
block|{
if|if
condition|(
name|intr
operator|<
literal|0
operator|||
name|intr
operator|>
literal|32
condition|)
name|panic
argument_list|(
literal|"set_apic_isrloc: bad intr argument: %d"
argument_list|,
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vector
operator|<
name|ICU_OFFSET
operator|||
name|vector
operator|>
literal|255
condition|)
name|panic
argument_list|(
literal|"set_apic_isrloc: bad vector argument: %d"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
name|apic_isrbit_location
index|[
name|intr
index|]
operator|.
name|location
operator|=
operator|&
name|lapic
operator|.
name|isr0
operator|+
operator|(
operator|(
name|vector
operator|>>
literal|5
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|apic_isrbit_location
index|[
name|intr
index|]
operator|.
name|bit
operator|=
operator|(
literal|1
operator|<<
operator|(
name|vector
operator|&
literal|31
operator|)
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*  * send an IPI to a set of cpus.  */
name|void
name|ipi_selected
parameter_list|(
name|u_int32_t
name|cpus
parameter_list|,
name|u_int
name|ipi
parameter_list|)
block|{
name|CTR2
argument_list|(
name|KTR_SMP
argument_list|,
name|__func__
literal|": cpus: %x ipi: %x"
argument_list|,
name|cpus
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
name|selected_apic_ipi
argument_list|(
name|cpus
argument_list|,
name|ipi
argument_list|,
name|APIC_DELMODE_FIXED
argument_list|)
expr_stmt|;
block|}
comment|/*  * send an IPI INTerrupt containing 'vector' to all CPUs, including myself  */
name|void
name|ipi_all
parameter_list|(
name|u_int
name|ipi
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_SMP
argument_list|,
name|__func__
literal|": ipi: %x"
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
name|apic_ipi
argument_list|(
name|APIC_DEST_ALLISELF
argument_list|,
name|ipi
argument_list|,
name|APIC_DELMODE_FIXED
argument_list|)
expr_stmt|;
block|}
comment|/*  * send an IPI to all CPUs EXCEPT myself  */
name|void
name|ipi_all_but_self
parameter_list|(
name|u_int
name|ipi
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_SMP
argument_list|,
name|__func__
literal|": ipi: %x"
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
name|apic_ipi
argument_list|(
name|APIC_DEST_ALLESELF
argument_list|,
name|ipi
argument_list|,
name|APIC_DELMODE_FIXED
argument_list|)
expr_stmt|;
block|}
comment|/*  * send an IPI to myself  */
name|void
name|ipi_self
parameter_list|(
name|u_int
name|ipi
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_SMP
argument_list|,
name|__func__
literal|": ipi: %x"
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
name|apic_ipi
argument_list|(
name|APIC_DEST_SELF
argument_list|,
name|ipi
argument_list|,
name|APIC_DELMODE_FIXED
argument_list|)
expr_stmt|;
block|}
name|void
name|release_aps
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|atomic_store_rel_int
argument_list|(
operator|&
name|aps_ready
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|SYSINIT
argument_list|(
name|start_aps
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|release_aps
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_function

end_unit

