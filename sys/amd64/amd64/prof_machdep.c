begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1996 Bruce D. Evans.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: prof_machdep.c,v 1.6 1997/02/22 09:36:59 peter Exp $  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GUPROF
end_ifdef

begin_include
include|#
directive|include
file|"opt_i586_guprof.h"
end_include

begin_include
include|#
directive|include
file|"opt_perfmon.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/gmon.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/perfmon.h>
end_include

begin_include
include|#
directive|include
file|<machine/profile.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<pc98/pc98/pc98.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/isa/timerreg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GUPROF
end_ifdef

begin_define
define|#
directive|define
name|CPUTIME_CLOCK_UNINITIALIZED
value|0
end_define

begin_define
define|#
directive|define
name|CPUTIME_CLOCK_I8254
value|1
end_define

begin_define
define|#
directive|define
name|CPUTIME_CLOCK_I586_CTR
value|2
end_define

begin_define
define|#
directive|define
name|CPUTIME_CLOCK_I586_PMC
value|3
end_define

begin_define
define|#
directive|define
name|CPUTIME_CLOCK_I8254_SHIFT
value|7
end_define

begin_decl_stmt
name|int
name|cputime_bias
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initialize for locality of reference */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cputime_clock
init|=
name|CPUTIME_CLOCK_UNINITIALIZED
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|I586_PMC_GUPROF
end_ifdef

begin_decl_stmt
specifier|static
name|u_int
name|cputime_clock_pmc_conf
init|=
name|I586_PMC_GUPROF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cputime_clock_pmc_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|gmonparam
name|saved_gmp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GUPROF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_asm
asm|asm(" GM_STATE	=	0 GMON_PROF_OFF	=	3  	.text 	.align	4,0x90 	.globl	__mcount __mcount: 	# 	# Check that we are profiling.  Do it early for speed. 	# 	cmpl	$GMON_PROF_OFF,__gmonparam+GM_STATE  	je	Lmcount_exit  	#  	# __mcount is the same as mcount except the caller hasn't changed  	# the stack except to call here, so the caller's raddr is above  	# our raddr.  	#  	movl	4(%esp),%edx  	jmp	Lgot_frompc    	.align	4,0x90  	.globl	mcount mcount: 	cmpl	$GMON_PROF_OFF,__gmonparam+GM_STATE 	je	Lmcount_exit 	# 	# The caller's stack frame has already been built, so %ebp is 	# the caller's frame pointer.  The caller's raddr is in the 	# caller's frame following the caller's caller's frame pointer. 	# 	movl	4(%ebp),%edx Lgot_frompc: 	# 	# Our raddr is the caller's pc. 	# 	movl	(%esp),%eax  	pushfl 	pushl	%eax 	pushl	%edx 	cli 	call	_mcount 	addl	$8,%esp 	popfl Lmcount_exit: 	ret ");
end_asm

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__GNUC__ */
end_comment

begin_error
error|#
directive|error
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GNUC__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GUPROF
end_ifdef

begin_comment
comment|/*  * mexitcount saves the return register(s), loads selfpc and calls  * mexitcount(selfpc) to do the work.  Someday it should be in a machine  * dependent file together with cputime(), __mcount and mcount.  cputime()  * can't just be put in machdep.c because it has to be compiled without -pg.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_asm
asm|asm(" 	.text # # Dummy label to be seen when gprof -u hides mexitcount. # 	.align	4,0x90 	.globl	__mexitcount __mexitcount: 	nop  GMON_PROF_HIRES	=	4  	.align	4,0x90 	.globl	mexitcount mexitcount: 	cmpl	$GMON_PROF_HIRES,__gmonparam+GM_STATE 	jne	Lmexitcount_exit 	pushl	%edx 	pushl	%eax 	movl	8(%esp),%eax 	pushfl 	pushl	%eax 	cli 	call	_mexitcount 	addl	$4,%esp 	popfl 	popl	%eax 	popl	%edx Lmexitcount_exit: 	ret ");
end_asm

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__GNUC__ */
end_comment

begin_error
error|#
directive|error
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GNUC__ */
end_comment

begin_comment
comment|/*  * Return the time elapsed since the last call.  The units are machine-  * dependent.  */
end_comment

begin_function
name|int
name|cputime
parameter_list|()
block|{
name|u_int
name|count
decl_stmt|;
name|int
name|delta
decl_stmt|;
ifdef|#
directive|ifdef
name|I586_PMC_GUPROF
name|u_quad_t
name|event_count
decl_stmt|;
endif|#
directive|endif
name|u_char
name|high
decl_stmt|,
name|low
decl_stmt|;
specifier|static
name|u_int
name|prev_count
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|||
name|defined
argument_list|(
name|I686_CPU
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
if|if
condition|(
name|cputime_clock
operator|==
name|CPUTIME_CLOCK_I586_CTR
condition|)
block|{
name|count
operator|=
operator|(
name|u_int
operator|)
name|rdtsc
argument_list|()
expr_stmt|;
name|delta
operator|=
call|(
name|int
call|)
argument_list|(
name|count
operator|-
name|prev_count
argument_list|)
expr_stmt|;
name|prev_count
operator|=
name|count
expr_stmt|;
return|return
operator|(
name|delta
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PERFMON
argument_list|)
operator|&&
name|defined
argument_list|(
name|I586_PMC_GUPROF
argument_list|)
if|if
condition|(
name|cputime_clock
operator|==
name|CPUTIME_CLOCK_I586_PMC
condition|)
block|{
comment|/* 		 * XXX permon_read() should be inlined so that the 		 * perfmon module doesn't need to be compiled with 		 * profiling disabled and so that it is fast. 		 */
name|perfmon_read
argument_list|(
literal|0
argument_list|,
operator|&
name|event_count
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
name|u_int
operator|)
name|event_count
expr_stmt|;
name|delta
operator|=
call|(
name|int
call|)
argument_list|(
name|count
operator|-
name|prev_count
argument_list|)
expr_stmt|;
name|prev_count
operator|=
name|count
expr_stmt|;
return|return
operator|(
name|delta
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* PERFMON&& I586_PMC_GUPROF */
endif|#
directive|endif
comment|/* (I586_CPU || I686_CPU)&& !SMP */
comment|/* 	 * Read the current value of the 8254 timer counter 0. 	 */
name|outb
argument_list|(
name|TIMER_MODE
argument_list|,
name|TIMER_SEL0
operator||
name|TIMER_LATCH
argument_list|)
expr_stmt|;
name|low
operator|=
name|inb
argument_list|(
name|TIMER_CNTR0
argument_list|)
expr_stmt|;
name|high
operator|=
name|inb
argument_list|(
name|TIMER_CNTR0
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
name|high
operator|<<
literal|8
operator|)
operator||
name|low
operator|)
operator|<<
name|CPUTIME_CLOCK_I8254_SHIFT
expr_stmt|;
comment|/* 	 * The timer counts down from TIMER_CNTR0_MAX to 0 and then resets. 	 * While profiling is enabled, this routine is called at least twice 	 * per timer reset (for mcounting and mexitcounting hardclock()), 	 * so at most one reset has occurred since the last call, and one 	 * has occurred iff the current count is larger than the previous 	 * count.  This allows counter underflow to be detected faster 	 * than in microtime(). 	 */
name|delta
operator|=
name|prev_count
operator|-
name|count
expr_stmt|;
name|prev_count
operator|=
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|delta
operator|<=
literal|0
condition|)
return|return
operator|(
name|delta
operator|+
operator|(
name|timer0_max_count
operator|<<
name|CPUTIME_CLOCK_I8254_SHIFT
operator|)
operator|)
return|;
return|return
operator|(
name|delta
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|sysctl_machdep_cputime_clock
name|SYSCTL_HANDLER_ARGS
block|{
name|int
name|clock
decl_stmt|;
name|int
name|event
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|pmc
name|pmc
decl_stmt|;
name|clock
operator|=
name|cputime_clock
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PERFMON
argument_list|)
operator|&&
name|defined
argument_list|(
name|I586_PMC_GUPROF
argument_list|)
if|if
condition|(
name|clock
operator|==
name|CPUTIME_CLOCK_I586_PMC
condition|)
block|{
name|pmc
operator|.
name|pmc_val
operator|=
name|cputime_clock_pmc_conf
expr_stmt|;
name|clock
operator|+=
name|pmc
operator|.
name|pmc_event
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|sysctl_handle_opaque
argument_list|(
name|oidp
argument_list|,
operator|&
name|clock
argument_list|,
sizeof|sizeof
name|clock
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PERFMON
argument_list|)
operator|&&
name|defined
argument_list|(
name|I586_PMC_GUPROF
argument_list|)
if|if
condition|(
name|clock
operator|>=
name|CPUTIME_CLOCK_I586_PMC
condition|)
block|{
name|event
operator|=
name|clock
operator|-
name|CPUTIME_CLOCK_I586_PMC
expr_stmt|;
if|if
condition|(
name|event
operator|>=
literal|256
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pmc
operator|.
name|pmc_num
operator|=
literal|0
expr_stmt|;
name|pmc
operator|.
name|pmc_event
operator|=
name|event
expr_stmt|;
name|pmc
operator|.
name|pmc_unit
operator|=
literal|0
expr_stmt|;
name|pmc
operator|.
name|pmc_flags
operator|=
name|PMCF_E
operator||
name|PMCF_OS
operator||
name|PMCF_USR
expr_stmt|;
name|pmc
operator|.
name|pmc_mask
operator|=
literal|0
expr_stmt|;
name|cputime_clock_pmc_conf
operator|=
name|pmc
operator|.
name|pmc_val
expr_stmt|;
name|cputime_clock
operator|=
name|CPUTIME_CLOCK_I586_PMC
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|clock
operator|<
literal|0
operator|||
name|clock
operator|>=
name|CPUTIME_CLOCK_I586_PMC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cputime_clock
operator|=
name|clock
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|cputime_clock
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|,
name|sysctl_machdep_cputime_clock
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The start and stop routines need not be here since we turn off profiling  * before calling them.  They are here for convenience.  */
end_comment

begin_function
name|void
name|startguprof
parameter_list|(
name|gp
parameter_list|)
name|struct
name|gmonparam
modifier|*
name|gp
decl_stmt|;
block|{
if|if
condition|(
name|cputime_clock
operator|==
name|CPUTIME_CLOCK_UNINITIALIZED
condition|)
block|{
name|cputime_clock
operator|=
name|CPUTIME_CLOCK_I8254
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|||
name|defined
argument_list|(
name|I686_CPU
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
if|if
condition|(
name|i586_ctr_freq
operator|!=
literal|0
condition|)
name|cputime_clock
operator|=
name|CPUTIME_CLOCK_I586_CTR
expr_stmt|;
endif|#
directive|endif
block|}
name|gp
operator|->
name|profrate
operator|=
name|timer_freq
operator|<<
name|CPUTIME_CLOCK_I8254_SHIFT
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|||
name|defined
argument_list|(
name|I686_CPU
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
if|if
condition|(
name|cputime_clock
operator|==
name|CPUTIME_CLOCK_I586_CTR
condition|)
name|gp
operator|->
name|profrate
operator|=
name|i586_ctr_freq
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PERFMON
argument_list|)
operator|&&
name|defined
argument_list|(
name|I586_PMC_GUPROF
argument_list|)
elseif|else
if|if
condition|(
name|cputime_clock
operator|==
name|CPUTIME_CLOCK_I586_PMC
condition|)
block|{
if|if
condition|(
name|perfmon_avail
argument_list|()
operator|&&
name|perfmon_setup
argument_list|(
literal|0
argument_list|,
name|cputime_clock_pmc_conf
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|perfmon_start
argument_list|(
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|perfmon_fini
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* XXX 1 event == 1 us. */
name|gp
operator|->
name|profrate
operator|=
literal|1000000
expr_stmt|;
name|saved_gmp
operator|=
operator|*
name|gp
expr_stmt|;
comment|/* Zap overheads.  They are invalid. */
name|gp
operator|->
name|cputime_overhead
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|mcount_overhead
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|mcount_post_overhead
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|mcount_pre_overhead
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|mexitcount_overhead
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|mexitcount_post_overhead
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|mexitcount_pre_overhead
operator|=
literal|0
expr_stmt|;
name|cputime_clock_pmc_init
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* PERFMON&& I586_PMC_GUPROF */
endif|#
directive|endif
comment|/* (I586_CPU || I686_CPU)&& !SMP */
name|cputime_bias
operator|=
literal|0
expr_stmt|;
name|cputime
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stopguprof
parameter_list|(
name|gp
parameter_list|)
name|struct
name|gmonparam
modifier|*
name|gp
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|PERFMON
argument_list|)
operator|&&
name|defined
argument_list|(
name|I586_PMC_GUPROF
argument_list|)
if|if
condition|(
name|cputime_clock_pmc_init
condition|)
block|{
operator|*
name|gp
operator|=
name|saved_gmp
expr_stmt|;
name|perfmon_fini
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cputime_clock_pmc_init
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !GUPROF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_asm
asm|asm(" 	.text 	.align	4,0x90 	.globl	mexitcount mexitcount: 	ret ");
end_asm

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__GNUC__ */
end_comment

begin_error
error|#
directive|error
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GNUC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GUPROF */
end_comment

end_unit

