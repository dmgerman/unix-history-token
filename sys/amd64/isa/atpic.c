begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 John Baldwin<jhb@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * PIC driver for the 8259A Master and Slave PICs in PC/AT machines.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_auto_eoi.h"
end_include

begin_include
include|#
directive|include
file|"opt_isa.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/i8259.h>
end_include

begin_include
include|#
directive|include
file|<amd64/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<amd64/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_define
define|#
directive|define
name|MASTER
value|0
end_define

begin_define
define|#
directive|define
name|SLAVE
value|1
end_define

begin_comment
comment|/*  * PC-AT machines wire the slave PIC to pin 2 on the master PIC.  */
end_comment

begin_define
define|#
directive|define
name|ICU_SLAVEID
value|2
end_define

begin_comment
comment|/*  * Determine the base master and slave modes not including auto EOI support.  * All machines that FreeBSD supports use 8086 mode.  */
end_comment

begin_define
define|#
directive|define
name|BASE_MASTER_MODE
value|ICW4_8086
end_define

begin_define
define|#
directive|define
name|BASE_SLAVE_MODE
value|ICW4_8086
end_define

begin_comment
comment|/* Enable automatic EOI if requested. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_EOI_1
end_ifdef

begin_define
define|#
directive|define
name|MASTER_MODE
value|(BASE_MASTER_MODE | ICW4_AEOI)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MASTER_MODE
value|BASE_MASTER_MODE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_EOI_2
end_ifdef

begin_define
define|#
directive|define
name|SLAVE_MODE
value|(BASE_SLAVE_MODE | ICW4_AEOI)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SLAVE_MODE
value|BASE_SLAVE_MODE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IRQ_MASK
parameter_list|(
name|irq
parameter_list|)
value|(1<< (irq))
end_define

begin_define
define|#
directive|define
name|IMEN_MASK
parameter_list|(
name|ai
parameter_list|)
value|(IRQ_MASK((ai)->at_irq))
end_define

begin_define
define|#
directive|define
name|NUM_ISA_IRQS
value|16
end_define

begin_function_decl
specifier|static
name|void
name|atpic_init
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|unsigned
name|int
name|imen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|inthand_t
name|IDTVEC
argument_list|(
name|atpic_intr0
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|atpic_intr1
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|atpic_intr2
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|atpic_intr3
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|atpic_intr4
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|atpic_intr5
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|atpic_intr6
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|atpic_intr7
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|atpic_intr8
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|atpic_intr9
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|atpic_intr10
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|atpic_intr11
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|atpic_intr12
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|atpic_intr13
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|atpic_intr14
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|atpic_intr15
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IRQ
parameter_list|(
name|ap
parameter_list|,
name|ai
parameter_list|)
value|((ap)->at_irqbase + (ai)->at_irq)
end_define

begin_define
define|#
directive|define
name|ATPIC
parameter_list|(
name|io
parameter_list|,
name|base
parameter_list|,
name|eoi
parameter_list|,
name|imenptr
parameter_list|)
define|\
value|{ { atpic_enable_source, atpic_disable_source, (eoi),		\ 	    atpic_enable_intr, atpic_vector, atpic_source_pending, NULL, \ 	    atpic_resume, atpic_config_intr }, (io), (base),		\ 	    IDT_IO_INTS + (base), (imenptr) }
end_define

begin_define
define|#
directive|define
name|INTSRC
parameter_list|(
name|irq
parameter_list|)
define|\
value|{ {&atpics[(irq) / 8].at_pic }, IDTVEC(atpic_intr ## irq ),	\ 	    (irq) % 8 }
end_define

begin_struct
struct|struct
name|atpic
block|{
name|struct
name|pic
name|at_pic
decl_stmt|;
name|int
name|at_ioaddr
decl_stmt|;
name|int
name|at_irqbase
decl_stmt|;
name|uint8_t
name|at_intbase
decl_stmt|;
name|uint8_t
modifier|*
name|at_imen
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|atpic_intsrc
block|{
name|struct
name|intsrc
name|at_intsrc
decl_stmt|;
name|inthand_t
modifier|*
name|at_intr
decl_stmt|;
name|int
name|at_irq
decl_stmt|;
comment|/* Relative to PIC base. */
name|enum
name|intr_trigger
name|at_trigger
decl_stmt|;
name|u_long
name|at_count
decl_stmt|;
name|u_long
name|at_straycount
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|atpic_enable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atpic_disable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|int
name|eoi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atpic_eoi_master
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atpic_eoi_slave
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atpic_enable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atpic_vector
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atpic_resume
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atpic_source_pending
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atpic_config_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i8259_init
parameter_list|(
name|struct
name|atpic
modifier|*
name|pic
parameter_list|,
name|int
name|slave
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|atpic
name|atpics
index|[]
init|=
block|{
name|ATPIC
argument_list|(
name|IO_ICU1
argument_list|,
literal|0
argument_list|,
name|atpic_eoi_master
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|imen
argument_list|)
block|,
name|ATPIC
argument_list|(
argument|IO_ICU2
argument_list|,
literal|8
argument_list|,
argument|atpic_eoi_slave
argument_list|,
argument|((uint8_t *)&imen) +
literal|1
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|atpic_intsrc
name|atintrs
index|[]
init|=
block|{
name|INTSRC
argument_list|(
literal|0
argument_list|)
block|,
name|INTSRC
argument_list|(
literal|1
argument_list|)
block|,
name|INTSRC
argument_list|(
literal|2
argument_list|)
block|,
name|INTSRC
argument_list|(
literal|3
argument_list|)
block|,
name|INTSRC
argument_list|(
literal|4
argument_list|)
block|,
name|INTSRC
argument_list|(
literal|5
argument_list|)
block|,
name|INTSRC
argument_list|(
literal|6
argument_list|)
block|,
name|INTSRC
argument_list|(
literal|7
argument_list|)
block|,
name|INTSRC
argument_list|(
literal|8
argument_list|)
block|,
name|INTSRC
argument_list|(
literal|9
argument_list|)
block|,
name|INTSRC
argument_list|(
literal|10
argument_list|)
block|,
name|INTSRC
argument_list|(
literal|11
argument_list|)
block|,
name|INTSRC
argument_list|(
literal|12
argument_list|)
block|,
name|INTSRC
argument_list|(
literal|13
argument_list|)
block|,
name|INTSRC
argument_list|(
literal|14
argument_list|)
block|,
name|INTSRC
argument_list|(
literal|15
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|atintrs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|atintrs
index|[
literal|0
index|]
argument_list|)
operator|==
name|NUM_ISA_IRQS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|__inline
name|void
name|_atpic_eoi_master
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|isrc
operator|->
name|is_pic
operator|==
operator|&
name|atpics
index|[
name|MASTER
index|]
operator|.
name|at_pic
argument_list|,
operator|(
literal|"%s: mismatched pic"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|AUTO_EOI_1
name|outb
argument_list|(
name|atpics
index|[
name|MASTER
index|]
operator|.
name|at_ioaddr
argument_list|,
name|OCW2_EOI
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * The data sheet says no auto-EOI on slave, but it sometimes works.  * So, if AUTO_EOI_2 is enabled, we use it.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|_atpic_eoi_slave
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|isrc
operator|->
name|is_pic
operator|==
operator|&
name|atpics
index|[
name|SLAVE
index|]
operator|.
name|at_pic
argument_list|,
operator|(
literal|"%s: mismatched pic"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|AUTO_EOI_2
name|outb
argument_list|(
name|atpics
index|[
name|SLAVE
index|]
operator|.
name|at_ioaddr
argument_list|,
name|OCW2_EOI
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|AUTO_EOI_1
name|outb
argument_list|(
name|atpics
index|[
name|MASTER
index|]
operator|.
name|at_ioaddr
argument_list|,
name|OCW2_EOI
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|atpic_enable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|atpic_intsrc
modifier|*
name|ai
init|=
operator|(
expr|struct
name|atpic_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|struct
name|atpic
modifier|*
name|ap
init|=
operator|(
expr|struct
name|atpic
operator|*
operator|)
name|isrc
operator|->
name|is_pic
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|->
name|at_imen
operator|&
name|IMEN_MASK
argument_list|(
name|ai
argument_list|)
condition|)
block|{
operator|*
name|ap
operator|->
name|at_imen
operator|&=
operator|~
name|IMEN_MASK
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ap
operator|->
name|at_ioaddr
operator|+
name|ICU_IMR_OFFSET
argument_list|,
operator|*
name|ap
operator|->
name|at_imen
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atpic_disable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|int
name|eoi
parameter_list|)
block|{
name|struct
name|atpic_intsrc
modifier|*
name|ai
init|=
operator|(
expr|struct
name|atpic_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|struct
name|atpic
modifier|*
name|ap
init|=
operator|(
expr|struct
name|atpic
operator|*
operator|)
name|isrc
operator|->
name|is_pic
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|at_trigger
operator|!=
name|INTR_TRIGGER_EDGE
condition|)
block|{
operator|*
name|ap
operator|->
name|at_imen
operator||=
name|IMEN_MASK
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ap
operator|->
name|at_ioaddr
operator|+
name|ICU_IMR_OFFSET
argument_list|,
operator|*
name|ap
operator|->
name|at_imen
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Take care to call these functions directly instead of through 	 * a function pointer.  All of the referenced variables should 	 * still be hot in the cache. 	 */
if|if
condition|(
name|eoi
operator|==
name|PIC_EOI
condition|)
block|{
if|if
condition|(
name|isrc
operator|->
name|is_pic
operator|==
operator|&
name|atpics
index|[
name|MASTER
index|]
operator|.
name|at_pic
condition|)
name|_atpic_eoi_master
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
else|else
name|_atpic_eoi_slave
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atpic_eoi_master
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|AUTO_EOI_1
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
name|_atpic_eoi_master
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|atpic_eoi_slave
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|AUTO_EOI_2
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
name|_atpic_eoi_slave
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|atpic_enable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|atpic_vector
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|atpic_intsrc
modifier|*
name|ai
init|=
operator|(
expr|struct
name|atpic_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|struct
name|atpic
modifier|*
name|ap
init|=
operator|(
expr|struct
name|atpic
operator|*
operator|)
name|isrc
operator|->
name|is_pic
decl_stmt|;
return|return
operator|(
name|IRQ
argument_list|(
name|ap
argument_list|,
name|ai
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atpic_source_pending
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|atpic_intsrc
modifier|*
name|ai
init|=
operator|(
expr|struct
name|atpic_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|struct
name|atpic
modifier|*
name|ap
init|=
operator|(
expr|struct
name|atpic
operator|*
operator|)
name|isrc
operator|->
name|is_pic
decl_stmt|;
return|return
operator|(
name|inb
argument_list|(
name|ap
operator|->
name|at_ioaddr
argument_list|)
operator|&
name|IMEN_MASK
argument_list|(
name|ai
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atpic_resume
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|atpic_intsrc
modifier|*
name|ai
init|=
operator|(
expr|struct
name|atpic_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|struct
name|atpic
modifier|*
name|ap
init|=
operator|(
expr|struct
name|atpic
operator|*
operator|)
name|isrc
operator|->
name|is_pic
decl_stmt|;
if|if
condition|(
name|ai
operator|->
name|at_irq
operator|==
literal|0
condition|)
block|{
name|i8259_init
argument_list|(
name|ap
argument_list|,
name|ap
operator|==
operator|&
name|atpics
index|[
name|SLAVE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
operator|&
name|atpics
index|[
name|SLAVE
index|]
operator|&&
name|elcr_found
condition|)
name|elcr_resume
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|atpic_config_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
block|{
name|struct
name|atpic_intsrc
modifier|*
name|ai
init|=
operator|(
expr|struct
name|atpic_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|u_int
name|vector
decl_stmt|;
comment|/* Map conforming values to edge/hi and sanity check the values. */
if|if
condition|(
name|trig
operator|==
name|INTR_TRIGGER_CONFORM
condition|)
name|trig
operator|=
name|INTR_TRIGGER_EDGE
expr_stmt|;
if|if
condition|(
name|pol
operator|==
name|INTR_POLARITY_CONFORM
condition|)
name|pol
operator|=
name|INTR_POLARITY_HIGH
expr_stmt|;
name|vector
operator|=
name|atpic_vector
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|trig
operator|==
name|INTR_TRIGGER_EDGE
operator|&&
name|pol
operator|==
name|INTR_POLARITY_LOW
operator|)
operator|||
operator|(
name|trig
operator|==
name|INTR_TRIGGER_LEVEL
operator|&&
name|pol
operator|==
name|INTR_POLARITY_HIGH
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"atpic: Mismatched config for IRQ%u: trigger %s, polarity %s\n"
argument_list|,
name|vector
argument_list|,
name|trig
operator|==
name|INTR_TRIGGER_EDGE
condition|?
literal|"edge"
else|:
literal|"level"
argument_list|,
name|pol
operator|==
name|INTR_POLARITY_HIGH
condition|?
literal|"high"
else|:
literal|"low"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* If there is no change, just return. */
if|if
condition|(
name|ai
operator|->
name|at_trigger
operator|==
name|trig
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Certain IRQs can never be level/lo, so don't try to set them 	 * that way if asked.  At least some ELCR registers ignore setting 	 * these bits as well. 	 */
if|if
condition|(
operator|(
name|vector
operator|==
literal|0
operator|||
name|vector
operator|==
literal|1
operator|||
name|vector
operator|==
literal|2
operator|||
name|vector
operator|==
literal|13
operator|)
operator|&&
name|trig
operator|==
name|INTR_TRIGGER_LEVEL
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"atpic: Ignoring invalid level/low configuration for IRQ%u\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|elcr_found
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"atpic: No ELCR to configure IRQ%u as %s\n"
argument_list|,
name|vector
argument_list|,
name|trig
operator|==
name|INTR_TRIGGER_EDGE
condition|?
literal|"edge/high"
else|:
literal|"level/low"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"atpic: Programming IRQ%u as %s\n"
argument_list|,
name|vector
argument_list|,
name|trig
operator|==
name|INTR_TRIGGER_EDGE
condition|?
literal|"edge/high"
else|:
literal|"level/low"
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
name|elcr_write_trigger
argument_list|(
name|atpic_vector
argument_list|(
name|isrc
argument_list|)
argument_list|,
name|trig
argument_list|)
expr_stmt|;
name|ai
operator|->
name|at_trigger
operator|=
name|trig
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i8259_init
parameter_list|(
name|struct
name|atpic
modifier|*
name|pic
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|int
name|imr_addr
decl_stmt|;
comment|/* Reset the PIC and program with next four bytes. */
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|pic
operator|->
name|at_ioaddr
argument_list|,
name|ICW1_RESET
operator||
name|ICW1_IC4
argument_list|)
expr_stmt|;
name|imr_addr
operator|=
name|pic
operator|->
name|at_ioaddr
operator|+
name|ICU_IMR_OFFSET
expr_stmt|;
comment|/* Start vector. */
name|outb
argument_list|(
name|imr_addr
argument_list|,
name|pic
operator|->
name|at_intbase
argument_list|)
expr_stmt|;
comment|/* 	 * Setup slave links.  For the master pic, indicate what line 	 * the slave is configured on.  For the slave indicate 	 * which line on the master we are connected to. 	 */
if|if
condition|(
name|slave
condition|)
name|outb
argument_list|(
name|imr_addr
argument_list|,
name|ICU_SLAVEID
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|imr_addr
argument_list|,
name|IRQ_MASK
argument_list|(
name|ICU_SLAVEID
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set mode. */
if|if
condition|(
name|slave
condition|)
name|outb
argument_list|(
name|imr_addr
argument_list|,
name|SLAVE_MODE
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|imr_addr
argument_list|,
name|MASTER_MODE
argument_list|)
expr_stmt|;
comment|/* Set interrupt enable mask. */
name|outb
argument_list|(
name|imr_addr
argument_list|,
operator|*
name|pic
operator|->
name|at_imen
argument_list|)
expr_stmt|;
comment|/* Reset is finished, default to IRR on read. */
name|outb
argument_list|(
name|pic
operator|->
name|at_ioaddr
argument_list|,
name|OCW3_SEL
operator||
name|OCW3_RR
argument_list|)
expr_stmt|;
comment|/* OCW2_L1 sets priority order to 3-7, 0-2 (com2 first). */
if|if
condition|(
operator|!
name|slave
condition|)
name|outb
argument_list|(
name|pic
operator|->
name|at_ioaddr
argument_list|,
name|OCW2_R
operator||
name|OCW2_SL
operator||
name|OCW2_L1
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|atpic_startup
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|atpic_intsrc
modifier|*
name|ai
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Start off with all interrupts disabled. */
name|imen
operator|=
literal|0xffff
expr_stmt|;
name|i8259_init
argument_list|(
operator|&
name|atpics
index|[
name|MASTER
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i8259_init
argument_list|(
operator|&
name|atpics
index|[
name|SLAVE
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|atpic_enable_source
argument_list|(
operator|(
expr|struct
name|intsrc
operator|*
operator|)
operator|&
name|atintrs
index|[
name|ICU_SLAVEID
index|]
argument_list|)
expr_stmt|;
comment|/* Install low-level interrupt handlers for all of our IRQs. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ai
operator|=
name|atintrs
init|;
name|i
operator|<
name|NUM_ISA_IRQS
condition|;
name|i
operator|++
operator|,
name|ai
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|ICU_SLAVEID
condition|)
continue|continue;
name|ai
operator|->
name|at_intsrc
operator|.
name|is_count
operator|=
operator|&
name|ai
operator|->
name|at_count
expr_stmt|;
name|ai
operator|->
name|at_intsrc
operator|.
name|is_straycount
operator|=
operator|&
name|ai
operator|->
name|at_straycount
expr_stmt|;
name|setidt
argument_list|(
operator|(
operator|(
expr|struct
name|atpic
operator|*
operator|)
name|ai
operator|->
name|at_intsrc
operator|.
name|is_pic
operator|)
operator|->
name|at_intbase
operator|+
name|ai
operator|->
name|at_irq
argument_list|,
name|ai
operator|->
name|at_intr
argument_list|,
name|SDT_SYSIGT
argument_list|,
name|SEL_KPL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Look for an ELCR.  If we find one, update the trigger modes. 	 * If we don't find one, assume that IRQs 0, 1, 2, and 13 are 	 * edge triggered and that everything else is level triggered. 	 * We only use the trigger information to reprogram the ELCR if 	 * we have one and as an optimization to avoid masking edge 	 * triggered interrupts.  For the case that we don't have an ELCR, 	 * it doesn't hurt to mask an edge triggered interrupt, so we 	 * assume level trigger for any interrupt that we aren't sure is 	 * edge triggered. 	 */
if|if
condition|(
name|elcr_found
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ai
operator|=
name|atintrs
init|;
name|i
operator|<
name|NUM_ISA_IRQS
condition|;
name|i
operator|++
operator|,
name|ai
operator|++
control|)
name|ai
operator|->
name|at_trigger
operator|=
name|elcr_read_trigger
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ai
operator|=
name|atintrs
init|;
name|i
operator|<
name|NUM_ISA_IRQS
condition|;
name|i
operator|++
operator|,
name|ai
operator|++
control|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|8
case|:
case|case
literal|13
case|:
name|ai
operator|->
name|at_trigger
operator|=
name|INTR_TRIGGER_EDGE
expr_stmt|;
break|break;
default|default:
name|ai
operator|->
name|at_trigger
operator|=
name|INTR_TRIGGER_LEVEL
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|atpic_init
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|struct
name|atpic_intsrc
modifier|*
name|ai
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * If any of the ISA IRQs have an interrupt source already, then 	 * assume that the APICs are being used and don't register any 	 * of our interrupt sources.  This makes sure we don't accidentally 	 * use mixed mode.  The "accidental" use could otherwise occur on 	 * machines that route the ACPI SCI interrupt to a different ISA 	 * IRQ (at least one machines routes it to IRQ 13) thus disabling 	 * that APIC ISA routing and allowing the ATPIC source for that IRQ 	 * to leak through.  We used to depend on this feature for routing 	 * IRQ0 via mixed mode, but now we don't use mixed mode at all. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ISA_IRQS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|intr_lookup_source
argument_list|(
name|i
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
comment|/* Loop through all interrupt sources and add them. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ai
operator|=
name|atintrs
init|;
name|i
operator|<
name|NUM_ISA_IRQS
condition|;
name|i
operator|++
operator|,
name|ai
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|ICU_SLAVEID
condition|)
continue|continue;
name|intr_register_source
argument_list|(
operator|&
name|ai
operator|->
name|at_intsrc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|atpic_init
argument_list|,
argument|SI_SUB_INTR
argument_list|,
argument|SI_ORDER_SECOND +
literal|1
argument_list|,
argument|atpic_init
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_function
name|void
name|atpic_handle_intr
parameter_list|(
name|u_int
name|vector
parameter_list|,
name|struct
name|trapframe
name|frame
parameter_list|)
block|{
name|struct
name|intsrc
modifier|*
name|isrc
decl_stmt|;
name|KASSERT
argument_list|(
name|vector
operator|<
name|NUM_ISA_IRQS
argument_list|,
operator|(
literal|"unknown int %u\n"
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
name|isrc
operator|=
operator|&
name|atintrs
index|[
name|vector
index|]
operator|.
name|at_intsrc
expr_stmt|;
comment|/* 	 * If we don't have an event, see if this is a spurious 	 * interrupt. 	 */
if|if
condition|(
name|isrc
operator|->
name|is_event
operator|==
name|NULL
operator|&&
operator|(
name|vector
operator|==
literal|7
operator|||
name|vector
operator|==
literal|15
operator|)
condition|)
block|{
name|int
name|port
decl_stmt|,
name|isr
decl_stmt|;
comment|/* 		 * Read the ISR register to see if IRQ 7/15 is really 		 * pending.  Reset read register back to IRR when done. 		 */
name|port
operator|=
operator|(
operator|(
expr|struct
name|atpic
operator|*
operator|)
name|isrc
operator|->
name|is_pic
operator|)
operator|->
name|at_ioaddr
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|OCW3_SEL
operator||
name|OCW3_RR
operator||
name|OCW3_RIS
argument_list|)
expr_stmt|;
name|isr
operator|=
name|inb
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|OCW3_SEL
operator||
name|OCW3_RR
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isr
operator|&
name|IRQ_MASK
argument_list|(
literal|7
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
name|intr_execute_handlers
argument_list|(
name|isrc
argument_list|,
operator|&
name|frame
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_ISA
end_ifdef

begin_comment
comment|/*  * Bus attachment for the ISA PIC.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|isa_pnp_id
name|atpic_ids
index|[]
init|=
block|{
block|{
literal|0x0000d041
comment|/* PNP0000 */
block|,
literal|"AT interrupt controller"
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|atpic_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|result
operator|=
name|ISA_PNP_PROBE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|atpic_ids
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<=
literal|0
condition|)
name|device_quiet
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We might be granted IRQ 2, as this is typically consumed by chaining  * between the two PIC components.  If we're using the APIC, however,  * this may not be the case, and as such we should free the resource.  * (XXX untested)  *  * The generic ISA attachment code will handle allocating any other resources  * that we don't explicitly claim here.  */
end_comment

begin_function
specifier|static
name|int
name|atpic_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|rid
decl_stmt|;
comment|/* Try to allocate our IRQ and then free it. */
name|rid
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|atpic_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|atpic_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|atpic_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|atpic_driver
init|=
block|{
literal|"atpic"
block|,
name|atpic_methods
block|,
literal|1
block|,
comment|/* no softc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|atpic_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|atpic
argument_list|,
name|isa
argument_list|,
name|atpic_driver
argument_list|,
name|atpic_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|atpic
argument_list|,
name|acpi
argument_list|,
name|atpic_driver
argument_list|,
name|atpic_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Return a bitmap of the current interrupt requests.  This is 8259-specific  * and is only suitable for use at probe time.  */
end_comment

begin_function
name|intrmask_t
name|isa_irq_pending
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|irr1
decl_stmt|;
name|u_char
name|irr2
decl_stmt|;
name|irr1
operator|=
name|inb
argument_list|(
name|IO_ICU1
argument_list|)
expr_stmt|;
name|irr2
operator|=
name|inb
argument_list|(
name|IO_ICU2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|irr2
operator|<<
literal|8
operator|)
operator||
name|irr1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_ISA */
end_comment

end_unit

