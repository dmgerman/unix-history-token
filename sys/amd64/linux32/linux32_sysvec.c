begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 Tim J. Robbins  * Copyright (c) 2003 Peter Wemm  * Copyright (c) 2002 Doug Rabson  * Copyright (c) 1998-1999 Andrew Gallatin  * Copyright (c) 1994-1996 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX we use functions that might not exist. */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|COMPAT_43
end_ifndef

begin_error
error|#
directive|error
literal|"Unable to compile Linux-emulator due to missing COMPAT_43 option!"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COMPAT_IA32
end_ifndef

begin_error
error|#
directive|error
literal|"Unable to compile Linux-emulator due to missing COMPAT_IA32 option!"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|__ELF_WORD_SIZE
value|32
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_elf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<amd64/linux32/linux.h>
end_include

begin_include
include|#
directive|include
file|<amd64/linux32/linux32_proto.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_mib.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_signal.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_util.h>
end_include

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|linux
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|linux
argument_list|,
name|sysvmsg
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|linux
argument_list|,
name|sysvsem
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|linux
argument_list|,
name|sysvshm
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_LINUX
argument_list|,
literal|"linux"
argument_list|,
literal|"Linux mode structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|AUXARGS_ENTRY_32
parameter_list|(
name|pos
parameter_list|,
name|id
parameter_list|,
name|val
parameter_list|)
define|\
value|do {				\ 		suword32(pos++, id);	\ 		suword32(pos++, val);	\ 	} while (0)
end_define

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
end_if

begin_define
define|#
directive|define
name|SHELLMAGIC
value|0x2123
end_define

begin_comment
comment|/* #! */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SHELLMAGIC
value|0x2321
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allow the sendsig functions to use the ldebug() facility  * even though they are not syscalls themselves. Map them  * to syscall 0. This is slightly less bogus than using  * ldebug(sigreturn).  */
end_comment

begin_define
define|#
directive|define
name|LINUX_SYS_linux_rt_sendsig
value|0
end_define

begin_define
define|#
directive|define
name|LINUX_SYS_linux_sendsig
value|0
end_define

begin_decl_stmt
specifier|extern
name|char
name|linux_sigcode
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|linux_szsigcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sysent
name|linux_sysent
index|[
name|LINUX_SYS_MAXSYSCALL
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SET_DECLARE
argument_list|(
name|linux_ioctl_handler_set
argument_list|,
expr|struct
name|linux_ioctl_handler
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|elf_linux_fixup
parameter_list|(
name|register_t
modifier|*
modifier|*
name|stack_base
parameter_list|,
name|struct
name|image_params
modifier|*
name|iparams
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|register_t
modifier|*
name|linux_copyout_strings
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|linux_prepsyscall
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|,
name|int
modifier|*
name|args
parameter_list|,
name|u_int
modifier|*
name|code
parameter_list|,
name|caddr_t
modifier|*
name|params
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|linux_sendsig
parameter_list|(
name|sig_t
name|catcher
parameter_list|,
name|int
name|sig
parameter_list|,
name|sigset_t
modifier|*
name|mask
parameter_list|,
name|u_long
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exec_linux_setregs
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_long
name|entry
parameter_list|,
name|u_long
name|stack
parameter_list|,
name|u_long
name|ps_strings
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|linux32_fixlimits
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Linux syscalls return negative errno's, we do positive and map them  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bsd_to_linux_errno
index|[
name|ELAST
operator|+
literal|1
index|]
init|=
block|{
operator|-
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|,
operator|-
literal|3
block|,
operator|-
literal|4
block|,
operator|-
literal|5
block|,
operator|-
literal|6
block|,
operator|-
literal|7
block|,
operator|-
literal|8
block|,
operator|-
literal|9
block|,
operator|-
literal|10
block|,
operator|-
literal|35
block|,
operator|-
literal|12
block|,
operator|-
literal|13
block|,
operator|-
literal|14
block|,
operator|-
literal|15
block|,
operator|-
literal|16
block|,
operator|-
literal|17
block|,
operator|-
literal|18
block|,
operator|-
literal|19
block|,
operator|-
literal|20
block|,
operator|-
literal|21
block|,
operator|-
literal|22
block|,
operator|-
literal|23
block|,
operator|-
literal|24
block|,
operator|-
literal|25
block|,
operator|-
literal|26
block|,
operator|-
literal|27
block|,
operator|-
literal|28
block|,
operator|-
literal|29
block|,
operator|-
literal|30
block|,
operator|-
literal|31
block|,
operator|-
literal|32
block|,
operator|-
literal|33
block|,
operator|-
literal|34
block|,
operator|-
literal|11
block|,
operator|-
literal|115
block|,
operator|-
literal|114
block|,
operator|-
literal|88
block|,
operator|-
literal|89
block|,
operator|-
literal|90
block|,
operator|-
literal|91
block|,
operator|-
literal|92
block|,
operator|-
literal|93
block|,
operator|-
literal|94
block|,
operator|-
literal|95
block|,
operator|-
literal|96
block|,
operator|-
literal|97
block|,
operator|-
literal|98
block|,
operator|-
literal|99
block|,
operator|-
literal|100
block|,
operator|-
literal|101
block|,
operator|-
literal|102
block|,
operator|-
literal|103
block|,
operator|-
literal|104
block|,
operator|-
literal|105
block|,
operator|-
literal|106
block|,
operator|-
literal|107
block|,
operator|-
literal|108
block|,
operator|-
literal|109
block|,
operator|-
literal|110
block|,
operator|-
literal|111
block|,
operator|-
literal|40
block|,
operator|-
literal|36
block|,
operator|-
literal|112
block|,
operator|-
literal|113
block|,
operator|-
literal|39
block|,
operator|-
literal|11
block|,
operator|-
literal|87
block|,
operator|-
literal|122
block|,
operator|-
literal|116
block|,
operator|-
literal|66
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|37
block|,
operator|-
literal|38
block|,
operator|-
literal|9
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|43
block|,
operator|-
literal|42
block|,
operator|-
literal|75
block|,
operator|-
literal|6
block|,
operator|-
literal|84
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bsd_to_linux_signal
index|[
name|LINUX_SIGTBLSZ
index|]
init|=
block|{
name|LINUX_SIGHUP
block|,
name|LINUX_SIGINT
block|,
name|LINUX_SIGQUIT
block|,
name|LINUX_SIGILL
block|,
name|LINUX_SIGTRAP
block|,
name|LINUX_SIGABRT
block|,
literal|0
block|,
name|LINUX_SIGFPE
block|,
name|LINUX_SIGKILL
block|,
name|LINUX_SIGBUS
block|,
name|LINUX_SIGSEGV
block|,
name|LINUX_SIGSYS
block|,
name|LINUX_SIGPIPE
block|,
name|LINUX_SIGALRM
block|,
name|LINUX_SIGTERM
block|,
name|LINUX_SIGURG
block|,
name|LINUX_SIGSTOP
block|,
name|LINUX_SIGTSTP
block|,
name|LINUX_SIGCONT
block|,
name|LINUX_SIGCHLD
block|,
name|LINUX_SIGTTIN
block|,
name|LINUX_SIGTTOU
block|,
name|LINUX_SIGIO
block|,
name|LINUX_SIGXCPU
block|,
name|LINUX_SIGXFSZ
block|,
name|LINUX_SIGVTALRM
block|,
name|LINUX_SIGPROF
block|,
name|LINUX_SIGWINCH
block|,
literal|0
block|,
name|LINUX_SIGUSR1
block|,
name|LINUX_SIGUSR2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linux_to_bsd_signal
index|[
name|LINUX_SIGTBLSZ
index|]
init|=
block|{
name|SIGHUP
block|,
name|SIGINT
block|,
name|SIGQUIT
block|,
name|SIGILL
block|,
name|SIGTRAP
block|,
name|SIGABRT
block|,
name|SIGBUS
block|,
name|SIGFPE
block|,
name|SIGKILL
block|,
name|SIGUSR1
block|,
name|SIGSEGV
block|,
name|SIGUSR2
block|,
name|SIGPIPE
block|,
name|SIGALRM
block|,
name|SIGTERM
block|,
name|SIGBUS
block|,
name|SIGCHLD
block|,
name|SIGCONT
block|,
name|SIGSTOP
block|,
name|SIGTSTP
block|,
name|SIGTTIN
block|,
name|SIGTTOU
block|,
name|SIGURG
block|,
name|SIGXCPU
block|,
name|SIGXFSZ
block|,
name|SIGVTALRM
block|,
name|SIGPROF
block|,
name|SIGWINCH
block|,
name|SIGIO
block|,
name|SIGURG
block|,
name|SIGSYS
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LINUX_T_UNKNOWN
value|255
end_define

begin_decl_stmt
specifier|static
name|int
name|_bsd_to_linux_trapcode
index|[]
init|=
block|{
name|LINUX_T_UNKNOWN
block|,
comment|/* 0 */
literal|6
block|,
comment|/* 1  T_PRIVINFLT */
name|LINUX_T_UNKNOWN
block|,
comment|/* 2 */
literal|3
block|,
comment|/* 3  T_BPTFLT */
name|LINUX_T_UNKNOWN
block|,
comment|/* 4 */
name|LINUX_T_UNKNOWN
block|,
comment|/* 5 */
literal|16
block|,
comment|/* 6  T_ARITHTRAP */
literal|254
block|,
comment|/* 7  T_ASTFLT */
name|LINUX_T_UNKNOWN
block|,
comment|/* 8 */
literal|13
block|,
comment|/* 9  T_PROTFLT */
literal|1
block|,
comment|/* 10 T_TRCTRAP */
name|LINUX_T_UNKNOWN
block|,
comment|/* 11 */
literal|14
block|,
comment|/* 12 T_PAGEFLT */
name|LINUX_T_UNKNOWN
block|,
comment|/* 13 */
literal|17
block|,
comment|/* 14 T_ALIGNFLT */
name|LINUX_T_UNKNOWN
block|,
comment|/* 15 */
name|LINUX_T_UNKNOWN
block|,
comment|/* 16 */
name|LINUX_T_UNKNOWN
block|,
comment|/* 17 */
literal|0
block|,
comment|/* 18 T_DIVIDE */
literal|2
block|,
comment|/* 19 T_NMI */
literal|4
block|,
comment|/* 20 T_OFLOW */
literal|5
block|,
comment|/* 21 T_BOUND */
literal|7
block|,
comment|/* 22 T_DNA */
literal|8
block|,
comment|/* 23 T_DOUBLEFLT */
literal|9
block|,
comment|/* 24 T_FPOPFLT */
literal|10
block|,
comment|/* 25 T_TSSFLT */
literal|11
block|,
comment|/* 26 T_SEGNPFLT */
literal|12
block|,
comment|/* 27 T_STKFLT */
literal|18
block|,
comment|/* 28 T_MCHK */
literal|19
block|,
comment|/* 29 T_XMMFLT */
literal|15
comment|/* 30 T_RESERVED */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|bsd_to_linux_trapcode
parameter_list|(
name|code
parameter_list|)
define|\
value|((code)<sizeof(_bsd_to_linux_trapcode)/sizeof(*_bsd_to_linux_trapcode)? \      _bsd_to_linux_trapcode[(code)]: \      LINUX_T_UNKNOWN)
end_define

begin_struct
struct|struct
name|linux32_ps_strings
block|{
name|u_int32_t
name|ps_argvstr
decl_stmt|;
comment|/* first of 0 or more argument strings */
name|u_int
name|ps_nargvstr
decl_stmt|;
comment|/* the number of argument strings */
name|u_int32_t
name|ps_envstr
decl_stmt|;
comment|/* first of 0 or more environment strings */
name|u_int
name|ps_nenvstr
decl_stmt|;
comment|/* the number of environment strings */
block|}
struct|;
end_struct

begin_comment
comment|/*  * If FreeBSD& Linux have a difference of opinion about what a trap  * means, deal with it here.  *  * MPSAFE  */
end_comment

begin_function
specifier|static
name|int
name|translate_traps
parameter_list|(
name|int
name|signal
parameter_list|,
name|int
name|trap_code
parameter_list|)
block|{
if|if
condition|(
name|signal
operator|!=
name|SIGBUS
condition|)
return|return
name|signal
return|;
switch|switch
condition|(
name|trap_code
condition|)
block|{
case|case
name|T_PROTFLT
case|:
case|case
name|T_TSSFLT
case|:
case|case
name|T_DOUBLEFLT
case|:
case|case
name|T_PAGEFLT
case|:
return|return
name|SIGSEGV
return|;
default|default:
return|return
name|signal
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|elf_linux_fixup
parameter_list|(
name|register_t
modifier|*
modifier|*
name|stack_base
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
name|Elf32_Auxargs
modifier|*
name|args
decl_stmt|;
name|Elf32_Addr
modifier|*
name|base
decl_stmt|;
name|Elf32_Addr
modifier|*
name|pos
decl_stmt|;
name|KASSERT
argument_list|(
name|curthread
operator|->
name|td_proc
operator|==
name|imgp
operator|->
name|proc
operator|&&
operator|(
name|curthread
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_SA
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"unsafe elf_linux_fixup(), should be curproc"
operator|)
argument_list|)
expr_stmt|;
name|base
operator|=
operator|(
name|Elf32_Addr
operator|*
operator|)
operator|*
name|stack_base
expr_stmt|;
name|args
operator|=
operator|(
name|Elf32_Auxargs
operator|*
operator|)
name|imgp
operator|->
name|auxargs
expr_stmt|;
name|pos
operator|=
name|base
operator|+
operator|(
name|imgp
operator|->
name|args
operator|->
name|argc
operator|+
name|imgp
operator|->
name|args
operator|->
name|envc
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|trace
condition|)
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_DEBUG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|execfd
operator|!=
operator|-
literal|1
condition|)
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_EXECFD
argument_list|,
name|args
operator|->
name|execfd
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_PHDR
argument_list|,
name|args
operator|->
name|phdr
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_PHENT
argument_list|,
name|args
operator|->
name|phent
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_PHNUM
argument_list|,
name|args
operator|->
name|phnum
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_PAGESZ
argument_list|,
name|args
operator|->
name|pagesz
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_FLAGS
argument_list|,
name|args
operator|->
name|flags
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_ENTRY
argument_list|,
name|args
operator|->
name|entry
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_BASE
argument_list|,
name|args
operator|->
name|base
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_UID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_ucred
operator|->
name|cr_ruid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_EUID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_ucred
operator|->
name|cr_svuid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_GID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_ucred
operator|->
name|cr_rgid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_EGID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_ucred
operator|->
name|cr_svgid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imgp
operator|->
name|auxargs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|auxargs
operator|=
name|NULL
expr_stmt|;
name|base
operator|--
expr_stmt|;
name|suword32
argument_list|(
name|base
argument_list|,
operator|(
name|uint32_t
operator|)
name|imgp
operator|->
name|args
operator|->
name|argc
argument_list|)
expr_stmt|;
operator|*
name|stack_base
operator|=
operator|(
name|register_t
operator|*
operator|)
name|base
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|_ucodesel
decl_stmt|,
name|_ucode32sel
decl_stmt|,
name|_udatasel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|linux_sznonrtsigcode
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|linux_rt_sendsig
parameter_list|(
name|sig_t
name|catcher
parameter_list|,
name|int
name|sig
parameter_list|,
name|sigset_t
modifier|*
name|mask
parameter_list|,
name|u_long
name|code
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|sigacts
modifier|*
name|psp
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|regs
decl_stmt|;
name|struct
name|l_rt_sigframe
modifier|*
name|fp
decl_stmt|,
name|frame
decl_stmt|;
name|int
name|oonstack
decl_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|psp
operator|=
name|p
operator|->
name|p_sigacts
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|psp
operator|->
name|ps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|regs
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
name|oonstack
operator|=
name|sigonstack
argument_list|(
name|regs
operator|->
name|tf_rsp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|rt_sendsig
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|rt_sendsig
argument_list|,
literal|"%p, %d, %p, %lu"
argument_list|)
argument_list|,
name|catcher
argument_list|,
name|sig
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mask
argument_list|,
name|code
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate space for the signal handler context. 	 */
if|if
condition|(
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_ALTSTACK
operator|)
operator|&&
operator|!
name|oonstack
operator|&&
name|SIGISMEMBER
argument_list|(
name|psp
operator|->
name|ps_sigonstack
argument_list|,
name|sig
argument_list|)
condition|)
block|{
name|fp
operator|=
operator|(
expr|struct
name|l_rt_sigframe
operator|*
operator|)
operator|(
name|td
operator|->
name|td_sigstk
operator|.
name|ss_sp
operator|+
name|td
operator|->
name|td_sigstk
operator|.
name|ss_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|l_rt_sigframe
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|fp
operator|=
operator|(
expr|struct
name|l_rt_sigframe
operator|*
operator|)
name|regs
operator|->
name|tf_rsp
operator|-
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|psp
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Build the argument list for the signal handler. 	 */
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_sigtbl
condition|)
if|if
condition|(
name|sig
operator|<=
name|p
operator|->
name|p_sysent
operator|->
name|sv_sigsize
condition|)
name|sig
operator|=
name|p
operator|->
name|p_sysent
operator|->
name|sv_sigtbl
index|[
name|_SIG_IDX
argument_list|(
name|sig
argument_list|)
index|]
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|frame
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_handler
operator|=
name|PTROUT
argument_list|(
name|catcher
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_sig
operator|=
name|sig
expr_stmt|;
name|frame
operator|.
name|sf_siginfo
operator|=
name|PTROUT
argument_list|(
operator|&
name|fp
operator|->
name|sf_si
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_ucontext
operator|=
name|PTROUT
argument_list|(
operator|&
name|fp
operator|->
name|sf_sc
argument_list|)
expr_stmt|;
comment|/* Fill in POSIX parts */
name|frame
operator|.
name|sf_si
operator|.
name|lsi_signo
operator|=
name|sig
expr_stmt|;
name|frame
operator|.
name|sf_si
operator|.
name|lsi_code
operator|=
name|code
expr_stmt|;
name|frame
operator|.
name|sf_si
operator|.
name|lsi_addr
operator|=
name|PTROUT
argument_list|(
name|regs
operator|->
name|tf_err
argument_list|)
expr_stmt|;
comment|/* 	 * Build the signal context to be used by sigreturn. 	 */
name|frame
operator|.
name|sf_sc
operator|.
name|uc_flags
operator|=
literal|0
expr_stmt|;
comment|/* XXX ??? */
name|frame
operator|.
name|sf_sc
operator|.
name|uc_link
operator|=
literal|0
expr_stmt|;
comment|/* XXX ??? */
name|frame
operator|.
name|sf_sc
operator|.
name|uc_stack
operator|.
name|ss_sp
operator|=
name|PTROUT
argument_list|(
name|td
operator|->
name|td_sigstk
operator|.
name|ss_sp
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_stack
operator|.
name|ss_size
operator|=
name|td
operator|->
name|td_sigstk
operator|.
name|ss_size
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_stack
operator|.
name|ss_flags
operator|=
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_ALTSTACK
operator|)
condition|?
operator|(
operator|(
name|oonstack
operator|)
condition|?
name|LINUX_SS_ONSTACK
else|:
literal|0
operator|)
else|:
name|LINUX_SS_DISABLE
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|bsd_to_linux_sigset
argument_list|(
name|mask
argument_list|,
operator|&
name|frame
operator|.
name|sf_sc
operator|.
name|uc_sigmask
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_mask
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|uc_sigmask
operator|.
name|__bits
index|[
literal|0
index|]
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_gs
operator|=
name|rgs
argument_list|()
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_fs
operator|=
name|rfs
argument_list|()
expr_stmt|;
asm|__asm __volatile("movl %%es,%0" :
literal|"=rm"
operator|(
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_es
operator|)
block|)
function|;
end_function

begin_asm
asm|__asm __volatile("movl %%ds,%0" :
end_asm

begin_expr_stmt
literal|"=rm"
operator|(
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_ds
operator|)
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_edi
operator|=
name|regs
operator|->
name|tf_rdi
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_esi
operator|=
name|regs
operator|->
name|tf_rsi
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_ebp
operator|=
name|regs
operator|->
name|tf_rbp
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_ebx
operator|=
name|regs
operator|->
name|tf_rbx
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_edx
operator|=
name|regs
operator|->
name|tf_rdx
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_ecx
operator|=
name|regs
operator|->
name|tf_rcx
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_eax
operator|=
name|regs
operator|->
name|tf_rax
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_eip
operator|=
name|regs
operator|->
name|tf_rip
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_cs
operator|=
name|regs
operator|->
name|tf_cs
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_eflags
operator|=
name|regs
operator|->
name|tf_rflags
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_esp_at_signal
operator|=
name|regs
operator|->
name|tf_rsp
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_ss
operator|=
name|regs
operator|->
name|tf_ss
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_err
operator|=
name|regs
operator|->
name|tf_err
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_trapno
operator|=
name|bsd_to_linux_trapcode
argument_list|(
name|code
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_if
if|if
condition|(
name|ldebug
argument_list|(
name|rt_sendsig
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"rt_sendsig flags: 0x%x, sp: %p, ss: 0x%lx, mask: 0x%x"
argument_list|)
argument_list|,
name|frame
operator|.
name|sf_sc
operator|.
name|uc_stack
operator|.
name|ss_flags
argument_list|,
name|td
operator|->
name|td_sigstk
operator|.
name|ss_sp
argument_list|,
name|td
operator|->
name|td_sigstk
operator|.
name|ss_size
argument_list|,
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_mask
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|frame
argument_list|,
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Process has trashed its stack; give it an illegal 		 * instruction to halt it in its tracks. 		 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|rt_sendsig
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"rt_sendsig: bad stack %p, oonstack=%x"
argument_list|)
argument_list|,
name|fp
argument_list|,
name|oonstack
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigexit
argument_list|(
name|td
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* 	 * Build context to run handler in. 	 */
end_comment

begin_expr_stmt
name|regs
operator|->
name|tf_rsp
operator|=
name|PTROUT
argument_list|(
name|fp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|regs
operator|->
name|tf_rip
operator|=
name|LINUX32_PS_STRINGS
operator|-
operator|*
operator|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_szsigcode
operator|)
operator|+
name|linux_sznonrtsigcode
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|regs
operator|->
name|tf_rflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|regs
operator|->
name|tf_cs
operator|=
name|_ucode32sel
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|regs
operator|->
name|tf_ss
operator|=
name|_udatasel
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|load_ds
argument_list|(
name|_udatasel
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|td
operator|->
name|td_pcb
operator|->
name|pcb_ds
operator|=
name|_udatasel
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|load_es
argument_list|(
name|_udatasel
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|td
operator|->
name|td_pcb
operator|->
name|pcb_es
operator|=
name|_udatasel
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mtx_lock
argument_list|(
operator|&
name|psp
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * Send an interrupt to process.  *  * Stack is set up to allow sigcode stored  * in u. to call routine, followed by kcall  * to sigreturn routine below.  After sigreturn  * resets the signal mask, the stack, and the  * frame pointer, it returns to the user  * specified pc, psl.  */
end_comment

begin_function
unit|static
name|void
name|linux_sendsig
parameter_list|(
name|sig_t
name|catcher
parameter_list|,
name|int
name|sig
parameter_list|,
name|sigset_t
modifier|*
name|mask
parameter_list|,
name|u_long
name|code
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|sigacts
modifier|*
name|psp
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|regs
decl_stmt|;
name|struct
name|l_sigframe
modifier|*
name|fp
decl_stmt|,
name|frame
decl_stmt|;
name|l_sigset_t
name|lmask
decl_stmt|;
name|int
name|oonstack
decl_stmt|,
name|i
decl_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|psp
operator|=
name|p
operator|->
name|p_sigacts
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|psp
operator|->
name|ps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|psp
operator|->
name|ps_siginfo
argument_list|,
name|sig
argument_list|)
condition|)
block|{
comment|/* Signal handler installed with SA_SIGINFO. */
name|linux_rt_sendsig
argument_list|(
name|catcher
argument_list|,
name|sig
argument_list|,
name|mask
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|regs
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
name|oonstack
operator|=
name|sigonstack
argument_list|(
name|regs
operator|->
name|tf_rsp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sendsig
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sendsig
argument_list|,
literal|"%p, %d, %p, %lu"
argument_list|)
argument_list|,
name|catcher
argument_list|,
name|sig
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mask
argument_list|,
name|code
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate space for the signal handler context. 	 */
if|if
condition|(
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_ALTSTACK
operator|)
operator|&&
operator|!
name|oonstack
operator|&&
name|SIGISMEMBER
argument_list|(
name|psp
operator|->
name|ps_sigonstack
argument_list|,
name|sig
argument_list|)
condition|)
block|{
name|fp
operator|=
operator|(
expr|struct
name|l_sigframe
operator|*
operator|)
operator|(
name|td
operator|->
name|td_sigstk
operator|.
name|ss_sp
operator|+
name|td
operator|->
name|td_sigstk
operator|.
name|ss_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|l_sigframe
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|fp
operator|=
operator|(
expr|struct
name|l_sigframe
operator|*
operator|)
name|regs
operator|->
name|tf_rsp
operator|-
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|psp
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Build the argument list for the signal handler. 	 */
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_sigtbl
condition|)
if|if
condition|(
name|sig
operator|<=
name|p
operator|->
name|p_sysent
operator|->
name|sv_sigsize
condition|)
name|sig
operator|=
name|p
operator|->
name|p_sysent
operator|->
name|sv_sigtbl
index|[
name|_SIG_IDX
argument_list|(
name|sig
argument_list|)
index|]
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|frame
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_handler
operator|=
name|PTROUT
argument_list|(
name|catcher
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_sig
operator|=
name|sig
expr_stmt|;
name|bsd_to_linux_sigset
argument_list|(
name|mask
argument_list|,
operator|&
name|lmask
argument_list|)
expr_stmt|;
comment|/* 	 * Build the signal context to be used by sigreturn. 	 */
name|frame
operator|.
name|sf_sc
operator|.
name|sc_mask
operator|=
name|lmask
operator|.
name|__bits
index|[
literal|0
index|]
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_gs
operator|=
name|rgs
argument_list|()
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_fs
operator|=
name|rfs
argument_list|()
expr_stmt|;
asm|__asm __volatile("movl %%es,%0" : "=rm" (frame.sf_sc.sc_es));
asm|__asm __volatile("movl %%ds,%0" : "=rm" (frame.sf_sc.sc_ds));
name|frame
operator|.
name|sf_sc
operator|.
name|sc_edi
operator|=
name|regs
operator|->
name|tf_rdi
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_esi
operator|=
name|regs
operator|->
name|tf_rsi
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ebp
operator|=
name|regs
operator|->
name|tf_rbp
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ebx
operator|=
name|regs
operator|->
name|tf_rbx
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_edx
operator|=
name|regs
operator|->
name|tf_rdx
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ecx
operator|=
name|regs
operator|->
name|tf_rcx
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_eax
operator|=
name|regs
operator|->
name|tf_rax
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_eip
operator|=
name|regs
operator|->
name|tf_rip
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_cs
operator|=
name|regs
operator|->
name|tf_cs
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_eflags
operator|=
name|regs
operator|->
name|tf_rflags
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_esp_at_signal
operator|=
name|regs
operator|->
name|tf_rsp
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ss
operator|=
name|regs
operator|->
name|tf_ss
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_err
operator|=
name|regs
operator|->
name|tf_err
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_trapno
operator|=
name|bsd_to_linux_trapcode
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|LINUX_NSIG_WORDS
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|frame
operator|.
name|sf_extramask
index|[
name|i
index|]
operator|=
name|lmask
operator|.
name|__bits
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|frame
argument_list|,
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Process has trashed its stack; give it an illegal 		 * instruction to halt it in its tracks. 		 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigexit
argument_list|(
name|td
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Build context to run handler in. 	 */
name|regs
operator|->
name|tf_rsp
operator|=
name|PTROUT
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|regs
operator|->
name|tf_rip
operator|=
name|LINUX32_PS_STRINGS
operator|-
operator|*
operator|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_szsigcode
operator|)
expr_stmt|;
name|regs
operator|->
name|tf_rflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|regs
operator|->
name|tf_cs
operator|=
name|_ucode32sel
expr_stmt|;
name|regs
operator|->
name|tf_ss
operator|=
name|_udatasel
expr_stmt|;
name|load_ds
argument_list|(
name|_udatasel
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_ds
operator|=
name|_udatasel
expr_stmt|;
name|load_es
argument_list|(
name|_udatasel
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_es
operator|=
name|_udatasel
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|psp
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * System call to cleanup state after a signal  * has been taken.  Reset signal mask and  * stack state from context left by sendsig (above).  * Return to previous pc and psl as specified by  * context left by sendsig. Check carefully to  * make sure that the user has not modified the  * psl to gain improper privileges or to cause  * a machine fault.  */
end_comment

begin_function
name|int
name|linux_sigreturn
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sigreturn_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|l_sigframe
name|frame
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|regs
decl_stmt|;
name|l_sigset_t
name|lmask
decl_stmt|;
name|int
name|eflags
decl_stmt|,
name|i
decl_stmt|;
name|regs
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sigreturn
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sigreturn
argument_list|,
literal|"%p"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|sfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The trampoline code hands us the sigframe. 	 * It is unsafe to keep track of it ourselves, in the event that a 	 * program jumps out of a signal handler. 	 */
if|if
condition|(
name|copyin
argument_list|(
name|args
operator|->
name|sfp
argument_list|,
operator|&
name|frame
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* 	 * Check for security violations. 	 */
define|#
directive|define
name|EFLAGS_SECURE
parameter_list|(
name|ef
parameter_list|,
name|oef
parameter_list|)
value|((((ef) ^ (oef))& ~PSL_USERCHANGE) == 0)
name|eflags
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_eflags
expr_stmt|;
comment|/* 	 * XXX do allow users to change the privileged flag PSL_RF.  The 	 * cpu sets PSL_RF in tf_eflags for faults.  Debuggers should 	 * sometimes set it there too.  tf_eflags is kept in the signal 	 * context during signal handling and there is no other place 	 * to remember it, so the PSL_RF bit may be corrupted by the 	 * signal handler without us knowing.  Corruption of the PSL_RF 	 * bit at worst causes one more or one less debugger trap, so 	 * allowing it is fairly harmless. 	 */
if|if
condition|(
operator|!
name|EFLAGS_SECURE
argument_list|(
name|eflags
operator|&
operator|~
name|PSL_RF
argument_list|,
name|regs
operator|->
name|tf_rflags
operator|&
operator|~
name|PSL_RF
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Don't allow users to load a valid privileged %cs.  Let the 	 * hardware check for invalid selectors, excess privilege in 	 * other selectors, invalid %eip's and invalid %esp's. 	 */
define|#
directive|define
name|CS_SECURE
parameter_list|(
name|cs
parameter_list|)
value|(ISPL(cs) == SEL_UPL)
if|if
condition|(
operator|!
name|CS_SECURE
argument_list|(
name|frame
operator|.
name|sf_sc
operator|.
name|sc_cs
argument_list|)
condition|)
block|{
name|trapsignal
argument_list|(
name|td
argument_list|,
name|SIGBUS
argument_list|,
name|T_PROTFLT
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|lmask
operator|.
name|__bits
index|[
literal|0
index|]
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|LINUX_NSIG_WORDS
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|lmask
operator|.
name|__bits
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|frame
operator|.
name|sf_extramask
index|[
name|i
index|]
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|linux_to_bsd_sigset
argument_list|(
operator|&
name|lmask
argument_list|,
operator|&
name|td
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|SIG_CANTMASK
argument_list|(
name|td
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|signotify
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Restore signal context. 	 */
comment|/* Selectors were restored by the trampoline. */
name|regs
operator|->
name|tf_rdi
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_edi
expr_stmt|;
name|regs
operator|->
name|tf_rsi
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_esi
expr_stmt|;
name|regs
operator|->
name|tf_rbp
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ebp
expr_stmt|;
name|regs
operator|->
name|tf_rbx
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ebx
expr_stmt|;
name|regs
operator|->
name|tf_rdx
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_edx
expr_stmt|;
name|regs
operator|->
name|tf_rcx
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ecx
expr_stmt|;
name|regs
operator|->
name|tf_rax
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_eax
expr_stmt|;
name|regs
operator|->
name|tf_rip
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_eip
expr_stmt|;
name|regs
operator|->
name|tf_cs
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_cs
expr_stmt|;
name|regs
operator|->
name|tf_rflags
operator|=
name|eflags
expr_stmt|;
name|regs
operator|->
name|tf_rsp
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_esp_at_signal
expr_stmt|;
name|regs
operator|->
name|tf_ss
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ss
expr_stmt|;
return|return
operator|(
name|EJUSTRETURN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * System call to cleanup state after a signal  * has been taken.  Reset signal mask and  * stack state from context left by rt_sendsig (above).  * Return to previous pc and psl as specified by  * context left by sendsig. Check carefully to  * make sure that the user has not modified the  * psl to gain improper privileges or to cause  * a machine fault.  */
end_comment

begin_function
name|int
name|linux_rt_sigreturn
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_rt_sigreturn_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|l_ucontext
name|uc
decl_stmt|;
name|struct
name|l_sigcontext
modifier|*
name|context
decl_stmt|;
name|l_stack_t
modifier|*
name|lss
decl_stmt|;
name|stack_t
name|ss
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|regs
decl_stmt|;
name|int
name|eflags
decl_stmt|;
name|regs
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|rt_sigreturn
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|rt_sigreturn
argument_list|,
literal|"%p"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|ucp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The trampoline code hands us the ucontext. 	 * It is unsafe to keep track of it ourselves, in the event that a 	 * program jumps out of a signal handler. 	 */
if|if
condition|(
name|copyin
argument_list|(
name|args
operator|->
name|ucp
argument_list|,
operator|&
name|uc
argument_list|,
sizeof|sizeof
argument_list|(
name|uc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|context
operator|=
operator|&
name|uc
operator|.
name|uc_mcontext
expr_stmt|;
comment|/* 	 * Check for security violations. 	 */
define|#
directive|define
name|EFLAGS_SECURE
parameter_list|(
name|ef
parameter_list|,
name|oef
parameter_list|)
value|((((ef) ^ (oef))& ~PSL_USERCHANGE) == 0)
name|eflags
operator|=
name|context
operator|->
name|sc_eflags
expr_stmt|;
comment|/* 	 * XXX do allow users to change the privileged flag PSL_RF.  The 	 * cpu sets PSL_RF in tf_eflags for faults.  Debuggers should 	 * sometimes set it there too.  tf_eflags is kept in the signal 	 * context during signal handling and there is no other place 	 * to remember it, so the PSL_RF bit may be corrupted by the 	 * signal handler without us knowing.  Corruption of the PSL_RF 	 * bit at worst causes one more or one less debugger trap, so 	 * allowing it is fairly harmless. 	 */
if|if
condition|(
operator|!
name|EFLAGS_SECURE
argument_list|(
name|eflags
operator|&
operator|~
name|PSL_RF
argument_list|,
name|regs
operator|->
name|tf_rflags
operator|&
operator|~
name|PSL_RF
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Don't allow users to load a valid privileged %cs.  Let the 	 * hardware check for invalid selectors, excess privilege in 	 * other selectors, invalid %eip's and invalid %esp's. 	 */
define|#
directive|define
name|CS_SECURE
parameter_list|(
name|cs
parameter_list|)
value|(ISPL(cs) == SEL_UPL)
if|if
condition|(
operator|!
name|CS_SECURE
argument_list|(
name|context
operator|->
name|sc_cs
argument_list|)
condition|)
block|{
name|trapsignal
argument_list|(
name|td
argument_list|,
name|SIGBUS
argument_list|,
name|T_PROTFLT
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|linux_to_bsd_sigset
argument_list|(
operator|&
name|uc
operator|.
name|uc_sigmask
argument_list|,
operator|&
name|td
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|SIG_CANTMASK
argument_list|(
name|td
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|signotify
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Restore signal context 	 */
comment|/* Selectors were restored by the trampoline. */
name|regs
operator|->
name|tf_rdi
operator|=
name|context
operator|->
name|sc_edi
expr_stmt|;
name|regs
operator|->
name|tf_rsi
operator|=
name|context
operator|->
name|sc_esi
expr_stmt|;
name|regs
operator|->
name|tf_rbp
operator|=
name|context
operator|->
name|sc_ebp
expr_stmt|;
name|regs
operator|->
name|tf_rbx
operator|=
name|context
operator|->
name|sc_ebx
expr_stmt|;
name|regs
operator|->
name|tf_rdx
operator|=
name|context
operator|->
name|sc_edx
expr_stmt|;
name|regs
operator|->
name|tf_rcx
operator|=
name|context
operator|->
name|sc_ecx
expr_stmt|;
name|regs
operator|->
name|tf_rax
operator|=
name|context
operator|->
name|sc_eax
expr_stmt|;
name|regs
operator|->
name|tf_rip
operator|=
name|context
operator|->
name|sc_eip
expr_stmt|;
name|regs
operator|->
name|tf_cs
operator|=
name|context
operator|->
name|sc_cs
expr_stmt|;
name|regs
operator|->
name|tf_rflags
operator|=
name|eflags
expr_stmt|;
name|regs
operator|->
name|tf_rsp
operator|=
name|context
operator|->
name|sc_esp_at_signal
expr_stmt|;
name|regs
operator|->
name|tf_ss
operator|=
name|context
operator|->
name|sc_ss
expr_stmt|;
comment|/* 	 * call sigaltstack& ignore results.. 	 */
name|lss
operator|=
operator|&
name|uc
operator|.
name|uc_stack
expr_stmt|;
name|ss
operator|.
name|ss_sp
operator|=
name|PTRIN
argument_list|(
name|lss
operator|->
name|ss_sp
argument_list|)
expr_stmt|;
name|ss
operator|.
name|ss_size
operator|=
name|lss
operator|->
name|ss_size
expr_stmt|;
name|ss
operator|.
name|ss_flags
operator|=
name|linux_to_bsd_sigaltstack
argument_list|(
name|lss
operator|->
name|ss_flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|rt_sigreturn
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"rt_sigret flags: 0x%x, sp: %p, ss: 0x%lx, mask: 0x%x"
argument_list|)
argument_list|,
name|ss
operator|.
name|ss_flags
argument_list|,
name|ss
operator|.
name|ss_sp
argument_list|,
name|ss
operator|.
name|ss_size
argument_list|,
name|context
operator|->
name|sc_mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|kern_sigaltstack
argument_list|(
name|td
argument_list|,
operator|&
name|ss
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EJUSTRETURN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
specifier|static
name|void
name|linux_prepsyscall
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|,
name|int
modifier|*
name|args
parameter_list|,
name|u_int
modifier|*
name|code
parameter_list|,
name|caddr_t
modifier|*
name|params
parameter_list|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|tf
operator|->
name|tf_rbx
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|tf
operator|->
name|tf_rcx
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|tf
operator|->
name|tf_rdx
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|tf
operator|->
name|tf_rsi
expr_stmt|;
name|args
index|[
literal|4
index|]
operator|=
name|tf
operator|->
name|tf_rdi
expr_stmt|;
name|args
index|[
literal|5
index|]
operator|=
name|tf
operator|->
name|tf_rbp
expr_stmt|;
comment|/* Unconfirmed */
operator|*
name|params
operator|=
name|NULL
expr_stmt|;
comment|/* no copyin */
block|}
end_function

begin_comment
comment|/*  * If a linux binary is exec'ing something, try this image activator  * first.  We override standard shell script execution in order to  * be able to modify the interpreter path.  We only do this if a linux  * binary is doing the exec, so we do not create an EXEC module for it.  */
end_comment

begin_function_decl
specifier|static
name|int
name|exec_linux_imgact_try
parameter_list|(
name|struct
name|image_params
modifier|*
name|iparams
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|exec_linux_imgact_try
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|head
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|imgp
operator|->
name|image_header
decl_stmt|;
name|char
modifier|*
name|rpath
decl_stmt|;
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|,
name|len
decl_stmt|;
comment|/*      * The interpreter for shell scripts run from a linux binary needs      * to be located in /compat/linux if possible in order to recursively      * maintain linux path emulation.      */
if|if
condition|(
operator|(
operator|(
specifier|const
name|short
operator|*
operator|)
name|head
operator|)
index|[
literal|0
index|]
operator|==
name|SHELLMAGIC
condition|)
block|{
comment|/* 	     * Run our normal shell image activator.  If it succeeds attempt 	     * to use the alternate path for the interpreter.  If an alternate 	     * path is found, use our stringspace to store it. 	     */
if|if
condition|(
operator|(
name|error
operator|=
name|exec_shell_imgact
argument_list|(
name|imgp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|linux_emul_convpath
argument_list|(
name|FIRST_THREAD_IN_PROC
argument_list|(
name|imgp
operator|->
name|proc
argument_list|)
argument_list|,
name|imgp
operator|->
name|interpreter_name
argument_list|,
name|UIO_SYSSPACE
argument_list|,
operator|&
name|rpath
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpath
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|rpath
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|MAXSHELLCMDLEN
condition|)
block|{
name|memcpy
argument_list|(
name|imgp
operator|->
name|interpreter_name
argument_list|,
name|rpath
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rpath
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear registers on exec  * XXX copied from ia32_signal.c.  */
end_comment

begin_function
specifier|static
name|void
name|exec_linux_setregs
parameter_list|(
name|td
parameter_list|,
name|entry
parameter_list|,
name|stack
parameter_list|,
name|ps_strings
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|u_long
name|entry
decl_stmt|;
name|u_long
name|stack
decl_stmt|;
name|u_long
name|ps_strings
decl_stmt|;
block|{
name|struct
name|trapframe
modifier|*
name|regs
init|=
name|td
operator|->
name|td_frame
decl_stmt|;
name|struct
name|pcb
modifier|*
name|pcb
init|=
name|td
operator|->
name|td_pcb
decl_stmt|;
name|wrmsr
argument_list|(
name|MSR_FSBASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_KGSBASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* User value while we're in the kernel */
name|pcb
operator|->
name|pcb_fsbase
operator|=
literal|0
expr_stmt|;
name|pcb
operator|->
name|pcb_gsbase
operator|=
literal|0
expr_stmt|;
name|load_ds
argument_list|(
name|_udatasel
argument_list|)
expr_stmt|;
name|load_es
argument_list|(
name|_udatasel
argument_list|)
expr_stmt|;
name|load_fs
argument_list|(
name|_udatasel
argument_list|)
expr_stmt|;
name|load_gs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|pcb_ds
operator|=
name|_udatasel
expr_stmt|;
name|pcb
operator|->
name|pcb_es
operator|=
name|_udatasel
expr_stmt|;
name|pcb
operator|->
name|pcb_fs
operator|=
name|_udatasel
expr_stmt|;
name|pcb
operator|->
name|pcb_gs
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|trapframe
argument_list|)
argument_list|)
expr_stmt|;
name|regs
operator|->
name|tf_rip
operator|=
name|entry
expr_stmt|;
name|regs
operator|->
name|tf_rsp
operator|=
name|stack
expr_stmt|;
name|regs
operator|->
name|tf_rflags
operator|=
name|PSL_USER
operator||
operator|(
name|regs
operator|->
name|tf_rflags
operator|&
name|PSL_T
operator|)
expr_stmt|;
name|regs
operator|->
name|tf_ss
operator|=
name|_udatasel
expr_stmt|;
name|regs
operator|->
name|tf_cs
operator|=
name|_ucode32sel
expr_stmt|;
name|regs
operator|->
name|tf_rbx
operator|=
name|ps_strings
expr_stmt|;
name|load_cr0
argument_list|(
name|rcr0
argument_list|()
operator||
name|CR0_MP
operator||
name|CR0_TS
argument_list|)
expr_stmt|;
name|fpstate_drop
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* Return via doreti so that we can change to a different %cs */
name|pcb
operator|->
name|pcb_flags
operator||=
name|PCB_FULLCTX
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX copied from ia32_sysvec.c.  */
end_comment

begin_function
specifier|static
name|register_t
modifier|*
name|linux_copyout_strings
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
name|int
name|argc
decl_stmt|,
name|envc
decl_stmt|;
name|u_int32_t
modifier|*
name|vectp
decl_stmt|;
name|char
modifier|*
name|stringp
decl_stmt|,
modifier|*
name|destp
decl_stmt|;
name|u_int32_t
modifier|*
name|stack_base
decl_stmt|;
name|struct
name|linux32_ps_strings
modifier|*
name|arginfo
decl_stmt|;
name|int
name|sigcodesz
decl_stmt|;
comment|/* 	 * Calculate string base and vector table pointers. 	 * Also deal with signal trampoline code for this exec type. 	 */
name|arginfo
operator|=
operator|(
expr|struct
name|linux32_ps_strings
operator|*
operator|)
name|LINUX32_PS_STRINGS
expr_stmt|;
name|sigcodesz
operator|=
operator|*
operator|(
name|imgp
operator|->
name|proc
operator|->
name|p_sysent
operator|->
name|sv_szsigcode
operator|)
expr_stmt|;
name|destp
operator|=
operator|(
name|caddr_t
operator|)
name|arginfo
operator|-
name|sigcodesz
operator|-
name|SPARE_USRSPACE
operator|-
name|roundup
argument_list|(
operator|(
name|ARG_MAX
operator|-
name|imgp
operator|->
name|args
operator|->
name|stringspace
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * install sigcode 	 */
if|if
condition|(
name|sigcodesz
condition|)
name|copyout
argument_list|(
name|imgp
operator|->
name|proc
operator|->
name|p_sysent
operator|->
name|sv_sigcode
argument_list|,
operator|(
operator|(
name|caddr_t
operator|)
name|arginfo
operator|-
name|sigcodesz
operator|)
argument_list|,
name|szsigcode
argument_list|)
expr_stmt|;
comment|/* 	 * If we have a valid auxargs ptr, prepare some room 	 * on the stack. 	 */
if|if
condition|(
name|imgp
operator|->
name|auxargs
condition|)
block|{
comment|/* 		 * 'AT_COUNT*2' is size for the ELF Auxargs data. This is for 		 * lower compatibility. 		 */
name|imgp
operator|->
name|auxarg_size
operator|=
operator|(
name|imgp
operator|->
name|auxarg_size
operator|)
condition|?
name|imgp
operator|->
name|auxarg_size
else|:
operator|(
name|AT_COUNT
operator|*
literal|2
operator|)
expr_stmt|;
comment|/* 		 * The '+ 2' is for the null pointers at the end of each of 		 * the arg and env vector sets,and imgp->auxarg_size is room 		 * for argument of Runtime loader. 		 */
name|vectp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|destp
operator|-
operator|(
name|imgp
operator|->
name|args
operator|->
name|argc
operator|+
name|imgp
operator|->
name|args
operator|->
name|envc
operator|+
literal|2
operator|+
name|imgp
operator|->
name|auxarg_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
comment|/* 		 * The '+ 2' is for the null pointers at the end of each of 		 * the arg and env vector sets 		 */
name|vectp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|destp
operator|-
operator|(
name|imgp
operator|->
name|args
operator|->
name|argc
operator|+
name|imgp
operator|->
name|args
operator|->
name|envc
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * vectp also becomes our initial stack base 	 */
name|stack_base
operator|=
name|vectp
expr_stmt|;
name|stringp
operator|=
name|imgp
operator|->
name|args
operator|->
name|begin_argv
expr_stmt|;
name|argc
operator|=
name|imgp
operator|->
name|args
operator|->
name|argc
expr_stmt|;
name|envc
operator|=
name|imgp
operator|->
name|args
operator|->
name|envc
expr_stmt|;
comment|/* 	 * Copy out strings - arguments and environment. 	 */
name|copyout
argument_list|(
name|stringp
argument_list|,
name|destp
argument_list|,
name|ARG_MAX
operator|-
name|imgp
operator|->
name|args
operator|->
name|stringspace
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in "ps_strings" struct for ps, w, etc. 	 */
name|suword32
argument_list|(
operator|&
name|arginfo
operator|->
name|ps_argvstr
argument_list|,
operator|(
name|u_int32_t
operator|)
operator|(
name|intptr_t
operator|)
name|vectp
argument_list|)
expr_stmt|;
name|suword32
argument_list|(
operator|&
name|arginfo
operator|->
name|ps_nargvstr
argument_list|,
name|argc
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in argument portion of vector table. 	 */
for|for
control|(
init|;
name|argc
operator|>
literal|0
condition|;
operator|--
name|argc
control|)
block|{
name|suword32
argument_list|(
name|vectp
operator|++
argument_list|,
operator|(
name|u_int32_t
operator|)
operator|(
name|intptr_t
operator|)
name|destp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|stringp
operator|++
operator|!=
literal|0
condition|)
name|destp
operator|++
expr_stmt|;
name|destp
operator|++
expr_stmt|;
block|}
comment|/* a null vector table pointer separates the argp's from the envp's */
name|suword32
argument_list|(
name|vectp
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|suword32
argument_list|(
operator|&
name|arginfo
operator|->
name|ps_envstr
argument_list|,
operator|(
name|u_int32_t
operator|)
operator|(
name|intptr_t
operator|)
name|vectp
argument_list|)
expr_stmt|;
name|suword32
argument_list|(
operator|&
name|arginfo
operator|->
name|ps_nenvstr
argument_list|,
name|envc
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in environment portion of vector table. 	 */
for|for
control|(
init|;
name|envc
operator|>
literal|0
condition|;
operator|--
name|envc
control|)
block|{
name|suword32
argument_list|(
name|vectp
operator|++
argument_list|,
operator|(
name|u_int32_t
operator|)
operator|(
name|intptr_t
operator|)
name|destp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|stringp
operator|++
operator|!=
literal|0
condition|)
name|destp
operator|++
expr_stmt|;
name|destp
operator|++
expr_stmt|;
block|}
comment|/* end of vector table is a null pointer */
name|suword32
argument_list|(
name|vectp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|register_t
operator|*
operator|)
name|stack_base
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_compat
argument_list|,
name|OID_AUTO
argument_list|,
name|linux32
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"32-bit Linux emulation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|linux32_maxdsiz
init|=
name|LINUX32_MAXDSIZ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_compat_linux32
argument_list|,
name|OID_AUTO
argument_list|,
name|maxdsiz
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|linux32_maxdsiz
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|linux32_maxssiz
init|=
name|LINUX32_MAXSSIZ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_compat_linux32
argument_list|,
name|OID_AUTO
argument_list|,
name|maxssiz
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|linux32_maxssiz
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|linux32_maxvmem
init|=
name|LINUX32_MAXVMEM
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_compat_linux32
argument_list|,
name|OID_AUTO
argument_list|,
name|maxvmem
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|linux32_maxvmem
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * XXX copied from ia32_sysvec.c.  */
end_comment

begin_function
specifier|static
name|void
name|linux32_fixlimits
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|imgp
operator|->
name|proc
decl_stmt|;
name|struct
name|plimit
modifier|*
name|oldlim
decl_stmt|,
modifier|*
name|newlim
decl_stmt|;
if|if
condition|(
name|linux32_maxdsiz
operator|==
literal|0
operator|&&
name|linux32_maxssiz
operator|==
literal|0
operator|&&
name|linux32_maxvmem
operator|==
literal|0
condition|)
return|return;
name|newlim
operator|=
name|lim_alloc
argument_list|()
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldlim
operator|=
name|p
operator|->
name|p_limit
expr_stmt|;
name|lim_copy
argument_list|(
name|newlim
argument_list|,
name|oldlim
argument_list|)
expr_stmt|;
if|if
condition|(
name|linux32_maxdsiz
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|newlim
operator|->
name|pl_rlimit
index|[
name|RLIMIT_DATA
index|]
operator|.
name|rlim_cur
operator|>
name|linux32_maxdsiz
condition|)
name|newlim
operator|->
name|pl_rlimit
index|[
name|RLIMIT_DATA
index|]
operator|.
name|rlim_cur
operator|=
name|linux32_maxdsiz
expr_stmt|;
if|if
condition|(
name|newlim
operator|->
name|pl_rlimit
index|[
name|RLIMIT_DATA
index|]
operator|.
name|rlim_max
operator|>
name|linux32_maxdsiz
condition|)
name|newlim
operator|->
name|pl_rlimit
index|[
name|RLIMIT_DATA
index|]
operator|.
name|rlim_max
operator|=
name|linux32_maxdsiz
expr_stmt|;
block|}
if|if
condition|(
name|linux32_maxssiz
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|newlim
operator|->
name|pl_rlimit
index|[
name|RLIMIT_STACK
index|]
operator|.
name|rlim_cur
operator|>
name|linux32_maxssiz
condition|)
name|newlim
operator|->
name|pl_rlimit
index|[
name|RLIMIT_STACK
index|]
operator|.
name|rlim_cur
operator|=
name|linux32_maxssiz
expr_stmt|;
if|if
condition|(
name|newlim
operator|->
name|pl_rlimit
index|[
name|RLIMIT_STACK
index|]
operator|.
name|rlim_max
operator|>
name|linux32_maxssiz
condition|)
name|newlim
operator|->
name|pl_rlimit
index|[
name|RLIMIT_STACK
index|]
operator|.
name|rlim_max
operator|=
name|linux32_maxssiz
expr_stmt|;
block|}
if|if
condition|(
name|linux32_maxvmem
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|newlim
operator|->
name|pl_rlimit
index|[
name|RLIMIT_VMEM
index|]
operator|.
name|rlim_cur
operator|>
name|linux32_maxvmem
condition|)
name|newlim
operator|->
name|pl_rlimit
index|[
name|RLIMIT_VMEM
index|]
operator|.
name|rlim_cur
operator|=
name|linux32_maxvmem
expr_stmt|;
if|if
condition|(
name|newlim
operator|->
name|pl_rlimit
index|[
name|RLIMIT_VMEM
index|]
operator|.
name|rlim_max
operator|>
name|linux32_maxvmem
condition|)
name|newlim
operator|->
name|pl_rlimit
index|[
name|RLIMIT_VMEM
index|]
operator|.
name|rlim_max
operator|=
name|linux32_maxvmem
expr_stmt|;
block|}
name|p
operator|->
name|p_limit
operator|=
name|newlim
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lim_free
argument_list|(
name|oldlim
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|sysentvec
name|elf_linux_sysvec
init|=
block|{
name|LINUX_SYS_MAXSYSCALL
block|,
name|linux_sysent
block|,
literal|0xff
block|,
name|LINUX_SIGTBLSZ
block|,
name|bsd_to_linux_signal
block|,
name|ELAST
operator|+
literal|1
block|,
name|bsd_to_linux_errno
block|,
name|translate_traps
block|,
name|elf_linux_fixup
block|,
name|linux_sendsig
block|,
name|linux_sigcode
block|,
operator|&
name|linux_szsigcode
block|,
name|linux_prepsyscall
block|,
literal|"Linux ELF32"
block|,
name|elf32_coredump
block|,
name|exec_linux_imgact_try
block|,
name|LINUX_MINSIGSTKSZ
block|,
name|PAGE_SIZE
block|,
name|VM_MIN_ADDRESS
block|,
name|LINUX32_USRSTACK
block|,
name|LINUX32_USRSTACK
block|,
name|LINUX32_PS_STRINGS
block|,
name|VM_PROT_ALL
block|,
name|linux_copyout_strings
block|,
name|exec_linux_setregs
block|,
name|linux32_fixlimits
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf32_Brandinfo
name|linux_brand
init|=
block|{
name|ELFOSABI_LINUX
block|,
name|EM_386
block|,
literal|"Linux"
block|,
literal|"/compat/linux"
block|,
literal|"/lib/ld-linux.so.1"
block|,
operator|&
name|elf_linux_sysvec
block|,
name|NULL
block|, 				 }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf32_Brandinfo
name|linux_glibc2brand
init|=
block|{
name|ELFOSABI_LINUX
block|,
name|EM_386
block|,
literal|"Linux"
block|,
literal|"/compat/linux"
block|,
literal|"/lib/ld-linux.so.2"
block|,
operator|&
name|elf_linux_sysvec
block|,
name|NULL
block|, 				 }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf32_Brandinfo
modifier|*
name|linux_brandlist
index|[]
init|=
block|{
operator|&
name|linux_brand
block|,
operator|&
name|linux_glibc2brand
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|linux_elf_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Elf32_Brandinfo
modifier|*
modifier|*
name|brandinfo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|linux_ioctl_handler
modifier|*
modifier|*
name|lihp
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
for|for
control|(
name|brandinfo
operator|=
operator|&
name|linux_brandlist
index|[
literal|0
index|]
init|;
operator|*
name|brandinfo
operator|!=
name|NULL
condition|;
operator|++
name|brandinfo
control|)
if|if
condition|(
name|elf32_insert_brand_entry
argument_list|(
operator|*
name|brandinfo
argument_list|)
operator|<
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|SET_FOREACH
argument_list|(
argument|lihp
argument_list|,
argument|linux_ioctl_handler_set
argument_list|)
name|linux_ioctl_register_handler
argument_list|(
operator|*
name|lihp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Linux ELF exec handler installed\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"cannot insert Linux ELF brand handler\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
for|for
control|(
name|brandinfo
operator|=
operator|&
name|linux_brandlist
index|[
literal|0
index|]
init|;
operator|*
name|brandinfo
operator|!=
name|NULL
condition|;
operator|++
name|brandinfo
control|)
if|if
condition|(
name|elf32_brand_inuse
argument_list|(
operator|*
name|brandinfo
argument_list|)
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|brandinfo
operator|=
operator|&
name|linux_brandlist
index|[
literal|0
index|]
init|;
operator|*
name|brandinfo
operator|!=
name|NULL
condition|;
operator|++
name|brandinfo
control|)
if|if
condition|(
name|elf32_remove_brand_entry
argument_list|(
operator|*
name|brandinfo
argument_list|)
operator|<
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|SET_FOREACH
argument_list|(
argument|lihp
argument_list|,
argument|linux_ioctl_handler_set
argument_list|)
name|linux_ioctl_unregister_handler
argument_list|(
operator|*
name|lihp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Linux ELF exec handler removed\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Could not deinstall ELF interpreter entry\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|linux_elf_mod
init|=
block|{
literal|"linuxelf"
block|,
name|linux_elf_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|linuxelf
argument_list|,
name|linux_elf_mod
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

