begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 Tim J. Robbins  * Copyright (c) 2003 Peter Wemm  * Copyright (c) 2002 Doug Rabson  * Copyright (c) 1998-1999 Andrew Gallatin  * Copyright (c) 1994-1996 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|COMPAT_FREEBSD32
end_ifndef

begin_error
error|#
directive|error
literal|"Unable to compile Linux-emulator due to missing COMPAT_FREEBSD32 option!"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|__ELF_WORD_SIZE
value|32
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_elf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<amd64/linux32/linux.h>
end_include

begin_include
include|#
directive|include
file|<amd64/linux32/linux32_proto.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_emul.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_futex.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_mib.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_misc.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_signal.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_util.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_vdso.h>
end_include

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|linux
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|AUXARGS_ENTRY_32
parameter_list|(
name|pos
parameter_list|,
name|id
parameter_list|,
name|val
parameter_list|)
define|\
value|do {				\ 		suword32(pos++, id);	\ 		suword32(pos++, val);	\ 	} while (0)
end_define

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
end_if

begin_define
define|#
directive|define
name|SHELLMAGIC
value|0x2123
end_define

begin_comment
comment|/* #! */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SHELLMAGIC
value|0x2321
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allow the sendsig functions to use the ldebug() facility  * even though they are not syscalls themselves. Map them  * to syscall 0. This is slightly less bogus than using  * ldebug(sigreturn).  */
end_comment

begin_define
define|#
directive|define
name|LINUX32_SYS_linux_rt_sendsig
value|0
end_define

begin_define
define|#
directive|define
name|LINUX32_SYS_linux_sendsig
value|0
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|linux_kplatform
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|linux_szsigcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_object_t
name|linux_shared_page_obj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|linux_shared_page_mapping
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|_binary_linux32_locore_o_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|_binary_linux32_locore_o_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sysent
name|linux32_sysent
index|[
name|LINUX32_SYS_MAXSYSCALL
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SET_DECLARE
argument_list|(
name|linux_ioctl_handler_set
argument_list|,
expr|struct
name|linux_ioctl_handler
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|elf_linux_fixup
parameter_list|(
name|register_t
modifier|*
modifier|*
name|stack_base
parameter_list|,
name|struct
name|image_params
modifier|*
name|iparams
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|register_t
modifier|*
name|linux_copyout_strings
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|linux_sendsig
parameter_list|(
name|sig_t
name|catcher
parameter_list|,
name|ksiginfo_t
modifier|*
name|ksi
parameter_list|,
name|sigset_t
modifier|*
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exec_linux_setregs
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|,
name|u_long
name|stack
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|linux32_fixlimit
parameter_list|(
name|struct
name|rlimit
modifier|*
name|rl
parameter_list|,
name|int
name|which
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|linux32_trans_osrel
parameter_list|(
specifier|const
name|Elf_Note
modifier|*
name|note
parameter_list|,
name|int32_t
modifier|*
name|osrel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|linux_vdso_install
parameter_list|(
name|void
modifier|*
name|param
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|linux_vdso_deinstall
parameter_list|(
name|void
modifier|*
name|param
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Linux syscalls return negative errno's, we do positive and map them  * Reference:  *   FreeBSD: src/sys/sys/errno.h  *   Linux:   linux-2.6.17.8/include/asm-generic/errno-base.h  *            linux-2.6.17.8/include/asm-generic/errno.h  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bsd_to_linux_errno
index|[
name|ELAST
operator|+
literal|1
index|]
init|=
block|{
operator|-
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|,
operator|-
literal|3
block|,
operator|-
literal|4
block|,
operator|-
literal|5
block|,
operator|-
literal|6
block|,
operator|-
literal|7
block|,
operator|-
literal|8
block|,
operator|-
literal|9
block|,
operator|-
literal|10
block|,
operator|-
literal|35
block|,
operator|-
literal|12
block|,
operator|-
literal|13
block|,
operator|-
literal|14
block|,
operator|-
literal|15
block|,
operator|-
literal|16
block|,
operator|-
literal|17
block|,
operator|-
literal|18
block|,
operator|-
literal|19
block|,
operator|-
literal|20
block|,
operator|-
literal|21
block|,
operator|-
literal|22
block|,
operator|-
literal|23
block|,
operator|-
literal|24
block|,
operator|-
literal|25
block|,
operator|-
literal|26
block|,
operator|-
literal|27
block|,
operator|-
literal|28
block|,
operator|-
literal|29
block|,
operator|-
literal|30
block|,
operator|-
literal|31
block|,
operator|-
literal|32
block|,
operator|-
literal|33
block|,
operator|-
literal|34
block|,
operator|-
literal|11
block|,
operator|-
literal|115
block|,
operator|-
literal|114
block|,
operator|-
literal|88
block|,
operator|-
literal|89
block|,
operator|-
literal|90
block|,
operator|-
literal|91
block|,
operator|-
literal|92
block|,
operator|-
literal|93
block|,
operator|-
literal|94
block|,
operator|-
literal|95
block|,
operator|-
literal|96
block|,
operator|-
literal|97
block|,
operator|-
literal|98
block|,
operator|-
literal|99
block|,
operator|-
literal|100
block|,
operator|-
literal|101
block|,
operator|-
literal|102
block|,
operator|-
literal|103
block|,
operator|-
literal|104
block|,
operator|-
literal|105
block|,
operator|-
literal|106
block|,
operator|-
literal|107
block|,
operator|-
literal|108
block|,
operator|-
literal|109
block|,
operator|-
literal|110
block|,
operator|-
literal|111
block|,
operator|-
literal|40
block|,
operator|-
literal|36
block|,
operator|-
literal|112
block|,
operator|-
literal|113
block|,
operator|-
literal|39
block|,
operator|-
literal|11
block|,
operator|-
literal|87
block|,
operator|-
literal|122
block|,
operator|-
literal|116
block|,
operator|-
literal|66
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|37
block|,
operator|-
literal|38
block|,
operator|-
literal|9
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|43
block|,
operator|-
literal|42
block|,
operator|-
literal|75
block|,
operator|-
literal|125
block|,
operator|-
literal|84
block|,
operator|-
literal|95
block|,
operator|-
literal|16
block|,
operator|-
literal|74
block|,
operator|-
literal|72
block|,
operator|-
literal|67
block|,
operator|-
literal|71
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LINUX_T_UNKNOWN
value|255
end_define

begin_decl_stmt
specifier|static
name|int
name|_bsd_to_linux_trapcode
index|[]
init|=
block|{
name|LINUX_T_UNKNOWN
block|,
comment|/* 0 */
literal|6
block|,
comment|/* 1  T_PRIVINFLT */
name|LINUX_T_UNKNOWN
block|,
comment|/* 2 */
literal|3
block|,
comment|/* 3  T_BPTFLT */
name|LINUX_T_UNKNOWN
block|,
comment|/* 4 */
name|LINUX_T_UNKNOWN
block|,
comment|/* 5 */
literal|16
block|,
comment|/* 6  T_ARITHTRAP */
literal|254
block|,
comment|/* 7  T_ASTFLT */
name|LINUX_T_UNKNOWN
block|,
comment|/* 8 */
literal|13
block|,
comment|/* 9  T_PROTFLT */
literal|1
block|,
comment|/* 10 T_TRCTRAP */
name|LINUX_T_UNKNOWN
block|,
comment|/* 11 */
literal|14
block|,
comment|/* 12 T_PAGEFLT */
name|LINUX_T_UNKNOWN
block|,
comment|/* 13 */
literal|17
block|,
comment|/* 14 T_ALIGNFLT */
name|LINUX_T_UNKNOWN
block|,
comment|/* 15 */
name|LINUX_T_UNKNOWN
block|,
comment|/* 16 */
name|LINUX_T_UNKNOWN
block|,
comment|/* 17 */
literal|0
block|,
comment|/* 18 T_DIVIDE */
literal|2
block|,
comment|/* 19 T_NMI */
literal|4
block|,
comment|/* 20 T_OFLOW */
literal|5
block|,
comment|/* 21 T_BOUND */
literal|7
block|,
comment|/* 22 T_DNA */
literal|8
block|,
comment|/* 23 T_DOUBLEFLT */
literal|9
block|,
comment|/* 24 T_FPOPFLT */
literal|10
block|,
comment|/* 25 T_TSSFLT */
literal|11
block|,
comment|/* 26 T_SEGNPFLT */
literal|12
block|,
comment|/* 27 T_STKFLT */
literal|18
block|,
comment|/* 28 T_MCHK */
literal|19
block|,
comment|/* 29 T_XMMFLT */
literal|15
comment|/* 30 T_RESERVED */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|bsd_to_linux_trapcode
parameter_list|(
name|code
parameter_list|)
define|\
value|((code)<sizeof(_bsd_to_linux_trapcode)/sizeof(*_bsd_to_linux_trapcode)? \      _bsd_to_linux_trapcode[(code)]: \      LINUX_T_UNKNOWN)
end_define

begin_struct
struct|struct
name|linux32_ps_strings
block|{
name|u_int32_t
name|ps_argvstr
decl_stmt|;
comment|/* first of 0 or more argument strings */
name|u_int
name|ps_nargvstr
decl_stmt|;
comment|/* the number of argument strings */
name|u_int32_t
name|ps_envstr
decl_stmt|;
comment|/* first of 0 or more environment strings */
name|u_int
name|ps_nenvstr
decl_stmt|;
comment|/* the number of environment strings */
block|}
struct|;
end_struct

begin_expr_stmt
name|LINUX_VDSO_SYM_INTPTR
argument_list|(
name|linux32_sigcode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LINUX_VDSO_SYM_INTPTR
argument_list|(
name|linux32_rt_sigcode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LINUX_VDSO_SYM_INTPTR
argument_list|(
name|linux32_vsyscall
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LINUX_VDSO_SYM_CHAR
argument_list|(
name|linux_platform
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * If FreeBSD& Linux have a difference of opinion about what a trap  * means, deal with it here.  *  * MPSAFE  */
end_comment

begin_function
specifier|static
name|int
name|translate_traps
parameter_list|(
name|int
name|signal
parameter_list|,
name|int
name|trap_code
parameter_list|)
block|{
if|if
condition|(
name|signal
operator|!=
name|SIGBUS
condition|)
return|return
name|signal
return|;
switch|switch
condition|(
name|trap_code
condition|)
block|{
case|case
name|T_PROTFLT
case|:
case|case
name|T_TSSFLT
case|:
case|case
name|T_DOUBLEFLT
case|:
case|case
name|T_PAGEFLT
case|:
return|return
name|SIGSEGV
return|;
default|default:
return|return
name|signal
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|elf_linux_fixup
parameter_list|(
name|register_t
modifier|*
modifier|*
name|stack_base
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
name|Elf32_Auxargs
modifier|*
name|args
decl_stmt|;
name|Elf32_Addr
modifier|*
name|base
decl_stmt|;
name|Elf32_Addr
modifier|*
name|pos
decl_stmt|;
name|struct
name|linux32_ps_strings
modifier|*
name|arginfo
decl_stmt|;
name|int
name|issetugid
decl_stmt|;
name|arginfo
operator|=
operator|(
expr|struct
name|linux32_ps_strings
operator|*
operator|)
name|LINUX32_PS_STRINGS
expr_stmt|;
name|KASSERT
argument_list|(
name|curthread
operator|->
name|td_proc
operator|==
name|imgp
operator|->
name|proc
argument_list|,
operator|(
literal|"unsafe elf_linux_fixup(), should be curproc"
operator|)
argument_list|)
expr_stmt|;
name|base
operator|=
operator|(
name|Elf32_Addr
operator|*
operator|)
operator|*
name|stack_base
expr_stmt|;
name|args
operator|=
operator|(
name|Elf32_Auxargs
operator|*
operator|)
name|imgp
operator|->
name|auxargs
expr_stmt|;
name|pos
operator|=
name|base
operator|+
operator|(
name|imgp
operator|->
name|args
operator|->
name|argc
operator|+
name|imgp
operator|->
name|args
operator|->
name|envc
operator|+
literal|2
operator|)
expr_stmt|;
name|issetugid
operator|=
name|imgp
operator|->
name|proc
operator|->
name|p_flag
operator|&
name|P_SUGID
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|LINUX_AT_SYSINFO_EHDR
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_sysent
operator|->
name|sv_shared_page_base
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|LINUX_AT_SYSINFO
argument_list|,
name|linux32_vsyscall
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|LINUX_AT_HWCAP
argument_list|,
name|cpu_feature
argument_list|)
expr_stmt|;
comment|/* 	 * Do not export AT_CLKTCK when emulating Linux kernel prior to 2.4.0, 	 * as it has appeared in the 2.4.0-rc7 first time. 	 * Being exported, AT_CLKTCK is returned by sysconf(_SC_CLK_TCK), 	 * glibc falls back to the hard-coded CLK_TCK value when aux entry 	 * is not present. 	 * Also see linux_times() implementation. 	 */
if|if
condition|(
name|linux_kernver
argument_list|(
name|curthread
argument_list|)
operator|>=
name|LINUX_KERNVER_2004000
condition|)
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|LINUX_AT_CLKTCK
argument_list|,
name|stclohz
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_PHDR
argument_list|,
name|args
operator|->
name|phdr
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_PHENT
argument_list|,
name|args
operator|->
name|phent
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_PHNUM
argument_list|,
name|args
operator|->
name|phnum
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_PAGESZ
argument_list|,
name|args
operator|->
name|pagesz
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_FLAGS
argument_list|,
name|args
operator|->
name|flags
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_ENTRY
argument_list|,
name|args
operator|->
name|entry
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_BASE
argument_list|,
name|args
operator|->
name|base
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|LINUX_AT_SECURE
argument_list|,
name|issetugid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_UID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_ucred
operator|->
name|cr_ruid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_EUID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_ucred
operator|->
name|cr_svuid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_GID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_ucred
operator|->
name|cr_rgid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_EGID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_ucred
operator|->
name|cr_svgid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|LINUX_AT_PLATFORM
argument_list|,
name|PTROUT
argument_list|(
name|linux_platform
argument_list|)
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|LINUX_AT_RANDOM
argument_list|,
name|PTROUT
argument_list|(
name|imgp
operator|->
name|canary
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imgp
operator|->
name|execpathp
operator|!=
literal|0
condition|)
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|LINUX_AT_EXECFN
argument_list|,
name|PTROUT
argument_list|(
name|imgp
operator|->
name|execpathp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|execfd
operator|!=
operator|-
literal|1
condition|)
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_EXECFD
argument_list|,
name|args
operator|->
name|execfd
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY_32
argument_list|(
name|pos
argument_list|,
name|AT_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imgp
operator|->
name|auxargs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|auxargs
operator|=
name|NULL
expr_stmt|;
name|base
operator|--
expr_stmt|;
name|suword32
argument_list|(
name|base
argument_list|,
operator|(
name|uint32_t
operator|)
name|imgp
operator|->
name|args
operator|->
name|argc
argument_list|)
expr_stmt|;
operator|*
name|stack_base
operator|=
operator|(
name|register_t
operator|*
operator|)
name|base
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|linux_rt_sendsig
parameter_list|(
name|sig_t
name|catcher
parameter_list|,
name|ksiginfo_t
modifier|*
name|ksi
parameter_list|,
name|sigset_t
modifier|*
name|mask
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|sigacts
modifier|*
name|psp
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|regs
decl_stmt|;
name|struct
name|l_rt_sigframe
modifier|*
name|fp
decl_stmt|,
name|frame
decl_stmt|;
name|int
name|oonstack
decl_stmt|;
name|int
name|sig
decl_stmt|;
name|int
name|code
decl_stmt|;
name|sig
operator|=
name|ksi
operator|->
name|ksi_signo
expr_stmt|;
name|code
operator|=
name|ksi
operator|->
name|ksi_code
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|psp
operator|=
name|p
operator|->
name|p_sigacts
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|psp
operator|->
name|ps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|regs
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
name|oonstack
operator|=
name|sigonstack
argument_list|(
name|regs
operator|->
name|tf_rsp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|rt_sendsig
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|rt_sendsig
argument_list|,
literal|"%p, %d, %p, %u"
argument_list|)
argument_list|,
name|catcher
argument_list|,
name|sig
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mask
argument_list|,
name|code
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate space for the signal handler context. 	 */
if|if
condition|(
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_ALTSTACK
operator|)
operator|&&
operator|!
name|oonstack
operator|&&
name|SIGISMEMBER
argument_list|(
name|psp
operator|->
name|ps_sigonstack
argument_list|,
name|sig
argument_list|)
condition|)
block|{
name|fp
operator|=
operator|(
expr|struct
name|l_rt_sigframe
operator|*
operator|)
operator|(
name|td
operator|->
name|td_sigstk
operator|.
name|ss_sp
operator|+
name|td
operator|->
name|td_sigstk
operator|.
name|ss_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|l_rt_sigframe
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|fp
operator|=
operator|(
expr|struct
name|l_rt_sigframe
operator|*
operator|)
name|regs
operator|->
name|tf_rsp
operator|-
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|psp
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Build the argument list for the signal handler. 	 */
name|sig
operator|=
name|bsd_to_linux_signal
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|frame
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_handler
operator|=
name|PTROUT
argument_list|(
name|catcher
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_sig
operator|=
name|sig
expr_stmt|;
name|frame
operator|.
name|sf_siginfo
operator|=
name|PTROUT
argument_list|(
operator|&
name|fp
operator|->
name|sf_si
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_ucontext
operator|=
name|PTROUT
argument_list|(
operator|&
name|fp
operator|->
name|sf_sc
argument_list|)
expr_stmt|;
comment|/* Fill in POSIX parts */
name|ksiginfo_to_lsiginfo
argument_list|(
name|ksi
argument_list|,
operator|&
name|frame
operator|.
name|sf_si
argument_list|,
name|sig
argument_list|)
expr_stmt|;
comment|/* 	 * Build the signal context to be used by sigreturn 	 * and libgcc unwind. 	 */
name|frame
operator|.
name|sf_sc
operator|.
name|uc_flags
operator|=
literal|0
expr_stmt|;
comment|/* XXX ??? */
name|frame
operator|.
name|sf_sc
operator|.
name|uc_link
operator|=
literal|0
expr_stmt|;
comment|/* XXX ??? */
name|frame
operator|.
name|sf_sc
operator|.
name|uc_stack
operator|.
name|ss_sp
operator|=
name|PTROUT
argument_list|(
name|td
operator|->
name|td_sigstk
operator|.
name|ss_sp
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_stack
operator|.
name|ss_size
operator|=
name|td
operator|->
name|td_sigstk
operator|.
name|ss_size
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_stack
operator|.
name|ss_flags
operator|=
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_ALTSTACK
operator|)
condition|?
operator|(
operator|(
name|oonstack
operator|)
condition|?
name|LINUX_SS_ONSTACK
else|:
literal|0
operator|)
else|:
name|LINUX_SS_DISABLE
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|bsd_to_linux_sigset
argument_list|(
name|mask
argument_list|,
operator|&
name|frame
operator|.
name|sf_sc
operator|.
name|uc_sigmask
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_mask
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|uc_sigmask
operator|.
name|__mask
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_edi
operator|=
name|regs
operator|->
name|tf_rdi
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_esi
operator|=
name|regs
operator|->
name|tf_rsi
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_ebp
operator|=
name|regs
operator|->
name|tf_rbp
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_ebx
operator|=
name|regs
operator|->
name|tf_rbx
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_esp
operator|=
name|regs
operator|->
name|tf_rsp
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_edx
operator|=
name|regs
operator|->
name|tf_rdx
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_ecx
operator|=
name|regs
operator|->
name|tf_rcx
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_eax
operator|=
name|regs
operator|->
name|tf_rax
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_eip
operator|=
name|regs
operator|->
name|tf_rip
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_cs
operator|=
name|regs
operator|->
name|tf_cs
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_gs
operator|=
name|regs
operator|->
name|tf_gs
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_fs
operator|=
name|regs
operator|->
name|tf_fs
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_es
operator|=
name|regs
operator|->
name|tf_es
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_ds
operator|=
name|regs
operator|->
name|tf_ds
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_eflags
operator|=
name|regs
operator|->
name|tf_rflags
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_esp_at_signal
operator|=
name|regs
operator|->
name|tf_rsp
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_ss
operator|=
name|regs
operator|->
name|tf_ss
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_err
operator|=
name|regs
operator|->
name|tf_err
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_cr2
operator|=
operator|(
name|u_int32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ksi
operator|->
name|ksi_addr
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_trapno
operator|=
name|bsd_to_linux_trapcode
argument_list|(
name|code
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|rt_sendsig
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"rt_sendsig flags: 0x%x, sp: %p, ss: 0x%lx, mask: 0x%x"
argument_list|)
argument_list|,
name|frame
operator|.
name|sf_sc
operator|.
name|uc_stack
operator|.
name|ss_flags
argument_list|,
name|td
operator|->
name|td_sigstk
operator|.
name|ss_sp
argument_list|,
name|td
operator|->
name|td_sigstk
operator|.
name|ss_size
argument_list|,
name|frame
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|frame
argument_list|,
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Process has trashed its stack; give it an illegal 		 * instruction to halt it in its tracks. 		 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|rt_sendsig
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"rt_sendsig: bad stack %p, oonstack=%x"
argument_list|)
argument_list|,
name|fp
argument_list|,
name|oonstack
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigexit
argument_list|(
name|td
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Build context to run handler in. 	 */
name|regs
operator|->
name|tf_rsp
operator|=
name|PTROUT
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|regs
operator|->
name|tf_rip
operator|=
name|linux32_rt_sigcode
expr_stmt|;
name|regs
operator|->
name|tf_rflags
operator|&=
operator|~
operator|(
name|PSL_T
operator||
name|PSL_D
operator|)
expr_stmt|;
name|regs
operator|->
name|tf_cs
operator|=
name|_ucode32sel
expr_stmt|;
name|regs
operator|->
name|tf_ss
operator|=
name|_udatasel
expr_stmt|;
name|regs
operator|->
name|tf_ds
operator|=
name|_udatasel
expr_stmt|;
name|regs
operator|->
name|tf_es
operator|=
name|_udatasel
expr_stmt|;
name|regs
operator|->
name|tf_fs
operator|=
name|_ufssel
expr_stmt|;
name|regs
operator|->
name|tf_gs
operator|=
name|_ugssel
expr_stmt|;
name|regs
operator|->
name|tf_flags
operator|=
name|TF_HASSEGS
expr_stmt|;
name|set_pcb_flags
argument_list|(
name|td
operator|->
name|td_pcb
argument_list|,
name|PCB_FULL_IRET
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|psp
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send an interrupt to process.  *  * Stack is set up to allow sigcode stored  * in u. to call routine, followed by kcall  * to sigreturn routine below.  After sigreturn  * resets the signal mask, the stack, and the  * frame pointer, it returns to the user  * specified pc, psl.  */
end_comment

begin_function
specifier|static
name|void
name|linux_sendsig
parameter_list|(
name|sig_t
name|catcher
parameter_list|,
name|ksiginfo_t
modifier|*
name|ksi
parameter_list|,
name|sigset_t
modifier|*
name|mask
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|sigacts
modifier|*
name|psp
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|regs
decl_stmt|;
name|struct
name|l_sigframe
modifier|*
name|fp
decl_stmt|,
name|frame
decl_stmt|;
name|l_sigset_t
name|lmask
decl_stmt|;
name|int
name|oonstack
decl_stmt|;
name|int
name|sig
decl_stmt|,
name|code
decl_stmt|;
name|sig
operator|=
name|ksi
operator|->
name|ksi_signo
expr_stmt|;
name|code
operator|=
name|ksi
operator|->
name|ksi_code
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|psp
operator|=
name|p
operator|->
name|p_sigacts
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|psp
operator|->
name|ps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|psp
operator|->
name|ps_siginfo
argument_list|,
name|sig
argument_list|)
condition|)
block|{
comment|/* Signal handler installed with SA_SIGINFO. */
name|linux_rt_sendsig
argument_list|(
name|catcher
argument_list|,
name|ksi
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return;
block|}
name|regs
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
name|oonstack
operator|=
name|sigonstack
argument_list|(
name|regs
operator|->
name|tf_rsp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sendsig
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sendsig
argument_list|,
literal|"%p, %d, %p, %u"
argument_list|)
argument_list|,
name|catcher
argument_list|,
name|sig
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mask
argument_list|,
name|code
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate space for the signal handler context. 	 */
if|if
condition|(
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_ALTSTACK
operator|)
operator|&&
operator|!
name|oonstack
operator|&&
name|SIGISMEMBER
argument_list|(
name|psp
operator|->
name|ps_sigonstack
argument_list|,
name|sig
argument_list|)
condition|)
block|{
name|fp
operator|=
operator|(
expr|struct
name|l_sigframe
operator|*
operator|)
operator|(
name|td
operator|->
name|td_sigstk
operator|.
name|ss_sp
operator|+
name|td
operator|->
name|td_sigstk
operator|.
name|ss_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|l_sigframe
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|fp
operator|=
operator|(
expr|struct
name|l_sigframe
operator|*
operator|)
name|regs
operator|->
name|tf_rsp
operator|-
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|psp
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Build the argument list for the signal handler. 	 */
name|sig
operator|=
name|bsd_to_linux_signal
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|frame
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_handler
operator|=
name|PTROUT
argument_list|(
name|catcher
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_sig
operator|=
name|sig
expr_stmt|;
name|bsd_to_linux_sigset
argument_list|(
name|mask
argument_list|,
operator|&
name|lmask
argument_list|)
expr_stmt|;
comment|/* 	 * Build the signal context to be used by sigreturn. 	 */
name|frame
operator|.
name|sf_sc
operator|.
name|sc_mask
operator|=
name|lmask
operator|.
name|__mask
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_gs
operator|=
name|regs
operator|->
name|tf_gs
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_fs
operator|=
name|regs
operator|->
name|tf_fs
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_es
operator|=
name|regs
operator|->
name|tf_es
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ds
operator|=
name|regs
operator|->
name|tf_ds
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_edi
operator|=
name|regs
operator|->
name|tf_rdi
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_esi
operator|=
name|regs
operator|->
name|tf_rsi
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ebp
operator|=
name|regs
operator|->
name|tf_rbp
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ebx
operator|=
name|regs
operator|->
name|tf_rbx
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_esp
operator|=
name|regs
operator|->
name|tf_rsp
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_edx
operator|=
name|regs
operator|->
name|tf_rdx
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ecx
operator|=
name|regs
operator|->
name|tf_rcx
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_eax
operator|=
name|regs
operator|->
name|tf_rax
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_eip
operator|=
name|regs
operator|->
name|tf_rip
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_cs
operator|=
name|regs
operator|->
name|tf_cs
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_eflags
operator|=
name|regs
operator|->
name|tf_rflags
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_esp_at_signal
operator|=
name|regs
operator|->
name|tf_rsp
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ss
operator|=
name|regs
operator|->
name|tf_ss
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_err
operator|=
name|regs
operator|->
name|tf_err
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_cr2
operator|=
operator|(
name|u_int32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ksi
operator|->
name|ksi_addr
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_trapno
operator|=
name|bsd_to_linux_trapcode
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_extramask
index|[
literal|0
index|]
operator|=
name|lmask
operator|.
name|__mask
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|frame
argument_list|,
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Process has trashed its stack; give it an illegal 		 * instruction to halt it in its tracks. 		 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigexit
argument_list|(
name|td
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Build context to run handler in. 	 */
name|regs
operator|->
name|tf_rsp
operator|=
name|PTROUT
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|regs
operator|->
name|tf_rip
operator|=
name|linux32_sigcode
expr_stmt|;
name|regs
operator|->
name|tf_rflags
operator|&=
operator|~
operator|(
name|PSL_T
operator||
name|PSL_D
operator|)
expr_stmt|;
name|regs
operator|->
name|tf_cs
operator|=
name|_ucode32sel
expr_stmt|;
name|regs
operator|->
name|tf_ss
operator|=
name|_udatasel
expr_stmt|;
name|regs
operator|->
name|tf_ds
operator|=
name|_udatasel
expr_stmt|;
name|regs
operator|->
name|tf_es
operator|=
name|_udatasel
expr_stmt|;
name|regs
operator|->
name|tf_fs
operator|=
name|_ufssel
expr_stmt|;
name|regs
operator|->
name|tf_gs
operator|=
name|_ugssel
expr_stmt|;
name|regs
operator|->
name|tf_flags
operator|=
name|TF_HASSEGS
expr_stmt|;
name|set_pcb_flags
argument_list|(
name|td
operator|->
name|td_pcb
argument_list|,
name|PCB_FULL_IRET
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|psp
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * System call to cleanup state after a signal  * has been taken.  Reset signal mask and  * stack state from context left by sendsig (above).  * Return to previous pc and psl as specified by  * context left by sendsig. Check carefully to  * make sure that the user has not modified the  * psl to gain improper privileges or to cause  * a machine fault.  */
end_comment

begin_function
name|int
name|linux_sigreturn
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sigreturn_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_sigframe
name|frame
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|regs
decl_stmt|;
name|sigset_t
name|bmask
decl_stmt|;
name|l_sigset_t
name|lmask
decl_stmt|;
name|int
name|eflags
decl_stmt|;
name|ksiginfo_t
name|ksi
decl_stmt|;
name|regs
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sigreturn
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sigreturn
argument_list|,
literal|"%p"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|sfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The trampoline code hands us the sigframe. 	 * It is unsafe to keep track of it ourselves, in the event that a 	 * program jumps out of a signal handler. 	 */
if|if
condition|(
name|copyin
argument_list|(
name|args
operator|->
name|sfp
argument_list|,
operator|&
name|frame
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* 	 * Check for security violations. 	 */
define|#
directive|define
name|EFLAGS_SECURE
parameter_list|(
name|ef
parameter_list|,
name|oef
parameter_list|)
value|((((ef) ^ (oef))& ~PSL_USERCHANGE) == 0)
name|eflags
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_eflags
expr_stmt|;
if|if
condition|(
operator|!
name|EFLAGS_SECURE
argument_list|(
name|eflags
argument_list|,
name|regs
operator|->
name|tf_rflags
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Don't allow users to load a valid privileged %cs.  Let the 	 * hardware check for invalid selectors, excess privilege in 	 * other selectors, invalid %eip's and invalid %esp's. 	 */
define|#
directive|define
name|CS_SECURE
parameter_list|(
name|cs
parameter_list|)
value|(ISPL(cs) == SEL_UPL)
if|if
condition|(
operator|!
name|CS_SECURE
argument_list|(
name|frame
operator|.
name|sf_sc
operator|.
name|sc_cs
argument_list|)
condition|)
block|{
name|ksiginfo_init_trap
argument_list|(
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|ksi_signo
operator|=
name|SIGBUS
expr_stmt|;
name|ksi
operator|.
name|ksi_code
operator|=
name|BUS_OBJERR
expr_stmt|;
name|ksi
operator|.
name|ksi_trapno
operator|=
name|T_PROTFLT
expr_stmt|;
name|ksi
operator|.
name|ksi_addr
operator|=
operator|(
name|void
operator|*
operator|)
name|regs
operator|->
name|tf_rip
expr_stmt|;
name|trapsignal
argument_list|(
name|td
argument_list|,
operator|&
name|ksi
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|lmask
operator|.
name|__mask
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_mask
expr_stmt|;
name|lmask
operator|.
name|__mask
operator|=
name|frame
operator|.
name|sf_extramask
index|[
literal|0
index|]
expr_stmt|;
name|linux_to_bsd_sigset
argument_list|(
operator|&
name|lmask
argument_list|,
operator|&
name|bmask
argument_list|)
expr_stmt|;
name|kern_sigprocmask
argument_list|(
name|td
argument_list|,
name|SIG_SETMASK
argument_list|,
operator|&
name|bmask
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Restore signal context. 	 */
name|regs
operator|->
name|tf_rdi
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_edi
expr_stmt|;
name|regs
operator|->
name|tf_rsi
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_esi
expr_stmt|;
name|regs
operator|->
name|tf_rbp
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ebp
expr_stmt|;
name|regs
operator|->
name|tf_rbx
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ebx
expr_stmt|;
name|regs
operator|->
name|tf_rdx
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_edx
expr_stmt|;
name|regs
operator|->
name|tf_rcx
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ecx
expr_stmt|;
name|regs
operator|->
name|tf_rax
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_eax
expr_stmt|;
name|regs
operator|->
name|tf_rip
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_eip
expr_stmt|;
name|regs
operator|->
name|tf_cs
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_cs
expr_stmt|;
name|regs
operator|->
name|tf_ds
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ds
expr_stmt|;
name|regs
operator|->
name|tf_es
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_es
expr_stmt|;
name|regs
operator|->
name|tf_fs
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_fs
expr_stmt|;
name|regs
operator|->
name|tf_gs
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_gs
expr_stmt|;
name|regs
operator|->
name|tf_rflags
operator|=
name|eflags
expr_stmt|;
name|regs
operator|->
name|tf_rsp
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_esp_at_signal
expr_stmt|;
name|regs
operator|->
name|tf_ss
operator|=
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ss
expr_stmt|;
name|set_pcb_flags
argument_list|(
name|td
operator|->
name|td_pcb
argument_list|,
name|PCB_FULL_IRET
argument_list|)
expr_stmt|;
return|return
operator|(
name|EJUSTRETURN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * System call to cleanup state after a signal  * has been taken.  Reset signal mask and  * stack state from context left by rt_sendsig (above).  * Return to previous pc and psl as specified by  * context left by sendsig. Check carefully to  * make sure that the user has not modified the  * psl to gain improper privileges or to cause  * a machine fault.  */
end_comment

begin_function
name|int
name|linux_rt_sigreturn
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_rt_sigreturn_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_ucontext
name|uc
decl_stmt|;
name|struct
name|l_sigcontext
modifier|*
name|context
decl_stmt|;
name|sigset_t
name|bmask
decl_stmt|;
name|l_stack_t
modifier|*
name|lss
decl_stmt|;
name|stack_t
name|ss
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|regs
decl_stmt|;
name|int
name|eflags
decl_stmt|;
name|ksiginfo_t
name|ksi
decl_stmt|;
name|regs
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|rt_sigreturn
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|rt_sigreturn
argument_list|,
literal|"%p"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|ucp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The trampoline code hands us the ucontext. 	 * It is unsafe to keep track of it ourselves, in the event that a 	 * program jumps out of a signal handler. 	 */
if|if
condition|(
name|copyin
argument_list|(
name|args
operator|->
name|ucp
argument_list|,
operator|&
name|uc
argument_list|,
sizeof|sizeof
argument_list|(
name|uc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|context
operator|=
operator|&
name|uc
operator|.
name|uc_mcontext
expr_stmt|;
comment|/* 	 * Check for security violations. 	 */
define|#
directive|define
name|EFLAGS_SECURE
parameter_list|(
name|ef
parameter_list|,
name|oef
parameter_list|)
value|((((ef) ^ (oef))& ~PSL_USERCHANGE) == 0)
name|eflags
operator|=
name|context
operator|->
name|sc_eflags
expr_stmt|;
if|if
condition|(
operator|!
name|EFLAGS_SECURE
argument_list|(
name|eflags
argument_list|,
name|regs
operator|->
name|tf_rflags
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Don't allow users to load a valid privileged %cs.  Let the 	 * hardware check for invalid selectors, excess privilege in 	 * other selectors, invalid %eip's and invalid %esp's. 	 */
define|#
directive|define
name|CS_SECURE
parameter_list|(
name|cs
parameter_list|)
value|(ISPL(cs) == SEL_UPL)
if|if
condition|(
operator|!
name|CS_SECURE
argument_list|(
name|context
operator|->
name|sc_cs
argument_list|)
condition|)
block|{
name|ksiginfo_init_trap
argument_list|(
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|ksi_signo
operator|=
name|SIGBUS
expr_stmt|;
name|ksi
operator|.
name|ksi_code
operator|=
name|BUS_OBJERR
expr_stmt|;
name|ksi
operator|.
name|ksi_trapno
operator|=
name|T_PROTFLT
expr_stmt|;
name|ksi
operator|.
name|ksi_addr
operator|=
operator|(
name|void
operator|*
operator|)
name|regs
operator|->
name|tf_rip
expr_stmt|;
name|trapsignal
argument_list|(
name|td
argument_list|,
operator|&
name|ksi
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|linux_to_bsd_sigset
argument_list|(
operator|&
name|uc
operator|.
name|uc_sigmask
argument_list|,
operator|&
name|bmask
argument_list|)
expr_stmt|;
name|kern_sigprocmask
argument_list|(
name|td
argument_list|,
name|SIG_SETMASK
argument_list|,
operator|&
name|bmask
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Restore signal context 	 */
name|regs
operator|->
name|tf_gs
operator|=
name|context
operator|->
name|sc_gs
expr_stmt|;
name|regs
operator|->
name|tf_fs
operator|=
name|context
operator|->
name|sc_fs
expr_stmt|;
name|regs
operator|->
name|tf_es
operator|=
name|context
operator|->
name|sc_es
expr_stmt|;
name|regs
operator|->
name|tf_ds
operator|=
name|context
operator|->
name|sc_ds
expr_stmt|;
name|regs
operator|->
name|tf_rdi
operator|=
name|context
operator|->
name|sc_edi
expr_stmt|;
name|regs
operator|->
name|tf_rsi
operator|=
name|context
operator|->
name|sc_esi
expr_stmt|;
name|regs
operator|->
name|tf_rbp
operator|=
name|context
operator|->
name|sc_ebp
expr_stmt|;
name|regs
operator|->
name|tf_rbx
operator|=
name|context
operator|->
name|sc_ebx
expr_stmt|;
name|regs
operator|->
name|tf_rdx
operator|=
name|context
operator|->
name|sc_edx
expr_stmt|;
name|regs
operator|->
name|tf_rcx
operator|=
name|context
operator|->
name|sc_ecx
expr_stmt|;
name|regs
operator|->
name|tf_rax
operator|=
name|context
operator|->
name|sc_eax
expr_stmt|;
name|regs
operator|->
name|tf_rip
operator|=
name|context
operator|->
name|sc_eip
expr_stmt|;
name|regs
operator|->
name|tf_cs
operator|=
name|context
operator|->
name|sc_cs
expr_stmt|;
name|regs
operator|->
name|tf_rflags
operator|=
name|eflags
expr_stmt|;
name|regs
operator|->
name|tf_rsp
operator|=
name|context
operator|->
name|sc_esp_at_signal
expr_stmt|;
name|regs
operator|->
name|tf_ss
operator|=
name|context
operator|->
name|sc_ss
expr_stmt|;
name|set_pcb_flags
argument_list|(
name|td
operator|->
name|td_pcb
argument_list|,
name|PCB_FULL_IRET
argument_list|)
expr_stmt|;
comment|/* 	 * call sigaltstack& ignore results.. 	 */
name|lss
operator|=
operator|&
name|uc
operator|.
name|uc_stack
expr_stmt|;
name|ss
operator|.
name|ss_sp
operator|=
name|PTRIN
argument_list|(
name|lss
operator|->
name|ss_sp
argument_list|)
expr_stmt|;
name|ss
operator|.
name|ss_size
operator|=
name|lss
operator|->
name|ss_size
expr_stmt|;
name|ss
operator|.
name|ss_flags
operator|=
name|linux_to_bsd_sigaltstack
argument_list|(
name|lss
operator|->
name|ss_flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|rt_sigreturn
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"rt_sigret flags: 0x%x, sp: %p, ss: 0x%lx, mask: 0x%x"
argument_list|)
argument_list|,
name|ss
operator|.
name|ss_flags
argument_list|,
name|ss
operator|.
name|ss_sp
argument_list|,
name|ss
operator|.
name|ss_size
argument_list|,
name|context
operator|->
name|sc_mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|kern_sigaltstack
argument_list|(
name|td
argument_list|,
operator|&
name|ss
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EJUSTRETURN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|linux32_fetch_syscall_args
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|syscall_args
modifier|*
name|sa
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|frame
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|0
index|]
operator|=
name|frame
operator|->
name|tf_rbx
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|1
index|]
operator|=
name|frame
operator|->
name|tf_rcx
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|2
index|]
operator|=
name|frame
operator|->
name|tf_rdx
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|3
index|]
operator|=
name|frame
operator|->
name|tf_rsi
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|4
index|]
operator|=
name|frame
operator|->
name|tf_rdi
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|5
index|]
operator|=
name|frame
operator|->
name|tf_rbp
expr_stmt|;
comment|/* Unconfirmed */
name|sa
operator|->
name|code
operator|=
name|frame
operator|->
name|tf_rax
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|code
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
comment|/* nosys */
name|sa
operator|->
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|sa
operator|->
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|sa
operator|->
name|code
index|]
expr_stmt|;
name|sa
operator|->
name|narg
operator|=
name|sa
operator|->
name|callp
operator|->
name|sy_narg
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|frame
operator|->
name|tf_rdx
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If a linux binary is exec'ing something, try this image activator  * first.  We override standard shell script execution in order to  * be able to modify the interpreter path.  We only do this if a linux  * binary is doing the exec, so we do not create an EXEC module for it.  */
end_comment

begin_function_decl
specifier|static
name|int
name|exec_linux_imgact_try
parameter_list|(
name|struct
name|image_params
modifier|*
name|iparams
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|exec_linux_imgact_try
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|head
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|imgp
operator|->
name|image_header
decl_stmt|;
name|char
modifier|*
name|rpath
decl_stmt|;
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
comment|/* 	* The interpreter for shell scripts run from a linux binary needs 	* to be located in /compat/linux if possible in order to recursively 	* maintain linux path emulation. 	*/
if|if
condition|(
operator|(
operator|(
specifier|const
name|short
operator|*
operator|)
name|head
operator|)
index|[
literal|0
index|]
operator|==
name|SHELLMAGIC
condition|)
block|{
comment|/* 		* Run our normal shell image activator.  If it succeeds attempt 		* to use the alternate path for the interpreter.  If an 		* alternate * path is found, use our stringspace to store it. 		*/
if|if
condition|(
operator|(
name|error
operator|=
name|exec_shell_imgact
argument_list|(
name|imgp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|linux_emul_convpath
argument_list|(
name|FIRST_THREAD_IN_PROC
argument_list|(
name|imgp
operator|->
name|proc
argument_list|)
argument_list|,
name|imgp
operator|->
name|interpreter_name
argument_list|,
name|UIO_SYSSPACE
argument_list|,
operator|&
name|rpath
argument_list|,
literal|0
argument_list|,
name|AT_FDCWD
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpath
operator|!=
name|NULL
condition|)
name|imgp
operator|->
name|args
operator|->
name|fname_buf
operator|=
name|imgp
operator|->
name|interpreter_name
operator|=
name|rpath
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear registers on exec  * XXX copied from ia32_signal.c.  */
end_comment

begin_function
specifier|static
name|void
name|exec_linux_setregs
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|,
name|u_long
name|stack
parameter_list|)
block|{
name|struct
name|trapframe
modifier|*
name|regs
init|=
name|td
operator|->
name|td_frame
decl_stmt|;
name|struct
name|pcb
modifier|*
name|pcb
init|=
name|td
operator|->
name|td_pcb
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dt_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_proc
operator|->
name|p_md
operator|.
name|md_ldt
operator|!=
name|NULL
condition|)
name|user_ldt_free
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|else
name|mtx_unlock
argument_list|(
operator|&
name|dt_lock
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_FSBASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_KGSBASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* User value while we're in the kernel */
name|pcb
operator|->
name|pcb_fsbase
operator|=
literal|0
expr_stmt|;
name|pcb
operator|->
name|pcb_gsbase
operator|=
literal|0
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|pcb
operator|->
name|pcb_initial_fpucw
operator|=
name|__LINUX_NPXCW__
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|trapframe
argument_list|)
argument_list|)
expr_stmt|;
name|regs
operator|->
name|tf_rip
operator|=
name|imgp
operator|->
name|entry_addr
expr_stmt|;
name|regs
operator|->
name|tf_rsp
operator|=
name|stack
expr_stmt|;
name|regs
operator|->
name|tf_rflags
operator|=
name|PSL_USER
operator||
operator|(
name|regs
operator|->
name|tf_rflags
operator|&
name|PSL_T
operator|)
expr_stmt|;
name|regs
operator|->
name|tf_gs
operator|=
name|_ugssel
expr_stmt|;
name|regs
operator|->
name|tf_fs
operator|=
name|_ufssel
expr_stmt|;
name|regs
operator|->
name|tf_es
operator|=
name|_udatasel
expr_stmt|;
name|regs
operator|->
name|tf_ds
operator|=
name|_udatasel
expr_stmt|;
name|regs
operator|->
name|tf_ss
operator|=
name|_udatasel
expr_stmt|;
name|regs
operator|->
name|tf_flags
operator|=
name|TF_HASSEGS
expr_stmt|;
name|regs
operator|->
name|tf_cs
operator|=
name|_ucode32sel
expr_stmt|;
name|regs
operator|->
name|tf_rbx
operator|=
name|imgp
operator|->
name|ps_strings
expr_stmt|;
name|fpstate_drop
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* Do full restore on return so that we can change to a different %cs */
name|set_pcb_flags
argument_list|(
name|pcb
argument_list|,
name|PCB_32BIT
operator||
name|PCB_FULL_IRET
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX copied from ia32_sysvec.c.  */
end_comment

begin_function
specifier|static
name|register_t
modifier|*
name|linux_copyout_strings
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
name|int
name|argc
decl_stmt|,
name|envc
decl_stmt|;
name|u_int32_t
modifier|*
name|vectp
decl_stmt|;
name|char
modifier|*
name|stringp
decl_stmt|,
modifier|*
name|destp
decl_stmt|;
name|u_int32_t
modifier|*
name|stack_base
decl_stmt|;
name|struct
name|linux32_ps_strings
modifier|*
name|arginfo
decl_stmt|;
name|char
name|canary
index|[
name|LINUX_AT_RANDOM_LEN
index|]
decl_stmt|;
name|size_t
name|execpath_len
decl_stmt|;
comment|/* 	 * Calculate string base and vector table pointers. 	 */
if|if
condition|(
name|imgp
operator|->
name|execpath
operator|!=
name|NULL
operator|&&
name|imgp
operator|->
name|auxargs
operator|!=
name|NULL
condition|)
name|execpath_len
operator|=
name|strlen
argument_list|(
name|imgp
operator|->
name|execpath
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|execpath_len
operator|=
literal|0
expr_stmt|;
name|arginfo
operator|=
operator|(
expr|struct
name|linux32_ps_strings
operator|*
operator|)
name|LINUX32_PS_STRINGS
expr_stmt|;
name|destp
operator|=
operator|(
name|caddr_t
operator|)
name|arginfo
operator|-
name|SPARE_USRSPACE
operator|-
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|canary
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|-
name|roundup
argument_list|(
name|execpath_len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|-
name|roundup
argument_list|(
name|ARG_MAX
operator|-
name|imgp
operator|->
name|args
operator|->
name|stringspace
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|execpath_len
operator|!=
literal|0
condition|)
block|{
name|imgp
operator|->
name|execpathp
operator|=
operator|(
name|uintptr_t
operator|)
name|arginfo
operator|-
name|execpath_len
expr_stmt|;
name|copyout
argument_list|(
name|imgp
operator|->
name|execpath
argument_list|,
operator|(
name|void
operator|*
operator|)
name|imgp
operator|->
name|execpathp
argument_list|,
name|execpath_len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Prepare the canary for SSP. 	 */
name|arc4rand
argument_list|(
name|canary
argument_list|,
sizeof|sizeof
argument_list|(
name|canary
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|canary
operator|=
operator|(
name|uintptr_t
operator|)
name|arginfo
operator|-
name|roundup
argument_list|(
name|execpath_len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|-
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|canary
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|canary
argument_list|,
operator|(
name|void
operator|*
operator|)
name|imgp
operator|->
name|canary
argument_list|,
sizeof|sizeof
argument_list|(
name|canary
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we have a valid auxargs ptr, prepare some room 	 * on the stack. 	 */
if|if
condition|(
name|imgp
operator|->
name|auxargs
condition|)
block|{
comment|/* 		 * 'AT_COUNT*2' is size for the ELF Auxargs data. This is for 		 * lower compatibility. 		 */
name|imgp
operator|->
name|auxarg_size
operator|=
operator|(
name|imgp
operator|->
name|auxarg_size
operator|)
condition|?
name|imgp
operator|->
name|auxarg_size
else|:
operator|(
name|LINUX_AT_COUNT
operator|*
literal|2
operator|)
expr_stmt|;
comment|/* 		 * The '+ 2' is for the null pointers at the end of each of 		 * the arg and env vector sets,and imgp->auxarg_size is room 		 * for argument of Runtime loader. 		 */
name|vectp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|destp
operator|-
operator|(
name|imgp
operator|->
name|args
operator|->
name|argc
operator|+
name|imgp
operator|->
name|args
operator|->
name|envc
operator|+
literal|2
operator|+
name|imgp
operator|->
name|auxarg_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
comment|/* 		 * The '+ 2' is for the null pointers at the end of each of 		 * the arg and env vector sets 		 */
name|vectp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|destp
operator|-
operator|(
name|imgp
operator|->
name|args
operator|->
name|argc
operator|+
name|imgp
operator|->
name|args
operator|->
name|envc
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * vectp also becomes our initial stack base 	 */
name|stack_base
operator|=
name|vectp
expr_stmt|;
name|stringp
operator|=
name|imgp
operator|->
name|args
operator|->
name|begin_argv
expr_stmt|;
name|argc
operator|=
name|imgp
operator|->
name|args
operator|->
name|argc
expr_stmt|;
name|envc
operator|=
name|imgp
operator|->
name|args
operator|->
name|envc
expr_stmt|;
comment|/* 	 * Copy out strings - arguments and environment. 	 */
name|copyout
argument_list|(
name|stringp
argument_list|,
name|destp
argument_list|,
name|ARG_MAX
operator|-
name|imgp
operator|->
name|args
operator|->
name|stringspace
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in "ps_strings" struct for ps, w, etc. 	 */
name|suword32
argument_list|(
operator|&
name|arginfo
operator|->
name|ps_argvstr
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|intptr_t
operator|)
name|vectp
argument_list|)
expr_stmt|;
name|suword32
argument_list|(
operator|&
name|arginfo
operator|->
name|ps_nargvstr
argument_list|,
name|argc
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in argument portion of vector table. 	 */
for|for
control|(
init|;
name|argc
operator|>
literal|0
condition|;
operator|--
name|argc
control|)
block|{
name|suword32
argument_list|(
name|vectp
operator|++
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|intptr_t
operator|)
name|destp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|stringp
operator|++
operator|!=
literal|0
condition|)
name|destp
operator|++
expr_stmt|;
name|destp
operator|++
expr_stmt|;
block|}
comment|/* a null vector table pointer separates the argp's from the envp's */
name|suword32
argument_list|(
name|vectp
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|suword32
argument_list|(
operator|&
name|arginfo
operator|->
name|ps_envstr
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|intptr_t
operator|)
name|vectp
argument_list|)
expr_stmt|;
name|suword32
argument_list|(
operator|&
name|arginfo
operator|->
name|ps_nenvstr
argument_list|,
name|envc
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in environment portion of vector table. 	 */
for|for
control|(
init|;
name|envc
operator|>
literal|0
condition|;
operator|--
name|envc
control|)
block|{
name|suword32
argument_list|(
name|vectp
operator|++
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|intptr_t
operator|)
name|destp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|stringp
operator|++
operator|!=
literal|0
condition|)
name|destp
operator|++
expr_stmt|;
name|destp
operator|++
expr_stmt|;
block|}
comment|/* end of vector table is a null pointer */
name|suword32
argument_list|(
name|vectp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|register_t
operator|*
operator|)
name|stack_base
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_compat
argument_list|,
name|OID_AUTO
argument_list|,
name|linux32
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"32-bit Linux emulation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|linux32_maxdsiz
init|=
name|LINUX32_MAXDSIZ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_compat_linux32
argument_list|,
name|OID_AUTO
argument_list|,
name|maxdsiz
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|linux32_maxdsiz
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|linux32_maxssiz
init|=
name|LINUX32_MAXSSIZ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_compat_linux32
argument_list|,
name|OID_AUTO
argument_list|,
name|maxssiz
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|linux32_maxssiz
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|linux32_maxvmem
init|=
name|LINUX32_MAXVMEM
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_compat_linux32
argument_list|,
name|OID_AUTO
argument_list|,
name|maxvmem
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|linux32_maxvmem
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
end_if

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_compat_linux32
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|linux_sysctl_debug
argument_list|,
literal|"A"
argument_list|,
literal|"Linux debugging control"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|linux32_fixlimit
parameter_list|(
name|struct
name|rlimit
modifier|*
name|rl
parameter_list|,
name|int
name|which
parameter_list|)
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|RLIMIT_DATA
case|:
if|if
condition|(
name|linux32_maxdsiz
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rl
operator|->
name|rlim_cur
operator|>
name|linux32_maxdsiz
condition|)
name|rl
operator|->
name|rlim_cur
operator|=
name|linux32_maxdsiz
expr_stmt|;
if|if
condition|(
name|rl
operator|->
name|rlim_max
operator|>
name|linux32_maxdsiz
condition|)
name|rl
operator|->
name|rlim_max
operator|=
name|linux32_maxdsiz
expr_stmt|;
block|}
break|break;
case|case
name|RLIMIT_STACK
case|:
if|if
condition|(
name|linux32_maxssiz
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rl
operator|->
name|rlim_cur
operator|>
name|linux32_maxssiz
condition|)
name|rl
operator|->
name|rlim_cur
operator|=
name|linux32_maxssiz
expr_stmt|;
if|if
condition|(
name|rl
operator|->
name|rlim_max
operator|>
name|linux32_maxssiz
condition|)
name|rl
operator|->
name|rlim_max
operator|=
name|linux32_maxssiz
expr_stmt|;
block|}
break|break;
case|case
name|RLIMIT_VMEM
case|:
if|if
condition|(
name|linux32_maxvmem
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rl
operator|->
name|rlim_cur
operator|>
name|linux32_maxvmem
condition|)
name|rl
operator|->
name|rlim_cur
operator|=
name|linux32_maxvmem
expr_stmt|;
if|if
condition|(
name|rl
operator|->
name|rlim_max
operator|>
name|linux32_maxvmem
condition|)
name|rl
operator|->
name|rlim_max
operator|=
name|linux32_maxvmem
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_decl_stmt
name|struct
name|sysentvec
name|elf_linux_sysvec
init|=
block|{
operator|.
name|sv_size
operator|=
name|LINUX32_SYS_MAXSYSCALL
block|,
operator|.
name|sv_table
operator|=
name|linux32_sysent
block|,
operator|.
name|sv_mask
operator|=
literal|0
block|,
operator|.
name|sv_sigsize
operator|=
literal|0
block|,
operator|.
name|sv_sigtbl
operator|=
name|NULL
block|,
operator|.
name|sv_errsize
operator|=
name|ELAST
operator|+
literal|1
block|,
operator|.
name|sv_errtbl
operator|=
name|bsd_to_linux_errno
block|,
operator|.
name|sv_transtrap
operator|=
name|translate_traps
block|,
operator|.
name|sv_fixup
operator|=
name|elf_linux_fixup
block|,
operator|.
name|sv_sendsig
operator|=
name|linux_sendsig
block|,
operator|.
name|sv_sigcode
operator|=
operator|&
name|_binary_linux32_locore_o_start
block|,
operator|.
name|sv_szsigcode
operator|=
operator|&
name|linux_szsigcode
block|,
operator|.
name|sv_prepsyscall
operator|=
name|NULL
block|,
operator|.
name|sv_name
operator|=
literal|"Linux ELF32"
block|,
operator|.
name|sv_coredump
operator|=
name|elf32_coredump
block|,
operator|.
name|sv_imgact_try
operator|=
name|exec_linux_imgact_try
block|,
operator|.
name|sv_minsigstksz
operator|=
name|LINUX_MINSIGSTKSZ
block|,
operator|.
name|sv_pagesize
operator|=
name|PAGE_SIZE
block|,
operator|.
name|sv_minuser
operator|=
name|VM_MIN_ADDRESS
block|,
operator|.
name|sv_maxuser
operator|=
name|LINUX32_MAXUSER
block|,
operator|.
name|sv_usrstack
operator|=
name|LINUX32_USRSTACK
block|,
operator|.
name|sv_psstrings
operator|=
name|LINUX32_PS_STRINGS
block|,
operator|.
name|sv_stackprot
operator|=
name|VM_PROT_ALL
block|,
operator|.
name|sv_copyout_strings
operator|=
name|linux_copyout_strings
block|,
operator|.
name|sv_setregs
operator|=
name|exec_linux_setregs
block|,
operator|.
name|sv_fixlimit
operator|=
name|linux32_fixlimit
block|,
operator|.
name|sv_maxssiz
operator|=
operator|&
name|linux32_maxssiz
block|,
operator|.
name|sv_flags
operator|=
name|SV_ABI_LINUX
operator||
name|SV_ILP32
operator||
name|SV_IA32
operator||
name|SV_SHP
block|,
operator|.
name|sv_set_syscall_retval
operator|=
name|cpu_set_syscall_retval
block|,
operator|.
name|sv_fetch_syscall_args
operator|=
name|linux32_fetch_syscall_args
block|,
operator|.
name|sv_syscallnames
operator|=
name|NULL
block|,
operator|.
name|sv_shared_page_base
operator|=
name|LINUX32_SHAREDPAGE
block|,
operator|.
name|sv_shared_page_len
operator|=
name|PAGE_SIZE
block|,
operator|.
name|sv_schedtail
operator|=
name|linux_schedtail
block|,
operator|.
name|sv_thread_detach
operator|=
name|linux_thread_detach
block|,
operator|.
name|sv_trap
operator|=
name|NULL
block|,	 }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|linux_vdso_install
parameter_list|(
name|void
modifier|*
name|param
parameter_list|)
block|{
name|linux_szsigcode
operator|=
operator|(
operator|&
name|_binary_linux32_locore_o_end
operator|-
operator|&
name|_binary_linux32_locore_o_start
operator|)
expr_stmt|;
if|if
condition|(
name|linux_szsigcode
operator|>
name|elf_linux_sysvec
operator|.
name|sv_shared_page_len
condition|)
name|panic
argument_list|(
literal|"Linux invalid vdso size\n"
argument_list|)
expr_stmt|;
name|__elfN
argument_list|(
name|linux_vdso_fixup
argument_list|)
argument_list|(
operator|&
name|elf_linux_sysvec
argument_list|)
expr_stmt|;
name|linux_shared_page_obj
operator|=
name|__elfN
argument_list|(
name|linux_shared_page_init
argument_list|)
argument_list|(
operator|&
name|linux_shared_page_mapping
argument_list|)
expr_stmt|;
name|__elfN
argument_list|(
name|linux_vdso_reloc
argument_list|)
argument_list|(
operator|&
name|elf_linux_sysvec
argument_list|,
name|LINUX32_SHAREDPAGE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|elf_linux_sysvec
operator|.
name|sv_sigcode
argument_list|,
name|linux_shared_page_mapping
argument_list|,
name|linux_szsigcode
argument_list|)
expr_stmt|;
name|elf_linux_sysvec
operator|.
name|sv_shared_page_obj
operator|=
name|linux_shared_page_obj
expr_stmt|;
name|linux_kplatform
operator|=
name|linux_shared_page_mapping
operator|+
operator|(
name|linux_platform
operator|-
operator|(
name|caddr_t
operator|)
name|LINUX32_SHAREDPAGE
operator|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|elf_linux_vdso_init
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_ANY
argument_list|,
operator|(
name|sysinit_cfunc_t
operator|)
name|linux_vdso_install
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|linux_vdso_deinstall
parameter_list|(
name|void
modifier|*
name|param
parameter_list|)
block|{
name|__elfN
function_decl|(
name|linux_shared_page_fini
function_decl|)
parameter_list|(
name|linux_shared_page_obj
parameter_list|)
function_decl|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|elf_linux_vdso_uninit
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
operator|(
name|sysinit_cfunc_t
operator|)
name|linux_vdso_deinstall
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
name|GNU_ABI_VENDOR
index|[]
init|=
literal|"GNU"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|GNULINUX_ABI_DESC
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean_t
name|linux32_trans_osrel
parameter_list|(
specifier|const
name|Elf_Note
modifier|*
name|note
parameter_list|,
name|int32_t
modifier|*
name|osrel
parameter_list|)
block|{
specifier|const
name|Elf32_Word
modifier|*
name|desc
decl_stmt|;
name|uintptr_t
name|p
decl_stmt|;
name|p
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
name|note
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|+=
name|roundup2
argument_list|(
name|note
operator|->
name|n_namesz
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_Addr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
specifier|const
name|Elf32_Word
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|desc
index|[
literal|0
index|]
operator|!=
name|GNULINUX_ABI_DESC
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 	 * For linux we encode osrel as follows (see linux_mib.c): 	 * VVVMMMIII (version, major, minor), see linux_mib.c. 	 */
operator|*
name|osrel
operator|=
name|desc
index|[
literal|1
index|]
operator|*
literal|1000000
operator|+
name|desc
index|[
literal|2
index|]
operator|*
literal|1000
operator|+
name|desc
index|[
literal|3
index|]
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|Elf_Brandnote
name|linux32_brandnote
init|=
block|{
operator|.
name|hdr
operator|.
name|n_namesz
operator|=
sizeof|sizeof
argument_list|(
name|GNU_ABI_VENDOR
argument_list|)
block|,
operator|.
name|hdr
operator|.
name|n_descsz
operator|=
literal|16
block|,
comment|/* XXX at least 16 */
operator|.
name|hdr
operator|.
name|n_type
operator|=
literal|1
block|,
operator|.
name|vendor
operator|=
name|GNU_ABI_VENDOR
block|,
operator|.
name|flags
operator|=
name|BN_TRANSLATE_OSREL
block|,
operator|.
name|trans_osrel
operator|=
name|linux32_trans_osrel
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf32_Brandinfo
name|linux_brand
init|=
block|{
operator|.
name|brand
operator|=
name|ELFOSABI_LINUX
block|,
operator|.
name|machine
operator|=
name|EM_386
block|,
operator|.
name|compat_3_brand
operator|=
literal|"Linux"
block|,
operator|.
name|emul_path
operator|=
literal|"/compat/linux"
block|,
operator|.
name|interp_path
operator|=
literal|"/lib/ld-linux.so.1"
block|,
operator|.
name|sysvec
operator|=
operator|&
name|elf_linux_sysvec
block|,
operator|.
name|interp_newpath
operator|=
name|NULL
block|,
operator|.
name|brand_note
operator|=
operator|&
name|linux32_brandnote
block|,
operator|.
name|flags
operator|=
name|BI_CAN_EXEC_DYN
operator||
name|BI_BRAND_NOTE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf32_Brandinfo
name|linux_glibc2brand
init|=
block|{
operator|.
name|brand
operator|=
name|ELFOSABI_LINUX
block|,
operator|.
name|machine
operator|=
name|EM_386
block|,
operator|.
name|compat_3_brand
operator|=
literal|"Linux"
block|,
operator|.
name|emul_path
operator|=
literal|"/compat/linux"
block|,
operator|.
name|interp_path
operator|=
literal|"/lib/ld-linux.so.2"
block|,
operator|.
name|sysvec
operator|=
operator|&
name|elf_linux_sysvec
block|,
operator|.
name|interp_newpath
operator|=
name|NULL
block|,
operator|.
name|brand_note
operator|=
operator|&
name|linux32_brandnote
block|,
operator|.
name|flags
operator|=
name|BI_CAN_EXEC_DYN
operator||
name|BI_BRAND_NOTE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf32_Brandinfo
modifier|*
name|linux_brandlist
index|[]
init|=
block|{
operator|&
name|linux_brand
block|,
operator|&
name|linux_glibc2brand
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|linux_elf_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Elf32_Brandinfo
modifier|*
modifier|*
name|brandinfo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|linux_ioctl_handler
modifier|*
modifier|*
name|lihp
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
for|for
control|(
name|brandinfo
operator|=
operator|&
name|linux_brandlist
index|[
literal|0
index|]
init|;
operator|*
name|brandinfo
operator|!=
name|NULL
condition|;
operator|++
name|brandinfo
control|)
if|if
condition|(
name|elf32_insert_brand_entry
argument_list|(
operator|*
name|brandinfo
argument_list|)
operator|<
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|SET_FOREACH
argument_list|(
argument|lihp
argument_list|,
argument|linux_ioctl_handler_set
argument_list|)
name|linux_ioctl_register_handler
argument_list|(
operator|*
name|lihp
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|futex_list
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|futex_mtx
argument_list|,
literal|"ftllk"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|stclohz
operator|=
operator|(
name|stathz
condition|?
name|stathz
else|:
name|hz
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Linux ELF exec handler installed\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"cannot insert Linux ELF brand handler\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
for|for
control|(
name|brandinfo
operator|=
operator|&
name|linux_brandlist
index|[
literal|0
index|]
init|;
operator|*
name|brandinfo
operator|!=
name|NULL
condition|;
operator|++
name|brandinfo
control|)
if|if
condition|(
name|elf32_brand_inuse
argument_list|(
operator|*
name|brandinfo
argument_list|)
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|brandinfo
operator|=
operator|&
name|linux_brandlist
index|[
literal|0
index|]
init|;
operator|*
name|brandinfo
operator|!=
name|NULL
condition|;
operator|++
name|brandinfo
control|)
if|if
condition|(
name|elf32_remove_brand_entry
argument_list|(
operator|*
name|brandinfo
argument_list|)
operator|<
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|SET_FOREACH
argument_list|(
argument|lihp
argument_list|,
argument|linux_ioctl_handler_set
argument_list|)
name|linux_ioctl_unregister_handler
argument_list|(
operator|*
name|lihp
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|futex_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Linux ELF exec handler removed\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Could not deinstall ELF interpreter entry\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|linux_elf_mod
init|=
block|{
literal|"linuxelf"
block|,
name|linux_elf_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE_TIED
argument_list|(
name|linuxelf
argument_list|,
name|linux_elf_mod
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|linuxelf
argument_list|,
name|linux_common
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|FEATURE
argument_list|(
name|linux
argument_list|,
literal|"Linux 32bit support"
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

