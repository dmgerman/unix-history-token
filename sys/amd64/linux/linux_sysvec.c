begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 Dmitry Chagin  * Copyright (c) 2004 Tim J. Robbins  * Copyright (c) 2003 Peter Wemm  * Copyright (c) 2002 Doug Rabson  * Copyright (c) 1998-1999 Andrew Gallatin  * Copyright (c) 1994-1996 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_define
define|#
directive|define
name|__ELF_WORD_SIZE
value|64
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_elf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<amd64/linux/linux.h>
end_include

begin_include
include|#
directive|include
file|<amd64/linux/linux_proto.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_emul.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_futex.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_mib.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_misc.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_signal.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_sysproto.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_util.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_vdso.h>
end_include

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|linux64
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
end_if

begin_define
define|#
directive|define
name|SHELLMAGIC
value|0x2123
end_define

begin_comment
comment|/* #! */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SHELLMAGIC
value|0x2321
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
end_if

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_compat_linux
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|linux_sysctl_debug
argument_list|,
literal|"A"
argument_list|,
literal|"Linux 64 debugging control"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allow the this functions to use the ldebug() facility  * even though they are not syscalls themselves. Map them  * to syscall 0. This is slightly less bogus than using  * ldebug(sigreturn).  */
end_comment

begin_define
define|#
directive|define
name|LINUX_SYS_linux_rt_sendsig
value|0
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|linux_kplatform
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|linux_szsigcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_object_t
name|linux_shared_page_obj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|linux_shared_page_mapping
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|_binary_linux_locore_o_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|_binary_linux_locore_o_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sysent
name|linux_sysent
index|[
name|LINUX_SYS_MAXSYSCALL
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SET_DECLARE
argument_list|(
name|linux_ioctl_handler_set
argument_list|,
expr|struct
name|linux_ioctl_handler
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|register_t
modifier|*
name|linux_copyout_strings
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|elf_linux_fixup
parameter_list|(
name|register_t
modifier|*
modifier|*
name|stack_base
parameter_list|,
name|struct
name|image_params
modifier|*
name|iparams
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|linux_trans_osrel
parameter_list|(
specifier|const
name|Elf_Note
modifier|*
name|note
parameter_list|,
name|int32_t
modifier|*
name|osrel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|linux_vdso_install
parameter_list|(
name|void
modifier|*
name|param
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|linux_vdso_deinstall
parameter_list|(
name|void
modifier|*
name|param
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|linux_set_syscall_retval
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|linux_fetch_syscall_args
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|syscall_args
modifier|*
name|sa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|linux_exec_setregs
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|,
name|u_long
name|stack
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|linux_vsyscall
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Linux syscalls return negative errno's, we do positive and map them  * Reference:  *   FreeBSD: src/sys/sys/errno.h  *   Linux:   linux-2.6.17.8/include/asm-generic/errno-base.h  *            linux-2.6.17.8/include/asm-generic/errno.h  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bsd_to_linux_errno
index|[
name|ELAST
operator|+
literal|1
index|]
init|=
block|{
operator|-
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|,
operator|-
literal|3
block|,
operator|-
literal|4
block|,
operator|-
literal|5
block|,
operator|-
literal|6
block|,
operator|-
literal|7
block|,
operator|-
literal|8
block|,
operator|-
literal|9
block|,
operator|-
literal|10
block|,
operator|-
literal|35
block|,
operator|-
literal|12
block|,
operator|-
literal|13
block|,
operator|-
literal|14
block|,
operator|-
literal|15
block|,
operator|-
literal|16
block|,
operator|-
literal|17
block|,
operator|-
literal|18
block|,
operator|-
literal|19
block|,
operator|-
literal|20
block|,
operator|-
literal|21
block|,
operator|-
literal|22
block|,
operator|-
literal|23
block|,
operator|-
literal|24
block|,
operator|-
literal|25
block|,
operator|-
literal|26
block|,
operator|-
literal|27
block|,
operator|-
literal|28
block|,
operator|-
literal|29
block|,
operator|-
literal|30
block|,
operator|-
literal|31
block|,
operator|-
literal|32
block|,
operator|-
literal|33
block|,
operator|-
literal|34
block|,
operator|-
literal|11
block|,
operator|-
literal|115
block|,
operator|-
literal|114
block|,
operator|-
literal|88
block|,
operator|-
literal|89
block|,
operator|-
literal|90
block|,
operator|-
literal|91
block|,
operator|-
literal|92
block|,
operator|-
literal|93
block|,
operator|-
literal|94
block|,
operator|-
literal|95
block|,
operator|-
literal|96
block|,
operator|-
literal|97
block|,
operator|-
literal|98
block|,
operator|-
literal|99
block|,
operator|-
literal|100
block|,
operator|-
literal|101
block|,
operator|-
literal|102
block|,
operator|-
literal|103
block|,
operator|-
literal|104
block|,
operator|-
literal|105
block|,
operator|-
literal|106
block|,
operator|-
literal|107
block|,
operator|-
literal|108
block|,
operator|-
literal|109
block|,
operator|-
literal|110
block|,
operator|-
literal|111
block|,
operator|-
literal|40
block|,
operator|-
literal|36
block|,
operator|-
literal|112
block|,
operator|-
literal|113
block|,
operator|-
literal|39
block|,
operator|-
literal|11
block|,
operator|-
literal|87
block|,
operator|-
literal|122
block|,
operator|-
literal|116
block|,
operator|-
literal|66
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|37
block|,
operator|-
literal|38
block|,
operator|-
literal|9
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|43
block|,
operator|-
literal|42
block|,
operator|-
literal|75
block|,
operator|-
literal|125
block|,
operator|-
literal|84
block|,
operator|-
literal|95
block|,
operator|-
literal|16
block|,
operator|-
literal|74
block|,
operator|-
literal|72
block|,
operator|-
literal|67
block|,
operator|-
literal|71
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LINUX_T_UNKNOWN
value|255
end_define

begin_decl_stmt
specifier|static
name|int
name|_bsd_to_linux_trapcode
index|[]
init|=
block|{
name|LINUX_T_UNKNOWN
block|,
comment|/* 0 */
literal|6
block|,
comment|/* 1  T_PRIVINFLT */
name|LINUX_T_UNKNOWN
block|,
comment|/* 2 */
literal|3
block|,
comment|/* 3  T_BPTFLT */
name|LINUX_T_UNKNOWN
block|,
comment|/* 4 */
name|LINUX_T_UNKNOWN
block|,
comment|/* 5 */
literal|16
block|,
comment|/* 6  T_ARITHTRAP */
literal|254
block|,
comment|/* 7  T_ASTFLT */
name|LINUX_T_UNKNOWN
block|,
comment|/* 8 */
literal|13
block|,
comment|/* 9  T_PROTFLT */
literal|1
block|,
comment|/* 10 T_TRCTRAP */
name|LINUX_T_UNKNOWN
block|,
comment|/* 11 */
literal|14
block|,
comment|/* 12 T_PAGEFLT */
name|LINUX_T_UNKNOWN
block|,
comment|/* 13 */
literal|17
block|,
comment|/* 14 T_ALIGNFLT */
name|LINUX_T_UNKNOWN
block|,
comment|/* 15 */
name|LINUX_T_UNKNOWN
block|,
comment|/* 16 */
name|LINUX_T_UNKNOWN
block|,
comment|/* 17 */
literal|0
block|,
comment|/* 18 T_DIVIDE */
literal|2
block|,
comment|/* 19 T_NMI */
literal|4
block|,
comment|/* 20 T_OFLOW */
literal|5
block|,
comment|/* 21 T_BOUND */
literal|7
block|,
comment|/* 22 T_DNA */
literal|8
block|,
comment|/* 23 T_DOUBLEFLT */
literal|9
block|,
comment|/* 24 T_FPOPFLT */
literal|10
block|,
comment|/* 25 T_TSSFLT */
literal|11
block|,
comment|/* 26 T_SEGNPFLT */
literal|12
block|,
comment|/* 27 T_STKFLT */
literal|18
block|,
comment|/* 28 T_MCHK */
literal|19
block|,
comment|/* 29 T_XMMFLT */
literal|15
comment|/* 30 T_RESERVED */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|bsd_to_linux_trapcode
parameter_list|(
name|code
parameter_list|)
define|\
value|((code)<sizeof(_bsd_to_linux_trapcode)/sizeof(*_bsd_to_linux_trapcode)? \      _bsd_to_linux_trapcode[(code)]: \      LINUX_T_UNKNOWN)
end_define

begin_expr_stmt
name|LINUX_VDSO_SYM_INTPTR
argument_list|(
name|linux_rt_sigcode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LINUX_VDSO_SYM_CHAR
argument_list|(
name|linux_platform
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * If FreeBSD& Linux have a difference of opinion about what a trap  * means, deal with it here.  *  * MPSAFE  */
end_comment

begin_function
specifier|static
name|int
name|translate_traps
parameter_list|(
name|int
name|signal
parameter_list|,
name|int
name|trap_code
parameter_list|)
block|{
if|if
condition|(
name|signal
operator|!=
name|SIGBUS
condition|)
return|return
name|signal
return|;
switch|switch
condition|(
name|trap_code
condition|)
block|{
case|case
name|T_PROTFLT
case|:
case|case
name|T_TSSFLT
case|:
case|case
name|T_DOUBLEFLT
case|:
case|case
name|T_PAGEFLT
case|:
return|return
name|SIGSEGV
return|;
default|default:
return|return
name|signal
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|linux_fetch_syscall_args
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|syscall_args
modifier|*
name|sa
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|frame
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|0
index|]
operator|=
name|frame
operator|->
name|tf_rdi
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|1
index|]
operator|=
name|frame
operator|->
name|tf_rsi
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|2
index|]
operator|=
name|frame
operator|->
name|tf_rdx
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|3
index|]
operator|=
name|frame
operator|->
name|tf_rcx
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|4
index|]
operator|=
name|frame
operator|->
name|tf_r8
expr_stmt|;
name|sa
operator|->
name|args
index|[
literal|5
index|]
operator|=
name|frame
operator|->
name|tf_r9
expr_stmt|;
name|sa
operator|->
name|code
operator|=
name|frame
operator|->
name|tf_rax
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|code
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
comment|/* nosys */
name|sa
operator|->
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|sa
operator|->
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|sa
operator|->
name|code
index|]
expr_stmt|;
name|sa
operator|->
name|narg
operator|=
name|sa
operator|->
name|callp
operator|->
name|sy_narg
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|linux_set_syscall_retval
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|trapframe
modifier|*
name|frame
init|=
name|td
operator|->
name|td_frame
decl_stmt|;
comment|/* 	 * On Linux only %rcx and %r11 values are not preserved across 	 * the syscall. 	 * So, do not clobber %rdx and %r10 	 */
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|frame
operator|->
name|tf_rdx
expr_stmt|;
name|frame
operator|->
name|tf_r10
operator|=
name|frame
operator|->
name|tf_rcx
expr_stmt|;
name|cpu_set_syscall_retval
argument_list|(
name|td
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Restore all registers. */
name|set_pcb_flags
argument_list|(
name|td
operator|->
name|td_pcb
argument_list|,
name|PCB_FULL_IRET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_linux_fixup
parameter_list|(
name|register_t
modifier|*
modifier|*
name|stack_base
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
name|Elf_Auxargs
modifier|*
name|args
decl_stmt|;
name|Elf_Addr
modifier|*
name|base
decl_stmt|;
name|Elf_Addr
modifier|*
name|pos
decl_stmt|;
name|struct
name|ps_strings
modifier|*
name|arginfo
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|imgp
operator|->
name|proc
expr_stmt|;
name|arginfo
operator|=
operator|(
expr|struct
name|ps_strings
operator|*
operator|)
name|p
operator|->
name|p_sysent
operator|->
name|sv_psstrings
expr_stmt|;
name|KASSERT
argument_list|(
name|curthread
operator|->
name|td_proc
operator|==
name|imgp
operator|->
name|proc
argument_list|,
operator|(
literal|"unsafe elf_linux_fixup(), should be curproc"
operator|)
argument_list|)
expr_stmt|;
name|base
operator|=
operator|(
name|Elf64_Addr
operator|*
operator|)
operator|*
name|stack_base
expr_stmt|;
name|args
operator|=
operator|(
name|Elf64_Auxargs
operator|*
operator|)
name|imgp
operator|->
name|auxargs
expr_stmt|;
name|pos
operator|=
name|base
operator|+
operator|(
name|imgp
operator|->
name|args
operator|->
name|argc
operator|+
name|imgp
operator|->
name|args
operator|->
name|envc
operator|+
literal|2
operator|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|LINUX_AT_SYSINFO_EHDR
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_sysent
operator|->
name|sv_shared_page_base
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|LINUX_AT_HWCAP
argument_list|,
name|cpu_feature
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|LINUX_AT_CLKTCK
argument_list|,
name|stclohz
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PHDR
argument_list|,
name|args
operator|->
name|phdr
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PHENT
argument_list|,
name|args
operator|->
name|phent
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PHNUM
argument_list|,
name|args
operator|->
name|phnum
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PAGESZ
argument_list|,
name|args
operator|->
name|pagesz
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_BASE
argument_list|,
name|args
operator|->
name|base
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_FLAGS
argument_list|,
name|args
operator|->
name|flags
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_ENTRY
argument_list|,
name|args
operator|->
name|entry
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_UID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_ucred
operator|->
name|cr_ruid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_EUID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_ucred
operator|->
name|cr_svuid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_GID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_ucred
operator|->
name|cr_rgid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_EGID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_ucred
operator|->
name|cr_svgid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|LINUX_AT_SECURE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|LINUX_AT_PLATFORM
argument_list|,
name|PTROUT
argument_list|(
name|linux_platform
argument_list|)
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|LINUX_AT_RANDOM
argument_list|,
name|imgp
operator|->
name|canary
argument_list|)
expr_stmt|;
if|if
condition|(
name|imgp
operator|->
name|execpathp
operator|!=
literal|0
condition|)
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|LINUX_AT_EXECFN
argument_list|,
name|imgp
operator|->
name|execpathp
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|execfd
operator|!=
operator|-
literal|1
condition|)
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_EXECFD
argument_list|,
name|args
operator|->
name|execfd
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imgp
operator|->
name|auxargs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|auxargs
operator|=
name|NULL
expr_stmt|;
name|base
operator|--
expr_stmt|;
name|suword
argument_list|(
name|base
argument_list|,
operator|(
name|uint64_t
operator|)
name|imgp
operator|->
name|args
operator|->
name|argc
argument_list|)
expr_stmt|;
operator|*
name|stack_base
operator|=
operator|(
name|register_t
operator|*
operator|)
name|base
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy strings out to the new process address space, constructing new arg  * and env vector tables. Return a pointer to the base so that it can be used  * as the initial stack pointer.  */
end_comment

begin_function
specifier|static
name|register_t
modifier|*
name|linux_copyout_strings
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
name|int
name|argc
decl_stmt|,
name|envc
decl_stmt|;
name|char
modifier|*
modifier|*
name|vectp
decl_stmt|;
name|char
modifier|*
name|stringp
decl_stmt|,
modifier|*
name|destp
decl_stmt|;
name|register_t
modifier|*
name|stack_base
decl_stmt|;
name|struct
name|ps_strings
modifier|*
name|arginfo
decl_stmt|;
name|char
name|canary
index|[
name|LINUX_AT_RANDOM_LEN
index|]
decl_stmt|;
name|size_t
name|execpath_len
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Calculate string base and vector table pointers. 	 */
if|if
condition|(
name|imgp
operator|->
name|execpath
operator|!=
name|NULL
operator|&&
name|imgp
operator|->
name|auxargs
operator|!=
name|NULL
condition|)
name|execpath_len
operator|=
name|strlen
argument_list|(
name|imgp
operator|->
name|execpath
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|execpath_len
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|imgp
operator|->
name|proc
expr_stmt|;
name|arginfo
operator|=
operator|(
expr|struct
name|ps_strings
operator|*
operator|)
name|p
operator|->
name|p_sysent
operator|->
name|sv_psstrings
expr_stmt|;
name|destp
operator|=
operator|(
name|caddr_t
operator|)
name|arginfo
operator|-
name|SPARE_USRSPACE
operator|-
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|canary
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|-
name|roundup
argument_list|(
name|execpath_len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|-
name|roundup
argument_list|(
operator|(
name|ARG_MAX
operator|-
name|imgp
operator|->
name|args
operator|->
name|stringspace
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|execpath_len
operator|!=
literal|0
condition|)
block|{
name|imgp
operator|->
name|execpathp
operator|=
operator|(
name|uintptr_t
operator|)
name|arginfo
operator|-
name|execpath_len
expr_stmt|;
name|copyout
argument_list|(
name|imgp
operator|->
name|execpath
argument_list|,
operator|(
name|void
operator|*
operator|)
name|imgp
operator|->
name|execpathp
argument_list|,
name|execpath_len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Prepare the canary for SSP. 	 */
name|arc4rand
argument_list|(
name|canary
argument_list|,
sizeof|sizeof
argument_list|(
name|canary
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|canary
operator|=
operator|(
name|uintptr_t
operator|)
name|arginfo
operator|-
name|roundup
argument_list|(
name|execpath_len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|-
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|canary
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|canary
argument_list|,
operator|(
name|void
operator|*
operator|)
name|imgp
operator|->
name|canary
argument_list|,
sizeof|sizeof
argument_list|(
name|canary
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we have a valid auxargs ptr, prepare some room 	 * on the stack. 	 */
if|if
condition|(
name|imgp
operator|->
name|auxargs
condition|)
block|{
comment|/* 		 * 'AT_COUNT*2' is size for the ELF Auxargs data. This is for 		 * lower compatibility. 		 */
name|imgp
operator|->
name|auxarg_size
operator|=
operator|(
name|imgp
operator|->
name|auxarg_size
operator|)
condition|?
name|imgp
operator|->
name|auxarg_size
else|:
operator|(
name|LINUX_AT_COUNT
operator|*
literal|2
operator|)
expr_stmt|;
comment|/* 		 * The '+ 2' is for the null pointers at the end of each of 		 * the arg and env vector sets,and imgp->auxarg_size is room 		 * for argument of Runtime loader. 		 */
name|vectp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|destp
operator|-
operator|(
name|imgp
operator|->
name|args
operator|->
name|argc
operator|+
name|imgp
operator|->
name|args
operator|->
name|envc
operator|+
literal|2
operator|+
name|imgp
operator|->
name|auxarg_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The '+ 2' is for the null pointers at the end of each of 		 * the arg and env vector sets 		 */
name|vectp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|destp
operator|-
operator|(
name|imgp
operator|->
name|args
operator|->
name|argc
operator|+
name|imgp
operator|->
name|args
operator|->
name|envc
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* 	 * vectp also becomes our initial stack base 	 */
name|stack_base
operator|=
operator|(
name|register_t
operator|*
operator|)
name|vectp
expr_stmt|;
name|stringp
operator|=
name|imgp
operator|->
name|args
operator|->
name|begin_argv
expr_stmt|;
name|argc
operator|=
name|imgp
operator|->
name|args
operator|->
name|argc
expr_stmt|;
name|envc
operator|=
name|imgp
operator|->
name|args
operator|->
name|envc
expr_stmt|;
comment|/* 	 * Copy out strings - arguments and environment. 	 */
name|copyout
argument_list|(
name|stringp
argument_list|,
name|destp
argument_list|,
name|ARG_MAX
operator|-
name|imgp
operator|->
name|args
operator|->
name|stringspace
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in "ps_strings" struct for ps, w, etc. 	 */
name|suword
argument_list|(
operator|&
name|arginfo
operator|->
name|ps_argvstr
argument_list|,
operator|(
name|long
operator|)
operator|(
name|intptr_t
operator|)
name|vectp
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|arginfo
operator|->
name|ps_nargvstr
argument_list|,
name|argc
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in argument portion of vector table. 	 */
for|for
control|(
init|;
name|argc
operator|>
literal|0
condition|;
operator|--
name|argc
control|)
block|{
name|suword
argument_list|(
name|vectp
operator|++
argument_list|,
operator|(
name|long
operator|)
operator|(
name|intptr_t
operator|)
name|destp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|stringp
operator|++
operator|!=
literal|0
condition|)
name|destp
operator|++
expr_stmt|;
name|destp
operator|++
expr_stmt|;
block|}
comment|/* a null vector table pointer separates the argp's from the envp's */
name|suword
argument_list|(
name|vectp
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|arginfo
operator|->
name|ps_envstr
argument_list|,
operator|(
name|long
operator|)
operator|(
name|intptr_t
operator|)
name|vectp
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|arginfo
operator|->
name|ps_nenvstr
argument_list|,
name|envc
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in environment portion of vector table. 	 */
for|for
control|(
init|;
name|envc
operator|>
literal|0
condition|;
operator|--
name|envc
control|)
block|{
name|suword
argument_list|(
name|vectp
operator|++
argument_list|,
operator|(
name|long
operator|)
operator|(
name|intptr_t
operator|)
name|destp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|stringp
operator|++
operator|!=
literal|0
condition|)
name|destp
operator|++
expr_stmt|;
name|destp
operator|++
expr_stmt|;
block|}
comment|/* end of vector table is a null pointer */
name|suword
argument_list|(
name|vectp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|stack_base
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset registers to default values on exec.  */
end_comment

begin_function
specifier|static
name|void
name|linux_exec_setregs
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|,
name|u_long
name|stack
parameter_list|)
block|{
name|struct
name|trapframe
modifier|*
name|regs
init|=
name|td
operator|->
name|td_frame
decl_stmt|;
name|struct
name|pcb
modifier|*
name|pcb
init|=
name|td
operator|->
name|td_pcb
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dt_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_proc
operator|->
name|p_md
operator|.
name|md_ldt
operator|!=
name|NULL
condition|)
name|user_ldt_free
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|else
name|mtx_unlock
argument_list|(
operator|&
name|dt_lock
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|pcb_fsbase
operator|=
literal|0
expr_stmt|;
name|pcb
operator|->
name|pcb_gsbase
operator|=
literal|0
expr_stmt|;
name|clear_pcb_flags
argument_list|(
name|pcb
argument_list|,
name|PCB_32BIT
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|pcb_initial_fpucw
operator|=
name|__LINUX_NPXCW__
expr_stmt|;
name|set_pcb_flags
argument_list|(
name|pcb
argument_list|,
name|PCB_FULL_IRET
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|trapframe
argument_list|)
argument_list|)
expr_stmt|;
name|regs
operator|->
name|tf_rip
operator|=
name|imgp
operator|->
name|entry_addr
expr_stmt|;
name|regs
operator|->
name|tf_rsp
operator|=
name|stack
expr_stmt|;
name|regs
operator|->
name|tf_rflags
operator|=
name|PSL_USER
operator||
operator|(
name|regs
operator|->
name|tf_rflags
operator|&
name|PSL_T
operator|)
expr_stmt|;
name|regs
operator|->
name|tf_ss
operator|=
name|_udatasel
expr_stmt|;
name|regs
operator|->
name|tf_cs
operator|=
name|_ucodesel
expr_stmt|;
name|regs
operator|->
name|tf_ds
operator|=
name|_udatasel
expr_stmt|;
name|regs
operator|->
name|tf_es
operator|=
name|_udatasel
expr_stmt|;
name|regs
operator|->
name|tf_fs
operator|=
name|_ufssel
expr_stmt|;
name|regs
operator|->
name|tf_gs
operator|=
name|_ugssel
expr_stmt|;
name|regs
operator|->
name|tf_flags
operator|=
name|TF_HASSEGS
expr_stmt|;
comment|/* 	 * Reset the hardware debug registers if they were in use. 	 * They won't have any meaning for the newly exec'd process. 	 */
if|if
condition|(
name|pcb
operator|->
name|pcb_flags
operator|&
name|PCB_DBREGS
condition|)
block|{
name|pcb
operator|->
name|pcb_dr0
operator|=
literal|0
expr_stmt|;
name|pcb
operator|->
name|pcb_dr1
operator|=
literal|0
expr_stmt|;
name|pcb
operator|->
name|pcb_dr2
operator|=
literal|0
expr_stmt|;
name|pcb
operator|->
name|pcb_dr3
operator|=
literal|0
expr_stmt|;
name|pcb
operator|->
name|pcb_dr6
operator|=
literal|0
expr_stmt|;
name|pcb
operator|->
name|pcb_dr7
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pcb
operator|==
name|curpcb
condition|)
block|{
comment|/* 			 * Clear the debug registers on the running 			 * CPU, otherwise they will end up affecting 			 * the next process we switch to. 			 */
name|reset_dbregs
argument_list|()
expr_stmt|;
block|}
name|clear_pcb_flags
argument_list|(
name|pcb
argument_list|,
name|PCB_DBREGS
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Drop the FP state if we hold it, so that the process gets a 	 * clean FP state if it uses the FPU again. 	 */
name|fpstate_drop
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copied from amd64/amd64/machdep.c  *  * XXX fpu state need? don't think so  */
end_comment

begin_function
name|int
name|linux_rt_sigreturn
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_rt_sigreturn_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|l_ucontext
name|uc
decl_stmt|;
name|struct
name|l_sigcontext
modifier|*
name|context
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|regs
decl_stmt|;
name|unsigned
name|long
name|rflags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ksiginfo_t
name|ksi
decl_stmt|;
name|regs
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|regs
operator|->
name|tf_rbx
argument_list|,
operator|&
name|uc
argument_list|,
sizeof|sizeof
argument_list|(
name|uc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|context
operator|=
operator|&
name|uc
operator|.
name|uc_mcontext
expr_stmt|;
name|rflags
operator|=
name|context
operator|->
name|sc_rflags
expr_stmt|;
comment|/* 	 * Don't allow users to change privileged or reserved flags. 	 */
comment|/* 	 * XXX do allow users to change the privileged flag PSL_RF. 	 * The cpu sets PSL_RF in tf_rflags for faults.  Debuggers 	 * should sometimes set it there too.  tf_rflags is kept in 	 * the signal context during signal handling and there is no 	 * other place to remember it, so the PSL_RF bit may be 	 * corrupted by the signal handler without us knowing. 	 * Corruption of the PSL_RF bit at worst causes one more or 	 * one less debugger trap, so allowing it is fairly harmless. 	 */
define|#
directive|define
name|RFLAG_SECURE
parameter_list|(
name|ef
parameter_list|,
name|oef
parameter_list|)
value|((((ef) ^ (oef))& ~PSL_USERCHANGE) == 0)
if|if
condition|(
operator|!
name|RFLAG_SECURE
argument_list|(
name|rflags
operator|&
operator|~
name|PSL_RF
argument_list|,
name|regs
operator|->
name|tf_rflags
operator|&
operator|~
name|PSL_RF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"linux_rt_sigreturn: rflags = 0x%lx\n"
argument_list|,
name|rflags
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Don't allow users to load a valid privileged %cs.  Let the 	 * hardware check for invalid selectors, excess privilege in 	 * other selectors, invalid %eip's and invalid %esp's. 	 */
define|#
directive|define
name|CS_SECURE
parameter_list|(
name|cs
parameter_list|)
value|(ISPL(cs) == SEL_UPL)
if|if
condition|(
operator|!
name|CS_SECURE
argument_list|(
name|context
operator|->
name|sc_cs
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"linux_rt_sigreturn: cs = 0x%x\n"
argument_list|,
name|context
operator|->
name|sc_cs
argument_list|)
expr_stmt|;
name|ksiginfo_init_trap
argument_list|(
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|ksi_signo
operator|=
name|SIGBUS
expr_stmt|;
name|ksi
operator|.
name|ksi_code
operator|=
name|BUS_OBJERR
expr_stmt|;
name|ksi
operator|.
name|ksi_trapno
operator|=
name|T_PROTFLT
expr_stmt|;
name|ksi
operator|.
name|ksi_addr
operator|=
operator|(
name|void
operator|*
operator|)
name|regs
operator|->
name|tf_rip
expr_stmt|;
name|trapsignal
argument_list|(
name|td
argument_list|,
operator|&
name|ksi
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|linux_to_bsd_sigset
argument_list|(
operator|&
name|uc
operator|.
name|uc_sigmask
argument_list|,
operator|&
name|td
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|SIG_CANTMASK
argument_list|(
name|td
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|signotify
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|regs
operator|->
name|tf_rdi
operator|=
name|context
operator|->
name|sc_rdi
expr_stmt|;
name|regs
operator|->
name|tf_rsi
operator|=
name|context
operator|->
name|sc_rsi
expr_stmt|;
name|regs
operator|->
name|tf_rdx
operator|=
name|context
operator|->
name|sc_rdx
expr_stmt|;
name|regs
operator|->
name|tf_rbp
operator|=
name|context
operator|->
name|sc_rbp
expr_stmt|;
name|regs
operator|->
name|tf_rbx
operator|=
name|context
operator|->
name|sc_rbx
expr_stmt|;
name|regs
operator|->
name|tf_rcx
operator|=
name|context
operator|->
name|sc_rcx
expr_stmt|;
name|regs
operator|->
name|tf_rax
operator|=
name|context
operator|->
name|sc_rax
expr_stmt|;
name|regs
operator|->
name|tf_rip
operator|=
name|context
operator|->
name|sc_rip
expr_stmt|;
name|regs
operator|->
name|tf_rsp
operator|=
name|context
operator|->
name|sc_rsp
expr_stmt|;
name|regs
operator|->
name|tf_r8
operator|=
name|context
operator|->
name|sc_r8
expr_stmt|;
name|regs
operator|->
name|tf_r9
operator|=
name|context
operator|->
name|sc_r9
expr_stmt|;
name|regs
operator|->
name|tf_r10
operator|=
name|context
operator|->
name|sc_r10
expr_stmt|;
name|regs
operator|->
name|tf_r11
operator|=
name|context
operator|->
name|sc_r11
expr_stmt|;
name|regs
operator|->
name|tf_r12
operator|=
name|context
operator|->
name|sc_r12
expr_stmt|;
name|regs
operator|->
name|tf_r13
operator|=
name|context
operator|->
name|sc_r13
expr_stmt|;
name|regs
operator|->
name|tf_r14
operator|=
name|context
operator|->
name|sc_r14
expr_stmt|;
name|regs
operator|->
name|tf_r15
operator|=
name|context
operator|->
name|sc_r15
expr_stmt|;
name|regs
operator|->
name|tf_cs
operator|=
name|context
operator|->
name|sc_cs
expr_stmt|;
name|regs
operator|->
name|tf_err
operator|=
name|context
operator|->
name|sc_err
expr_stmt|;
name|regs
operator|->
name|tf_rflags
operator|=
name|rflags
expr_stmt|;
name|set_pcb_flags
argument_list|(
name|td
operator|->
name|td_pcb
argument_list|,
name|PCB_FULL_IRET
argument_list|)
expr_stmt|;
return|return
operator|(
name|EJUSTRETURN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * copied from amd64/amd64/machdep.c  *  * Send an interrupt to process.  */
end_comment

begin_function
specifier|static
name|void
name|linux_rt_sendsig
parameter_list|(
name|sig_t
name|catcher
parameter_list|,
name|ksiginfo_t
modifier|*
name|ksi
parameter_list|,
name|sigset_t
modifier|*
name|mask
parameter_list|)
block|{
name|struct
name|l_rt_sigframe
name|sf
decl_stmt|,
modifier|*
name|sfp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|sigacts
modifier|*
name|psp
decl_stmt|;
name|caddr_t
name|sp
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|regs
decl_stmt|;
name|int
name|sig
decl_stmt|,
name|code
decl_stmt|;
name|int
name|oonstack
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sig
operator|=
name|ksi
operator|->
name|ksi_signo
expr_stmt|;
name|psp
operator|=
name|p
operator|->
name|p_sigacts
expr_stmt|;
name|code
operator|=
name|ksi
operator|->
name|ksi_code
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|psp
operator|->
name|ps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|regs
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
name|oonstack
operator|=
name|sigonstack
argument_list|(
name|regs
operator|->
name|tf_rsp
argument_list|)
expr_stmt|;
name|LINUX_CTR4
argument_list|(
name|rt_sendsig
argument_list|,
literal|"%p, %d, %p, %u"
argument_list|,
name|catcher
argument_list|,
name|sig
argument_list|,
name|mask
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/* Allocate space for the signal handler context. */
if|if
condition|(
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_ALTSTACK
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|oonstack
operator|&&
name|SIGISMEMBER
argument_list|(
name|psp
operator|->
name|ps_sigonstack
argument_list|,
name|sig
argument_list|)
condition|)
block|{
name|sp
operator|=
name|td
operator|->
name|td_sigstk
operator|.
name|ss_sp
operator|+
name|td
operator|->
name|td_sigstk
operator|.
name|ss_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|l_rt_sigframe
argument_list|)
expr_stmt|;
block|}
else|else
name|sp
operator|=
operator|(
name|caddr_t
operator|)
name|regs
operator|->
name|tf_rsp
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|l_rt_sigframe
argument_list|)
operator|-
literal|128
expr_stmt|;
comment|/* Align to 16 bytes. */
name|sfp
operator|=
operator|(
expr|struct
name|l_rt_sigframe
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|sp
operator|&
operator|~
literal|0xFul
operator|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|psp
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
comment|/* Translate the signal. */
name|sig
operator|=
name|bsd_to_linux_signal
argument_list|(
name|sig
argument_list|)
expr_stmt|;
comment|/* Save user context. */
name|bzero
argument_list|(
operator|&
name|sf
argument_list|,
sizeof|sizeof
argument_list|(
name|sf
argument_list|)
argument_list|)
expr_stmt|;
name|bsd_to_linux_sigset
argument_list|(
name|mask
argument_list|,
operator|&
name|sf
operator|.
name|sf_sc
operator|.
name|uc_sigmask
argument_list|)
expr_stmt|;
name|bsd_to_linux_sigset
argument_list|(
name|mask
argument_list|,
operator|&
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_mask
argument_list|)
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_stack
operator|.
name|ss_sp
operator|=
name|PTROUT
argument_list|(
name|td
operator|->
name|td_sigstk
operator|.
name|ss_sp
argument_list|)
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_stack
operator|.
name|ss_size
operator|=
name|td
operator|->
name|td_sigstk
operator|.
name|ss_size
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_stack
operator|.
name|ss_flags
operator|=
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_ALTSTACK
operator|)
condition|?
operator|(
operator|(
name|oonstack
operator|)
condition|?
name|LINUX_SS_ONSTACK
else|:
literal|0
operator|)
else|:
name|LINUX_SS_DISABLE
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_rdi
operator|=
name|regs
operator|->
name|tf_rdi
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_rsi
operator|=
name|regs
operator|->
name|tf_rsi
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_rdx
operator|=
name|regs
operator|->
name|tf_rdx
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_rbp
operator|=
name|regs
operator|->
name|tf_rbp
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_rbx
operator|=
name|regs
operator|->
name|tf_rbx
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_rcx
operator|=
name|regs
operator|->
name|tf_rcx
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_rax
operator|=
name|regs
operator|->
name|tf_rax
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_rip
operator|=
name|regs
operator|->
name|tf_rip
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_rsp
operator|=
name|regs
operator|->
name|tf_rsp
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_r8
operator|=
name|regs
operator|->
name|tf_r8
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_r9
operator|=
name|regs
operator|->
name|tf_r9
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_r10
operator|=
name|regs
operator|->
name|tf_r10
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_r11
operator|=
name|regs
operator|->
name|tf_r11
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_r12
operator|=
name|regs
operator|->
name|tf_r12
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_r13
operator|=
name|regs
operator|->
name|tf_r13
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_r14
operator|=
name|regs
operator|->
name|tf_r14
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_r15
operator|=
name|regs
operator|->
name|tf_r15
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_cs
operator|=
name|regs
operator|->
name|tf_cs
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_rflags
operator|=
name|regs
operator|->
name|tf_rflags
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_err
operator|=
name|regs
operator|->
name|tf_err
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_trapno
operator|=
name|bsd_to_linux_trapcode
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|sf
operator|.
name|sf_sc
operator|.
name|uc_mcontext
operator|.
name|sc_cr2
operator|=
operator|(
name|register_t
operator|)
name|ksi
operator|->
name|ksi_addr
expr_stmt|;
comment|/* Build the argument list for the signal handler. */
name|regs
operator|->
name|tf_rdi
operator|=
name|sig
expr_stmt|;
comment|/* arg 1 in %rdi */
name|regs
operator|->
name|tf_rax
operator|=
literal|0
expr_stmt|;
name|regs
operator|->
name|tf_rsi
operator|=
operator|(
name|register_t
operator|)
operator|&
name|sfp
operator|->
name|sf_si
expr_stmt|;
comment|/* arg 2 in %rsi */
name|regs
operator|->
name|tf_rdx
operator|=
operator|(
name|register_t
operator|)
operator|&
name|sfp
operator|->
name|sf_sc
expr_stmt|;
comment|/* arg 3 in %rdx */
name|sf
operator|.
name|sf_handler
operator|=
name|catcher
expr_stmt|;
comment|/* Fill in POSIX parts */
name|ksiginfo_to_lsiginfo
argument_list|(
name|ksi
argument_list|,
operator|&
name|sf
operator|.
name|sf_si
argument_list|,
name|sig
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the sigframe out to the user's stack. 	 */
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|sf
argument_list|,
name|sfp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sfp
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"process %ld has trashed its stack\n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigexit
argument_list|(
name|td
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
block|}
name|regs
operator|->
name|tf_rsp
operator|=
operator|(
name|long
operator|)
name|sfp
expr_stmt|;
name|regs
operator|->
name|tf_rip
operator|=
name|linux_rt_sigcode
expr_stmt|;
name|regs
operator|->
name|tf_rflags
operator|&=
operator|~
operator|(
name|PSL_T
operator||
name|PSL_D
operator|)
expr_stmt|;
name|regs
operator|->
name|tf_cs
operator|=
name|_ucodesel
expr_stmt|;
name|set_pcb_flags
argument_list|(
name|td
operator|->
name|td_pcb
argument_list|,
name|PCB_FULL_IRET
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|psp
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If a linux binary is exec'ing something, try this image activator  * first.  We override standard shell script execution in order to  * be able to modify the interpreter path.  We only do this if a linux  * binary is doing the exec, so we do not create an EXEC module for it.  */
end_comment

begin_function_decl
specifier|static
name|int
name|exec_linux_imgact_try
parameter_list|(
name|struct
name|image_params
modifier|*
name|iparams
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|exec_linux_imgact_try
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|head
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|imgp
operator|->
name|image_header
decl_stmt|;
name|char
modifier|*
name|rpath
decl_stmt|;
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|,
name|len
decl_stmt|;
comment|/* 	 * The interpreter for shell scripts run from a linux binary needs 	 * to be located in /compat/linux if possible in order to recursively 	 * maintain linux path emulation. 	 */
if|if
condition|(
operator|(
operator|(
specifier|const
name|short
operator|*
operator|)
name|head
operator|)
index|[
literal|0
index|]
operator|==
name|SHELLMAGIC
condition|)
block|{
comment|/* 		 * Run our normal shell image activator.  If it succeeds 		 * attempt to use the alternate path for the interpreter. 		 * If an alternate path is found, use our stringspace 		 * to store it. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|exec_shell_imgact
argument_list|(
name|imgp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|linux_emul_convpath
argument_list|(
name|FIRST_THREAD_IN_PROC
argument_list|(
name|imgp
operator|->
name|proc
argument_list|)
argument_list|,
name|imgp
operator|->
name|interpreter_name
argument_list|,
name|UIO_SYSSPACE
argument_list|,
operator|&
name|rpath
argument_list|,
literal|0
argument_list|,
name|AT_FDCWD
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpath
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|rpath
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|MAXSHELLCMDLEN
condition|)
name|memcpy
argument_list|(
name|imgp
operator|->
name|interpreter_name
argument_list|,
name|rpath
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rpath
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|LINUX_VSYSCALL_START
value|(-10UL<< 20)
end_define

begin_define
define|#
directive|define
name|LINUX_VSYSCALL_SZ
value|1024
end_define

begin_decl_stmt
specifier|const
name|unsigned
name|long
name|linux_vsyscall_vector
index|[]
init|=
block|{
name|LINUX_SYS_gettimeofday
block|,
name|LINUX_SYS_linux_time
block|,
comment|/* getcpu not implemented */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|linux_vsyscall
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|uint64_t
name|retqaddr
decl_stmt|;
name|int
name|code
decl_stmt|,
name|traced
decl_stmt|;
name|int
name|error
decl_stmt|;
name|frame
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
comment|/* Check %rip for vsyscall area */
if|if
condition|(
name|__predict_true
argument_list|(
name|frame
operator|->
name|tf_rip
operator|<
name|LINUX_VSYSCALL_START
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|frame
operator|->
name|tf_rip
operator|&
operator|(
name|LINUX_VSYSCALL_SZ
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|code
operator|=
operator|(
name|frame
operator|->
name|tf_rip
operator|-
name|LINUX_VSYSCALL_START
operator|)
operator|/
name|LINUX_VSYSCALL_SZ
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|nitems
argument_list|(
name|linux_vsyscall_vector
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * vsyscall called as callq *(%rax), so we must 	 * use return address from %rsp and also fixup %rsp 	 */
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|frame
operator|->
name|tf_rsp
argument_list|,
operator|&
name|retqaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|retqaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|frame
operator|->
name|tf_rip
operator|=
name|retqaddr
expr_stmt|;
name|frame
operator|->
name|tf_rax
operator|=
name|linux_vsyscall_vector
index|[
name|code
index|]
expr_stmt|;
name|frame
operator|->
name|tf_rsp
operator|+=
literal|8
expr_stmt|;
name|traced
operator|=
operator|(
name|frame
operator|->
name|tf_flags
operator|&
name|PSL_T
operator|)
expr_stmt|;
name|amd64_syscall
argument_list|(
name|td
argument_list|,
name|traced
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|sysentvec
name|elf_linux_sysvec
init|=
block|{
operator|.
name|sv_size
operator|=
name|LINUX_SYS_MAXSYSCALL
block|,
operator|.
name|sv_table
operator|=
name|linux_sysent
block|,
operator|.
name|sv_mask
operator|=
literal|0
block|,
operator|.
name|sv_errsize
operator|=
name|ELAST
operator|+
literal|1
block|,
operator|.
name|sv_errtbl
operator|=
name|bsd_to_linux_errno
block|,
operator|.
name|sv_transtrap
operator|=
name|translate_traps
block|,
operator|.
name|sv_fixup
operator|=
name|elf_linux_fixup
block|,
operator|.
name|sv_sendsig
operator|=
name|linux_rt_sendsig
block|,
operator|.
name|sv_sigcode
operator|=
operator|&
name|_binary_linux_locore_o_start
block|,
operator|.
name|sv_szsigcode
operator|=
operator|&
name|linux_szsigcode
block|,
operator|.
name|sv_name
operator|=
literal|"Linux ELF64"
block|,
operator|.
name|sv_coredump
operator|=
name|elf64_coredump
block|,
operator|.
name|sv_imgact_try
operator|=
name|exec_linux_imgact_try
block|,
operator|.
name|sv_minsigstksz
operator|=
name|LINUX_MINSIGSTKSZ
block|,
operator|.
name|sv_pagesize
operator|=
name|PAGE_SIZE
block|,
operator|.
name|sv_minuser
operator|=
name|VM_MIN_ADDRESS
block|,
operator|.
name|sv_maxuser
operator|=
name|VM_MAXUSER_ADDRESS
block|,
operator|.
name|sv_usrstack
operator|=
name|USRSTACK
block|,
operator|.
name|sv_psstrings
operator|=
name|PS_STRINGS
block|,
operator|.
name|sv_stackprot
operator|=
name|VM_PROT_ALL
block|,
operator|.
name|sv_copyout_strings
operator|=
name|linux_copyout_strings
block|,
operator|.
name|sv_setregs
operator|=
name|linux_exec_setregs
block|,
operator|.
name|sv_fixlimit
operator|=
name|NULL
block|,
operator|.
name|sv_maxssiz
operator|=
name|NULL
block|,
operator|.
name|sv_flags
operator|=
name|SV_ABI_LINUX
operator||
name|SV_LP64
operator||
name|SV_SHP
block|,
operator|.
name|sv_set_syscall_retval
operator|=
name|linux_set_syscall_retval
block|,
operator|.
name|sv_fetch_syscall_args
operator|=
name|linux_fetch_syscall_args
block|,
operator|.
name|sv_syscallnames
operator|=
name|NULL
block|,
operator|.
name|sv_shared_page_base
operator|=
name|SHAREDPAGE
block|,
operator|.
name|sv_shared_page_len
operator|=
name|PAGE_SIZE
block|,
operator|.
name|sv_schedtail
operator|=
name|linux_schedtail
block|,
operator|.
name|sv_thread_detach
operator|=
name|linux_thread_detach
block|,
operator|.
name|sv_trap
operator|=
name|linux_vsyscall
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|linux_vdso_install
parameter_list|(
name|void
modifier|*
name|param
parameter_list|)
block|{
name|linux_szsigcode
operator|=
operator|(
operator|&
name|_binary_linux_locore_o_end
operator|-
operator|&
name|_binary_linux_locore_o_start
operator|)
expr_stmt|;
if|if
condition|(
name|linux_szsigcode
operator|>
name|elf_linux_sysvec
operator|.
name|sv_shared_page_len
condition|)
name|panic
argument_list|(
literal|"Linux invalid vdso size\n"
argument_list|)
expr_stmt|;
name|__elfN
argument_list|(
name|linux_vdso_fixup
argument_list|)
argument_list|(
operator|&
name|elf_linux_sysvec
argument_list|)
expr_stmt|;
name|linux_shared_page_obj
operator|=
name|__elfN
argument_list|(
name|linux_shared_page_init
argument_list|)
argument_list|(
operator|&
name|linux_shared_page_mapping
argument_list|)
expr_stmt|;
name|__elfN
argument_list|(
name|linux_vdso_reloc
argument_list|)
argument_list|(
operator|&
name|elf_linux_sysvec
argument_list|,
name|SHAREDPAGE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|elf_linux_sysvec
operator|.
name|sv_sigcode
argument_list|,
name|linux_shared_page_mapping
argument_list|,
name|linux_szsigcode
argument_list|)
expr_stmt|;
name|elf_linux_sysvec
operator|.
name|sv_shared_page_obj
operator|=
name|linux_shared_page_obj
expr_stmt|;
name|linux_kplatform
operator|=
name|linux_shared_page_mapping
operator|+
operator|(
name|linux_platform
operator|-
operator|(
name|caddr_t
operator|)
name|SHAREDPAGE
operator|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|elf_linux_vdso_init
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_ANY
argument_list|,
operator|(
name|sysinit_cfunc_t
operator|)
name|linux_vdso_install
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|linux_vdso_deinstall
parameter_list|(
name|void
modifier|*
name|param
parameter_list|)
block|{
name|__elfN
function_decl|(
name|linux_shared_page_fini
function_decl|)
parameter_list|(
name|linux_shared_page_obj
parameter_list|)
function_decl|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|elf_linux_vdso_uninit
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
operator|(
name|sysinit_cfunc_t
operator|)
name|linux_vdso_deinstall
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
name|GNULINUX_ABI_VENDOR
index|[]
init|=
literal|"GNU"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|GNULINUX_ABI_DESC
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean_t
name|linux_trans_osrel
parameter_list|(
specifier|const
name|Elf_Note
modifier|*
name|note
parameter_list|,
name|int32_t
modifier|*
name|osrel
parameter_list|)
block|{
specifier|const
name|Elf32_Word
modifier|*
name|desc
decl_stmt|;
name|uintptr_t
name|p
decl_stmt|;
name|p
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
name|note
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|+=
name|roundup2
argument_list|(
name|note
operator|->
name|n_namesz
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_Addr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
specifier|const
name|Elf32_Word
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|desc
index|[
literal|0
index|]
operator|!=
name|GNULINUX_ABI_DESC
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 	 * For linux we encode osrel as follows (see linux_mib.c): 	 * VVVMMMIII (version, major, minor), see linux_mib.c. 	 */
operator|*
name|osrel
operator|=
name|desc
index|[
literal|1
index|]
operator|*
literal|1000000
operator|+
name|desc
index|[
literal|2
index|]
operator|*
literal|1000
operator|+
name|desc
index|[
literal|3
index|]
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|Elf_Brandnote
name|linux64_brandnote
init|=
block|{
operator|.
name|hdr
operator|.
name|n_namesz
operator|=
sizeof|sizeof
argument_list|(
name|GNULINUX_ABI_VENDOR
argument_list|)
block|,
operator|.
name|hdr
operator|.
name|n_descsz
operator|=
literal|16
block|,
operator|.
name|hdr
operator|.
name|n_type
operator|=
literal|1
block|,
operator|.
name|vendor
operator|=
name|GNULINUX_ABI_VENDOR
block|,
operator|.
name|flags
operator|=
name|BN_TRANSLATE_OSREL
block|,
operator|.
name|trans_osrel
operator|=
name|linux_trans_osrel
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf64_Brandinfo
name|linux_glibc2brand
init|=
block|{
operator|.
name|brand
operator|=
name|ELFOSABI_LINUX
block|,
operator|.
name|machine
operator|=
name|EM_X86_64
block|,
operator|.
name|compat_3_brand
operator|=
literal|"Linux"
block|,
operator|.
name|emul_path
operator|=
literal|"/compat/linux"
block|,
operator|.
name|interp_path
operator|=
literal|"/lib64/ld-linux-x86-64.so.2"
block|,
operator|.
name|sysvec
operator|=
operator|&
name|elf_linux_sysvec
block|,
operator|.
name|interp_newpath
operator|=
name|NULL
block|,
operator|.
name|brand_note
operator|=
operator|&
name|linux64_brandnote
block|,
operator|.
name|flags
operator|=
name|BI_CAN_EXEC_DYN
operator||
name|BI_BRAND_NOTE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf64_Brandinfo
name|linux_glibc2brandshort
init|=
block|{
operator|.
name|brand
operator|=
name|ELFOSABI_LINUX
block|,
operator|.
name|machine
operator|=
name|EM_X86_64
block|,
operator|.
name|compat_3_brand
operator|=
literal|"Linux"
block|,
operator|.
name|emul_path
operator|=
literal|"/compat/linux"
block|,
operator|.
name|interp_path
operator|=
literal|"/lib64/ld-linux.so.2"
block|,
operator|.
name|sysvec
operator|=
operator|&
name|elf_linux_sysvec
block|,
operator|.
name|interp_newpath
operator|=
name|NULL
block|,
operator|.
name|brand_note
operator|=
operator|&
name|linux64_brandnote
block|,
operator|.
name|flags
operator|=
name|BI_CAN_EXEC_DYN
operator||
name|BI_BRAND_NOTE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf64_Brandinfo
modifier|*
name|linux_brandlist
index|[]
init|=
block|{
operator|&
name|linux_glibc2brand
block|,
operator|&
name|linux_glibc2brandshort
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|linux64_elf_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Elf64_Brandinfo
modifier|*
modifier|*
name|brandinfo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|linux_ioctl_handler
modifier|*
modifier|*
name|lihp
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
for|for
control|(
name|brandinfo
operator|=
operator|&
name|linux_brandlist
index|[
literal|0
index|]
init|;
operator|*
name|brandinfo
operator|!=
name|NULL
condition|;
operator|++
name|brandinfo
control|)
if|if
condition|(
name|elf64_insert_brand_entry
argument_list|(
operator|*
name|brandinfo
argument_list|)
operator|<
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|SET_FOREACH
argument_list|(
argument|lihp
argument_list|,
argument|linux_ioctl_handler_set
argument_list|)
name|linux_ioctl_register_handler
argument_list|(
operator|*
name|lihp
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|futex_list
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|futex_mtx
argument_list|,
literal|"ftllk64"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|stclohz
operator|=
operator|(
name|stathz
condition|?
name|stathz
else|:
name|hz
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Linux x86-64 ELF exec handler installed\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"cannot insert Linux x86-64 ELF brand handler\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
for|for
control|(
name|brandinfo
operator|=
operator|&
name|linux_brandlist
index|[
literal|0
index|]
init|;
operator|*
name|brandinfo
operator|!=
name|NULL
condition|;
operator|++
name|brandinfo
control|)
if|if
condition|(
name|elf64_brand_inuse
argument_list|(
operator|*
name|brandinfo
argument_list|)
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|brandinfo
operator|=
operator|&
name|linux_brandlist
index|[
literal|0
index|]
init|;
operator|*
name|brandinfo
operator|!=
name|NULL
condition|;
operator|++
name|brandinfo
control|)
if|if
condition|(
name|elf64_remove_brand_entry
argument_list|(
operator|*
name|brandinfo
argument_list|)
operator|<
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|SET_FOREACH
argument_list|(
argument|lihp
argument_list|,
argument|linux_ioctl_handler_set
argument_list|)
name|linux_ioctl_unregister_handler
argument_list|(
operator|*
name|lihp
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|futex_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Linux ELF exec handler removed\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Could not deinstall ELF interpreter entry\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|linux64_elf_mod
init|=
block|{
literal|"linux64elf"
block|,
name|linux64_elf_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE_TIED
argument_list|(
name|linux64elf
argument_list|,
name|linux64_elf_mod
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|linux64elf
argument_list|,
name|linux_common
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

