begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2017 Edward Tomasz Napierala<trasz@FreeBSD.org>  * All rights reserved.  *  * This software was developed by SRI International and the University of  * Cambridge Computer Laboratory under DARPA/AFRL contract (FA8750-10-C-0237)  * ("CTSRD"), as part of the DARPA CRASH research programme.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<amd64/linux/linux.h>
end_include

begin_include
include|#
directive|include
file|<amd64/linux/linux_proto.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_signal.h>
end_include

begin_define
define|#
directive|define
name|LINUX_PTRACE_TRACEME
value|0
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_PEEKTEXT
value|1
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_PEEKDATA
value|2
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_PEEKUSER
value|3
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_POKETEXT
value|4
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_POKEDATA
value|5
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_POKEUSER
value|6
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_CONT
value|7
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_KILL
value|8
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_SINGLESTEP
value|9
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_GETREGS
value|12
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_SETREGS
value|13
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_GETFPREGS
value|14
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_SETFPREGS
value|15
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_ATTACH
value|16
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_DETACH
value|17
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_SYSCALL
value|24
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_SETOPTIONS
value|0x4200
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_GETREGSET
value|0x4204
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_SEIZE
value|0x4206
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_O_TRACESYSGOOD
value|1
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_O_TRACEFORK
value|2
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_O_TRACEVFORK
value|4
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_O_TRACECLONE
value|8
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_O_TRACEEXEC
value|16
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_O_TRACEVFORKDONE
value|32
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_O_TRACEEXIT
value|64
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_O_TRACESECCOMP
value|128
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_O_EXITKILL
value|1048576
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_O_SUSPEND_SECCOMP
value|2097152
end_define

begin_define
define|#
directive|define
name|LINUX_NT_PRSTATUS
value|1
end_define

begin_define
define|#
directive|define
name|LINUX_PTRACE_O_MASK
value|(LINUX_PTRACE_O_TRACESYSGOOD |	\     LINUX_PTRACE_O_TRACEFORK | LINUX_PTRACE_O_TRACEVFORK |	\     LINUX_PTRACE_O_TRACECLONE | LINUX_PTRACE_O_TRACEEXEC |	\     LINUX_PTRACE_O_TRACEVFORKDONE | LINUX_PTRACE_O_TRACEEXIT |	\     LINUX_PTRACE_O_TRACESECCOMP | LINUX_PTRACE_O_EXITKILL |	\     LINUX_PTRACE_O_SUSPEND_SECCOMP)
end_define

begin_function
specifier|static
name|int
name|map_signum
parameter_list|(
name|int
name|lsig
parameter_list|,
name|int
modifier|*
name|bsigp
parameter_list|)
block|{
name|int
name|bsig
decl_stmt|;
if|if
condition|(
name|lsig
operator|==
literal|0
condition|)
block|{
operator|*
name|bsigp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|lsig
operator|<
literal|0
operator|||
name|lsig
operator|>
name|LINUX_SIGRTMAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bsig
operator|=
name|linux_to_bsd_signal
argument_list|(
name|lsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsig
operator|==
name|SIGSTOP
condition|)
name|bsig
operator|=
literal|0
expr_stmt|;
operator|*
name|bsigp
operator|=
name|bsig
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|linux_pt_reg
block|{
name|l_ulong
name|r15
decl_stmt|;
name|l_ulong
name|r14
decl_stmt|;
name|l_ulong
name|r13
decl_stmt|;
name|l_ulong
name|r12
decl_stmt|;
name|l_ulong
name|rbp
decl_stmt|;
name|l_ulong
name|rbx
decl_stmt|;
name|l_ulong
name|r11
decl_stmt|;
name|l_ulong
name|r10
decl_stmt|;
name|l_ulong
name|r9
decl_stmt|;
name|l_ulong
name|r8
decl_stmt|;
name|l_ulong
name|rax
decl_stmt|;
name|l_ulong
name|rcx
decl_stmt|;
name|l_ulong
name|rdx
decl_stmt|;
name|l_ulong
name|rsi
decl_stmt|;
name|l_ulong
name|rdi
decl_stmt|;
name|l_ulong
name|orig_rax
decl_stmt|;
name|l_ulong
name|rip
decl_stmt|;
name|l_ulong
name|cs
decl_stmt|;
name|l_ulong
name|eflags
decl_stmt|;
name|l_ulong
name|rsp
decl_stmt|;
name|l_ulong
name|ss
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Translate amd64 ptrace registers between Linux and FreeBSD formats.  * The translation is pretty straighforward, for all registers but  * orig_rax on Linux side and r_trapno and r_err in FreeBSD.  */
end_comment

begin_function
specifier|static
name|void
name|map_regs_to_linux
parameter_list|(
name|struct
name|reg
modifier|*
name|b_reg
parameter_list|,
name|struct
name|linux_pt_reg
modifier|*
name|l_reg
parameter_list|)
block|{
name|l_reg
operator|->
name|r15
operator|=
name|b_reg
operator|->
name|r_r15
expr_stmt|;
name|l_reg
operator|->
name|r14
operator|=
name|b_reg
operator|->
name|r_r14
expr_stmt|;
name|l_reg
operator|->
name|r13
operator|=
name|b_reg
operator|->
name|r_r13
expr_stmt|;
name|l_reg
operator|->
name|r12
operator|=
name|b_reg
operator|->
name|r_r12
expr_stmt|;
name|l_reg
operator|->
name|rbp
operator|=
name|b_reg
operator|->
name|r_rbp
expr_stmt|;
name|l_reg
operator|->
name|rbx
operator|=
name|b_reg
operator|->
name|r_rbx
expr_stmt|;
name|l_reg
operator|->
name|r11
operator|=
name|b_reg
operator|->
name|r_r11
expr_stmt|;
name|l_reg
operator|->
name|r10
operator|=
name|b_reg
operator|->
name|r_r10
expr_stmt|;
name|l_reg
operator|->
name|r9
operator|=
name|b_reg
operator|->
name|r_r9
expr_stmt|;
name|l_reg
operator|->
name|r8
operator|=
name|b_reg
operator|->
name|r_r8
expr_stmt|;
name|l_reg
operator|->
name|rax
operator|=
name|b_reg
operator|->
name|r_rax
expr_stmt|;
name|l_reg
operator|->
name|rcx
operator|=
name|b_reg
operator|->
name|r_rcx
expr_stmt|;
name|l_reg
operator|->
name|rdx
operator|=
name|b_reg
operator|->
name|r_rdx
expr_stmt|;
name|l_reg
operator|->
name|rsi
operator|=
name|b_reg
operator|->
name|r_rsi
expr_stmt|;
name|l_reg
operator|->
name|rdi
operator|=
name|b_reg
operator|->
name|r_rdi
expr_stmt|;
name|l_reg
operator|->
name|orig_rax
operator|=
name|b_reg
operator|->
name|r_rax
expr_stmt|;
name|l_reg
operator|->
name|rip
operator|=
name|b_reg
operator|->
name|r_rip
expr_stmt|;
name|l_reg
operator|->
name|cs
operator|=
name|b_reg
operator|->
name|r_cs
expr_stmt|;
name|l_reg
operator|->
name|eflags
operator|=
name|b_reg
operator|->
name|r_rflags
expr_stmt|;
name|l_reg
operator|->
name|rsp
operator|=
name|b_reg
operator|->
name|r_rsp
expr_stmt|;
name|l_reg
operator|->
name|ss
operator|=
name|b_reg
operator|->
name|r_ss
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|map_regs_from_linux
parameter_list|(
name|struct
name|reg
modifier|*
name|b_reg
parameter_list|,
name|struct
name|linux_pt_reg
modifier|*
name|l_reg
parameter_list|)
block|{
name|b_reg
operator|->
name|r_r15
operator|=
name|l_reg
operator|->
name|r15
expr_stmt|;
name|b_reg
operator|->
name|r_r14
operator|=
name|l_reg
operator|->
name|r14
expr_stmt|;
name|b_reg
operator|->
name|r_r13
operator|=
name|l_reg
operator|->
name|r13
expr_stmt|;
name|b_reg
operator|->
name|r_r12
operator|=
name|l_reg
operator|->
name|r12
expr_stmt|;
name|b_reg
operator|->
name|r_r11
operator|=
name|l_reg
operator|->
name|r11
expr_stmt|;
name|b_reg
operator|->
name|r_r10
operator|=
name|l_reg
operator|->
name|r10
expr_stmt|;
name|b_reg
operator|->
name|r_r9
operator|=
name|l_reg
operator|->
name|r9
expr_stmt|;
name|b_reg
operator|->
name|r_r8
operator|=
name|l_reg
operator|->
name|r8
expr_stmt|;
name|b_reg
operator|->
name|r_rdi
operator|=
name|l_reg
operator|->
name|rdi
expr_stmt|;
name|b_reg
operator|->
name|r_rsi
operator|=
name|l_reg
operator|->
name|rsi
expr_stmt|;
name|b_reg
operator|->
name|r_rbp
operator|=
name|l_reg
operator|->
name|rbp
expr_stmt|;
name|b_reg
operator|->
name|r_rbx
operator|=
name|l_reg
operator|->
name|rbx
expr_stmt|;
name|b_reg
operator|->
name|r_rdx
operator|=
name|l_reg
operator|->
name|rdx
expr_stmt|;
name|b_reg
operator|->
name|r_rcx
operator|=
name|l_reg
operator|->
name|rcx
expr_stmt|;
name|b_reg
operator|->
name|r_rax
operator|=
name|l_reg
operator|->
name|rax
expr_stmt|;
comment|/* 	 * XXX: Are zeroes the right thing to put here? 	 */
name|b_reg
operator|->
name|r_trapno
operator|=
literal|0
expr_stmt|;
name|b_reg
operator|->
name|r_fs
operator|=
literal|0
expr_stmt|;
name|b_reg
operator|->
name|r_gs
operator|=
literal|0
expr_stmt|;
name|b_reg
operator|->
name|r_err
operator|=
literal|0
expr_stmt|;
name|b_reg
operator|->
name|r_es
operator|=
literal|0
expr_stmt|;
name|b_reg
operator|->
name|r_ds
operator|=
literal|0
expr_stmt|;
name|b_reg
operator|->
name|r_rip
operator|=
name|l_reg
operator|->
name|rip
expr_stmt|;
name|b_reg
operator|->
name|r_cs
operator|=
name|l_reg
operator|->
name|cs
expr_stmt|;
name|b_reg
operator|->
name|r_rflags
operator|=
name|l_reg
operator|->
name|eflags
expr_stmt|;
name|b_reg
operator|->
name|r_rsp
operator|=
name|l_reg
operator|->
name|rsp
expr_stmt|;
name|b_reg
operator|->
name|r_ss
operator|=
name|l_reg
operator|->
name|ss
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|linux_ptrace_peek
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|kern_ptrace
argument_list|(
name|td
argument_list|,
name|PT_READ_I
argument_list|,
name|pid
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|td
operator|->
name|td_retval
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|l_int
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|error
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|linux_ptrace_setoptions
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|l_ulong
name|data
parameter_list|)
block|{
name|int
name|mask
decl_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data
operator|&
operator|~
name|LINUX_PTRACE_O_MASK
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unknown ptrace option %lx set; "
literal|"returning EINVAL\n"
argument_list|,
name|__func__
argument_list|,
name|data
operator|&
operator|~
name|LINUX_PTRACE_O_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * PTRACE_O_EXITKILL is ignored, we do that by default. 	 */
if|if
condition|(
name|data
operator|&
name|LINUX_PTRACE_O_TRACESYSGOOD
condition|)
block|{
name|printf
argument_list|(
literal|"%s: PTRACE_O_TRACESYSGOOD not implemented; "
literal|"returning EINVAL\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|data
operator|&
name|LINUX_PTRACE_O_TRACEFORK
condition|)
name|mask
operator||=
name|PTRACE_FORK
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|LINUX_PTRACE_O_TRACEVFORK
condition|)
name|mask
operator||=
name|PTRACE_VFORK
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|LINUX_PTRACE_O_TRACECLONE
condition|)
name|mask
operator||=
name|PTRACE_VFORK
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|LINUX_PTRACE_O_TRACEEXEC
condition|)
name|mask
operator||=
name|PTRACE_EXEC
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|LINUX_PTRACE_O_TRACEVFORKDONE
condition|)
name|mask
operator||=
name|PTRACE_VFORK
expr_stmt|;
comment|/* XXX: Close enough? */
if|if
condition|(
name|data
operator|&
name|LINUX_PTRACE_O_TRACEEXIT
condition|)
block|{
name|printf
argument_list|(
literal|"%s: PTRACE_O_TRACEEXIT not implemented; "
literal|"returning EINVAL\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|kern_ptrace
argument_list|(
name|td
argument_list|,
name|PT_SET_EVENT_MASK
argument_list|,
name|pid
argument_list|,
operator|&
name|mask
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|linux_ptrace_getregs
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ptrace_lwpinfo
name|lwpinfo
decl_stmt|;
name|struct
name|reg
name|b_reg
decl_stmt|;
name|struct
name|linux_pt_reg
name|l_reg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|kern_ptrace
argument_list|(
name|td
argument_list|,
name|PT_GETREGS
argument_list|,
name|pid
argument_list|,
operator|&
name|b_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|map_regs_to_linux
argument_list|(
operator|&
name|b_reg
argument_list|,
operator|&
name|l_reg
argument_list|)
expr_stmt|;
comment|/* 	 * The strace(1) utility depends on RAX being set to -ENOSYS 	 * on syscall entry. 	 */
name|error
operator|=
name|kern_ptrace
argument_list|(
name|td
argument_list|,
name|PT_LWPINFO
argument_list|,
name|pid
argument_list|,
operator|&
name|lwpinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|lwpinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: PT_LWPINFO failed with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|lwpinfo
operator|.
name|pl_flags
operator|&
name|PL_FLAG_SCE
condition|)
name|l_reg
operator|.
name|rax
operator|=
operator|-
literal|38
expr_stmt|;
comment|// XXX: Don't hardcode?
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|l_reg
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|l_reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|linux_ptrace_setregs
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|reg
name|b_reg
decl_stmt|;
name|struct
name|linux_pt_reg
name|l_reg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|data
argument_list|,
operator|&
name|l_reg
argument_list|,
sizeof|sizeof
argument_list|(
name|l_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|map_regs_from_linux
argument_list|(
operator|&
name|b_reg
argument_list|,
operator|&
name|l_reg
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_ptrace
argument_list|(
name|td
argument_list|,
name|PT_SETREGS
argument_list|,
name|pid
argument_list|,
operator|&
name|b_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|linux_ptrace_getregset
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|l_ulong
name|addr
parameter_list|,
name|l_ulong
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|addr
condition|)
block|{
case|case
name|LINUX_NT_PRSTATUS
case|:
name|printf
argument_list|(
literal|"%s: NT_PRSTATUS not implemented; returning EINVAL\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"%s: PTRACE_GETREGSET request %ld not implemented; "
literal|"returning EINVAL\n"
argument_list|,
name|__func__
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|linux_ptrace_seize
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|l_ulong
name|addr
parameter_list|,
name|l_ulong
name|data
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s: PTRACE_SEIZE not implemented; returning EINVAL\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_ptrace
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_ptrace_args
modifier|*
name|uap
parameter_list|)
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sig
decl_stmt|;
name|pid
operator|=
operator|(
name|pid_t
operator|)
name|uap
operator|->
name|pid
expr_stmt|;
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
name|uap
operator|->
name|addr
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|req
condition|)
block|{
case|case
name|LINUX_PTRACE_TRACEME
case|:
name|error
operator|=
name|kern_ptrace
argument_list|(
name|td
argument_list|,
name|PT_TRACE_ME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PTRACE_PEEKTEXT
case|:
case|case
name|LINUX_PTRACE_PEEKDATA
case|:
name|error
operator|=
name|linux_ptrace_peek
argument_list|(
name|td
argument_list|,
name|pid
argument_list|,
name|addr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uap
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Linux expects this syscall to read 64 bits, not 32. 		 */
name|error
operator|=
name|linux_ptrace_peek
argument_list|(
name|td
argument_list|,
name|pid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uap
operator|->
name|addr
operator|+
literal|4
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uap
operator|->
name|data
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PTRACE_POKETEXT
case|:
name|error
operator|=
name|kern_ptrace
argument_list|(
name|td
argument_list|,
name|PT_WRITE_I
argument_list|,
name|pid
argument_list|,
name|addr
argument_list|,
name|uap
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PTRACE_POKEDATA
case|:
name|error
operator|=
name|kern_ptrace
argument_list|(
name|td
argument_list|,
name|PT_WRITE_D
argument_list|,
name|pid
argument_list|,
name|addr
argument_list|,
name|uap
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PTRACE_CONT
case|:
name|error
operator|=
name|map_signum
argument_list|(
name|uap
operator|->
name|data
argument_list|,
operator|&
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|error
operator|=
name|kern_ptrace
argument_list|(
name|td
argument_list|,
name|PT_CONTINUE
argument_list|,
name|pid
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|,
name|sig
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PTRACE_KILL
case|:
name|error
operator|=
name|kern_ptrace
argument_list|(
name|td
argument_list|,
name|PT_KILL
argument_list|,
name|pid
argument_list|,
name|addr
argument_list|,
name|uap
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PTRACE_SINGLESTEP
case|:
name|error
operator|=
name|map_signum
argument_list|(
name|uap
operator|->
name|data
argument_list|,
operator|&
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|error
operator|=
name|kern_ptrace
argument_list|(
name|td
argument_list|,
name|PT_STEP
argument_list|,
name|pid
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|,
name|sig
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PTRACE_GETREGS
case|:
name|error
operator|=
name|linux_ptrace_getregs
argument_list|(
name|td
argument_list|,
name|pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uap
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PTRACE_SETREGS
case|:
name|error
operator|=
name|linux_ptrace_setregs
argument_list|(
name|td
argument_list|,
name|pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uap
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PTRACE_ATTACH
case|:
name|error
operator|=
name|kern_ptrace
argument_list|(
name|td
argument_list|,
name|PT_ATTACH
argument_list|,
name|pid
argument_list|,
name|addr
argument_list|,
name|uap
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PTRACE_DETACH
case|:
name|error
operator|=
name|map_signum
argument_list|(
name|uap
operator|->
name|data
argument_list|,
operator|&
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|error
operator|=
name|kern_ptrace
argument_list|(
name|td
argument_list|,
name|PT_DETACH
argument_list|,
name|pid
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|,
name|sig
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PTRACE_SYSCALL
case|:
name|error
operator|=
name|map_signum
argument_list|(
name|uap
operator|->
name|data
argument_list|,
operator|&
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|error
operator|=
name|kern_ptrace
argument_list|(
name|td
argument_list|,
name|PT_SYSCALL
argument_list|,
name|pid
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|,
name|sig
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PTRACE_SETOPTIONS
case|:
name|error
operator|=
name|linux_ptrace_setoptions
argument_list|(
name|td
argument_list|,
name|pid
argument_list|,
name|uap
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PTRACE_GETREGSET
case|:
name|error
operator|=
name|linux_ptrace_getregset
argument_list|(
name|td
argument_list|,
name|pid
argument_list|,
name|uap
operator|->
name|addr
argument_list|,
name|uap
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PTRACE_SEIZE
case|:
name|error
operator|=
name|linux_ptrace_seize
argument_list|(
name|td
argument_list|,
name|pid
argument_list|,
name|uap
operator|->
name|addr
argument_list|,
name|uap
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: ptrace(%ld, ...) not implemented; returning EINVAL\n"
argument_list|,
name|__func__
argument_list|,
name|uap
operator|->
name|req
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

