begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 NetApp, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm_instruction_emul.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm_dev.h>
end_include

begin_include
include|#
directive|include
file|"vmm_lapic.h"
end_include

begin_include
include|#
directive|include
file|"vmm_stat.h"
end_include

begin_include
include|#
directive|include
file|"vmm_mem.h"
end_include

begin_include
include|#
directive|include
file|"io/ppt.h"
end_include

begin_include
include|#
directive|include
file|"io/vatpic.h"
end_include

begin_include
include|#
directive|include
file|"io/vioapic.h"
end_include

begin_include
include|#
directive|include
file|"io/vhpet.h"
end_include

begin_include
include|#
directive|include
file|"io/vrtc.h"
end_include

begin_struct
struct|struct
name|devmem_softc
block|{
name|int
name|segid
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|cdev
modifier|*
name|cdev
decl_stmt|;
name|struct
name|vmmdev_softc
modifier|*
name|sc
decl_stmt|;
name|SLIST_ENTRY
argument_list|(
argument|devmem_softc
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vmmdev_softc
block|{
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
comment|/* vm instance cookie */
name|struct
name|cdev
modifier|*
name|cdev
decl_stmt|;
name|SLIST_ENTRY
argument_list|(
argument|vmmdev_softc
argument_list|)
name|link
expr_stmt|;
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|devmem_softc
argument_list|)
name|devmem
expr_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|VSC_LINKED
value|0x01
end_define

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|vmmdev_softc
argument_list|)
name|head
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|vmmdev_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VMMDEV
argument_list|,
literal|"vmmdev"
argument_list|,
literal|"vmmdev"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_vmm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|devmem_create_cdev
parameter_list|(
specifier|const
name|char
modifier|*
name|vmname
parameter_list|,
name|int
name|id
parameter_list|,
name|char
modifier|*
name|devmem
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|devmem_destroy
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|vcpu_lock_one
parameter_list|(
name|struct
name|vmmdev_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vcpu
operator|<
literal|0
operator|||
name|vcpu
operator|>=
name|VM_MAXCPU
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|vcpu_set_state
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VCPU_FROZEN
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vcpu_unlock_one
parameter_list|(
name|struct
name|vmmdev_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|enum
name|vcpu_state
name|state
decl_stmt|;
name|state
operator|=
name|vcpu_get_state
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|VCPU_FROZEN
condition|)
block|{
name|panic
argument_list|(
literal|"vcpu %s(%d) has invalid state %d"
argument_list|,
name|vm_name
argument_list|(
name|sc
operator|->
name|vm
argument_list|)
argument_list|,
name|vcpu
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
name|vcpu_set_state
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VCPU_IDLE
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vcpu_lock_all
parameter_list|(
name|struct
name|vmmdev_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|vcpu
decl_stmt|;
for|for
control|(
name|vcpu
operator|=
literal|0
init|;
name|vcpu
operator|<
name|VM_MAXCPU
condition|;
name|vcpu
operator|++
control|)
block|{
name|error
operator|=
name|vcpu_lock_one
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
while|while
condition|(
operator|--
name|vcpu
operator|>=
literal|0
condition|)
name|vcpu_unlock_one
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vcpu_unlock_all
parameter_list|(
name|struct
name|vmmdev_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|vcpu
decl_stmt|;
for|for
control|(
name|vcpu
operator|=
literal|0
init|;
name|vcpu
operator|<
name|VM_MAXCPU
condition|;
name|vcpu
operator|++
control|)
name|vcpu_unlock_one
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|vmmdev_softc
modifier|*
name|vmmdev_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|vmmdev_softc
modifier|*
name|sc
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX kernel is not compiled with invariants */
name|mtx_assert
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SLIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|&head
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|vm_name
argument_list|(
name|sc
operator|->
name|vm
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|vmmdev_softc
modifier|*
name|vmmdev_lookup2
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|)
block|{
return|return
operator|(
name|cdev
operator|->
name|si_drv1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmmdev_rw
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|off
decl_stmt|,
name|c
decl_stmt|,
name|prot
decl_stmt|;
name|vm_paddr_t
name|gpa
decl_stmt|;
name|void
modifier|*
name|hpa
decl_stmt|,
modifier|*
name|cookie
decl_stmt|;
name|struct
name|vmmdev_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|vmmdev_lookup2
argument_list|(
name|cdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Get a read lock on the guest memory map by freezing any vcpu. 	 */
name|error
operator|=
name|vcpu_lock_one
argument_list|(
name|sc
argument_list|,
name|VM_MAXCPU
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|prot
operator|=
operator|(
name|uio
operator|->
name|uio_rw
operator|==
name|UIO_WRITE
condition|?
name|VM_PROT_WRITE
else|:
name|VM_PROT_READ
operator|)
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|gpa
operator|=
name|uio
operator|->
name|uio_offset
expr_stmt|;
name|off
operator|=
name|gpa
operator|&
name|PAGE_MASK
expr_stmt|;
name|c
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|PAGE_SIZE
operator|-
name|off
argument_list|)
expr_stmt|;
comment|/* 		 * The VM has a hole in its physical memory map. If we want to 		 * use 'dd' to inspect memory beyond the hole we need to 		 * provide bogus data for memory that lies in the hole. 		 * 		 * Since this device does not support lseek(2), dd(1) will 		 * read(2) blocks of data to simulate the lseek(2). 		 */
name|hpa
operator|=
name|vm_gpa_hold
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|VM_MAXCPU
operator|-
literal|1
argument_list|,
name|gpa
argument_list|,
name|c
argument_list|,
name|prot
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpa
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|uio
operator|->
name|uio_rw
operator|==
name|UIO_READ
condition|)
name|error
operator|=
name|uiomove
argument_list|(
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|zero_region
argument_list|)
argument_list|,
name|c
argument_list|,
name|uio
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|hpa
argument_list|,
name|c
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|vm_gpa_release
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
block|}
name|vcpu_unlock_one
argument_list|(
name|sc
argument_list|,
name|VM_MAXCPU
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|vm_memseg
operator|*
operator|)
literal|0
operator|)
operator|->
name|name
argument_list|)
operator|>=
name|SPECNAMELEN
operator|+
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|get_memseg
parameter_list|(
name|struct
name|vmmdev_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vm_memseg
modifier|*
name|mseg
parameter_list|)
block|{
name|struct
name|devmem_softc
modifier|*
name|dsc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bool
name|sysmem
decl_stmt|;
name|error
operator|=
name|vm_get_memseg
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|mseg
operator|->
name|segid
argument_list|,
operator|&
name|mseg
operator|->
name|len
argument_list|,
operator|&
name|sysmem
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|mseg
operator|->
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|sysmem
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|dsc
argument_list|,
argument|&sc->devmem
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|dsc
operator|->
name|segid
operator|==
name|mseg
operator|->
name|segid
condition|)
break|break;
block|}
name|KASSERT
argument_list|(
name|dsc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: devmem segment %d not found"
operator|,
name|__func__
operator|,
name|mseg
operator|->
name|segid
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|copystr
argument_list|(
name|dsc
operator|->
name|name
argument_list|,
name|mseg
operator|->
name|name
argument_list|,
name|SPECNAMELEN
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|mseg
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|mseg
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_memseg
parameter_list|(
name|struct
name|vmmdev_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vm_memseg
modifier|*
name|mseg
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bool
name|sysmem
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|sysmem
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|VM_MEMSEG_NAME
argument_list|(
name|mseg
argument_list|)
condition|)
block|{
name|sysmem
operator|=
name|false
expr_stmt|;
name|name
operator|=
name|malloc
argument_list|(
name|SPECNAMELEN
operator|+
literal|1
argument_list|,
name|M_VMMDEV
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copystr
argument_list|(
name|mseg
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|SPECNAMELEN
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
name|error
operator|=
name|vm_alloc_memseg
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|mseg
operator|->
name|segid
argument_list|,
name|mseg
operator|->
name|len
argument_list|,
name|sysmem
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|VM_MEMSEG_NAME
argument_list|(
name|mseg
argument_list|)
condition|)
block|{
name|error
operator|=
name|devmem_create_cdev
argument_list|(
name|vm_name
argument_list|(
name|sc
operator|->
name|vm
argument_list|)
argument_list|,
name|mseg
operator|->
name|segid
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|vm_free_memseg
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|mseg
operator|->
name|segid
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|NULL
expr_stmt|;
comment|/* freed when 'cdev' is destroyed */
block|}
name|done
label|:
name|free
argument_list|(
name|name
argument_list|,
name|M_VMMDEV
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmmdev_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|vcpu
decl_stmt|,
name|state_changed
decl_stmt|,
name|size
decl_stmt|;
name|cpuset_t
modifier|*
name|cpuset
decl_stmt|;
name|struct
name|vmmdev_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|vm_register
modifier|*
name|vmreg
decl_stmt|;
name|struct
name|vm_seg_desc
modifier|*
name|vmsegdesc
decl_stmt|;
name|struct
name|vm_run
modifier|*
name|vmrun
decl_stmt|;
name|struct
name|vm_exception
modifier|*
name|vmexc
decl_stmt|;
name|struct
name|vm_lapic_irq
modifier|*
name|vmirq
decl_stmt|;
name|struct
name|vm_lapic_msi
modifier|*
name|vmmsi
decl_stmt|;
name|struct
name|vm_ioapic_irq
modifier|*
name|ioapic_irq
decl_stmt|;
name|struct
name|vm_isa_irq
modifier|*
name|isa_irq
decl_stmt|;
name|struct
name|vm_isa_irq_trigger
modifier|*
name|isa_irq_trigger
decl_stmt|;
name|struct
name|vm_capability
modifier|*
name|vmcap
decl_stmt|;
name|struct
name|vm_pptdev
modifier|*
name|pptdev
decl_stmt|;
name|struct
name|vm_pptdev_mmio
modifier|*
name|pptmmio
decl_stmt|;
name|struct
name|vm_pptdev_msi
modifier|*
name|pptmsi
decl_stmt|;
name|struct
name|vm_pptdev_msix
modifier|*
name|pptmsix
decl_stmt|;
name|struct
name|vm_nmi
modifier|*
name|vmnmi
decl_stmt|;
name|struct
name|vm_stats
modifier|*
name|vmstats
decl_stmt|;
name|struct
name|vm_stat_desc
modifier|*
name|statdesc
decl_stmt|;
name|struct
name|vm_x2apic
modifier|*
name|x2apic
decl_stmt|;
name|struct
name|vm_gpa_pte
modifier|*
name|gpapte
decl_stmt|;
name|struct
name|vm_suspend
modifier|*
name|vmsuspend
decl_stmt|;
name|struct
name|vm_gla2gpa
modifier|*
name|gg
decl_stmt|;
name|struct
name|vm_activate_cpu
modifier|*
name|vac
decl_stmt|;
name|struct
name|vm_cpuset
modifier|*
name|vm_cpuset
decl_stmt|;
name|struct
name|vm_intinfo
modifier|*
name|vmii
decl_stmt|;
name|struct
name|vm_rtc_time
modifier|*
name|rtctime
decl_stmt|;
name|struct
name|vm_rtc_data
modifier|*
name|rtcdata
decl_stmt|;
name|struct
name|vm_memmap
modifier|*
name|mm
decl_stmt|;
name|sc
operator|=
name|vmmdev_lookup2
argument_list|(
name|cdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|vcpu
operator|=
operator|-
literal|1
expr_stmt|;
name|state_changed
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Some VMM ioctls can operate only on vcpus that are not running. 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|VM_RUN
case|:
case|case
name|VM_GET_REGISTER
case|:
case|case
name|VM_SET_REGISTER
case|:
case|case
name|VM_GET_SEGMENT_DESCRIPTOR
case|:
case|case
name|VM_SET_SEGMENT_DESCRIPTOR
case|:
case|case
name|VM_INJECT_EXCEPTION
case|:
case|case
name|VM_GET_CAPABILITY
case|:
case|case
name|VM_SET_CAPABILITY
case|:
case|case
name|VM_PPTDEV_MSI
case|:
case|case
name|VM_PPTDEV_MSIX
case|:
case|case
name|VM_SET_X2APIC_STATE
case|:
case|case
name|VM_GLA2GPA
case|:
case|case
name|VM_ACTIVATE_CPU
case|:
case|case
name|VM_SET_INTINFO
case|:
case|case
name|VM_GET_INTINFO
case|:
case|case
name|VM_RESTART_INSTRUCTION
case|:
comment|/* 		 * XXX fragile, handle with care 		 * Assumes that the first field of the ioctl data is the vcpu. 		 */
name|vcpu
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vcpu_lock_one
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|state_changed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VM_MAP_PPTDEV_MMIO
case|:
case|case
name|VM_BIND_PPTDEV
case|:
case|case
name|VM_UNBIND_PPTDEV
case|:
case|case
name|VM_ALLOC_MEMSEG
case|:
case|case
name|VM_MMAP_MEMSEG
case|:
case|case
name|VM_REINIT
case|:
comment|/* 		 * ioctls that operate on the entire virtual machine must 		 * prevent all vcpus from running. 		 */
name|error
operator|=
name|vcpu_lock_all
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|state_changed
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|VM_GET_MEMSEG
case|:
case|case
name|VM_MMAP_GETNEXT
case|:
comment|/* 		 * Lock a vcpu to make sure that the memory map cannot be 		 * modified while it is being inspected. 		 */
name|vcpu
operator|=
name|VM_MAXCPU
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|vcpu_lock_one
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|state_changed
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|VM_RUN
case|:
name|vmrun
operator|=
operator|(
expr|struct
name|vm_run
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_run
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmrun
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_SUSPEND
case|:
name|vmsuspend
operator|=
operator|(
expr|struct
name|vm_suspend
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_suspend
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmsuspend
operator|->
name|how
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_REINIT
case|:
name|error
operator|=
name|vm_reinit
argument_list|(
name|sc
operator|->
name|vm
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_STAT_DESC
case|:
block|{
name|statdesc
operator|=
operator|(
expr|struct
name|vm_stat_desc
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vmm_stat_desc_copy
argument_list|(
name|statdesc
operator|->
name|index
argument_list|,
name|statdesc
operator|->
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|statdesc
operator|->
name|desc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VM_STATS
case|:
block|{
name|CTASSERT
argument_list|(
name|MAX_VM_STATS
operator|>=
name|MAX_VMM_STAT_ELEMS
argument_list|)
expr_stmt|;
name|vmstats
operator|=
operator|(
expr|struct
name|vm_stats
operator|*
operator|)
name|data
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|vmstats
operator|->
name|tv
argument_list|)
expr_stmt|;
name|error
operator|=
name|vmm_stat_copy
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmstats
operator|->
name|cpuid
argument_list|,
operator|&
name|vmstats
operator|->
name|num_entries
argument_list|,
name|vmstats
operator|->
name|statbuf
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VM_PPTDEV_MSI
case|:
name|pptmsi
operator|=
operator|(
expr|struct
name|vm_pptdev_msi
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|ppt_setup_msi
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|pptmsi
operator|->
name|vcpu
argument_list|,
name|pptmsi
operator|->
name|bus
argument_list|,
name|pptmsi
operator|->
name|slot
argument_list|,
name|pptmsi
operator|->
name|func
argument_list|,
name|pptmsi
operator|->
name|addr
argument_list|,
name|pptmsi
operator|->
name|msg
argument_list|,
name|pptmsi
operator|->
name|numvec
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_PPTDEV_MSIX
case|:
name|pptmsix
operator|=
operator|(
expr|struct
name|vm_pptdev_msix
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|ppt_setup_msix
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|pptmsix
operator|->
name|vcpu
argument_list|,
name|pptmsix
operator|->
name|bus
argument_list|,
name|pptmsix
operator|->
name|slot
argument_list|,
name|pptmsix
operator|->
name|func
argument_list|,
name|pptmsix
operator|->
name|idx
argument_list|,
name|pptmsix
operator|->
name|addr
argument_list|,
name|pptmsix
operator|->
name|msg
argument_list|,
name|pptmsix
operator|->
name|vector_control
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_MAP_PPTDEV_MMIO
case|:
name|pptmmio
operator|=
operator|(
expr|struct
name|vm_pptdev_mmio
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|ppt_map_mmio
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|pptmmio
operator|->
name|bus
argument_list|,
name|pptmmio
operator|->
name|slot
argument_list|,
name|pptmmio
operator|->
name|func
argument_list|,
name|pptmmio
operator|->
name|gpa
argument_list|,
name|pptmmio
operator|->
name|len
argument_list|,
name|pptmmio
operator|->
name|hpa
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_BIND_PPTDEV
case|:
name|pptdev
operator|=
operator|(
expr|struct
name|vm_pptdev
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_assign_pptdev
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|pptdev
operator|->
name|bus
argument_list|,
name|pptdev
operator|->
name|slot
argument_list|,
name|pptdev
operator|->
name|func
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_UNBIND_PPTDEV
case|:
name|pptdev
operator|=
operator|(
expr|struct
name|vm_pptdev
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_unassign_pptdev
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|pptdev
operator|->
name|bus
argument_list|,
name|pptdev
operator|->
name|slot
argument_list|,
name|pptdev
operator|->
name|func
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_INJECT_EXCEPTION
case|:
name|vmexc
operator|=
operator|(
expr|struct
name|vm_exception
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_inject_exception
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmexc
operator|->
name|cpuid
argument_list|,
name|vmexc
operator|->
name|vector
argument_list|,
name|vmexc
operator|->
name|error_code_valid
argument_list|,
name|vmexc
operator|->
name|error_code
argument_list|,
name|vmexc
operator|->
name|restart_instruction
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_INJECT_NMI
case|:
name|vmnmi
operator|=
operator|(
expr|struct
name|vm_nmi
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_inject_nmi
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmnmi
operator|->
name|cpuid
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_LAPIC_IRQ
case|:
name|vmirq
operator|=
operator|(
expr|struct
name|vm_lapic_irq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|lapic_intr_edge
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmirq
operator|->
name|cpuid
argument_list|,
name|vmirq
operator|->
name|vector
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_LAPIC_LOCAL_IRQ
case|:
name|vmirq
operator|=
operator|(
expr|struct
name|vm_lapic_irq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|lapic_set_local_intr
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmirq
operator|->
name|cpuid
argument_list|,
name|vmirq
operator|->
name|vector
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_LAPIC_MSI
case|:
name|vmmsi
operator|=
operator|(
expr|struct
name|vm_lapic_msi
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|lapic_intr_msi
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmmsi
operator|->
name|addr
argument_list|,
name|vmmsi
operator|->
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_IOAPIC_ASSERT_IRQ
case|:
name|ioapic_irq
operator|=
operator|(
expr|struct
name|vm_ioapic_irq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vioapic_assert_irq
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|ioapic_irq
operator|->
name|irq
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_IOAPIC_DEASSERT_IRQ
case|:
name|ioapic_irq
operator|=
operator|(
expr|struct
name|vm_ioapic_irq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vioapic_deassert_irq
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|ioapic_irq
operator|->
name|irq
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_IOAPIC_PULSE_IRQ
case|:
name|ioapic_irq
operator|=
operator|(
expr|struct
name|vm_ioapic_irq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vioapic_pulse_irq
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|ioapic_irq
operator|->
name|irq
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_IOAPIC_PINCOUNT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|vioapic_pincount
argument_list|(
name|sc
operator|->
name|vm
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_ISA_ASSERT_IRQ
case|:
name|isa_irq
operator|=
operator|(
expr|struct
name|vm_isa_irq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vatpic_assert_irq
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|isa_irq
operator|->
name|atpic_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|isa_irq
operator|->
name|ioapic_irq
operator|!=
operator|-
literal|1
condition|)
name|error
operator|=
name|vioapic_assert_irq
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|isa_irq
operator|->
name|ioapic_irq
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_ISA_DEASSERT_IRQ
case|:
name|isa_irq
operator|=
operator|(
expr|struct
name|vm_isa_irq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vatpic_deassert_irq
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|isa_irq
operator|->
name|atpic_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|isa_irq
operator|->
name|ioapic_irq
operator|!=
operator|-
literal|1
condition|)
name|error
operator|=
name|vioapic_deassert_irq
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|isa_irq
operator|->
name|ioapic_irq
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_ISA_PULSE_IRQ
case|:
name|isa_irq
operator|=
operator|(
expr|struct
name|vm_isa_irq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vatpic_pulse_irq
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|isa_irq
operator|->
name|atpic_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|isa_irq
operator|->
name|ioapic_irq
operator|!=
operator|-
literal|1
condition|)
name|error
operator|=
name|vioapic_pulse_irq
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|isa_irq
operator|->
name|ioapic_irq
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_ISA_SET_IRQ_TRIGGER
case|:
name|isa_irq_trigger
operator|=
operator|(
expr|struct
name|vm_isa_irq_trigger
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vatpic_set_irq_trigger
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|isa_irq_trigger
operator|->
name|atpic_irq
argument_list|,
name|isa_irq_trigger
operator|->
name|trigger
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_MMAP_GETNEXT
case|:
name|mm
operator|=
operator|(
expr|struct
name|vm_memmap
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_mmap_getnext
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
operator|&
name|mm
operator|->
name|gpa
argument_list|,
operator|&
name|mm
operator|->
name|segid
argument_list|,
operator|&
name|mm
operator|->
name|segoff
argument_list|,
operator|&
name|mm
operator|->
name|len
argument_list|,
operator|&
name|mm
operator|->
name|prot
argument_list|,
operator|&
name|mm
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_MMAP_MEMSEG
case|:
name|mm
operator|=
operator|(
expr|struct
name|vm_memmap
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_mmap_memseg
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|mm
operator|->
name|gpa
argument_list|,
name|mm
operator|->
name|segid
argument_list|,
name|mm
operator|->
name|segoff
argument_list|,
name|mm
operator|->
name|len
argument_list|,
name|mm
operator|->
name|prot
argument_list|,
name|mm
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_ALLOC_MEMSEG
case|:
name|error
operator|=
name|alloc_memseg
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|vm_memseg
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_GET_MEMSEG
case|:
name|error
operator|=
name|get_memseg
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|vm_memseg
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_GET_REGISTER
case|:
name|vmreg
operator|=
operator|(
expr|struct
name|vm_register
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_get_register
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmreg
operator|->
name|cpuid
argument_list|,
name|vmreg
operator|->
name|regnum
argument_list|,
operator|&
name|vmreg
operator|->
name|regval
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_SET_REGISTER
case|:
name|vmreg
operator|=
operator|(
expr|struct
name|vm_register
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_set_register
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmreg
operator|->
name|cpuid
argument_list|,
name|vmreg
operator|->
name|regnum
argument_list|,
name|vmreg
operator|->
name|regval
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_SET_SEGMENT_DESCRIPTOR
case|:
name|vmsegdesc
operator|=
operator|(
expr|struct
name|vm_seg_desc
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_set_seg_desc
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmsegdesc
operator|->
name|cpuid
argument_list|,
name|vmsegdesc
operator|->
name|regnum
argument_list|,
operator|&
name|vmsegdesc
operator|->
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_GET_SEGMENT_DESCRIPTOR
case|:
name|vmsegdesc
operator|=
operator|(
expr|struct
name|vm_seg_desc
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_get_seg_desc
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmsegdesc
operator|->
name|cpuid
argument_list|,
name|vmsegdesc
operator|->
name|regnum
argument_list|,
operator|&
name|vmsegdesc
operator|->
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_GET_CAPABILITY
case|:
name|vmcap
operator|=
operator|(
expr|struct
name|vm_capability
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_get_capability
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmcap
operator|->
name|cpuid
argument_list|,
name|vmcap
operator|->
name|captype
argument_list|,
operator|&
name|vmcap
operator|->
name|capval
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_SET_CAPABILITY
case|:
name|vmcap
operator|=
operator|(
expr|struct
name|vm_capability
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_set_capability
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmcap
operator|->
name|cpuid
argument_list|,
name|vmcap
operator|->
name|captype
argument_list|,
name|vmcap
operator|->
name|capval
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_SET_X2APIC_STATE
case|:
name|x2apic
operator|=
operator|(
expr|struct
name|vm_x2apic
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_set_x2apic_state
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|x2apic
operator|->
name|cpuid
argument_list|,
name|x2apic
operator|->
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_GET_X2APIC_STATE
case|:
name|x2apic
operator|=
operator|(
expr|struct
name|vm_x2apic
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_get_x2apic_state
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|x2apic
operator|->
name|cpuid
argument_list|,
operator|&
name|x2apic
operator|->
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_GET_GPA_PMAP
case|:
name|gpapte
operator|=
operator|(
expr|struct
name|vm_gpa_pte
operator|*
operator|)
name|data
expr_stmt|;
name|pmap_get_mapping
argument_list|(
name|vmspace_pmap
argument_list|(
name|vm_get_vmspace
argument_list|(
name|sc
operator|->
name|vm
argument_list|)
argument_list|)
argument_list|,
name|gpapte
operator|->
name|gpa
argument_list|,
name|gpapte
operator|->
name|pte
argument_list|,
operator|&
name|gpapte
operator|->
name|ptenum
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VM_GET_HPET_CAPABILITIES
case|:
name|error
operator|=
name|vhpet_getcap
argument_list|(
operator|(
expr|struct
name|vm_hpet_cap
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_GLA2GPA
case|:
block|{
name|CTASSERT
argument_list|(
name|PROT_READ
operator|==
name|VM_PROT_READ
argument_list|)
expr_stmt|;
name|CTASSERT
argument_list|(
name|PROT_WRITE
operator|==
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|CTASSERT
argument_list|(
name|PROT_EXEC
operator|==
name|VM_PROT_EXECUTE
argument_list|)
expr_stmt|;
name|gg
operator|=
operator|(
expr|struct
name|vm_gla2gpa
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_gla2gpa
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|gg
operator|->
name|vcpuid
argument_list|,
operator|&
name|gg
operator|->
name|paging
argument_list|,
name|gg
operator|->
name|gla
argument_list|,
name|gg
operator|->
name|prot
argument_list|,
operator|&
name|gg
operator|->
name|gpa
argument_list|,
operator|&
name|gg
operator|->
name|fault
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|EFAULT
argument_list|,
operator|(
literal|"%s: vm_gla2gpa unknown error %d"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VM_ACTIVATE_CPU
case|:
name|vac
operator|=
operator|(
expr|struct
name|vm_activate_cpu
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_activate_cpu
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vac
operator|->
name|vcpuid
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_GET_CPUS
case|:
name|error
operator|=
literal|0
expr_stmt|;
name|vm_cpuset
operator|=
operator|(
expr|struct
name|vm_cpuset
operator|*
operator|)
name|data
expr_stmt|;
name|size
operator|=
name|vm_cpuset
operator|->
name|cpusetsize
expr_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
operator|||
name|size
operator|>
name|CPU_MAXSIZE
operator|/
name|NBBY
condition|)
block|{
name|error
operator|=
name|ERANGE
expr_stmt|;
break|break;
block|}
name|cpuset
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_cpuset
operator|->
name|which
operator|==
name|VM_ACTIVE_CPUS
condition|)
operator|*
name|cpuset
operator|=
name|vm_active_cpus
argument_list|(
name|sc
operator|->
name|vm
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vm_cpuset
operator|->
name|which
operator|==
name|VM_SUSPENDED_CPUS
condition|)
operator|*
name|cpuset
operator|=
name|vm_suspended_cpus
argument_list|(
name|sc
operator|->
name|vm
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|cpuset
argument_list|,
name|vm_cpuset
operator|->
name|cpus
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cpuset
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_SET_INTINFO
case|:
name|vmii
operator|=
operator|(
expr|struct
name|vm_intinfo
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_exit_intinfo
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmii
operator|->
name|vcpuid
argument_list|,
name|vmii
operator|->
name|info1
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_GET_INTINFO
case|:
name|vmii
operator|=
operator|(
expr|struct
name|vm_intinfo
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vm_get_intinfo
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vmii
operator|->
name|vcpuid
argument_list|,
operator|&
name|vmii
operator|->
name|info1
argument_list|,
operator|&
name|vmii
operator|->
name|info2
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_RTC_WRITE
case|:
name|rtcdata
operator|=
operator|(
expr|struct
name|vm_rtc_data
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vrtc_nvram_write
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|rtcdata
operator|->
name|offset
argument_list|,
name|rtcdata
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_RTC_READ
case|:
name|rtcdata
operator|=
operator|(
expr|struct
name|vm_rtc_data
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vrtc_nvram_read
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|rtcdata
operator|->
name|offset
argument_list|,
operator|&
name|rtcdata
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_RTC_SETTIME
case|:
name|rtctime
operator|=
operator|(
expr|struct
name|vm_rtc_time
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|vrtc_set_time
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|rtctime
operator|->
name|secs
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_RTC_GETTIME
case|:
name|error
operator|=
literal|0
expr_stmt|;
name|rtctime
operator|=
operator|(
expr|struct
name|vm_rtc_time
operator|*
operator|)
name|data
expr_stmt|;
name|rtctime
operator|->
name|secs
operator|=
name|vrtc_get_time
argument_list|(
name|sc
operator|->
name|vm
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_RESTART_INSTRUCTION
case|:
name|error
operator|=
name|vm_restart_instruction
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|state_changed
operator|==
literal|1
condition|)
name|vcpu_unlock_one
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|state_changed
operator|==
literal|2
condition|)
name|vcpu_unlock_all
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* Make sure that no handler returns a bogus value like ERESTART */
name|KASSERT
argument_list|(
name|error
operator|>=
literal|0
argument_list|,
operator|(
literal|"vmmdev_ioctl: invalid error return %d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmmdev_mmap_single
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|,
name|vm_ooffset_t
modifier|*
name|offset
parameter_list|,
name|vm_size_t
name|mapsize
parameter_list|,
name|struct
name|vm_object
modifier|*
modifier|*
name|objp
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|struct
name|vmmdev_softc
modifier|*
name|sc
decl_stmt|;
name|vm_paddr_t
name|gpa
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|vm_ooffset_t
name|segoff
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|;
name|int
name|error
decl_stmt|,
name|found
decl_stmt|,
name|segid
decl_stmt|;
name|bool
name|sysmem
decl_stmt|;
name|first
operator|=
operator|*
name|offset
expr_stmt|;
name|last
operator|=
name|first
operator|+
name|mapsize
expr_stmt|;
if|if
condition|(
operator|(
name|nprot
operator|&
name|PROT_EXEC
operator|)
operator|||
name|first
operator|<
literal|0
operator|||
name|first
operator|>=
name|last
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|vmmdev_lookup2
argument_list|(
name|cdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
comment|/* virtual machine is in the process of being created */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Get a read lock on the guest memory map by freezing any vcpu. 	 */
name|error
operator|=
name|vcpu_lock_one
argument_list|(
name|sc
argument_list|,
name|VM_MAXCPU
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|gpa
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|found
condition|)
block|{
name|error
operator|=
name|vm_mmap_getnext
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
operator|&
name|gpa
argument_list|,
operator|&
name|segid
argument_list|,
operator|&
name|segoff
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|first
operator|>=
name|gpa
operator|&&
name|last
operator|<=
name|gpa
operator|+
name|len
condition|)
name|found
operator|=
literal|1
expr_stmt|;
else|else
name|gpa
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
name|error
operator|=
name|vm_get_memseg
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|segid
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|sysmem
argument_list|,
name|objp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
operator|&&
operator|*
name|objp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: invalid memory segment %d"
operator|,
name|__func__
operator|,
name|segid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysmem
condition|)
block|{
name|vm_object_reference
argument_list|(
operator|*
name|objp
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|segoff
operator|+
operator|(
name|first
operator|-
name|gpa
operator|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
name|vcpu_unlock_one
argument_list|(
name|sc
argument_list|,
name|VM_MAXCPU
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmmdev_destroy
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vmmdev_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|devmem_softc
modifier|*
name|dsc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|vcpu_lock_all
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d freezing vcpus"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dsc
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|devmem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|dsc
operator|->
name|cdev
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: devmem not free"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|devmem
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dsc
operator|->
name|name
argument_list|,
name|M_VMMDEV
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dsc
argument_list|,
name|M_VMMDEV
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|cdev
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|sc
operator|->
name|cdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vm
operator|!=
name|NULL
condition|)
name|vm_destroy
argument_list|(
name|sc
operator|->
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|VSC_LINKED
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|)
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|head
argument_list|,
name|sc
argument_list|,
name|vmmdev_softc
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
argument_list|,
name|M_VMMDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_vmm_destroy
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
name|buf
index|[
name|VM_MAX_NAMELEN
index|]
decl_stmt|;
name|struct
name|devmem_softc
modifier|*
name|dsc
decl_stmt|;
name|struct
name|vmmdev_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cdev
modifier|*
name|cdev
decl_stmt|;
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"beavis"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|)
expr_stmt|;
name|sc
operator|=
name|vmmdev_lookup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|cdev
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * The 'cdev' will be destroyed asynchronously when 'si_threadcount' 	 * goes down to 0 so we should not do it again in the callback. 	 * 	 * Setting 'sc->cdev' to NULL is also used to indicate that the VM 	 * is scheduled for destruction. 	 */
name|cdev
operator|=
name|sc
operator|->
name|cdev
expr_stmt|;
name|sc
operator|->
name|cdev
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule all cdevs to be destroyed: 	 * 	 * - any new operations on the 'cdev' will return an error (ENXIO). 	 * 	 * - when the 'si_threadcount' dwindles down to zero the 'cdev' will 	 *   be destroyed and the callback will be invoked in a taskqueue 	 *   context. 	 * 	 * - the 'devmem' cdevs are destroyed before the virtual machine 'cdev' 	 */
name|SLIST_FOREACH
argument_list|(
argument|dsc
argument_list|,
argument|&sc->devmem
argument_list|,
argument|link
argument_list|)
block|{
name|KASSERT
argument_list|(
name|dsc
operator|->
name|cdev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"devmem cdev already destroyed"
operator|)
argument_list|)
expr_stmt|;
name|destroy_dev_sched_cb
argument_list|(
name|dsc
operator|->
name|cdev
argument_list|,
name|devmem_destroy
argument_list|,
name|dsc
argument_list|)
expr_stmt|;
block|}
name|destroy_dev_sched_cb
argument_list|(
name|cdev
argument_list|,
name|vmmdev_destroy
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_vmm
argument_list|,
name|OID_AUTO
argument_list|,
name|destroy
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_vmm_destroy
argument_list|,
literal|"A"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|vmmdevsw
init|=
block|{
operator|.
name|d_name
operator|=
literal|"vmmdev"
block|,
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_ioctl
operator|=
name|vmmdev_ioctl
block|,
operator|.
name|d_mmap_single
operator|=
name|vmmdev_mmap_single
block|,
operator|.
name|d_read
operator|=
name|vmmdev_rw
block|,
operator|.
name|d_write
operator|=
name|vmmdev_rw
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sysctl_vmm_create
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
name|struct
name|cdev
modifier|*
name|cdev
decl_stmt|;
name|struct
name|vmmdev_softc
modifier|*
name|sc
decl_stmt|,
modifier|*
name|sc2
decl_stmt|;
name|char
name|buf
index|[
name|VM_MAX_NAMELEN
index|]
decl_stmt|;
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"beavis"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|)
expr_stmt|;
name|sc
operator|=
name|vmmdev_lookup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
name|error
operator|=
name|vm_create
argument_list|(
name|buf
argument_list|,
operator|&
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vmmdev_softc
argument_list|)
argument_list|,
name|M_VMMDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|devmem
argument_list|)
expr_stmt|;
comment|/* 	 * Lookup the name again just in case somebody sneaked in when we 	 * dropped the lock. 	 */
name|mtx_lock
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|)
expr_stmt|;
name|sc2
operator|=
name|vmmdev_lookup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc2
operator|==
name|NULL
condition|)
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|head
argument_list|,
name|sc
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|VSC_LINKED
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc2
operator|!=
name|NULL
condition|)
block|{
name|vmmdev_destroy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|error
operator|=
name|make_dev_p
argument_list|(
name|MAKEDEV_CHECKNAME
argument_list|,
operator|&
name|cdev
argument_list|,
operator|&
name|vmmdevsw
argument_list|,
name|NULL
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"vmm/%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|vmmdev_destroy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cdev
operator|=
name|cdev
expr_stmt|;
name|sc
operator|->
name|cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_vmm
argument_list|,
name|OID_AUTO
argument_list|,
name|create
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_vmm_create
argument_list|,
literal|"A"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|vmmdev_init
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_init
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|,
literal|"vmm device mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vmmdev_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|head
argument_list|)
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
name|error
operator|=
name|EBUSY
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devmem_mmap_single
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|,
name|vm_ooffset_t
modifier|*
name|offset
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|struct
name|vm_object
modifier|*
modifier|*
name|objp
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|struct
name|devmem_softc
modifier|*
name|dsc
decl_stmt|;
name|vm_ooffset_t
name|first
decl_stmt|,
name|last
decl_stmt|;
name|size_t
name|seglen
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bool
name|sysmem
decl_stmt|;
name|dsc
operator|=
name|cdev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|dsc
operator|==
name|NULL
condition|)
block|{
comment|/* 'cdev' has been created but is not ready for use */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|first
operator|=
operator|*
name|offset
expr_stmt|;
name|last
operator|=
operator|*
name|offset
operator|+
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|nprot
operator|&
name|PROT_EXEC
operator|)
operator|||
name|first
operator|<
literal|0
operator|||
name|first
operator|>=
name|last
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|vcpu_lock_one
argument_list|(
name|dsc
operator|->
name|sc
argument_list|,
name|VM_MAXCPU
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|vm_get_memseg
argument_list|(
name|dsc
operator|->
name|sc
operator|->
name|vm
argument_list|,
name|dsc
operator|->
name|segid
argument_list|,
operator|&
name|seglen
argument_list|,
operator|&
name|sysmem
argument_list|,
name|objp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
operator|&&
operator|!
name|sysmem
operator|&&
operator|*
name|objp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: invalid devmem segment %d"
operator|,
name|__func__
operator|,
name|dsc
operator|->
name|segid
operator|)
argument_list|)
expr_stmt|;
name|vcpu_unlock_one
argument_list|(
name|dsc
operator|->
name|sc
argument_list|,
name|VM_MAXCPU
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|seglen
operator|>=
name|last
condition|)
block|{
name|vm_object_reference
argument_list|(
operator|*
name|objp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|devmemsw
init|=
block|{
operator|.
name|d_name
operator|=
literal|"devmem"
block|,
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_mmap_single
operator|=
name|devmem_mmap_single
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|devmem_create_cdev
parameter_list|(
specifier|const
name|char
modifier|*
name|vmname
parameter_list|,
name|int
name|segid
parameter_list|,
name|char
modifier|*
name|devname
parameter_list|)
block|{
name|struct
name|devmem_softc
modifier|*
name|dsc
decl_stmt|;
name|struct
name|vmmdev_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cdev
modifier|*
name|cdev
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|make_dev_p
argument_list|(
name|MAKEDEV_CHECKNAME
argument_list|,
operator|&
name|cdev
argument_list|,
operator|&
name|devmemsw
argument_list|,
name|NULL
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"vmm.io/%s.%s"
argument_list|,
name|vmname
argument_list|,
name|devname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dsc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|devmem_softc
argument_list|)
argument_list|,
name|M_VMMDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|)
expr_stmt|;
name|sc
operator|=
name|vmmdev_lookup
argument_list|(
name|vmname
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: vm %s softc not found"
operator|,
name|__func__
operator|,
name|vmname
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cdev
operator|==
name|NULL
condition|)
block|{
comment|/* virtual machine is being created or destroyed */
name|mtx_unlock
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dsc
argument_list|,
name|M_VMMDEV
argument_list|)
expr_stmt|;
name|destroy_dev_sched_cb
argument_list|(
name|cdev
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|dsc
operator|->
name|segid
operator|=
name|segid
expr_stmt|;
name|dsc
operator|->
name|name
operator|=
name|devname
expr_stmt|;
name|dsc
operator|->
name|cdev
operator|=
name|cdev
expr_stmt|;
name|dsc
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|devmem
argument_list|,
name|dsc
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vmmdev_mtx
argument_list|)
expr_stmt|;
comment|/* The 'cdev' is ready for use after 'si_drv1' is initialized */
name|cdev
operator|->
name|si_drv1
operator|=
name|dsc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|devmem_destroy
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|devmem_softc
modifier|*
name|dsc
init|=
name|arg
decl_stmt|;
name|KASSERT
argument_list|(
name|dsc
operator|->
name|cdev
argument_list|,
operator|(
literal|"%s: devmem cdev already destroyed"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|dsc
operator|->
name|cdev
operator|=
name|NULL
expr_stmt|;
name|dsc
operator|->
name|sc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

