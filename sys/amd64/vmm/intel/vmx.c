begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 NetApp, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|"vmm_host.h"
end_include

begin_include
include|#
directive|include
file|"vmm_lapic.h"
end_include

begin_include
include|#
directive|include
file|"vmm_msr.h"
end_include

begin_include
include|#
directive|include
file|"vmm_ktr.h"
end_include

begin_include
include|#
directive|include
file|"vmm_stat.h"
end_include

begin_include
include|#
directive|include
file|"vmx_msr.h"
end_include

begin_include
include|#
directive|include
file|"ept.h"
end_include

begin_include
include|#
directive|include
file|"vmx_cpufunc.h"
end_include

begin_include
include|#
directive|include
file|"vmx.h"
end_include

begin_include
include|#
directive|include
file|"x86.h"
end_include

begin_include
include|#
directive|include
file|"vmx_controls.h"
end_include

begin_define
define|#
directive|define
name|PINBASED_CTLS_ONE_SETTING
define|\
value|(PINBASED_EXTINT_EXITING	|				\ 	 PINBASED_NMI_EXITING		|				\ 	 PINBASED_VIRTUAL_NMI)
end_define

begin_define
define|#
directive|define
name|PINBASED_CTLS_ZERO_SETTING
value|0
end_define

begin_define
define|#
directive|define
name|PROCBASED_CTLS_WINDOW_SETTING
define|\
value|(PROCBASED_INT_WINDOW_EXITING	|				\ 	 PROCBASED_NMI_WINDOW_EXITING)
end_define

begin_define
define|#
directive|define
name|PROCBASED_CTLS_ONE_SETTING
define|\
value|(PROCBASED_SECONDARY_CONTROLS	|				\ 	 PROCBASED_IO_EXITING		|				\ 	 PROCBASED_MSR_BITMAPS		|				\ 	 PROCBASED_CTLS_WINDOW_SETTING)
end_define

begin_define
define|#
directive|define
name|PROCBASED_CTLS_ZERO_SETTING
define|\
value|(PROCBASED_CR3_LOAD_EXITING |	\ 	PROCBASED_CR3_STORE_EXITING |	\ 	PROCBASED_IO_BITMAPS)
end_define

begin_define
define|#
directive|define
name|PROCBASED_CTLS2_ONE_SETTING
value|PROCBASED2_ENABLE_EPT
end_define

begin_define
define|#
directive|define
name|PROCBASED_CTLS2_ZERO_SETTING
value|0
end_define

begin_define
define|#
directive|define
name|VM_EXIT_CTLS_ONE_SETTING_NO_PAT
define|\
value|(VM_EXIT_HOST_LMA			|			\ 	VM_EXIT_SAVE_EFER			|			\ 	VM_EXIT_LOAD_EFER)
end_define

begin_define
define|#
directive|define
name|VM_EXIT_CTLS_ONE_SETTING
define|\
value|(VM_EXIT_CTLS_ONE_SETTING_NO_PAT       	|			\ 	VM_EXIT_SAVE_PAT			|			\ 	VM_EXIT_LOAD_PAT)
end_define

begin_define
define|#
directive|define
name|VM_EXIT_CTLS_ZERO_SETTING
value|VM_EXIT_SAVE_DEBUG_CONTROLS
end_define

begin_define
define|#
directive|define
name|VM_ENTRY_CTLS_ONE_SETTING_NO_PAT
value|VM_ENTRY_LOAD_EFER
end_define

begin_define
define|#
directive|define
name|VM_ENTRY_CTLS_ONE_SETTING
define|\
value|(VM_ENTRY_CTLS_ONE_SETTING_NO_PAT     	|			\ 	VM_ENTRY_LOAD_PAT)
end_define

begin_define
define|#
directive|define
name|VM_ENTRY_CTLS_ZERO_SETTING
define|\
value|(VM_ENTRY_LOAD_DEBUG_CONTROLS		|			\ 	VM_ENTRY_INTO_SMM			|			\ 	VM_ENTRY_DEACTIVATE_DUAL_MONITOR)
end_define

begin_define
define|#
directive|define
name|guest_msr_rw
parameter_list|(
name|vmx
parameter_list|,
name|msr
parameter_list|)
define|\
value|msr_bitmap_change_access((vmx)->msr_bitmap, (msr), MSR_BITMAP_ACCESS_RW)
end_define

begin_define
define|#
directive|define
name|HANDLED
value|1
end_define

begin_define
define|#
directive|define
name|UNHANDLED
value|0
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_VMX
argument_list|,
literal|"vmx"
argument_list|,
literal|"vmx"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_vmm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_vmm
argument_list|,
name|OID_AUTO
argument_list|,
name|vmx
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|vmxon_enabled
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
name|vmxon_region
index|[
name|MAXCPU
index|]
index|[
name|PAGE_SIZE
index|]
name|__aligned
parameter_list|(
name|PAGE_SIZE
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|uint32_t
name|pinbased_ctls
decl_stmt|,
name|procbased_ctls
decl_stmt|,
name|procbased_ctls2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|exit_ctls
decl_stmt|,
name|entry_ctls
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|cr0_ones_mask
decl_stmt|,
name|cr0_zeros_mask
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_hw_vmm_vmx
argument_list|,
name|OID_AUTO
argument_list|,
name|cr0_ones_mask
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|cr0_ones_mask
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_hw_vmm_vmx
argument_list|,
name|OID_AUTO
argument_list|,
name|cr0_zeros_mask
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|cr0_zeros_mask
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|cr4_ones_mask
decl_stmt|,
name|cr4_zeros_mask
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_hw_vmm_vmx
argument_list|,
name|OID_AUTO
argument_list|,
name|cr4_ones_mask
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|cr4_ones_mask
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_hw_vmm_vmx
argument_list|,
name|OID_AUTO
argument_list|,
name|cr4_zeros_mask
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|cr4_zeros_mask
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|vmx_no_patmsr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vmx_initialized
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_vmm_vmx
argument_list|,
name|OID_AUTO
argument_list|,
name|initialized
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|vmx_initialized
argument_list|,
literal|0
argument_list|,
literal|"Intel VMX initialized"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Virtual NMI blocking conditions.  *  * Some processor implementations also require NMI to be blocked if  * the STI_BLOCKING bit is set. It is possible to detect this at runtime  * based on the (exit_reason,exit_qual) tuple being set to   * (EXIT_REASON_INVAL_VMCS, EXIT_QUAL_NMI_WHILE_STI_BLOCKING).  *  * We take the easy way out and also include STI_BLOCKING as one of the  * gating items for vNMI injection.  */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|nmi_blocking_bits
init|=
name|VMCS_INTERRUPTIBILITY_MOVSS_BLOCKING
operator||
name|VMCS_INTERRUPTIBILITY_NMI_BLOCKING
operator||
name|VMCS_INTERRUPTIBILITY_STI_BLOCKING
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Optional capabilities  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cap_halt_exit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cap_pause_exit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cap_unrestricted_guest
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cap_monitor_trap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cap_invpcid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|unrhdr
modifier|*
name|vpid_unr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|vpid_alloc_failed
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_vmm_vmx
argument_list|,
name|OID_AUTO
argument_list|,
name|vpid_alloc_failed
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|vpid_alloc_failed
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|exit_reason_to_str
parameter_list|(
name|int
name|reason
parameter_list|)
block|{
specifier|static
name|char
name|reasonbuf
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|EXIT_REASON_EXCEPTION
case|:
return|return
literal|"exception"
return|;
case|case
name|EXIT_REASON_EXT_INTR
case|:
return|return
literal|"extint"
return|;
case|case
name|EXIT_REASON_TRIPLE_FAULT
case|:
return|return
literal|"triplefault"
return|;
case|case
name|EXIT_REASON_INIT
case|:
return|return
literal|"init"
return|;
case|case
name|EXIT_REASON_SIPI
case|:
return|return
literal|"sipi"
return|;
case|case
name|EXIT_REASON_IO_SMI
case|:
return|return
literal|"iosmi"
return|;
case|case
name|EXIT_REASON_SMI
case|:
return|return
literal|"smi"
return|;
case|case
name|EXIT_REASON_INTR_WINDOW
case|:
return|return
literal|"intrwindow"
return|;
case|case
name|EXIT_REASON_NMI_WINDOW
case|:
return|return
literal|"nmiwindow"
return|;
case|case
name|EXIT_REASON_TASK_SWITCH
case|:
return|return
literal|"taskswitch"
return|;
case|case
name|EXIT_REASON_CPUID
case|:
return|return
literal|"cpuid"
return|;
case|case
name|EXIT_REASON_GETSEC
case|:
return|return
literal|"getsec"
return|;
case|case
name|EXIT_REASON_HLT
case|:
return|return
literal|"hlt"
return|;
case|case
name|EXIT_REASON_INVD
case|:
return|return
literal|"invd"
return|;
case|case
name|EXIT_REASON_INVLPG
case|:
return|return
literal|"invlpg"
return|;
case|case
name|EXIT_REASON_RDPMC
case|:
return|return
literal|"rdpmc"
return|;
case|case
name|EXIT_REASON_RDTSC
case|:
return|return
literal|"rdtsc"
return|;
case|case
name|EXIT_REASON_RSM
case|:
return|return
literal|"rsm"
return|;
case|case
name|EXIT_REASON_VMCALL
case|:
return|return
literal|"vmcall"
return|;
case|case
name|EXIT_REASON_VMCLEAR
case|:
return|return
literal|"vmclear"
return|;
case|case
name|EXIT_REASON_VMLAUNCH
case|:
return|return
literal|"vmlaunch"
return|;
case|case
name|EXIT_REASON_VMPTRLD
case|:
return|return
literal|"vmptrld"
return|;
case|case
name|EXIT_REASON_VMPTRST
case|:
return|return
literal|"vmptrst"
return|;
case|case
name|EXIT_REASON_VMREAD
case|:
return|return
literal|"vmread"
return|;
case|case
name|EXIT_REASON_VMRESUME
case|:
return|return
literal|"vmresume"
return|;
case|case
name|EXIT_REASON_VMWRITE
case|:
return|return
literal|"vmwrite"
return|;
case|case
name|EXIT_REASON_VMXOFF
case|:
return|return
literal|"vmxoff"
return|;
case|case
name|EXIT_REASON_VMXON
case|:
return|return
literal|"vmxon"
return|;
case|case
name|EXIT_REASON_CR_ACCESS
case|:
return|return
literal|"craccess"
return|;
case|case
name|EXIT_REASON_DR_ACCESS
case|:
return|return
literal|"draccess"
return|;
case|case
name|EXIT_REASON_INOUT
case|:
return|return
literal|"inout"
return|;
case|case
name|EXIT_REASON_RDMSR
case|:
return|return
literal|"rdmsr"
return|;
case|case
name|EXIT_REASON_WRMSR
case|:
return|return
literal|"wrmsr"
return|;
case|case
name|EXIT_REASON_INVAL_VMCS
case|:
return|return
literal|"invalvmcs"
return|;
case|case
name|EXIT_REASON_INVAL_MSR
case|:
return|return
literal|"invalmsr"
return|;
case|case
name|EXIT_REASON_MWAIT
case|:
return|return
literal|"mwait"
return|;
case|case
name|EXIT_REASON_MTF
case|:
return|return
literal|"mtf"
return|;
case|case
name|EXIT_REASON_MONITOR
case|:
return|return
literal|"monitor"
return|;
case|case
name|EXIT_REASON_PAUSE
case|:
return|return
literal|"pause"
return|;
case|case
name|EXIT_REASON_MCE
case|:
return|return
literal|"mce"
return|;
case|case
name|EXIT_REASON_TPR
case|:
return|return
literal|"tpr"
return|;
case|case
name|EXIT_REASON_APIC
case|:
return|return
literal|"apic"
return|;
case|case
name|EXIT_REASON_GDTR_IDTR
case|:
return|return
literal|"gdtridtr"
return|;
case|case
name|EXIT_REASON_LDTR_TR
case|:
return|return
literal|"ldtrtr"
return|;
case|case
name|EXIT_REASON_EPT_FAULT
case|:
return|return
literal|"eptfault"
return|;
case|case
name|EXIT_REASON_EPT_MISCONFIG
case|:
return|return
literal|"eptmisconfig"
return|;
case|case
name|EXIT_REASON_INVEPT
case|:
return|return
literal|"invept"
return|;
case|case
name|EXIT_REASON_RDTSCP
case|:
return|return
literal|"rdtscp"
return|;
case|case
name|EXIT_REASON_VMX_PREEMPT
case|:
return|return
literal|"vmxpreempt"
return|;
case|case
name|EXIT_REASON_INVVPID
case|:
return|return
literal|"invvpid"
return|;
case|case
name|EXIT_REASON_WBINVD
case|:
return|return
literal|"wbinvd"
return|;
case|case
name|EXIT_REASON_XSETBV
case|:
return|return
literal|"xsetbv"
return|;
default|default:
name|snprintf
argument_list|(
name|reasonbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|reasonbuf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
operator|(
name|reasonbuf
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KTR */
end_comment

begin_function
name|u_long
name|vmx_fix_cr0
parameter_list|(
name|u_long
name|cr0
parameter_list|)
block|{
return|return
operator|(
operator|(
name|cr0
operator||
name|cr0_ones_mask
operator|)
operator|&
operator|~
name|cr0_zeros_mask
operator|)
return|;
block|}
end_function

begin_function
name|u_long
name|vmx_fix_cr4
parameter_list|(
name|u_long
name|cr4
parameter_list|)
block|{
return|return
operator|(
operator|(
name|cr4
operator||
name|cr4_ones_mask
operator|)
operator|&
operator|~
name|cr4_zeros_mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vpid_free
parameter_list|(
name|int
name|vpid
parameter_list|)
block|{
if|if
condition|(
name|vpid
operator|<
literal|0
operator|||
name|vpid
operator|>
literal|0xffff
condition|)
name|panic
argument_list|(
literal|"vpid_free: invalid vpid %d"
argument_list|,
name|vpid
argument_list|)
expr_stmt|;
comment|/* 	 * VPIDs [0,VM_MAXCPU] are special and are not allocated from 	 * the unit number allocator. 	 */
if|if
condition|(
name|vpid
operator|>
name|VM_MAXCPU
condition|)
name|free_unr
argument_list|(
name|vpid_unr
argument_list|,
name|vpid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vpid_alloc
parameter_list|(
name|uint16_t
modifier|*
name|vpid
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0
operator|||
name|num
operator|>
name|VM_MAXCPU
condition|)
name|panic
argument_list|(
literal|"invalid number of vpids requested: %d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
comment|/* 	 * If the "enable vpid" execution control is not enabled then the 	 * VPID is required to be 0 for all vcpus. 	 */
if|if
condition|(
operator|(
name|procbased_ctls2
operator|&
name|PROCBASED2_ENABLE_VPID
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|vpid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * Allocate a unique VPID for each vcpu from the unit number allocator. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|alloc_unr
argument_list|(
name|vpid_unr
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
break|break;
else|else
name|vpid
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|num
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|vpid_alloc_failed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * If the unit number allocator does not have enough unique 		 * VPIDs then we need to allocate from the [1,VM_MAXCPU] range. 		 * 		 * These VPIDs are not be unique across VMs but this does not 		 * affect correctness because the combined mappings are also 		 * tagged with the EP4TA which is unique for each VM. 		 * 		 * It is still sub-optimal because the invvpid will invalidate 		 * combined mappings for a particular VPID across all EP4TAs. 		 */
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|vpid_free
argument_list|(
name|vpid
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|vpid
index|[
name|i
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vpid_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * VPID 0 is required when the "enable VPID" execution control is 	 * disabled. 	 * 	 * VPIDs [1,VM_MAXCPU] are used as the "overflow namespace" when the 	 * unit number allocator does not have sufficient unique VPIDs to 	 * satisfy the allocation. 	 * 	 * The remaining VPIDs are managed by the unit number allocator. 	 */
name|vpid_unr
operator|=
name|new_unrhdr
argument_list|(
name|VM_MAXCPU
operator|+
literal|1
argument_list|,
literal|0xffff
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msr_save_area_init
parameter_list|(
name|struct
name|msr_entry
modifier|*
name|g_area
parameter_list|,
name|int
modifier|*
name|g_count
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
specifier|static
name|struct
name|msr_entry
name|guest_msrs
index|[]
init|=
block|{
block|{
name|MSR_KGSBASE
block|,
literal|0
block|,
literal|0
block|}
block|, 	}
decl_stmt|;
name|cnt
operator|=
sizeof|sizeof
argument_list|(
name|guest_msrs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|guest_msrs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|GUEST_MSR_MAX_ENTRIES
condition|)
name|panic
argument_list|(
literal|"guest msr save area overrun"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|guest_msrs
argument_list|,
name|g_area
argument_list|,
sizeof|sizeof
argument_list|(
name|guest_msrs
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|g_count
operator|=
name|cnt
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmx_disable
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|struct
name|invvpid_desc
name|invvpid_desc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|struct
name|invept_desc
name|invept_desc
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|vmxon_enabled
index|[
name|curcpu
index|]
condition|)
block|{
comment|/* 		 * See sections 25.3.3.3 and 25.3.3.4 in Intel Vol 3b. 		 * 		 * VMXON or VMXOFF are not required to invalidate any TLB 		 * caching structures. This prevents potential retention of 		 * cached information in the TLB between distinct VMX episodes. 		 */
name|invvpid
argument_list|(
name|INVVPID_TYPE_ALL_CONTEXTS
argument_list|,
name|invvpid_desc
argument_list|)
expr_stmt|;
name|invept
argument_list|(
name|INVEPT_TYPE_ALL_CONTEXTS
argument_list|,
name|invept_desc
argument_list|)
expr_stmt|;
name|vmxoff
argument_list|()
expr_stmt|;
block|}
name|load_cr4
argument_list|(
name|rcr4
argument_list|()
operator|&
operator|~
name|CR4_VMXE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|vpid_unr
operator|!=
name|NULL
condition|)
block|{
name|delete_unrhdr
argument_list|(
name|vpid_unr
argument_list|)
expr_stmt|;
name|vpid_unr
operator|=
name|NULL
expr_stmt|;
block|}
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|vmx_disable
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmx_enable
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|load_cr4
argument_list|(
name|rcr4
argument_list|()
operator||
name|CR4_VMXE
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|vmxon_region
index|[
name|curcpu
index|]
operator|=
name|vmx_revision
argument_list|()
expr_stmt|;
name|error
operator|=
name|vmxon
argument_list|(
name|vmxon_region
index|[
name|curcpu
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|vmxon_enabled
index|[
name|curcpu
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmx_restore
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|vmxon_enabled
index|[
name|curcpu
index|]
condition|)
name|vmxon
argument_list|(
name|vmxon_region
index|[
name|curcpu
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
name|fixed0
decl_stmt|,
name|fixed1
decl_stmt|,
name|feature_control
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
comment|/* CPUID.1:ECX[bit 5] must be 1 for processor to support VMX */
if|if
condition|(
operator|!
operator|(
name|cpu_feature2
operator|&
name|CPUID2_VMX
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"vmx_init: processor does not support VMX operation\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Verify that MSR_IA32_FEATURE_CONTROL lock and VMXON enable bits 	 * are set (bits 0 and 2 respectively). 	 */
name|feature_control
operator|=
name|rdmsr
argument_list|(
name|MSR_IA32_FEATURE_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|feature_control
operator|&
name|IA32_FEATURE_CONTROL_LOCK
operator|)
operator|==
literal|0
operator|||
operator|(
name|feature_control
operator|&
name|IA32_FEATURE_CONTROL_VMX_EN
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vmx_init: VMX operation disabled by BIOS\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Check support for primary processor-based VM-execution controls */
name|error
operator|=
name|vmx_set_ctlreg
argument_list|(
name|MSR_VMX_PROCBASED_CTLS
argument_list|,
name|MSR_VMX_TRUE_PROCBASED_CTLS
argument_list|,
name|PROCBASED_CTLS_ONE_SETTING
argument_list|,
name|PROCBASED_CTLS_ZERO_SETTING
argument_list|,
operator|&
name|procbased_ctls
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"vmx_init: processor does not support desired primary "
literal|"processor-based controls\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Clear the processor-based ctl bits that are set on demand */
name|procbased_ctls
operator|&=
operator|~
name|PROCBASED_CTLS_WINDOW_SETTING
expr_stmt|;
comment|/* Check support for secondary processor-based VM-execution controls */
name|error
operator|=
name|vmx_set_ctlreg
argument_list|(
name|MSR_VMX_PROCBASED_CTLS2
argument_list|,
name|MSR_VMX_PROCBASED_CTLS2
argument_list|,
name|PROCBASED_CTLS2_ONE_SETTING
argument_list|,
name|PROCBASED_CTLS2_ZERO_SETTING
argument_list|,
operator|&
name|procbased_ctls2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"vmx_init: processor does not support desired secondary "
literal|"processor-based controls\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Check support for VPID */
name|error
operator|=
name|vmx_set_ctlreg
argument_list|(
name|MSR_VMX_PROCBASED_CTLS2
argument_list|,
name|MSR_VMX_PROCBASED_CTLS2
argument_list|,
name|PROCBASED2_ENABLE_VPID
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|procbased_ctls2
operator||=
name|PROCBASED2_ENABLE_VPID
expr_stmt|;
comment|/* Check support for pin-based VM-execution controls */
name|error
operator|=
name|vmx_set_ctlreg
argument_list|(
name|MSR_VMX_PINBASED_CTLS
argument_list|,
name|MSR_VMX_TRUE_PINBASED_CTLS
argument_list|,
name|PINBASED_CTLS_ONE_SETTING
argument_list|,
name|PINBASED_CTLS_ZERO_SETTING
argument_list|,
operator|&
name|pinbased_ctls
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"vmx_init: processor does not support desired "
literal|"pin-based controls\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Check support for VM-exit controls */
name|error
operator|=
name|vmx_set_ctlreg
argument_list|(
name|MSR_VMX_EXIT_CTLS
argument_list|,
name|MSR_VMX_TRUE_EXIT_CTLS
argument_list|,
name|VM_EXIT_CTLS_ONE_SETTING
argument_list|,
name|VM_EXIT_CTLS_ZERO_SETTING
argument_list|,
operator|&
name|exit_ctls
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* Try again without the PAT MSR bits */
name|error
operator|=
name|vmx_set_ctlreg
argument_list|(
name|MSR_VMX_EXIT_CTLS
argument_list|,
name|MSR_VMX_TRUE_EXIT_CTLS
argument_list|,
name|VM_EXIT_CTLS_ONE_SETTING_NO_PAT
argument_list|,
name|VM_EXIT_CTLS_ZERO_SETTING
argument_list|,
operator|&
name|exit_ctls
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"vmx_init: processor does not support desired "
literal|"exit controls\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"vmm: PAT MSR access not supported\n"
argument_list|)
expr_stmt|;
name|guest_msr_valid
argument_list|(
name|MSR_PAT
argument_list|)
expr_stmt|;
name|vmx_no_patmsr
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Check support for VM-entry controls */
if|if
condition|(
operator|!
name|vmx_no_patmsr
condition|)
block|{
name|error
operator|=
name|vmx_set_ctlreg
argument_list|(
name|MSR_VMX_ENTRY_CTLS
argument_list|,
name|MSR_VMX_TRUE_ENTRY_CTLS
argument_list|,
name|VM_ENTRY_CTLS_ONE_SETTING
argument_list|,
name|VM_ENTRY_CTLS_ZERO_SETTING
argument_list|,
operator|&
name|entry_ctls
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|vmx_set_ctlreg
argument_list|(
name|MSR_VMX_ENTRY_CTLS
argument_list|,
name|MSR_VMX_TRUE_ENTRY_CTLS
argument_list|,
name|VM_ENTRY_CTLS_ONE_SETTING_NO_PAT
argument_list|,
name|VM_ENTRY_CTLS_ZERO_SETTING
argument_list|,
operator|&
name|entry_ctls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"vmx_init: processor does not support desired "
literal|"entry controls\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Check support for optional features by testing them 	 * as individual bits 	 */
name|cap_halt_exit
operator|=
operator|(
name|vmx_set_ctlreg
argument_list|(
name|MSR_VMX_PROCBASED_CTLS
argument_list|,
name|MSR_VMX_TRUE_PROCBASED_CTLS
argument_list|,
name|PROCBASED_HLT_EXITING
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|cap_monitor_trap
operator|=
operator|(
name|vmx_set_ctlreg
argument_list|(
name|MSR_VMX_PROCBASED_CTLS
argument_list|,
name|MSR_VMX_PROCBASED_CTLS
argument_list|,
name|PROCBASED_MTF
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|cap_pause_exit
operator|=
operator|(
name|vmx_set_ctlreg
argument_list|(
name|MSR_VMX_PROCBASED_CTLS
argument_list|,
name|MSR_VMX_TRUE_PROCBASED_CTLS
argument_list|,
name|PROCBASED_PAUSE_EXITING
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|cap_unrestricted_guest
operator|=
operator|(
name|vmx_set_ctlreg
argument_list|(
name|MSR_VMX_PROCBASED_CTLS2
argument_list|,
name|MSR_VMX_PROCBASED_CTLS2
argument_list|,
name|PROCBASED2_UNRESTRICTED_GUEST
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|cap_invpcid
operator|=
operator|(
name|vmx_set_ctlreg
argument_list|(
name|MSR_VMX_PROCBASED_CTLS2
argument_list|,
name|MSR_VMX_PROCBASED_CTLS2
argument_list|,
name|PROCBASED2_ENABLE_INVPCID
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* Initialize EPT */
name|error
operator|=
name|ept_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"vmx_init: ept initialization failed (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Stash the cr0 and cr4 bits that must be fixed to 0 or 1 	 */
name|fixed0
operator|=
name|rdmsr
argument_list|(
name|MSR_VMX_CR0_FIXED0
argument_list|)
expr_stmt|;
name|fixed1
operator|=
name|rdmsr
argument_list|(
name|MSR_VMX_CR0_FIXED1
argument_list|)
expr_stmt|;
name|cr0_ones_mask
operator|=
name|fixed0
operator|&
name|fixed1
expr_stmt|;
name|cr0_zeros_mask
operator|=
operator|~
name|fixed0
operator|&
operator|~
name|fixed1
expr_stmt|;
comment|/* 	 * CR0_PE and CR0_PG can be set to zero in VMX non-root operation 	 * if unrestricted guest execution is allowed. 	 */
if|if
condition|(
name|cap_unrestricted_guest
condition|)
name|cr0_ones_mask
operator|&=
operator|~
operator|(
name|CR0_PG
operator||
name|CR0_PE
operator|)
expr_stmt|;
comment|/* 	 * Do not allow the guest to set CR0_NW or CR0_CD. 	 */
name|cr0_zeros_mask
operator||=
operator|(
name|CR0_NW
operator||
name|CR0_CD
operator|)
expr_stmt|;
name|fixed0
operator|=
name|rdmsr
argument_list|(
name|MSR_VMX_CR4_FIXED0
argument_list|)
expr_stmt|;
name|fixed1
operator|=
name|rdmsr
argument_list|(
name|MSR_VMX_CR4_FIXED1
argument_list|)
expr_stmt|;
name|cr4_ones_mask
operator|=
name|fixed0
operator|&
name|fixed1
expr_stmt|;
name|cr4_zeros_mask
operator|=
operator|~
name|fixed0
operator|&
operator|~
name|fixed1
expr_stmt|;
name|vpid_init
argument_list|()
expr_stmt|;
comment|/* enable VMX operation */
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|vmx_enable
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vmx_initialized
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_setup_cr_shadow
parameter_list|(
name|int
name|which
parameter_list|,
name|struct
name|vmcs
modifier|*
name|vmcs
parameter_list|,
name|uint32_t
name|initial
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|mask_ident
decl_stmt|,
name|shadow_ident
decl_stmt|;
name|uint64_t
name|mask_value
decl_stmt|;
if|if
condition|(
name|which
operator|!=
literal|0
operator|&&
name|which
operator|!=
literal|4
condition|)
name|panic
argument_list|(
literal|"vmx_setup_cr_shadow: unknown cr%d"
argument_list|,
name|which
argument_list|)
expr_stmt|;
if|if
condition|(
name|which
operator|==
literal|0
condition|)
block|{
name|mask_ident
operator|=
name|VMCS_CR0_MASK
expr_stmt|;
name|mask_value
operator|=
name|cr0_ones_mask
operator||
name|cr0_zeros_mask
expr_stmt|;
name|shadow_ident
operator|=
name|VMCS_CR0_SHADOW
expr_stmt|;
block|}
else|else
block|{
name|mask_ident
operator|=
name|VMCS_CR4_MASK
expr_stmt|;
name|mask_value
operator|=
name|cr4_ones_mask
operator||
name|cr4_zeros_mask
expr_stmt|;
name|shadow_ident
operator|=
name|VMCS_CR4_SHADOW
expr_stmt|;
block|}
name|error
operator|=
name|vmcs_setreg
argument_list|(
name|vmcs
argument_list|,
literal|0
argument_list|,
name|VMCS_IDENT
argument_list|(
name|mask_ident
argument_list|)
argument_list|,
name|mask_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|vmcs_setreg
argument_list|(
name|vmcs
argument_list|,
literal|0
argument_list|,
name|VMCS_IDENT
argument_list|(
name|shadow_ident
argument_list|)
argument_list|,
name|initial
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|vmx_setup_cr0_shadow
parameter_list|(
name|vmcs
parameter_list|,
name|init
parameter_list|)
value|vmx_setup_cr_shadow(0, (vmcs), (init))
end_define

begin_define
define|#
directive|define
name|vmx_setup_cr4_shadow
parameter_list|(
name|vmcs
parameter_list|,
name|init
parameter_list|)
value|vmx_setup_cr_shadow(4, (vmcs), (init))
end_define

begin_function
specifier|static
name|void
modifier|*
name|vmx_vminit
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|pmap_t
name|pmap
parameter_list|)
block|{
name|uint16_t
name|vpid
index|[
name|VM_MAXCPU
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|guest_msr_count
decl_stmt|;
name|struct
name|vmx
modifier|*
name|vmx
decl_stmt|;
name|vmx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vmx
argument_list|)
argument_list|,
name|M_VMX
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|vmx
operator|&
name|PAGE_MASK
condition|)
block|{
name|panic
argument_list|(
literal|"malloc of struct vmx not aligned on %d byte boundary"
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
name|vmx
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|vmx
operator|->
name|eptp
operator|=
name|eptp
argument_list|(
name|vtophys
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_pml4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up EPTP-tagged guest physical and combined mappings 	 * 	 * VMX transitions are not required to invalidate any guest physical 	 * mappings. So, it may be possible for stale guest physical mappings 	 * to be present in the processor TLBs. 	 * 	 * Combined mappings for this EP4TA are also invalidated for all VPIDs. 	 */
name|ept_invalidate_mappings
argument_list|(
name|vmx
operator|->
name|eptp
argument_list|)
expr_stmt|;
name|msr_bitmap_initialize
argument_list|(
name|vmx
operator|->
name|msr_bitmap
argument_list|)
expr_stmt|;
comment|/* 	 * It is safe to allow direct access to MSR_GSBASE and MSR_FSBASE. 	 * The guest FSBASE and GSBASE are saved and restored during 	 * vm-exit and vm-entry respectively. The host FSBASE and GSBASE are 	 * always restored from the vmcs host state area on vm-exit. 	 * 	 * The SYSENTER_CS/ESP/EIP MSRs are identical to FS/GSBASE in 	 * how they are saved/restored so can be directly accessed by the 	 * guest. 	 * 	 * Guest KGSBASE is saved and restored in the guest MSR save area. 	 * Host KGSBASE is restored before returning to userland from the pcb. 	 * There will be a window of time when we are executing in the host 	 * kernel context with a value of KGSBASE from the guest. This is ok 	 * because the value of KGSBASE is inconsequential in kernel context. 	 * 	 * MSR_EFER is saved and restored in the guest VMCS area on a 	 * VM exit and entry respectively. It is also restored from the 	 * host VMCS area on a VM exit. 	 */
if|if
condition|(
name|guest_msr_rw
argument_list|(
name|vmx
argument_list|,
name|MSR_GSBASE
argument_list|)
operator|||
name|guest_msr_rw
argument_list|(
name|vmx
argument_list|,
name|MSR_FSBASE
argument_list|)
operator|||
name|guest_msr_rw
argument_list|(
name|vmx
argument_list|,
name|MSR_SYSENTER_CS_MSR
argument_list|)
operator|||
name|guest_msr_rw
argument_list|(
name|vmx
argument_list|,
name|MSR_SYSENTER_ESP_MSR
argument_list|)
operator|||
name|guest_msr_rw
argument_list|(
name|vmx
argument_list|,
name|MSR_SYSENTER_EIP_MSR
argument_list|)
operator|||
name|guest_msr_rw
argument_list|(
name|vmx
argument_list|,
name|MSR_KGSBASE
argument_list|)
operator|||
name|guest_msr_rw
argument_list|(
name|vmx
argument_list|,
name|MSR_EFER
argument_list|)
condition|)
name|panic
argument_list|(
literal|"vmx_vminit: error setting guest msr access"
argument_list|)
expr_stmt|;
comment|/* 	 * MSR_PAT is saved and restored in the guest VMCS are on a VM exit 	 * and entry respectively. It is also restored from the host VMCS 	 * area on a VM exit. However, if running on a system with no 	 * MSR_PAT save/restore support, leave access disabled so accesses 	 * will be trapped. 	 */
if|if
condition|(
operator|!
name|vmx_no_patmsr
operator|&&
name|guest_msr_rw
argument_list|(
name|vmx
argument_list|,
name|MSR_PAT
argument_list|)
condition|)
name|panic
argument_list|(
literal|"vmx_vminit: error setting guest pat msr access"
argument_list|)
expr_stmt|;
name|vpid_alloc
argument_list|(
name|vpid
argument_list|,
name|VM_MAXCPU
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VM_MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|vmx
operator|->
name|vmcs
index|[
name|i
index|]
operator|.
name|identifier
operator|=
name|vmx_revision
argument_list|()
expr_stmt|;
name|error
operator|=
name|vmclear
argument_list|(
operator|&
name|vmx
operator|->
name|vmcs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"vmx_vminit: vmclear error %d on vcpu %d\n"
argument_list|,
name|error
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|vmcs_set_defaults
argument_list|(
operator|&
name|vmx
operator|->
name|vmcs
index|[
name|i
index|]
argument_list|,
operator|(
name|u_long
operator|)
name|vmx_exit_guest
argument_list|,
operator|(
name|u_long
operator|)
operator|&
name|vmx
operator|->
name|ctx
index|[
name|i
index|]
argument_list|,
name|vmx
operator|->
name|eptp
argument_list|,
name|pinbased_ctls
argument_list|,
name|procbased_ctls
argument_list|,
name|procbased_ctls2
argument_list|,
name|exit_ctls
argument_list|,
name|entry_ctls
argument_list|,
name|vtophys
argument_list|(
name|vmx
operator|->
name|msr_bitmap
argument_list|)
argument_list|,
name|vpid
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"vmx_vminit: vmcs_set_defaults error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vmx
operator|->
name|cap
index|[
name|i
index|]
operator|.
name|set
operator|=
literal|0
expr_stmt|;
name|vmx
operator|->
name|cap
index|[
name|i
index|]
operator|.
name|proc_ctls
operator|=
name|procbased_ctls
expr_stmt|;
name|vmx
operator|->
name|cap
index|[
name|i
index|]
operator|.
name|proc_ctls2
operator|=
name|procbased_ctls2
expr_stmt|;
name|vmx
operator|->
name|state
index|[
name|i
index|]
operator|.
name|lastcpu
operator|=
operator|-
literal|1
expr_stmt|;
name|vmx
operator|->
name|state
index|[
name|i
index|]
operator|.
name|vpid
operator|=
name|vpid
index|[
name|i
index|]
expr_stmt|;
name|msr_save_area_init
argument_list|(
name|vmx
operator|->
name|guest_msrs
index|[
name|i
index|]
argument_list|,
operator|&
name|guest_msr_count
argument_list|)
expr_stmt|;
name|error
operator|=
name|vmcs_set_msr_save
argument_list|(
operator|&
name|vmx
operator|->
name|vmcs
index|[
name|i
index|]
argument_list|,
name|vtophys
argument_list|(
name|vmx
operator|->
name|guest_msrs
index|[
name|i
index|]
argument_list|)
argument_list|,
name|guest_msr_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"vmcs_set_msr_save error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 		 * Set up the CR0/4 shadows, and init the read shadow 		 * to the power-on register value from the Intel Sys Arch. 		 *  CR0 - 0x60000010 		 *  CR4 - 0 		 */
name|error
operator|=
name|vmx_setup_cr0_shadow
argument_list|(
operator|&
name|vmx
operator|->
name|vmcs
index|[
name|i
index|]
argument_list|,
literal|0x60000010
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"vmx_setup_cr0_shadow %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|vmx_setup_cr4_shadow
argument_list|(
operator|&
name|vmx
operator|->
name|vmcs
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"vmx_setup_cr4_shadow %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vmx
operator|->
name|ctx
index|[
name|i
index|]
operator|.
name|pmap
operator|=
name|pmap
expr_stmt|;
name|vmx
operator|->
name|ctx
index|[
name|i
index|]
operator|.
name|eptp
operator|=
name|vmx
operator|->
name|eptp
expr_stmt|;
block|}
return|return
operator|(
name|vmx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_handle_cpuid
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vmxctx
modifier|*
name|vmxctx
parameter_list|)
block|{
name|int
name|handled
decl_stmt|,
name|func
decl_stmt|;
name|func
operator|=
name|vmxctx
operator|->
name|guest_rax
expr_stmt|;
name|handled
operator|=
name|x86_emulate_cpuid
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|&
name|vmxctx
operator|->
name|guest_rax
operator|)
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|&
name|vmxctx
operator|->
name|guest_rbx
operator|)
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|&
name|vmxctx
operator|->
name|guest_rcx
operator|)
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|&
name|vmxctx
operator|->
name|guest_rdx
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|handled
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|vmx_run_trace
parameter_list|(
name|struct
name|vmx
modifier|*
name|vmx
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|KTR
name|VCPU_CTR1
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Resume execution at %#lx"
argument_list|,
name|vmcs_guest_rip
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|vmx_exit_trace
parameter_list|(
name|struct
name|vmx
modifier|*
name|vmx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|uint64_t
name|rip
parameter_list|,
name|uint32_t
name|exit_reason
parameter_list|,
name|int
name|handled
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|KTR
name|VCPU_CTR3
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"%s %s vmexit at 0x%0lx"
argument_list|,
name|handled
condition|?
literal|"handled"
else|:
literal|"unhandled"
argument_list|,
name|exit_reason_to_str
argument_list|(
name|exit_reason
argument_list|)
argument_list|,
name|rip
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|vmx_astpending_trace
parameter_list|(
name|struct
name|vmx
modifier|*
name|vmx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|uint64_t
name|rip
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|KTR
name|VCPU_CTR1
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"astpending vmexit at 0x%0lx"
argument_list|,
name|rip
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|vmx_set_pcpu_defaults
parameter_list|(
name|struct
name|vmx
modifier|*
name|vmx
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|int
name|lastcpu
decl_stmt|;
name|struct
name|vmxstate
modifier|*
name|vmxstate
decl_stmt|;
name|struct
name|invvpid_desc
name|invvpid_desc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|vmxstate
operator|=
operator|&
name|vmx
operator|->
name|state
index|[
name|vcpu
index|]
expr_stmt|;
name|lastcpu
operator|=
name|vmxstate
operator|->
name|lastcpu
expr_stmt|;
name|vmxstate
operator|->
name|lastcpu
operator|=
name|curcpu
expr_stmt|;
if|if
condition|(
name|lastcpu
operator|==
name|curcpu
condition|)
return|return;
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VCPU_MIGRATIONS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmcs_write
argument_list|(
name|VMCS_HOST_TR_BASE
argument_list|,
name|vmm_get_host_trbase
argument_list|()
argument_list|)
expr_stmt|;
name|vmcs_write
argument_list|(
name|VMCS_HOST_GDTR_BASE
argument_list|,
name|vmm_get_host_gdtrbase
argument_list|()
argument_list|)
expr_stmt|;
name|vmcs_write
argument_list|(
name|VMCS_HOST_GS_BASE
argument_list|,
name|vmm_get_host_gsbase
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 	 * If we are using VPIDs then invalidate all mappings tagged with 'vpid' 	 * 	 * We do this because this vcpu was executing on a different host 	 * cpu when it last ran. We do not track whether it invalidated 	 * mappings associated with its 'vpid' during that run. So we must 	 * assume that the mappings associated with 'vpid' on 'curcpu' are 	 * stale and invalidate them. 	 * 	 * Note that we incur this penalty only when the scheduler chooses to 	 * move the thread associated with this vcpu between host cpus. 	 * 	 * Note also that this will invalidate mappings tagged with 'vpid' 	 * for "all" EP4TAs. 	 */
if|if
condition|(
name|vmxstate
operator|->
name|vpid
operator|!=
literal|0
condition|)
block|{
name|invvpid_desc
operator|.
name|vpid
operator|=
name|vmxstate
operator|->
name|vpid
expr_stmt|;
name|invvpid
argument_list|(
name|INVVPID_TYPE_SINGLE_CONTEXT
argument_list|,
name|invvpid_desc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * We depend on 'procbased_ctls' to have the Interrupt Window Exiting bit set.  */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
operator|(
name|PROCBASED_CTLS_ONE_SETTING
operator|&
name|PROCBASED_INT_WINDOW_EXITING
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|__inline
name|vmx_set_int_window_exiting
parameter_list|(
name|struct
name|vmx
modifier|*
name|vmx
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|proc_ctls
operator||=
name|PROCBASED_INT_WINDOW_EXITING
expr_stmt|;
name|vmcs_write
argument_list|(
name|VMCS_PRI_PROC_BASED_CTLS
argument_list|,
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|proc_ctls
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__inline
name|vmx_clear_int_window_exiting
parameter_list|(
name|struct
name|vmx
modifier|*
name|vmx
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|proc_ctls
operator|&=
operator|~
name|PROCBASED_INT_WINDOW_EXITING
expr_stmt|;
name|vmcs_write
argument_list|(
name|VMCS_PRI_PROC_BASED_CTLS
argument_list|,
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|proc_ctls
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__inline
name|vmx_set_nmi_window_exiting
parameter_list|(
name|struct
name|vmx
modifier|*
name|vmx
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|proc_ctls
operator||=
name|PROCBASED_NMI_WINDOW_EXITING
expr_stmt|;
name|vmcs_write
argument_list|(
name|VMCS_PRI_PROC_BASED_CTLS
argument_list|,
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|proc_ctls
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__inline
name|vmx_clear_nmi_window_exiting
parameter_list|(
name|struct
name|vmx
modifier|*
name|vmx
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|proc_ctls
operator|&=
operator|~
name|PROCBASED_NMI_WINDOW_EXITING
expr_stmt|;
name|vmcs_write
argument_list|(
name|VMCS_PRI_PROC_BASED_CTLS
argument_list|,
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|proc_ctls
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_inject_nmi
parameter_list|(
name|struct
name|vmx
modifier|*
name|vmx
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|uint64_t
name|info
decl_stmt|,
name|interruptibility
decl_stmt|;
comment|/* Bail out if no NMI requested */
if|if
condition|(
operator|!
name|vm_nmi_pending
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|interruptibility
operator|=
name|vmcs_read
argument_list|(
name|VMCS_GUEST_INTERRUPTIBILITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|interruptibility
operator|&
name|nmi_blocking_bits
condition|)
goto|goto
name|nmiblocked
goto|;
comment|/* 	 * Inject the virtual NMI. The vector must be the NMI IDT entry 	 * or the VMCS entry check will fail. 	 */
name|info
operator|=
name|VMCS_INTERRUPTION_INFO_NMI
operator||
name|VMCS_INTERRUPTION_INFO_VALID
expr_stmt|;
name|info
operator||=
name|IDT_NMI
expr_stmt|;
name|vmcs_write
argument_list|(
name|VMCS_ENTRY_INTR_INFO
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|VCPU_CTR0
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Injecting vNMI"
argument_list|)
expr_stmt|;
comment|/* Clear the request */
name|vm_nmi_clear
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|nmiblocked
label|:
comment|/* 	 * Set the NMI Window Exiting execution control so we can inject 	 * the virtual NMI as soon as blocking condition goes away. 	 */
name|vmx_set_nmi_window_exiting
argument_list|(
name|vmx
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|VCPU_CTR0
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Enabling NMI window exiting"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmx_inject_interrupts
parameter_list|(
name|struct
name|vmx
modifier|*
name|vmx
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|int
name|vector
decl_stmt|;
name|uint64_t
name|info
decl_stmt|,
name|rflags
decl_stmt|,
name|interruptibility
decl_stmt|;
specifier|const
name|int
name|HWINTR_BLOCKED
init|=
name|VMCS_INTERRUPTIBILITY_STI_BLOCKING
operator||
name|VMCS_INTERRUPTIBILITY_MOVSS_BLOCKING
decl_stmt|;
comment|/* 	 * If there is already an interrupt pending then just return. 	 * 	 * This could happen if an interrupt was injected on a prior 	 * VM entry but the actual entry into guest mode was aborted 	 * because of a pending AST. 	 */
name|info
operator|=
name|vmcs_read
argument_list|(
name|VMCS_ENTRY_INTR_INFO
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|&
name|VMCS_INTERRUPTION_INFO_VALID
condition|)
return|return;
comment|/* 	 * NMI injection has priority so deal with those first 	 */
if|if
condition|(
name|vmx_inject_nmi
argument_list|(
name|vmx
argument_list|,
name|vcpu
argument_list|)
condition|)
return|return;
comment|/* Ask the local apic for a vector to inject */
name|vector
operator|=
name|lapic_pending_intr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|vector
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|vector
operator|<
literal|32
operator|||
name|vector
operator|>
literal|255
condition|)
name|panic
argument_list|(
literal|"vmx_inject_interrupts: invalid vector %d\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
comment|/* Check RFLAGS.IF and the interruptibility state of the guest */
name|rflags
operator|=
name|vmcs_read
argument_list|(
name|VMCS_GUEST_RFLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rflags
operator|&
name|PSL_I
operator|)
operator|==
literal|0
condition|)
goto|goto
name|cantinject
goto|;
name|interruptibility
operator|=
name|vmcs_read
argument_list|(
name|VMCS_GUEST_INTERRUPTIBILITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|interruptibility
operator|&
name|HWINTR_BLOCKED
condition|)
goto|goto
name|cantinject
goto|;
comment|/* Inject the interrupt */
name|info
operator|=
name|VMCS_INTERRUPTION_INFO_HW_INTR
operator||
name|VMCS_INTERRUPTION_INFO_VALID
expr_stmt|;
name|info
operator||=
name|vector
expr_stmt|;
name|vmcs_write
argument_list|(
name|VMCS_ENTRY_INTR_INFO
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Update the Local APIC ISR */
name|lapic_intr_accepted
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|vector
argument_list|)
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Injecting hwintr at vector %d"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return;
name|cantinject
label|:
comment|/* 	 * Set the Interrupt Window Exiting execution control so we can inject 	 * the interrupt as soon as blocking condition goes away. 	 */
name|vmx_set_int_window_exiting
argument_list|(
name|vmx
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|VCPU_CTR0
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Enabling interrupt window exiting"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_emulate_cr_access
parameter_list|(
name|struct
name|vmx
modifier|*
name|vmx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|uint64_t
name|exitqual
parameter_list|)
block|{
name|int
name|cr
decl_stmt|,
name|vmcs_guest_cr
decl_stmt|,
name|vmcs_shadow_cr
decl_stmt|;
name|uint64_t
name|crval
decl_stmt|,
name|regval
decl_stmt|,
name|ones_mask
decl_stmt|,
name|zeros_mask
decl_stmt|;
specifier|const
name|struct
name|vmxctx
modifier|*
name|vmxctx
decl_stmt|;
comment|/* We only handle mov to %cr0 or %cr4 at this time */
if|if
condition|(
operator|(
name|exitqual
operator|&
literal|0xf0
operator|)
operator|!=
literal|0x00
condition|)
return|return
operator|(
name|UNHANDLED
operator|)
return|;
name|cr
operator|=
name|exitqual
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|cr
operator|!=
literal|0
operator|&&
name|cr
operator|!=
literal|4
condition|)
return|return
operator|(
name|UNHANDLED
operator|)
return|;
name|vmxctx
operator|=
operator|&
name|vmx
operator|->
name|ctx
index|[
name|vcpu
index|]
expr_stmt|;
comment|/* 	 * We must use vmcs_write() directly here because vmcs_setreg() will 	 * call vmclear(vmcs) as a side-effect which we certainly don't want. 	 */
switch|switch
condition|(
operator|(
name|exitqual
operator|>>
literal|8
operator|)
operator|&
literal|0xf
condition|)
block|{
case|case
literal|0
case|:
name|regval
operator|=
name|vmxctx
operator|->
name|guest_rax
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|regval
operator|=
name|vmxctx
operator|->
name|guest_rcx
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|regval
operator|=
name|vmxctx
operator|->
name|guest_rdx
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|regval
operator|=
name|vmxctx
operator|->
name|guest_rbx
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|regval
operator|=
name|vmcs_read
argument_list|(
name|VMCS_GUEST_RSP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|regval
operator|=
name|vmxctx
operator|->
name|guest_rbp
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|regval
operator|=
name|vmxctx
operator|->
name|guest_rsi
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|regval
operator|=
name|vmxctx
operator|->
name|guest_rdi
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|regval
operator|=
name|vmxctx
operator|->
name|guest_r8
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|regval
operator|=
name|vmxctx
operator|->
name|guest_r9
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|regval
operator|=
name|vmxctx
operator|->
name|guest_r10
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|regval
operator|=
name|vmxctx
operator|->
name|guest_r11
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|regval
operator|=
name|vmxctx
operator|->
name|guest_r12
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|regval
operator|=
name|vmxctx
operator|->
name|guest_r13
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|regval
operator|=
name|vmxctx
operator|->
name|guest_r14
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|regval
operator|=
name|vmxctx
operator|->
name|guest_r15
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cr
operator|==
literal|0
condition|)
block|{
name|ones_mask
operator|=
name|cr0_ones_mask
expr_stmt|;
name|zeros_mask
operator|=
name|cr0_zeros_mask
expr_stmt|;
name|vmcs_guest_cr
operator|=
name|VMCS_GUEST_CR0
expr_stmt|;
name|vmcs_shadow_cr
operator|=
name|VMCS_CR0_SHADOW
expr_stmt|;
block|}
else|else
block|{
name|ones_mask
operator|=
name|cr4_ones_mask
expr_stmt|;
name|zeros_mask
operator|=
name|cr4_zeros_mask
expr_stmt|;
name|vmcs_guest_cr
operator|=
name|VMCS_GUEST_CR4
expr_stmt|;
name|vmcs_shadow_cr
operator|=
name|VMCS_CR4_SHADOW
expr_stmt|;
block|}
name|vmcs_write
argument_list|(
name|vmcs_shadow_cr
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|crval
operator|=
name|regval
operator||
name|ones_mask
expr_stmt|;
name|crval
operator|&=
operator|~
name|zeros_mask
expr_stmt|;
name|vmcs_write
argument_list|(
name|vmcs_guest_cr
argument_list|,
name|crval
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|==
literal|0
operator|&&
name|regval
operator|&
name|CR0_PG
condition|)
block|{
name|uint64_t
name|efer
decl_stmt|,
name|entry_ctls
decl_stmt|;
comment|/* 		 * If CR0.PG is 1 and EFER.LME is 1 then EFER.LMA and 		 * the "IA-32e mode guest" bit in VM-entry control must be 		 * equal. 		 */
name|efer
operator|=
name|vmcs_read
argument_list|(
name|VMCS_GUEST_IA32_EFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|efer
operator|&
name|EFER_LME
condition|)
block|{
name|efer
operator||=
name|EFER_LMA
expr_stmt|;
name|vmcs_write
argument_list|(
name|VMCS_GUEST_IA32_EFER
argument_list|,
name|efer
argument_list|)
expr_stmt|;
name|entry_ctls
operator|=
name|vmcs_read
argument_list|(
name|VMCS_ENTRY_CTLS
argument_list|)
expr_stmt|;
name|entry_ctls
operator||=
name|VM_ENTRY_GUEST_LMA
expr_stmt|;
name|vmcs_write
argument_list|(
name|VMCS_ENTRY_CTLS
argument_list|,
name|entry_ctls
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ept_fault_type
parameter_list|(
name|uint64_t
name|ept_qual
parameter_list|)
block|{
name|int
name|fault_type
decl_stmt|;
if|if
condition|(
name|ept_qual
operator|&
name|EPT_VIOLATION_DATA_WRITE
condition|)
name|fault_type
operator|=
name|VM_PROT_WRITE
expr_stmt|;
elseif|else
if|if
condition|(
name|ept_qual
operator|&
name|EPT_VIOLATION_INST_FETCH
condition|)
name|fault_type
operator|=
name|VM_PROT_EXECUTE
expr_stmt|;
else|else
name|fault_type
operator|=
name|VM_PROT_READ
expr_stmt|;
return|return
operator|(
name|fault_type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|ept_emulation_fault
parameter_list|(
name|uint64_t
name|ept_qual
parameter_list|)
block|{
name|int
name|read
decl_stmt|,
name|write
decl_stmt|;
comment|/* EPT fault on an instruction fetch doesn't make sense here */
if|if
condition|(
name|ept_qual
operator|&
name|EPT_VIOLATION_INST_FETCH
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* EPT fault must be a read fault or a write fault */
name|read
operator|=
name|ept_qual
operator|&
name|EPT_VIOLATION_DATA_READ
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|write
operator|=
name|ept_qual
operator|&
name|EPT_VIOLATION_DATA_WRITE
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|read
operator||
name|write
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 	 * The EPT violation must have been caused by accessing a 	 * guest-physical address that is a translation of a guest-linear 	 * address. 	 */
if|if
condition|(
operator|(
name|ept_qual
operator|&
name|EPT_VIOLATION_GLA_VALID
operator|)
operator|==
literal|0
operator|||
operator|(
name|ept_qual
operator|&
name|EPT_VIOLATION_XLAT_VALID
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_exit_process
parameter_list|(
name|struct
name|vmx
modifier|*
name|vmx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_exit
modifier|*
name|vmexit
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|handled
decl_stmt|;
name|struct
name|vmxctx
modifier|*
name|vmxctx
decl_stmt|;
name|uint32_t
name|eax
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|,
name|idtvec_info
decl_stmt|,
name|idtvec_err
decl_stmt|,
name|reason
decl_stmt|;
name|uint64_t
name|qual
decl_stmt|,
name|gpa
decl_stmt|;
name|bool
name|retu
decl_stmt|;
name|handled
operator|=
literal|0
expr_stmt|;
name|vmxctx
operator|=
operator|&
name|vmx
operator|->
name|ctx
index|[
name|vcpu
index|]
expr_stmt|;
name|qual
operator|=
name|vmexit
operator|->
name|u
operator|.
name|vmx
operator|.
name|exit_qualification
expr_stmt|;
name|reason
operator|=
name|vmexit
operator|->
name|u
operator|.
name|vmx
operator|.
name|exit_reason
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_BOGUS
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_COUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * VM exits that could be triggered during event injection on the 	 * previous VM entry need to be handled specially by re-injecting 	 * the event. 	 * 	 * See "Information for VM Exits During Event Delivery" in Intel SDM 	 * for details. 	 */
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|EXIT_REASON_EPT_FAULT
case|:
case|case
name|EXIT_REASON_EPT_MISCONFIG
case|:
case|case
name|EXIT_REASON_APIC
case|:
case|case
name|EXIT_REASON_TASK_SWITCH
case|:
case|case
name|EXIT_REASON_EXCEPTION
case|:
name|idtvec_info
operator|=
name|vmcs_idt_vectoring_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|idtvec_info
operator|&
name|VMCS_IDT_VEC_VALID
condition|)
block|{
name|idtvec_info
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|12
operator|)
expr_stmt|;
comment|/* clear undefined bit */
name|vmcs_write
argument_list|(
name|VMCS_ENTRY_INTR_INFO
argument_list|,
name|idtvec_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|idtvec_info
operator|&
name|VMCS_IDT_VEC_ERRCODE_VALID
condition|)
block|{
name|idtvec_err
operator|=
name|vmcs_idt_vectoring_err
argument_list|()
expr_stmt|;
name|vmcs_write
argument_list|(
name|VMCS_ENTRY_EXCEPTION_ERROR
argument_list|,
name|idtvec_err
argument_list|)
expr_stmt|;
block|}
name|vmcs_write
argument_list|(
name|VMCS_ENTRY_INST_LENGTH
argument_list|,
name|vmexit
operator|->
name|inst_length
argument_list|)
expr_stmt|;
block|}
default|default:
break|break;
block|}
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|EXIT_REASON_CR_ACCESS
case|:
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_CR_ACCESS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|handled
operator|=
name|vmx_emulate_cr_access
argument_list|(
name|vmx
argument_list|,
name|vcpu
argument_list|,
name|qual
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXIT_REASON_RDMSR
case|:
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_RDMSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|retu
operator|=
name|false
expr_stmt|;
name|ecx
operator|=
name|vmxctx
operator|->
name|guest_rcx
expr_stmt|;
name|error
operator|=
name|emulate_rdmsr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|ecx
argument_list|,
operator|&
name|retu
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_RDMSR
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|msr
operator|.
name|code
operator|=
name|ecx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|retu
condition|)
block|{
name|handled
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Return to userspace with a valid exitcode */
name|KASSERT
argument_list|(
name|vmexit
operator|->
name|exitcode
operator|!=
name|VM_EXITCODE_BOGUS
argument_list|,
operator|(
literal|"emulate_wrmsr retu with bogus exitcode"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EXIT_REASON_WRMSR
case|:
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_WRMSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|retu
operator|=
name|false
expr_stmt|;
name|eax
operator|=
name|vmxctx
operator|->
name|guest_rax
expr_stmt|;
name|ecx
operator|=
name|vmxctx
operator|->
name|guest_rcx
expr_stmt|;
name|edx
operator|=
name|vmxctx
operator|->
name|guest_rdx
expr_stmt|;
name|error
operator|=
name|emulate_wrmsr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|ecx
argument_list|,
operator|(
name|uint64_t
operator|)
name|edx
operator|<<
literal|32
operator||
name|eax
argument_list|,
operator|&
name|retu
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_WRMSR
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|msr
operator|.
name|code
operator|=
name|ecx
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|msr
operator|.
name|wval
operator|=
operator|(
name|uint64_t
operator|)
name|edx
operator|<<
literal|32
operator||
name|eax
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|retu
condition|)
block|{
name|handled
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Return to userspace with a valid exitcode */
name|KASSERT
argument_list|(
name|vmexit
operator|->
name|exitcode
operator|!=
name|VM_EXITCODE_BOGUS
argument_list|,
operator|(
literal|"emulate_wrmsr retu with bogus exitcode"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EXIT_REASON_HLT
case|:
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_HLT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_HLT
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|hlt
operator|.
name|rflags
operator|=
name|vmcs_read
argument_list|(
name|VMCS_GUEST_RFLAGS
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXIT_REASON_MTF
case|:
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_MTRAP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_MTRAP
expr_stmt|;
break|break;
case|case
name|EXIT_REASON_PAUSE
case|:
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_PAUSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_PAUSE
expr_stmt|;
break|break;
case|case
name|EXIT_REASON_INTR_WINDOW
case|:
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_INTR_WINDOW
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmx_clear_int_window_exiting
argument_list|(
name|vmx
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|VCPU_CTR0
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Disabling interrupt window exiting"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|EXIT_REASON_EXT_INTR
case|:
comment|/* 		 * External interrupts serve only to cause VM exits and allow 		 * the host interrupt handler to run. 		 * 		 * If this external interrupt triggers a virtual interrupt 		 * to a VM, then that state will be recorded by the 		 * host interrupt handler in the VM's softc. We will inject 		 * this virtual interrupt during the subsequent VM enter. 		 */
comment|/* 		 * This is special. We want to treat this as an 'handled' 		 * VM-exit but not increment the instruction pointer. 		 */
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_EXTINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|EXIT_REASON_NMI_WINDOW
case|:
comment|/* Exit to allow the pending virtual NMI to be injected */
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_NMI_WINDOW
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmx_clear_nmi_window_exiting
argument_list|(
name|vmx
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|VCPU_CTR0
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Disabling NMI window exiting"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|EXIT_REASON_INOUT
case|:
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_INOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_INOUT
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|bytes
operator|=
operator|(
name|qual
operator|&
literal|0x7
operator|)
operator|+
literal|1
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|in
operator|=
operator|(
name|qual
operator|&
literal|0x8
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|string
operator|=
operator|(
name|qual
operator|&
literal|0x10
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|rep
operator|=
operator|(
name|qual
operator|&
literal|0x20
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|port
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|qual
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|eax
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|vmxctx
operator|->
name|guest_rax
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXIT_REASON_CPUID
case|:
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_CPUID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|handled
operator|=
name|vmx_handle_cpuid
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|vmxctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXIT_REASON_EPT_FAULT
case|:
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_EPT_FAULT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * If 'gpa' lies within the address space allocated to 		 * memory then this must be a nested page fault otherwise 		 * this must be an instruction that accesses MMIO space. 		 */
name|gpa
operator|=
name|vmcs_gpa
argument_list|()
expr_stmt|;
if|if
condition|(
name|vm_mem_allocated
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|gpa
argument_list|)
condition|)
block|{
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_PAGING
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|paging
operator|.
name|gpa
operator|=
name|gpa
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|paging
operator|.
name|fault_type
operator|=
name|ept_fault_type
argument_list|(
name|qual
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ept_emulation_fault
argument_list|(
name|qual
argument_list|)
condition|)
block|{
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_INST_EMUL
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|gpa
operator|=
name|gpa
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|gla
operator|=
name|vmcs_gla
argument_list|()
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|cr3
operator|=
name|vmcs_guest_cr3
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_UNKNOWN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|handled
condition|)
block|{
comment|/* 		 * It is possible that control is returned to userland 		 * even though we were able to handle the VM exit in the 		 * kernel. 		 * 		 * In such a case we want to make sure that the userland 		 * restarts guest execution at the instruction *after* 		 * the one we just processed. Therefore we update the 		 * guest rip in the VMCS and in 'vmexit'. 		 */
name|vmexit
operator|->
name|rip
operator|+=
name|vmexit
operator|->
name|inst_length
expr_stmt|;
name|vmexit
operator|->
name|inst_length
operator|=
literal|0
expr_stmt|;
name|vmcs_write
argument_list|(
name|VMCS_GUEST_RIP
argument_list|,
name|vmexit
operator|->
name|rip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vmexit
operator|->
name|exitcode
operator|==
name|VM_EXITCODE_BOGUS
condition|)
block|{
comment|/* 			 * If this VM exit was not claimed by anybody then 			 * treat it as a generic VMX exit. 			 */
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_VMX
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|vmx
operator|.
name|status
operator|=
name|VM_SUCCESS
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The exitcode and collateral have been populated. 			 * The VM exit will be processed further in userland. 			 */
block|}
block|}
return|return
operator|(
name|handled
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|vmx_exit_astpending
parameter_list|(
name|struct
name|vmx
modifier|*
name|vmx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_exit
modifier|*
name|vmexit
parameter_list|)
block|{
name|vmexit
operator|->
name|rip
operator|=
name|vmcs_guest_rip
argument_list|()
expr_stmt|;
name|vmexit
operator|->
name|inst_length
operator|=
literal|0
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_BOGUS
expr_stmt|;
name|vmx_astpending_trace
argument_list|(
name|vmx
argument_list|,
name|vcpu
argument_list|,
name|vmexit
operator|->
name|rip
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_ASTPENDING
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|vmx_exit_inst_error
parameter_list|(
name|struct
name|vmxctx
modifier|*
name|vmxctx
parameter_list|,
name|int
name|rc
parameter_list|,
name|struct
name|vm_exit
modifier|*
name|vmexit
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|vmxctx
operator|->
name|inst_fail_status
operator|!=
name|VM_SUCCESS
argument_list|,
operator|(
literal|"vmx_exit_inst_error: invalid inst_fail_status %d"
operator|,
name|vmxctx
operator|->
name|inst_fail_status
operator|)
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|inst_length
operator|=
literal|0
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_VMX
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|vmx
operator|.
name|status
operator|=
name|vmxctx
operator|->
name|inst_fail_status
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|vmx
operator|.
name|inst_error
operator|=
name|vmcs_instruction_error
argument_list|()
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|vmx
operator|.
name|exit_reason
operator|=
operator|~
literal|0
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|vmx
operator|.
name|exit_qualification
operator|=
operator|~
literal|0
expr_stmt|;
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|VMX_VMRESUME_ERROR
case|:
case|case
name|VMX_VMLAUNCH_ERROR
case|:
case|case
name|VMX_INVEPT_ERROR
case|:
name|vmexit
operator|->
name|u
operator|.
name|vmx
operator|.
name|inst_type
operator|=
name|rc
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"vm_exit_inst_error: vmx_enter_guest returned %d"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|UNHANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_run
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|register_t
name|startrip
parameter_list|,
name|pmap_t
name|pmap
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|handled
decl_stmt|,
name|launched
decl_stmt|;
name|struct
name|vmx
modifier|*
name|vmx
decl_stmt|;
name|struct
name|vmxctx
modifier|*
name|vmxctx
decl_stmt|;
name|struct
name|vmcs
modifier|*
name|vmcs
decl_stmt|;
name|struct
name|vm_exit
modifier|*
name|vmexit
decl_stmt|;
name|uint64_t
name|rip
decl_stmt|;
name|uint32_t
name|exit_reason
decl_stmt|;
name|vmx
operator|=
name|arg
expr_stmt|;
name|vmcs
operator|=
operator|&
name|vmx
operator|->
name|vmcs
index|[
name|vcpu
index|]
expr_stmt|;
name|vmxctx
operator|=
operator|&
name|vmx
operator|->
name|ctx
index|[
name|vcpu
index|]
expr_stmt|;
name|vmexit
operator|=
name|vm_exitinfo
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|launched
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
name|vmxctx
operator|->
name|pmap
operator|==
name|pmap
argument_list|,
operator|(
literal|"pmap %p different than ctx pmap %p"
operator|,
name|pmap
operator|,
name|vmxctx
operator|->
name|pmap
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vmxctx
operator|->
name|eptp
operator|==
name|vmx
operator|->
name|eptp
argument_list|,
operator|(
literal|"eptp %p different than ctx eptp %#lx"
operator|,
name|eptp
operator|,
name|vmxctx
operator|->
name|eptp
operator|)
argument_list|)
expr_stmt|;
name|VMPTRLD
argument_list|(
name|vmcs
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * We do this every time because we may setup the virtual machine 	 * from a different process than the one that actually runs it. 	 * 	 * If the life of a virtual machine was spent entirely in the context 	 * of a single process we could do this once in vmcs_set_defaults(). 	 */
name|vmcs_write
argument_list|(
name|VMCS_HOST_CR3
argument_list|,
name|rcr3
argument_list|()
argument_list|)
expr_stmt|;
name|vmcs_write
argument_list|(
name|VMCS_GUEST_RIP
argument_list|,
name|startrip
argument_list|)
expr_stmt|;
name|vmx_set_pcpu_defaults
argument_list|(
name|vmx
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* 		 * Interrupts are disabled from this point on until the 		 * guest starts executing. This is done for the following 		 * reasons: 		 * 		 * If an AST is asserted on this thread after the check below, 		 * then the IPI_AST notification will not be lost, because it 		 * will cause a VM exit due to external interrupt as soon as 		 * the guest state is loaded. 		 * 		 * A posted interrupt after 'vmx_inject_interrupts()' will 		 * not be "lost" because it will be held pending in the host 		 * APIC because interrupts are disabled. The pending interrupt 		 * will be recognized as soon as the guest state is loaded. 		 * 		 * The same reasoning applies to the IPI generated by 		 * pmap_invalidate_ept(). 		 */
name|disable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|curthread
operator|->
name|td_flags
operator|&
operator|(
name|TDF_ASTPENDING
operator||
name|TDF_NEEDRESCHED
operator|)
condition|)
block|{
name|enable_intr
argument_list|()
expr_stmt|;
name|handled
operator|=
name|vmx_exit_astpending
argument_list|(
name|vmx
argument_list|,
name|vcpu
argument_list|,
name|vmexit
argument_list|)
expr_stmt|;
break|break;
block|}
name|vmx_inject_interrupts
argument_list|(
name|vmx
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|vmx_run_trace
argument_list|(
name|vmx
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|rc
operator|=
name|vmx_enter_guest
argument_list|(
name|vmxctx
argument_list|,
name|launched
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
comment|/* Collect some information for VM exit processing */
name|vmexit
operator|->
name|rip
operator|=
name|rip
operator|=
name|vmcs_guest_rip
argument_list|()
expr_stmt|;
name|vmexit
operator|->
name|inst_length
operator|=
name|vmexit_instruction_length
argument_list|()
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|vmx
operator|.
name|exit_reason
operator|=
name|exit_reason
operator|=
name|vmcs_exit_reason
argument_list|()
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|vmx
operator|.
name|exit_qualification
operator|=
name|vmcs_exit_qualification
argument_list|()
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|VMX_GUEST_VMEXIT
condition|)
block|{
name|launched
operator|=
literal|1
expr_stmt|;
name|handled
operator|=
name|vmx_exit_process
argument_list|(
name|vmx
argument_list|,
name|vcpu
argument_list|,
name|vmexit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|handled
operator|=
name|vmx_exit_inst_error
argument_list|(
name|vmxctx
argument_list|,
name|rc
argument_list|,
name|vmexit
argument_list|)
expr_stmt|;
block|}
name|vmx_exit_trace
argument_list|(
name|vmx
argument_list|,
name|vcpu
argument_list|,
name|rip
argument_list|,
name|exit_reason
argument_list|,
name|handled
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|handled
condition|)
do|;
comment|/* 	 * If a VM exit has been handled then the exitcode must be BOGUS 	 * If a VM exit is not handled then the exitcode must not be BOGUS 	 */
if|if
condition|(
operator|(
name|handled
operator|&&
name|vmexit
operator|->
name|exitcode
operator|!=
name|VM_EXITCODE_BOGUS
operator|)
operator|||
operator|(
operator|!
name|handled
operator|&&
name|vmexit
operator|->
name|exitcode
operator|==
name|VM_EXITCODE_BOGUS
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"Mismatch between handled (%d) and exitcode (%d)"
argument_list|,
name|handled
argument_list|,
name|vmexit
operator|->
name|exitcode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|handled
condition|)
name|vmm_stat_incr
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_USERSPACE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"returning from vmx_run: exitcode %d"
argument_list|,
name|vmexit
operator|->
name|exitcode
argument_list|)
expr_stmt|;
name|VMCLEAR
argument_list|(
name|vmcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmx_vmcleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|vmx
modifier|*
name|vmx
init|=
name|arg
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VM_MAXCPU
condition|;
name|i
operator|++
control|)
name|vpid_free
argument_list|(
name|vmx
operator|->
name|state
index|[
name|i
index|]
operator|.
name|vpid
argument_list|)
expr_stmt|;
comment|/* 	 * XXXSMP we also need to clear the VMCS active on the other vcpus. 	 */
name|error
operator|=
name|vmclear
argument_list|(
operator|&
name|vmx
operator|->
name|vmcs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"vmx_vmcleanup: vmclear error %d on vcpu 0"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vmx
argument_list|,
name|M_VMX
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|register_t
modifier|*
name|vmxctx_regptr
parameter_list|(
name|struct
name|vmxctx
modifier|*
name|vmxctx
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|VM_REG_GUEST_RAX
case|:
return|return
operator|(
operator|&
name|vmxctx
operator|->
name|guest_rax
operator|)
return|;
case|case
name|VM_REG_GUEST_RBX
case|:
return|return
operator|(
operator|&
name|vmxctx
operator|->
name|guest_rbx
operator|)
return|;
case|case
name|VM_REG_GUEST_RCX
case|:
return|return
operator|(
operator|&
name|vmxctx
operator|->
name|guest_rcx
operator|)
return|;
case|case
name|VM_REG_GUEST_RDX
case|:
return|return
operator|(
operator|&
name|vmxctx
operator|->
name|guest_rdx
operator|)
return|;
case|case
name|VM_REG_GUEST_RSI
case|:
return|return
operator|(
operator|&
name|vmxctx
operator|->
name|guest_rsi
operator|)
return|;
case|case
name|VM_REG_GUEST_RDI
case|:
return|return
operator|(
operator|&
name|vmxctx
operator|->
name|guest_rdi
operator|)
return|;
case|case
name|VM_REG_GUEST_RBP
case|:
return|return
operator|(
operator|&
name|vmxctx
operator|->
name|guest_rbp
operator|)
return|;
case|case
name|VM_REG_GUEST_R8
case|:
return|return
operator|(
operator|&
name|vmxctx
operator|->
name|guest_r8
operator|)
return|;
case|case
name|VM_REG_GUEST_R9
case|:
return|return
operator|(
operator|&
name|vmxctx
operator|->
name|guest_r9
operator|)
return|;
case|case
name|VM_REG_GUEST_R10
case|:
return|return
operator|(
operator|&
name|vmxctx
operator|->
name|guest_r10
operator|)
return|;
case|case
name|VM_REG_GUEST_R11
case|:
return|return
operator|(
operator|&
name|vmxctx
operator|->
name|guest_r11
operator|)
return|;
case|case
name|VM_REG_GUEST_R12
case|:
return|return
operator|(
operator|&
name|vmxctx
operator|->
name|guest_r12
operator|)
return|;
case|case
name|VM_REG_GUEST_R13
case|:
return|return
operator|(
operator|&
name|vmxctx
operator|->
name|guest_r13
operator|)
return|;
case|case
name|VM_REG_GUEST_R14
case|:
return|return
operator|(
operator|&
name|vmxctx
operator|->
name|guest_r14
operator|)
return|;
case|case
name|VM_REG_GUEST_R15
case|:
return|return
operator|(
operator|&
name|vmxctx
operator|->
name|guest_r15
operator|)
return|;
default|default:
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmxctx_getreg
parameter_list|(
name|struct
name|vmxctx
modifier|*
name|vmxctx
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint64_t
modifier|*
name|retval
parameter_list|)
block|{
name|register_t
modifier|*
name|regp
decl_stmt|;
if|if
condition|(
operator|(
name|regp
operator|=
name|vmxctx_regptr
argument_list|(
name|vmxctx
argument_list|,
name|reg
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|retval
operator|=
operator|*
name|regp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmxctx_setreg
parameter_list|(
name|struct
name|vmxctx
modifier|*
name|vmxctx
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|register_t
modifier|*
name|regp
decl_stmt|;
if|if
condition|(
operator|(
name|regp
operator|=
name|vmxctx_regptr
argument_list|(
name|vmxctx
argument_list|,
name|reg
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|regp
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_shadow_reg
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
name|int
name|shreg
decl_stmt|;
name|shreg
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|VM_REG_GUEST_CR0
case|:
name|shreg
operator|=
name|VMCS_CR0_SHADOW
expr_stmt|;
break|break;
case|case
name|VM_REG_GUEST_CR4
case|:
name|shreg
operator|=
name|VMCS_CR4_SHADOW
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|shreg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_getreg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint64_t
modifier|*
name|retval
parameter_list|)
block|{
name|int
name|running
decl_stmt|,
name|hostcpu
decl_stmt|;
name|struct
name|vmx
modifier|*
name|vmx
init|=
name|arg
decl_stmt|;
name|running
operator|=
name|vcpu_is_running
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
operator|&
name|hostcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|running
operator|&&
name|hostcpu
operator|!=
name|curcpu
condition|)
name|panic
argument_list|(
literal|"vmx_getreg: %s%d is running"
argument_list|,
name|vm_name
argument_list|(
name|vmx
operator|->
name|vm
argument_list|)
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmxctx_getreg
argument_list|(
operator|&
name|vmx
operator|->
name|ctx
index|[
name|vcpu
index|]
argument_list|,
name|reg
argument_list|,
name|retval
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|vmcs_getreg
argument_list|(
operator|&
name|vmx
operator|->
name|vmcs
index|[
name|vcpu
index|]
argument_list|,
name|running
argument_list|,
name|reg
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_setreg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|hostcpu
decl_stmt|,
name|running
decl_stmt|,
name|shadow
decl_stmt|;
name|uint64_t
name|ctls
decl_stmt|;
name|struct
name|vmx
modifier|*
name|vmx
init|=
name|arg
decl_stmt|;
name|running
operator|=
name|vcpu_is_running
argument_list|(
name|vmx
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
operator|&
name|hostcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|running
operator|&&
name|hostcpu
operator|!=
name|curcpu
condition|)
name|panic
argument_list|(
literal|"vmx_setreg: %s%d is running"
argument_list|,
name|vm_name
argument_list|(
name|vmx
operator|->
name|vm
argument_list|)
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmxctx_setreg
argument_list|(
operator|&
name|vmx
operator|->
name|ctx
index|[
name|vcpu
index|]
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|vmcs_setreg
argument_list|(
operator|&
name|vmx
operator|->
name|vmcs
index|[
name|vcpu
index|]
argument_list|,
name|running
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If the "load EFER" VM-entry control is 1 then the 		 * value of EFER.LMA must be identical to "IA-32e mode guest" 		 * bit in the VM-entry control. 		 */
if|if
condition|(
operator|(
name|entry_ctls
operator|&
name|VM_ENTRY_LOAD_EFER
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|reg
operator|==
name|VM_REG_GUEST_EFER
operator|)
condition|)
block|{
name|vmcs_getreg
argument_list|(
operator|&
name|vmx
operator|->
name|vmcs
index|[
name|vcpu
index|]
argument_list|,
name|running
argument_list|,
name|VMCS_IDENT
argument_list|(
name|VMCS_ENTRY_CTLS
argument_list|)
argument_list|,
operator|&
name|ctls
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|EFER_LMA
condition|)
name|ctls
operator||=
name|VM_ENTRY_GUEST_LMA
expr_stmt|;
else|else
name|ctls
operator|&=
operator|~
name|VM_ENTRY_GUEST_LMA
expr_stmt|;
name|vmcs_setreg
argument_list|(
operator|&
name|vmx
operator|->
name|vmcs
index|[
name|vcpu
index|]
argument_list|,
name|running
argument_list|,
name|VMCS_IDENT
argument_list|(
name|VMCS_ENTRY_CTLS
argument_list|)
argument_list|,
name|ctls
argument_list|)
expr_stmt|;
block|}
name|shadow
operator|=
name|vmx_shadow_reg
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadow
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Store the unmodified value in the shadow 			 */
name|error
operator|=
name|vmcs_setreg
argument_list|(
operator|&
name|vmx
operator|->
name|vmcs
index|[
name|vcpu
index|]
argument_list|,
name|running
argument_list|,
name|VMCS_IDENT
argument_list|(
name|shadow
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_getdesc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|seg_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|vmx
modifier|*
name|vmx
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|vmcs_getdesc
argument_list|(
operator|&
name|vmx
operator|->
name|vmcs
index|[
name|vcpu
index|]
argument_list|,
name|reg
argument_list|,
name|desc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_setdesc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|seg_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|vmx
modifier|*
name|vmx
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|vmcs_setdesc
argument_list|(
operator|&
name|vmx
operator|->
name|vmcs
index|[
name|vcpu
index|]
argument_list|,
name|reg
argument_list|,
name|desc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_inject
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|vector
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|int
name|code_valid
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
name|info
decl_stmt|;
name|struct
name|vmx
modifier|*
name|vmx
init|=
name|arg
decl_stmt|;
name|struct
name|vmcs
modifier|*
name|vmcs
init|=
operator|&
name|vmx
operator|->
name|vmcs
index|[
name|vcpu
index|]
decl_stmt|;
specifier|static
name|uint32_t
name|type_map
index|[
name|VM_EVENT_MAX
index|]
init|=
block|{
literal|0x1
block|,
comment|/* VM_EVENT_NONE */
literal|0x0
block|,
comment|/* VM_HW_INTR */
literal|0x2
block|,
comment|/* VM_NMI */
literal|0x3
block|,
comment|/* VM_HW_EXCEPTION */
literal|0x4
block|,
comment|/* VM_SW_INTR */
literal|0x5
block|,
comment|/* VM_PRIV_SW_EXCEPTION */
literal|0x6
block|,
comment|/* VM_SW_EXCEPTION */
block|}
decl_stmt|;
comment|/* 	 * If there is already an exception pending to be delivered to the 	 * vcpu then just return. 	 */
name|error
operator|=
name|vmcs_getreg
argument_list|(
name|vmcs
argument_list|,
literal|0
argument_list|,
name|VMCS_IDENT
argument_list|(
name|VMCS_ENTRY_INTR_INFO
argument_list|)
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|info
operator|&
name|VMCS_INTERRUPTION_INFO_VALID
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
name|info
operator|=
name|vector
operator||
operator|(
name|type_map
index|[
name|type
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|code_valid
condition|?
literal|1
operator|<<
literal|11
else|:
literal|0
operator|)
expr_stmt|;
name|info
operator||=
name|VMCS_INTERRUPTION_INFO_VALID
expr_stmt|;
name|error
operator|=
name|vmcs_setreg
argument_list|(
name|vmcs
argument_list|,
literal|0
argument_list|,
name|VMCS_IDENT
argument_list|(
name|VMCS_ENTRY_INTR_INFO
argument_list|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|code_valid
condition|)
block|{
name|error
operator|=
name|vmcs_setreg
argument_list|(
name|vmcs
argument_list|,
literal|0
argument_list|,
name|VMCS_IDENT
argument_list|(
name|VMCS_ENTRY_EXCEPTION_ERROR
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_getcap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|struct
name|vmx
modifier|*
name|vmx
init|=
name|arg
decl_stmt|;
name|int
name|vcap
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|ENOENT
expr_stmt|;
name|vcap
operator|=
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|set
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|VM_CAP_HALT_EXIT
case|:
if|if
condition|(
name|cap_halt_exit
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VM_CAP_PAUSE_EXIT
case|:
if|if
condition|(
name|cap_pause_exit
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VM_CAP_MTRAP_EXIT
case|:
if|if
condition|(
name|cap_monitor_trap
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VM_CAP_UNRESTRICTED_GUEST
case|:
if|if
condition|(
name|cap_unrestricted_guest
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VM_CAP_ENABLE_INVPCID
case|:
if|if
condition|(
name|cap_invpcid
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
operator|*
name|retval
operator|=
operator|(
name|vcap
operator|&
operator|(
literal|1
operator|<<
name|type
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmx_setcap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|vmx
modifier|*
name|vmx
init|=
name|arg
decl_stmt|;
name|struct
name|vmcs
modifier|*
name|vmcs
init|=
operator|&
name|vmx
operator|->
name|vmcs
index|[
name|vcpu
index|]
decl_stmt|;
name|uint32_t
name|baseval
decl_stmt|;
name|uint32_t
modifier|*
name|pptr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|ENOENT
expr_stmt|;
name|pptr
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|VM_CAP_HALT_EXIT
case|:
if|if
condition|(
name|cap_halt_exit
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|pptr
operator|=
operator|&
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|proc_ctls
expr_stmt|;
name|baseval
operator|=
operator|*
name|pptr
expr_stmt|;
name|flag
operator|=
name|PROCBASED_HLT_EXITING
expr_stmt|;
name|reg
operator|=
name|VMCS_PRI_PROC_BASED_CTLS
expr_stmt|;
block|}
break|break;
case|case
name|VM_CAP_MTRAP_EXIT
case|:
if|if
condition|(
name|cap_monitor_trap
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|pptr
operator|=
operator|&
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|proc_ctls
expr_stmt|;
name|baseval
operator|=
operator|*
name|pptr
expr_stmt|;
name|flag
operator|=
name|PROCBASED_MTF
expr_stmt|;
name|reg
operator|=
name|VMCS_PRI_PROC_BASED_CTLS
expr_stmt|;
block|}
break|break;
case|case
name|VM_CAP_PAUSE_EXIT
case|:
if|if
condition|(
name|cap_pause_exit
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|pptr
operator|=
operator|&
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|proc_ctls
expr_stmt|;
name|baseval
operator|=
operator|*
name|pptr
expr_stmt|;
name|flag
operator|=
name|PROCBASED_PAUSE_EXITING
expr_stmt|;
name|reg
operator|=
name|VMCS_PRI_PROC_BASED_CTLS
expr_stmt|;
block|}
break|break;
case|case
name|VM_CAP_UNRESTRICTED_GUEST
case|:
if|if
condition|(
name|cap_unrestricted_guest
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|pptr
operator|=
operator|&
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|proc_ctls2
expr_stmt|;
name|baseval
operator|=
operator|*
name|pptr
expr_stmt|;
name|flag
operator|=
name|PROCBASED2_UNRESTRICTED_GUEST
expr_stmt|;
name|reg
operator|=
name|VMCS_SEC_PROC_BASED_CTLS
expr_stmt|;
block|}
break|break;
case|case
name|VM_CAP_ENABLE_INVPCID
case|:
if|if
condition|(
name|cap_invpcid
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|pptr
operator|=
operator|&
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|proc_ctls2
expr_stmt|;
name|baseval
operator|=
operator|*
name|pptr
expr_stmt|;
name|flag
operator|=
name|PROCBASED2_ENABLE_INVPCID
expr_stmt|;
name|reg
operator|=
name|VMCS_SEC_PROC_BASED_CTLS
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
condition|)
block|{
name|baseval
operator||=
name|flag
expr_stmt|;
block|}
else|else
block|{
name|baseval
operator|&=
operator|~
name|flag
expr_stmt|;
block|}
name|VMPTRLD
argument_list|(
name|vmcs
argument_list|)
expr_stmt|;
name|error
operator|=
name|vmwrite
argument_list|(
name|reg
argument_list|,
name|baseval
argument_list|)
expr_stmt|;
name|VMCLEAR
argument_list|(
name|vmcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|retval
operator|=
name|error
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Update optional stored flags, and record 			 * setting 			 */
if|if
condition|(
name|pptr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|pptr
operator|=
name|baseval
expr_stmt|;
block|}
if|if
condition|(
name|val
condition|)
block|{
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|set
operator||=
operator|(
literal|1
operator|<<
name|type
operator|)
expr_stmt|;
block|}
else|else
block|{
name|vmx
operator|->
name|cap
index|[
name|vcpu
index|]
operator|.
name|set
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|type
operator|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|vmm_ops
name|vmm_ops_intel
init|=
block|{
name|vmx_init
block|,
name|vmx_cleanup
block|,
name|vmx_restore
block|,
name|vmx_vminit
block|,
name|vmx_run
block|,
name|vmx_vmcleanup
block|,
name|vmx_getreg
block|,
name|vmx_setreg
block|,
name|vmx_getdesc
block|,
name|vmx_setdesc
block|,
name|vmx_inject
block|,
name|vmx_getcap
block|,
name|vmx_setcap
block|,
name|ept_vmspace_alloc
block|,
name|ept_vmspace_free
block|, }
decl_stmt|;
end_decl_stmt

end_unit

