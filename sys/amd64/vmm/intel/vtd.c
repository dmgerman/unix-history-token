begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 NetApp, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|"io/iommu.h"
end_include

begin_comment
comment|/*  * Documented in the "Intel Virtualization Technology for Directed I/O",  * Architecture Spec, September 2008.  */
end_comment

begin_comment
comment|/* Section 10.4 "Register Descriptions" */
end_comment

begin_struct
struct|struct
name|vtdmap
block|{
specifier|volatile
name|uint32_t
name|version
decl_stmt|;
specifier|volatile
name|uint32_t
name|res0
decl_stmt|;
specifier|volatile
name|uint64_t
name|cap
decl_stmt|;
specifier|volatile
name|uint64_t
name|ext_cap
decl_stmt|;
specifier|volatile
name|uint32_t
name|gcr
decl_stmt|;
specifier|volatile
name|uint32_t
name|gsr
decl_stmt|;
specifier|volatile
name|uint64_t
name|rta
decl_stmt|;
specifier|volatile
name|uint64_t
name|ccr
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|VTD_CAP_SAGAW
parameter_list|(
name|cap
parameter_list|)
value|(((cap)>> 8)& 0x1F)
end_define

begin_define
define|#
directive|define
name|VTD_CAP_ND
parameter_list|(
name|cap
parameter_list|)
value|((cap)& 0x7)
end_define

begin_define
define|#
directive|define
name|VTD_CAP_CM
parameter_list|(
name|cap
parameter_list|)
value|(((cap)>> 7)& 0x1)
end_define

begin_define
define|#
directive|define
name|VTD_CAP_SPS
parameter_list|(
name|cap
parameter_list|)
value|(((cap)>> 34)& 0xF)
end_define

begin_define
define|#
directive|define
name|VTD_CAP_RWBF
parameter_list|(
name|cap
parameter_list|)
value|(((cap)>> 4)& 0x1)
end_define

begin_define
define|#
directive|define
name|VTD_ECAP_DI
parameter_list|(
name|ecap
parameter_list|)
value|(((ecap)>> 2)& 0x1)
end_define

begin_define
define|#
directive|define
name|VTD_ECAP_COHERENCY
parameter_list|(
name|ecap
parameter_list|)
value|((ecap)& 0x1)
end_define

begin_define
define|#
directive|define
name|VTD_ECAP_IRO
parameter_list|(
name|ecap
parameter_list|)
value|(((ecap)>> 8)& 0x3FF)
end_define

begin_define
define|#
directive|define
name|VTD_GCR_WBF
value|(1<< 27)
end_define

begin_define
define|#
directive|define
name|VTD_GCR_SRTP
value|(1<< 30)
end_define

begin_define
define|#
directive|define
name|VTD_GCR_TE
value|(1<< 31)
end_define

begin_define
define|#
directive|define
name|VTD_GSR_WBFS
value|(1<< 27)
end_define

begin_define
define|#
directive|define
name|VTD_GSR_RTPS
value|(1<< 30)
end_define

begin_define
define|#
directive|define
name|VTD_GSR_TES
value|(1<< 31)
end_define

begin_define
define|#
directive|define
name|VTD_CCR_ICC
value|(1UL<< 63)
end_define

begin_comment
comment|/* invalidate context cache */
end_comment

begin_define
define|#
directive|define
name|VTD_CCR_CIRG_GLOBAL
value|(1UL<< 61)
end_define

begin_comment
comment|/* global invalidation */
end_comment

begin_define
define|#
directive|define
name|VTD_IIR_IVT
value|(1UL<< 63)
end_define

begin_comment
comment|/* invalidation IOTLB */
end_comment

begin_define
define|#
directive|define
name|VTD_IIR_IIRG_GLOBAL
value|(1ULL<< 60)
end_define

begin_comment
comment|/* global IOTLB invalidation */
end_comment

begin_define
define|#
directive|define
name|VTD_IIR_IIRG_DOMAIN
value|(2ULL<< 60)
end_define

begin_comment
comment|/* domain IOTLB invalidation */
end_comment

begin_define
define|#
directive|define
name|VTD_IIR_IIRG_PAGE
value|(3ULL<< 60)
end_define

begin_comment
comment|/* page IOTLB invalidation */
end_comment

begin_define
define|#
directive|define
name|VTD_IIR_DRAIN_READS
value|(1ULL<< 49)
end_define

begin_comment
comment|/* drain pending DMA reads */
end_comment

begin_define
define|#
directive|define
name|VTD_IIR_DRAIN_WRITES
value|(1ULL<< 48)
end_define

begin_comment
comment|/* drain pending DMA writes */
end_comment

begin_define
define|#
directive|define
name|VTD_IIR_DOMAIN_P
value|32
end_define

begin_define
define|#
directive|define
name|VTD_ROOT_PRESENT
value|0x1
end_define

begin_define
define|#
directive|define
name|VTD_CTX_PRESENT
value|0x1
end_define

begin_define
define|#
directive|define
name|VTD_CTX_TT_ALL
value|(1UL<< 2)
end_define

begin_define
define|#
directive|define
name|VTD_PTE_RD
value|(1UL<< 0)
end_define

begin_define
define|#
directive|define
name|VTD_PTE_WR
value|(1UL<< 1)
end_define

begin_define
define|#
directive|define
name|VTD_PTE_SUPERPAGE
value|(1UL<< 7)
end_define

begin_define
define|#
directive|define
name|VTD_PTE_ADDR_M
value|(0x000FFFFFFFFFF000UL)
end_define

begin_struct
struct|struct
name|domain
block|{
name|uint64_t
modifier|*
name|ptp
decl_stmt|;
comment|/* first level page table page */
name|int
name|pt_levels
decl_stmt|;
comment|/* number of page table levels */
name|int
name|addrwidth
decl_stmt|;
comment|/* 'AW' field in context entry */
name|int
name|spsmask
decl_stmt|;
comment|/* supported super page sizes */
name|u_int
name|id
decl_stmt|;
comment|/* domain id */
name|vm_paddr_t
name|maxaddr
decl_stmt|;
comment|/* highest address to be mapped */
name|SLIST_ENTRY
argument_list|(
argument|domain
argument_list|)
name|next
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|domain
argument_list|)
name|domhead
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DRHD_MAX_UNITS
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|drhd_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vtdmap
modifier|*
name|vtdmaps
index|[
name|DRHD_MAX_UNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_domains
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|drhd_ident_func_t
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|uint64_t
name|root_table
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
index|]
name|__aligned
argument_list|(
literal|4096
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|ctx_tables
index|[
literal|256
index|]
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
index|]
name|__aligned
argument_list|(
literal|4096
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VTD
argument_list|,
literal|"vtd"
argument_list|,
literal|"vtd"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|vtd_max_domains
parameter_list|(
name|struct
name|vtdmap
modifier|*
name|vtdmap
parameter_list|)
block|{
name|int
name|nd
decl_stmt|;
name|nd
operator|=
name|VTD_CAP_ND
argument_list|(
name|vtdmap
operator|->
name|cap
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nd
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
literal|16
operator|)
return|;
case|case
literal|1
case|:
return|return
operator|(
literal|64
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
literal|256
operator|)
return|;
case|case
literal|3
case|:
return|return
operator|(
literal|1024
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
literal|4
operator|*
literal|1024
operator|)
return|;
case|case
literal|5
case|:
return|return
operator|(
literal|16
operator|*
literal|1024
operator|)
return|;
case|case
literal|6
case|:
return|return
operator|(
literal|64
operator|*
literal|1024
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"vtd_max_domains: invalid value of nd (0x%0x)"
argument_list|,
name|nd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int
name|domain_id
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|id
decl_stmt|;
name|struct
name|domain
modifier|*
name|dom
decl_stmt|;
comment|/* Skip domain id 0 - it is reserved when Caching Mode field is set */
for|for
control|(
name|id
operator|=
literal|1
init|;
name|id
operator|<
name|max_domains
condition|;
name|id
operator|++
control|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|dom
argument_list|,
argument|&domhead
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|dom
operator|->
name|id
operator|==
name|id
condition|)
break|break;
block|}
if|if
condition|(
name|dom
operator|==
name|NULL
condition|)
break|break;
comment|/* found it */
block|}
if|if
condition|(
name|id
operator|>=
name|max_domains
condition|)
name|panic
argument_list|(
literal|"domain ids exhausted"
argument_list|)
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtd_wbflush
parameter_list|(
name|struct
name|vtdmap
modifier|*
name|vtdmap
parameter_list|)
block|{
if|if
condition|(
name|VTD_ECAP_COHERENCY
argument_list|(
name|vtdmap
operator|->
name|ext_cap
argument_list|)
operator|==
literal|0
condition|)
name|pmap_invalidate_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|VTD_CAP_RWBF
argument_list|(
name|vtdmap
operator|->
name|cap
argument_list|)
condition|)
block|{
name|vtdmap
operator|->
name|gcr
operator|=
name|VTD_GCR_WBF
expr_stmt|;
while|while
condition|(
operator|(
name|vtdmap
operator|->
name|gsr
operator|&
name|VTD_GSR_WBFS
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtd_ctx_global_invalidate
parameter_list|(
name|struct
name|vtdmap
modifier|*
name|vtdmap
parameter_list|)
block|{
name|vtdmap
operator|->
name|ccr
operator|=
name|VTD_CCR_ICC
operator||
name|VTD_CCR_CIRG_GLOBAL
expr_stmt|;
while|while
condition|(
operator|(
name|vtdmap
operator|->
name|ccr
operator|&
name|VTD_CCR_ICC
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtd_iotlb_global_invalidate
parameter_list|(
name|struct
name|vtdmap
modifier|*
name|vtdmap
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
specifier|volatile
name|uint64_t
modifier|*
name|iotlb_reg
decl_stmt|,
name|val
decl_stmt|;
name|vtd_wbflush
argument_list|(
name|vtdmap
argument_list|)
expr_stmt|;
name|offset
operator|=
name|VTD_ECAP_IRO
argument_list|(
name|vtdmap
operator|->
name|ext_cap
argument_list|)
operator|*
literal|16
expr_stmt|;
name|iotlb_reg
operator|=
operator|(
specifier|volatile
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|vtdmap
operator|+
name|offset
operator|+
literal|8
operator|)
expr_stmt|;
operator|*
name|iotlb_reg
operator|=
name|VTD_IIR_IVT
operator||
name|VTD_IIR_IIRG_GLOBAL
operator||
name|VTD_IIR_DRAIN_READS
operator||
name|VTD_IIR_DRAIN_WRITES
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|val
operator|=
operator|*
name|iotlb_reg
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|VTD_IIR_IVT
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtd_translation_enable
parameter_list|(
name|struct
name|vtdmap
modifier|*
name|vtdmap
parameter_list|)
block|{
name|vtdmap
operator|->
name|gcr
operator|=
name|VTD_GCR_TE
expr_stmt|;
while|while
condition|(
operator|(
name|vtdmap
operator|->
name|gsr
operator|&
name|VTD_GSR_TES
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtd_translation_disable
parameter_list|(
name|struct
name|vtdmap
modifier|*
name|vtdmap
parameter_list|)
block|{
name|vtdmap
operator|->
name|gcr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|vtdmap
operator|->
name|gsr
operator|&
name|VTD_GSR_TES
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtd_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|units
decl_stmt|,
name|remaining
decl_stmt|;
name|struct
name|vtdmap
modifier|*
name|vtdmap
decl_stmt|;
name|vm_paddr_t
name|ctx_paddr
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|,
name|envname
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|long
name|mapaddr
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|ACPI_TABLE_DMAR
modifier|*
name|dmar
decl_stmt|;
name|ACPI_DMAR_HEADER
modifier|*
name|hdr
decl_stmt|;
name|ACPI_DMAR_HARDWARE_UNIT
modifier|*
name|drhd
decl_stmt|;
comment|/* 	 * Allow the user to override the ACPI DMAR table by specifying the 	 * physical address of each remapping unit. 	 * 	 * The following example specifies two remapping units at 	 * physical addresses 0xfed90000 and 0xfeda0000 respectively. 	 * set vtd.regmap.0.addr=0xfed90000 	 * set vtd.regmap.1.addr=0xfeda0000 	 */
for|for
control|(
name|units
operator|=
literal|0
init|;
name|units
operator|<
name|DRHD_MAX_UNITS
condition|;
name|units
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|envname
argument_list|,
sizeof|sizeof
argument_list|(
name|envname
argument_list|)
argument_list|,
literal|"vtd.regmap.%d.addr"
argument_list|,
name|units
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv_ulong
argument_list|(
name|envname
argument_list|,
operator|&
name|mapaddr
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|vtdmaps
index|[
name|units
index|]
operator|=
operator|(
expr|struct
name|vtdmap
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|mapaddr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|units
operator|>
literal|0
condition|)
goto|goto
name|skip_dmar
goto|;
comment|/* Search for DMAR table. */
name|status
operator|=
name|AcpiGetTable
argument_list|(
name|ACPI_SIG_DMAR
argument_list|,
literal|0
argument_list|,
operator|(
name|ACPI_TABLE_HEADER
operator|*
operator|*
operator|)
operator|&
name|dmar
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|dmar
operator|+
name|dmar
operator|->
name|Header
operator|.
name|Length
expr_stmt|;
name|remaining
operator|=
name|dmar
operator|->
name|Header
operator|.
name|Length
operator|-
sizeof|sizeof
argument_list|(
name|ACPI_TABLE_DMAR
argument_list|)
expr_stmt|;
while|while
condition|(
name|remaining
operator|>
sizeof|sizeof
argument_list|(
name|ACPI_DMAR_HEADER
argument_list|)
condition|)
block|{
name|hdr
operator|=
operator|(
name|ACPI_DMAR_HEADER
operator|*
operator|)
operator|(
name|end
operator|-
name|remaining
operator|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|Length
operator|>
name|remaining
condition|)
break|break;
comment|/* 		 * From Intel VT-d arch spec, version 1.3: 		 * BIOS implementations must report mapping structures 		 * in numerical order, i.e. All remapping structures of 		 * type 0 (DRHD) enumerated before remapping structures of 		 * type 1 (RMRR) and so forth. 		 */
if|if
condition|(
name|hdr
operator|->
name|Type
operator|!=
name|ACPI_DMAR_TYPE_HARDWARE_UNIT
condition|)
break|break;
name|drhd
operator|=
operator|(
name|ACPI_DMAR_HARDWARE_UNIT
operator|*
operator|)
name|hdr
expr_stmt|;
name|vtdmaps
index|[
name|units
operator|++
index|]
operator|=
operator|(
expr|struct
name|vtdmap
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|drhd
operator|->
name|Address
argument_list|)
expr_stmt|;
if|if
condition|(
name|units
operator|>=
name|DRHD_MAX_UNITS
condition|)
break|break;
name|remaining
operator|-=
name|hdr
operator|->
name|Length
expr_stmt|;
block|}
if|if
condition|(
name|units
operator|<=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|skip_dmar
label|:
name|drhd_num
operator|=
name|units
expr_stmt|;
name|vtdmap
operator|=
name|vtdmaps
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|VTD_CAP_CM
argument_list|(
name|vtdmap
operator|->
name|cap
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"vtd_init: invalid caching mode"
argument_list|)
expr_stmt|;
name|max_domains
operator|=
name|vtd_max_domains
argument_list|(
name|vtdmap
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the root-table to point to the context-entry tables 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|ctx_paddr
operator|=
name|vtophys
argument_list|(
name|ctx_tables
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx_paddr
operator|&
name|PAGE_MASK
condition|)
name|panic
argument_list|(
literal|"ctx table (0x%0lx) not page aligned"
argument_list|,
name|ctx_paddr
argument_list|)
expr_stmt|;
name|root_table
index|[
name|i
operator|*
literal|2
index|]
operator|=
name|ctx_paddr
operator||
name|VTD_ROOT_PRESENT
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtd_cleanup
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|vtd_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|vtdmap
modifier|*
name|vtdmap
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|drhd_num
condition|;
name|i
operator|++
control|)
block|{
name|vtdmap
operator|=
name|vtdmaps
index|[
name|i
index|]
expr_stmt|;
name|vtd_wbflush
argument_list|(
name|vtdmap
argument_list|)
expr_stmt|;
comment|/* Update the root table address */
name|vtdmap
operator|->
name|rta
operator|=
name|vtophys
argument_list|(
name|root_table
argument_list|)
expr_stmt|;
name|vtdmap
operator|->
name|gcr
operator|=
name|VTD_GCR_SRTP
expr_stmt|;
while|while
condition|(
operator|(
name|vtdmap
operator|->
name|gsr
operator|&
name|VTD_GSR_RTPS
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|vtd_ctx_global_invalidate
argument_list|(
name|vtdmap
argument_list|)
expr_stmt|;
name|vtd_iotlb_global_invalidate
argument_list|(
name|vtdmap
argument_list|)
expr_stmt|;
name|vtd_translation_enable
argument_list|(
name|vtdmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtd_disable
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|vtdmap
modifier|*
name|vtdmap
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|drhd_num
condition|;
name|i
operator|++
control|)
block|{
name|vtdmap
operator|=
name|vtdmaps
index|[
name|i
index|]
expr_stmt|;
name|vtd_translation_disable
argument_list|(
name|vtdmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtd_add_device
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|uint64_t
modifier|*
name|ctxp
decl_stmt|;
name|struct
name|domain
modifier|*
name|dom
init|=
name|arg
decl_stmt|;
name|vm_paddr_t
name|pt_paddr
decl_stmt|;
name|struct
name|vtdmap
modifier|*
name|vtdmap
decl_stmt|;
if|if
condition|(
name|bus
operator|<
literal|0
operator|||
name|bus
operator|>
name|PCI_BUSMAX
operator|||
name|slot
operator|<
literal|0
operator|||
name|slot
operator|>
name|PCI_SLOTMAX
operator|||
name|func
operator|<
literal|0
operator|||
name|func
operator|>
name|PCI_FUNCMAX
condition|)
name|panic
argument_list|(
literal|"vtd_add_device: invalid bsf %d/%d/%d"
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|vtdmap
operator|=
name|vtdmaps
index|[
literal|0
index|]
expr_stmt|;
name|ctxp
operator|=
name|ctx_tables
index|[
name|bus
index|]
expr_stmt|;
name|pt_paddr
operator|=
name|vtophys
argument_list|(
name|dom
operator|->
name|ptp
argument_list|)
expr_stmt|;
name|idx
operator|=
operator|(
name|slot
operator|<<
literal|3
operator||
name|func
operator|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|ctxp
index|[
name|idx
index|]
operator|&
name|VTD_CTX_PRESENT
condition|)
block|{
name|panic
argument_list|(
literal|"vtd_add_device: device %d/%d/%d is already owned by "
literal|"domain %d"
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|ctxp
index|[
name|idx
operator|+
literal|1
index|]
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Order is important. The 'present' bit is set only after all fields 	 * of the context pointer are initialized. 	 */
name|ctxp
index|[
name|idx
operator|+
literal|1
index|]
operator|=
name|dom
operator|->
name|addrwidth
operator||
operator|(
name|dom
operator|->
name|id
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|VTD_ECAP_DI
argument_list|(
name|vtdmap
operator|->
name|ext_cap
argument_list|)
condition|)
name|ctxp
index|[
name|idx
index|]
operator|=
name|VTD_CTX_TT_ALL
expr_stmt|;
else|else
name|ctxp
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
name|ctxp
index|[
name|idx
index|]
operator||=
name|pt_paddr
operator||
name|VTD_CTX_PRESENT
expr_stmt|;
comment|/* 	 * 'Not Present' entries are not cached in either the Context Cache 	 * or in the IOTLB, so there is no need to invalidate either of them. 	 */
block|}
end_function

begin_function
specifier|static
name|void
name|vtd_remove_device
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|;
name|uint64_t
modifier|*
name|ctxp
decl_stmt|;
name|struct
name|vtdmap
modifier|*
name|vtdmap
decl_stmt|;
if|if
condition|(
name|bus
operator|<
literal|0
operator|||
name|bus
operator|>
name|PCI_BUSMAX
operator|||
name|slot
operator|<
literal|0
operator|||
name|slot
operator|>
name|PCI_SLOTMAX
operator|||
name|func
operator|<
literal|0
operator|||
name|func
operator|>
name|PCI_FUNCMAX
condition|)
name|panic
argument_list|(
literal|"vtd_add_device: invalid bsf %d/%d/%d"
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|ctxp
operator|=
name|ctx_tables
index|[
name|bus
index|]
expr_stmt|;
name|idx
operator|=
operator|(
name|slot
operator|<<
literal|3
operator||
name|func
operator|)
operator|*
literal|2
expr_stmt|;
comment|/* 	 * Order is important. The 'present' bit is must be cleared first. 	 */
name|ctxp
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
name|ctxp
index|[
name|idx
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Invalidate the Context Cache and the IOTLB. 	 * 	 * XXX use device-selective invalidation for Context Cache 	 * XXX use domain-selective invalidation for IOTLB 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|drhd_num
condition|;
name|i
operator|++
control|)
block|{
name|vtdmap
operator|=
name|vtdmaps
index|[
name|i
index|]
expr_stmt|;
name|vtd_ctx_global_invalidate
argument_list|(
name|vtdmap
argument_list|)
expr_stmt|;
name|vtd_iotlb_global_invalidate
argument_list|(
name|vtdmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|CREATE_MAPPING
value|0
end_define

begin_define
define|#
directive|define
name|REMOVE_MAPPING
value|1
end_define

begin_function
specifier|static
name|uint64_t
name|vtd_update_mapping
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|vm_paddr_t
name|gpa
parameter_list|,
name|vm_paddr_t
name|hpa
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|int
name|remove
parameter_list|)
block|{
name|struct
name|domain
modifier|*
name|dom
decl_stmt|;
name|int
name|i
decl_stmt|,
name|spshift
decl_stmt|,
name|ptpshift
decl_stmt|,
name|ptpindex
decl_stmt|,
name|nlevels
decl_stmt|;
name|uint64_t
name|spsize
decl_stmt|,
modifier|*
name|ptp
decl_stmt|;
name|dom
operator|=
name|arg
expr_stmt|;
name|ptpindex
operator|=
literal|0
expr_stmt|;
name|ptpshift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gpa
operator|&
name|PAGE_MASK
condition|)
name|panic
argument_list|(
literal|"vtd_create_mapping: unaligned gpa 0x%0lx"
argument_list|,
name|gpa
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpa
operator|&
name|PAGE_MASK
condition|)
name|panic
argument_list|(
literal|"vtd_create_mapping: unaligned hpa 0x%0lx"
argument_list|,
name|hpa
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&
name|PAGE_MASK
condition|)
name|panic
argument_list|(
literal|"vtd_create_mapping: unaligned len 0x%0lx"
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the size of the mapping that we can accomodate. 	 * 	 * This is based on three factors: 	 * - supported super page size 	 * - alignment of the region starting at 'gpa' and 'hpa' 	 * - length of the region 'len' 	 */
name|spshift
operator|=
literal|48
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|spsize
operator|=
literal|1UL
operator|<<
name|spshift
expr_stmt|;
if|if
condition|(
operator|(
name|dom
operator|->
name|spsmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|gpa
operator|&
operator|(
name|spsize
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|hpa
operator|&
operator|(
name|spsize
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|len
operator|>=
name|spsize
operator|)
condition|)
block|{
break|break;
block|}
name|spshift
operator|-=
literal|9
expr_stmt|;
block|}
name|ptp
operator|=
name|dom
operator|->
name|ptp
expr_stmt|;
name|nlevels
operator|=
name|dom
operator|->
name|pt_levels
expr_stmt|;
while|while
condition|(
operator|--
name|nlevels
operator|>=
literal|0
condition|)
block|{
name|ptpshift
operator|=
literal|12
operator|+
name|nlevels
operator|*
literal|9
expr_stmt|;
name|ptpindex
operator|=
operator|(
name|gpa
operator|>>
name|ptpshift
operator|)
operator|&
literal|0x1FF
expr_stmt|;
comment|/* We have reached the leaf mapping */
if|if
condition|(
name|spshift
operator|>=
name|ptpshift
condition|)
block|{
break|break;
block|}
comment|/* 		 * We are working on a non-leaf page table page. 		 * 		 * Create a downstream page table page if necessary and point 		 * to it from the current page table. 		 */
if|if
condition|(
name|ptp
index|[
name|ptpindex
index|]
operator|==
literal|0
condition|)
block|{
name|void
modifier|*
name|nlp
init|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_VTD
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
decl_stmt|;
name|ptp
index|[
name|ptpindex
index|]
operator|=
name|vtophys
argument_list|(
name|nlp
argument_list|)
operator||
name|VTD_PTE_RD
operator||
name|VTD_PTE_WR
expr_stmt|;
block|}
name|ptp
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|ptp
index|[
name|ptpindex
index|]
operator|&
name|VTD_PTE_ADDR_M
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|gpa
operator|&
operator|(
operator|(
literal|1UL
operator|<<
name|ptpshift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"gpa 0x%lx and ptpshift %d mismatch"
argument_list|,
name|gpa
argument_list|,
name|ptpshift
argument_list|)
expr_stmt|;
comment|/* 	 * Update the 'gpa' -> 'hpa' mapping 	 */
if|if
condition|(
name|remove
condition|)
block|{
name|ptp
index|[
name|ptpindex
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ptp
index|[
name|ptpindex
index|]
operator|=
name|hpa
operator||
name|VTD_PTE_RD
operator||
name|VTD_PTE_WR
expr_stmt|;
if|if
condition|(
name|nlevels
operator|>
literal|0
condition|)
name|ptp
index|[
name|ptpindex
index|]
operator||=
name|VTD_PTE_SUPERPAGE
expr_stmt|;
block|}
return|return
operator|(
literal|1UL
operator|<<
name|ptpshift
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|vtd_create_mapping
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|vm_paddr_t
name|gpa
parameter_list|,
name|vm_paddr_t
name|hpa
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
return|return
operator|(
name|vtd_update_mapping
argument_list|(
name|arg
argument_list|,
name|gpa
argument_list|,
name|hpa
argument_list|,
name|len
argument_list|,
name|CREATE_MAPPING
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|vtd_remove_mapping
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|vm_paddr_t
name|gpa
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
return|return
operator|(
name|vtd_update_mapping
argument_list|(
name|arg
argument_list|,
name|gpa
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|REMOVE_MAPPING
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtd_invalidate_tlb
parameter_list|(
name|void
modifier|*
name|dom
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|vtdmap
modifier|*
name|vtdmap
decl_stmt|;
comment|/* 	 * Invalidate the IOTLB. 	 * XXX use domain-selective invalidation for IOTLB 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|drhd_num
condition|;
name|i
operator|++
control|)
block|{
name|vtdmap
operator|=
name|vtdmaps
index|[
name|i
index|]
expr_stmt|;
name|vtd_iotlb_global_invalidate
argument_list|(
name|vtdmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|vtd_create_domain
parameter_list|(
name|vm_paddr_t
name|maxaddr
parameter_list|)
block|{
name|struct
name|domain
modifier|*
name|dom
decl_stmt|;
name|vm_paddr_t
name|addr
decl_stmt|;
name|int
name|tmp
decl_stmt|,
name|i
decl_stmt|,
name|gaw
decl_stmt|,
name|agaw
decl_stmt|,
name|sagaw
decl_stmt|,
name|res
decl_stmt|,
name|pt_levels
decl_stmt|,
name|addrwidth
decl_stmt|;
name|struct
name|vtdmap
modifier|*
name|vtdmap
decl_stmt|;
if|if
condition|(
name|drhd_num
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"vtd_create_domain: no dma remapping hardware available"
argument_list|)
expr_stmt|;
name|vtdmap
operator|=
name|vtdmaps
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Calculate AGAW. 	 * Section 3.4.2 "Adjusted Guest Address Width", Architecture Spec. 	 */
name|addr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|gaw
operator|=
literal|0
init|;
name|addr
operator|<
name|maxaddr
condition|;
name|gaw
operator|++
control|)
name|addr
operator|=
literal|1ULL
operator|<<
name|gaw
expr_stmt|;
name|res
operator|=
operator|(
name|gaw
operator|-
literal|12
operator|)
operator|%
literal|9
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
name|agaw
operator|=
name|gaw
expr_stmt|;
else|else
name|agaw
operator|=
name|gaw
operator|+
literal|9
operator|-
name|res
expr_stmt|;
if|if
condition|(
name|agaw
operator|>
literal|64
condition|)
name|agaw
operator|=
literal|64
expr_stmt|;
comment|/* 	 * Select the smallest Supported AGAW and the corresponding number 	 * of page table levels. 	 */
name|pt_levels
operator|=
literal|2
expr_stmt|;
name|sagaw
operator|=
literal|30
expr_stmt|;
name|addrwidth
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|VTD_CAP_SAGAW
argument_list|(
name|vtdmap
operator|->
name|cap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|tmp
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|sagaw
operator|>=
name|agaw
condition|)
break|break;
name|pt_levels
operator|++
expr_stmt|;
name|addrwidth
operator|++
expr_stmt|;
name|sagaw
operator|+=
literal|9
expr_stmt|;
if|if
condition|(
name|sagaw
operator|>
literal|64
condition|)
name|sagaw
operator|=
literal|64
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
literal|5
condition|)
block|{
name|panic
argument_list|(
literal|"vtd_create_domain: SAGAW 0x%lx does not support AGAW %d"
argument_list|,
name|VTD_CAP_SAGAW
argument_list|(
name|vtdmap
operator|->
name|cap
argument_list|)
argument_list|,
name|agaw
argument_list|)
expr_stmt|;
block|}
name|dom
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|domain
argument_list|)
argument_list|,
name|M_VTD
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|dom
operator|->
name|pt_levels
operator|=
name|pt_levels
expr_stmt|;
name|dom
operator|->
name|addrwidth
operator|=
name|addrwidth
expr_stmt|;
name|dom
operator|->
name|id
operator|=
name|domain_id
argument_list|()
expr_stmt|;
name|dom
operator|->
name|maxaddr
operator|=
name|maxaddr
expr_stmt|;
name|dom
operator|->
name|ptp
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_VTD
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|dom
operator|->
name|ptp
operator|&
name|PAGE_MASK
condition|)
name|panic
argument_list|(
literal|"vtd_create_domain: ptp (%p) not page aligned"
argument_list|,
name|dom
operator|->
name|ptp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 * XXX superpage mappings for the iommu do not work correctly. 	 * 	 * By default all physical memory is mapped into the host_domain. 	 * When a VM is allocated wired memory the pages belonging to it 	 * are removed from the host_domain and added to the vm's domain. 	 * 	 * If the page being removed was mapped using a superpage mapping 	 * in the host_domain then we need to demote the mapping before 	 * removing the page. 	 * 	 * There is not any code to deal with the demotion at the moment 	 * so we disable superpage mappings altogether. 	 */
name|dom
operator|->
name|spsmask
operator|=
name|VTD_CAP_SPS
argument_list|(
name|vtdmap
operator|->
name|cap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|domhead
argument_list|,
name|dom
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
name|dom
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtd_free_ptp
parameter_list|(
name|uint64_t
modifier|*
name|ptp
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint64_t
modifier|*
name|nlp
decl_stmt|;
if|if
condition|(
name|level
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|512
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ptp
index|[
name|i
index|]
operator|&
operator|(
name|VTD_PTE_RD
operator||
name|VTD_PTE_WR
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ptp
index|[
name|i
index|]
operator|&
name|VTD_PTE_SUPERPAGE
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|nlp
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|ptp
index|[
name|i
index|]
operator|&
name|VTD_PTE_ADDR_M
argument_list|)
expr_stmt|;
name|vtd_free_ptp
argument_list|(
name|nlp
argument_list|,
name|level
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
name|ptp
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptp
argument_list|,
name|M_VTD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtd_destroy_domain
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|domain
modifier|*
name|dom
decl_stmt|;
name|dom
operator|=
name|arg
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|domhead
argument_list|,
name|dom
argument_list|,
name|domain
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|vtd_free_ptp
argument_list|(
name|dom
operator|->
name|ptp
argument_list|,
name|dom
operator|->
name|pt_levels
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dom
argument_list|,
name|M_VTD
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|iommu_ops
name|iommu_ops_intel
init|=
block|{
name|vtd_init
block|,
name|vtd_cleanup
block|,
name|vtd_enable
block|,
name|vtd_disable
block|,
name|vtd_create_domain
block|,
name|vtd_destroy_domain
block|,
name|vtd_create_mapping
block|,
name|vtd_remove_mapping
block|,
name|vtd_add_device
block|,
name|vtd_remove_device
block|,
name|vtd_invalidate_tlb
block|, }
decl_stmt|;
end_decl_stmt

end_unit

