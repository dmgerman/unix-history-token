begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 Tycho Nightingale<tycho.nightingale@pluribusnetworks.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<x86/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/i8259.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|"vmm_ktr.h"
end_include

begin_include
include|#
directive|include
file|"vmm_lapic.h"
end_include

begin_include
include|#
directive|include
file|"vioapic.h"
end_include

begin_include
include|#
directive|include
file|"vatpic.h"
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VATPIC
argument_list|,
literal|"atpic"
argument_list|,
literal|"bhyve virtual atpic (8259)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|VATPIC_LOCK
parameter_list|(
name|vatpic
parameter_list|)
value|mtx_lock_spin(&((vatpic)->mtx))
end_define

begin_define
define|#
directive|define
name|VATPIC_UNLOCK
parameter_list|(
name|vatpic
parameter_list|)
value|mtx_unlock_spin(&((vatpic)->mtx))
end_define

begin_define
define|#
directive|define
name|VATPIC_LOCKED
parameter_list|(
name|vatpic
parameter_list|)
value|mtx_owned(&((vatpic)->mtx))
end_define

begin_enum
enum|enum
name|irqstate
block|{
name|IRQSTATE_ASSERT
block|,
name|IRQSTATE_DEASSERT
block|,
name|IRQSTATE_PULSE
block|}
enum|;
end_enum

begin_struct
struct|struct
name|atpic
block|{
name|bool
name|ready
decl_stmt|;
name|int
name|icw_num
decl_stmt|;
name|int
name|rd_cmd_reg
decl_stmt|;
name|bool
name|aeoi
decl_stmt|;
name|bool
name|poll
decl_stmt|;
name|bool
name|rotate
decl_stmt|;
name|bool
name|sfn
decl_stmt|;
comment|/* special fully-nested mode */
name|int
name|irq_base
decl_stmt|;
name|uint8_t
name|request
decl_stmt|;
comment|/* Interrupt Request Register (IIR) */
name|uint8_t
name|service
decl_stmt|;
comment|/* Interrupt Service (ISR) */
name|uint8_t
name|mask
decl_stmt|;
comment|/* Interrupt Mask Register (IMR) */
name|int
name|acnt
index|[
literal|8
index|]
decl_stmt|;
comment|/* sum of pin asserts and deasserts */
name|int
name|priority
decl_stmt|;
comment|/* current pin priority */
name|bool
name|intr_raised
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vatpic
block|{
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
name|struct
name|mtx
name|mtx
decl_stmt|;
name|struct
name|atpic
name|atpic
index|[
literal|2
index|]
decl_stmt|;
name|uint8_t
name|elc
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|VATPIC_CTR0
parameter_list|(
name|vatpic
parameter_list|,
name|fmt
parameter_list|)
define|\
value|VM_CTR0((vatpic)->vm, fmt)
end_define

begin_define
define|#
directive|define
name|VATPIC_CTR1
parameter_list|(
name|vatpic
parameter_list|,
name|fmt
parameter_list|,
name|a1
parameter_list|)
define|\
value|VM_CTR1((vatpic)->vm, fmt, a1)
end_define

begin_define
define|#
directive|define
name|VATPIC_CTR2
parameter_list|(
name|vatpic
parameter_list|,
name|fmt
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
define|\
value|VM_CTR2((vatpic)->vm, fmt, a1, a2)
end_define

begin_define
define|#
directive|define
name|VATPIC_CTR3
parameter_list|(
name|vatpic
parameter_list|,
name|fmt
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|)
define|\
value|VM_CTR3((vatpic)->vm, fmt, a1, a2, a3)
end_define

begin_define
define|#
directive|define
name|VATPIC_CTR4
parameter_list|(
name|vatpic
parameter_list|,
name|fmt
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|,
name|a4
parameter_list|)
define|\
value|VM_CTR4((vatpic)->vm, fmt, a1, a2, a3, a4)
end_define

begin_function_decl
specifier|static
name|void
name|vatpic_set_pinstate
parameter_list|(
name|struct
name|vatpic
modifier|*
name|vatpic
parameter_list|,
name|int
name|pin
parameter_list|,
name|bool
name|newstate
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|int
name|vatpic_get_highest_isrpin
parameter_list|(
name|struct
name|atpic
modifier|*
name|atpic
parameter_list|)
block|{
name|int
name|bit
decl_stmt|,
name|pin
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|pin
operator|=
operator|(
operator|(
name|i
operator|+
literal|7
operator|-
name|atpic
operator|->
name|priority
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
name|bit
operator|=
operator|(
literal|1
operator|<<
name|pin
operator|)
expr_stmt|;
if|if
condition|(
name|atpic
operator|->
name|service
operator|&
name|bit
condition|)
return|return
operator|(
name|pin
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|vatpic_get_highest_irrpin
parameter_list|(
name|struct
name|atpic
modifier|*
name|atpic
parameter_list|)
block|{
name|int
name|serviced
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|pin
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * In 'Special Fully-Nested Mode' when an interrupt request from 	 * a slave is in service, the slave is not locked out from the 	 * master's priority logic. 	 */
name|serviced
operator|=
name|atpic
operator|->
name|service
expr_stmt|;
if|if
condition|(
name|atpic
operator|->
name|sfn
condition|)
name|serviced
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|pin
operator|=
operator|(
operator|(
name|i
operator|+
literal|7
operator|-
name|atpic
operator|->
name|priority
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
name|bit
operator|=
operator|(
literal|1
operator|<<
name|pin
operator|)
expr_stmt|;
if|if
condition|(
name|serviced
operator|&
name|bit
condition|)
break|break;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|pin
operator|=
operator|(
operator|(
name|j
operator|+
literal|7
operator|-
name|atpic
operator|->
name|priority
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
name|bit
operator|=
operator|(
literal|1
operator|<<
name|pin
operator|)
expr_stmt|;
if|if
condition|(
name|atpic
operator|->
name|request
operator|&
name|bit
operator|&&
operator|(
operator|~
name|atpic
operator|->
name|mask
operator|&
name|bit
operator|)
condition|)
return|return
operator|(
name|pin
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vatpic_notify_intr
parameter_list|(
name|struct
name|vatpic
modifier|*
name|vatpic
parameter_list|)
block|{
name|struct
name|atpic
modifier|*
name|atpic
decl_stmt|;
name|int
name|pin
decl_stmt|;
name|KASSERT
argument_list|(
name|VATPIC_LOCKED
argument_list|(
name|vatpic
argument_list|)
argument_list|,
operator|(
literal|"vatpic_notify_intr not locked"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * First check the slave. 	 */
name|atpic
operator|=
operator|&
name|vatpic
operator|->
name|atpic
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|atpic
operator|->
name|intr_raised
operator|&&
operator|(
name|pin
operator|=
name|vatpic_get_highest_irrpin
argument_list|(
name|atpic
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|VATPIC_CTR4
argument_list|(
name|vatpic
argument_list|,
literal|"atpic slave notify pin = %d "
literal|"(imr 0x%x irr 0x%x isr 0x%x)"
argument_list|,
name|pin
argument_list|,
name|atpic
operator|->
name|mask
argument_list|,
name|atpic
operator|->
name|request
argument_list|,
name|atpic
operator|->
name|service
argument_list|)
expr_stmt|;
comment|/* 		 * Cascade the request from the slave to the master. 		 */
name|atpic
operator|->
name|intr_raised
operator|=
name|true
expr_stmt|;
name|vatpic_set_pinstate
argument_list|(
name|vatpic
argument_list|,
literal|2
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|vatpic_set_pinstate
argument_list|(
name|vatpic
argument_list|,
literal|2
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VATPIC_CTR3
argument_list|(
name|vatpic
argument_list|,
literal|"atpic slave no eligible interrupts "
literal|"(imr 0x%x irr 0x%x isr 0x%x)"
argument_list|,
name|atpic
operator|->
name|mask
argument_list|,
name|atpic
operator|->
name|request
argument_list|,
name|atpic
operator|->
name|service
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Then check the master. 	 */
name|atpic
operator|=
operator|&
name|vatpic
operator|->
name|atpic
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|atpic
operator|->
name|intr_raised
operator|&&
operator|(
name|pin
operator|=
name|vatpic_get_highest_irrpin
argument_list|(
name|atpic
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|VATPIC_CTR4
argument_list|(
name|vatpic
argument_list|,
literal|"atpic master notify pin = %d "
literal|"(imr 0x%x irr 0x%x isr 0x%x)"
argument_list|,
name|pin
argument_list|,
name|atpic
operator|->
name|mask
argument_list|,
name|atpic
operator|->
name|request
argument_list|,
name|atpic
operator|->
name|service
argument_list|)
expr_stmt|;
comment|/* 		 * From Section 3.6.2, "Interrupt Modes", in the 		 * MPtable Specification, Version 1.4 		 * 		 * PIC interrupts are routed to both the Local APIC 		 * and the I/O APIC to support operation in 1 of 3 		 * modes. 		 * 		 * 1. Legacy PIC Mode: the PIC effectively bypasses 		 * all APIC components.  In this mode the local APIC is 		 * disabled and LINT0 is reconfigured as INTR to 		 * deliver the PIC interrupt directly to the CPU. 		 * 		 * 2. Virtual Wire Mode: the APIC is treated as a 		 * virtual wire which delivers interrupts from the PIC 		 * to the CPU.  In this mode LINT0 is programmed as 		 * ExtINT to indicate that the PIC is the source of 		 * the interrupt. 		 * 		 * 3. Virtual Wire Mode via I/O APIC: PIC interrupts are 		 * fielded by the I/O APIC and delivered to the appropriate 		 * CPU.  In this mode the I/O APIC input 0 is programmed 		 * as ExtINT to indicate that the PIC is the source of the 		 * interrupt. 		 */
name|atpic
operator|->
name|intr_raised
operator|=
name|true
expr_stmt|;
name|lapic_set_local_intr
argument_list|(
name|vatpic
operator|->
name|vm
argument_list|,
operator|-
literal|1
argument_list|,
name|APIC_LVT_LINT0
argument_list|)
expr_stmt|;
name|vioapic_pulse_irq
argument_list|(
name|vatpic
operator|->
name|vm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VATPIC_CTR3
argument_list|(
name|vatpic
argument_list|,
literal|"atpic master no eligible interrupts "
literal|"(imr 0x%x irr 0x%x isr 0x%x)"
argument_list|,
name|atpic
operator|->
name|mask
argument_list|,
name|atpic
operator|->
name|request
argument_list|,
name|atpic
operator|->
name|service
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vatpic_icw1
parameter_list|(
name|struct
name|vatpic
modifier|*
name|vatpic
parameter_list|,
name|struct
name|atpic
modifier|*
name|atpic
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|VATPIC_CTR1
argument_list|(
name|vatpic
argument_list|,
literal|"atpic icw1 0x%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|atpic
operator|->
name|ready
operator|=
name|false
expr_stmt|;
name|atpic
operator|->
name|icw_num
operator|=
literal|1
expr_stmt|;
name|atpic
operator|->
name|mask
operator|=
literal|0
expr_stmt|;
name|atpic
operator|->
name|priority
operator|=
literal|0
expr_stmt|;
name|atpic
operator|->
name|rd_cmd_reg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|ICW1_SNGL
operator|)
operator|!=
literal|0
condition|)
block|{
name|VATPIC_CTR0
argument_list|(
name|vatpic
argument_list|,
literal|"vatpic cascade mode required"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|val
operator|&
name|ICW1_IC4
operator|)
operator|==
literal|0
condition|)
block|{
name|VATPIC_CTR0
argument_list|(
name|vatpic
argument_list|,
literal|"vatpic icw4 required"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|atpic
operator|->
name|icw_num
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vatpic_icw2
parameter_list|(
name|struct
name|vatpic
modifier|*
name|vatpic
parameter_list|,
name|struct
name|atpic
modifier|*
name|atpic
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|VATPIC_CTR1
argument_list|(
name|vatpic
argument_list|,
literal|"atpic icw2 0x%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|atpic
operator|->
name|irq_base
operator|=
name|val
operator|&
literal|0xf8
expr_stmt|;
name|atpic
operator|->
name|icw_num
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vatpic_icw3
parameter_list|(
name|struct
name|vatpic
modifier|*
name|vatpic
parameter_list|,
name|struct
name|atpic
modifier|*
name|atpic
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|VATPIC_CTR1
argument_list|(
name|vatpic
argument_list|,
literal|"atpic icw3 0x%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|atpic
operator|->
name|icw_num
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vatpic_icw4
parameter_list|(
name|struct
name|vatpic
modifier|*
name|vatpic
parameter_list|,
name|struct
name|atpic
modifier|*
name|atpic
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|VATPIC_CTR1
argument_list|(
name|vatpic
argument_list|,
literal|"atpic icw4 0x%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|ICW4_8086
operator|)
operator|==
literal|0
condition|)
block|{
name|VATPIC_CTR0
argument_list|(
name|vatpic
argument_list|,
literal|"vatpic microprocessor mode required"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|val
operator|&
name|ICW4_AEOI
operator|)
operator|!=
literal|0
condition|)
name|atpic
operator|->
name|aeoi
operator|=
name|true
expr_stmt|;
name|atpic
operator|->
name|icw_num
operator|=
literal|0
expr_stmt|;
name|atpic
operator|->
name|ready
operator|=
name|true
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vatpic_ocw1
parameter_list|(
name|struct
name|vatpic
modifier|*
name|vatpic
parameter_list|,
name|struct
name|atpic
modifier|*
name|atpic
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|VATPIC_CTR1
argument_list|(
name|vatpic
argument_list|,
literal|"atpic ocw1 0x%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|atpic
operator|->
name|mask
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vatpic_ocw2
parameter_list|(
name|struct
name|vatpic
modifier|*
name|vatpic
parameter_list|,
name|struct
name|atpic
modifier|*
name|atpic
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|VATPIC_CTR1
argument_list|(
name|vatpic
argument_list|,
literal|"atpic ocw2 0x%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|atpic
operator|->
name|rotate
operator|=
operator|(
operator|(
name|val
operator|&
name|OCW2_R
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|OCW2_EOI
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|isr_bit
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|OCW2_SL
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* specific EOI */
name|isr_bit
operator|=
name|val
operator|&
literal|0x7
expr_stmt|;
block|}
else|else
block|{
comment|/* non-specific EOI */
name|isr_bit
operator|=
name|vatpic_get_highest_isrpin
argument_list|(
name|atpic
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isr_bit
operator|!=
operator|-
literal|1
condition|)
block|{
name|atpic
operator|->
name|service
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|isr_bit
operator|)
expr_stmt|;
if|if
condition|(
name|atpic
operator|->
name|rotate
condition|)
name|atpic
operator|->
name|priority
operator|=
name|isr_bit
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
name|OCW2_SL
operator|)
operator|!=
literal|0
operator|&&
name|atpic
operator|->
name|rotate
operator|==
name|true
condition|)
block|{
comment|/* specific priority */
name|atpic
operator|->
name|priority
operator|=
name|val
operator|&
literal|0x7
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vatpic_ocw3
parameter_list|(
name|struct
name|vatpic
modifier|*
name|vatpic
parameter_list|,
name|struct
name|atpic
modifier|*
name|atpic
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|VATPIC_CTR1
argument_list|(
name|vatpic
argument_list|,
literal|"atpic ocw3 0x%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|atpic
operator|->
name|poll
operator|=
operator|(
operator|(
name|val
operator|&
name|OCW3_P
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|OCW3_RR
condition|)
block|{
comment|/* read register command */
name|atpic
operator|->
name|rd_cmd_reg
operator|=
name|val
operator|&
name|OCW3_RIS
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vatpic_set_pinstate
parameter_list|(
name|struct
name|vatpic
modifier|*
name|vatpic
parameter_list|,
name|int
name|pin
parameter_list|,
name|bool
name|newstate
parameter_list|)
block|{
name|struct
name|atpic
modifier|*
name|atpic
decl_stmt|;
name|int
name|oldcnt
decl_stmt|,
name|newcnt
decl_stmt|;
name|bool
name|level
decl_stmt|;
name|KASSERT
argument_list|(
name|pin
operator|>=
literal|0
operator|&&
name|pin
operator|<
literal|16
argument_list|,
operator|(
literal|"vatpic_set_pinstate: invalid pin number %d"
operator|,
name|pin
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|VATPIC_LOCKED
argument_list|(
name|vatpic
argument_list|)
argument_list|,
operator|(
literal|"vatpic_set_pinstate: vatpic is not locked"
operator|)
argument_list|)
expr_stmt|;
name|atpic
operator|=
operator|&
name|vatpic
operator|->
name|atpic
index|[
name|pin
operator|>>
literal|3
index|]
expr_stmt|;
name|oldcnt
operator|=
name|atpic
operator|->
name|acnt
index|[
name|pin
operator|&
literal|0x7
index|]
expr_stmt|;
if|if
condition|(
name|newstate
condition|)
name|atpic
operator|->
name|acnt
index|[
name|pin
operator|&
literal|0x7
index|]
operator|++
expr_stmt|;
else|else
name|atpic
operator|->
name|acnt
index|[
name|pin
operator|&
literal|0x7
index|]
operator|--
expr_stmt|;
name|newcnt
operator|=
name|atpic
operator|->
name|acnt
index|[
name|pin
operator|&
literal|0x7
index|]
expr_stmt|;
if|if
condition|(
name|newcnt
operator|<
literal|0
condition|)
block|{
name|VATPIC_CTR2
argument_list|(
name|vatpic
argument_list|,
literal|"atpic pin%d: bad acnt %d"
argument_list|,
name|pin
argument_list|,
name|newcnt
argument_list|)
expr_stmt|;
block|}
name|level
operator|=
operator|(
operator|(
name|vatpic
operator|->
name|elc
index|[
name|pin
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|pin
operator|&
literal|0x7
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldcnt
operator|==
literal|0
operator|&&
name|newcnt
operator|==
literal|1
operator|)
operator|||
operator|(
name|newcnt
operator|>
literal|0
operator|&&
name|level
operator|==
name|true
operator|)
condition|)
block|{
comment|/* rising edge or level */
name|VATPIC_CTR1
argument_list|(
name|vatpic
argument_list|,
literal|"atpic pin%d: asserted"
argument_list|,
name|pin
argument_list|)
expr_stmt|;
name|atpic
operator|->
name|request
operator||=
operator|(
literal|1
operator|<<
operator|(
name|pin
operator|&
literal|0x7
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldcnt
operator|==
literal|1
operator|&&
name|newcnt
operator|==
literal|0
condition|)
block|{
comment|/* falling edge */
name|VATPIC_CTR1
argument_list|(
name|vatpic
argument_list|,
literal|"atpic pin%d: deasserted"
argument_list|,
name|pin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VATPIC_CTR3
argument_list|(
name|vatpic
argument_list|,
literal|"atpic pin%d: %s, ignored, acnt %d"
argument_list|,
name|pin
argument_list|,
name|newstate
condition|?
literal|"asserted"
else|:
literal|"deasserted"
argument_list|,
name|newcnt
argument_list|)
expr_stmt|;
block|}
name|vatpic_notify_intr
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vatpic_set_irqstate
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|irq
parameter_list|,
name|enum
name|irqstate
name|irqstate
parameter_list|)
block|{
name|struct
name|vatpic
modifier|*
name|vatpic
decl_stmt|;
name|struct
name|atpic
modifier|*
name|atpic
decl_stmt|;
if|if
condition|(
name|irq
operator|<
literal|0
operator|||
name|irq
operator|>
literal|15
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|vatpic
operator|=
name|vm_atpic
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|atpic
operator|=
operator|&
name|vatpic
operator|->
name|atpic
index|[
name|irq
operator|>>
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|atpic
operator|->
name|ready
operator|==
name|false
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|VATPIC_LOCK
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|irqstate
condition|)
block|{
case|case
name|IRQSTATE_ASSERT
case|:
name|vatpic_set_pinstate
argument_list|(
name|vatpic
argument_list|,
name|irq
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|IRQSTATE_DEASSERT
case|:
name|vatpic_set_pinstate
argument_list|(
name|vatpic
argument_list|,
name|irq
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|IRQSTATE_PULSE
case|:
name|vatpic_set_pinstate
argument_list|(
name|vatpic
argument_list|,
name|irq
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|vatpic_set_pinstate
argument_list|(
name|vatpic
argument_list|,
name|irq
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"vatpic_set_irqstate: invalid irqstate %d"
argument_list|,
name|irqstate
argument_list|)
expr_stmt|;
block|}
name|VATPIC_UNLOCK
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vatpic_assert_irq
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
return|return
operator|(
name|vatpic_set_irqstate
argument_list|(
name|vm
argument_list|,
name|irq
argument_list|,
name|IRQSTATE_ASSERT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vatpic_deassert_irq
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
return|return
operator|(
name|vatpic_set_irqstate
argument_list|(
name|vm
argument_list|,
name|irq
argument_list|,
name|IRQSTATE_DEASSERT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vatpic_pulse_irq
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
return|return
operator|(
name|vatpic_set_irqstate
argument_list|(
name|vm
argument_list|,
name|irq
argument_list|,
name|IRQSTATE_PULSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vatpic_set_irq_trigger
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|irq
parameter_list|,
name|enum
name|vm_intr_trigger
name|trigger
parameter_list|)
block|{
name|struct
name|vatpic
modifier|*
name|vatpic
decl_stmt|;
if|if
condition|(
name|irq
operator|<
literal|0
operator|||
name|irq
operator|>
literal|15
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * See comment in vatpic_elc_handler.  These IRQs must be 	 * edge triggered. 	 */
if|if
condition|(
name|trigger
operator|==
name|LEVEL_TRIGGER
condition|)
block|{
switch|switch
condition|(
name|irq
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|8
case|:
case|case
literal|13
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|vatpic
operator|=
name|vm_atpic
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|VATPIC_LOCK
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
if|if
condition|(
name|trigger
operator|==
name|LEVEL_TRIGGER
condition|)
name|vatpic
operator|->
name|elc
index|[
name|irq
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|irq
operator|&
literal|0x7
operator|)
expr_stmt|;
else|else
name|vatpic
operator|->
name|elc
index|[
name|irq
operator|>>
literal|3
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|irq
operator|&
literal|0x7
operator|)
operator|)
expr_stmt|;
name|VATPIC_UNLOCK
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vatpic_pending_intr
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
modifier|*
name|vecptr
parameter_list|)
block|{
name|struct
name|vatpic
modifier|*
name|vatpic
decl_stmt|;
name|struct
name|atpic
modifier|*
name|atpic
decl_stmt|;
name|int
name|pin
decl_stmt|;
name|vatpic
operator|=
name|vm_atpic
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|atpic
operator|=
operator|&
name|vatpic
operator|->
name|atpic
index|[
literal|0
index|]
expr_stmt|;
name|VATPIC_LOCK
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
name|pin
operator|=
name|vatpic_get_highest_irrpin
argument_list|(
name|atpic
argument_list|)
expr_stmt|;
if|if
condition|(
name|pin
operator|==
operator|-
literal|1
condition|)
name|pin
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|pin
operator|==
literal|2
condition|)
block|{
name|atpic
operator|=
operator|&
name|vatpic
operator|->
name|atpic
index|[
literal|1
index|]
expr_stmt|;
name|pin
operator|=
name|vatpic_get_highest_irrpin
argument_list|(
name|atpic
argument_list|)
expr_stmt|;
block|}
operator|*
name|vecptr
operator|=
name|atpic
operator|->
name|irq_base
operator|+
name|pin
expr_stmt|;
name|VATPIC_UNLOCK
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vatpic_pin_accepted
parameter_list|(
name|struct
name|atpic
modifier|*
name|atpic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|atpic
operator|->
name|intr_raised
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|atpic
operator|->
name|acnt
index|[
name|pin
index|]
operator|==
literal|0
condition|)
name|atpic
operator|->
name|request
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|pin
operator|)
expr_stmt|;
if|if
condition|(
name|atpic
operator|->
name|aeoi
operator|==
name|true
condition|)
block|{
if|if
condition|(
name|atpic
operator|->
name|rotate
operator|==
name|true
condition|)
name|atpic
operator|->
name|priority
operator|=
name|pin
expr_stmt|;
block|}
else|else
block|{
name|atpic
operator|->
name|service
operator||=
operator|(
literal|1
operator|<<
name|pin
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vatpic_intr_accepted
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vector
parameter_list|)
block|{
name|struct
name|vatpic
modifier|*
name|vatpic
decl_stmt|;
name|int
name|pin
decl_stmt|;
name|vatpic
operator|=
name|vm_atpic
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|VATPIC_LOCK
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
name|pin
operator|=
name|vector
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
operator|(
name|vector
operator|&
operator|~
literal|0x7
operator|)
operator|==
name|vatpic
operator|->
name|atpic
index|[
literal|1
index|]
operator|.
name|irq_base
condition|)
block|{
name|vatpic_pin_accepted
argument_list|(
operator|&
name|vatpic
operator|->
name|atpic
index|[
literal|1
index|]
argument_list|,
name|pin
argument_list|)
expr_stmt|;
comment|/* 		 * If this vector originated from the slave, 		 * accept the cascaded interrupt too. 		 */
name|vatpic_pin_accepted
argument_list|(
operator|&
name|vatpic
operator|->
name|atpic
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vatpic_pin_accepted
argument_list|(
operator|&
name|vatpic
operator|->
name|atpic
index|[
literal|0
index|]
argument_list|,
name|pin
argument_list|)
expr_stmt|;
block|}
name|vatpic_notify_intr
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
name|VATPIC_UNLOCK
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vatpic_read
parameter_list|(
name|struct
name|vatpic
modifier|*
name|vatpic
parameter_list|,
name|struct
name|atpic
modifier|*
name|atpic
parameter_list|,
name|bool
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|)
block|{
name|VATPIC_LOCK
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
if|if
condition|(
name|atpic
operator|->
name|poll
condition|)
block|{
name|VATPIC_CTR0
argument_list|(
name|vatpic
argument_list|,
literal|"vatpic polled mode not supported"
argument_list|)
expr_stmt|;
name|VATPIC_UNLOCK
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|port
operator|&
name|ICU_IMR_OFFSET
condition|)
block|{
comment|/* read interrrupt mask register */
operator|*
name|eax
operator|=
name|atpic
operator|->
name|mask
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|atpic
operator|->
name|rd_cmd_reg
operator|==
name|OCW3_RIS
condition|)
block|{
comment|/* read interrupt service register */
operator|*
name|eax
operator|=
name|atpic
operator|->
name|service
expr_stmt|;
block|}
else|else
block|{
comment|/* read interrupt request register */
operator|*
name|eax
operator|=
name|atpic
operator|->
name|request
expr_stmt|;
block|}
block|}
block|}
name|VATPIC_UNLOCK
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vatpic_write
parameter_list|(
name|struct
name|vatpic
modifier|*
name|vatpic
parameter_list|,
name|struct
name|atpic
modifier|*
name|atpic
parameter_list|,
name|bool
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint8_t
name|val
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|*
name|eax
expr_stmt|;
name|VATPIC_LOCK
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|&
name|ICU_IMR_OFFSET
condition|)
block|{
switch|switch
condition|(
name|atpic
operator|->
name|icw_num
condition|)
block|{
case|case
literal|2
case|:
name|error
operator|=
name|vatpic_icw2
argument_list|(
name|vatpic
argument_list|,
name|atpic
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|error
operator|=
name|vatpic_icw3
argument_list|(
name|vatpic
argument_list|,
name|atpic
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|error
operator|=
name|vatpic_icw4
argument_list|(
name|vatpic
argument_list|,
name|atpic
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|vatpic_ocw1
argument_list|(
name|vatpic
argument_list|,
name|atpic
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
condition|)
name|error
operator|=
name|vatpic_icw1
argument_list|(
name|vatpic
argument_list|,
name|atpic
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|atpic
operator|->
name|ready
condition|)
block|{
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
condition|)
name|error
operator|=
name|vatpic_ocw3
argument_list|(
name|vatpic
argument_list|,
name|atpic
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|vatpic_ocw2
argument_list|(
name|vatpic
argument_list|,
name|atpic
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|atpic
operator|->
name|ready
condition|)
name|vatpic_notify_intr
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
name|VATPIC_UNLOCK
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vatpic_master_handler
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|bool
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|)
block|{
name|struct
name|vatpic
modifier|*
name|vatpic
decl_stmt|;
name|struct
name|atpic
modifier|*
name|atpic
decl_stmt|;
name|vatpic
operator|=
name|vm_atpic
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|atpic
operator|=
operator|&
name|vatpic
operator|->
name|atpic
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|in
condition|)
block|{
return|return
operator|(
name|vatpic_read
argument_list|(
name|vatpic
argument_list|,
name|atpic
argument_list|,
name|in
argument_list|,
name|port
argument_list|,
name|bytes
argument_list|,
name|eax
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|vatpic_write
argument_list|(
name|vatpic
argument_list|,
name|atpic
argument_list|,
name|in
argument_list|,
name|port
argument_list|,
name|bytes
argument_list|,
name|eax
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vatpic_slave_handler
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|bool
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|)
block|{
name|struct
name|vatpic
modifier|*
name|vatpic
decl_stmt|;
name|struct
name|atpic
modifier|*
name|atpic
decl_stmt|;
name|vatpic
operator|=
name|vm_atpic
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|atpic
operator|=
operator|&
name|vatpic
operator|->
name|atpic
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|in
condition|)
block|{
return|return
operator|(
name|vatpic_read
argument_list|(
name|vatpic
argument_list|,
name|atpic
argument_list|,
name|in
argument_list|,
name|port
argument_list|,
name|bytes
argument_list|,
name|eax
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|vatpic_write
argument_list|(
name|vatpic
argument_list|,
name|atpic
argument_list|,
name|in
argument_list|,
name|port
argument_list|,
name|bytes
argument_list|,
name|eax
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vatpic_elc_handler
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|bool
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|)
block|{
name|struct
name|vatpic
modifier|*
name|vatpic
decl_stmt|;
name|bool
name|is_master
decl_stmt|;
name|vatpic
operator|=
name|vm_atpic
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|is_master
operator|=
operator|(
name|port
operator|==
name|IO_ELCR1
operator|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|VATPIC_LOCK
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
condition|)
block|{
if|if
condition|(
name|is_master
condition|)
operator|*
name|eax
operator|=
name|vatpic
operator|->
name|elc
index|[
literal|0
index|]
expr_stmt|;
else|else
operator|*
name|eax
operator|=
name|vatpic
operator|->
name|elc
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * For the master PIC the cascade channel (IRQ2), the 		 * heart beat timer (IRQ0), and the keyboard 		 * controller (IRQ1) cannot be programmed for level 		 * mode. 		 * 		 * For the slave PIC the real time clock (IRQ8) and 		 * the floating point error interrupt (IRQ13) cannot 		 * be programmed for level mode. 		 */
if|if
condition|(
name|is_master
condition|)
name|vatpic
operator|->
name|elc
index|[
literal|0
index|]
operator|=
operator|(
operator|*
name|eax
operator|&
literal|0xf8
operator|)
expr_stmt|;
else|else
name|vatpic
operator|->
name|elc
index|[
literal|1
index|]
operator|=
operator|(
operator|*
name|eax
operator|&
literal|0xde
operator|)
expr_stmt|;
block|}
name|VATPIC_UNLOCK
argument_list|(
name|vatpic
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|vatpic
modifier|*
name|vatpic_init
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|)
block|{
name|struct
name|vatpic
modifier|*
name|vatpic
decl_stmt|;
name|vatpic
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vatpic
argument_list|)
argument_list|,
name|M_VATPIC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vatpic
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|vatpic
operator|->
name|mtx
argument_list|,
literal|"vatpic lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
return|return
operator|(
name|vatpic
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vatpic_cleanup
parameter_list|(
name|struct
name|vatpic
modifier|*
name|vatpic
parameter_list|)
block|{
name|free
argument_list|(
name|vatpic
argument_list|,
name|M_VATPIC
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

