begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 NetApp, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm_dev.h>
end_include

begin_include
include|#
directive|include
file|"vmm_lapic.h"
end_include

begin_include
include|#
directive|include
file|"vmm_ktr.h"
end_include

begin_include
include|#
directive|include
file|"iommu.h"
end_include

begin_include
include|#
directive|include
file|"ppt.h"
end_include

begin_comment
comment|/* XXX locking */
end_comment

begin_define
define|#
directive|define
name|MAX_PPTDEVS
value|(sizeof(pptdevs) / sizeof(pptdevs[0]))
end_define

begin_define
define|#
directive|define
name|MAX_MSIMSGS
value|32
end_define

begin_comment
comment|/*  * If the MSI-X table is located in the middle of a BAR then that MMIO  * region gets split into two segments - one segment above the MSI-X table  * and the other segment below the MSI-X table - with a hole in place of  * the MSI-X table so accesses to it can be trapped and emulated.  *  * So, allocate a MMIO segment for each BAR register + 1 additional segment.  */
end_comment

begin_define
define|#
directive|define
name|MAX_MMIOSEGS
value|((PCIR_MAX_BAR_0 + 1) + 1)
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PPTMSIX
argument_list|,
literal|"pptmsix"
argument_list|,
literal|"Passthru MSI-X resources"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|pptintr_arg
block|{
comment|/* pptintr(pptintr_arg) */
name|struct
name|pptdev
modifier|*
name|pptdev
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint64_t
name|msg_data
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|pptdev
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
comment|/* owner of this device */
name|struct
name|vm_memory_segment
name|mmio
index|[
name|MAX_MMIOSEGS
index|]
decl_stmt|;
struct|struct
block|{
name|int
name|num_msgs
decl_stmt|;
comment|/* guest state */
name|int
name|startrid
decl_stmt|;
comment|/* host state */
name|struct
name|resource
modifier|*
name|res
index|[
name|MAX_MSIMSGS
index|]
decl_stmt|;
name|void
modifier|*
name|cookie
index|[
name|MAX_MSIMSGS
index|]
decl_stmt|;
name|struct
name|pptintr_arg
name|arg
index|[
name|MAX_MSIMSGS
index|]
decl_stmt|;
block|}
name|msi
struct|;
struct|struct
block|{
name|int
name|num_msgs
decl_stmt|;
name|int
name|startrid
decl_stmt|;
name|int
name|msix_table_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|msix_table_res
decl_stmt|;
name|struct
name|resource
modifier|*
modifier|*
name|res
decl_stmt|;
name|void
modifier|*
modifier|*
name|cookie
decl_stmt|;
name|struct
name|pptintr_arg
modifier|*
name|arg
decl_stmt|;
block|}
name|msix
struct|;
block|}
name|pptdevs
index|[
literal|64
index|]
struct|;
end_struct

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_vmm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_vmm
argument_list|,
name|OID_AUTO
argument_list|,
name|ppt
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"bhyve passthru devices"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|num_pptdevs
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_vmm_ppt
argument_list|,
name|OID_AUTO
argument_list|,
name|devices
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|num_pptdevs
argument_list|,
literal|0
argument_list|,
literal|"number of pci passthru devices"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|ppt_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|bus
decl_stmt|,
name|slot
decl_stmt|,
name|func
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
operator|(
expr|struct
name|pci_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|slot
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|func
operator|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * To qualify as a pci passthrough device a device must: 	 * - be allowed by administrator to be used in this role 	 * - be an endpoint device 	 */
if|if
condition|(
name|vmm_is_pptdev
argument_list|(
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|hdrtype
operator|&
name|PCIM_HDRTYPE
operator|)
operator|==
name|PCIM_HDRTYPE_NORMAL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ppt_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|num_pptdevs
operator|>=
name|MAX_PPTDEVS
condition|)
block|{
name|printf
argument_list|(
literal|"ppt_attach: maximum number of pci passthrough devices "
literal|"exceeded\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|n
operator|=
name|num_pptdevs
operator|++
expr_stmt|;
name|pptdevs
index|[
name|n
index|]
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"attached\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ppt_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * XXX check whether there are any pci passthrough devices assigned 	 * to guests before we allow this driver to detach. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ppt_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ppt_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ppt_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ppt_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ppt_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|ppt
argument_list|,
name|ppt_driver
argument_list|,
name|ppt_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ppt
argument_list|,
name|pci
argument_list|,
name|ppt_driver
argument_list|,
name|ppt_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|struct
name|pptdev
modifier|*
name|ppt_find
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|b
decl_stmt|,
name|s
decl_stmt|,
name|f
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_pptdevs
condition|;
name|i
operator|++
control|)
block|{
name|dev
operator|=
name|pptdevs
index|[
name|i
index|]
operator|.
name|dev
expr_stmt|;
name|b
operator|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|s
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|f
operator|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|==
name|b
operator|&&
name|slot
operator|==
name|s
operator|&&
name|func
operator|==
name|f
condition|)
return|return
operator|(
operator|&
name|pptdevs
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppt_unmap_mmio
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|struct
name|pptdev
modifier|*
name|ppt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|vm_memory_segment
modifier|*
name|seg
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MMIOSEGS
condition|;
name|i
operator|++
control|)
block|{
name|seg
operator|=
operator|&
name|ppt
operator|->
name|mmio
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|seg
operator|->
name|len
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|vm_unmap_mmio
argument_list|(
name|vm
argument_list|,
name|seg
operator|->
name|gpa
argument_list|,
name|seg
operator|->
name|len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|seg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vm_memory_segment
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ppt_teardown_msi
parameter_list|(
name|struct
name|pptdev
modifier|*
name|ppt
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rid
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|ppt
operator|->
name|msi
operator|.
name|num_msgs
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppt
operator|->
name|msi
operator|.
name|num_msgs
condition|;
name|i
operator|++
control|)
block|{
name|rid
operator|=
name|ppt
operator|->
name|msi
operator|.
name|startrid
operator|+
name|i
expr_stmt|;
name|res
operator|=
name|ppt
operator|->
name|msi
operator|.
name|res
index|[
name|i
index|]
expr_stmt|;
name|cookie
operator|=
name|ppt
operator|->
name|msi
operator|.
name|cookie
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|cookie
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|ppt
operator|->
name|dev
argument_list|,
name|res
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ppt
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ppt
operator|->
name|msi
operator|.
name|res
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ppt
operator|->
name|msi
operator|.
name|cookie
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ppt
operator|->
name|msi
operator|.
name|startrid
operator|==
literal|1
condition|)
name|pci_release_msi
argument_list|(
name|ppt
operator|->
name|dev
argument_list|)
expr_stmt|;
name|ppt
operator|->
name|msi
operator|.
name|num_msgs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppt_teardown_msix_intr
parameter_list|(
name|struct
name|pptdev
modifier|*
name|ppt
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|int
name|rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|rid
operator|=
name|ppt
operator|->
name|msix
operator|.
name|startrid
operator|+
name|idx
expr_stmt|;
name|res
operator|=
name|ppt
operator|->
name|msix
operator|.
name|res
index|[
name|idx
index|]
expr_stmt|;
name|cookie
operator|=
name|ppt
operator|->
name|msix
operator|.
name|cookie
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|cookie
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|ppt
operator|->
name|dev
argument_list|,
name|res
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ppt
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ppt
operator|->
name|msix
operator|.
name|res
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
name|ppt
operator|->
name|msix
operator|.
name|cookie
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppt_teardown_msix
parameter_list|(
name|struct
name|pptdev
modifier|*
name|ppt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ppt
operator|->
name|msix
operator|.
name|num_msgs
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppt
operator|->
name|msix
operator|.
name|num_msgs
condition|;
name|i
operator|++
control|)
name|ppt_teardown_msix_intr
argument_list|(
name|ppt
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppt
operator|->
name|msix
operator|.
name|msix_table_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|ppt
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ppt
operator|->
name|msix
operator|.
name|msix_table_rid
argument_list|,
name|ppt
operator|->
name|msix
operator|.
name|msix_table_res
argument_list|)
expr_stmt|;
name|ppt
operator|->
name|msix
operator|.
name|msix_table_res
operator|=
name|NULL
expr_stmt|;
name|ppt
operator|->
name|msix
operator|.
name|msix_table_rid
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|ppt
operator|->
name|msix
operator|.
name|res
argument_list|,
name|M_PPTMSIX
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ppt
operator|->
name|msix
operator|.
name|cookie
argument_list|,
name|M_PPTMSIX
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ppt
operator|->
name|msix
operator|.
name|arg
argument_list|,
name|M_PPTMSIX
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|ppt
operator|->
name|dev
argument_list|)
expr_stmt|;
name|ppt
operator|->
name|msix
operator|.
name|num_msgs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ppt_avail_devices
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|num_pptdevs
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ppt_assigned_devices
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|num
decl_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_pptdevs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pptdevs
index|[
name|i
index|]
operator|.
name|vm
operator|==
name|vm
condition|)
name|num
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|num
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|ppt_is_mmio
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|vm_paddr_t
name|gpa
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|pptdev
modifier|*
name|ppt
decl_stmt|;
name|struct
name|vm_memory_segment
modifier|*
name|seg
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_pptdevs
condition|;
name|n
operator|++
control|)
block|{
name|ppt
operator|=
operator|&
name|pptdevs
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|ppt
operator|->
name|vm
operator|!=
name|vm
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MMIOSEGS
condition|;
name|i
operator|++
control|)
block|{
name|seg
operator|=
operator|&
name|ppt
operator|->
name|mmio
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|seg
operator|->
name|len
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|gpa
operator|>=
name|seg
operator|->
name|gpa
operator|&&
name|gpa
operator|<
name|seg
operator|->
name|gpa
operator|+
name|seg
operator|->
name|len
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ppt_assign_device
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|)
block|{
name|struct
name|pptdev
modifier|*
name|ppt
decl_stmt|;
name|ppt
operator|=
name|ppt_find
argument_list|(
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppt
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If this device is owned by a different VM then we 		 * cannot change its owner. 		 */
if|if
condition|(
name|ppt
operator|->
name|vm
operator|!=
name|NULL
operator|&&
name|ppt
operator|->
name|vm
operator|!=
name|vm
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|ppt
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|iommu_add_device
argument_list|(
name|vm_iommu_domain
argument_list|(
name|vm
argument_list|)
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ppt_unassign_device
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|)
block|{
name|struct
name|pptdev
modifier|*
name|ppt
decl_stmt|;
name|ppt
operator|=
name|ppt_find
argument_list|(
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppt
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If this device is not owned by this 'vm' then bail out. 		 */
if|if
condition|(
name|ppt
operator|->
name|vm
operator|!=
name|vm
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|ppt_unmap_mmio
argument_list|(
name|vm
argument_list|,
name|ppt
argument_list|)
expr_stmt|;
name|ppt_teardown_msi
argument_list|(
name|ppt
argument_list|)
expr_stmt|;
name|ppt_teardown_msix
argument_list|(
name|ppt
argument_list|)
expr_stmt|;
name|iommu_remove_device
argument_list|(
name|vm_iommu_domain
argument_list|(
name|vm
argument_list|)
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|ppt
operator|->
name|vm
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ppt_unassign_all
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|bus
decl_stmt|,
name|slot
decl_stmt|,
name|func
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_pptdevs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pptdevs
index|[
name|i
index|]
operator|.
name|vm
operator|==
name|vm
condition|)
block|{
name|dev
operator|=
name|pptdevs
index|[
name|i
index|]
operator|.
name|dev
expr_stmt|;
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|slot
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|func
operator|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|vm_unassign_pptdev
argument_list|(
name|vm
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ppt_map_mmio
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|vm_paddr_t
name|gpa
parameter_list|,
name|size_t
name|len
parameter_list|,
name|vm_paddr_t
name|hpa
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|vm_memory_segment
modifier|*
name|seg
decl_stmt|;
name|struct
name|pptdev
modifier|*
name|ppt
decl_stmt|;
name|ppt
operator|=
name|ppt_find
argument_list|(
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ppt
operator|->
name|vm
operator|!=
name|vm
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MMIOSEGS
condition|;
name|i
operator|++
control|)
block|{
name|seg
operator|=
operator|&
name|ppt
operator|->
name|mmio
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|seg
operator|->
name|len
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|vm_map_mmio
argument_list|(
name|vm
argument_list|,
name|gpa
argument_list|,
name|len
argument_list|,
name|hpa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|seg
operator|->
name|gpa
operator|=
name|gpa
expr_stmt|;
name|seg
operator|->
name|len
operator|=
name|len
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pptintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pptdev
modifier|*
name|ppt
decl_stmt|;
name|struct
name|pptintr_arg
modifier|*
name|pptarg
decl_stmt|;
name|pptarg
operator|=
name|arg
expr_stmt|;
name|ppt
operator|=
name|pptarg
operator|->
name|pptdev
expr_stmt|;
if|if
condition|(
name|ppt
operator|->
name|vm
operator|!=
name|NULL
condition|)
name|lapic_intr_msi
argument_list|(
name|ppt
operator|->
name|vm
argument_list|,
name|pptarg
operator|->
name|addr
argument_list|,
name|pptarg
operator|->
name|msg_data
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * XXX 		 * This is not expected to happen - panic? 		 */
block|}
comment|/* 	 * For legacy interrupts give other filters a chance in case 	 * the interrupt was not generated by the passthrough device. 	 */
if|if
condition|(
name|ppt
operator|->
name|msi
operator|.
name|startrid
operator|==
literal|0
condition|)
return|return
operator|(
name|FILTER_STRAY
operator|)
return|;
else|else
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ppt_setup_msi
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|uint64_t
name|msg
parameter_list|,
name|int
name|numvec
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rid
decl_stmt|,
name|flags
decl_stmt|;
name|int
name|msi_count
decl_stmt|,
name|startrid
decl_stmt|,
name|error
decl_stmt|,
name|tmp
decl_stmt|;
name|struct
name|pptdev
modifier|*
name|ppt
decl_stmt|;
if|if
condition|(
name|numvec
operator|<
literal|0
operator|||
name|numvec
operator|>
name|MAX_MSIMSGS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ppt
operator|=
name|ppt_find
argument_list|(
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|ppt
operator|->
name|vm
operator|!=
name|vm
condition|)
comment|/* Make sure we own this device */
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Free any allocated resources */
name|ppt_teardown_msi
argument_list|(
name|ppt
argument_list|)
expr_stmt|;
if|if
condition|(
name|numvec
operator|==
literal|0
condition|)
comment|/* nothing more to do */
return|return
operator|(
literal|0
operator|)
return|;
name|flags
operator|=
name|RF_ACTIVE
expr_stmt|;
name|msi_count
operator|=
name|pci_msi_count
argument_list|(
name|ppt
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|msi_count
operator|==
literal|0
condition|)
block|{
name|startrid
operator|=
literal|0
expr_stmt|;
comment|/* legacy interrupt */
name|msi_count
operator|=
literal|1
expr_stmt|;
name|flags
operator||=
name|RF_SHAREABLE
expr_stmt|;
block|}
else|else
name|startrid
operator|=
literal|1
expr_stmt|;
comment|/* MSI */
comment|/* 	 * The device must be capable of supporting the number of vectors 	 * the guest wants to allocate. 	 */
if|if
condition|(
name|numvec
operator|>
name|msi_count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Make sure that we can allocate all the MSI vectors that are needed 	 * by the guest. 	 */
if|if
condition|(
name|startrid
operator|==
literal|1
condition|)
block|{
name|tmp
operator|=
name|numvec
expr_stmt|;
name|error
operator|=
name|pci_alloc_msi
argument_list|(
name|ppt
operator|->
name|dev
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
elseif|else
if|if
condition|(
name|tmp
operator|!=
name|numvec
condition|)
block|{
name|pci_release_msi
argument_list|(
name|ppt
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
else|else
block|{
comment|/* success */
block|}
block|}
name|ppt
operator|->
name|msi
operator|.
name|startrid
operator|=
name|startrid
expr_stmt|;
comment|/* 	 * Allocate the irq resource and attach it to the interrupt handler. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvec
condition|;
name|i
operator|++
control|)
block|{
name|ppt
operator|->
name|msi
operator|.
name|num_msgs
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|ppt
operator|->
name|msi
operator|.
name|cookie
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|rid
operator|=
name|startrid
operator|+
name|i
expr_stmt|;
name|ppt
operator|->
name|msi
operator|.
name|res
index|[
name|i
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ppt
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppt
operator|->
name|msi
operator|.
name|res
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
name|ppt
operator|->
name|msi
operator|.
name|arg
index|[
name|i
index|]
operator|.
name|pptdev
operator|=
name|ppt
expr_stmt|;
name|ppt
operator|->
name|msi
operator|.
name|arg
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|ppt
operator|->
name|msi
operator|.
name|arg
index|[
name|i
index|]
operator|.
name|msg_data
operator|=
name|msg
operator|+
name|i
expr_stmt|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|ppt
operator|->
name|dev
argument_list|,
name|ppt
operator|->
name|msi
operator|.
name|res
index|[
name|i
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|pptintr
argument_list|,
name|NULL
argument_list|,
operator|&
name|ppt
operator|->
name|msi
operator|.
name|arg
index|[
name|i
index|]
argument_list|,
operator|&
name|ppt
operator|->
name|msi
operator|.
name|cookie
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|numvec
condition|)
block|{
name|ppt_teardown_msi
argument_list|(
name|ppt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ppt_setup_msix
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|uint64_t
name|msg
parameter_list|,
name|uint32_t
name|vector_control
parameter_list|)
block|{
name|struct
name|pptdev
modifier|*
name|ppt
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|numvec
decl_stmt|,
name|alloced
decl_stmt|,
name|rid
decl_stmt|,
name|error
decl_stmt|;
name|size_t
name|res_size
decl_stmt|,
name|cookie_size
decl_stmt|,
name|arg_size
decl_stmt|;
name|ppt
operator|=
name|ppt_find
argument_list|(
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|ppt
operator|->
name|vm
operator|!=
name|vm
condition|)
comment|/* Make sure we own this device */
return|return
operator|(
name|EBUSY
operator|)
return|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|ppt
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dinfo
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*  	 * First-time configuration: 	 * 	Allocate the MSI-X table 	 *	Allocate the IRQ resources 	 *	Set up some variables in ppt->msix 	 */
if|if
condition|(
name|ppt
operator|->
name|msix
operator|.
name|num_msgs
operator|==
literal|0
condition|)
block|{
name|numvec
operator|=
name|pci_msix_count
argument_list|(
name|ppt
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|numvec
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ppt
operator|->
name|msix
operator|.
name|startrid
operator|=
literal|1
expr_stmt|;
name|ppt
operator|->
name|msix
operator|.
name|num_msgs
operator|=
name|numvec
expr_stmt|;
name|res_size
operator|=
name|numvec
operator|*
sizeof|sizeof
argument_list|(
name|ppt
operator|->
name|msix
operator|.
name|res
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cookie_size
operator|=
name|numvec
operator|*
sizeof|sizeof
argument_list|(
name|ppt
operator|->
name|msix
operator|.
name|cookie
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|arg_size
operator|=
name|numvec
operator|*
sizeof|sizeof
argument_list|(
name|ppt
operator|->
name|msix
operator|.
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ppt
operator|->
name|msix
operator|.
name|res
operator|=
name|malloc
argument_list|(
name|res_size
argument_list|,
name|M_PPTMSIX
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ppt
operator|->
name|msix
operator|.
name|cookie
operator|=
name|malloc
argument_list|(
name|cookie_size
argument_list|,
name|M_PPTMSIX
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ppt
operator|->
name|msix
operator|.
name|arg
operator|=
name|malloc
argument_list|(
name|arg_size
argument_list|,
name|M_PPTMSIX
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|rid
operator|=
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_table_bar
expr_stmt|;
name|ppt
operator|->
name|msix
operator|.
name|msix_table_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ppt
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppt
operator|->
name|msix
operator|.
name|msix_table_res
operator|==
name|NULL
condition|)
block|{
name|ppt_teardown_msix
argument_list|(
name|ppt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|ppt
operator|->
name|msix
operator|.
name|msix_table_rid
operator|=
name|rid
expr_stmt|;
name|alloced
operator|=
name|numvec
expr_stmt|;
name|error
operator|=
name|pci_alloc_msix
argument_list|(
name|ppt
operator|->
name|dev
argument_list|,
operator|&
name|alloced
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|alloced
operator|!=
name|numvec
condition|)
block|{
name|ppt_teardown_msix
argument_list|(
name|ppt
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|==
literal|0
condition|?
name|ENOSPC
else|:
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|vector_control
operator|&
name|PCIM_MSIX_VCTRL_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Tear down the IRQ if it's already set up */
name|ppt_teardown_msix_intr
argument_list|(
name|ppt
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|/* Allocate the IRQ resource */
name|ppt
operator|->
name|msix
operator|.
name|cookie
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
name|rid
operator|=
name|ppt
operator|->
name|msix
operator|.
name|startrid
operator|+
name|idx
expr_stmt|;
name|ppt
operator|->
name|msix
operator|.
name|res
index|[
name|idx
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ppt
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppt
operator|->
name|msix
operator|.
name|res
index|[
name|idx
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ppt
operator|->
name|msix
operator|.
name|arg
index|[
name|idx
index|]
operator|.
name|pptdev
operator|=
name|ppt
expr_stmt|;
name|ppt
operator|->
name|msix
operator|.
name|arg
index|[
name|idx
index|]
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|ppt
operator|->
name|msix
operator|.
name|arg
index|[
name|idx
index|]
operator|.
name|msg_data
operator|=
name|msg
expr_stmt|;
comment|/* Setup the MSI-X interrupt */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|ppt
operator|->
name|dev
argument_list|,
name|ppt
operator|->
name|msix
operator|.
name|res
index|[
name|idx
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|pptintr
argument_list|,
name|NULL
argument_list|,
operator|&
name|ppt
operator|->
name|msix
operator|.
name|arg
index|[
name|idx
index|]
argument_list|,
operator|&
name|ppt
operator|->
name|msix
operator|.
name|cookie
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|ppt
operator|->
name|dev
argument_list|,
name|ppt
operator|->
name|msix
operator|.
name|res
index|[
name|idx
index|]
argument_list|,
name|ppt
operator|->
name|msix
operator|.
name|cookie
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|ppt
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|ppt
operator|->
name|msix
operator|.
name|res
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|ppt
operator|->
name|msix
operator|.
name|cookie
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
name|ppt
operator|->
name|msix
operator|.
name|res
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Masked, tear it down if it's already been set up */
name|ppt_teardown_msix_intr
argument_list|(
name|ppt
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

