begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 Tycho Nightingale<tycho.nightingale@pluribusnetworks.com>  * Copyright (c) 2011 NetApp, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|"vmm_ktr.h"
end_include

begin_include
include|#
directive|include
file|"vatpic.h"
end_include

begin_include
include|#
directive|include
file|"vioapic.h"
end_include

begin_include
include|#
directive|include
file|"vatpit.h"
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VATPIT
argument_list|,
literal|"atpit"
argument_list|,
literal|"bhyve virtual atpit (8254)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|VATPIT_LOCK
parameter_list|(
name|vatpit
parameter_list|)
value|mtx_lock_spin(&((vatpit)->mtx))
end_define

begin_define
define|#
directive|define
name|VATPIT_UNLOCK
parameter_list|(
name|vatpit
parameter_list|)
value|mtx_unlock_spin(&((vatpit)->mtx))
end_define

begin_define
define|#
directive|define
name|VATPIT_LOCKED
parameter_list|(
name|vatpit
parameter_list|)
value|mtx_owned(&((vatpit)->mtx))
end_define

begin_define
define|#
directive|define
name|TIMER_SEL_MASK
value|0xc0
end_define

begin_define
define|#
directive|define
name|TIMER_RW_MASK
value|0x30
end_define

begin_define
define|#
directive|define
name|TIMER_MODE_MASK
value|0x0f
end_define

begin_define
define|#
directive|define
name|TIMER_SEL_READBACK
value|0xc0
end_define

begin_define
define|#
directive|define
name|TIMER_STS_OUT
value|0x80
end_define

begin_define
define|#
directive|define
name|TIMER_STS_NULLCNT
value|0x40
end_define

begin_define
define|#
directive|define
name|TIMER_RB_LCTR
value|0x20
end_define

begin_define
define|#
directive|define
name|TIMER_RB_LSTATUS
value|0x10
end_define

begin_define
define|#
directive|define
name|TIMER_RB_CTR_2
value|0x08
end_define

begin_define
define|#
directive|define
name|TIMER_RB_CTR_1
value|0x04
end_define

begin_define
define|#
directive|define
name|TIMER_RB_CTR_0
value|0x02
end_define

begin_define
define|#
directive|define
name|TMR2_OUT_STS
value|0x20
end_define

begin_define
define|#
directive|define
name|PIT_8254_FREQ
value|1193182
end_define

begin_define
define|#
directive|define
name|TIMER_DIV
parameter_list|(
name|freq
parameter_list|,
name|hz
parameter_list|)
value|(((freq) + (hz) / 2) / (hz))
end_define

begin_struct
struct|struct
name|vatpit_callout_arg
block|{
name|struct
name|vatpit
modifier|*
name|vatpit
decl_stmt|;
name|int
name|channel_num
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|channel
block|{
name|int
name|mode
decl_stmt|;
name|uint16_t
name|initial
decl_stmt|;
comment|/* initial counter value */
name|sbintime_t
name|now_sbt
decl_stmt|;
comment|/* uptime when counter was loaded */
name|uint8_t
name|cr
index|[
literal|2
index|]
decl_stmt|;
name|uint8_t
name|ol
index|[
literal|2
index|]
decl_stmt|;
name|bool
name|slatched
decl_stmt|;
comment|/* status latched */
name|uint8_t
name|status
decl_stmt|;
name|int
name|crbyte
decl_stmt|;
name|int
name|olbyte
decl_stmt|;
name|int
name|frbyte
decl_stmt|;
name|struct
name|callout
name|callout
decl_stmt|;
name|sbintime_t
name|callout_sbt
decl_stmt|;
comment|/* target time */
name|struct
name|vatpit_callout_arg
name|callout_arg
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vatpit
block|{
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
name|struct
name|mtx
name|mtx
decl_stmt|;
name|sbintime_t
name|freq_sbt
decl_stmt|;
name|struct
name|channel
name|channel
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|pit_timer_start_cntr0
parameter_list|(
name|struct
name|vatpit
modifier|*
name|vatpit
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|vatpit_get_out
parameter_list|(
name|struct
name|vatpit
modifier|*
name|vatpit
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|struct
name|channel
modifier|*
name|c
decl_stmt|;
name|sbintime_t
name|delta_ticks
decl_stmt|;
name|int
name|out
decl_stmt|;
name|c
operator|=
operator|&
name|vatpit
operator|->
name|channel
index|[
name|channel
index|]
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|mode
condition|)
block|{
case|case
name|TIMER_INTTC
case|:
name|delta_ticks
operator|=
operator|(
name|sbinuptime
argument_list|()
operator|-
name|c
operator|->
name|now_sbt
operator|)
operator|/
name|vatpit
operator|->
name|freq_sbt
expr_stmt|;
name|out
operator|=
operator|(
operator|(
name|c
operator|->
name|initial
operator|-
name|delta_ticks
operator|)
operator|<=
literal|0
operator|)
expr_stmt|;
break|break;
default|default:
name|out
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|out
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vatpit_callout_handler
parameter_list|(
name|void
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|vatpit_callout_arg
modifier|*
name|arg
init|=
name|a
decl_stmt|;
name|struct
name|vatpit
modifier|*
name|vatpit
decl_stmt|;
name|struct
name|callout
modifier|*
name|callout
decl_stmt|;
name|struct
name|channel
modifier|*
name|c
decl_stmt|;
name|vatpit
operator|=
name|arg
operator|->
name|vatpit
expr_stmt|;
name|c
operator|=
operator|&
name|vatpit
operator|->
name|channel
index|[
name|arg
operator|->
name|channel_num
index|]
expr_stmt|;
name|callout
operator|=
operator|&
name|c
operator|->
name|callout
expr_stmt|;
name|VM_CTR1
argument_list|(
name|vatpit
operator|->
name|vm
argument_list|,
literal|"atpit t%d fired"
argument_list|,
name|arg
operator|->
name|channel_num
argument_list|)
expr_stmt|;
name|VATPIT_LOCK
argument_list|(
name|vatpit
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
name|callout
argument_list|)
condition|)
comment|/* callout was reset */
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|callout_active
argument_list|(
name|callout
argument_list|)
condition|)
comment|/* callout was stopped */
goto|goto
name|done
goto|;
name|callout_deactivate
argument_list|(
name|callout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|TIMER_RATEGEN
condition|)
block|{
name|pit_timer_start_cntr0
argument_list|(
name|vatpit
argument_list|)
expr_stmt|;
block|}
name|vatpic_pulse_irq
argument_list|(
name|vatpit
operator|->
name|vm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vioapic_pulse_irq
argument_list|(
name|vatpit
operator|->
name|vm
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|done
label|:
name|VATPIT_UNLOCK
argument_list|(
name|vatpit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|pit_timer_start_cntr0
parameter_list|(
name|struct
name|vatpit
modifier|*
name|vatpit
parameter_list|)
block|{
name|struct
name|channel
modifier|*
name|c
decl_stmt|;
name|sbintime_t
name|now
decl_stmt|,
name|delta
decl_stmt|,
name|precision
decl_stmt|;
name|c
operator|=
operator|&
name|vatpit
operator|->
name|channel
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|initial
operator|!=
literal|0
condition|)
block|{
name|delta
operator|=
name|c
operator|->
name|initial
operator|*
name|vatpit
operator|->
name|freq_sbt
expr_stmt|;
name|precision
operator|=
name|delta
operator|>>
name|tc_precexp
expr_stmt|;
name|c
operator|->
name|callout_sbt
operator|=
name|c
operator|->
name|callout_sbt
operator|+
name|delta
expr_stmt|;
comment|/* 		 * Reset 'callout_sbt' if the time that the callout 		 * was supposed to fire is more than 'c->initial' 		 * ticks in the past. 		 */
name|now
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|callout_sbt
operator|<
name|now
condition|)
name|c
operator|->
name|callout_sbt
operator|=
name|now
operator|+
name|delta
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|c
operator|->
name|callout
argument_list|,
name|c
operator|->
name|callout_sbt
argument_list|,
name|precision
argument_list|,
name|vatpit_callout_handler
argument_list|,
operator|&
name|c
operator|->
name|callout_arg
argument_list|,
name|C_ABSOLUTE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|pit_update_counter
parameter_list|(
name|struct
name|vatpit
modifier|*
name|vatpit
parameter_list|,
name|struct
name|channel
modifier|*
name|c
parameter_list|,
name|bool
name|latch
parameter_list|)
block|{
name|uint16_t
name|lval
decl_stmt|;
name|sbintime_t
name|delta_ticks
decl_stmt|;
comment|/* cannot latch a new value until the old one has been consumed */
if|if
condition|(
name|latch
operator|&&
name|c
operator|->
name|olbyte
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|c
operator|->
name|initial
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This is possibly an o/s bug - reading the value of 		 * the timer without having set up the initial value. 		 * 		 * The original user-space version of this code set 		 * the timer to 100hz in this condition; do the same 		 * here. 		 */
name|c
operator|->
name|initial
operator|=
name|TIMER_DIV
argument_list|(
name|PIT_8254_FREQ
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|c
operator|->
name|now_sbt
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
name|c
operator|->
name|status
operator|&=
operator|~
name|TIMER_STS_NULLCNT
expr_stmt|;
block|}
name|delta_ticks
operator|=
operator|(
name|sbinuptime
argument_list|()
operator|-
name|c
operator|->
name|now_sbt
operator|)
operator|/
name|vatpit
operator|->
name|freq_sbt
expr_stmt|;
name|lval
operator|=
name|c
operator|->
name|initial
operator|-
name|delta_ticks
operator|%
name|c
operator|->
name|initial
expr_stmt|;
if|if
condition|(
name|latch
condition|)
block|{
name|c
operator|->
name|olbyte
operator|=
literal|2
expr_stmt|;
name|c
operator|->
name|ol
index|[
literal|1
index|]
operator|=
name|lval
expr_stmt|;
comment|/* LSB */
name|c
operator|->
name|ol
index|[
literal|0
index|]
operator|=
name|lval
operator|>>
literal|8
expr_stmt|;
comment|/* MSB */
block|}
return|return
operator|(
name|lval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pit_readback1
parameter_list|(
name|struct
name|vatpit
modifier|*
name|vatpit
parameter_list|,
name|int
name|channel
parameter_list|,
name|uint8_t
name|cmd
parameter_list|)
block|{
name|struct
name|channel
modifier|*
name|c
decl_stmt|;
name|c
operator|=
operator|&
name|vatpit
operator|->
name|channel
index|[
name|channel
index|]
expr_stmt|;
comment|/* 	 * Latch the count/status of the timer if not already latched. 	 * N.B. that the count/status latch-select bits are active-low. 	 */
if|if
condition|(
operator|!
operator|(
name|cmd
operator|&
name|TIMER_RB_LCTR
operator|)
operator|&&
operator|!
name|c
operator|->
name|olbyte
condition|)
block|{
operator|(
name|void
operator|)
name|pit_update_counter
argument_list|(
name|vatpit
argument_list|,
name|c
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|cmd
operator|&
name|TIMER_RB_LSTATUS
operator|)
operator|&&
operator|!
name|c
operator|->
name|slatched
condition|)
block|{
name|c
operator|->
name|slatched
operator|=
name|true
expr_stmt|;
comment|/* 		 * For mode 0, see if the elapsed time is greater 		 * than the initial value - this results in the 		 * output pin being set to 1 in the status byte. 		 */
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|TIMER_INTTC
operator|&&
name|vatpit_get_out
argument_list|(
name|vatpit
argument_list|,
name|channel
argument_list|)
condition|)
name|c
operator|->
name|status
operator||=
name|TIMER_STS_OUT
expr_stmt|;
else|else
name|c
operator|->
name|status
operator|&=
operator|~
name|TIMER_STS_OUT
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pit_readback
parameter_list|(
name|struct
name|vatpit
modifier|*
name|vatpit
parameter_list|,
name|uint8_t
name|cmd
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * The readback command can apply to all timers. 	 */
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
name|TIMER_RB_CTR_0
condition|)
name|error
operator|=
name|pit_readback1
argument_list|(
name|vatpit
argument_list|,
literal|0
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|cmd
operator|&
name|TIMER_RB_CTR_1
condition|)
name|error
operator|=
name|pit_readback1
argument_list|(
name|vatpit
argument_list|,
literal|1
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|cmd
operator|&
name|TIMER_RB_CTR_2
condition|)
name|error
operator|=
name|pit_readback1
argument_list|(
name|vatpit
argument_list|,
literal|2
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vatpit_update_mode
parameter_list|(
name|struct
name|vatpit
modifier|*
name|vatpit
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|struct
name|channel
modifier|*
name|c
decl_stmt|;
name|int
name|sel
decl_stmt|,
name|rw
decl_stmt|,
name|mode
decl_stmt|;
name|sel
operator|=
name|val
operator|&
name|TIMER_SEL_MASK
expr_stmt|;
name|rw
operator|=
name|val
operator|&
name|TIMER_RW_MASK
expr_stmt|;
name|mode
operator|=
name|val
operator|&
name|TIMER_MODE_MASK
expr_stmt|;
if|if
condition|(
name|sel
operator|==
name|TIMER_SEL_READBACK
condition|)
return|return
operator|(
name|pit_readback
argument_list|(
name|vatpit
argument_list|,
name|val
argument_list|)
operator|)
return|;
if|if
condition|(
name|rw
operator|!=
name|TIMER_LATCH
operator|&&
name|rw
operator|!=
name|TIMER_16BIT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|rw
operator|!=
name|TIMER_LATCH
condition|)
block|{
comment|/* 		 * Counter mode is not affected when issuing a 		 * latch command. 		 */
if|if
condition|(
name|mode
operator|!=
name|TIMER_INTTC
operator|&&
name|mode
operator|!=
name|TIMER_RATEGEN
operator|&&
name|mode
operator|!=
name|TIMER_SQWAVE
operator|&&
name|mode
operator|!=
name|TIMER_SWSTROBE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|c
operator|=
operator|&
name|vatpit
operator|->
name|channel
index|[
name|sel
operator|>>
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|TIMER_LATCH
condition|)
name|pit_update_counter
argument_list|(
name|vatpit
argument_list|,
name|c
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
block|{
name|c
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|c
operator|->
name|olbyte
operator|=
literal|0
expr_stmt|;
comment|/* reset latch after reprogramming */
name|c
operator|->
name|status
operator||=
name|TIMER_STS_NULLCNT
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vatpit_handler
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|bool
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|)
block|{
name|struct
name|vatpit
modifier|*
name|vatpit
decl_stmt|;
name|struct
name|channel
modifier|*
name|c
decl_stmt|;
name|uint8_t
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vatpit
operator|=
name|vm_atpit
argument_list|(
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|val
operator|=
operator|*
name|eax
expr_stmt|;
if|if
condition|(
name|port
operator|==
name|TIMER_MODE
condition|)
block|{
if|if
condition|(
name|in
condition|)
block|{
name|VM_CTR0
argument_list|(
name|vatpit
operator|->
name|vm
argument_list|,
literal|"vatpit attempt to read mode"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|VATPIT_LOCK
argument_list|(
name|vatpit
argument_list|)
expr_stmt|;
name|error
operator|=
name|vatpit_update_mode
argument_list|(
name|vatpit
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|VATPIT_UNLOCK
argument_list|(
name|vatpit
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* counter ports */
name|KASSERT
argument_list|(
name|port
operator|>=
name|TIMER_CNTR0
operator|&&
name|port
operator|<=
name|TIMER_CNTR2
argument_list|,
operator|(
literal|"invalid port 0x%x"
operator|,
name|port
operator|)
argument_list|)
expr_stmt|;
name|c
operator|=
operator|&
name|vatpit
operator|->
name|channel
index|[
name|port
operator|-
name|TIMER_CNTR0
index|]
expr_stmt|;
name|VATPIT_LOCK
argument_list|(
name|vatpit
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|&&
name|c
operator|->
name|slatched
condition|)
block|{
comment|/* 		 * Return the status byte if latched 		 */
operator|*
name|eax
operator|=
name|c
operator|->
name|status
expr_stmt|;
name|c
operator|->
name|slatched
operator|=
name|false
expr_stmt|;
name|c
operator|->
name|status
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
condition|)
block|{
comment|/* 		 * The spec says that once the output latch is completely 		 * read it should revert to "following" the counter. Use 		 * the free running counter for this case (i.e. Linux 		 * TSC calibration). Assuming the access mode is 16-bit, 		 * toggle the MSB/LSB bit on each read. 		 */
if|if
condition|(
name|c
operator|->
name|olbyte
operator|==
literal|0
condition|)
block|{
name|uint16_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|pit_update_counter
argument_list|(
name|vatpit
argument_list|,
name|c
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|frbyte
condition|)
name|tmp
operator|>>=
literal|8
expr_stmt|;
name|tmp
operator|&=
literal|0xff
expr_stmt|;
operator|*
name|eax
operator|=
name|tmp
expr_stmt|;
name|c
operator|->
name|frbyte
operator|^=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|eax
operator|=
name|c
operator|->
name|ol
index|[
operator|--
name|c
operator|->
name|olbyte
index|]
expr_stmt|;
block|}
else|else
block|{
name|c
operator|->
name|cr
index|[
name|c
operator|->
name|crbyte
operator|++
index|]
operator|=
operator|*
name|eax
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|crbyte
operator|==
literal|2
condition|)
block|{
name|c
operator|->
name|status
operator|&=
operator|~
name|TIMER_STS_NULLCNT
expr_stmt|;
name|c
operator|->
name|frbyte
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|crbyte
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|initial
operator|=
name|c
operator|->
name|cr
index|[
literal|0
index|]
operator||
operator|(
name|uint16_t
operator|)
name|c
operator|->
name|cr
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|c
operator|->
name|now_sbt
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
comment|/* Start an interval timer for channel 0 */
if|if
condition|(
name|port
operator|==
name|TIMER_CNTR0
condition|)
block|{
name|c
operator|->
name|callout_sbt
operator|=
name|c
operator|->
name|now_sbt
expr_stmt|;
name|pit_timer_start_cntr0
argument_list|(
name|vatpit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|initial
operator|==
literal|0
condition|)
name|c
operator|->
name|initial
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
name|VATPIT_UNLOCK
argument_list|(
name|vatpit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vatpit_nmisc_handler
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|bool
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|)
block|{
name|struct
name|vatpit
modifier|*
name|vatpit
decl_stmt|;
name|vatpit
operator|=
name|vm_atpit
argument_list|(
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
condition|)
block|{
name|VATPIT_LOCK
argument_list|(
name|vatpit
argument_list|)
expr_stmt|;
if|if
condition|(
name|vatpit_get_out
argument_list|(
name|vatpit
argument_list|,
literal|2
argument_list|)
condition|)
operator|*
name|eax
operator|=
name|TMR2_OUT_STS
expr_stmt|;
else|else
operator|*
name|eax
operator|=
literal|0
expr_stmt|;
name|VATPIT_UNLOCK
argument_list|(
name|vatpit
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|vatpit
modifier|*
name|vatpit_init
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|)
block|{
name|struct
name|vatpit
modifier|*
name|vatpit
decl_stmt|;
name|struct
name|bintime
name|bt
decl_stmt|;
name|struct
name|vatpit_callout_arg
modifier|*
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vatpit
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vatpit
argument_list|)
argument_list|,
name|M_VATPIT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vatpit
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|vatpit
operator|->
name|mtx
argument_list|,
literal|"vatpit lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|FREQ2BT
argument_list|(
name|PIT_8254_FREQ
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|vatpit
operator|->
name|freq_sbt
operator|=
name|bttosbt
argument_list|(
name|bt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|callout_init
argument_list|(
operator|&
name|vatpit
operator|->
name|channel
index|[
name|i
index|]
operator|.
name|callout
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|arg
operator|=
operator|&
name|vatpit
operator|->
name|channel
index|[
name|i
index|]
operator|.
name|callout_arg
expr_stmt|;
name|arg
operator|->
name|vatpit
operator|=
name|vatpit
expr_stmt|;
name|arg
operator|->
name|channel_num
operator|=
name|i
expr_stmt|;
block|}
return|return
operator|(
name|vatpit
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vatpit_cleanup
parameter_list|(
name|struct
name|vatpit
modifier|*
name|vatpit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|callout_drain
argument_list|(
operator|&
name|vatpit
operator|->
name|channel
index|[
name|i
index|]
operator|.
name|callout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vatpit
argument_list|,
name|M_VATPIT
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

