begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 Tycho Nightingale<tycho.nightingale@pluribusnetworks.com>  * Copyright (c) 2013 Neel Natu<neel@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpi_hpet.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm_dev.h>
end_include

begin_include
include|#
directive|include
file|"vmm_lapic.h"
end_include

begin_include
include|#
directive|include
file|"vioapic.h"
end_include

begin_include
include|#
directive|include
file|"vhpet.h"
end_include

begin_include
include|#
directive|include
file|"vmm_ktr.h"
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VHPET
argument_list|,
literal|"vhpet"
argument_list|,
literal|"bhyve virtual hpet"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|HPET_FREQ
value|10000000
end_define

begin_comment
comment|/* 10.0 Mhz */
end_comment

begin_define
define|#
directive|define
name|FS_PER_S
value|1000000000000000ul
end_define

begin_comment
comment|/* Timer N Configuration and Capabilities Register */
end_comment

begin_define
define|#
directive|define
name|HPET_TCAP_RO_MASK
value|(HPET_TCAP_INT_ROUTE 	|		\ 				 HPET_TCAP_FSB_INT_DEL	|		\ 				 HPET_TCAP_SIZE		|		\ 				 HPET_TCAP_PER_INT)
end_define

begin_comment
comment|/*  * HPET requires at least 3 timers and up to 32 timers per block.  */
end_comment

begin_define
define|#
directive|define
name|VHPET_NUM_TIMERS
value|8
end_define

begin_expr_stmt
name|CTASSERT
argument_list|(
name|VHPET_NUM_TIMERS
operator|>=
literal|3
operator|&&
name|VHPET_NUM_TIMERS
operator|<=
literal|32
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|vhpet_callout_arg
block|{
name|struct
name|vhpet
modifier|*
name|vhpet
decl_stmt|;
name|int
name|timer_num
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vhpet
block|{
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
name|struct
name|mtx
name|mtx
decl_stmt|;
name|sbintime_t
name|freq_sbt
decl_stmt|;
name|uint64_t
name|config
decl_stmt|;
comment|/* Configuration */
name|uint64_t
name|isr
decl_stmt|;
comment|/* Interrupt Status */
name|uint32_t
name|counter
decl_stmt|;
comment|/* HPET Counter */
name|sbintime_t
name|counter_sbt
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|cap_config
decl_stmt|;
comment|/* Configuration */
name|uint64_t
name|msireg
decl_stmt|;
comment|/* FSB interrupt routing */
name|uint32_t
name|compval
decl_stmt|;
comment|/* Comparator */
name|uint32_t
name|comprate
decl_stmt|;
name|struct
name|callout
name|callout
decl_stmt|;
name|struct
name|vhpet_callout_arg
name|arg
decl_stmt|;
block|}
name|timer
index|[
name|VHPET_NUM_TIMERS
index|]
struct|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|VHPET_LOCK
parameter_list|(
name|vhp
parameter_list|)
value|mtx_lock(&((vhp)->mtx))
end_define

begin_define
define|#
directive|define
name|VHPET_UNLOCK
parameter_list|(
name|vhp
parameter_list|)
value|mtx_unlock(&((vhp)->mtx))
end_define

begin_function
specifier|static
name|uint64_t
name|vhpet_capabilities
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|cap
init|=
literal|0
decl_stmt|;
name|cap
operator||=
literal|0x8086
operator|<<
literal|16
expr_stmt|;
comment|/* vendor id */
name|cap
operator||=
name|HPET_CAP_LEG_RT
expr_stmt|;
comment|/* legacy routing capable */
name|cap
operator||=
operator|(
name|VHPET_NUM_TIMERS
operator|-
literal|1
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* number of timers */
name|cap
operator||=
literal|1
expr_stmt|;
comment|/* revision */
name|cap
operator|&=
operator|~
name|HPET_CAP_COUNT_SIZE
expr_stmt|;
comment|/* 32-bit timer */
name|cap
operator|&=
literal|0xffffffff
expr_stmt|;
name|cap
operator||=
operator|(
name|FS_PER_S
operator|/
name|HPET_FREQ
operator|)
operator|<<
literal|32
expr_stmt|;
comment|/* tick period in fs */
return|return
operator|(
name|cap
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|bool
name|vhpet_counter_enabled
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|)
block|{
return|return
operator|(
operator|(
name|vhpet
operator|->
name|config
operator|&
name|HPET_CNF_ENABLE
operator|)
condition|?
name|true
else|:
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|bool
name|vhpet_timer_msi_enabled
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|const
name|uint64_t
name|msi_enable
init|=
name|HPET_TCAP_FSB_INT_DEL
operator||
name|HPET_TCNF_FSB_EN
decl_stmt|;
comment|/* 	 * LegacyReplacement Route configuration takes precedence over MSI 	 * for timers 0 and 1. 	 */
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|n
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|vhpet
operator|->
name|config
operator|&
name|HPET_CNF_LEG_RT
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|&
name|msi_enable
operator|)
operator|==
name|msi_enable
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|vhpet_timer_ioapic_pin
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
comment|/* 	 * If the timer is configured to use MSI then treat it as if the 	 * timer is not connected to the ioapic. 	 */
if|if
condition|(
name|vhpet_timer_msi_enabled
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|vhpet
operator|->
name|config
operator|&
name|HPET_CNF_LEG_RT
condition|)
block|{
comment|/* 		 * In "legacy routing" timers 0 and 1 are connected to 		 * ioapic pins 2 and 8 respectively. 		 */
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
literal|1
case|:
return|return
operator|(
literal|8
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|&
name|HPET_TCNF_INT_ROUTE
operator|)
operator|>>
literal|9
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|vhpet_counter
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|bool
name|latch
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|sbintime_t
name|cur_sbt
decl_stmt|,
name|delta_sbt
decl_stmt|;
name|val
operator|=
name|vhpet
operator|->
name|counter
expr_stmt|;
if|if
condition|(
name|vhpet_counter_enabled
argument_list|(
name|vhpet
argument_list|)
condition|)
block|{
name|cur_sbt
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
name|delta_sbt
operator|=
name|cur_sbt
operator|-
name|vhpet
operator|->
name|counter_sbt
expr_stmt|;
name|KASSERT
argument_list|(
name|delta_sbt
operator|>=
literal|0
argument_list|,
operator|(
literal|"vhpet counter went backwards: %#lx to %#lx"
operator|,
name|vhpet
operator|->
name|counter_sbt
operator|,
name|cur_sbt
operator|)
argument_list|)
expr_stmt|;
name|val
operator|+=
name|delta_sbt
operator|/
name|vhpet
operator|->
name|freq_sbt
expr_stmt|;
comment|/* 		 * Keep track of the last value of the main counter that 		 * was read by the guest. 		 */
if|if
condition|(
name|latch
condition|)
block|{
name|vhpet
operator|->
name|counter
operator|=
name|val
expr_stmt|;
name|vhpet
operator|->
name|counter_sbt
operator|=
name|cur_sbt
expr_stmt|;
block|}
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_timer_clear_isr
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|pin
decl_stmt|;
if|if
condition|(
name|vhpet
operator|->
name|isr
operator|&
operator|(
literal|1
operator|<<
name|n
operator|)
condition|)
block|{
name|pin
operator|=
name|vhpet_timer_ioapic_pin
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pin
operator|!=
literal|0
argument_list|,
operator|(
literal|"vhpet timer %d irq incorrectly routed"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|vioapic_deassert_irq
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
name|pin
argument_list|)
expr_stmt|;
name|vhpet
operator|->
name|isr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|n
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|bool
name|vhpet_periodic_timer
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
operator|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|&
name|HPET_TCNF_TYPE
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|bool
name|vhpet_timer_interrupt_enabled
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
operator|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|&
name|HPET_TCNF_INT_ENB
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|bool
name|vhpet_timer_edge_trig
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|!
name|vhpet_timer_msi_enabled
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
argument_list|,
operator|(
literal|"vhpet_timer_edge_trig: "
literal|"timer %d is using MSI"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
comment|/* The legacy replacement interrupts are always edge triggered */
if|if
condition|(
name|vhpet
operator|->
name|config
operator|&
name|HPET_CNF_LEG_RT
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|n
operator|==
literal|1
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|&
name|HPET_TCNF_INT_TYPE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_timer_interrupt
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|apicid
decl_stmt|,
name|vector
decl_stmt|,
name|vcpuid
decl_stmt|,
name|pin
decl_stmt|;
name|cpuset_t
name|dmask
decl_stmt|;
comment|/* If interrupts are not enabled for this timer then just return. */
if|if
condition|(
operator|!
name|vhpet_timer_interrupt_enabled
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
return|return;
comment|/* 	 * If a level triggered interrupt is already asserted then just return. 	 */
if|if
condition|(
operator|(
name|vhpet
operator|->
name|isr
operator|&
operator|(
literal|1
operator|<<
name|n
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d intr is already asserted"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vhpet_timer_msi_enabled
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
block|{
comment|/* 		 * XXX should have an API 'vlapic_deliver_msi(vm, addr, data)' 		 * - assuming physical delivery mode 		 * - no need to interpret contents of 'msireg' here 		 */
name|vector
operator|=
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|msireg
operator|&
literal|0xff
expr_stmt|;
name|apicid
operator|=
operator|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|msireg
operator|>>
operator|(
literal|32
operator|+
literal|12
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|apicid
operator|!=
literal|0xff
condition|)
block|{
comment|/* unicast */
name|vcpuid
operator|=
name|vm_apicid2vcpuid
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
name|apicid
argument_list|)
expr_stmt|;
name|lapic_intr_edge
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* broadcast */
name|dmask
operator|=
name|vm_active_cpus
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|vcpuid
operator|=
name|CPU_FFS
argument_list|(
operator|&
name|dmask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vcpuid
operator|--
expr_stmt|;
name|CPU_CLR
argument_list|(
name|vcpuid
argument_list|,
operator|&
name|dmask
argument_list|)
expr_stmt|;
name|lapic_intr_edge
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
name|pin
operator|=
name|vhpet_timer_ioapic_pin
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|pin
operator|==
literal|0
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d intr is not routed to ioapic"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vhpet_timer_edge_trig
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|vioapic_pulse_irq
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
name|pin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vhpet
operator|->
name|isr
operator||=
literal|1
operator|<<
name|n
expr_stmt|;
name|vioapic_assert_irq
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
name|pin
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_adjust_compval
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|,
name|uint32_t
name|counter
parameter_list|)
block|{
name|uint32_t
name|compval
decl_stmt|,
name|comprate
decl_stmt|,
name|compnext
decl_stmt|;
name|KASSERT
argument_list|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|comprate
operator|!=
literal|0
argument_list|,
operator|(
literal|"hpet t%d is not periodic"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|compval
operator|=
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|compval
expr_stmt|;
name|comprate
operator|=
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|comprate
expr_stmt|;
comment|/* 	 * Calculate the comparator value to be used for the next periodic 	 * interrupt. 	 * 	 * This function is commonly called from the callout handler. 	 * In this scenario the 'counter' is ahead of 'compval'. To find 	 * the next value to program into the accumulator we divide the 	 * number space between 'compval' and 'counter' into 'comprate' 	 * sized units. The 'compval' is rounded up such that is "ahead" 	 * of 'counter'. 	 */
name|compnext
operator|=
name|compval
operator|+
operator|(
operator|(
name|counter
operator|-
name|compval
operator|)
operator|/
name|comprate
operator|+
literal|1
operator|)
operator|*
name|comprate
expr_stmt|;
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|compval
operator|=
name|compnext
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_handler
parameter_list|(
name|void
modifier|*
name|a
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|uint32_t
name|counter
decl_stmt|;
name|sbintime_t
name|sbt
decl_stmt|;
name|struct
name|vhpet
modifier|*
name|vhpet
decl_stmt|;
name|struct
name|callout
modifier|*
name|callout
decl_stmt|;
name|struct
name|vhpet_callout_arg
modifier|*
name|arg
decl_stmt|;
name|arg
operator|=
name|a
expr_stmt|;
name|vhpet
operator|=
name|arg
operator|->
name|vhpet
expr_stmt|;
name|n
operator|=
name|arg
operator|->
name|timer_num
expr_stmt|;
name|callout
operator|=
operator|&
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|callout
expr_stmt|;
name|VM_CTR1
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d fired"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|VHPET_LOCK
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
name|callout
argument_list|)
condition|)
comment|/* callout was reset */
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|callout_active
argument_list|(
name|callout
argument_list|)
condition|)
comment|/* callout was stopped */
goto|goto
name|done
goto|;
name|callout_deactivate
argument_list|(
name|callout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vhpet_counter_enabled
argument_list|(
name|vhpet
argument_list|)
condition|)
name|panic
argument_list|(
literal|"vhpet(%p) callout with counter disabled"
argument_list|,
name|vhpet
argument_list|)
expr_stmt|;
name|counter
operator|=
name|vhpet_counter
argument_list|(
name|vhpet
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Update the accumulator for periodic timers */
if|if
condition|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|comprate
operator|!=
literal|0
condition|)
name|vhpet_adjust_compval
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|sbt
operator|=
operator|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|compval
operator|-
name|counter
operator|)
operator|*
name|vhpet
operator|->
name|freq_sbt
expr_stmt|;
name|callout_reset_sbt
argument_list|(
name|callout
argument_list|,
name|sbt
argument_list|,
literal|0
argument_list|,
name|vhpet_handler
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vhpet_timer_interrupt
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|done
label|:
name|VHPET_UNLOCK
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_stop_timer
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|callout_stop
argument_list|(
operator|&
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|callout
argument_list|)
expr_stmt|;
name|vhpet_timer_clear_isr
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_start_timer
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|uint32_t
name|counter
decl_stmt|,
name|delta
decl_stmt|,
name|delta2
decl_stmt|;
name|sbintime_t
name|sbt
decl_stmt|;
name|counter
operator|=
name|vhpet_counter
argument_list|(
name|vhpet
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|comprate
operator|!=
literal|0
condition|)
name|vhpet_adjust_compval
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|delta
operator|=
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|compval
operator|-
name|counter
expr_stmt|;
comment|/* 	 * In one-shot mode the guest will typically read the main counter 	 * before programming the comparator. We can use this heuristic to 	 * figure out whether the expiration time is in the past. If this 	 * is the case we schedule the callout to fire immediately. 	 */
if|if
condition|(
operator|!
name|vhpet_periodic_timer
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|delta2
operator|=
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|compval
operator|-
name|vhpet
operator|->
name|counter
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|delta2
condition|)
block|{
name|VM_CTR3
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d comparator value is in "
literal|"the past: %u/%u/%u"
argument_list|,
name|counter
argument_list|,
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|compval
argument_list|,
name|vhpet
operator|->
name|counter
argument_list|)
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|sbt
operator|=
name|delta
operator|*
name|vhpet
operator|->
name|freq_sbt
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|callout
argument_list|,
name|sbt
argument_list|,
literal|0
argument_list|,
name|vhpet_handler
argument_list|,
operator|&
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_start_counting
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vhpet
operator|->
name|counter_sbt
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VHPET_NUM_TIMERS
condition|;
name|i
operator|++
control|)
name|vhpet_start_timer
argument_list|(
name|vhpet
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_stop_counting
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VHPET_NUM_TIMERS
condition|;
name|i
operator|++
control|)
name|vhpet_stop_timer
argument_list|(
name|vhpet
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|update_register
parameter_list|(
name|uint64_t
modifier|*
name|regptr
parameter_list|,
name|uint64_t
name|data
parameter_list|,
name|uint64_t
name|mask
parameter_list|)
block|{
operator|*
name|regptr
operator|&=
operator|~
name|mask
expr_stmt|;
operator|*
name|regptr
operator||=
operator|(
name|data
operator|&
name|mask
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_timer_update_config
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|,
name|uint64_t
name|data
parameter_list|,
name|uint64_t
name|mask
parameter_list|)
block|{
name|bool
name|clear_isr
decl_stmt|;
name|int
name|old_pin
decl_stmt|,
name|new_pin
decl_stmt|;
name|uint32_t
name|allowed_irqs
decl_stmt|;
name|uint64_t
name|oldval
decl_stmt|,
name|newval
decl_stmt|;
if|if
condition|(
name|vhpet_timer_msi_enabled
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
operator|||
name|vhpet_timer_edge_trig
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
block|{
if|if
condition|(
name|vhpet
operator|->
name|isr
operator|&
operator|(
literal|1
operator|<<
name|n
operator|)
condition|)
name|panic
argument_list|(
literal|"vhpet timer %d isr should not be asserted"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|old_pin
operator|=
name|vhpet_timer_ioapic_pin
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
expr_stmt|;
name|newval
operator|=
name|oldval
expr_stmt|;
name|update_register
argument_list|(
operator|&
name|newval
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|newval
operator|&=
operator|~
operator|(
name|HPET_TCAP_RO_MASK
operator||
name|HPET_TCNF_32MODE
operator|)
expr_stmt|;
name|newval
operator||=
name|oldval
operator|&
name|HPET_TCAP_RO_MASK
expr_stmt|;
if|if
condition|(
name|newval
operator|==
name|oldval
condition|)
return|return;
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|=
name|newval
expr_stmt|;
name|VM_CTR2
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d cap_config set to 0x%016x"
argument_list|,
name|n
argument_list|,
name|newval
argument_list|)
expr_stmt|;
comment|/* 	 * Validate the interrupt routing in the HPET_TCNF_INT_ROUTE field. 	 * If it does not match the bits set in HPET_TCAP_INT_ROUTE then set 	 * it to the default value of 0. 	 */
name|allowed_irqs
operator|=
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|>>
literal|32
expr_stmt|;
name|new_pin
operator|=
name|vhpet_timer_ioapic_pin
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pin
operator|!=
literal|0
operator|&&
operator|(
name|allowed_irqs
operator|&
operator|(
literal|1
operator|<<
name|new_pin
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|VM_CTR3
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d configured invalid irq %d, "
literal|"allowed_irqs 0x%08x"
argument_list|,
name|n
argument_list|,
name|new_pin
argument_list|,
name|allowed_irqs
argument_list|)
expr_stmt|;
name|new_pin
operator|=
literal|0
expr_stmt|;
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|&=
operator|~
name|HPET_TCNF_INT_ROUTE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vhpet_periodic_timer
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|comprate
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the timer's ISR bit is set then clear it in the following cases: 	 * - interrupt is disabled 	 * - interrupt type is changed from level to edge or fsb. 	 * - interrupt routing is changed 	 * 	 * This is to ensure that this timer's level triggered interrupt does 	 * not remain asserted forever. 	 */
if|if
condition|(
name|vhpet
operator|->
name|isr
operator|&
operator|(
literal|1
operator|<<
name|n
operator|)
condition|)
block|{
name|KASSERT
argument_list|(
name|old_pin
operator|!=
literal|0
argument_list|,
operator|(
literal|"timer %d isr asserted to ioapic pin %d"
operator|,
name|n
operator|,
name|old_pin
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vhpet_timer_interrupt_enabled
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
name|clear_isr
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|vhpet_timer_msi_enabled
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
name|clear_isr
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|vhpet_timer_edge_trig
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
name|clear_isr
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|vhpet_timer_ioapic_pin
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
operator|!=
name|old_pin
condition|)
name|clear_isr
operator|=
name|true
expr_stmt|;
else|else
name|clear_isr
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|clear_isr
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d isr cleared due to "
literal|"configuration change"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|vioapic_deassert_irq
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
name|old_pin
argument_list|)
expr_stmt|;
name|vhpet
operator|->
name|isr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|n
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|vhpet_mmio_write
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|uint64_t
name|val
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vhpet
modifier|*
name|vhpet
decl_stmt|;
name|uint64_t
name|data
decl_stmt|,
name|mask
decl_stmt|,
name|oldval
decl_stmt|,
name|val64
decl_stmt|;
name|uint32_t
name|isr_clear_mask
decl_stmt|,
name|old_compval
decl_stmt|,
name|old_comprate
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|vhpet
operator|=
name|vm_hpet
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gpa
operator|-
name|VHPET_BASE
expr_stmt|;
name|VHPET_LOCK
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
comment|/* Accesses to the HPET should be 4 or 8 bytes wide */
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
name|mask
operator|=
literal|0xffffffffffffffff
expr_stmt|;
name|data
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|mask
operator|=
literal|0xffffffff
expr_stmt|;
name|data
operator|=
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
literal|0x4
operator|)
operator|!=
literal|0
condition|)
block|{
name|mask
operator|<<=
literal|32
expr_stmt|;
name|data
operator|<<=
literal|32
expr_stmt|;
block|}
break|break;
default|default:
name|VM_CTR2
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet invalid mmio write: "
literal|"offset 0x%08x, size %d"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Access to the HPET should be naturally aligned to its width */
if|if
condition|(
name|offset
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet invalid mmio write: "
literal|"offset 0x%08x, size %d"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_CONFIG
operator|||
name|offset
operator|==
name|HPET_CONFIG
operator|+
literal|4
condition|)
block|{
name|oldval
operator|=
name|vhpet
operator|->
name|config
expr_stmt|;
name|update_register
argument_list|(
operator|&
name|vhpet
operator|->
name|config
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldval
operator|^
name|vhpet
operator|->
name|config
operator|)
operator|&
name|HPET_CNF_ENABLE
condition|)
block|{
if|if
condition|(
name|vhpet_counter_enabled
argument_list|(
name|vhpet
argument_list|)
condition|)
block|{
name|vhpet_start_counting
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
name|VM_CTR0
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet enabled"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vhpet_stop_counting
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
name|VM_CTR0
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet disabled"
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_ISR
operator|||
name|offset
operator|==
name|HPET_ISR
operator|+
literal|4
condition|)
block|{
name|isr_clear_mask
operator|=
name|vhpet
operator|->
name|isr
operator|&
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VHPET_NUM_TIMERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|isr_clear_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d isr cleared"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vhpet_timer_clear_isr
argument_list|(
name|vhpet
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_MAIN_COUNTER
operator|||
name|offset
operator|==
name|HPET_MAIN_COUNTER
operator|+
literal|4
condition|)
block|{
comment|/* Zero-extend the counter to 64-bits before updating it */
name|val64
operator|=
name|vhpet
operator|->
name|counter
expr_stmt|;
name|update_register
argument_list|(
operator|&
name|val64
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|vhpet
operator|->
name|counter
operator|=
name|val64
expr_stmt|;
if|if
condition|(
name|vhpet_counter_enabled
argument_list|(
name|vhpet
argument_list|)
condition|)
name|vhpet_start_counting
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VHPET_NUM_TIMERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offset
operator|==
name|HPET_TIMER_CAP_CNF
argument_list|(
name|i
argument_list|)
operator|||
name|offset
operator|==
name|HPET_TIMER_CAP_CNF
argument_list|(
name|i
argument_list|)
operator|+
literal|4
condition|)
block|{
name|vhpet_timer_update_config
argument_list|(
name|vhpet
argument_list|,
name|i
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_TIMER_COMPARATOR
argument_list|(
name|i
argument_list|)
operator|||
name|offset
operator|==
name|HPET_TIMER_COMPARATOR
argument_list|(
name|i
argument_list|)
operator|+
literal|4
condition|)
block|{
name|old_compval
operator|=
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|compval
expr_stmt|;
name|old_comprate
operator|=
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|comprate
expr_stmt|;
if|if
condition|(
name|vhpet_periodic_timer
argument_list|(
name|vhpet
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* 				 * In periodic mode writes to the comparator 				 * change the 'compval' register only if the 				 * HPET_TCNF_VAL_SET bit is set in the config 				 * register. 				 */
name|val64
operator|=
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|comprate
expr_stmt|;
name|update_register
argument_list|(
operator|&
name|val64
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|comprate
operator|=
name|val64
expr_stmt|;
if|if
condition|(
operator|(
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|cap_config
operator|&
name|HPET_TCNF_VAL_SET
operator|)
operator|!=
literal|0
condition|)
block|{
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|compval
operator|=
name|val64
expr_stmt|;
block|}
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|comprate
operator|==
literal|0
argument_list|,
operator|(
literal|"vhpet one-shot timer %d has invalid "
literal|"rate %u"
operator|,
name|i
operator|,
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|comprate
operator|)
argument_list|)
expr_stmt|;
name|val64
operator|=
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|compval
expr_stmt|;
name|update_register
argument_list|(
operator|&
name|val64
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|compval
operator|=
name|val64
expr_stmt|;
block|}
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|cap_config
operator|&=
operator|~
name|HPET_TCNF_VAL_SET
expr_stmt|;
if|if
condition|(
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|compval
operator|!=
name|old_compval
operator|||
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|comprate
operator|!=
name|old_comprate
condition|)
block|{
if|if
condition|(
name|vhpet_counter_enabled
argument_list|(
name|vhpet
argument_list|)
condition|)
name|vhpet_start_timer
argument_list|(
name|vhpet
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_TIMER_FSB_VAL
argument_list|(
name|i
argument_list|)
operator|||
name|offset
operator|==
name|HPET_TIMER_FSB_ADDR
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|update_register
argument_list|(
operator|&
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|msireg
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|done
label|:
name|VHPET_UNLOCK
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vhpet_mmio_read
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|uint64_t
modifier|*
name|rval
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|vhpet
modifier|*
name|vhpet
decl_stmt|;
name|uint64_t
name|data
decl_stmt|;
name|vhpet
operator|=
name|vm_hpet
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gpa
operator|-
name|VHPET_BASE
expr_stmt|;
name|VHPET_LOCK
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
comment|/* Accesses to the HPET should be 4 or 8 bytes wide */
if|if
condition|(
name|size
operator|!=
literal|4
operator|&&
name|size
operator|!=
literal|8
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet invalid mmio read: "
literal|"offset 0x%08x, size %d"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Access to the HPET should be naturally aligned to its width */
if|if
condition|(
name|offset
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet invalid mmio read: "
literal|"offset 0x%08x, size %d"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_CAPABILITIES
operator|||
name|offset
operator|==
name|HPET_CAPABILITIES
operator|+
literal|4
condition|)
block|{
name|data
operator|=
name|vhpet_capabilities
argument_list|()
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_CONFIG
operator|||
name|offset
operator|==
name|HPET_CONFIG
operator|+
literal|4
condition|)
block|{
name|data
operator|=
name|vhpet
operator|->
name|config
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_ISR
operator|||
name|offset
operator|==
name|HPET_ISR
operator|+
literal|4
condition|)
block|{
name|data
operator|=
name|vhpet
operator|->
name|isr
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_MAIN_COUNTER
operator|||
name|offset
operator|==
name|HPET_MAIN_COUNTER
operator|+
literal|4
condition|)
block|{
name|data
operator|=
name|vhpet_counter
argument_list|(
name|vhpet
argument_list|,
name|true
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VHPET_NUM_TIMERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offset
operator|==
name|HPET_TIMER_CAP_CNF
argument_list|(
name|i
argument_list|)
operator|||
name|offset
operator|==
name|HPET_TIMER_CAP_CNF
argument_list|(
name|i
argument_list|)
operator|+
literal|4
condition|)
block|{
name|data
operator|=
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|cap_config
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_TIMER_COMPARATOR
argument_list|(
name|i
argument_list|)
operator|||
name|offset
operator|==
name|HPET_TIMER_COMPARATOR
argument_list|(
name|i
argument_list|)
operator|+
literal|4
condition|)
block|{
name|data
operator|=
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|compval
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_TIMER_FSB_VAL
argument_list|(
name|i
argument_list|)
operator|||
name|offset
operator|==
name|HPET_TIMER_FSB_ADDR
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|data
operator|=
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|msireg
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|VHPET_NUM_TIMERS
condition|)
name|data
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|VHPET_UNLOCK
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|offset
operator|&
literal|0x4
condition|)
name|data
operator|>>=
literal|32
expr_stmt|;
block|}
operator|*
name|rval
operator|=
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|vhpet
modifier|*
name|vhpet_init
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|pincount
decl_stmt|;
name|struct
name|vhpet
modifier|*
name|vhpet
decl_stmt|;
name|uint64_t
name|allowed_irqs
decl_stmt|;
name|struct
name|vhpet_callout_arg
modifier|*
name|arg
decl_stmt|;
name|struct
name|bintime
name|bt
decl_stmt|;
name|vhpet
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vhpet
argument_list|)
argument_list|,
name|M_VHPET
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vhpet
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|vhpet
operator|->
name|mtx
argument_list|,
literal|"vhpet lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|FREQ2BT
argument_list|(
name|HPET_FREQ
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|vhpet
operator|->
name|freq_sbt
operator|=
name|bttosbt
argument_list|(
name|bt
argument_list|)
expr_stmt|;
name|pincount
operator|=
name|vioapic_pincount
argument_list|(
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pincount
operator|>=
literal|24
condition|)
name|allowed_irqs
operator|=
literal|0x00f00000
expr_stmt|;
comment|/* irqs 20, 21, 22 and 23 */
else|else
name|allowed_irqs
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize HPET timer hardware state. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VHPET_NUM_TIMERS
condition|;
name|i
operator|++
control|)
block|{
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|cap_config
operator|=
name|allowed_irqs
operator|<<
literal|32
expr_stmt|;
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|cap_config
operator||=
name|HPET_TCAP_PER_INT
expr_stmt|;
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|cap_config
operator||=
name|HPET_TCAP_FSB_INT_DEL
expr_stmt|;
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|compval
operator|=
literal|0xffffffff
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|=
operator|&
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|arg
expr_stmt|;
name|arg
operator|->
name|vhpet
operator|=
name|vhpet
expr_stmt|;
name|arg
operator|->
name|timer_num
operator|=
name|i
expr_stmt|;
block|}
return|return
operator|(
name|vhpet
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vhpet_cleanup
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VHPET_NUM_TIMERS
condition|;
name|i
operator|++
control|)
name|callout_drain
argument_list|(
operator|&
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|callout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vhpet
argument_list|,
name|M_VHPET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vhpet_getcap
parameter_list|(
name|struct
name|vm_hpet_cap
modifier|*
name|cap
parameter_list|)
block|{
name|cap
operator|->
name|capabilities
operator|=
name|vhpet_capabilities
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

