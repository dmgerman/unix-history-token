begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 Tycho Nightingale<tycho.nightingale@pluribusnetworks.com>  * Copyright (c) 2013 Neel Natu<neel@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpi_hpet.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm_dev.h>
end_include

begin_include
include|#
directive|include
file|"vmm_lapic.h"
end_include

begin_include
include|#
directive|include
file|"vatpic.h"
end_include

begin_include
include|#
directive|include
file|"vioapic.h"
end_include

begin_include
include|#
directive|include
file|"vhpet.h"
end_include

begin_include
include|#
directive|include
file|"vmm_ktr.h"
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VHPET
argument_list|,
literal|"vhpet"
argument_list|,
literal|"bhyve virtual hpet"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|HPET_FREQ
value|10000000
end_define

begin_comment
comment|/* 10.0 Mhz */
end_comment

begin_define
define|#
directive|define
name|FS_PER_S
value|1000000000000000ul
end_define

begin_comment
comment|/* Timer N Configuration and Capabilities Register */
end_comment

begin_define
define|#
directive|define
name|HPET_TCAP_RO_MASK
value|(HPET_TCAP_INT_ROUTE 	|		\ 				 HPET_TCAP_FSB_INT_DEL	|		\ 				 HPET_TCAP_SIZE		|		\ 				 HPET_TCAP_PER_INT)
end_define

begin_comment
comment|/*  * HPET requires at least 3 timers and up to 32 timers per block.  */
end_comment

begin_define
define|#
directive|define
name|VHPET_NUM_TIMERS
value|8
end_define

begin_expr_stmt
name|CTASSERT
argument_list|(
name|VHPET_NUM_TIMERS
operator|>=
literal|3
operator|&&
name|VHPET_NUM_TIMERS
operator|<=
literal|32
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|vhpet_callout_arg
block|{
name|struct
name|vhpet
modifier|*
name|vhpet
decl_stmt|;
name|int
name|timer_num
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vhpet
block|{
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
name|struct
name|mtx
name|mtx
decl_stmt|;
name|sbintime_t
name|freq_sbt
decl_stmt|;
name|uint64_t
name|config
decl_stmt|;
comment|/* Configuration */
name|uint64_t
name|isr
decl_stmt|;
comment|/* Interrupt Status */
name|uint32_t
name|countbase
decl_stmt|;
comment|/* HPET counter base value */
name|sbintime_t
name|countbase_sbt
decl_stmt|;
comment|/* uptime corresponding to base value */
struct|struct
block|{
name|uint64_t
name|cap_config
decl_stmt|;
comment|/* Configuration */
name|uint64_t
name|msireg
decl_stmt|;
comment|/* FSB interrupt routing */
name|uint32_t
name|compval
decl_stmt|;
comment|/* Comparator */
name|uint32_t
name|comprate
decl_stmt|;
name|struct
name|callout
name|callout
decl_stmt|;
name|sbintime_t
name|callout_sbt
decl_stmt|;
comment|/* time when counter==compval */
name|struct
name|vhpet_callout_arg
name|arg
decl_stmt|;
block|}
name|timer
index|[
name|VHPET_NUM_TIMERS
index|]
struct|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|VHPET_LOCK
parameter_list|(
name|vhp
parameter_list|)
value|mtx_lock(&((vhp)->mtx))
end_define

begin_define
define|#
directive|define
name|VHPET_UNLOCK
parameter_list|(
name|vhp
parameter_list|)
value|mtx_unlock(&((vhp)->mtx))
end_define

begin_function_decl
specifier|static
name|void
name|vhpet_start_timer
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|,
name|uint32_t
name|counter
parameter_list|,
name|sbintime_t
name|now
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|uint64_t
name|vhpet_capabilities
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|cap
init|=
literal|0
decl_stmt|;
name|cap
operator||=
literal|0x8086
operator|<<
literal|16
expr_stmt|;
comment|/* vendor id */
name|cap
operator||=
operator|(
name|VHPET_NUM_TIMERS
operator|-
literal|1
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* number of timers */
name|cap
operator||=
literal|1
expr_stmt|;
comment|/* revision */
name|cap
operator|&=
operator|~
name|HPET_CAP_COUNT_SIZE
expr_stmt|;
comment|/* 32-bit timer */
name|cap
operator|&=
literal|0xffffffff
expr_stmt|;
name|cap
operator||=
operator|(
name|FS_PER_S
operator|/
name|HPET_FREQ
operator|)
operator|<<
literal|32
expr_stmt|;
comment|/* tick period in fs */
return|return
operator|(
name|cap
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|bool
name|vhpet_counter_enabled
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|)
block|{
return|return
operator|(
operator|(
name|vhpet
operator|->
name|config
operator|&
name|HPET_CNF_ENABLE
operator|)
condition|?
name|true
else|:
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|bool
name|vhpet_timer_msi_enabled
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|const
name|uint64_t
name|msi_enable
init|=
name|HPET_TCAP_FSB_INT_DEL
operator||
name|HPET_TCNF_FSB_EN
decl_stmt|;
if|if
condition|(
operator|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|&
name|msi_enable
operator|)
operator|==
name|msi_enable
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|vhpet_timer_ioapic_pin
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
comment|/* 	 * If the timer is configured to use MSI then treat it as if the 	 * timer is not connected to the ioapic. 	 */
if|if
condition|(
name|vhpet_timer_msi_enabled
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|&
name|HPET_TCNF_INT_ROUTE
operator|)
operator|>>
literal|9
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|vhpet_counter
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|sbintime_t
modifier|*
name|nowptr
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|sbintime_t
name|now
decl_stmt|,
name|delta
decl_stmt|;
name|val
operator|=
name|vhpet
operator|->
name|countbase
expr_stmt|;
if|if
condition|(
name|vhpet_counter_enabled
argument_list|(
name|vhpet
argument_list|)
condition|)
block|{
name|now
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
name|delta
operator|=
name|now
operator|-
name|vhpet
operator|->
name|countbase_sbt
expr_stmt|;
name|KASSERT
argument_list|(
name|delta
operator|>=
literal|0
argument_list|,
operator|(
literal|"vhpet_counter: uptime went backwards: "
literal|"%#lx to %#lx"
operator|,
name|vhpet
operator|->
name|countbase_sbt
operator|,
name|now
operator|)
argument_list|)
expr_stmt|;
name|val
operator|+=
name|delta
operator|/
name|vhpet
operator|->
name|freq_sbt
expr_stmt|;
if|if
condition|(
name|nowptr
operator|!=
name|NULL
condition|)
operator|*
name|nowptr
operator|=
name|now
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The sbinuptime corresponding to the 'countbase' is 		 * meaningless when the counter is disabled. Make sure 		 * that the caller doesn't want to use it. 		 */
name|KASSERT
argument_list|(
name|nowptr
operator|==
name|NULL
argument_list|,
operator|(
literal|"vhpet_counter: nowptr must be NULL"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_timer_clear_isr
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|pin
decl_stmt|;
if|if
condition|(
name|vhpet
operator|->
name|isr
operator|&
operator|(
literal|1
operator|<<
name|n
operator|)
condition|)
block|{
name|pin
operator|=
name|vhpet_timer_ioapic_pin
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pin
operator|!=
literal|0
argument_list|,
operator|(
literal|"vhpet timer %d irq incorrectly routed"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|vioapic_deassert_irq
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
name|pin
argument_list|)
expr_stmt|;
name|vhpet
operator|->
name|isr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|n
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|bool
name|vhpet_periodic_timer
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
operator|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|&
name|HPET_TCNF_TYPE
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|bool
name|vhpet_timer_interrupt_enabled
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
operator|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|&
name|HPET_TCNF_INT_ENB
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|bool
name|vhpet_timer_edge_trig
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|!
name|vhpet_timer_msi_enabled
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
argument_list|,
operator|(
literal|"vhpet_timer_edge_trig: "
literal|"timer %d is using MSI"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|&
name|HPET_TCNF_INT_TYPE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_timer_interrupt
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|pin
decl_stmt|;
comment|/* If interrupts are not enabled for this timer then just return. */
if|if
condition|(
operator|!
name|vhpet_timer_interrupt_enabled
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
return|return;
comment|/* 	 * If a level triggered interrupt is already asserted then just return. 	 */
if|if
condition|(
operator|(
name|vhpet
operator|->
name|isr
operator|&
operator|(
literal|1
operator|<<
name|n
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d intr is already asserted"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vhpet_timer_msi_enabled
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|lapic_intr_msi
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|msireg
operator|>>
literal|32
argument_list|,
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|msireg
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
name|pin
operator|=
name|vhpet_timer_ioapic_pin
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|pin
operator|==
literal|0
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d intr is not routed to ioapic"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vhpet_timer_edge_trig
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|vioapic_pulse_irq
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
name|pin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vhpet
operator|->
name|isr
operator||=
literal|1
operator|<<
name|n
expr_stmt|;
name|vioapic_assert_irq
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
name|pin
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_adjust_compval
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|,
name|uint32_t
name|counter
parameter_list|)
block|{
name|uint32_t
name|compval
decl_stmt|,
name|comprate
decl_stmt|,
name|compnext
decl_stmt|;
name|KASSERT
argument_list|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|comprate
operator|!=
literal|0
argument_list|,
operator|(
literal|"hpet t%d is not periodic"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|compval
operator|=
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|compval
expr_stmt|;
name|comprate
operator|=
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|comprate
expr_stmt|;
comment|/* 	 * Calculate the comparator value to be used for the next periodic 	 * interrupt. 	 * 	 * This function is commonly called from the callout handler. 	 * In this scenario the 'counter' is ahead of 'compval'. To find 	 * the next value to program into the accumulator we divide the 	 * number space between 'compval' and 'counter' into 'comprate' 	 * sized units. The 'compval' is rounded up such that is "ahead" 	 * of 'counter'. 	 */
name|compnext
operator|=
name|compval
operator|+
operator|(
operator|(
name|counter
operator|-
name|compval
operator|)
operator|/
name|comprate
operator|+
literal|1
operator|)
operator|*
name|comprate
expr_stmt|;
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|compval
operator|=
name|compnext
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_handler
parameter_list|(
name|void
modifier|*
name|a
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|uint32_t
name|counter
decl_stmt|;
name|sbintime_t
name|now
decl_stmt|;
name|struct
name|vhpet
modifier|*
name|vhpet
decl_stmt|;
name|struct
name|callout
modifier|*
name|callout
decl_stmt|;
name|struct
name|vhpet_callout_arg
modifier|*
name|arg
decl_stmt|;
name|arg
operator|=
name|a
expr_stmt|;
name|vhpet
operator|=
name|arg
operator|->
name|vhpet
expr_stmt|;
name|n
operator|=
name|arg
operator|->
name|timer_num
expr_stmt|;
name|callout
operator|=
operator|&
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|callout
expr_stmt|;
name|VM_CTR1
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d fired"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|VHPET_LOCK
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
name|callout
argument_list|)
condition|)
comment|/* callout was reset */
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|callout_active
argument_list|(
name|callout
argument_list|)
condition|)
comment|/* callout was stopped */
goto|goto
name|done
goto|;
name|callout_deactivate
argument_list|(
name|callout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vhpet_counter_enabled
argument_list|(
name|vhpet
argument_list|)
condition|)
name|panic
argument_list|(
literal|"vhpet(%p) callout with counter disabled"
argument_list|,
name|vhpet
argument_list|)
expr_stmt|;
name|counter
operator|=
name|vhpet_counter
argument_list|(
name|vhpet
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|vhpet_start_timer
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|,
name|counter
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|vhpet_timer_interrupt
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|done
label|:
name|VHPET_UNLOCK
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_stop_timer
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|,
name|sbintime_t
name|now
parameter_list|)
block|{
name|VM_CTR1
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d stopped"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|callout
argument_list|)
expr_stmt|;
comment|/* 	 * If the callout was scheduled to expire in the past but hasn't 	 * had a chance to execute yet then trigger the timer interrupt 	 * here. Failing to do so will result in a missed timer interrupt 	 * in the guest. This is especially bad in one-shot mode because 	 * the next interrupt has to wait for the counter to wrap around. 	 */
if|if
condition|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|callout_sbt
operator|<
name|now
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d interrupt triggered after "
literal|"stopping timer"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|vhpet_timer_interrupt
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_start_timer
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|,
name|uint32_t
name|counter
parameter_list|,
name|sbintime_t
name|now
parameter_list|)
block|{
name|sbintime_t
name|delta
decl_stmt|,
name|precision
decl_stmt|;
if|if
condition|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|comprate
operator|!=
literal|0
condition|)
name|vhpet_adjust_compval
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|,
name|counter
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * In one-shot mode it is the guest's responsibility to make 		 * sure that the comparator value is not in the "past". The 		 * hardware doesn't have any belt-and-suspenders to deal with 		 * this so we don't either. 		 */
block|}
name|delta
operator|=
operator|(
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|compval
operator|-
name|counter
operator|)
operator|*
name|vhpet
operator|->
name|freq_sbt
expr_stmt|;
name|precision
operator|=
name|delta
operator|>>
name|tc_precexp
expr_stmt|;
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|callout_sbt
operator|=
name|now
operator|+
name|delta
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|callout
argument_list|,
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|callout_sbt
argument_list|,
name|precision
argument_list|,
name|vhpet_handler
argument_list|,
operator|&
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|arg
argument_list|,
name|C_ABSOLUTE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_start_counting
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vhpet
operator|->
name|countbase_sbt
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VHPET_NUM_TIMERS
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Restart the timers based on the value of the main counter 		 * when it stopped counting. 		 */
name|vhpet_start_timer
argument_list|(
name|vhpet
argument_list|,
name|i
argument_list|,
name|vhpet
operator|->
name|countbase
argument_list|,
name|vhpet
operator|->
name|countbase_sbt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_stop_counting
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|uint32_t
name|counter
parameter_list|,
name|sbintime_t
name|now
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vhpet
operator|->
name|countbase
operator|=
name|counter
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VHPET_NUM_TIMERS
condition|;
name|i
operator|++
control|)
name|vhpet_stop_timer
argument_list|(
name|vhpet
argument_list|,
name|i
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|update_register
parameter_list|(
name|uint64_t
modifier|*
name|regptr
parameter_list|,
name|uint64_t
name|data
parameter_list|,
name|uint64_t
name|mask
parameter_list|)
block|{
operator|*
name|regptr
operator|&=
operator|~
name|mask
expr_stmt|;
operator|*
name|regptr
operator||=
operator|(
name|data
operator|&
name|mask
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vhpet_timer_update_config
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|,
name|int
name|n
parameter_list|,
name|uint64_t
name|data
parameter_list|,
name|uint64_t
name|mask
parameter_list|)
block|{
name|bool
name|clear_isr
decl_stmt|;
name|int
name|old_pin
decl_stmt|,
name|new_pin
decl_stmt|;
name|uint32_t
name|allowed_irqs
decl_stmt|;
name|uint64_t
name|oldval
decl_stmt|,
name|newval
decl_stmt|;
if|if
condition|(
name|vhpet_timer_msi_enabled
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
operator|||
name|vhpet_timer_edge_trig
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
block|{
if|if
condition|(
name|vhpet
operator|->
name|isr
operator|&
operator|(
literal|1
operator|<<
name|n
operator|)
condition|)
name|panic
argument_list|(
literal|"vhpet timer %d isr should not be asserted"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|old_pin
operator|=
name|vhpet_timer_ioapic_pin
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
expr_stmt|;
name|newval
operator|=
name|oldval
expr_stmt|;
name|update_register
argument_list|(
operator|&
name|newval
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|newval
operator|&=
operator|~
operator|(
name|HPET_TCAP_RO_MASK
operator||
name|HPET_TCNF_32MODE
operator|)
expr_stmt|;
name|newval
operator||=
name|oldval
operator|&
name|HPET_TCAP_RO_MASK
expr_stmt|;
if|if
condition|(
name|newval
operator|==
name|oldval
condition|)
return|return;
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|=
name|newval
expr_stmt|;
name|VM_CTR2
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d cap_config set to 0x%016x"
argument_list|,
name|n
argument_list|,
name|newval
argument_list|)
expr_stmt|;
comment|/* 	 * Validate the interrupt routing in the HPET_TCNF_INT_ROUTE field. 	 * If it does not match the bits set in HPET_TCAP_INT_ROUTE then set 	 * it to the default value of 0. 	 */
name|allowed_irqs
operator|=
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|>>
literal|32
expr_stmt|;
name|new_pin
operator|=
name|vhpet_timer_ioapic_pin
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pin
operator|!=
literal|0
operator|&&
operator|(
name|allowed_irqs
operator|&
operator|(
literal|1
operator|<<
name|new_pin
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|VM_CTR3
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d configured invalid irq %d, "
literal|"allowed_irqs 0x%08x"
argument_list|,
name|n
argument_list|,
name|new_pin
argument_list|,
name|allowed_irqs
argument_list|)
expr_stmt|;
name|new_pin
operator|=
literal|0
expr_stmt|;
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|cap_config
operator|&=
operator|~
name|HPET_TCNF_INT_ROUTE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vhpet_periodic_timer
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
name|vhpet
operator|->
name|timer
index|[
name|n
index|]
operator|.
name|comprate
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the timer's ISR bit is set then clear it in the following cases: 	 * - interrupt is disabled 	 * - interrupt type is changed from level to edge or fsb. 	 * - interrupt routing is changed 	 * 	 * This is to ensure that this timer's level triggered interrupt does 	 * not remain asserted forever. 	 */
if|if
condition|(
name|vhpet
operator|->
name|isr
operator|&
operator|(
literal|1
operator|<<
name|n
operator|)
condition|)
block|{
name|KASSERT
argument_list|(
name|old_pin
operator|!=
literal|0
argument_list|,
operator|(
literal|"timer %d isr asserted to ioapic pin %d"
operator|,
name|n
operator|,
name|old_pin
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vhpet_timer_interrupt_enabled
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
name|clear_isr
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|vhpet_timer_msi_enabled
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
name|clear_isr
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|vhpet_timer_edge_trig
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
condition|)
name|clear_isr
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|vhpet_timer_ioapic_pin
argument_list|(
name|vhpet
argument_list|,
name|n
argument_list|)
operator|!=
name|old_pin
condition|)
name|clear_isr
operator|=
name|true
expr_stmt|;
else|else
name|clear_isr
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|clear_isr
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d isr cleared due to "
literal|"configuration change"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|vioapic_deassert_irq
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
name|old_pin
argument_list|)
expr_stmt|;
name|vhpet
operator|->
name|isr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|n
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|vhpet_mmio_write
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|uint64_t
name|val
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vhpet
modifier|*
name|vhpet
decl_stmt|;
name|uint64_t
name|data
decl_stmt|,
name|mask
decl_stmt|,
name|oldval
decl_stmt|,
name|val64
decl_stmt|;
name|uint32_t
name|isr_clear_mask
decl_stmt|,
name|old_compval
decl_stmt|,
name|old_comprate
decl_stmt|,
name|counter
decl_stmt|;
name|sbintime_t
name|now
decl_stmt|,
modifier|*
name|nowptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|vhpet
operator|=
name|vm_hpet
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gpa
operator|-
name|VHPET_BASE
expr_stmt|;
name|VHPET_LOCK
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
comment|/* Accesses to the HPET should be 4 or 8 bytes wide */
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
name|mask
operator|=
literal|0xffffffffffffffff
expr_stmt|;
name|data
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|mask
operator|=
literal|0xffffffff
expr_stmt|;
name|data
operator|=
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
literal|0x4
operator|)
operator|!=
literal|0
condition|)
block|{
name|mask
operator|<<=
literal|32
expr_stmt|;
name|data
operator|<<=
literal|32
expr_stmt|;
block|}
break|break;
default|default:
name|VM_CTR2
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet invalid mmio write: "
literal|"offset 0x%08x, size %d"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Access to the HPET should be naturally aligned to its width */
if|if
condition|(
name|offset
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet invalid mmio write: "
literal|"offset 0x%08x, size %d"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_CONFIG
operator|||
name|offset
operator|==
name|HPET_CONFIG
operator|+
literal|4
condition|)
block|{
comment|/* 		 * Get the most recent value of the counter before updating 		 * the 'config' register. If the HPET is going to be disabled 		 * then we need to update 'countbase' with the value right 		 * before it is disabled. 		 */
name|nowptr
operator|=
name|vhpet_counter_enabled
argument_list|(
name|vhpet
argument_list|)
condition|?
operator|&
name|now
else|:
name|NULL
expr_stmt|;
name|counter
operator|=
name|vhpet_counter
argument_list|(
name|vhpet
argument_list|,
name|nowptr
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|vhpet
operator|->
name|config
expr_stmt|;
name|update_register
argument_list|(
operator|&
name|vhpet
operator|->
name|config
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* 		 * LegacyReplacement Routing is not supported so clear the 		 * bit explicitly. 		 */
name|vhpet
operator|->
name|config
operator|&=
operator|~
name|HPET_CNF_LEG_RT
expr_stmt|;
if|if
condition|(
operator|(
name|oldval
operator|^
name|vhpet
operator|->
name|config
operator|)
operator|&
name|HPET_CNF_ENABLE
condition|)
block|{
if|if
condition|(
name|vhpet_counter_enabled
argument_list|(
name|vhpet
argument_list|)
condition|)
block|{
name|vhpet_start_counting
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
name|VM_CTR0
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet enabled"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vhpet_stop_counting
argument_list|(
name|vhpet
argument_list|,
name|counter
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|VM_CTR0
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet disabled"
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_ISR
operator|||
name|offset
operator|==
name|HPET_ISR
operator|+
literal|4
condition|)
block|{
name|isr_clear_mask
operator|=
name|vhpet
operator|->
name|isr
operator|&
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VHPET_NUM_TIMERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|isr_clear_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet t%d isr cleared"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vhpet_timer_clear_isr
argument_list|(
name|vhpet
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_MAIN_COUNTER
operator|||
name|offset
operator|==
name|HPET_MAIN_COUNTER
operator|+
literal|4
condition|)
block|{
comment|/* Zero-extend the counter to 64-bits before updating it */
name|val64
operator|=
name|vhpet_counter
argument_list|(
name|vhpet
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|update_register
argument_list|(
operator|&
name|val64
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|vhpet
operator|->
name|countbase
operator|=
name|val64
expr_stmt|;
if|if
condition|(
name|vhpet_counter_enabled
argument_list|(
name|vhpet
argument_list|)
condition|)
name|vhpet_start_counting
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VHPET_NUM_TIMERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offset
operator|==
name|HPET_TIMER_CAP_CNF
argument_list|(
name|i
argument_list|)
operator|||
name|offset
operator|==
name|HPET_TIMER_CAP_CNF
argument_list|(
name|i
argument_list|)
operator|+
literal|4
condition|)
block|{
name|vhpet_timer_update_config
argument_list|(
name|vhpet
argument_list|,
name|i
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_TIMER_COMPARATOR
argument_list|(
name|i
argument_list|)
operator|||
name|offset
operator|==
name|HPET_TIMER_COMPARATOR
argument_list|(
name|i
argument_list|)
operator|+
literal|4
condition|)
block|{
name|old_compval
operator|=
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|compval
expr_stmt|;
name|old_comprate
operator|=
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|comprate
expr_stmt|;
if|if
condition|(
name|vhpet_periodic_timer
argument_list|(
name|vhpet
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* 				 * In periodic mode writes to the comparator 				 * change the 'compval' register only if the 				 * HPET_TCNF_VAL_SET bit is set in the config 				 * register. 				 */
name|val64
operator|=
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|comprate
expr_stmt|;
name|update_register
argument_list|(
operator|&
name|val64
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|comprate
operator|=
name|val64
expr_stmt|;
if|if
condition|(
operator|(
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|cap_config
operator|&
name|HPET_TCNF_VAL_SET
operator|)
operator|!=
literal|0
condition|)
block|{
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|compval
operator|=
name|val64
expr_stmt|;
block|}
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|comprate
operator|==
literal|0
argument_list|,
operator|(
literal|"vhpet one-shot timer %d has invalid "
literal|"rate %u"
operator|,
name|i
operator|,
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|comprate
operator|)
argument_list|)
expr_stmt|;
name|val64
operator|=
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|compval
expr_stmt|;
name|update_register
argument_list|(
operator|&
name|val64
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|compval
operator|=
name|val64
expr_stmt|;
block|}
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|cap_config
operator|&=
operator|~
name|HPET_TCNF_VAL_SET
expr_stmt|;
if|if
condition|(
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|compval
operator|!=
name|old_compval
operator|||
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|comprate
operator|!=
name|old_comprate
condition|)
block|{
if|if
condition|(
name|vhpet_counter_enabled
argument_list|(
name|vhpet
argument_list|)
condition|)
block|{
name|counter
operator|=
name|vhpet_counter
argument_list|(
name|vhpet
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|vhpet_start_timer
argument_list|(
name|vhpet
argument_list|,
name|i
argument_list|,
name|counter
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_TIMER_FSB_VAL
argument_list|(
name|i
argument_list|)
operator|||
name|offset
operator|==
name|HPET_TIMER_FSB_ADDR
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|update_register
argument_list|(
operator|&
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|msireg
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|done
label|:
name|VHPET_UNLOCK
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vhpet_mmio_read
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|uint64_t
modifier|*
name|rval
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|vhpet
modifier|*
name|vhpet
decl_stmt|;
name|uint64_t
name|data
decl_stmt|;
name|vhpet
operator|=
name|vm_hpet
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gpa
operator|-
name|VHPET_BASE
expr_stmt|;
name|VHPET_LOCK
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
comment|/* Accesses to the HPET should be 4 or 8 bytes wide */
if|if
condition|(
name|size
operator|!=
literal|4
operator|&&
name|size
operator|!=
literal|8
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet invalid mmio read: "
literal|"offset 0x%08x, size %d"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Access to the HPET should be naturally aligned to its width */
if|if
condition|(
name|offset
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vhpet
operator|->
name|vm
argument_list|,
literal|"hpet invalid mmio read: "
literal|"offset 0x%08x, size %d"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_CAPABILITIES
operator|||
name|offset
operator|==
name|HPET_CAPABILITIES
operator|+
literal|4
condition|)
block|{
name|data
operator|=
name|vhpet_capabilities
argument_list|()
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_CONFIG
operator|||
name|offset
operator|==
name|HPET_CONFIG
operator|+
literal|4
condition|)
block|{
name|data
operator|=
name|vhpet
operator|->
name|config
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_ISR
operator|||
name|offset
operator|==
name|HPET_ISR
operator|+
literal|4
condition|)
block|{
name|data
operator|=
name|vhpet
operator|->
name|isr
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_MAIN_COUNTER
operator|||
name|offset
operator|==
name|HPET_MAIN_COUNTER
operator|+
literal|4
condition|)
block|{
name|data
operator|=
name|vhpet_counter
argument_list|(
name|vhpet
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VHPET_NUM_TIMERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offset
operator|==
name|HPET_TIMER_CAP_CNF
argument_list|(
name|i
argument_list|)
operator|||
name|offset
operator|==
name|HPET_TIMER_CAP_CNF
argument_list|(
name|i
argument_list|)
operator|+
literal|4
condition|)
block|{
name|data
operator|=
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|cap_config
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_TIMER_COMPARATOR
argument_list|(
name|i
argument_list|)
operator|||
name|offset
operator|==
name|HPET_TIMER_COMPARATOR
argument_list|(
name|i
argument_list|)
operator|+
literal|4
condition|)
block|{
name|data
operator|=
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|compval
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|offset
operator|==
name|HPET_TIMER_FSB_VAL
argument_list|(
name|i
argument_list|)
operator|||
name|offset
operator|==
name|HPET_TIMER_FSB_ADDR
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|data
operator|=
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|msireg
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|VHPET_NUM_TIMERS
condition|)
name|data
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|VHPET_UNLOCK
argument_list|(
name|vhpet
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|offset
operator|&
literal|0x4
condition|)
name|data
operator|>>=
literal|32
expr_stmt|;
block|}
operator|*
name|rval
operator|=
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|vhpet
modifier|*
name|vhpet_init
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|pincount
decl_stmt|;
name|struct
name|vhpet
modifier|*
name|vhpet
decl_stmt|;
name|uint64_t
name|allowed_irqs
decl_stmt|;
name|struct
name|vhpet_callout_arg
modifier|*
name|arg
decl_stmt|;
name|struct
name|bintime
name|bt
decl_stmt|;
name|vhpet
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vhpet
argument_list|)
argument_list|,
name|M_VHPET
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vhpet
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|vhpet
operator|->
name|mtx
argument_list|,
literal|"vhpet lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|FREQ2BT
argument_list|(
name|HPET_FREQ
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|vhpet
operator|->
name|freq_sbt
operator|=
name|bttosbt
argument_list|(
name|bt
argument_list|)
expr_stmt|;
name|pincount
operator|=
name|vioapic_pincount
argument_list|(
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pincount
operator|>=
literal|32
condition|)
name|allowed_irqs
operator|=
literal|0xff000000
expr_stmt|;
comment|/* irqs 24-31 */
elseif|else
if|if
condition|(
name|pincount
operator|>=
literal|20
condition|)
name|allowed_irqs
operator|=
literal|0xf
operator|<<
operator|(
name|pincount
operator|-
literal|4
operator|)
expr_stmt|;
comment|/* 4 upper irqs */
else|else
name|allowed_irqs
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize HPET timer hardware state. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VHPET_NUM_TIMERS
condition|;
name|i
operator|++
control|)
block|{
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|cap_config
operator|=
name|allowed_irqs
operator|<<
literal|32
expr_stmt|;
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|cap_config
operator||=
name|HPET_TCAP_PER_INT
expr_stmt|;
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|cap_config
operator||=
name|HPET_TCAP_FSB_INT_DEL
expr_stmt|;
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|compval
operator|=
literal|0xffffffff
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|=
operator|&
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|arg
expr_stmt|;
name|arg
operator|->
name|vhpet
operator|=
name|vhpet
expr_stmt|;
name|arg
operator|->
name|timer_num
operator|=
name|i
expr_stmt|;
block|}
return|return
operator|(
name|vhpet
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vhpet_cleanup
parameter_list|(
name|struct
name|vhpet
modifier|*
name|vhpet
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VHPET_NUM_TIMERS
condition|;
name|i
operator|++
control|)
name|callout_drain
argument_list|(
operator|&
name|vhpet
operator|->
name|timer
index|[
name|i
index|]
operator|.
name|callout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vhpet
argument_list|,
name|M_VHPET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vhpet_getcap
parameter_list|(
name|struct
name|vm_hpet_cap
modifier|*
name|cap
parameter_list|)
block|{
name|cap
operator|->
name|capabilities
operator|=
name|vhpet_capabilities
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

