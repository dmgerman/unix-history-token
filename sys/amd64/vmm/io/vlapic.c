begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 NetApp, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<x86/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<x86/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|"vmm_stat.h"
end_include

begin_include
include|#
directive|include
file|"vmm_lapic.h"
end_include

begin_include
include|#
directive|include
file|"vmm_ktr.h"
end_include

begin_include
include|#
directive|include
file|"vlapic.h"
end_include

begin_include
include|#
directive|include
file|"vioapic.h"
end_include

begin_define
define|#
directive|define
name|VLAPIC_CTR0
parameter_list|(
name|vlapic
parameter_list|,
name|format
parameter_list|)
define|\
value|VCPU_CTR0((vlapic)->vm, (vlapic)->vcpuid, format)
end_define

begin_define
define|#
directive|define
name|VLAPIC_CTR1
parameter_list|(
name|vlapic
parameter_list|,
name|format
parameter_list|,
name|p1
parameter_list|)
define|\
value|VCPU_CTR1((vlapic)->vm, (vlapic)->vcpuid, format, p1)
end_define

begin_define
define|#
directive|define
name|VLAPIC_CTR2
parameter_list|(
name|vlapic
parameter_list|,
name|format
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|)
define|\
value|VCPU_CTR2((vlapic)->vm, (vlapic)->vcpuid, format, p1, p2)
end_define

begin_define
define|#
directive|define
name|VLAPIC_CTR_IRR
parameter_list|(
name|vlapic
parameter_list|,
name|msg
parameter_list|)
define|\
value|do {									\ 	uint32_t *irrptr =&(vlapic)->apic.irr0;			\ 	irrptr[0] = irrptr[0];
comment|/* silence compiler */
value|\ 	VLAPIC_CTR1((vlapic), msg " irr0 0x%08x", irrptr[0<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " irr1 0x%08x", irrptr[1<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " irr2 0x%08x", irrptr[2<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " irr3 0x%08x", irrptr[3<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " irr4 0x%08x", irrptr[4<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " irr5 0x%08x", irrptr[5<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " irr6 0x%08x", irrptr[6<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " irr7 0x%08x", irrptr[7<< 2]);	\ } while (0)
end_define

begin_define
define|#
directive|define
name|VLAPIC_CTR_ISR
parameter_list|(
name|vlapic
parameter_list|,
name|msg
parameter_list|)
define|\
value|do {									\ 	uint32_t *isrptr =&(vlapic)->apic.isr0;			\ 	isrptr[0] = isrptr[0];
comment|/* silence compiler */
value|\ 	VLAPIC_CTR1((vlapic), msg " isr0 0x%08x", isrptr[0<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " isr1 0x%08x", isrptr[1<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " isr2 0x%08x", isrptr[2<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " isr3 0x%08x", isrptr[3<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " isr4 0x%08x", isrptr[4<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " isr5 0x%08x", isrptr[5<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " isr6 0x%08x", isrptr[6<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " isr7 0x%08x", isrptr[7<< 2]);	\ } while (0)
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VLAPIC
argument_list|,
literal|"vlapic"
argument_list|,
literal|"vlapic"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PRIO
parameter_list|(
name|x
parameter_list|)
value|((x)>> 4)
end_define

begin_define
define|#
directive|define
name|VLAPIC_VERSION
value|(16)
end_define

begin_define
define|#
directive|define
name|VLAPIC_MAXLVT_ENTRIES
value|(5)
end_define

begin_define
define|#
directive|define
name|x2apic
parameter_list|(
name|vlapic
parameter_list|)
value|(((vlapic)->msr_apicbase& APICBASE_X2APIC) ? 1 : 0)
end_define

begin_enum
enum|enum
name|boot_state
block|{
name|BS_INIT
block|,
name|BS_SIPI
block|,
name|BS_RUNNING
block|}
enum|;
end_enum

begin_struct
struct|struct
name|vlapic
block|{
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
name|int
name|vcpuid
decl_stmt|;
name|struct
name|LAPIC
name|apic
decl_stmt|;
name|int
name|esr_update
decl_stmt|;
name|struct
name|callout
name|callout
decl_stmt|;
comment|/* vlapic timer */
name|struct
name|bintime
name|timer_fire_bt
decl_stmt|;
comment|/* callout expiry time */
name|struct
name|bintime
name|timer_freq_bt
decl_stmt|;
comment|/* timer frequency */
name|struct
name|bintime
name|timer_period_bt
decl_stmt|;
comment|/* timer period */
name|struct
name|mtx
name|timer_mtx
decl_stmt|;
comment|/* 	 * The 'isrvec_stk' is a stack of vectors injected by the local apic. 	 * A vector is popped from the stack when the processor does an EOI. 	 * The vector on the top of the stack is used to compute the 	 * Processor Priority in conjunction with the TPR. 	 */
name|uint8_t
name|isrvec_stk
index|[
name|ISRVEC_STK_SIZE
index|]
decl_stmt|;
name|int
name|isrvec_stk_top
decl_stmt|;
name|uint64_t
name|msr_apicbase
decl_stmt|;
name|enum
name|boot_state
name|boot_state
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The 'vlapic->timer_mtx' is used to provide mutual exclusion between the  * vlapic_callout_handler() and vcpu accesses to the following registers:  * - initial count register aka icr_timer  * - current count register aka ccr_timer  * - divide config register aka dcr_timer  * - timer LVT register  *  * Note that the vlapic_callout_handler() does not write to any of these  * registers so they can be safely read from the vcpu context without locking.  */
end_comment

begin_define
define|#
directive|define
name|VLAPIC_TIMER_LOCK
parameter_list|(
name|vlapic
parameter_list|)
value|mtx_lock_spin(&((vlapic)->timer_mtx))
end_define

begin_define
define|#
directive|define
name|VLAPIC_TIMER_UNLOCK
parameter_list|(
name|vlapic
parameter_list|)
value|mtx_unlock_spin(&((vlapic)->timer_mtx))
end_define

begin_define
define|#
directive|define
name|VLAPIC_TIMER_LOCKED
parameter_list|(
name|vlapic
parameter_list|)
value|mtx_owned(&((vlapic)->timer_mtx))
end_define

begin_define
define|#
directive|define
name|VLAPIC_BUS_FREQ
value|tsc_freq
end_define

begin_function
specifier|static
name|__inline
name|uint32_t
name|vlapic_get_id
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
return|return
operator|(
name|vlapic
operator|->
name|vcpuid
operator|)
return|;
else|else
return|return
operator|(
name|vlapic
operator|->
name|vcpuid
operator|<<
literal|24
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|vlapic_get_ldr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|int
name|apicid
decl_stmt|;
name|uint32_t
name|ldr
decl_stmt|;
name|lapic
operator|=
operator|&
name|vlapic
operator|->
name|apic
expr_stmt|;
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
block|{
name|apicid
operator|=
name|vlapic_get_id
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|ldr
operator|=
literal|1
operator|<<
operator|(
name|apicid
operator|&
literal|0xf
operator|)
expr_stmt|;
name|ldr
operator||=
operator|(
name|apicid
operator|&
literal|0xffff0
operator|)
operator|<<
literal|12
expr_stmt|;
return|return
operator|(
name|ldr
operator|)
return|;
block|}
else|else
return|return
operator|(
name|lapic
operator|->
name|ldr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|vlapic_get_dfr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|lapic
operator|=
operator|&
name|vlapic
operator|->
name|apic
expr_stmt|;
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|lapic
operator|->
name|dfr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_set_dfr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|uint32_t
name|dfr
decl_stmt|;
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
literal|"write to DFR in x2apic mode: %#x"
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
name|lapic
operator|=
operator|&
name|vlapic
operator|->
name|apic
expr_stmt|;
name|dfr
operator|=
operator|(
name|lapic
operator|->
name|dfr
operator|&
name|APIC_DFR_RESERVED
operator|)
operator||
operator|(
name|data
operator|&
name|APIC_DFR_MODEL_MASK
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|dfr
operator|&
name|APIC_DFR_MODEL_MASK
operator|)
operator|==
name|APIC_DFR_MODEL_FLAT
condition|)
name|VLAPIC_CTR0
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic DFR in Flat Model"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dfr
operator|&
name|APIC_DFR_MODEL_MASK
operator|)
operator|==
name|APIC_DFR_MODEL_CLUSTER
condition|)
name|VLAPIC_CTR0
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic DFR in Cluster Model"
argument_list|)
expr_stmt|;
else|else
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic DFR in Unknown Model %#x"
argument_list|,
name|dfr
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|dfr
operator|=
name|dfr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_set_ldr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
comment|/* LDR is read-only in x2apic mode */
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
block|{
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"write to LDR in x2apic mode: %#x"
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
name|lapic
operator|=
operator|&
name|vlapic
operator|->
name|apic
expr_stmt|;
name|lapic
operator|->
name|ldr
operator|=
name|data
operator|&
operator|~
name|APIC_LDR_RESERVED
expr_stmt|;
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic LDR set to %#x"
argument_list|,
name|lapic
operator|->
name|ldr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vlapic_timer_divisor
parameter_list|(
name|uint32_t
name|dcr
parameter_list|)
block|{
switch|switch
condition|(
name|dcr
operator|&
literal|0xB
condition|)
block|{
case|case
name|APIC_TDCR_1
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|APIC_TDCR_2
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
name|APIC_TDCR_4
case|:
return|return
operator|(
literal|4
operator|)
return|;
case|case
name|APIC_TDCR_8
case|:
return|return
operator|(
literal|8
operator|)
return|;
case|case
name|APIC_TDCR_16
case|:
return|return
operator|(
literal|16
operator|)
return|;
case|case
name|APIC_TDCR_32
case|:
return|return
operator|(
literal|32
operator|)
return|;
case|case
name|APIC_TDCR_64
case|:
return|return
operator|(
literal|64
operator|)
return|;
case|case
name|APIC_TDCR_128
case|:
return|return
operator|(
literal|128
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"vlapic_timer_divisor: invalid dcr 0x%08x"
argument_list|,
name|dcr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_mask_lvts
parameter_list|(
name|uint32_t
modifier|*
name|lvts
parameter_list|,
name|int
name|num_lvt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_lvt
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|lvts
operator||=
name|APIC_LVT_M
expr_stmt|;
name|lvts
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static inline void vlapic_dump_lvt(uint32_t offset, uint32_t *lvt) { 	printf("Offset %x: lvt %08x (V:%02x DS:%x M:%x)\n", offset, 	    *lvt, *lvt& APIC_LVTT_VECTOR, *lvt& APIC_LVTT_DS, 	    *lvt& APIC_LVTT_M); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|uint32_t
name|vlapic_get_ccr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|bintime
name|bt_now
decl_stmt|,
name|bt_rem
decl_stmt|;
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|uint32_t
name|ccr
decl_stmt|;
name|ccr
operator|=
literal|0
expr_stmt|;
name|lapic
operator|=
operator|&
name|vlapic
operator|->
name|apic
expr_stmt|;
name|VLAPIC_TIMER_LOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_active
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|)
condition|)
block|{
comment|/* 		 * If the timer is scheduled to expire in the future then 		 * compute the value of 'ccr' based on the remaining time. 		 */
name|binuptime
argument_list|(
operator|&
name|bt_now
argument_list|)
expr_stmt|;
if|if
condition|(
name|bintime_cmp
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_fire_bt
argument_list|,
operator|&
name|bt_now
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|bt_rem
operator|=
name|vlapic
operator|->
name|timer_fire_bt
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|bt_rem
argument_list|,
operator|&
name|bt_now
argument_list|)
expr_stmt|;
name|ccr
operator|+=
name|bt_rem
operator|.
name|sec
operator|*
name|BT2FREQ
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_freq_bt
argument_list|)
expr_stmt|;
name|ccr
operator|+=
name|bt_rem
operator|.
name|frac
operator|/
name|vlapic
operator|->
name|timer_freq_bt
operator|.
name|frac
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
name|ccr
operator|<=
name|lapic
operator|->
name|icr_timer
argument_list|,
operator|(
literal|"vlapic_get_ccr: invalid ccr %#x, "
literal|"icr_timer is %#x"
operator|,
name|ccr
operator|,
name|lapic
operator|->
name|icr_timer
operator|)
argument_list|)
expr_stmt|;
name|VLAPIC_CTR2
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic ccr_timer = %#x, icr_timer = %#x"
argument_list|,
name|ccr
argument_list|,
name|lapic
operator|->
name|icr_timer
argument_list|)
expr_stmt|;
name|VLAPIC_TIMER_UNLOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
return|return
operator|(
name|ccr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_set_dcr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|dcr
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|int
name|divisor
decl_stmt|;
name|lapic
operator|=
operator|&
name|vlapic
operator|->
name|apic
expr_stmt|;
name|VLAPIC_TIMER_LOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|dcr_timer
operator|=
name|dcr
expr_stmt|;
name|divisor
operator|=
name|vlapic_timer_divisor
argument_list|(
name|dcr
argument_list|)
expr_stmt|;
name|VLAPIC_CTR2
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic dcr_timer=%#x, divisor=%d"
argument_list|,
name|dcr
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
comment|/* 	 * Update the timer frequency and the timer period. 	 * 	 * XXX changes to the frequency divider will not take effect until 	 * the timer is reloaded. 	 */
name|FREQ2BT
argument_list|(
name|VLAPIC_BUS_FREQ
operator|/
name|divisor
argument_list|,
operator|&
name|vlapic
operator|->
name|timer_freq_bt
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|timer_period_bt
operator|=
name|vlapic
operator|->
name|timer_freq_bt
expr_stmt|;
name|bintime_mul
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_period_bt
argument_list|,
name|lapic
operator|->
name|icr_timer
argument_list|)
expr_stmt|;
name|VLAPIC_TIMER_UNLOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_update_errors
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|lapic
operator|->
name|esr
operator|=
literal|0
expr_stmt|;
comment|// XXX
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_init_ipi
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|lapic
operator|->
name|version
operator|=
name|VLAPIC_VERSION
expr_stmt|;
name|lapic
operator|->
name|version
operator||=
operator|(
name|VLAPIC_MAXLVT_ENTRIES
operator|<<
name|MAXLVTSHIFT
operator|)
expr_stmt|;
name|lapic
operator|->
name|dfr
operator|=
literal|0xffffffff
expr_stmt|;
name|lapic
operator|->
name|svr
operator|=
name|APIC_SVR_VECTOR
expr_stmt|;
name|vlapic_mask_lvts
argument_list|(
operator|&
name|lapic
operator|->
name|lvt_timer
argument_list|,
name|VLAPIC_MAXLVT_ENTRIES
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vlapic_reset
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|memset
argument_list|(
name|lapic
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lapic
argument_list|)
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|apr
operator|=
name|vlapic
operator|->
name|vcpuid
expr_stmt|;
name|vlapic_init_ipi
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|vlapic_set_dcr
argument_list|(
name|vlapic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlapic
operator|->
name|vcpuid
operator|==
literal|0
condition|)
name|vlapic
operator|->
name|boot_state
operator|=
name|BS_RUNNING
expr_stmt|;
comment|/* BSP */
else|else
name|vlapic
operator|->
name|boot_state
operator|=
name|BS_INIT
expr_stmt|;
comment|/* AP */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|vlapic_set_intr_ready
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|int
name|vector
parameter_list|,
name|bool
name|level
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|uint32_t
modifier|*
name|irrptr
decl_stmt|,
modifier|*
name|tmrptr
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|vector
operator|<
literal|0
operator|||
name|vector
operator|>=
literal|256
condition|)
name|panic
argument_list|(
literal|"vlapic_set_intr_ready: invalid vector %d\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lapic
operator|->
name|svr
operator|&
name|APIC_SVR_ENABLE
operator|)
condition|)
block|{
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic is software disabled, ignoring "
literal|"interrupt %d"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return;
block|}
name|idx
operator|=
operator|(
name|vector
operator|/
literal|32
operator|)
operator|*
literal|4
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
expr_stmt|;
name|irrptr
operator|=
operator|&
name|lapic
operator|->
name|irr0
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|irrptr
index|[
name|idx
index|]
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* 	 * Upon acceptance of an interrupt into the IRR the corresponding 	 * TMR bit is cleared for edge-triggered interrupts and set for 	 * level-triggered interrupts. 	 */
name|tmrptr
operator|=
operator|&
name|lapic
operator|->
name|tmr0
expr_stmt|;
if|if
condition|(
name|level
condition|)
name|atomic_set_int
argument_list|(
operator|&
name|tmrptr
index|[
name|idx
index|]
argument_list|,
name|mask
argument_list|)
expr_stmt|;
else|else
name|atomic_clear_int
argument_list|(
operator|&
name|tmrptr
index|[
name|idx
index|]
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|VLAPIC_CTR_IRR
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic_set_intr_ready"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
modifier|*
name|vlapic_get_lvtptr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|offset
operator|<
name|APIC_OFFSET_TIMER_LVT
operator|||
name|offset
operator|>
name|APIC_OFFSET_ERROR_LVT
condition|)
block|{
name|panic
argument_list|(
literal|"vlapic_get_lvt: invalid LVT\n"
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
operator|(
name|offset
operator|-
name|APIC_OFFSET_TIMER_LVT
operator|)
operator|>>
literal|2
expr_stmt|;
return|return
operator|(
operator|(
operator|&
name|lapic
operator|->
name|lvt_timer
operator|)
operator|+
name|i
operator|)
return|;
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|vlapic_get_lvt
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
return|return
operator|(
operator|*
name|vlapic_get_lvtptr
argument_list|(
name|vlapic
argument_list|,
name|offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_set_lvt
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|uint32_t
modifier|*
name|lvtptr
decl_stmt|;
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|lapic
operator|=
operator|&
name|vlapic
operator|->
name|apic
expr_stmt|;
name|lvtptr
operator|=
name|vlapic_get_lvtptr
argument_list|(
name|vlapic
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|APIC_OFFSET_TIMER_LVT
condition|)
name|VLAPIC_TIMER_LOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lapic
operator|->
name|svr
operator|&
name|APIC_SVR_ENABLE
operator|)
condition|)
name|val
operator||=
name|APIC_LVT_M
expr_stmt|;
operator|*
name|lvtptr
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|APIC_OFFSET_TIMER_LVT
condition|)
name|VLAPIC_TIMER_UNLOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|1
end_if

begin_function
specifier|static
name|void
name|dump_isrvec_stk
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|isrptr
decl_stmt|;
name|isrptr
operator|=
operator|&
name|vlapic
operator|->
name|apic
operator|.
name|isr0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"ISR%d 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|isrptr
index|[
name|i
operator|*
literal|4
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|vlapic
operator|->
name|isrvec_stk_top
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"isrvec_stk[%d] = %d\n"
argument_list|,
name|i
argument_list|,
name|vlapic
operator|->
name|isrvec_stk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Algorithm adopted from section "Interrupt, Task and Processor Priority"  * in Intel Architecture Manual Vol 3a.  */
end_comment

begin_function
specifier|static
name|void
name|vlapic_update_ppr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|int
name|isrvec
decl_stmt|,
name|tpr
decl_stmt|,
name|ppr
decl_stmt|;
comment|/* 	 * Note that the value on the stack at index 0 is always 0. 	 * 	 * This is a placeholder for the value of ISRV when none of the 	 * bits is set in the ISRx registers. 	 */
name|isrvec
operator|=
name|vlapic
operator|->
name|isrvec_stk
index|[
name|vlapic
operator|->
name|isrvec_stk_top
index|]
expr_stmt|;
name|tpr
operator|=
name|vlapic
operator|->
name|apic
operator|.
name|tpr
expr_stmt|;
if|#
directive|if
literal|1
block|{
name|int
name|i
decl_stmt|,
name|lastprio
decl_stmt|,
name|curprio
decl_stmt|,
name|vector
decl_stmt|,
name|idx
decl_stmt|;
name|uint32_t
modifier|*
name|isrptr
decl_stmt|;
if|if
condition|(
name|vlapic
operator|->
name|isrvec_stk_top
operator|==
literal|0
operator|&&
name|isrvec
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"isrvec_stk is corrupted: %d"
argument_list|,
name|isrvec
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure that the priority of the nested interrupts is 		 * always increasing. 		 */
name|lastprio
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|vlapic
operator|->
name|isrvec_stk_top
condition|;
name|i
operator|++
control|)
block|{
name|curprio
operator|=
name|PRIO
argument_list|(
name|vlapic
operator|->
name|isrvec_stk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|curprio
operator|<=
name|lastprio
condition|)
block|{
name|dump_isrvec_stk
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"isrvec_stk does not satisfy invariant"
argument_list|)
expr_stmt|;
block|}
name|lastprio
operator|=
name|curprio
expr_stmt|;
block|}
comment|/* 		 * Make sure that each bit set in the ISRx registers has a 		 * corresponding entry on the isrvec stack. 		 */
name|i
operator|=
literal|1
expr_stmt|;
name|isrptr
operator|=
operator|&
name|vlapic
operator|->
name|apic
operator|.
name|isr0
expr_stmt|;
for|for
control|(
name|vector
operator|=
literal|0
init|;
name|vector
operator|<
literal|256
condition|;
name|vector
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|vector
operator|/
literal|32
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|isrptr
index|[
name|idx
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|vlapic
operator|->
name|isrvec_stk_top
operator|||
name|vlapic
operator|->
name|isrvec_stk
index|[
name|i
index|]
operator|!=
name|vector
condition|)
block|{
name|dump_isrvec_stk
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ISR and isrvec_stk out of sync"
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|PRIO
argument_list|(
name|tpr
argument_list|)
operator|>=
name|PRIO
argument_list|(
name|isrvec
argument_list|)
condition|)
name|ppr
operator|=
name|tpr
expr_stmt|;
else|else
name|ppr
operator|=
name|isrvec
operator|&
literal|0xf0
expr_stmt|;
name|vlapic
operator|->
name|apic
operator|.
name|ppr
operator|=
name|ppr
expr_stmt|;
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic_update_ppr 0x%02x"
argument_list|,
name|ppr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_process_eoi
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|uint32_t
modifier|*
name|isrptr
decl_stmt|,
modifier|*
name|tmrptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|,
name|bitpos
decl_stmt|,
name|vector
decl_stmt|;
name|isrptr
operator|=
operator|&
name|lapic
operator|->
name|isr0
expr_stmt|;
name|tmrptr
operator|=
operator|&
name|lapic
operator|->
name|tmr0
expr_stmt|;
comment|/* 	 * The x86 architecture reserves the the first 32 vectors for use 	 * by the processor. 	 */
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|idx
operator|=
name|i
operator|*
literal|4
expr_stmt|;
name|bitpos
operator|=
name|fls
argument_list|(
name|isrptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|--
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|vlapic
operator|->
name|isrvec_stk_top
operator|<=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"invalid vlapic isrvec_stk_top %d"
argument_list|,
name|vlapic
operator|->
name|isrvec_stk_top
argument_list|)
expr_stmt|;
block|}
name|isrptr
index|[
name|idx
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bitpos
operator|)
expr_stmt|;
name|VLAPIC_CTR_ISR
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic_process_eoi"
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|isrvec_stk_top
operator|--
expr_stmt|;
name|vlapic_update_ppr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmrptr
index|[
name|idx
index|]
operator|&
operator|(
literal|1
operator|<<
name|bitpos
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vector
operator|=
name|i
operator|*
literal|32
operator|+
name|bitpos
expr_stmt|;
name|vioapic_process_eoi
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|vlapic_get_lvt_field
parameter_list|(
name|uint32_t
name|lvt
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
return|return
operator|(
name|lvt
operator|&
name|mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|vlapic_periodic_timer
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|uint32_t
name|lvt
decl_stmt|;
name|lvt
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_TIMER_LVT
argument_list|)
expr_stmt|;
return|return
operator|(
name|vlapic_get_lvt_field
argument_list|(
name|lvt
argument_list|,
name|APIC_LVTT_TM_PERIODIC
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|VMM_STAT
argument_list|(
name|VLAPIC_INTR_TIMER
argument_list|,
literal|"timer interrupts generated by vlapic"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|vlapic_fire_timer
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|int
name|vector
decl_stmt|;
name|uint32_t
name|lvt
decl_stmt|;
name|KASSERT
argument_list|(
name|VLAPIC_TIMER_LOCKED
argument_list|(
name|vlapic
argument_list|)
argument_list|,
operator|(
literal|"vlapic_fire_timer not locked"
operator|)
argument_list|)
expr_stmt|;
name|lvt
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_TIMER_LVT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vlapic_get_lvt_field
argument_list|(
name|lvt
argument_list|,
name|APIC_LVTT_M
argument_list|)
condition|)
block|{
name|vmm_stat_incr
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
name|VLAPIC_INTR_TIMER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vector
operator|=
name|vlapic_get_lvt_field
argument_list|(
name|lvt
argument_list|,
name|APIC_LVTT_VECTOR
argument_list|)
expr_stmt|;
name|vlapic_set_intr_ready
argument_list|(
name|vlapic
argument_list|,
name|vector
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|vcpu_notify_event
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_callout_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|struct
name|bintime
name|bt
decl_stmt|,
name|btnow
decl_stmt|;
name|sbintime_t
name|rem_sbt
decl_stmt|;
name|vlapic
operator|=
name|arg
expr_stmt|;
name|VLAPIC_TIMER_LOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|)
condition|)
comment|/* callout was reset */
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|callout_active
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|)
condition|)
comment|/* callout was stopped */
goto|goto
name|done
goto|;
name|callout_deactivate
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vlapic
operator|->
name|apic
operator|.
name|icr_timer
operator|!=
literal|0
argument_list|,
operator|(
literal|"vlapic timer is disabled"
operator|)
argument_list|)
expr_stmt|;
name|vlapic_fire_timer
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlapic_periodic_timer
argument_list|(
name|vlapic
argument_list|)
condition|)
block|{
name|binuptime
argument_list|(
operator|&
name|btnow
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bintime_cmp
argument_list|(
operator|&
name|btnow
argument_list|,
operator|&
name|vlapic
operator|->
name|timer_fire_bt
argument_list|,
operator|>=
argument_list|)
argument_list|,
operator|(
literal|"vlapic callout at %#lx.%#lx, expected at %#lx.#%lx"
operator|,
name|btnow
operator|.
name|sec
operator|,
name|btnow
operator|.
name|frac
operator|,
name|vlapic
operator|->
name|timer_fire_bt
operator|.
name|sec
operator|,
name|vlapic
operator|->
name|timer_fire_bt
operator|.
name|frac
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Compute the delta between when the timer was supposed to 		 * fire and the present time. 		 */
name|bt
operator|=
name|btnow
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|vlapic
operator|->
name|timer_fire_bt
argument_list|)
expr_stmt|;
name|rem_sbt
operator|=
name|bttosbt
argument_list|(
name|vlapic
operator|->
name|timer_period_bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bintime_cmp
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|vlapic
operator|->
name|timer_period_bt
argument_list|,
operator|<
argument_list|)
condition|)
block|{
comment|/* 			 * Adjust the time until the next countdown downward 			 * to account for the lost time. 			 */
name|rem_sbt
operator|-=
name|bttosbt
argument_list|(
name|bt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If the delta is greater than the timer period then 			 * just reset our time base instead of trying to catch 			 * up. 			 */
name|vlapic
operator|->
name|timer_fire_bt
operator|=
name|btnow
expr_stmt|;
name|VLAPIC_CTR2
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic timer lagging by %lu "
literal|"usecs, period is %lu usecs - resetting time base"
argument_list|,
name|bttosbt
argument_list|(
name|bt
argument_list|)
operator|/
name|SBT_1US
argument_list|,
name|bttosbt
argument_list|(
name|vlapic
operator|->
name|timer_period_bt
argument_list|)
operator|/
name|SBT_1US
argument_list|)
expr_stmt|;
block|}
name|bintime_add
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_fire_bt
argument_list|,
operator|&
name|vlapic
operator|->
name|timer_period_bt
argument_list|)
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|,
name|rem_sbt
argument_list|,
literal|0
argument_list|,
name|vlapic_callout_handler
argument_list|,
name|vlapic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|VLAPIC_TIMER_UNLOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_set_icr_timer
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|icr_timer
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|sbintime_t
name|sbt
decl_stmt|;
name|VLAPIC_TIMER_LOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|lapic
operator|=
operator|&
name|vlapic
operator|->
name|apic
expr_stmt|;
name|lapic
operator|->
name|icr_timer
operator|=
name|icr_timer
expr_stmt|;
name|vlapic
operator|->
name|timer_period_bt
operator|=
name|vlapic
operator|->
name|timer_freq_bt
expr_stmt|;
name|bintime_mul
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_period_bt
argument_list|,
name|icr_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|icr_timer
operator|!=
literal|0
condition|)
block|{
name|binuptime
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_fire_bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_fire_bt
argument_list|,
operator|&
name|vlapic
operator|->
name|timer_period_bt
argument_list|)
expr_stmt|;
name|sbt
operator|=
name|bttosbt
argument_list|(
name|vlapic
operator|->
name|timer_period_bt
argument_list|)
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|,
name|sbt
argument_list|,
literal|0
argument_list|,
name|vlapic_callout_handler
argument_list|,
name|vlapic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|callout_stop
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|)
expr_stmt|;
name|VLAPIC_TIMER_UNLOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function populates 'dmask' with the set of vcpus that match the  * addressing specified by the (dest, phys, lowprio) tuple.  *   * 'x2apic_dest' specifies whether 'dest' is interpreted as x2APIC (32-bit)  * or xAPIC (8-bit) destination field.  */
end_comment

begin_function
specifier|static
name|void
name|vlapic_calcdest
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|cpuset_t
modifier|*
name|dmask
parameter_list|,
name|uint32_t
name|dest
parameter_list|,
name|bool
name|phys
parameter_list|,
name|bool
name|lowprio
parameter_list|,
name|bool
name|x2apic_dest
parameter_list|)
block|{
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|uint32_t
name|dfr
decl_stmt|,
name|ldr
decl_stmt|,
name|ldest
decl_stmt|,
name|cluster
decl_stmt|;
name|uint32_t
name|mda_flat_ldest
decl_stmt|,
name|mda_cluster_ldest
decl_stmt|,
name|mda_ldest
decl_stmt|,
name|mda_cluster_id
decl_stmt|;
name|cpuset_t
name|amask
decl_stmt|;
name|int
name|vcpuid
decl_stmt|;
if|if
condition|(
operator|(
name|x2apic_dest
operator|&&
name|dest
operator|==
literal|0xffffffff
operator|)
operator|||
operator|(
operator|!
name|x2apic_dest
operator|&&
name|dest
operator|==
literal|0xff
operator|)
condition|)
block|{
comment|/* 		 * Broadcast in both logical and physical modes. 		 */
operator|*
name|dmask
operator|=
name|vm_active_cpus
argument_list|(
name|vm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|phys
condition|)
block|{
comment|/* 		 * Physical mode: destination is APIC ID. 		 */
name|CPU_ZERO
argument_list|(
name|dmask
argument_list|)
expr_stmt|;
name|vcpuid
operator|=
name|vm_apicid2vcpuid
argument_list|(
name|vm
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcpuid
operator|<
name|VM_MAXCPU
condition|)
name|CPU_SET
argument_list|(
name|vcpuid
argument_list|,
name|dmask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * In the "Flat Model" the MDA is interpreted as an 8-bit wide 		 * bitmask. This model is only avilable in the xAPIC mode. 		 */
name|mda_flat_ldest
operator|=
name|dest
operator|&
literal|0xff
expr_stmt|;
comment|/* 		 * In the "Cluster Model" the MDA is used to identify a 		 * specific cluster and a set of APICs in that cluster. 		 */
if|if
condition|(
name|x2apic_dest
condition|)
block|{
name|mda_cluster_id
operator|=
name|dest
operator|>>
literal|16
expr_stmt|;
name|mda_cluster_ldest
operator|=
name|dest
operator|&
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
name|mda_cluster_id
operator|=
operator|(
name|dest
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
name|mda_cluster_ldest
operator|=
name|dest
operator|&
literal|0xf
expr_stmt|;
block|}
comment|/* 		 * Logical mode: match each APIC that has a bit set 		 * in it's LDR that matches a bit in the ldest. 		 */
name|CPU_ZERO
argument_list|(
name|dmask
argument_list|)
expr_stmt|;
name|amask
operator|=
name|vm_active_cpus
argument_list|(
name|vm
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|vcpuid
operator|=
name|CPU_FFS
argument_list|(
operator|&
name|amask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vcpuid
operator|--
expr_stmt|;
name|CPU_CLR
argument_list|(
name|vcpuid
argument_list|,
operator|&
name|amask
argument_list|)
expr_stmt|;
name|vlapic
operator|=
name|vm_lapic
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
name|dfr
operator|=
name|vlapic_get_dfr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|ldr
operator|=
name|vlapic_get_ldr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dfr
operator|&
name|APIC_DFR_MODEL_MASK
operator|)
operator|==
name|APIC_DFR_MODEL_FLAT
condition|)
block|{
name|ldest
operator|=
name|ldr
operator|>>
literal|24
expr_stmt|;
name|mda_ldest
operator|=
name|mda_flat_ldest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dfr
operator|&
name|APIC_DFR_MODEL_MASK
operator|)
operator|==
name|APIC_DFR_MODEL_CLUSTER
condition|)
block|{
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
block|{
name|cluster
operator|=
name|ldr
operator|>>
literal|16
expr_stmt|;
name|ldest
operator|=
name|ldr
operator|&
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
name|cluster
operator|=
name|ldr
operator|>>
literal|28
expr_stmt|;
name|ldest
operator|=
operator|(
name|ldr
operator|>>
literal|24
operator|)
operator|&
literal|0xf
expr_stmt|;
block|}
if|if
condition|(
name|cluster
operator|!=
name|mda_cluster_id
condition|)
continue|continue;
name|mda_ldest
operator|=
name|mda_cluster_ldest
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Guest has configured a bad logical 				 * model for this vcpu - skip it. 				 */
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic has bad logical "
literal|"model %x - cannot deliver interrupt"
argument_list|,
name|dfr
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|mda_ldest
operator|&
name|ldest
operator|)
operator|!=
literal|0
condition|)
block|{
name|CPU_SET
argument_list|(
name|vcpuid
argument_list|,
name|dmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowprio
condition|)
break|break;
block|}
block|}
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|VMM_STAT_ARRAY
argument_list|(
name|IPIS_SENT
argument_list|,
name|VM_MAXCPU
argument_list|,
literal|"ipis sent to vcpu"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|lapic_process_icr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint64_t
name|icrval
parameter_list|,
name|bool
modifier|*
name|retu
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bool
name|phys
decl_stmt|;
name|cpuset_t
name|dmask
decl_stmt|;
name|uint32_t
name|dest
decl_stmt|,
name|vec
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|vlapic
modifier|*
name|vlapic2
decl_stmt|;
name|struct
name|vm_exit
modifier|*
name|vmexit
decl_stmt|;
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
name|dest
operator|=
name|icrval
operator|>>
literal|32
expr_stmt|;
else|else
name|dest
operator|=
name|icrval
operator|>>
operator|(
literal|32
operator|+
literal|24
operator|)
expr_stmt|;
name|vec
operator|=
name|icrval
operator|&
name|APIC_VECTOR_MASK
expr_stmt|;
name|mode
operator|=
name|icrval
operator|&
name|APIC_DELMODE_MASK
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|APIC_DELMODE_FIXED
operator|||
name|mode
operator|==
name|APIC_DELMODE_NMI
condition|)
block|{
switch|switch
condition|(
name|icrval
operator|&
name|APIC_DEST_MASK
condition|)
block|{
case|case
name|APIC_DEST_DESTFLD
case|:
name|phys
operator|=
operator|(
operator|(
name|icrval
operator|&
name|APIC_DESTMODE_LOG
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
name|vlapic_calcdest
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
operator|&
name|dmask
argument_list|,
name|dest
argument_list|,
name|phys
argument_list|,
name|false
argument_list|,
name|x2apic
argument_list|(
name|vlapic
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_DEST_SELF
case|:
name|CPU_SETOF
argument_list|(
name|vlapic
operator|->
name|vcpuid
argument_list|,
operator|&
name|dmask
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_DEST_ALLISELF
case|:
name|dmask
operator|=
name|vm_active_cpus
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_DEST_ALLESELF
case|:
name|dmask
operator|=
name|vm_active_cpus
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|)
expr_stmt|;
name|CPU_CLR
argument_list|(
name|vlapic
operator|->
name|vcpuid
argument_list|,
operator|&
name|dmask
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CPU_ZERO
argument_list|(
operator|&
name|dmask
argument_list|)
expr_stmt|;
comment|/* satisfy gcc */
break|break;
block|}
while|while
condition|(
operator|(
name|i
operator|=
name|CPU_FFS
argument_list|(
operator|&
name|dmask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|CPU_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|dmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|APIC_DELMODE_FIXED
condition|)
block|{
name|lapic_intr_edge
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|i
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|vmm_stat_array_incr
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
name|IPIS_SENT
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|vm_inject_nmi
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* handled completely in the kernel */
block|}
if|if
condition|(
name|mode
operator|==
name|APIC_DELMODE_INIT
condition|)
block|{
if|if
condition|(
operator|(
name|icrval
operator|&
name|APIC_LEVEL_MASK
operator|)
operator|==
name|APIC_LEVEL_DEASSERT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|vlapic
operator|->
name|vcpuid
operator|==
literal|0
operator|&&
name|dest
operator|!=
literal|0
operator|&&
name|dest
operator|<
name|VM_MAXCPU
condition|)
block|{
name|vlapic2
operator|=
name|vm_lapic
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/* move from INIT to waiting-for-SIPI state */
if|if
condition|(
name|vlapic2
operator|->
name|boot_state
operator|==
name|BS_INIT
condition|)
block|{
name|vlapic2
operator|->
name|boot_state
operator|=
name|BS_SIPI
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|APIC_DELMODE_STARTUP
condition|)
block|{
if|if
condition|(
name|vlapic
operator|->
name|vcpuid
operator|==
literal|0
operator|&&
name|dest
operator|!=
literal|0
operator|&&
name|dest
operator|<
name|VM_MAXCPU
condition|)
block|{
name|vlapic2
operator|=
name|vm_lapic
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/* 			 * Ignore SIPIs in any state other than wait-for-SIPI 			 */
if|if
condition|(
name|vlapic2
operator|->
name|boot_state
operator|!=
name|BS_SIPI
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 			 * XXX this assumes that the startup IPI always succeeds 			 */
name|vlapic2
operator|->
name|boot_state
operator|=
name|BS_RUNNING
expr_stmt|;
name|vm_activate_cpu
argument_list|(
name|vlapic2
operator|->
name|vm
argument_list|,
name|dest
argument_list|)
expr_stmt|;
operator|*
name|retu
operator|=
name|true
expr_stmt|;
name|vmexit
operator|=
name|vm_exitinfo
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_SPINUP_AP
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|spinup_ap
operator|.
name|vcpu
operator|=
name|dest
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|spinup_ap
operator|.
name|rip
operator|=
name|vec
operator|<<
name|PAGE_SHIFT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * This will cause a return to userland. 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vlapic_pending_intr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|i
decl_stmt|,
name|bitpos
decl_stmt|,
name|vector
decl_stmt|;
name|uint32_t
modifier|*
name|irrptr
decl_stmt|,
name|val
decl_stmt|;
name|irrptr
operator|=
operator|&
name|lapic
operator|->
name|irr0
expr_stmt|;
comment|/* 	 * The x86 architecture reserves the the first 32 vectors for use 	 * by the processor. 	 */
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|idx
operator|=
name|i
operator|*
literal|4
expr_stmt|;
name|val
operator|=
name|atomic_load_acq_int
argument_list|(
operator|&
name|irrptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|bitpos
operator|=
name|fls
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|!=
literal|0
condition|)
block|{
name|vector
operator|=
name|i
operator|*
literal|32
operator|+
operator|(
name|bitpos
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|PRIO
argument_list|(
name|vector
argument_list|)
operator|>
name|PRIO
argument_list|(
name|lapic
operator|->
name|ppr
argument_list|)
condition|)
block|{
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"pending intr %d"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return
operator|(
name|vector
operator|)
return|;
block|}
else|else
break|break;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vlapic_intr_accepted
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|int
name|vector
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|uint32_t
modifier|*
name|irrptr
decl_stmt|,
modifier|*
name|isrptr
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|stk_top
decl_stmt|;
comment|/* 	 * clear the ready bit for vector being accepted in irr  	 * and set the vector as in service in isr. 	 */
name|idx
operator|=
operator|(
name|vector
operator|/
literal|32
operator|)
operator|*
literal|4
expr_stmt|;
name|irrptr
operator|=
operator|&
name|lapic
operator|->
name|irr0
expr_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|irrptr
index|[
name|idx
index|]
argument_list|,
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
argument_list|)
expr_stmt|;
name|VLAPIC_CTR_IRR
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic_intr_accepted"
argument_list|)
expr_stmt|;
name|isrptr
operator|=
operator|&
name|lapic
operator|->
name|isr0
expr_stmt|;
name|isrptr
index|[
name|idx
index|]
operator||=
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
expr_stmt|;
name|VLAPIC_CTR_ISR
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic_intr_accepted"
argument_list|)
expr_stmt|;
comment|/* 	 * Update the PPR 	 */
name|vlapic
operator|->
name|isrvec_stk_top
operator|++
expr_stmt|;
name|stk_top
operator|=
name|vlapic
operator|->
name|isrvec_stk_top
expr_stmt|;
if|if
condition|(
name|stk_top
operator|>=
name|ISRVEC_STK_SIZE
condition|)
name|panic
argument_list|(
literal|"isrvec_stk_top overflow %d"
argument_list|,
name|stk_top
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|isrvec_stk
index|[
name|stk_top
index|]
operator|=
name|vector
expr_stmt|;
name|vlapic_update_ppr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_set_svr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|new
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|uint32_t
name|old
decl_stmt|,
name|changed
decl_stmt|;
name|lapic
operator|=
operator|&
name|vlapic
operator|->
name|apic
expr_stmt|;
name|old
operator|=
name|lapic
operator|->
name|svr
expr_stmt|;
name|changed
operator|=
name|old
operator|^
name|new
expr_stmt|;
if|if
condition|(
operator|(
name|changed
operator|&
name|APIC_SVR_ENABLE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|new
operator|&
name|APIC_SVR_ENABLE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The apic is now disabled so stop the apic timer. 			 */
name|VLAPIC_CTR0
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic is software-disabled"
argument_list|)
expr_stmt|;
name|VLAPIC_TIMER_LOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|)
expr_stmt|;
name|VLAPIC_TIMER_UNLOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The apic is now enabled so restart the apic timer 			 * if it is configured in periodic mode. 			 */
name|VLAPIC_CTR0
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic is software-enabled"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlapic_periodic_timer
argument_list|(
name|vlapic
argument_list|)
condition|)
name|vlapic_set_icr_timer
argument_list|(
name|vlapic
argument_list|,
name|lapic
operator|->
name|icr_timer
argument_list|)
expr_stmt|;
block|}
block|}
name|lapic
operator|->
name|svr
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vlapic_read
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
modifier|*
name|data
parameter_list|,
name|bool
modifier|*
name|retu
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|uint32_t
modifier|*
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|offset
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|lapic
argument_list|)
condition|)
block|{
operator|*
name|data
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|offset
operator|&=
operator|~
literal|3
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|APIC_OFFSET_ID
case|:
operator|*
name|data
operator|=
name|vlapic_get_id
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_VER
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|version
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_TPR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|tpr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_APR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|apr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_PPR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|ppr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_EOI
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|eoi
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_LDR
case|:
operator|*
name|data
operator|=
name|vlapic_get_ldr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_DFR
case|:
operator|*
name|data
operator|=
name|vlapic_get_dfr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_SVR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|svr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ISR0
operator|...
name|APIC_OFFSET_ISR7
case|:
name|i
operator|=
operator|(
name|offset
operator|-
name|APIC_OFFSET_ISR0
operator|)
operator|>>
literal|2
expr_stmt|;
name|reg
operator|=
operator|&
name|lapic
operator|->
name|isr0
expr_stmt|;
operator|*
name|data
operator|=
operator|*
operator|(
name|reg
operator|+
name|i
operator|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_TMR0
operator|...
name|APIC_OFFSET_TMR7
case|:
name|i
operator|=
operator|(
name|offset
operator|-
name|APIC_OFFSET_TMR0
operator|)
operator|>>
literal|2
expr_stmt|;
name|reg
operator|=
operator|&
name|lapic
operator|->
name|tmr0
expr_stmt|;
operator|*
name|data
operator|=
operator|*
operator|(
name|reg
operator|+
name|i
operator|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_IRR0
operator|...
name|APIC_OFFSET_IRR7
case|:
name|i
operator|=
operator|(
name|offset
operator|-
name|APIC_OFFSET_IRR0
operator|)
operator|>>
literal|2
expr_stmt|;
name|reg
operator|=
operator|&
name|lapic
operator|->
name|irr0
expr_stmt|;
operator|*
name|data
operator|=
name|atomic_load_acq_int
argument_list|(
name|reg
operator|+
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ESR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|esr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ICR_LOW
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|icr_lo
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ICR_HI
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|icr_hi
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_TIMER_LVT
operator|...
name|APIC_OFFSET_ERROR_LVT
case|:
operator|*
name|data
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ICR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|icr_timer
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_CCR
case|:
operator|*
name|data
operator|=
name|vlapic_get_ccr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_DCR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|dcr_timer
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_RRR
case|:
default|default:
operator|*
name|data
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|done
label|:
name|VLAPIC_CTR2
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic read offset %#x, data %#lx"
argument_list|,
name|offset
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|vlapic_write
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|data
parameter_list|,
name|bool
modifier|*
name|retu
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|VLAPIC_CTR2
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic write offset %#x, data %#lx"
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|lapic
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|retval
operator|=
literal|0
expr_stmt|;
name|offset
operator|&=
operator|~
literal|3
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|APIC_OFFSET_ID
case|:
break|break;
case|case
name|APIC_OFFSET_TPR
case|:
name|lapic
operator|->
name|tpr
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
name|vlapic_update_ppr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_EOI
case|:
name|vlapic_process_eoi
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_LDR
case|:
name|vlapic_set_ldr
argument_list|(
name|vlapic
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_DFR
case|:
name|vlapic_set_dfr
argument_list|(
name|vlapic
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_SVR
case|:
name|lapic_set_svr
argument_list|(
name|vlapic
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ICR_LOW
case|:
if|if
condition|(
operator|!
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
block|{
name|data
operator|&=
literal|0xffffffff
expr_stmt|;
name|data
operator||=
operator|(
name|uint64_t
operator|)
name|lapic
operator|->
name|icr_hi
operator|<<
literal|32
expr_stmt|;
block|}
name|retval
operator|=
name|lapic_process_icr
argument_list|(
name|vlapic
argument_list|,
name|data
argument_list|,
name|retu
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ICR_HI
case|:
if|if
condition|(
operator|!
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|lapic
operator|->
name|icr_hi
operator|=
name|data
expr_stmt|;
block|}
break|break;
case|case
name|APIC_OFFSET_TIMER_LVT
operator|...
name|APIC_OFFSET_ERROR_LVT
case|:
name|vlapic_set_lvt
argument_list|(
name|vlapic
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ICR
case|:
name|vlapic_set_icr_timer
argument_list|(
name|vlapic
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_DCR
case|:
name|vlapic_set_dcr
argument_list|(
name|vlapic
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ESR
case|:
name|vlapic_update_errors
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_VER
case|:
case|case
name|APIC_OFFSET_APR
case|:
case|case
name|APIC_OFFSET_PPR
case|:
case|case
name|APIC_OFFSET_RRR
case|:
case|case
name|APIC_OFFSET_ISR0
operator|...
name|APIC_OFFSET_ISR7
case|:
case|case
name|APIC_OFFSET_TMR0
operator|...
name|APIC_OFFSET_TMR7
case|:
case|case
name|APIC_OFFSET_IRR0
operator|...
name|APIC_OFFSET_IRR7
case|:
case|case
name|APIC_OFFSET_CCR
case|:
default|default:
comment|// Read only.
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|vlapic
modifier|*
name|vlapic_init
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|)
block|{
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|vlapic
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vlapic
argument_list|)
argument_list|,
name|M_VLAPIC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|vlapic
operator|->
name|vcpuid
operator|=
name|vcpuid
expr_stmt|;
comment|/* 	 * If the vlapic is configured in x2apic mode then it will be 	 * accessed in the critical section via the MSR emulation code. 	 * 	 * Therefore the timer mutex must be a spinlock because blockable 	 * mutexes cannot be acquired in a critical section. 	 */
name|mtx_init
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_mtx
argument_list|,
literal|"vlapic timer mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|msr_apicbase
operator|=
name|DEFAULT_APIC_BASE
operator||
name|APICBASE_ENABLED
expr_stmt|;
if|if
condition|(
name|vcpuid
operator|==
literal|0
condition|)
name|vlapic
operator|->
name|msr_apicbase
operator||=
name|APICBASE_BSP
expr_stmt|;
name|vlapic_reset
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
return|return
operator|(
name|vlapic
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vlapic_cleanup
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|callout_drain
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vlapic
argument_list|,
name|M_VLAPIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|vlapic_get_apicbase
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
return|return
operator|(
name|vlapic
operator|->
name|msr_apicbase
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vlapic_set_apicbase
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|enum
name|x2apic_state
name|state
decl_stmt|;
name|err
operator|=
name|vm_get_x2apic_state
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|panic
argument_list|(
literal|"vlapic_set_apicbase: err %d fetching x2apic state"
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|X2APIC_DISABLED
condition|)
name|val
operator|&=
operator|~
name|APICBASE_X2APIC
expr_stmt|;
name|vlapic
operator|->
name|msr_apicbase
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vlapic_set_x2apic_state
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|enum
name|x2apic_state
name|state
parameter_list|)
block|{
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|vlapic
operator|=
name|vm_lapic
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|X2APIC_DISABLED
condition|)
name|vlapic
operator|->
name|msr_apicbase
operator|&=
operator|~
name|APICBASE_X2APIC
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vlapic_deliver_intr
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|bool
name|level
parameter_list|,
name|uint32_t
name|dest
parameter_list|,
name|bool
name|phys
parameter_list|,
name|int
name|delmode
parameter_list|,
name|int
name|vec
parameter_list|)
block|{
name|bool
name|lowprio
decl_stmt|;
name|int
name|vcpuid
decl_stmt|;
name|cpuset_t
name|dmask
decl_stmt|;
if|if
condition|(
name|delmode
operator|!=
name|APIC_DELMODE_FIXED
operator|&&
name|delmode
operator|!=
name|APIC_DELMODE_LOWPRIO
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vm
argument_list|,
literal|"vlapic intr invalid delmode %#x"
argument_list|,
name|delmode
argument_list|)
expr_stmt|;
return|return;
block|}
name|lowprio
operator|=
operator|(
name|delmode
operator|==
name|APIC_DELMODE_LOWPRIO
operator|)
expr_stmt|;
comment|/* 	 * We don't provide any virtual interrupt redirection hardware so 	 * all interrupts originating from the ioapic or MSI specify the 	 * 'dest' in the legacy xAPIC format. 	 */
name|vlapic_calcdest
argument_list|(
name|vm
argument_list|,
operator|&
name|dmask
argument_list|,
name|dest
argument_list|,
name|phys
argument_list|,
name|lowprio
argument_list|,
name|false
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|vcpuid
operator|=
name|CPU_FFS
argument_list|(
operator|&
name|dmask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vcpuid
operator|--
expr_stmt|;
name|CPU_CLR
argument_list|(
name|vcpuid
argument_list|,
operator|&
name|dmask
argument_list|)
expr_stmt|;
name|lapic_set_intr
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|vec
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|vlapic_enabled
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
if|if
condition|(
operator|(
name|vlapic
operator|->
name|msr_apicbase
operator|&
name|APICBASE_ENABLED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|lapic
operator|->
name|svr
operator|&
name|APIC_SVR_ENABLE
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

end_unit

