begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 NetApp, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<x86/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<x86/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|"vmm_ipi.h"
end_include

begin_include
include|#
directive|include
file|"vmm_lapic.h"
end_include

begin_include
include|#
directive|include
file|"vmm_ktr.h"
end_include

begin_include
include|#
directive|include
file|"vmm_stat.h"
end_include

begin_include
include|#
directive|include
file|"vlapic.h"
end_include

begin_include
include|#
directive|include
file|"vlapic_priv.h"
end_include

begin_include
include|#
directive|include
file|"vioapic.h"
end_include

begin_define
define|#
directive|define
name|PRIO
parameter_list|(
name|x
parameter_list|)
value|((x)>> 4)
end_define

begin_define
define|#
directive|define
name|VLAPIC_VERSION
value|(16)
end_define

begin_define
define|#
directive|define
name|x2apic
parameter_list|(
name|vlapic
parameter_list|)
value|(((vlapic)->msr_apicbase& APICBASE_X2APIC) ? 1 : 0)
end_define

begin_comment
comment|/*  * The 'vlapic->timer_mtx' is used to provide mutual exclusion between the  * vlapic_callout_handler() and vcpu accesses to:  * - timer_freq_bt, timer_period_bt, timer_fire_bt  * - timer LVT register  */
end_comment

begin_define
define|#
directive|define
name|VLAPIC_TIMER_LOCK
parameter_list|(
name|vlapic
parameter_list|)
value|mtx_lock_spin(&((vlapic)->timer_mtx))
end_define

begin_define
define|#
directive|define
name|VLAPIC_TIMER_UNLOCK
parameter_list|(
name|vlapic
parameter_list|)
value|mtx_unlock_spin(&((vlapic)->timer_mtx))
end_define

begin_define
define|#
directive|define
name|VLAPIC_TIMER_LOCKED
parameter_list|(
name|vlapic
parameter_list|)
value|mtx_owned(&((vlapic)->timer_mtx))
end_define

begin_comment
comment|/*  * APIC timer frequency:  * - arbitrary but chosen to be in the ballpark of contemporary hardware.  * - power-of-two to avoid loss of precision when converted to a bintime.  */
end_comment

begin_define
define|#
directive|define
name|VLAPIC_BUS_FREQ
value|(128 * 1024 * 1024)
end_define

begin_function
specifier|static
name|__inline
name|uint32_t
name|vlapic_get_id
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
return|return
operator|(
name|vlapic
operator|->
name|vcpuid
operator|)
return|;
else|else
return|return
operator|(
name|vlapic
operator|->
name|vcpuid
operator|<<
literal|24
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|x2apic_ldr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|int
name|apicid
decl_stmt|;
name|uint32_t
name|ldr
decl_stmt|;
name|apicid
operator|=
name|vlapic_get_id
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|ldr
operator|=
literal|1
operator|<<
operator|(
name|apicid
operator|&
literal|0xf
operator|)
expr_stmt|;
name|ldr
operator||=
operator|(
name|apicid
operator|&
literal|0xffff0
operator|)
operator|<<
literal|12
expr_stmt|;
return|return
operator|(
name|ldr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vlapic_dfr_write_handler
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|lapic
operator|=
name|vlapic
operator|->
name|apic_page
expr_stmt|;
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
literal|"ignoring write to DFR in x2apic mode: %#x"
argument_list|,
name|lapic
operator|->
name|dfr
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|dfr
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|lapic
operator|->
name|dfr
operator|&=
name|APIC_DFR_MODEL_MASK
expr_stmt|;
name|lapic
operator|->
name|dfr
operator||=
name|APIC_DFR_RESERVED
expr_stmt|;
if|if
condition|(
operator|(
name|lapic
operator|->
name|dfr
operator|&
name|APIC_DFR_MODEL_MASK
operator|)
operator|==
name|APIC_DFR_MODEL_FLAT
condition|)
name|VLAPIC_CTR0
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic DFR in Flat Model"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|lapic
operator|->
name|dfr
operator|&
name|APIC_DFR_MODEL_MASK
operator|)
operator|==
name|APIC_DFR_MODEL_CLUSTER
condition|)
name|VLAPIC_CTR0
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic DFR in Cluster Model"
argument_list|)
expr_stmt|;
else|else
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"DFR in Unknown Model %#x"
argument_list|,
name|lapic
operator|->
name|dfr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vlapic_ldr_write_handler
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|lapic
operator|=
name|vlapic
operator|->
name|apic_page
expr_stmt|;
comment|/* LDR is read-only in x2apic mode */
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
block|{
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"ignoring write to LDR in x2apic mode: %#x"
argument_list|,
name|lapic
operator|->
name|ldr
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|ldr
operator|=
name|x2apic_ldr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lapic
operator|->
name|ldr
operator|&=
operator|~
name|APIC_LDR_RESERVED
expr_stmt|;
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic LDR set to %#x"
argument_list|,
name|lapic
operator|->
name|ldr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vlapic_id_write_handler
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
comment|/* 	 * We don't allow the ID register to be modified so reset it back to 	 * its default value. 	 */
name|lapic
operator|=
name|vlapic
operator|->
name|apic_page
expr_stmt|;
name|lapic
operator|->
name|id
operator|=
name|vlapic_get_id
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vlapic_timer_divisor
parameter_list|(
name|uint32_t
name|dcr
parameter_list|)
block|{
switch|switch
condition|(
name|dcr
operator|&
literal|0xB
condition|)
block|{
case|case
name|APIC_TDCR_1
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|APIC_TDCR_2
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
name|APIC_TDCR_4
case|:
return|return
operator|(
literal|4
operator|)
return|;
case|case
name|APIC_TDCR_8
case|:
return|return
operator|(
literal|8
operator|)
return|;
case|case
name|APIC_TDCR_16
case|:
return|return
operator|(
literal|16
operator|)
return|;
case|case
name|APIC_TDCR_32
case|:
return|return
operator|(
literal|32
operator|)
return|;
case|case
name|APIC_TDCR_64
case|:
return|return
operator|(
literal|64
operator|)
return|;
case|case
name|APIC_TDCR_128
case|:
return|return
operator|(
literal|128
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"vlapic_timer_divisor: invalid dcr 0x%08x"
argument_list|,
name|dcr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static inline void vlapic_dump_lvt(uint32_t offset, uint32_t *lvt) { 	printf("Offset %x: lvt %08x (V:%02x DS:%x M:%x)\n", offset, 	    *lvt, *lvt& APIC_LVTT_VECTOR, *lvt& APIC_LVTT_DS, 	    *lvt& APIC_LVTT_M); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|uint32_t
name|vlapic_get_ccr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|bintime
name|bt_now
decl_stmt|,
name|bt_rem
decl_stmt|;
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|uint32_t
name|ccr
decl_stmt|;
name|ccr
operator|=
literal|0
expr_stmt|;
name|lapic
operator|=
name|vlapic
operator|->
name|apic_page
expr_stmt|;
name|VLAPIC_TIMER_LOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_active
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|)
condition|)
block|{
comment|/* 		 * If the timer is scheduled to expire in the future then 		 * compute the value of 'ccr' based on the remaining time. 		 */
name|binuptime
argument_list|(
operator|&
name|bt_now
argument_list|)
expr_stmt|;
if|if
condition|(
name|bintime_cmp
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_fire_bt
argument_list|,
operator|&
name|bt_now
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|bt_rem
operator|=
name|vlapic
operator|->
name|timer_fire_bt
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|bt_rem
argument_list|,
operator|&
name|bt_now
argument_list|)
expr_stmt|;
name|ccr
operator|+=
name|bt_rem
operator|.
name|sec
operator|*
name|BT2FREQ
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_freq_bt
argument_list|)
expr_stmt|;
name|ccr
operator|+=
name|bt_rem
operator|.
name|frac
operator|/
name|vlapic
operator|->
name|timer_freq_bt
operator|.
name|frac
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
name|ccr
operator|<=
name|lapic
operator|->
name|icr_timer
argument_list|,
operator|(
literal|"vlapic_get_ccr: invalid ccr %#x, "
literal|"icr_timer is %#x"
operator|,
name|ccr
operator|,
name|lapic
operator|->
name|icr_timer
operator|)
argument_list|)
expr_stmt|;
name|VLAPIC_CTR2
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic ccr_timer = %#x, icr_timer = %#x"
argument_list|,
name|ccr
argument_list|,
name|lapic
operator|->
name|icr_timer
argument_list|)
expr_stmt|;
name|VLAPIC_TIMER_UNLOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
return|return
operator|(
name|ccr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vlapic_dcr_write_handler
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|int
name|divisor
decl_stmt|;
name|lapic
operator|=
name|vlapic
operator|->
name|apic_page
expr_stmt|;
name|VLAPIC_TIMER_LOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|divisor
operator|=
name|vlapic_timer_divisor
argument_list|(
name|lapic
operator|->
name|dcr_timer
argument_list|)
expr_stmt|;
name|VLAPIC_CTR2
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic dcr_timer=%#x, divisor=%d"
argument_list|,
name|lapic
operator|->
name|dcr_timer
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
comment|/* 	 * Update the timer frequency and the timer period. 	 * 	 * XXX changes to the frequency divider will not take effect until 	 * the timer is reloaded. 	 */
name|FREQ2BT
argument_list|(
name|VLAPIC_BUS_FREQ
operator|/
name|divisor
argument_list|,
operator|&
name|vlapic
operator|->
name|timer_freq_bt
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|timer_period_bt
operator|=
name|vlapic
operator|->
name|timer_freq_bt
expr_stmt|;
name|bintime_mul
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_period_bt
argument_list|,
name|lapic
operator|->
name|icr_timer
argument_list|)
expr_stmt|;
name|VLAPIC_TIMER_UNLOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vlapic_esr_write_handler
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|lapic
operator|=
name|vlapic
operator|->
name|apic_page
expr_stmt|;
name|lapic
operator|->
name|esr
operator|=
name|vlapic
operator|->
name|esr_pending
expr_stmt|;
name|vlapic
operator|->
name|esr_pending
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vlapic_set_intr_ready
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|int
name|vector
parameter_list|,
name|bool
name|level
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|uint32_t
modifier|*
name|irrptr
decl_stmt|,
modifier|*
name|tmrptr
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|KASSERT
argument_list|(
name|vector
operator|>=
literal|0
operator|&&
name|vector
operator|<
literal|256
argument_list|,
operator|(
literal|"invalid vector %d"
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
name|lapic
operator|=
name|vlapic
operator|->
name|apic_page
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lapic
operator|->
name|svr
operator|&
name|APIC_SVR_ENABLE
operator|)
condition|)
block|{
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic is software disabled, ignoring "
literal|"interrupt %d"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|vector
operator|<
literal|16
condition|)
block|{
name|vlapic_set_error
argument_list|(
name|vlapic
argument_list|,
name|APIC_ESR_RECEIVE_ILLEGAL_VECTOR
argument_list|)
expr_stmt|;
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic ignoring interrupt to vector %d"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|vlapic
operator|->
name|ops
operator|.
name|set_intr_ready
condition|)
return|return
operator|(
call|(
modifier|*
name|vlapic
operator|->
name|ops
operator|.
name|set_intr_ready
call|)
argument_list|(
name|vlapic
argument_list|,
name|vector
argument_list|,
name|level
argument_list|)
operator|)
return|;
name|idx
operator|=
operator|(
name|vector
operator|/
literal|32
operator|)
operator|*
literal|4
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
expr_stmt|;
name|irrptr
operator|=
operator|&
name|lapic
operator|->
name|irr0
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|irrptr
index|[
name|idx
index|]
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that the trigger-mode of the interrupt matches with 	 * the vlapic TMR registers. 	 */
name|tmrptr
operator|=
operator|&
name|lapic
operator|->
name|tmr0
expr_stmt|;
if|if
condition|(
operator|(
name|tmrptr
index|[
name|idx
index|]
operator|&
name|mask
operator|)
operator|!=
operator|(
name|level
condition|?
name|mask
else|:
literal|0
operator|)
condition|)
block|{
name|VLAPIC_CTR3
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic TMR[%d] is 0x%08x but "
literal|"interrupt is %s-triggered"
argument_list|,
name|idx
operator|/
literal|4
argument_list|,
name|tmrptr
index|[
name|idx
index|]
argument_list|,
name|level
condition|?
literal|"level"
else|:
literal|"edge"
argument_list|)
expr_stmt|;
block|}
name|VLAPIC_CTR_IRR
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic_set_intr_ready"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
modifier|*
name|vlapic_get_lvtptr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
name|vlapic
operator|->
name|apic_page
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|APIC_OFFSET_CMCI_LVT
case|:
return|return
operator|(
operator|&
name|lapic
operator|->
name|lvt_cmci
operator|)
return|;
case|case
name|APIC_OFFSET_TIMER_LVT
operator|...
name|APIC_OFFSET_ERROR_LVT
case|:
name|i
operator|=
operator|(
name|offset
operator|-
name|APIC_OFFSET_TIMER_LVT
operator|)
operator|>>
literal|2
expr_stmt|;
return|return
operator|(
operator|(
operator|&
name|lapic
operator|->
name|lvt_timer
operator|)
operator|+
name|i
operator|)
return|;
empty_stmt|;
default|default:
name|panic
argument_list|(
literal|"vlapic_get_lvt: invalid LVT\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|lvt_off_to_idx
parameter_list|(
name|uint32_t
name|offset
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|APIC_OFFSET_CMCI_LVT
case|:
name|index
operator|=
name|APIC_LVT_CMCI
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_TIMER_LVT
case|:
name|index
operator|=
name|APIC_LVT_TIMER
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_THERM_LVT
case|:
name|index
operator|=
name|APIC_LVT_THERMAL
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_PERF_LVT
case|:
name|index
operator|=
name|APIC_LVT_PMC
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_LINT0_LVT
case|:
name|index
operator|=
name|APIC_LVT_LINT0
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_LINT1_LVT
case|:
name|index
operator|=
name|APIC_LVT_LINT1
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ERROR_LVT
case|:
name|index
operator|=
name|APIC_LVT_ERROR
expr_stmt|;
break|break;
default|default:
name|index
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|KASSERT
argument_list|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<=
name|VLAPIC_MAXLVT_INDEX
argument_list|,
operator|(
literal|"lvt_off_to_idx: "
literal|"invalid lvt index %d for offset %#x"
operator|,
name|index
operator|,
name|offset
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|index
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|vlapic_get_lvt
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|idx
operator|=
name|lvt_off_to_idx
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|val
operator|=
name|atomic_load_acq_32
argument_list|(
operator|&
name|vlapic
operator|->
name|lvt_last
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vlapic_lvt_write_handler
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
name|uint32_t
modifier|*
name|lvtptr
decl_stmt|,
name|mask
decl_stmt|,
name|val
decl_stmt|;
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|lapic
operator|=
name|vlapic
operator|->
name|apic_page
expr_stmt|;
name|lvtptr
operator|=
name|vlapic_get_lvtptr
argument_list|(
name|vlapic
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|val
operator|=
operator|*
name|lvtptr
expr_stmt|;
name|idx
operator|=
name|lvt_off_to_idx
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lapic
operator|->
name|svr
operator|&
name|APIC_SVR_ENABLE
operator|)
condition|)
name|val
operator||=
name|APIC_LVT_M
expr_stmt|;
name|mask
operator|=
name|APIC_LVT_M
operator||
name|APIC_LVT_DS
operator||
name|APIC_LVT_VECTOR
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|APIC_OFFSET_TIMER_LVT
case|:
name|mask
operator||=
name|APIC_LVTT_TM
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ERROR_LVT
case|:
break|break;
case|case
name|APIC_OFFSET_LINT0_LVT
case|:
case|case
name|APIC_OFFSET_LINT1_LVT
case|:
name|mask
operator||=
name|APIC_LVT_TM
operator||
name|APIC_LVT_RIRR
operator||
name|APIC_LVT_IIPP
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|mask
operator||=
name|APIC_LVT_DM
expr_stmt|;
break|break;
block|}
name|val
operator|&=
name|mask
expr_stmt|;
operator|*
name|lvtptr
operator|=
name|val
expr_stmt|;
name|atomic_store_rel_32
argument_list|(
operator|&
name|vlapic
operator|->
name|lvt_last
index|[
name|idx
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_mask_lvts
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
name|vlapic
operator|->
name|apic_page
decl_stmt|;
name|lapic
operator|->
name|lvt_cmci
operator||=
name|APIC_LVT_M
expr_stmt|;
name|vlapic_lvt_write_handler
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_CMCI_LVT
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|lvt_timer
operator||=
name|APIC_LVT_M
expr_stmt|;
name|vlapic_lvt_write_handler
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_TIMER_LVT
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|lvt_thermal
operator||=
name|APIC_LVT_M
expr_stmt|;
name|vlapic_lvt_write_handler
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_THERM_LVT
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|lvt_pcint
operator||=
name|APIC_LVT_M
expr_stmt|;
name|vlapic_lvt_write_handler
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_PERF_LVT
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|lvt_lint0
operator||=
name|APIC_LVT_M
expr_stmt|;
name|vlapic_lvt_write_handler
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_LINT0_LVT
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|lvt_lint1
operator||=
name|APIC_LVT_M
expr_stmt|;
name|vlapic_lvt_write_handler
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_LINT1_LVT
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|lvt_error
operator||=
name|APIC_LVT_M
expr_stmt|;
name|vlapic_lvt_write_handler
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_ERROR_LVT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vlapic_fire_lvt
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|lvt
parameter_list|)
block|{
name|uint32_t
name|vec
decl_stmt|,
name|mode
decl_stmt|;
if|if
condition|(
name|lvt
operator|&
name|APIC_LVT_M
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vec
operator|=
name|lvt
operator|&
name|APIC_LVT_VECTOR
expr_stmt|;
name|mode
operator|=
name|lvt
operator|&
name|APIC_LVT_DM
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|APIC_LVT_DM_FIXED
case|:
if|if
condition|(
name|vec
operator|<
literal|16
condition|)
block|{
name|vlapic_set_error
argument_list|(
name|vlapic
argument_list|,
name|APIC_ESR_SEND_ILLEGAL_VECTOR
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|vlapic_set_intr_ready
argument_list|(
name|vlapic
argument_list|,
name|vec
argument_list|,
name|false
argument_list|)
condition|)
name|vcpu_notify_event
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_DM_NMI
case|:
name|vm_inject_nmi
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_DM_EXTINT
case|:
name|vm_inject_extint
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// Other modes ignored
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|1
end_if

begin_function
specifier|static
name|void
name|dump_isrvec_stk
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|isrptr
decl_stmt|;
name|isrptr
operator|=
operator|&
name|vlapic
operator|->
name|apic_page
operator|->
name|isr0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"ISR%d 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|isrptr
index|[
name|i
operator|*
literal|4
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|vlapic
operator|->
name|isrvec_stk_top
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"isrvec_stk[%d] = %d\n"
argument_list|,
name|i
argument_list|,
name|vlapic
operator|->
name|isrvec_stk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Algorithm adopted from section "Interrupt, Task and Processor Priority"  * in Intel Architecture Manual Vol 3a.  */
end_comment

begin_function
specifier|static
name|void
name|vlapic_update_ppr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|int
name|isrvec
decl_stmt|,
name|tpr
decl_stmt|,
name|ppr
decl_stmt|;
comment|/* 	 * Note that the value on the stack at index 0 is always 0. 	 * 	 * This is a placeholder for the value of ISRV when none of the 	 * bits is set in the ISRx registers. 	 */
name|isrvec
operator|=
name|vlapic
operator|->
name|isrvec_stk
index|[
name|vlapic
operator|->
name|isrvec_stk_top
index|]
expr_stmt|;
name|tpr
operator|=
name|vlapic
operator|->
name|apic_page
operator|->
name|tpr
expr_stmt|;
if|#
directive|if
literal|1
block|{
name|int
name|i
decl_stmt|,
name|lastprio
decl_stmt|,
name|curprio
decl_stmt|,
name|vector
decl_stmt|,
name|idx
decl_stmt|;
name|uint32_t
modifier|*
name|isrptr
decl_stmt|;
if|if
condition|(
name|vlapic
operator|->
name|isrvec_stk_top
operator|==
literal|0
operator|&&
name|isrvec
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"isrvec_stk is corrupted: %d"
argument_list|,
name|isrvec
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure that the priority of the nested interrupts is 		 * always increasing. 		 */
name|lastprio
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|vlapic
operator|->
name|isrvec_stk_top
condition|;
name|i
operator|++
control|)
block|{
name|curprio
operator|=
name|PRIO
argument_list|(
name|vlapic
operator|->
name|isrvec_stk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|curprio
operator|<=
name|lastprio
condition|)
block|{
name|dump_isrvec_stk
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"isrvec_stk does not satisfy invariant"
argument_list|)
expr_stmt|;
block|}
name|lastprio
operator|=
name|curprio
expr_stmt|;
block|}
comment|/* 		 * Make sure that each bit set in the ISRx registers has a 		 * corresponding entry on the isrvec stack. 		 */
name|i
operator|=
literal|1
expr_stmt|;
name|isrptr
operator|=
operator|&
name|vlapic
operator|->
name|apic_page
operator|->
name|isr0
expr_stmt|;
for|for
control|(
name|vector
operator|=
literal|0
init|;
name|vector
operator|<
literal|256
condition|;
name|vector
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|vector
operator|/
literal|32
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|isrptr
index|[
name|idx
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|vlapic
operator|->
name|isrvec_stk_top
operator|||
name|vlapic
operator|->
name|isrvec_stk
index|[
name|i
index|]
operator|!=
name|vector
condition|)
block|{
name|dump_isrvec_stk
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ISR and isrvec_stk out of sync"
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|PRIO
argument_list|(
name|tpr
argument_list|)
operator|>=
name|PRIO
argument_list|(
name|isrvec
argument_list|)
condition|)
name|ppr
operator|=
name|tpr
expr_stmt|;
else|else
name|ppr
operator|=
name|isrvec
operator|&
literal|0xf0
expr_stmt|;
name|vlapic
operator|->
name|apic_page
operator|->
name|ppr
operator|=
name|ppr
expr_stmt|;
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic_update_ppr 0x%02x"
argument_list|,
name|ppr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_process_eoi
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
name|vlapic
operator|->
name|apic_page
decl_stmt|;
name|uint32_t
modifier|*
name|isrptr
decl_stmt|,
modifier|*
name|tmrptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|,
name|bitpos
decl_stmt|,
name|vector
decl_stmt|;
name|isrptr
operator|=
operator|&
name|lapic
operator|->
name|isr0
expr_stmt|;
name|tmrptr
operator|=
operator|&
name|lapic
operator|->
name|tmr0
expr_stmt|;
comment|/* 	 * The x86 architecture reserves the the first 32 vectors for use 	 * by the processor. 	 */
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|idx
operator|=
name|i
operator|*
literal|4
expr_stmt|;
name|bitpos
operator|=
name|fls
argument_list|(
name|isrptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|--
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|vlapic
operator|->
name|isrvec_stk_top
operator|<=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"invalid vlapic isrvec_stk_top %d"
argument_list|,
name|vlapic
operator|->
name|isrvec_stk_top
argument_list|)
expr_stmt|;
block|}
name|isrptr
index|[
name|idx
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bitpos
operator|)
expr_stmt|;
name|VLAPIC_CTR_ISR
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic_process_eoi"
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|isrvec_stk_top
operator|--
expr_stmt|;
name|vlapic_update_ppr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmrptr
index|[
name|idx
index|]
operator|&
operator|(
literal|1
operator|<<
name|bitpos
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vector
operator|=
name|i
operator|*
literal|32
operator|+
name|bitpos
expr_stmt|;
name|vioapic_process_eoi
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|vlapic_get_lvt_field
parameter_list|(
name|uint32_t
name|lvt
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
return|return
operator|(
name|lvt
operator|&
name|mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|vlapic_periodic_timer
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|uint32_t
name|lvt
decl_stmt|;
name|lvt
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_TIMER_LVT
argument_list|)
expr_stmt|;
return|return
operator|(
name|vlapic_get_lvt_field
argument_list|(
name|lvt
argument_list|,
name|APIC_LVTT_TM_PERIODIC
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|VMM_STAT
argument_list|(
name|VLAPIC_INTR_ERROR
argument_list|,
literal|"error interrupts generated by vlapic"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|vlapic_set_error
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|uint32_t
name|lvt
decl_stmt|;
name|vlapic
operator|->
name|esr_pending
operator||=
name|mask
expr_stmt|;
if|if
condition|(
name|vlapic
operator|->
name|esr_firing
condition|)
return|return;
name|vlapic
operator|->
name|esr_firing
operator|=
literal|1
expr_stmt|;
comment|// The error LVT always uses the fixed delivery mode.
name|lvt
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_ERROR_LVT
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlapic_fire_lvt
argument_list|(
name|vlapic
argument_list|,
name|lvt
operator||
name|APIC_LVT_DM_FIXED
argument_list|)
condition|)
block|{
name|vmm_stat_incr
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
name|VLAPIC_INTR_ERROR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|vlapic
operator|->
name|esr_firing
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|VMM_STAT
argument_list|(
name|VLAPIC_INTR_TIMER
argument_list|,
literal|"timer interrupts generated by vlapic"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|vlapic_fire_timer
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|uint32_t
name|lvt
decl_stmt|;
name|KASSERT
argument_list|(
name|VLAPIC_TIMER_LOCKED
argument_list|(
name|vlapic
argument_list|)
argument_list|,
operator|(
literal|"vlapic_fire_timer not locked"
operator|)
argument_list|)
expr_stmt|;
comment|// The timer LVT always uses the fixed delivery mode.
name|lvt
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_TIMER_LVT
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlapic_fire_lvt
argument_list|(
name|vlapic
argument_list|,
name|lvt
operator||
name|APIC_LVT_DM_FIXED
argument_list|)
condition|)
block|{
name|vmm_stat_incr
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
name|VLAPIC_INTR_TIMER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|VMM_STAT
argument_list|(
name|VLAPIC_INTR_CMC
argument_list|,
literal|"corrected machine check interrupts generated by vlapic"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|vlapic_fire_cmci
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|uint32_t
name|lvt
decl_stmt|;
name|lvt
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_CMCI_LVT
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlapic_fire_lvt
argument_list|(
name|vlapic
argument_list|,
name|lvt
argument_list|)
condition|)
block|{
name|vmm_stat_incr
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
name|VLAPIC_INTR_CMC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|VMM_STAT_ARRAY
argument_list|(
name|LVTS_TRIGGERRED
argument_list|,
name|VLAPIC_MAXLVT_INDEX
operator|+
literal|1
argument_list|,
literal|"lvts triggered"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|vlapic_trigger_lvt
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|int
name|vector
parameter_list|)
block|{
name|uint32_t
name|lvt
decl_stmt|;
if|if
condition|(
name|vlapic_enabled
argument_list|(
name|vlapic
argument_list|)
operator|==
name|false
condition|)
block|{
comment|/* 		 * When the local APIC is global/hardware disabled, 		 * LINT[1:0] pins are configured as INTR and NMI pins, 		 * respectively. 		*/
switch|switch
condition|(
name|vector
condition|)
block|{
case|case
name|APIC_LVT_LINT0
case|:
name|vm_inject_extint
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_LINT1
case|:
name|vm_inject_nmi
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|vector
condition|)
block|{
case|case
name|APIC_LVT_LINT0
case|:
name|lvt
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_LINT0_LVT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_LINT1
case|:
name|lvt
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_LINT1_LVT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_TIMER
case|:
name|lvt
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_TIMER_LVT
argument_list|)
expr_stmt|;
name|lvt
operator||=
name|APIC_LVT_DM_FIXED
expr_stmt|;
break|break;
case|case
name|APIC_LVT_ERROR
case|:
name|lvt
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_ERROR_LVT
argument_list|)
expr_stmt|;
name|lvt
operator||=
name|APIC_LVT_DM_FIXED
expr_stmt|;
break|break;
case|case
name|APIC_LVT_PMC
case|:
name|lvt
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_PERF_LVT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_THERMAL
case|:
name|lvt
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_THERM_LVT
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_CMCI
case|:
name|lvt
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_CMCI_LVT
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|vlapic_fire_lvt
argument_list|(
name|vlapic
argument_list|,
name|lvt
argument_list|)
condition|)
block|{
name|vmm_stat_array_incr
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
name|LVTS_TRIGGERRED
argument_list|,
name|vector
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_callout_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|struct
name|bintime
name|bt
decl_stmt|,
name|btnow
decl_stmt|;
name|sbintime_t
name|rem_sbt
decl_stmt|;
name|vlapic
operator|=
name|arg
expr_stmt|;
name|VLAPIC_TIMER_LOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|)
condition|)
comment|/* callout was reset */
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|callout_active
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|)
condition|)
comment|/* callout was stopped */
goto|goto
name|done
goto|;
name|callout_deactivate
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|)
expr_stmt|;
name|vlapic_fire_timer
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlapic_periodic_timer
argument_list|(
name|vlapic
argument_list|)
condition|)
block|{
name|binuptime
argument_list|(
operator|&
name|btnow
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bintime_cmp
argument_list|(
operator|&
name|btnow
argument_list|,
operator|&
name|vlapic
operator|->
name|timer_fire_bt
argument_list|,
operator|>=
argument_list|)
argument_list|,
operator|(
literal|"vlapic callout at %#lx.%#lx, expected at %#lx.#%lx"
operator|,
name|btnow
operator|.
name|sec
operator|,
name|btnow
operator|.
name|frac
operator|,
name|vlapic
operator|->
name|timer_fire_bt
operator|.
name|sec
operator|,
name|vlapic
operator|->
name|timer_fire_bt
operator|.
name|frac
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Compute the delta between when the timer was supposed to 		 * fire and the present time. 		 */
name|bt
operator|=
name|btnow
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|vlapic
operator|->
name|timer_fire_bt
argument_list|)
expr_stmt|;
name|rem_sbt
operator|=
name|bttosbt
argument_list|(
name|vlapic
operator|->
name|timer_period_bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bintime_cmp
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|vlapic
operator|->
name|timer_period_bt
argument_list|,
operator|<
argument_list|)
condition|)
block|{
comment|/* 			 * Adjust the time until the next countdown downward 			 * to account for the lost time. 			 */
name|rem_sbt
operator|-=
name|bttosbt
argument_list|(
name|bt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If the delta is greater than the timer period then 			 * just reset our time base instead of trying to catch 			 * up. 			 */
name|vlapic
operator|->
name|timer_fire_bt
operator|=
name|btnow
expr_stmt|;
name|VLAPIC_CTR2
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic timer lagging by %lu "
literal|"usecs, period is %lu usecs - resetting time base"
argument_list|,
name|bttosbt
argument_list|(
name|bt
argument_list|)
operator|/
name|SBT_1US
argument_list|,
name|bttosbt
argument_list|(
name|vlapic
operator|->
name|timer_period_bt
argument_list|)
operator|/
name|SBT_1US
argument_list|)
expr_stmt|;
block|}
name|bintime_add
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_fire_bt
argument_list|,
operator|&
name|vlapic
operator|->
name|timer_period_bt
argument_list|)
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|,
name|rem_sbt
argument_list|,
literal|0
argument_list|,
name|vlapic_callout_handler
argument_list|,
name|vlapic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|VLAPIC_TIMER_UNLOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vlapic_icrtmr_write_handler
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|sbintime_t
name|sbt
decl_stmt|;
name|uint32_t
name|icr_timer
decl_stmt|;
name|VLAPIC_TIMER_LOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|lapic
operator|=
name|vlapic
operator|->
name|apic_page
expr_stmt|;
name|icr_timer
operator|=
name|lapic
operator|->
name|icr_timer
expr_stmt|;
name|vlapic
operator|->
name|timer_period_bt
operator|=
name|vlapic
operator|->
name|timer_freq_bt
expr_stmt|;
name|bintime_mul
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_period_bt
argument_list|,
name|icr_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|icr_timer
operator|!=
literal|0
condition|)
block|{
name|binuptime
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_fire_bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_fire_bt
argument_list|,
operator|&
name|vlapic
operator|->
name|timer_period_bt
argument_list|)
expr_stmt|;
name|sbt
operator|=
name|bttosbt
argument_list|(
name|vlapic
operator|->
name|timer_period_bt
argument_list|)
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|,
name|sbt
argument_list|,
literal|0
argument_list|,
name|vlapic_callout_handler
argument_list|,
name|vlapic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|callout_stop
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|)
expr_stmt|;
name|VLAPIC_TIMER_UNLOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function populates 'dmask' with the set of vcpus that match the  * addressing specified by the (dest, phys, lowprio) tuple.  *   * 'x2apic_dest' specifies whether 'dest' is interpreted as x2APIC (32-bit)  * or xAPIC (8-bit) destination field.  */
end_comment

begin_function
specifier|static
name|void
name|vlapic_calcdest
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|cpuset_t
modifier|*
name|dmask
parameter_list|,
name|uint32_t
name|dest
parameter_list|,
name|bool
name|phys
parameter_list|,
name|bool
name|lowprio
parameter_list|,
name|bool
name|x2apic_dest
parameter_list|)
block|{
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|uint32_t
name|dfr
decl_stmt|,
name|ldr
decl_stmt|,
name|ldest
decl_stmt|,
name|cluster
decl_stmt|;
name|uint32_t
name|mda_flat_ldest
decl_stmt|,
name|mda_cluster_ldest
decl_stmt|,
name|mda_ldest
decl_stmt|,
name|mda_cluster_id
decl_stmt|;
name|cpuset_t
name|amask
decl_stmt|;
name|int
name|vcpuid
decl_stmt|;
if|if
condition|(
operator|(
name|x2apic_dest
operator|&&
name|dest
operator|==
literal|0xffffffff
operator|)
operator|||
operator|(
operator|!
name|x2apic_dest
operator|&&
name|dest
operator|==
literal|0xff
operator|)
condition|)
block|{
comment|/* 		 * Broadcast in both logical and physical modes. 		 */
operator|*
name|dmask
operator|=
name|vm_active_cpus
argument_list|(
name|vm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|phys
condition|)
block|{
comment|/* 		 * Physical mode: destination is APIC ID. 		 */
name|CPU_ZERO
argument_list|(
name|dmask
argument_list|)
expr_stmt|;
name|vcpuid
operator|=
name|vm_apicid2vcpuid
argument_list|(
name|vm
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcpuid
operator|<
name|VM_MAXCPU
condition|)
name|CPU_SET
argument_list|(
name|vcpuid
argument_list|,
name|dmask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * In the "Flat Model" the MDA is interpreted as an 8-bit wide 		 * bitmask. This model is only avilable in the xAPIC mode. 		 */
name|mda_flat_ldest
operator|=
name|dest
operator|&
literal|0xff
expr_stmt|;
comment|/* 		 * In the "Cluster Model" the MDA is used to identify a 		 * specific cluster and a set of APICs in that cluster. 		 */
if|if
condition|(
name|x2apic_dest
condition|)
block|{
name|mda_cluster_id
operator|=
name|dest
operator|>>
literal|16
expr_stmt|;
name|mda_cluster_ldest
operator|=
name|dest
operator|&
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
name|mda_cluster_id
operator|=
operator|(
name|dest
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
name|mda_cluster_ldest
operator|=
name|dest
operator|&
literal|0xf
expr_stmt|;
block|}
comment|/* 		 * Logical mode: match each APIC that has a bit set 		 * in it's LDR that matches a bit in the ldest. 		 */
name|CPU_ZERO
argument_list|(
name|dmask
argument_list|)
expr_stmt|;
name|amask
operator|=
name|vm_active_cpus
argument_list|(
name|vm
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|vcpuid
operator|=
name|CPU_FFS
argument_list|(
operator|&
name|amask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vcpuid
operator|--
expr_stmt|;
name|CPU_CLR
argument_list|(
name|vcpuid
argument_list|,
operator|&
name|amask
argument_list|)
expr_stmt|;
name|vlapic
operator|=
name|vm_lapic
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
name|dfr
operator|=
name|vlapic
operator|->
name|apic_page
operator|->
name|dfr
expr_stmt|;
name|ldr
operator|=
name|vlapic
operator|->
name|apic_page
operator|->
name|ldr
expr_stmt|;
if|if
condition|(
operator|(
name|dfr
operator|&
name|APIC_DFR_MODEL_MASK
operator|)
operator|==
name|APIC_DFR_MODEL_FLAT
condition|)
block|{
name|ldest
operator|=
name|ldr
operator|>>
literal|24
expr_stmt|;
name|mda_ldest
operator|=
name|mda_flat_ldest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dfr
operator|&
name|APIC_DFR_MODEL_MASK
operator|)
operator|==
name|APIC_DFR_MODEL_CLUSTER
condition|)
block|{
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
block|{
name|cluster
operator|=
name|ldr
operator|>>
literal|16
expr_stmt|;
name|ldest
operator|=
name|ldr
operator|&
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
name|cluster
operator|=
name|ldr
operator|>>
literal|28
expr_stmt|;
name|ldest
operator|=
operator|(
name|ldr
operator|>>
literal|24
operator|)
operator|&
literal|0xf
expr_stmt|;
block|}
if|if
condition|(
name|cluster
operator|!=
name|mda_cluster_id
condition|)
continue|continue;
name|mda_ldest
operator|=
name|mda_cluster_ldest
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Guest has configured a bad logical 				 * model for this vcpu - skip it. 				 */
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic has bad logical "
literal|"model %x - cannot deliver interrupt"
argument_list|,
name|dfr
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|mda_ldest
operator|&
name|ldest
operator|)
operator|!=
literal|0
condition|)
block|{
name|CPU_SET
argument_list|(
name|vcpuid
argument_list|,
name|dmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowprio
condition|)
break|break;
block|}
block|}
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|VMM_STAT_ARRAY
argument_list|(
name|IPIS_SENT
argument_list|,
name|VM_MAXCPU
argument_list|,
literal|"ipis sent to vcpu"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|vlapic_icrlo_write_handler
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|bool
modifier|*
name|retu
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bool
name|phys
decl_stmt|;
name|cpuset_t
name|dmask
decl_stmt|;
name|uint64_t
name|icrval
decl_stmt|;
name|uint32_t
name|dest
decl_stmt|,
name|vec
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|vlapic
modifier|*
name|vlapic2
decl_stmt|;
name|struct
name|vm_exit
modifier|*
name|vmexit
decl_stmt|;
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|lapic
operator|=
name|vlapic
operator|->
name|apic_page
expr_stmt|;
name|lapic
operator|->
name|icr_lo
operator|&=
operator|~
name|APIC_DELSTAT_PEND
expr_stmt|;
name|icrval
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|lapic
operator|->
name|icr_hi
operator|<<
literal|32
operator|)
operator||
name|lapic
operator|->
name|icr_lo
expr_stmt|;
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
name|dest
operator|=
name|icrval
operator|>>
literal|32
expr_stmt|;
else|else
name|dest
operator|=
name|icrval
operator|>>
operator|(
literal|32
operator|+
literal|24
operator|)
expr_stmt|;
name|vec
operator|=
name|icrval
operator|&
name|APIC_VECTOR_MASK
expr_stmt|;
name|mode
operator|=
name|icrval
operator|&
name|APIC_DELMODE_MASK
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|APIC_DELMODE_FIXED
operator|&&
name|vec
operator|<
literal|16
condition|)
block|{
name|vlapic_set_error
argument_list|(
name|vlapic
argument_list|,
name|APIC_ESR_SEND_ILLEGAL_VECTOR
argument_list|)
expr_stmt|;
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"Ignoring invalid IPI %d"
argument_list|,
name|vec
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|VLAPIC_CTR2
argument_list|(
name|vlapic
argument_list|,
literal|"icrlo 0x%016lx triggered ipi %d"
argument_list|,
name|icrval
argument_list|,
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|APIC_DELMODE_FIXED
operator|||
name|mode
operator|==
name|APIC_DELMODE_NMI
condition|)
block|{
switch|switch
condition|(
name|icrval
operator|&
name|APIC_DEST_MASK
condition|)
block|{
case|case
name|APIC_DEST_DESTFLD
case|:
name|phys
operator|=
operator|(
operator|(
name|icrval
operator|&
name|APIC_DESTMODE_LOG
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
name|vlapic_calcdest
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
operator|&
name|dmask
argument_list|,
name|dest
argument_list|,
name|phys
argument_list|,
name|false
argument_list|,
name|x2apic
argument_list|(
name|vlapic
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_DEST_SELF
case|:
name|CPU_SETOF
argument_list|(
name|vlapic
operator|->
name|vcpuid
argument_list|,
operator|&
name|dmask
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_DEST_ALLISELF
case|:
name|dmask
operator|=
name|vm_active_cpus
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_DEST_ALLESELF
case|:
name|dmask
operator|=
name|vm_active_cpus
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|)
expr_stmt|;
name|CPU_CLR
argument_list|(
name|vlapic
operator|->
name|vcpuid
argument_list|,
operator|&
name|dmask
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CPU_ZERO
argument_list|(
operator|&
name|dmask
argument_list|)
expr_stmt|;
comment|/* satisfy gcc */
break|break;
block|}
while|while
condition|(
operator|(
name|i
operator|=
name|CPU_FFS
argument_list|(
operator|&
name|dmask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|CPU_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|dmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|APIC_DELMODE_FIXED
condition|)
block|{
name|lapic_intr_edge
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|i
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|vmm_stat_array_incr
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
name|IPIS_SENT
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VLAPIC_CTR2
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic sending ipi %d "
literal|"to vcpuid %d"
argument_list|,
name|vec
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vm_inject_nmi
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic sending ipi nmi "
literal|"to vcpuid %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* handled completely in the kernel */
block|}
if|if
condition|(
name|mode
operator|==
name|APIC_DELMODE_INIT
condition|)
block|{
if|if
condition|(
operator|(
name|icrval
operator|&
name|APIC_LEVEL_MASK
operator|)
operator|==
name|APIC_LEVEL_DEASSERT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|vlapic
operator|->
name|vcpuid
operator|==
literal|0
operator|&&
name|dest
operator|!=
literal|0
operator|&&
name|dest
operator|<
name|VM_MAXCPU
condition|)
block|{
name|vlapic2
operator|=
name|vm_lapic
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/* move from INIT to waiting-for-SIPI state */
if|if
condition|(
name|vlapic2
operator|->
name|boot_state
operator|==
name|BS_INIT
condition|)
block|{
name|vlapic2
operator|->
name|boot_state
operator|=
name|BS_SIPI
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|APIC_DELMODE_STARTUP
condition|)
block|{
if|if
condition|(
name|vlapic
operator|->
name|vcpuid
operator|==
literal|0
operator|&&
name|dest
operator|!=
literal|0
operator|&&
name|dest
operator|<
name|VM_MAXCPU
condition|)
block|{
name|vlapic2
operator|=
name|vm_lapic
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/* 			 * Ignore SIPIs in any state other than wait-for-SIPI 			 */
if|if
condition|(
name|vlapic2
operator|->
name|boot_state
operator|!=
name|BS_SIPI
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 			 * XXX this assumes that the startup IPI always succeeds 			 */
name|vlapic2
operator|->
name|boot_state
operator|=
name|BS_RUNNING
expr_stmt|;
name|vm_activate_cpu
argument_list|(
name|vlapic2
operator|->
name|vm
argument_list|,
name|dest
argument_list|)
expr_stmt|;
operator|*
name|retu
operator|=
name|true
expr_stmt|;
name|vmexit
operator|=
name|vm_exitinfo
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_SPINUP_AP
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|spinup_ap
operator|.
name|vcpu
operator|=
name|dest
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|spinup_ap
operator|.
name|rip
operator|=
name|vec
operator|<<
name|PAGE_SHIFT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * This will cause a return to userland. 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vlapic_self_ipi_handler
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|int
name|vec
decl_stmt|;
name|KASSERT
argument_list|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
argument_list|,
operator|(
literal|"SELF_IPI does not exist in xAPIC mode"
operator|)
argument_list|)
expr_stmt|;
name|vec
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|lapic_intr_edge
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|vmm_stat_array_incr
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
name|IPIS_SENT
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic self-ipi %d"
argument_list|,
name|vec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vlapic_pending_intr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|int
modifier|*
name|vecptr
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
name|vlapic
operator|->
name|apic_page
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|i
decl_stmt|,
name|bitpos
decl_stmt|,
name|vector
decl_stmt|;
name|uint32_t
modifier|*
name|irrptr
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
name|vlapic
operator|->
name|ops
operator|.
name|pending_intr
condition|)
return|return
operator|(
call|(
modifier|*
name|vlapic
operator|->
name|ops
operator|.
name|pending_intr
call|)
argument_list|(
name|vlapic
argument_list|,
name|vecptr
argument_list|)
operator|)
return|;
name|irrptr
operator|=
operator|&
name|lapic
operator|->
name|irr0
expr_stmt|;
comment|/* 	 * The x86 architecture reserves the the first 32 vectors for use 	 * by the processor. 	 */
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|idx
operator|=
name|i
operator|*
literal|4
expr_stmt|;
name|val
operator|=
name|atomic_load_acq_int
argument_list|(
operator|&
name|irrptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|bitpos
operator|=
name|fls
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|!=
literal|0
condition|)
block|{
name|vector
operator|=
name|i
operator|*
literal|32
operator|+
operator|(
name|bitpos
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|PRIO
argument_list|(
name|vector
argument_list|)
operator|>
name|PRIO
argument_list|(
name|lapic
operator|->
name|ppr
argument_list|)
condition|)
block|{
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"pending intr %d"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
if|if
condition|(
name|vecptr
operator|!=
name|NULL
condition|)
operator|*
name|vecptr
operator|=
name|vector
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vlapic_intr_accepted
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|int
name|vector
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
name|vlapic
operator|->
name|apic_page
decl_stmt|;
name|uint32_t
modifier|*
name|irrptr
decl_stmt|,
modifier|*
name|isrptr
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|stk_top
decl_stmt|;
if|if
condition|(
name|vlapic
operator|->
name|ops
operator|.
name|intr_accepted
condition|)
return|return
operator|(
call|(
modifier|*
name|vlapic
operator|->
name|ops
operator|.
name|intr_accepted
call|)
argument_list|(
name|vlapic
argument_list|,
name|vector
argument_list|)
operator|)
return|;
comment|/* 	 * clear the ready bit for vector being accepted in irr  	 * and set the vector as in service in isr. 	 */
name|idx
operator|=
operator|(
name|vector
operator|/
literal|32
operator|)
operator|*
literal|4
expr_stmt|;
name|irrptr
operator|=
operator|&
name|lapic
operator|->
name|irr0
expr_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|irrptr
index|[
name|idx
index|]
argument_list|,
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
argument_list|)
expr_stmt|;
name|VLAPIC_CTR_IRR
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic_intr_accepted"
argument_list|)
expr_stmt|;
name|isrptr
operator|=
operator|&
name|lapic
operator|->
name|isr0
expr_stmt|;
name|isrptr
index|[
name|idx
index|]
operator||=
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
expr_stmt|;
name|VLAPIC_CTR_ISR
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic_intr_accepted"
argument_list|)
expr_stmt|;
comment|/* 	 * Update the PPR 	 */
name|vlapic
operator|->
name|isrvec_stk_top
operator|++
expr_stmt|;
name|stk_top
operator|=
name|vlapic
operator|->
name|isrvec_stk_top
expr_stmt|;
if|if
condition|(
name|stk_top
operator|>=
name|ISRVEC_STK_SIZE
condition|)
name|panic
argument_list|(
literal|"isrvec_stk_top overflow %d"
argument_list|,
name|stk_top
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|isrvec_stk
index|[
name|stk_top
index|]
operator|=
name|vector
expr_stmt|;
name|vlapic_update_ppr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vlapic_svr_write_handler
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|uint32_t
name|old
decl_stmt|,
name|new
decl_stmt|,
name|changed
decl_stmt|;
name|lapic
operator|=
name|vlapic
operator|->
name|apic_page
expr_stmt|;
name|new
operator|=
name|lapic
operator|->
name|svr
expr_stmt|;
name|old
operator|=
name|vlapic
operator|->
name|svr_last
expr_stmt|;
name|vlapic
operator|->
name|svr_last
operator|=
name|new
expr_stmt|;
name|changed
operator|=
name|old
operator|^
name|new
expr_stmt|;
if|if
condition|(
operator|(
name|changed
operator|&
name|APIC_SVR_ENABLE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|new
operator|&
name|APIC_SVR_ENABLE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The apic is now disabled so stop the apic timer 			 * and mask all the LVT entries. 			 */
name|VLAPIC_CTR0
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic is software-disabled"
argument_list|)
expr_stmt|;
name|VLAPIC_TIMER_LOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|)
expr_stmt|;
name|VLAPIC_TIMER_UNLOCK
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|vlapic_mask_lvts
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The apic is now enabled so restart the apic timer 			 * if it is configured in periodic mode. 			 */
name|VLAPIC_CTR0
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic is software-enabled"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlapic_periodic_timer
argument_list|(
name|vlapic
argument_list|)
condition|)
name|vlapic_icrtmr_write_handler
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|vlapic_read
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|int
name|mmio_access
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
modifier|*
name|data
parameter_list|,
name|bool
modifier|*
name|retu
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
name|vlapic
operator|->
name|apic_page
decl_stmt|;
name|uint32_t
modifier|*
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Ignore MMIO accesses in x2APIC mode */
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
operator|&&
name|mmio_access
condition|)
block|{
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"MMIO read from offset %#lx in x2APIC mode"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|x2apic
argument_list|(
name|vlapic
argument_list|)
operator|&&
operator|!
name|mmio_access
condition|)
block|{
comment|/* 		 * XXX Generate GP fault for MSR accesses in xAPIC mode 		 */
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"x2APIC MSR read from offset %#lx in "
literal|"xAPIC mode"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|lapic
argument_list|)
condition|)
block|{
operator|*
name|data
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|offset
operator|&=
operator|~
literal|3
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|APIC_OFFSET_ID
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|id
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_VER
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|version
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_TPR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|tpr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_APR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|apr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_PPR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|ppr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_EOI
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|eoi
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_LDR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|ldr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_DFR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|dfr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_SVR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|svr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ISR0
operator|...
name|APIC_OFFSET_ISR7
case|:
name|i
operator|=
operator|(
name|offset
operator|-
name|APIC_OFFSET_ISR0
operator|)
operator|>>
literal|2
expr_stmt|;
name|reg
operator|=
operator|&
name|lapic
operator|->
name|isr0
expr_stmt|;
operator|*
name|data
operator|=
operator|*
operator|(
name|reg
operator|+
name|i
operator|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_TMR0
operator|...
name|APIC_OFFSET_TMR7
case|:
name|i
operator|=
operator|(
name|offset
operator|-
name|APIC_OFFSET_TMR0
operator|)
operator|>>
literal|2
expr_stmt|;
name|reg
operator|=
operator|&
name|lapic
operator|->
name|tmr0
expr_stmt|;
operator|*
name|data
operator|=
operator|*
operator|(
name|reg
operator|+
name|i
operator|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_IRR0
operator|...
name|APIC_OFFSET_IRR7
case|:
name|i
operator|=
operator|(
name|offset
operator|-
name|APIC_OFFSET_IRR0
operator|)
operator|>>
literal|2
expr_stmt|;
name|reg
operator|=
operator|&
name|lapic
operator|->
name|irr0
expr_stmt|;
operator|*
name|data
operator|=
name|atomic_load_acq_int
argument_list|(
name|reg
operator|+
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ESR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|esr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ICR_LOW
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|icr_lo
expr_stmt|;
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
operator|*
name|data
operator||=
operator|(
name|uint64_t
operator|)
name|lapic
operator|->
name|icr_hi
operator|<<
literal|32
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ICR_HI
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|icr_hi
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_CMCI_LVT
case|:
case|case
name|APIC_OFFSET_TIMER_LVT
operator|...
name|APIC_OFFSET_ERROR_LVT
case|:
operator|*
name|data
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|reg
operator|=
name|vlapic_get_lvtptr
argument_list|(
name|vlapic
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|*
name|data
operator|==
operator|*
name|reg
argument_list|,
operator|(
literal|"inconsistent lvt value at "
literal|"offset %#lx: %#lx/%#x"
operator|,
name|offset
operator|,
operator|*
name|data
operator|,
operator|*
name|reg
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|APIC_OFFSET_TIMER_ICR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|icr_timer
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_TIMER_CCR
case|:
operator|*
name|data
operator|=
name|vlapic_get_ccr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_TIMER_DCR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|dcr_timer
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_SELF_IPI
case|:
comment|/* 			 * XXX generate a GP fault if vlapic is in x2apic mode 			 */
operator|*
name|data
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_RRR
case|:
default|default:
operator|*
name|data
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|done
label|:
name|VLAPIC_CTR2
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic read offset %#x, data %#lx"
argument_list|,
name|offset
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|vlapic_write
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|int
name|mmio_access
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|data
parameter_list|,
name|bool
modifier|*
name|retu
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
name|vlapic
operator|->
name|apic_page
decl_stmt|;
name|uint32_t
modifier|*
name|regptr
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|offset
operator|&
literal|0xf
operator|)
operator|==
literal|0
operator|&&
name|offset
operator|<
name|PAGE_SIZE
argument_list|,
operator|(
literal|"vlapic_write: invalid offset %#lx"
operator|,
name|offset
operator|)
argument_list|)
expr_stmt|;
name|VLAPIC_CTR2
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic write offset %#lx, data %#lx"
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|lapic
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Ignore MMIO accesses in x2APIC mode */
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
operator|&&
name|mmio_access
condition|)
block|{
name|VLAPIC_CTR2
argument_list|(
name|vlapic
argument_list|,
literal|"MMIO write of %#lx to offset %#lx "
literal|"in x2APIC mode"
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * XXX Generate GP fault for MSR accesses in xAPIC mode 	 */
if|if
condition|(
operator|!
name|x2apic
argument_list|(
name|vlapic
argument_list|)
operator|&&
operator|!
name|mmio_access
condition|)
block|{
name|VLAPIC_CTR2
argument_list|(
name|vlapic
argument_list|,
literal|"x2APIC MSR write of %#lx to offset %#lx "
literal|"in xAPIC mode"
argument_list|,
name|data
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|retval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|APIC_OFFSET_ID
case|:
name|lapic
operator|->
name|id
operator|=
name|data
expr_stmt|;
name|vlapic_id_write_handler
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_TPR
case|:
name|lapic
operator|->
name|tpr
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
name|vlapic_update_ppr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_EOI
case|:
name|vlapic_process_eoi
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_LDR
case|:
name|lapic
operator|->
name|ldr
operator|=
name|data
expr_stmt|;
name|vlapic_ldr_write_handler
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_DFR
case|:
name|lapic
operator|->
name|dfr
operator|=
name|data
expr_stmt|;
name|vlapic_dfr_write_handler
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_SVR
case|:
name|lapic
operator|->
name|svr
operator|=
name|data
expr_stmt|;
name|vlapic_svr_write_handler
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ICR_LOW
case|:
name|lapic
operator|->
name|icr_lo
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
name|lapic
operator|->
name|icr_hi
operator|=
name|data
operator|>>
literal|32
expr_stmt|;
name|retval
operator|=
name|vlapic_icrlo_write_handler
argument_list|(
name|vlapic
argument_list|,
name|retu
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ICR_HI
case|:
name|lapic
operator|->
name|icr_hi
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_CMCI_LVT
case|:
case|case
name|APIC_OFFSET_TIMER_LVT
operator|...
name|APIC_OFFSET_ERROR_LVT
case|:
name|regptr
operator|=
name|vlapic_get_lvtptr
argument_list|(
name|vlapic
argument_list|,
name|offset
argument_list|)
expr_stmt|;
operator|*
name|regptr
operator|=
name|data
expr_stmt|;
name|vlapic_lvt_write_handler
argument_list|(
name|vlapic
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_TIMER_ICR
case|:
name|lapic
operator|->
name|icr_timer
operator|=
name|data
expr_stmt|;
name|vlapic_icrtmr_write_handler
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_TIMER_DCR
case|:
name|lapic
operator|->
name|dcr_timer
operator|=
name|data
expr_stmt|;
name|vlapic_dcr_write_handler
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ESR
case|:
name|vlapic_esr_write_handler
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_SELF_IPI
case|:
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
name|vlapic_self_ipi_handler
argument_list|(
name|vlapic
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_VER
case|:
case|case
name|APIC_OFFSET_APR
case|:
case|case
name|APIC_OFFSET_PPR
case|:
case|case
name|APIC_OFFSET_RRR
case|:
case|case
name|APIC_OFFSET_ISR0
operator|...
name|APIC_OFFSET_ISR7
case|:
case|case
name|APIC_OFFSET_TMR0
operator|...
name|APIC_OFFSET_TMR7
case|:
case|case
name|APIC_OFFSET_IRR0
operator|...
name|APIC_OFFSET_IRR7
case|:
case|case
name|APIC_OFFSET_TIMER_CCR
case|:
default|default:
comment|// Read only.
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_reset
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|lapic
operator|=
name|vlapic
operator|->
name|apic_page
expr_stmt|;
name|bzero
argument_list|(
name|lapic
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|LAPIC
argument_list|)
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|id
operator|=
name|vlapic_get_id
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|version
operator|=
name|VLAPIC_VERSION
expr_stmt|;
name|lapic
operator|->
name|version
operator||=
operator|(
name|VLAPIC_MAXLVT_INDEX
operator|<<
name|MAXLVTSHIFT
operator|)
expr_stmt|;
name|lapic
operator|->
name|dfr
operator|=
literal|0xffffffff
expr_stmt|;
name|lapic
operator|->
name|svr
operator|=
name|APIC_SVR_VECTOR
expr_stmt|;
name|vlapic_mask_lvts
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|vlapic_reset_tmr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|dcr_timer
operator|=
literal|0
expr_stmt|;
name|vlapic_dcr_write_handler
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlapic
operator|->
name|vcpuid
operator|==
literal|0
condition|)
name|vlapic
operator|->
name|boot_state
operator|=
name|BS_RUNNING
expr_stmt|;
comment|/* BSP */
else|else
name|vlapic
operator|->
name|boot_state
operator|=
name|BS_INIT
expr_stmt|;
comment|/* AP */
name|vlapic
operator|->
name|svr_last
operator|=
name|lapic
operator|->
name|svr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vlapic_init
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|vlapic
operator|->
name|vm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"vlapic_init: vm is not initialized"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vlapic
operator|->
name|vcpuid
operator|>=
literal|0
operator|&&
name|vlapic
operator|->
name|vcpuid
operator|<
name|VM_MAXCPU
argument_list|,
operator|(
literal|"vlapic_init: vcpuid is not initialized"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vlapic
operator|->
name|apic_page
operator|!=
name|NULL
argument_list|,
operator|(
literal|"vlapic_init: apic_page is not "
literal|"initialized"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the vlapic is configured in x2apic mode then it will be 	 * accessed in the critical section via the MSR emulation code. 	 * 	 * Therefore the timer mutex must be a spinlock because blockable 	 * mutexes cannot be acquired in a critical section. 	 */
name|mtx_init
argument_list|(
operator|&
name|vlapic
operator|->
name|timer_mtx
argument_list|,
literal|"vlapic timer mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|msr_apicbase
operator|=
name|DEFAULT_APIC_BASE
operator||
name|APICBASE_ENABLED
expr_stmt|;
if|if
condition|(
name|vlapic
operator|->
name|vcpuid
operator|==
literal|0
condition|)
name|vlapic
operator|->
name|msr_apicbase
operator||=
name|APICBASE_BSP
expr_stmt|;
name|vlapic_reset
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vlapic_cleanup
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|callout_drain
argument_list|(
operator|&
name|vlapic
operator|->
name|callout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|vlapic_get_apicbase
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
return|return
operator|(
name|vlapic
operator|->
name|msr_apicbase
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vlapic_set_apicbase
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint64_t
name|new
parameter_list|)
block|{
if|if
condition|(
name|vlapic
operator|->
name|msr_apicbase
operator|!=
name|new
condition|)
block|{
name|VLAPIC_CTR2
argument_list|(
name|vlapic
argument_list|,
literal|"Changing APIC_BASE MSR from %#lx to %#lx "
literal|"not supported"
argument_list|,
name|vlapic
operator|->
name|msr_apicbase
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vlapic_set_x2apic_state
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|enum
name|x2apic_state
name|state
parameter_list|)
block|{
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|vlapic
operator|=
name|vm_lapic
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|X2APIC_DISABLED
condition|)
name|vlapic
operator|->
name|msr_apicbase
operator|&=
operator|~
name|APICBASE_X2APIC
expr_stmt|;
else|else
name|vlapic
operator|->
name|msr_apicbase
operator||=
name|APICBASE_X2APIC
expr_stmt|;
comment|/* 	 * Reset the local APIC registers whose values are mode-dependent. 	 * 	 * XXX this works because the APIC mode can be changed only at vcpu 	 * initialization time. 	 */
name|lapic
operator|=
name|vlapic
operator|->
name|apic_page
expr_stmt|;
name|lapic
operator|->
name|id
operator|=
name|vlapic_get_id
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
block|{
name|lapic
operator|->
name|ldr
operator|=
name|x2apic_ldr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|dfr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lapic
operator|->
name|ldr
operator|=
literal|0
expr_stmt|;
name|lapic
operator|->
name|dfr
operator|=
literal|0xffffffff
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|X2APIC_ENABLED
condition|)
block|{
if|if
condition|(
name|vlapic
operator|->
name|ops
operator|.
name|enable_x2apic_mode
condition|)
call|(
modifier|*
name|vlapic
operator|->
name|ops
operator|.
name|enable_x2apic_mode
call|)
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vlapic_deliver_intr
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|bool
name|level
parameter_list|,
name|uint32_t
name|dest
parameter_list|,
name|bool
name|phys
parameter_list|,
name|int
name|delmode
parameter_list|,
name|int
name|vec
parameter_list|)
block|{
name|bool
name|lowprio
decl_stmt|;
name|int
name|vcpuid
decl_stmt|;
name|cpuset_t
name|dmask
decl_stmt|;
if|if
condition|(
name|delmode
operator|!=
name|IOART_DELFIXED
operator|&&
name|delmode
operator|!=
name|IOART_DELLOPRI
operator|&&
name|delmode
operator|!=
name|IOART_DELEXINT
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vm
argument_list|,
literal|"vlapic intr invalid delmode %#x"
argument_list|,
name|delmode
argument_list|)
expr_stmt|;
return|return;
block|}
name|lowprio
operator|=
operator|(
name|delmode
operator|==
name|IOART_DELLOPRI
operator|)
expr_stmt|;
comment|/* 	 * We don't provide any virtual interrupt redirection hardware so 	 * all interrupts originating from the ioapic or MSI specify the 	 * 'dest' in the legacy xAPIC format. 	 */
name|vlapic_calcdest
argument_list|(
name|vm
argument_list|,
operator|&
name|dmask
argument_list|,
name|dest
argument_list|,
name|phys
argument_list|,
name|lowprio
argument_list|,
name|false
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|vcpuid
operator|=
name|CPU_FFS
argument_list|(
operator|&
name|dmask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vcpuid
operator|--
expr_stmt|;
name|CPU_CLR
argument_list|(
name|vcpuid
argument_list|,
operator|&
name|dmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|delmode
operator|==
name|IOART_DELEXINT
condition|)
block|{
name|vm_inject_extint
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lapic_set_intr
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|vec
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|vlapic_post_intr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|int
name|hostcpu
parameter_list|,
name|int
name|ipinum
parameter_list|)
block|{
comment|/* 	 * Post an interrupt to the vcpu currently running on 'hostcpu'. 	 * 	 * This is done by leveraging features like Posted Interrupts (Intel) 	 * Doorbell MSR (AMD AVIC) that avoid a VM exit. 	 * 	 * If neither of these features are available then fallback to 	 * sending an IPI to 'hostcpu'. 	 */
if|if
condition|(
name|vlapic
operator|->
name|ops
operator|.
name|post_intr
condition|)
call|(
modifier|*
name|vlapic
operator|->
name|ops
operator|.
name|post_intr
call|)
argument_list|(
name|vlapic
argument_list|,
name|hostcpu
argument_list|)
expr_stmt|;
else|else
name|ipi_cpu
argument_list|(
name|hostcpu
argument_list|,
name|ipinum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|vlapic_enabled
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
name|vlapic
operator|->
name|apic_page
decl_stmt|;
if|if
condition|(
operator|(
name|vlapic
operator|->
name|msr_apicbase
operator|&
name|APICBASE_ENABLED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|lapic
operator|->
name|svr
operator|&
name|APIC_SVR_ENABLE
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_set_tmr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|int
name|vector
parameter_list|,
name|bool
name|level
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
decl_stmt|;
name|uint32_t
modifier|*
name|tmrptr
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|lapic
operator|=
name|vlapic
operator|->
name|apic_page
expr_stmt|;
name|tmrptr
operator|=
operator|&
name|lapic
operator|->
name|tmr0
expr_stmt|;
name|idx
operator|=
operator|(
name|vector
operator|/
literal|32
operator|)
operator|*
literal|4
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
expr_stmt|;
if|if
condition|(
name|level
condition|)
name|tmrptr
index|[
name|idx
index|]
operator||=
name|mask
expr_stmt|;
else|else
name|tmrptr
index|[
name|idx
index|]
operator|&=
operator|~
name|mask
expr_stmt|;
if|if
condition|(
name|vlapic
operator|->
name|ops
operator|.
name|set_tmr
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|vlapic
operator|->
name|ops
operator|.
name|set_tmr
call|)
argument_list|(
name|vlapic
argument_list|,
name|vector
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vlapic_reset_tmr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|int
name|vector
decl_stmt|;
name|VLAPIC_CTR0
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic resetting all vectors to edge-triggered"
argument_list|)
expr_stmt|;
for|for
control|(
name|vector
operator|=
literal|0
init|;
name|vector
operator|<=
literal|255
condition|;
name|vector
operator|++
control|)
name|vlapic_set_tmr
argument_list|(
name|vlapic
argument_list|,
name|vector
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vlapic_set_tmr_level
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|dest
parameter_list|,
name|bool
name|phys
parameter_list|,
name|int
name|delmode
parameter_list|,
name|int
name|vector
parameter_list|)
block|{
name|cpuset_t
name|dmask
decl_stmt|;
name|bool
name|lowprio
decl_stmt|;
name|KASSERT
argument_list|(
name|vector
operator|>=
literal|0
operator|&&
name|vector
operator|<=
literal|255
argument_list|,
operator|(
literal|"invalid vector %d"
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * A level trigger is valid only for fixed and lowprio delivery modes. 	 */
if|if
condition|(
name|delmode
operator|!=
name|APIC_DELMODE_FIXED
operator|&&
name|delmode
operator|!=
name|APIC_DELMODE_LOWPRIO
condition|)
block|{
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"Ignoring level trigger-mode for "
literal|"delivery-mode %d"
argument_list|,
name|delmode
argument_list|)
expr_stmt|;
return|return;
block|}
name|lowprio
operator|=
operator|(
name|delmode
operator|==
name|APIC_DELMODE_LOWPRIO
operator|)
expr_stmt|;
name|vlapic_calcdest
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
operator|&
name|dmask
argument_list|,
name|dest
argument_list|,
name|phys
argument_list|,
name|lowprio
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPU_ISSET
argument_list|(
name|vlapic
operator|->
name|vcpuid
argument_list|,
operator|&
name|dmask
argument_list|)
condition|)
return|return;
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"vector %d set to level-triggered"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
name|vlapic_set_tmr
argument_list|(
name|vlapic
argument_list|,
name|vector
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

