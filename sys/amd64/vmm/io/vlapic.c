begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 NetApp, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<x86/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<x86/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|"vmm_stat.h"
end_include

begin_include
include|#
directive|include
file|"vmm_lapic.h"
end_include

begin_include
include|#
directive|include
file|"vmm_ktr.h"
end_include

begin_include
include|#
directive|include
file|"vlapic.h"
end_include

begin_define
define|#
directive|define
name|VLAPIC_CTR0
parameter_list|(
name|vlapic
parameter_list|,
name|format
parameter_list|)
define|\
value|VCPU_CTR0((vlapic)->vm, (vlapic)->vcpuid, format)
end_define

begin_define
define|#
directive|define
name|VLAPIC_CTR1
parameter_list|(
name|vlapic
parameter_list|,
name|format
parameter_list|,
name|p1
parameter_list|)
define|\
value|VCPU_CTR1((vlapic)->vm, (vlapic)->vcpuid, format, p1)
end_define

begin_define
define|#
directive|define
name|VLAPIC_CTR_IRR
parameter_list|(
name|vlapic
parameter_list|,
name|msg
parameter_list|)
define|\
value|do {									\ 	uint32_t *irrptr =&(vlapic)->apic.irr0;			\ 	irrptr[0] = irrptr[0];
comment|/* silence compiler */
value|\ 	VLAPIC_CTR1((vlapic), msg " irr0 0x%08x", irrptr[0<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " irr1 0x%08x", irrptr[1<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " irr2 0x%08x", irrptr[2<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " irr3 0x%08x", irrptr[3<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " irr4 0x%08x", irrptr[4<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " irr5 0x%08x", irrptr[5<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " irr6 0x%08x", irrptr[6<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " irr7 0x%08x", irrptr[7<< 2]);	\ } while (0)
end_define

begin_define
define|#
directive|define
name|VLAPIC_CTR_ISR
parameter_list|(
name|vlapic
parameter_list|,
name|msg
parameter_list|)
define|\
value|do {									\ 	uint32_t *isrptr =&(vlapic)->apic.isr0;			\ 	isrptr[0] = isrptr[0];
comment|/* silence compiler */
value|\ 	VLAPIC_CTR1((vlapic), msg " isr0 0x%08x", isrptr[0<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " isr1 0x%08x", isrptr[1<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " isr2 0x%08x", isrptr[2<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " isr3 0x%08x", isrptr[3<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " isr4 0x%08x", isrptr[4<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " isr5 0x%08x", isrptr[5<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " isr6 0x%08x", isrptr[6<< 2]);	\ 	VLAPIC_CTR1((vlapic), msg " isr7 0x%08x", isrptr[7<< 2]);	\ } while (0)
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VLAPIC
argument_list|,
literal|"vlapic"
argument_list|,
literal|"vlapic"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PRIO
parameter_list|(
name|x
parameter_list|)
value|((x)>> 4)
end_define

begin_define
define|#
directive|define
name|VLAPIC_VERSION
value|(16)
end_define

begin_define
define|#
directive|define
name|VLAPIC_MAXLVT_ENTRIES
value|(5)
end_define

begin_define
define|#
directive|define
name|x2apic
parameter_list|(
name|vlapic
parameter_list|)
value|(((vlapic)->msr_apicbase& APICBASE_X2APIC) ? 1 : 0)
end_define

begin_enum
enum|enum
name|boot_state
block|{
name|BS_INIT
block|,
name|BS_SIPI
block|,
name|BS_RUNNING
block|}
enum|;
end_enum

begin_struct
struct|struct
name|vlapic
block|{
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
name|int
name|vcpuid
decl_stmt|;
name|struct
name|LAPIC
name|apic
decl_stmt|;
name|int
name|esr_update
decl_stmt|;
name|int
name|divisor
decl_stmt|;
name|int
name|ccr_ticks
decl_stmt|;
comment|/* 	 * The 'isrvec_stk' is a stack of vectors injected by the local apic. 	 * A vector is popped from the stack when the processor does an EOI. 	 * The vector on the top of the stack is used to compute the 	 * Processor Priority in conjunction with the TPR. 	 */
name|uint8_t
name|isrvec_stk
index|[
name|ISRVEC_STK_SIZE
index|]
decl_stmt|;
name|int
name|isrvec_stk_top
decl_stmt|;
name|uint64_t
name|msr_apicbase
decl_stmt|;
name|enum
name|boot_state
name|boot_state
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|VLAPIC_BUS_FREQ
value|tsc_freq
end_define

begin_function
specifier|static
name|int
name|vlapic_timer_divisor
parameter_list|(
name|uint32_t
name|dcr
parameter_list|)
block|{
switch|switch
condition|(
name|dcr
operator|&
literal|0xB
condition|)
block|{
case|case
name|APIC_TDCR_1
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|APIC_TDCR_2
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
name|APIC_TDCR_4
case|:
return|return
operator|(
literal|4
operator|)
return|;
case|case
name|APIC_TDCR_8
case|:
return|return
operator|(
literal|8
operator|)
return|;
case|case
name|APIC_TDCR_16
case|:
return|return
operator|(
literal|16
operator|)
return|;
case|case
name|APIC_TDCR_32
case|:
return|return
operator|(
literal|32
operator|)
return|;
case|case
name|APIC_TDCR_64
case|:
return|return
operator|(
literal|64
operator|)
return|;
case|case
name|APIC_TDCR_128
case|:
return|return
operator|(
literal|128
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"vlapic_timer_divisor: invalid dcr 0x%08x"
argument_list|,
name|dcr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_mask_lvts
parameter_list|(
name|uint32_t
modifier|*
name|lvts
parameter_list|,
name|int
name|num_lvt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_lvt
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|lvts
operator||=
name|APIC_LVT_M
expr_stmt|;
name|lvts
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static inline void vlapic_dump_lvt(uint32_t offset, uint32_t *lvt) { 	printf("Offset %x: lvt %08x (V:%02x DS:%x M:%x)\n", offset, 	    *lvt, *lvt& APIC_LVTT_VECTOR, *lvt& APIC_LVTT_DS, 	    *lvt& APIC_LVTT_M); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|uint64_t
name|vlapic_get_ccr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
return|return
name|lapic
operator|->
name|ccr_timer
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_update_errors
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|lapic
operator|->
name|esr
operator|=
literal|0
expr_stmt|;
comment|// XXX
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_init_ipi
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|lapic
operator|->
name|version
operator|=
name|VLAPIC_VERSION
expr_stmt|;
name|lapic
operator|->
name|version
operator||=
operator|(
name|VLAPIC_MAXLVT_ENTRIES
operator|<
name|MAXLVTSHIFT
operator|)
expr_stmt|;
name|lapic
operator|->
name|dfr
operator|=
literal|0xffffffff
expr_stmt|;
name|lapic
operator|->
name|svr
operator|=
name|APIC_SVR_VECTOR
expr_stmt|;
name|vlapic_mask_lvts
argument_list|(
operator|&
name|lapic
operator|->
name|lvt_timer
argument_list|,
name|VLAPIC_MAXLVT_ENTRIES
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vlapic_reset
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|memset
argument_list|(
name|lapic
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lapic
argument_list|)
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|apr
operator|=
name|vlapic
operator|->
name|vcpuid
expr_stmt|;
name|vlapic_init_ipi
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|divisor
operator|=
name|vlapic_timer_divisor
argument_list|(
name|lapic
operator|->
name|dcr_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlapic
operator|->
name|vcpuid
operator|==
literal|0
condition|)
name|vlapic
operator|->
name|boot_state
operator|=
name|BS_RUNNING
expr_stmt|;
comment|/* BSP */
else|else
name|vlapic
operator|->
name|boot_state
operator|=
name|BS_INIT
expr_stmt|;
comment|/* AP */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|vlapic_set_intr_ready
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|int
name|vector
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|uint32_t
modifier|*
name|irrptr
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|vector
operator|<
literal|0
operator|||
name|vector
operator|>=
literal|256
condition|)
name|panic
argument_list|(
literal|"vlapic_set_intr_ready: invalid vector %d\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
name|idx
operator|=
operator|(
name|vector
operator|/
literal|32
operator|)
operator|*
literal|4
expr_stmt|;
name|irrptr
operator|=
operator|&
name|lapic
operator|->
name|irr0
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|irrptr
index|[
name|idx
index|]
argument_list|,
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
argument_list|)
expr_stmt|;
name|VLAPIC_CTR_IRR
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic_set_intr_ready"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_start_timer
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|elapsed
parameter_list|)
block|{
name|uint32_t
name|icr_timer
decl_stmt|;
name|icr_timer
operator|=
name|vlapic
operator|->
name|apic
operator|.
name|icr_timer
expr_stmt|;
name|vlapic
operator|->
name|ccr_ticks
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|elapsed
operator|<
name|icr_timer
condition|)
name|vlapic
operator|->
name|apic
operator|.
name|ccr_timer
operator|=
name|icr_timer
operator|-
name|elapsed
expr_stmt|;
else|else
block|{
comment|/* 		 * This can happen when the guest is trying to run its local 		 * apic timer higher that the setting of 'hz' in the host. 		 * 		 * We deal with this by running the guest local apic timer 		 * at the rate of the host's 'hz' setting. 		 */
name|vlapic
operator|->
name|apic
operator|.
name|ccr_timer
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
modifier|*
name|vlapic_get_lvt
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|offset
operator|<
name|APIC_OFFSET_TIMER_LVT
operator|||
name|offset
operator|>
name|APIC_OFFSET_ERROR_LVT
condition|)
block|{
name|panic
argument_list|(
literal|"vlapic_get_lvt: invalid LVT\n"
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
operator|(
name|offset
operator|-
name|APIC_OFFSET_TIMER_LVT
operator|)
operator|>>
literal|2
expr_stmt|;
return|return
operator|(
operator|(
operator|&
name|lapic
operator|->
name|lvt_timer
operator|)
operator|+
name|i
operator|)
return|;
empty_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|1
end_if

begin_function
specifier|static
name|void
name|dump_isrvec_stk
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|isrptr
decl_stmt|;
name|isrptr
operator|=
operator|&
name|vlapic
operator|->
name|apic
operator|.
name|isr0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"ISR%d 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|isrptr
index|[
name|i
operator|*
literal|4
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|vlapic
operator|->
name|isrvec_stk_top
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"isrvec_stk[%d] = %d\n"
argument_list|,
name|i
argument_list|,
name|vlapic
operator|->
name|isrvec_stk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Algorithm adopted from section "Interrupt, Task and Processor Priority"  * in Intel Architecture Manual Vol 3a.  */
end_comment

begin_function
specifier|static
name|void
name|vlapic_update_ppr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|int
name|isrvec
decl_stmt|,
name|tpr
decl_stmt|,
name|ppr
decl_stmt|;
comment|/* 	 * Note that the value on the stack at index 0 is always 0. 	 * 	 * This is a placeholder for the value of ISRV when none of the 	 * bits is set in the ISRx registers. 	 */
name|isrvec
operator|=
name|vlapic
operator|->
name|isrvec_stk
index|[
name|vlapic
operator|->
name|isrvec_stk_top
index|]
expr_stmt|;
name|tpr
operator|=
name|vlapic
operator|->
name|apic
operator|.
name|tpr
expr_stmt|;
if|#
directive|if
literal|1
block|{
name|int
name|i
decl_stmt|,
name|lastprio
decl_stmt|,
name|curprio
decl_stmt|,
name|vector
decl_stmt|,
name|idx
decl_stmt|;
name|uint32_t
modifier|*
name|isrptr
decl_stmt|;
if|if
condition|(
name|vlapic
operator|->
name|isrvec_stk_top
operator|==
literal|0
operator|&&
name|isrvec
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"isrvec_stk is corrupted: %d"
argument_list|,
name|isrvec
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure that the priority of the nested interrupts is 		 * always increasing. 		 */
name|lastprio
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|vlapic
operator|->
name|isrvec_stk_top
condition|;
name|i
operator|++
control|)
block|{
name|curprio
operator|=
name|PRIO
argument_list|(
name|vlapic
operator|->
name|isrvec_stk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|curprio
operator|<=
name|lastprio
condition|)
block|{
name|dump_isrvec_stk
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"isrvec_stk does not satisfy invariant"
argument_list|)
expr_stmt|;
block|}
name|lastprio
operator|=
name|curprio
expr_stmt|;
block|}
comment|/* 		 * Make sure that each bit set in the ISRx registers has a 		 * corresponding entry on the isrvec stack. 		 */
name|i
operator|=
literal|1
expr_stmt|;
name|isrptr
operator|=
operator|&
name|vlapic
operator|->
name|apic
operator|.
name|isr0
expr_stmt|;
for|for
control|(
name|vector
operator|=
literal|0
init|;
name|vector
operator|<
literal|256
condition|;
name|vector
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|vector
operator|/
literal|32
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|isrptr
index|[
name|idx
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|vlapic
operator|->
name|isrvec_stk_top
operator|||
name|vlapic
operator|->
name|isrvec_stk
index|[
name|i
index|]
operator|!=
name|vector
condition|)
block|{
name|dump_isrvec_stk
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ISR and isrvec_stk out of sync"
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|PRIO
argument_list|(
name|tpr
argument_list|)
operator|>=
name|PRIO
argument_list|(
name|isrvec
argument_list|)
condition|)
name|ppr
operator|=
name|tpr
expr_stmt|;
else|else
name|ppr
operator|=
name|isrvec
operator|&
literal|0xf0
expr_stmt|;
name|vlapic
operator|->
name|apic
operator|.
name|ppr
operator|=
name|ppr
expr_stmt|;
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic_update_ppr 0x%02x"
argument_list|,
name|ppr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vlapic_process_eoi
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|uint32_t
modifier|*
name|isrptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|,
name|bitpos
decl_stmt|;
name|isrptr
operator|=
operator|&
name|lapic
operator|->
name|isr0
expr_stmt|;
comment|/* 	 * The x86 architecture reserves the the first 32 vectors for use 	 * by the processor. 	 */
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|idx
operator|=
name|i
operator|*
literal|4
expr_stmt|;
name|bitpos
operator|=
name|fls
argument_list|(
name|isrptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|vlapic
operator|->
name|isrvec_stk_top
operator|<=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"invalid vlapic isrvec_stk_top %d"
argument_list|,
name|vlapic
operator|->
name|isrvec_stk_top
argument_list|)
expr_stmt|;
block|}
name|isrptr
index|[
name|idx
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|bitpos
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|VLAPIC_CTR_ISR
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic_process_eoi"
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|isrvec_stk_top
operator|--
expr_stmt|;
name|vlapic_update_ppr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|vlapic_get_lvt_field
parameter_list|(
name|uint32_t
modifier|*
name|lvt
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
return|return
operator|(
operator|*
name|lvt
operator|&
name|mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|vlapic_periodic_timer
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|uint32_t
modifier|*
name|lvt
decl_stmt|;
name|lvt
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_TIMER_LVT
argument_list|)
expr_stmt|;
return|return
operator|(
name|vlapic_get_lvt_field
argument_list|(
name|lvt
argument_list|,
name|APIC_LVTT_TM_PERIODIC
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|VMM_STAT
argument_list|(
name|VLAPIC_INTR_TIMER
argument_list|,
literal|"timer interrupts generated by vlapic"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|vlapic_fire_timer
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|int
name|vector
decl_stmt|;
name|uint32_t
modifier|*
name|lvt
decl_stmt|;
name|lvt
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|APIC_OFFSET_TIMER_LVT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vlapic_get_lvt_field
argument_list|(
name|lvt
argument_list|,
name|APIC_LVTT_M
argument_list|)
condition|)
block|{
name|vmm_stat_incr
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
name|VLAPIC_INTR_TIMER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vector
operator|=
name|vlapic_get_lvt_field
argument_list|(
name|lvt
argument_list|,
name|APIC_LVTT_VECTOR
argument_list|)
expr_stmt|;
name|vlapic_set_intr_ready
argument_list|(
name|vlapic
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|VMM_STAT_ARRAY
argument_list|(
name|IPIS_SENT
argument_list|,
name|VM_MAXCPU
argument_list|,
literal|"ipis sent to vcpu"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|lapic_process_icr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint64_t
name|icrval
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|cpuset_t
name|dmask
decl_stmt|;
name|uint32_t
name|dest
decl_stmt|,
name|vec
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|vlapic
modifier|*
name|vlapic2
decl_stmt|;
name|struct
name|vm_exit
modifier|*
name|vmexit
decl_stmt|;
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
name|dest
operator|=
name|icrval
operator|>>
literal|32
expr_stmt|;
else|else
name|dest
operator|=
name|icrval
operator|>>
operator|(
literal|32
operator|+
literal|24
operator|)
expr_stmt|;
name|vec
operator|=
name|icrval
operator|&
name|APIC_VECTOR_MASK
expr_stmt|;
name|mode
operator|=
name|icrval
operator|&
name|APIC_DELMODE_MASK
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|APIC_DELMODE_FIXED
operator|||
name|mode
operator|==
name|APIC_DELMODE_NMI
condition|)
block|{
switch|switch
condition|(
name|icrval
operator|&
name|APIC_DEST_MASK
condition|)
block|{
case|case
name|APIC_DEST_DESTFLD
case|:
name|CPU_SETOF
argument_list|(
name|dest
argument_list|,
operator|&
name|dmask
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_DEST_SELF
case|:
name|CPU_SETOF
argument_list|(
name|vlapic
operator|->
name|vcpuid
argument_list|,
operator|&
name|dmask
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_DEST_ALLISELF
case|:
name|dmask
operator|=
name|vm_active_cpus
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_DEST_ALLESELF
case|:
name|dmask
operator|=
name|vm_active_cpus
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|)
expr_stmt|;
name|CPU_CLR
argument_list|(
name|vlapic
operator|->
name|vcpuid
argument_list|,
operator|&
name|dmask
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CPU_ZERO
argument_list|(
operator|&
name|dmask
argument_list|)
expr_stmt|;
comment|/* satisfy gcc */
break|break;
block|}
while|while
condition|(
operator|(
name|i
operator|=
name|CPU_FFS
argument_list|(
operator|&
name|dmask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|CPU_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|dmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|APIC_DELMODE_FIXED
condition|)
block|{
name|lapic_set_intr
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|i
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|vmm_stat_array_incr
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
name|IPIS_SENT
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|vm_inject_nmi
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* handled completely in the kernel */
block|}
if|if
condition|(
name|mode
operator|==
name|APIC_DELMODE_INIT
condition|)
block|{
if|if
condition|(
operator|(
name|icrval
operator|&
name|APIC_LEVEL_MASK
operator|)
operator|==
name|APIC_LEVEL_DEASSERT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|vlapic
operator|->
name|vcpuid
operator|==
literal|0
operator|&&
name|dest
operator|!=
literal|0
operator|&&
name|dest
operator|<
name|VM_MAXCPU
condition|)
block|{
name|vlapic2
operator|=
name|vm_lapic
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/* move from INIT to waiting-for-SIPI state */
if|if
condition|(
name|vlapic2
operator|->
name|boot_state
operator|==
name|BS_INIT
condition|)
block|{
name|vlapic2
operator|->
name|boot_state
operator|=
name|BS_SIPI
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|APIC_DELMODE_STARTUP
condition|)
block|{
if|if
condition|(
name|vlapic
operator|->
name|vcpuid
operator|==
literal|0
operator|&&
name|dest
operator|!=
literal|0
operator|&&
name|dest
operator|<
name|VM_MAXCPU
condition|)
block|{
name|vlapic2
operator|=
name|vm_lapic
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/* 			 * Ignore SIPIs in any state other than wait-for-SIPI 			 */
if|if
condition|(
name|vlapic2
operator|->
name|boot_state
operator|!=
name|BS_SIPI
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vmexit
operator|=
name|vm_exitinfo
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_SPINUP_AP
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|spinup_ap
operator|.
name|vcpu
operator|=
name|dest
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|spinup_ap
operator|.
name|rip
operator|=
name|vec
operator|<<
name|PAGE_SHIFT
expr_stmt|;
comment|/* 			 * XXX this assumes that the startup IPI always succeeds 			 */
name|vlapic2
operator|->
name|boot_state
operator|=
name|BS_RUNNING
expr_stmt|;
name|vm_activate_cpu
argument_list|(
name|vlapic2
operator|->
name|vm
argument_list|,
name|dest
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * This will cause a return to userland. 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vlapic_pending_intr
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|i
decl_stmt|,
name|bitpos
decl_stmt|,
name|vector
decl_stmt|;
name|uint32_t
modifier|*
name|irrptr
decl_stmt|,
name|val
decl_stmt|;
name|irrptr
operator|=
operator|&
name|lapic
operator|->
name|irr0
expr_stmt|;
comment|/* 	 * The x86 architecture reserves the the first 32 vectors for use 	 * by the processor. 	 */
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|idx
operator|=
name|i
operator|*
literal|4
expr_stmt|;
name|val
operator|=
name|atomic_load_acq_int
argument_list|(
operator|&
name|irrptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|bitpos
operator|=
name|fls
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|!=
literal|0
condition|)
block|{
name|vector
operator|=
name|i
operator|*
literal|32
operator|+
operator|(
name|bitpos
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|PRIO
argument_list|(
name|vector
argument_list|)
operator|>
name|PRIO
argument_list|(
name|lapic
operator|->
name|ppr
argument_list|)
condition|)
block|{
name|VLAPIC_CTR1
argument_list|(
name|vlapic
argument_list|,
literal|"pending intr %d"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return
operator|(
name|vector
operator|)
return|;
block|}
else|else
break|break;
block|}
block|}
name|VLAPIC_CTR0
argument_list|(
name|vlapic
argument_list|,
literal|"no pending intr"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vlapic_intr_accepted
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|int
name|vector
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|uint32_t
modifier|*
name|irrptr
decl_stmt|,
modifier|*
name|isrptr
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|stk_top
decl_stmt|;
comment|/* 	 * clear the ready bit for vector being accepted in irr  	 * and set the vector as in service in isr. 	 */
name|idx
operator|=
operator|(
name|vector
operator|/
literal|32
operator|)
operator|*
literal|4
expr_stmt|;
name|irrptr
operator|=
operator|&
name|lapic
operator|->
name|irr0
expr_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|irrptr
index|[
name|idx
index|]
argument_list|,
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
argument_list|)
expr_stmt|;
name|VLAPIC_CTR_IRR
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic_intr_accepted"
argument_list|)
expr_stmt|;
name|isrptr
operator|=
operator|&
name|lapic
operator|->
name|isr0
expr_stmt|;
name|isrptr
index|[
name|idx
index|]
operator||=
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
expr_stmt|;
name|VLAPIC_CTR_ISR
argument_list|(
name|vlapic
argument_list|,
literal|"vlapic_intr_accepted"
argument_list|)
expr_stmt|;
comment|/* 	 * Update the PPR 	 */
name|vlapic
operator|->
name|isrvec_stk_top
operator|++
expr_stmt|;
name|stk_top
operator|=
name|vlapic
operator|->
name|isrvec_stk_top
expr_stmt|;
if|if
condition|(
name|stk_top
operator|>=
name|ISRVEC_STK_SIZE
condition|)
name|panic
argument_list|(
literal|"isrvec_stk_top overflow %d"
argument_list|,
name|stk_top
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|isrvec_stk
index|[
name|stk_top
index|]
operator|=
name|vector
expr_stmt|;
name|vlapic_update_ppr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vlapic_read
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|uint32_t
modifier|*
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|offset
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|lapic
argument_list|)
condition|)
block|{
operator|*
name|data
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|offset
operator|&=
operator|~
literal|3
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|APIC_OFFSET_ID
case|:
if|if
condition|(
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
operator|*
name|data
operator|=
name|vlapic
operator|->
name|vcpuid
expr_stmt|;
else|else
operator|*
name|data
operator|=
name|vlapic
operator|->
name|vcpuid
operator|<<
literal|24
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_VER
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|version
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_TPR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|tpr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_APR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|apr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_PPR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|ppr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_EOI
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|eoi
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_LDR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|ldr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_DFR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|dfr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_SVR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|svr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ISR0
operator|...
name|APIC_OFFSET_ISR7
case|:
name|i
operator|=
operator|(
name|offset
operator|-
name|APIC_OFFSET_ISR0
operator|)
operator|>>
literal|2
expr_stmt|;
name|reg
operator|=
operator|&
name|lapic
operator|->
name|isr0
expr_stmt|;
operator|*
name|data
operator|=
operator|*
operator|(
name|reg
operator|+
name|i
operator|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_TMR0
operator|...
name|APIC_OFFSET_TMR7
case|:
name|i
operator|=
operator|(
name|offset
operator|-
name|APIC_OFFSET_TMR0
operator|)
operator|>>
literal|2
expr_stmt|;
name|reg
operator|=
operator|&
name|lapic
operator|->
name|tmr0
expr_stmt|;
operator|*
name|data
operator|=
operator|*
operator|(
name|reg
operator|+
name|i
operator|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_IRR0
operator|...
name|APIC_OFFSET_IRR7
case|:
name|i
operator|=
operator|(
name|offset
operator|-
name|APIC_OFFSET_IRR0
operator|)
operator|>>
literal|2
expr_stmt|;
name|reg
operator|=
operator|&
name|lapic
operator|->
name|irr0
expr_stmt|;
operator|*
name|data
operator|=
name|atomic_load_acq_int
argument_list|(
name|reg
operator|+
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ESR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|esr
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ICR_LOW
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|icr_lo
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ICR_HI
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|icr_hi
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_TIMER_LVT
operator|...
name|APIC_OFFSET_ERROR_LVT
case|:
name|reg
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|offset
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
operator|*
operator|(
name|reg
operator|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ICR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|icr_timer
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_CCR
case|:
operator|*
name|data
operator|=
name|vlapic_get_ccr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_DCR
case|:
operator|*
name|data
operator|=
name|lapic
operator|->
name|dcr_timer
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_RRR
case|:
default|default:
operator|*
name|data
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|vlapic_write
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|data
parameter_list|)
block|{
name|struct
name|LAPIC
modifier|*
name|lapic
init|=
operator|&
name|vlapic
operator|->
name|apic
decl_stmt|;
name|uint32_t
modifier|*
name|reg
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|offset
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|lapic
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|retval
operator|=
literal|0
expr_stmt|;
name|offset
operator|&=
operator|~
literal|3
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|APIC_OFFSET_ID
case|:
break|break;
case|case
name|APIC_OFFSET_TPR
case|:
name|lapic
operator|->
name|tpr
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
name|vlapic_update_ppr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_EOI
case|:
name|vlapic_process_eoi
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_LDR
case|:
break|break;
case|case
name|APIC_OFFSET_DFR
case|:
break|break;
case|case
name|APIC_OFFSET_SVR
case|:
name|lapic
operator|->
name|svr
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ICR_LOW
case|:
if|if
condition|(
operator|!
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
block|{
name|data
operator|&=
literal|0xffffffff
expr_stmt|;
name|data
operator||=
operator|(
name|uint64_t
operator|)
name|lapic
operator|->
name|icr_hi
operator|<<
literal|32
expr_stmt|;
block|}
name|retval
operator|=
name|lapic_process_icr
argument_list|(
name|vlapic
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ICR_HI
case|:
if|if
condition|(
operator|!
name|x2apic
argument_list|(
name|vlapic
argument_list|)
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|lapic
operator|->
name|icr_hi
operator|=
name|data
expr_stmt|;
block|}
break|break;
case|case
name|APIC_OFFSET_TIMER_LVT
operator|...
name|APIC_OFFSET_ERROR_LVT
case|:
name|reg
operator|=
name|vlapic_get_lvt
argument_list|(
name|vlapic
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lapic
operator|->
name|svr
operator|&
name|APIC_SVR_ENABLE
operator|)
condition|)
block|{
name|data
operator||=
name|APIC_LVT_M
expr_stmt|;
block|}
operator|*
name|reg
operator|=
name|data
expr_stmt|;
comment|// vlapic_dump_lvt(offset, reg);
break|break;
case|case
name|APIC_OFFSET_ICR
case|:
name|lapic
operator|->
name|icr_timer
operator|=
name|data
expr_stmt|;
name|vlapic_start_timer
argument_list|(
name|vlapic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_DCR
case|:
name|lapic
operator|->
name|dcr_timer
operator|=
name|data
expr_stmt|;
name|vlapic
operator|->
name|divisor
operator|=
name|vlapic_timer_divisor
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_ESR
case|:
name|vlapic_update_errors
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_OFFSET_VER
case|:
case|case
name|APIC_OFFSET_APR
case|:
case|case
name|APIC_OFFSET_PPR
case|:
case|case
name|APIC_OFFSET_RRR
case|:
case|case
name|APIC_OFFSET_ISR0
operator|...
name|APIC_OFFSET_ISR7
case|:
case|case
name|APIC_OFFSET_TMR0
operator|...
name|APIC_OFFSET_TMR7
case|:
case|case
name|APIC_OFFSET_IRR0
operator|...
name|APIC_OFFSET_IRR7
case|:
case|case
name|APIC_OFFSET_CCR
case|:
default|default:
comment|// Read only.
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vlapic_timer_tick
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|int
name|curticks
decl_stmt|,
name|delta
decl_stmt|,
name|periodic
decl_stmt|,
name|fired
decl_stmt|;
name|uint32_t
name|ccr
decl_stmt|;
name|uint32_t
name|decrement
decl_stmt|,
name|leftover
decl_stmt|;
name|restart
label|:
name|curticks
operator|=
name|ticks
expr_stmt|;
name|delta
operator|=
name|curticks
operator|-
name|vlapic
operator|->
name|ccr_ticks
expr_stmt|;
comment|/* Local APIC timer is disabled */
if|if
condition|(
name|vlapic
operator|->
name|apic
operator|.
name|icr_timer
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* One-shot mode and timer has already counted down to zero */
name|periodic
operator|=
name|vlapic_periodic_timer
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|periodic
operator|&&
name|vlapic
operator|->
name|apic
operator|.
name|ccr_timer
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * The 'curticks' and 'ccr_ticks' are out of sync by more than 	 * 2^31 ticks. We deal with this by restarting the timer. 	 */
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|vlapic_start_timer
argument_list|(
name|vlapic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|fired
operator|=
literal|0
expr_stmt|;
name|decrement
operator|=
operator|(
name|VLAPIC_BUS_FREQ
operator|/
name|vlapic
operator|->
name|divisor
operator|)
operator|/
name|hz
expr_stmt|;
name|vlapic
operator|->
name|ccr_ticks
operator|=
name|curticks
expr_stmt|;
name|ccr
operator|=
name|vlapic
operator|->
name|apic
operator|.
name|ccr_timer
expr_stmt|;
while|while
condition|(
name|delta
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ccr
operator|>
name|decrement
condition|)
block|{
name|ccr
operator|-=
name|decrement
expr_stmt|;
continue|continue;
block|}
comment|/* Trigger the local apic timer interrupt */
name|vlapic_fire_timer
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
if|if
condition|(
name|periodic
condition|)
block|{
name|leftover
operator|=
name|decrement
operator|-
name|ccr
expr_stmt|;
name|vlapic_start_timer
argument_list|(
name|vlapic
argument_list|,
name|leftover
argument_list|)
expr_stmt|;
name|ccr
operator|=
name|vlapic
operator|->
name|apic
operator|.
name|ccr_timer
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * One-shot timer has counted down to zero. 			 */
name|ccr
operator|=
literal|0
expr_stmt|;
block|}
name|fired
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|vlapic
operator|->
name|apic
operator|.
name|ccr_timer
operator|=
name|ccr
expr_stmt|;
if|if
condition|(
operator|!
name|fired
condition|)
return|return
operator|(
operator|(
name|ccr
operator|/
name|decrement
operator|)
operator|+
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|vlapic
modifier|*
name|vlapic_init
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|)
block|{
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|vlapic
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vlapic
argument_list|)
argument_list|,
name|M_VLAPIC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|vlapic
operator|->
name|vcpuid
operator|=
name|vcpuid
expr_stmt|;
name|vlapic
operator|->
name|msr_apicbase
operator|=
name|DEFAULT_APIC_BASE
operator||
name|APICBASE_ENABLED
expr_stmt|;
if|if
condition|(
name|vcpuid
operator|==
literal|0
condition|)
name|vlapic
operator|->
name|msr_apicbase
operator||=
name|APICBASE_BSP
expr_stmt|;
name|vlapic_reset
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
return|return
operator|(
name|vlapic
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vlapic_cleanup
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|free
argument_list|(
name|vlapic
argument_list|,
name|M_VLAPIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|vlapic_get_apicbase
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
return|return
operator|(
name|vlapic
operator|->
name|msr_apicbase
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vlapic_set_apicbase
parameter_list|(
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|enum
name|x2apic_state
name|state
decl_stmt|;
name|err
operator|=
name|vm_get_x2apic_state
argument_list|(
name|vlapic
operator|->
name|vm
argument_list|,
name|vlapic
operator|->
name|vcpuid
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|panic
argument_list|(
literal|"vlapic_set_apicbase: err %d fetching x2apic state"
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|X2APIC_DISABLED
condition|)
name|val
operator|&=
operator|~
name|APICBASE_X2APIC
expr_stmt|;
name|vlapic
operator|->
name|msr_apicbase
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vlapic_set_x2apic_state
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|enum
name|x2apic_state
name|state
parameter_list|)
block|{
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|vlapic
operator|=
name|vm_lapic
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|X2APIC_DISABLED
condition|)
name|vlapic
operator|->
name|msr_apicbase
operator|&=
operator|~
name|APICBASE_X2APIC
expr_stmt|;
block|}
end_function

end_unit

