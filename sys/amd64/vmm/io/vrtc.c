begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014, Neel Natu (neel@freebsd.org)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|<isa/rtc.h>
end_include

begin_include
include|#
directive|include
file|"vmm_ktr.h"
end_include

begin_include
include|#
directive|include
file|"vatpic.h"
end_include

begin_include
include|#
directive|include
file|"vioapic.h"
end_include

begin_include
include|#
directive|include
file|"vrtc.h"
end_include

begin_comment
comment|/* Register layout of the RTC */
end_comment

begin_struct
struct|struct
name|rtcdev
block|{
name|uint8_t
name|sec
decl_stmt|;
name|uint8_t
name|alarm_sec
decl_stmt|;
name|uint8_t
name|min
decl_stmt|;
name|uint8_t
name|alarm_min
decl_stmt|;
name|uint8_t
name|hour
decl_stmt|;
name|uint8_t
name|alarm_hour
decl_stmt|;
name|uint8_t
name|day_of_week
decl_stmt|;
name|uint8_t
name|day_of_month
decl_stmt|;
name|uint8_t
name|month
decl_stmt|;
name|uint8_t
name|year
decl_stmt|;
name|uint8_t
name|reg_a
decl_stmt|;
name|uint8_t
name|reg_b
decl_stmt|;
name|uint8_t
name|reg_c
decl_stmt|;
name|uint8_t
name|reg_d
decl_stmt|;
name|uint8_t
name|nvram
index|[
literal|36
index|]
decl_stmt|;
name|uint8_t
name|century
decl_stmt|;
name|uint8_t
name|nvram2
index|[
literal|128
operator|-
literal|51
index|]
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rtcdev
argument_list|)
operator|==
literal|128
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|rtcdev
argument_list|,
name|century
argument_list|)
operator|==
name|RTC_CENTURY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|vrtc
block|{
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
name|struct
name|mtx
name|mtx
decl_stmt|;
name|struct
name|callout
name|callout
decl_stmt|;
name|u_int
name|addr
decl_stmt|;
comment|/* RTC register to read or write */
name|sbintime_t
name|base_uptime
decl_stmt|;
name|time_t
name|base_rtctime
decl_stmt|;
name|struct
name|rtcdev
name|rtcdev
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|VRTC_LOCK
parameter_list|(
name|vrtc
parameter_list|)
value|mtx_lock(&((vrtc)->mtx))
end_define

begin_define
define|#
directive|define
name|VRTC_UNLOCK
parameter_list|(
name|vrtc
parameter_list|)
value|mtx_unlock(&((vrtc)->mtx))
end_define

begin_define
define|#
directive|define
name|VRTC_LOCKED
parameter_list|(
name|vrtc
parameter_list|)
value|mtx_owned(&((vrtc)->mtx))
end_define

begin_comment
comment|/*  * RTC time is considered "broken" if:  * - RTC updates are halted by the guest  * - RTC date/time fields have invalid values  */
end_comment

begin_define
define|#
directive|define
name|VRTC_BROKEN_TIME
value|((time_t)-1)
end_define

begin_define
define|#
directive|define
name|RTC_IRQ
value|8
end_define

begin_define
define|#
directive|define
name|RTCSB_BIN
value|0x04
end_define

begin_define
define|#
directive|define
name|RTCSB_ALL_INTRS
value|(RTCSB_UINTR | RTCSB_AINTR | RTCSB_PINTR)
end_define

begin_define
define|#
directive|define
name|rtc_halted
parameter_list|(
name|vrtc
parameter_list|)
value|((vrtc->rtcdev.reg_b& RTCSB_HALT) != 0)
end_define

begin_define
define|#
directive|define
name|aintr_enabled
parameter_list|(
name|vrtc
parameter_list|)
value|(((vrtc)->rtcdev.reg_b& RTCSB_AINTR) != 0)
end_define

begin_define
define|#
directive|define
name|pintr_enabled
parameter_list|(
name|vrtc
parameter_list|)
value|(((vrtc)->rtcdev.reg_b& RTCSB_PINTR) != 0)
end_define

begin_define
define|#
directive|define
name|uintr_enabled
parameter_list|(
name|vrtc
parameter_list|)
value|(((vrtc)->rtcdev.reg_b& RTCSB_UINTR) != 0)
end_define

begin_function_decl
specifier|static
name|void
name|vrtc_callout_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vrtc_set_reg_c
parameter_list|(
name|struct
name|vrtc
modifier|*
name|vrtc
parameter_list|,
name|uint8_t
name|newval
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VRTC
argument_list|,
literal|"vrtc"
argument_list|,
literal|"bhyve virtual rtc"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_vmm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_vmm
argument_list|,
name|OID_AUTO
argument_list|,
name|vrtc
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|rtc_flag_broken_time
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_vmm_vrtc
argument_list|,
name|OID_AUTO
argument_list|,
name|flag_broken_time
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|rtc_flag_broken_time
argument_list|,
literal|0
argument_list|,
literal|"Stop guest when invalid RTC time is detected"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|__inline
name|bool
name|divider_enabled
parameter_list|(
name|int
name|reg_a
parameter_list|)
block|{
comment|/* 	 * The RTC is counting only when dividers are not held in reset. 	 */
return|return
operator|(
operator|(
name|reg_a
operator|&
literal|0x70
operator|)
operator|==
literal|0x20
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|bool
name|update_enabled
parameter_list|(
name|struct
name|vrtc
modifier|*
name|vrtc
parameter_list|)
block|{
comment|/* 	 * RTC date/time can be updated only if: 	 * - divider is not held in reset 	 * - guest has not disabled updates 	 * - the date/time fields have valid contents 	 */
if|if
condition|(
operator|!
name|divider_enabled
argument_list|(
name|vrtc
operator|->
name|rtcdev
operator|.
name|reg_a
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|rtc_halted
argument_list|(
name|vrtc
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|vrtc
operator|->
name|base_rtctime
operator|==
name|VRTC_BROKEN_TIME
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|vrtc_curtime
parameter_list|(
name|struct
name|vrtc
modifier|*
name|vrtc
parameter_list|)
block|{
name|sbintime_t
name|now
decl_stmt|,
name|delta
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|KASSERT
argument_list|(
name|VRTC_LOCKED
argument_list|(
name|vrtc
argument_list|)
argument_list|,
operator|(
literal|"%s: vrtc not locked"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|vrtc
operator|->
name|base_rtctime
expr_stmt|;
if|if
condition|(
name|update_enabled
argument_list|(
name|vrtc
argument_list|)
condition|)
block|{
name|now
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
name|delta
operator|=
name|now
operator|-
name|vrtc
operator|->
name|base_uptime
expr_stmt|;
name|KASSERT
argument_list|(
name|delta
operator|>=
literal|0
argument_list|,
operator|(
literal|"vrtc_curtime: uptime went backwards: "
literal|"%#lx to %#lx"
operator|,
name|vrtc
operator|->
name|base_uptime
operator|,
name|now
operator|)
argument_list|)
expr_stmt|;
name|t
operator|+=
name|delta
operator|/
name|SBT_1S
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint8_t
name|rtcset
parameter_list|(
name|struct
name|rtcdev
modifier|*
name|rtc
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|val
operator|>=
literal|0
operator|&&
name|val
operator|<
literal|100
argument_list|,
operator|(
literal|"%s: invalid bin2bcd index %d"
operator|,
name|__func__
operator|,
name|val
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|rtc
operator|->
name|reg_b
operator|&
name|RTCSB_BIN
operator|)
condition|?
name|val
else|:
name|bin2bcd_data
index|[
name|val
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|secs_to_rtc
parameter_list|(
name|time_t
name|rtctime
parameter_list|,
name|struct
name|vrtc
modifier|*
name|vrtc
parameter_list|,
name|int
name|force_update
parameter_list|)
block|{
name|struct
name|clocktime
name|ct
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|rtcdev
modifier|*
name|rtc
decl_stmt|;
name|int
name|hour
decl_stmt|;
name|KASSERT
argument_list|(
name|VRTC_LOCKED
argument_list|(
name|vrtc
argument_list|)
argument_list|,
operator|(
literal|"%s: vrtc not locked"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtctime
operator|<
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|rtctime
operator|==
name|VRTC_BROKEN_TIME
argument_list|,
operator|(
literal|"%s: invalid vrtc time %#lx"
operator|,
name|__func__
operator|,
name|rtctime
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the RTC is halted then the guest has "ownership" of the 	 * date/time fields. Don't update the RTC date/time fields in 	 * this case (unless forced). 	 */
if|if
condition|(
name|rtc_halted
argument_list|(
name|vrtc
argument_list|)
operator|&&
operator|!
name|force_update
condition|)
return|return;
name|ts
operator|.
name|tv_sec
operator|=
name|rtctime
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|clock_ts_to_ct
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|ct
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ct
operator|.
name|sec
operator|>=
literal|0
operator|&&
name|ct
operator|.
name|sec
operator|<=
literal|59
argument_list|,
operator|(
literal|"invalid clocktime sec %d"
operator|,
name|ct
operator|.
name|sec
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ct
operator|.
name|min
operator|>=
literal|0
operator|&&
name|ct
operator|.
name|min
operator|<=
literal|59
argument_list|,
operator|(
literal|"invalid clocktime min %d"
operator|,
name|ct
operator|.
name|min
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ct
operator|.
name|hour
operator|>=
literal|0
operator|&&
name|ct
operator|.
name|hour
operator|<=
literal|23
argument_list|,
operator|(
literal|"invalid clocktime hour %d"
operator|,
name|ct
operator|.
name|hour
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ct
operator|.
name|dow
operator|>=
literal|0
operator|&&
name|ct
operator|.
name|dow
operator|<=
literal|6
argument_list|,
operator|(
literal|"invalid clocktime wday %d"
operator|,
name|ct
operator|.
name|dow
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ct
operator|.
name|day
operator|>=
literal|1
operator|&&
name|ct
operator|.
name|day
operator|<=
literal|31
argument_list|,
operator|(
literal|"invalid clocktime mday %d"
operator|,
name|ct
operator|.
name|day
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ct
operator|.
name|mon
operator|>=
literal|1
operator|&&
name|ct
operator|.
name|mon
operator|<=
literal|12
argument_list|,
operator|(
literal|"invalid clocktime month %d"
operator|,
name|ct
operator|.
name|mon
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ct
operator|.
name|year
operator|>=
name|POSIX_BASE_YEAR
argument_list|,
operator|(
literal|"invalid clocktime year %d"
operator|,
name|ct
operator|.
name|year
operator|)
argument_list|)
expr_stmt|;
name|rtc
operator|=
operator|&
name|vrtc
operator|->
name|rtcdev
expr_stmt|;
name|rtc
operator|->
name|sec
operator|=
name|rtcset
argument_list|(
name|rtc
argument_list|,
name|ct
operator|.
name|sec
argument_list|)
expr_stmt|;
name|rtc
operator|->
name|min
operator|=
name|rtcset
argument_list|(
name|rtc
argument_list|,
name|ct
operator|.
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtc
operator|->
name|reg_b
operator|&
name|RTCSB_24HR
condition|)
block|{
name|hour
operator|=
name|ct
operator|.
name|hour
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Convert to the 12-hour format. 		 */
switch|switch
condition|(
name|ct
operator|.
name|hour
condition|)
block|{
case|case
literal|0
case|:
comment|/* 12 AM */
case|case
literal|12
case|:
comment|/* 12 PM */
name|hour
operator|=
literal|12
expr_stmt|;
break|break;
default|default:
comment|/* 			 * The remaining 'ct.hour' values are interpreted as: 			 * [1  - 11] ->  1 - 11 AM 			 * [13 - 23] ->  1 - 11 PM 			 */
name|hour
operator|=
name|ct
operator|.
name|hour
operator|%
literal|12
expr_stmt|;
break|break;
block|}
block|}
name|rtc
operator|->
name|hour
operator|=
name|rtcset
argument_list|(
name|rtc
argument_list|,
name|hour
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rtc
operator|->
name|reg_b
operator|&
name|RTCSB_24HR
operator|)
operator|==
literal|0
operator|&&
name|ct
operator|.
name|hour
operator|>=
literal|12
condition|)
name|rtc
operator|->
name|hour
operator||=
literal|0x80
expr_stmt|;
comment|/* set MSB to indicate PM */
name|rtc
operator|->
name|day_of_week
operator|=
name|rtcset
argument_list|(
name|rtc
argument_list|,
name|ct
operator|.
name|dow
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rtc
operator|->
name|day_of_month
operator|=
name|rtcset
argument_list|(
name|rtc
argument_list|,
name|ct
operator|.
name|day
argument_list|)
expr_stmt|;
name|rtc
operator|->
name|month
operator|=
name|rtcset
argument_list|(
name|rtc
argument_list|,
name|ct
operator|.
name|mon
argument_list|)
expr_stmt|;
name|rtc
operator|->
name|year
operator|=
name|rtcset
argument_list|(
name|rtc
argument_list|,
name|ct
operator|.
name|year
operator|%
literal|100
argument_list|)
expr_stmt|;
name|rtc
operator|->
name|century
operator|=
name|rtcset
argument_list|(
name|rtc
argument_list|,
name|ct
operator|.
name|year
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtcget
parameter_list|(
name|struct
name|rtcdev
modifier|*
name|rtc
parameter_list|,
name|int
name|val
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|uint8_t
name|upper
decl_stmt|,
name|lower
decl_stmt|;
if|if
condition|(
name|rtc
operator|->
name|reg_b
operator|&
name|RTCSB_BIN
condition|)
block|{
operator|*
name|retval
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|lower
operator|=
name|val
operator|&
literal|0xf
expr_stmt|;
name|upper
operator|=
operator|(
name|val
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|lower
operator|>
literal|9
operator|||
name|upper
operator|>
literal|9
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|retval
operator|=
name|upper
operator|*
literal|10
operator|+
name|lower
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|rtc_to_secs
parameter_list|(
name|struct
name|vrtc
modifier|*
name|vrtc
parameter_list|)
block|{
name|struct
name|clocktime
name|ct
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|rtcdev
modifier|*
name|rtc
decl_stmt|;
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
name|int
name|century
decl_stmt|,
name|error
decl_stmt|,
name|hour
decl_stmt|,
name|pm
decl_stmt|,
name|year
decl_stmt|;
name|KASSERT
argument_list|(
name|VRTC_LOCKED
argument_list|(
name|vrtc
argument_list|)
argument_list|,
operator|(
literal|"%s: vrtc not locked"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|vm
operator|=
name|vrtc
operator|->
name|vm
expr_stmt|;
name|rtc
operator|=
operator|&
name|vrtc
operator|->
name|rtcdev
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ct
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|clocktime
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|rtcget
argument_list|(
name|rtc
argument_list|,
name|rtc
operator|->
name|sec
argument_list|,
operator|&
name|ct
operator|.
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|ct
operator|.
name|sec
operator|<
literal|0
operator|||
name|ct
operator|.
name|sec
operator|>
literal|59
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vm
argument_list|,
literal|"Invalid RTC sec %#x/%d"
argument_list|,
name|rtc
operator|->
name|sec
argument_list|,
name|ct
operator|.
name|sec
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|rtcget
argument_list|(
name|rtc
argument_list|,
name|rtc
operator|->
name|min
argument_list|,
operator|&
name|ct
operator|.
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|ct
operator|.
name|min
operator|<
literal|0
operator|||
name|ct
operator|.
name|min
operator|>
literal|59
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vm
argument_list|,
literal|"Invalid RTC min %#x/%d"
argument_list|,
name|rtc
operator|->
name|min
argument_list|,
name|ct
operator|.
name|min
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|pm
operator|=
literal|0
expr_stmt|;
name|hour
operator|=
name|rtc
operator|->
name|hour
expr_stmt|;
if|if
condition|(
operator|(
name|rtc
operator|->
name|reg_b
operator|&
name|RTCSB_24HR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hour
operator|&
literal|0x80
condition|)
block|{
name|hour
operator|&=
operator|~
literal|0x80
expr_stmt|;
name|pm
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|error
operator|=
name|rtcget
argument_list|(
name|rtc
argument_list|,
name|hour
argument_list|,
operator|&
name|ct
operator|.
name|hour
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rtc
operator|->
name|reg_b
operator|&
name|RTCSB_24HR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ct
operator|.
name|hour
operator|>=
literal|1
operator|&&
name|ct
operator|.
name|hour
operator|<=
literal|12
condition|)
block|{
comment|/* 			 * Convert from 12-hour format to internal 24-hour 			 * representation as follows: 			 * 			 *    12-hour format		ct.hour 			 *	12	AM		0 			 *	1 - 11	AM		1 - 11 			 *	12	PM		12 			 *	1 - 11	PM		13 - 23 			 */
if|if
condition|(
name|ct
operator|.
name|hour
operator|==
literal|12
condition|)
name|ct
operator|.
name|hour
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pm
condition|)
name|ct
operator|.
name|hour
operator|+=
literal|12
expr_stmt|;
block|}
else|else
block|{
name|VM_CTR2
argument_list|(
name|vm
argument_list|,
literal|"Invalid RTC 12-hour format %#x/%d"
argument_list|,
name|rtc
operator|->
name|hour
argument_list|,
name|ct
operator|.
name|hour
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
name|error
operator|||
name|ct
operator|.
name|hour
operator|<
literal|0
operator|||
name|ct
operator|.
name|hour
operator|>
literal|23
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vm
argument_list|,
literal|"Invalid RTC hour %#x/%d"
argument_list|,
name|rtc
operator|->
name|hour
argument_list|,
name|ct
operator|.
name|hour
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Ignore 'rtc->dow' because some guests like Linux don't bother 	 * setting it at all while others like OpenBSD/i386 set it incorrectly.  	 * 	 * clock_ct_to_ts() does not depend on 'ct.dow' anyways so ignore it. 	 */
name|ct
operator|.
name|dow
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|rtcget
argument_list|(
name|rtc
argument_list|,
name|rtc
operator|->
name|day_of_month
argument_list|,
operator|&
name|ct
operator|.
name|day
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|ct
operator|.
name|day
operator|<
literal|1
operator|||
name|ct
operator|.
name|day
operator|>
literal|31
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vm
argument_list|,
literal|"Invalid RTC mday %#x/%d"
argument_list|,
name|rtc
operator|->
name|day_of_month
argument_list|,
name|ct
operator|.
name|day
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|rtcget
argument_list|(
name|rtc
argument_list|,
name|rtc
operator|->
name|month
argument_list|,
operator|&
name|ct
operator|.
name|mon
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|ct
operator|.
name|mon
operator|<
literal|1
operator|||
name|ct
operator|.
name|mon
operator|>
literal|12
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vm
argument_list|,
literal|"Invalid RTC month %#x/%d"
argument_list|,
name|rtc
operator|->
name|month
argument_list|,
name|ct
operator|.
name|mon
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|rtcget
argument_list|(
name|rtc
argument_list|,
name|rtc
operator|->
name|year
argument_list|,
operator|&
name|year
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|year
operator|<
literal|0
operator|||
name|year
operator|>
literal|99
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vm
argument_list|,
literal|"Invalid RTC year %#x/%d"
argument_list|,
name|rtc
operator|->
name|year
argument_list|,
name|year
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|rtcget
argument_list|(
name|rtc
argument_list|,
name|rtc
operator|->
name|century
argument_list|,
operator|&
name|century
argument_list|)
expr_stmt|;
name|ct
operator|.
name|year
operator|=
name|century
operator|*
literal|100
operator|+
name|year
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|ct
operator|.
name|year
operator|<
name|POSIX_BASE_YEAR
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vm
argument_list|,
literal|"Invalid RTC century %#x/%d"
argument_list|,
name|rtc
operator|->
name|century
argument_list|,
name|ct
operator|.
name|year
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|clock_ct_to_ts
argument_list|(
operator|&
name|ct
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|ts
operator|.
name|tv_sec
operator|<
literal|0
condition|)
block|{
name|VM_CTR3
argument_list|(
name|vm
argument_list|,
literal|"Invalid RTC clocktime.date %04d-%02d-%02d"
argument_list|,
name|ct
operator|.
name|year
argument_list|,
name|ct
operator|.
name|mon
argument_list|,
name|ct
operator|.
name|day
argument_list|)
expr_stmt|;
name|VM_CTR3
argument_list|(
name|vm
argument_list|,
literal|"Invalid RTC clocktime.time %02d:%02d:%02d"
argument_list|,
name|ct
operator|.
name|hour
argument_list|,
name|ct
operator|.
name|min
argument_list|,
name|ct
operator|.
name|sec
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
return|return
operator|(
name|ts
operator|.
name|tv_sec
operator|)
return|;
comment|/* success */
name|fail
label|:
comment|/* 	 * Stop updating the RTC if the date/time fields programmed by 	 * the guest are invalid. 	 */
name|VM_CTR0
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"Invalid RTC date/time programming detected"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VRTC_BROKEN_TIME
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vrtc_time_update
parameter_list|(
name|struct
name|vrtc
modifier|*
name|vrtc
parameter_list|,
name|time_t
name|newtime
parameter_list|)
block|{
name|struct
name|rtcdev
modifier|*
name|rtc
decl_stmt|;
name|time_t
name|oldtime
decl_stmt|;
name|uint8_t
name|alarm_sec
decl_stmt|,
name|alarm_min
decl_stmt|,
name|alarm_hour
decl_stmt|;
name|KASSERT
argument_list|(
name|VRTC_LOCKED
argument_list|(
name|vrtc
argument_list|)
argument_list|,
operator|(
literal|"%s: vrtc not locked"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|rtc
operator|=
operator|&
name|vrtc
operator|->
name|rtcdev
expr_stmt|;
name|alarm_sec
operator|=
name|rtc
operator|->
name|alarm_sec
expr_stmt|;
name|alarm_min
operator|=
name|rtc
operator|->
name|alarm_min
expr_stmt|;
name|alarm_hour
operator|=
name|rtc
operator|->
name|alarm_hour
expr_stmt|;
name|oldtime
operator|=
name|vrtc
operator|->
name|base_rtctime
expr_stmt|;
name|VM_CTR2
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"Updating RTC time from %#lx to %#lx"
argument_list|,
name|oldtime
argument_list|,
name|newtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtime
operator|==
name|oldtime
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If 'newtime' indicates that RTC updates are disabled then just 	 * record that and return. There is no need to do alarm interrupt 	 * processing or update 'base_uptime' in this case. 	 */
if|if
condition|(
name|newtime
operator|==
name|VRTC_BROKEN_TIME
condition|)
block|{
name|vrtc
operator|->
name|base_rtctime
operator|=
name|VRTC_BROKEN_TIME
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Return an error if RTC updates are halted by the guest. 	 */
if|if
condition|(
name|rtc_halted
argument_list|(
name|vrtc
argument_list|)
condition|)
block|{
name|VM_CTR0
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"RTC update halted by guest"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
do|do
block|{
comment|/* 		 * If the alarm interrupt is enabled and 'oldtime' is valid 		 * then visit all the seconds between 'oldtime' and 'newtime' 		 * to check for the alarm condition. 		 * 		 * Otherwise move the RTC time forward directly to 'newtime'. 		 */
if|if
condition|(
name|aintr_enabled
argument_list|(
name|vrtc
argument_list|)
operator|&&
name|oldtime
operator|!=
name|VRTC_BROKEN_TIME
condition|)
name|vrtc
operator|->
name|base_rtctime
operator|++
expr_stmt|;
else|else
name|vrtc
operator|->
name|base_rtctime
operator|=
name|newtime
expr_stmt|;
if|if
condition|(
name|aintr_enabled
argument_list|(
name|vrtc
argument_list|)
condition|)
block|{
comment|/* 			 * Update the RTC date/time fields before checking 			 * if the alarm conditions are satisfied. 			 */
name|secs_to_rtc
argument_list|(
name|vrtc
operator|->
name|base_rtctime
argument_list|,
name|vrtc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|alarm_sec
operator|>=
literal|0xC0
operator|||
name|alarm_sec
operator|==
name|rtc
operator|->
name|sec
operator|)
operator|&&
operator|(
name|alarm_min
operator|>=
literal|0xC0
operator|||
name|alarm_min
operator|==
name|rtc
operator|->
name|min
operator|)
operator|&&
operator|(
name|alarm_hour
operator|>=
literal|0xC0
operator|||
name|alarm_hour
operator|==
name|rtc
operator|->
name|hour
operator|)
condition|)
block|{
name|vrtc_set_reg_c
argument_list|(
name|vrtc
argument_list|,
name|rtc
operator|->
name|reg_c
operator||
name|RTCIR_ALARM
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|vrtc
operator|->
name|base_rtctime
operator|!=
name|newtime
condition|)
do|;
if|if
condition|(
name|uintr_enabled
argument_list|(
name|vrtc
argument_list|)
condition|)
name|vrtc_set_reg_c
argument_list|(
name|vrtc
argument_list|,
name|rtc
operator|->
name|reg_c
operator||
name|RTCIR_UPDATE
argument_list|)
expr_stmt|;
name|vrtc
operator|->
name|base_uptime
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|sbintime_t
name|vrtc_freq
parameter_list|(
name|struct
name|vrtc
modifier|*
name|vrtc
parameter_list|)
block|{
name|int
name|ratesel
decl_stmt|;
specifier|static
name|sbintime_t
name|pf
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
name|SBT_1S
operator|/
literal|256
block|,
name|SBT_1S
operator|/
literal|128
block|,
name|SBT_1S
operator|/
literal|8192
block|,
name|SBT_1S
operator|/
literal|4096
block|,
name|SBT_1S
operator|/
literal|2048
block|,
name|SBT_1S
operator|/
literal|1024
block|,
name|SBT_1S
operator|/
literal|512
block|,
name|SBT_1S
operator|/
literal|256
block|,
name|SBT_1S
operator|/
literal|128
block|,
name|SBT_1S
operator|/
literal|64
block|,
name|SBT_1S
operator|/
literal|32
block|,
name|SBT_1S
operator|/
literal|16
block|,
name|SBT_1S
operator|/
literal|8
block|,
name|SBT_1S
operator|/
literal|4
block|,
name|SBT_1S
operator|/
literal|2
block|, 	}
decl_stmt|;
name|KASSERT
argument_list|(
name|VRTC_LOCKED
argument_list|(
name|vrtc
argument_list|)
argument_list|,
operator|(
literal|"%s: vrtc not locked"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If both periodic and alarm interrupts are enabled then use the 	 * periodic frequency to drive the callout. The minimum periodic 	 * frequency (2 Hz) is higher than the alarm frequency (1 Hz) so 	 * piggyback the alarm on top of it. The same argument applies to 	 * the update interrupt. 	 */
if|if
condition|(
name|pintr_enabled
argument_list|(
name|vrtc
argument_list|)
operator|&&
name|divider_enabled
argument_list|(
name|vrtc
operator|->
name|rtcdev
operator|.
name|reg_a
argument_list|)
condition|)
block|{
name|ratesel
operator|=
name|vrtc
operator|->
name|rtcdev
operator|.
name|reg_a
operator|&
literal|0xf
expr_stmt|;
return|return
operator|(
name|pf
index|[
name|ratesel
index|]
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|aintr_enabled
argument_list|(
name|vrtc
argument_list|)
operator|&&
name|update_enabled
argument_list|(
name|vrtc
argument_list|)
condition|)
block|{
return|return
operator|(
name|SBT_1S
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|uintr_enabled
argument_list|(
name|vrtc
argument_list|)
operator|&&
name|update_enabled
argument_list|(
name|vrtc
argument_list|)
condition|)
block|{
return|return
operator|(
name|SBT_1S
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vrtc_callout_reset
parameter_list|(
name|struct
name|vrtc
modifier|*
name|vrtc
parameter_list|,
name|sbintime_t
name|freqsbt
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|VRTC_LOCKED
argument_list|(
name|vrtc
argument_list|)
argument_list|,
operator|(
literal|"%s: vrtc not locked"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|freqsbt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|callout_active
argument_list|(
operator|&
name|vrtc
operator|->
name|callout
argument_list|)
condition|)
block|{
name|VM_CTR0
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"RTC callout stopped"
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|vrtc
operator|->
name|callout
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|VM_CTR1
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"RTC callout frequency %d hz"
argument_list|,
name|SBT_1S
operator|/
name|freqsbt
argument_list|)
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|vrtc
operator|->
name|callout
argument_list|,
name|freqsbt
argument_list|,
literal|0
argument_list|,
name|vrtc_callout_handler
argument_list|,
name|vrtc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vrtc_callout_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vrtc
modifier|*
name|vrtc
init|=
name|arg
decl_stmt|;
name|sbintime_t
name|freqsbt
decl_stmt|;
name|time_t
name|rtctime
decl_stmt|;
name|int
name|error
decl_stmt|;
name|VM_CTR0
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"vrtc callout fired"
argument_list|)
expr_stmt|;
name|VRTC_LOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|vrtc
operator|->
name|callout
argument_list|)
condition|)
comment|/* callout was reset */
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|callout_active
argument_list|(
operator|&
name|vrtc
operator|->
name|callout
argument_list|)
condition|)
comment|/* callout was stopped */
goto|goto
name|done
goto|;
name|callout_deactivate
argument_list|(
operator|&
name|vrtc
operator|->
name|callout
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|vrtc
operator|->
name|rtcdev
operator|.
name|reg_b
operator|&
name|RTCSB_ALL_INTRS
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"gratuitous vrtc callout"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pintr_enabled
argument_list|(
name|vrtc
argument_list|)
condition|)
name|vrtc_set_reg_c
argument_list|(
name|vrtc
argument_list|,
name|vrtc
operator|->
name|rtcdev
operator|.
name|reg_c
operator||
name|RTCIR_PERIOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|aintr_enabled
argument_list|(
name|vrtc
argument_list|)
operator|||
name|uintr_enabled
argument_list|(
name|vrtc
argument_list|)
condition|)
block|{
name|rtctime
operator|=
name|vrtc_curtime
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
name|error
operator|=
name|vrtc_time_update
argument_list|(
name|vrtc
argument_list|,
name|rtctime
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: vrtc_time_update error %d"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
block|}
name|freqsbt
operator|=
name|vrtc_freq
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|freqsbt
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: vrtc frequency cannot be zero"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|vrtc_callout_reset
argument_list|(
name|vrtc
argument_list|,
name|freqsbt
argument_list|)
expr_stmt|;
name|done
label|:
name|VRTC_UNLOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|vrtc_callout_check
parameter_list|(
name|struct
name|vrtc
modifier|*
name|vrtc
parameter_list|,
name|sbintime_t
name|freq
parameter_list|)
block|{
name|int
name|active
decl_stmt|;
name|active
operator|=
name|callout_active
argument_list|(
operator|&
name|vrtc
operator|->
name|callout
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|freq
operator|==
literal|0
operator|&&
operator|!
name|active
operator|)
operator|||
operator|(
name|freq
operator|!=
literal|0
operator|&&
name|active
operator|)
argument_list|,
operator|(
literal|"vrtc callout %s with frequency %#lx"
operator|,
name|active
condition|?
literal|"active"
else|:
literal|"inactive"
operator|,
name|freq
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vrtc_set_reg_c
parameter_list|(
name|struct
name|vrtc
modifier|*
name|vrtc
parameter_list|,
name|uint8_t
name|newval
parameter_list|)
block|{
name|struct
name|rtcdev
modifier|*
name|rtc
decl_stmt|;
name|int
name|oldirqf
decl_stmt|,
name|newirqf
decl_stmt|;
name|uint8_t
name|oldval
decl_stmt|,
name|changed
decl_stmt|;
name|KASSERT
argument_list|(
name|VRTC_LOCKED
argument_list|(
name|vrtc
argument_list|)
argument_list|,
operator|(
literal|"%s: vrtc not locked"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|rtc
operator|=
operator|&
name|vrtc
operator|->
name|rtcdev
expr_stmt|;
name|newval
operator|&=
name|RTCIR_ALARM
operator||
name|RTCIR_PERIOD
operator||
name|RTCIR_UPDATE
expr_stmt|;
name|oldirqf
operator|=
name|rtc
operator|->
name|reg_c
operator|&
name|RTCIR_INT
expr_stmt|;
if|if
condition|(
operator|(
name|aintr_enabled
argument_list|(
name|vrtc
argument_list|)
operator|&&
operator|(
name|newval
operator|&
name|RTCIR_ALARM
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pintr_enabled
argument_list|(
name|vrtc
argument_list|)
operator|&&
operator|(
name|newval
operator|&
name|RTCIR_PERIOD
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|uintr_enabled
argument_list|(
name|vrtc
argument_list|)
operator|&&
operator|(
name|newval
operator|&
name|RTCIR_UPDATE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|newirqf
operator|=
name|RTCIR_INT
expr_stmt|;
block|}
else|else
block|{
name|newirqf
operator|=
literal|0
expr_stmt|;
block|}
name|oldval
operator|=
name|rtc
operator|->
name|reg_c
expr_stmt|;
name|rtc
operator|->
name|reg_c
operator|=
name|newirqf
operator||
name|newval
expr_stmt|;
name|changed
operator|=
name|oldval
operator|^
name|rtc
operator|->
name|reg_c
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"RTC reg_c changed from %#x to %#x"
argument_list|,
name|oldval
argument_list|,
name|rtc
operator|->
name|reg_c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|oldirqf
operator|&&
name|newirqf
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"RTC irq %d asserted"
argument_list|,
name|RTC_IRQ
argument_list|)
expr_stmt|;
name|vatpic_pulse_irq
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
name|RTC_IRQ
argument_list|)
expr_stmt|;
name|vioapic_pulse_irq
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
name|RTC_IRQ
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldirqf
operator|&&
operator|!
name|newirqf
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"RTC irq %d deasserted"
argument_list|,
name|RTC_IRQ
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vrtc_set_reg_b
parameter_list|(
name|struct
name|vrtc
modifier|*
name|vrtc
parameter_list|,
name|uint8_t
name|newval
parameter_list|)
block|{
name|struct
name|rtcdev
modifier|*
name|rtc
decl_stmt|;
name|sbintime_t
name|oldfreq
decl_stmt|,
name|newfreq
decl_stmt|;
name|time_t
name|curtime
decl_stmt|,
name|rtctime
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|oldval
decl_stmt|,
name|changed
decl_stmt|;
name|KASSERT
argument_list|(
name|VRTC_LOCKED
argument_list|(
name|vrtc
argument_list|)
argument_list|,
operator|(
literal|"%s: vrtc not locked"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|rtc
operator|=
operator|&
name|vrtc
operator|->
name|rtcdev
expr_stmt|;
name|oldval
operator|=
name|rtc
operator|->
name|reg_b
expr_stmt|;
name|oldfreq
operator|=
name|vrtc_freq
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
name|rtc
operator|->
name|reg_b
operator|=
name|newval
expr_stmt|;
name|changed
operator|=
name|oldval
operator|^
name|newval
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"RTC reg_b changed from %#x to %#x"
argument_list|,
name|oldval
argument_list|,
name|newval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
operator|&
name|RTCSB_HALT
condition|)
block|{
if|if
condition|(
operator|(
name|newval
operator|&
name|RTCSB_HALT
operator|)
operator|==
literal|0
condition|)
block|{
name|rtctime
operator|=
name|rtc_to_secs
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtctime
operator|==
name|VRTC_BROKEN_TIME
condition|)
block|{
if|if
condition|(
name|rtc_flag_broken_time
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|curtime
operator|=
name|vrtc_curtime
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|curtime
operator|==
name|vrtc
operator|->
name|base_rtctime
argument_list|,
operator|(
literal|"%s: mismatch "
literal|"between vrtc basetime (%#lx) and curtime (%#lx)"
operator|,
name|__func__
operator|,
name|vrtc
operator|->
name|base_rtctime
operator|,
name|curtime
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Force a refresh of the RTC date/time fields so 			 * they reflect the time right before the guest set 			 * the HALT bit. 			 */
name|secs_to_rtc
argument_list|(
name|curtime
argument_list|,
name|vrtc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * Updates are halted so mark 'base_rtctime' to denote 			 * that the RTC date/time is in flux. 			 */
name|rtctime
operator|=
name|VRTC_BROKEN_TIME
expr_stmt|;
name|rtc
operator|->
name|reg_b
operator|&=
operator|~
name|RTCSB_UINTR
expr_stmt|;
block|}
name|error
operator|=
name|vrtc_time_update
argument_list|(
name|vrtc
argument_list|,
name|rtctime
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"vrtc_time_update error %d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Side effect of changes to the interrupt enable bits. 	 */
if|if
condition|(
name|changed
operator|&
name|RTCSB_ALL_INTRS
condition|)
name|vrtc_set_reg_c
argument_list|(
name|vrtc
argument_list|,
name|vrtc
operator|->
name|rtcdev
operator|.
name|reg_c
argument_list|)
expr_stmt|;
comment|/* 	 * Change the callout frequency if it has changed. 	 */
name|newfreq
operator|=
name|vrtc_freq
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfreq
operator|!=
name|oldfreq
condition|)
name|vrtc_callout_reset
argument_list|(
name|vrtc
argument_list|,
name|newfreq
argument_list|)
expr_stmt|;
else|else
name|vrtc_callout_check
argument_list|(
name|vrtc
argument_list|,
name|newfreq
argument_list|)
expr_stmt|;
comment|/* 	 * The side effect of bits that control the RTC date/time format 	 * is handled lazily when those fields are actually read. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vrtc_set_reg_a
parameter_list|(
name|struct
name|vrtc
modifier|*
name|vrtc
parameter_list|,
name|uint8_t
name|newval
parameter_list|)
block|{
name|sbintime_t
name|oldfreq
decl_stmt|,
name|newfreq
decl_stmt|;
name|uint8_t
name|oldval
decl_stmt|,
name|changed
decl_stmt|;
name|KASSERT
argument_list|(
name|VRTC_LOCKED
argument_list|(
name|vrtc
argument_list|)
argument_list|,
operator|(
literal|"%s: vrtc not locked"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|newval
operator|&=
operator|~
name|RTCSA_TUP
expr_stmt|;
name|oldval
operator|=
name|vrtc
operator|->
name|rtcdev
operator|.
name|reg_a
expr_stmt|;
name|oldfreq
operator|=
name|vrtc_freq
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|divider_enabled
argument_list|(
name|oldval
argument_list|)
operator|&&
operator|!
name|divider_enabled
argument_list|(
name|newval
argument_list|)
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"RTC divider held in reset at %#lx/%#lx"
argument_list|,
name|vrtc
operator|->
name|base_rtctime
argument_list|,
name|vrtc
operator|->
name|base_uptime
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|divider_enabled
argument_list|(
name|oldval
argument_list|)
operator|&&
name|divider_enabled
argument_list|(
name|newval
argument_list|)
condition|)
block|{
comment|/* 		 * If the dividers are coming out of reset then update 		 * 'base_uptime' before this happens. This is done to 		 * maintain the illusion that the RTC date/time was frozen 		 * while the dividers were disabled. 		 */
name|vrtc
operator|->
name|base_uptime
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
name|VM_CTR2
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"RTC divider out of reset at %#lx/%#lx"
argument_list|,
name|vrtc
operator|->
name|base_rtctime
argument_list|,
name|vrtc
operator|->
name|base_uptime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* NOTHING */
block|}
name|vrtc
operator|->
name|rtcdev
operator|.
name|reg_a
operator|=
name|newval
expr_stmt|;
name|changed
operator|=
name|oldval
operator|^
name|newval
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"RTC reg_a changed from %#x to %#x"
argument_list|,
name|oldval
argument_list|,
name|newval
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Side effect of changes to rate select and divider enable bits. 	 */
name|newfreq
operator|=
name|vrtc_freq
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfreq
operator|!=
name|oldfreq
condition|)
name|vrtc_callout_reset
argument_list|(
name|vrtc
argument_list|,
name|newfreq
argument_list|)
expr_stmt|;
else|else
name|vrtc_callout_check
argument_list|(
name|vrtc
argument_list|,
name|newfreq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vrtc_set_time
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|time_t
name|secs
parameter_list|)
block|{
name|struct
name|vrtc
modifier|*
name|vrtc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vrtc
operator|=
name|vm_rtc
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|VRTC_LOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
name|error
operator|=
name|vrtc_time_update
argument_list|(
name|vrtc
argument_list|,
name|secs
argument_list|)
expr_stmt|;
name|VRTC_UNLOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VM_CTR2
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"Error %d setting RTC time to %#lx"
argument_list|,
name|error
argument_list|,
name|secs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VM_CTR1
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"RTC time set to %#lx"
argument_list|,
name|secs
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|time_t
name|vrtc_get_time
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|)
block|{
name|struct
name|vrtc
modifier|*
name|vrtc
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|vrtc
operator|=
name|vm_rtc
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|VRTC_LOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
name|t
operator|=
name|vrtc_curtime
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
name|VRTC_UNLOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vrtc_nvram_write
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|offset
parameter_list|,
name|uint8_t
name|value
parameter_list|)
block|{
name|struct
name|vrtc
modifier|*
name|vrtc
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
decl_stmt|;
name|vrtc
operator|=
name|vm_rtc
argument_list|(
name|vm
argument_list|)
expr_stmt|;
comment|/* 	 * Don't allow writes to RTC control registers or the date/time fields. 	 */
if|if
condition|(
name|offset
operator|<
name|offsetof
argument_list|(
expr|struct
name|rtcdev
argument_list|,
name|nvram
index|[
literal|0
index|]
argument_list|)
operator|||
name|offset
operator|==
name|RTC_CENTURY
operator|||
name|offset
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|rtcdev
argument_list|)
condition|)
block|{
name|VM_CTR1
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"RTC nvram write to invalid offset %d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|VRTC_LOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
operator|&
name|vrtc
operator|->
name|rtcdev
operator|)
expr_stmt|;
name|ptr
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
name|VM_CTR2
argument_list|(
name|vrtc
operator|->
name|vm
argument_list|,
literal|"RTC nvram write %#x to offset %#x"
argument_list|,
name|value
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|VRTC_UNLOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vrtc_nvram_read
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|retval
parameter_list|)
block|{
name|struct
name|vrtc
modifier|*
name|vrtc
decl_stmt|;
name|time_t
name|curtime
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
decl_stmt|;
comment|/* 	 * Allow all offsets in the RTC to be read. 	 */
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|rtcdev
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|vrtc
operator|=
name|vm_rtc
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|VRTC_LOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
comment|/* 	 * Update RTC date/time fields if necessary. 	 */
if|if
condition|(
name|offset
operator|<
literal|10
operator|||
name|offset
operator|==
name|RTC_CENTURY
condition|)
block|{
name|curtime
operator|=
name|vrtc_curtime
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
name|secs_to_rtc
argument_list|(
name|curtime
argument_list|,
name|vrtc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
operator|&
name|vrtc
operator|->
name|rtcdev
operator|)
expr_stmt|;
operator|*
name|retval
operator|=
name|ptr
index|[
name|offset
index|]
expr_stmt|;
name|VRTC_UNLOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vrtc_addr_handler
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|bool
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|vrtc
modifier|*
name|vrtc
decl_stmt|;
name|vrtc
operator|=
name|vm_rtc
argument_list|(
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|in
condition|)
block|{
operator|*
name|val
operator|=
literal|0xff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|VRTC_LOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
name|vrtc
operator|->
name|addr
operator|=
operator|*
name|val
operator|&
literal|0x7f
expr_stmt|;
name|VRTC_UNLOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vrtc_data_handler
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|bool
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|vrtc
modifier|*
name|vrtc
decl_stmt|;
name|struct
name|rtcdev
modifier|*
name|rtc
decl_stmt|;
name|time_t
name|curtime
decl_stmt|;
name|int
name|error
decl_stmt|,
name|offset
decl_stmt|;
name|vrtc
operator|=
name|vm_rtc
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|rtc
operator|=
operator|&
name|vrtc
operator|->
name|rtcdev
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|VRTC_LOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
name|offset
operator|=
name|vrtc
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|rtcdev
argument_list|)
condition|)
block|{
name|VRTC_UNLOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|curtime
operator|=
name|vrtc_curtime
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
name|vrtc_time_update
argument_list|(
name|vrtc
argument_list|,
name|curtime
argument_list|)
expr_stmt|;
comment|/* 	 * Update RTC date/time fields if necessary. 	 * 	 * This is not just for reads of the RTC. The side-effect of writing 	 * the century byte requires other RTC date/time fields (e.g. sec) 	 * to be updated here. 	 */
if|if
condition|(
name|offset
operator|<
literal|10
operator|||
name|offset
operator|==
name|RTC_CENTURY
condition|)
name|secs_to_rtc
argument_list|(
name|curtime
argument_list|,
name|vrtc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
condition|)
block|{
if|if
condition|(
name|offset
operator|==
literal|12
condition|)
block|{
comment|/* 			 * XXX 			 * reg_c interrupt flags are updated only if the 			 * corresponding interrupt enable bit in reg_b is set. 			 */
operator|*
name|val
operator|=
name|vrtc
operator|->
name|rtcdev
operator|.
name|reg_c
expr_stmt|;
name|vrtc_set_reg_c
argument_list|(
name|vrtc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|val
operator|=
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rtc
operator|+
name|offset
operator|)
expr_stmt|;
block|}
name|VCPU_CTR2
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
literal|"Read value %#x from RTC offset %#x"
argument_list|,
operator|*
name|val
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
literal|10
case|:
name|VCPU_CTR1
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
literal|"RTC reg_a set to %#x"
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
name|vrtc_set_reg_a
argument_list|(
name|vrtc
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|VCPU_CTR1
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
literal|"RTC reg_b set to %#x"
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
name|error
operator|=
name|vrtc_set_reg_b
argument_list|(
name|vrtc
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|VCPU_CTR1
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
literal|"RTC reg_c set to %#x (ignored)"
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|VCPU_CTR1
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
literal|"RTC reg_d set to %#x (ignored)"
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* 			 * High order bit of 'seconds' is readonly. 			 */
operator|*
name|val
operator|&=
literal|0x7f
expr_stmt|;
comment|/* FALLTHRU */
default|default:
name|VCPU_CTR2
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
literal|"RTC offset %#x set to %#x"
argument_list|,
name|offset
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rtc
operator|+
name|offset
operator|)
operator|=
operator|*
name|val
expr_stmt|;
break|break;
block|}
comment|/* 		 * XXX some guests (e.g. OpenBSD) write the century byte 		 * outside of RTCSB_HALT so re-calculate the RTC date/time. 		 */
if|if
condition|(
name|offset
operator|==
name|RTC_CENTURY
operator|&&
operator|!
name|rtc_halted
argument_list|(
name|vrtc
argument_list|)
condition|)
block|{
name|curtime
operator|=
name|rtc_to_secs
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
name|error
operator|=
name|vrtc_time_update
argument_list|(
name|vrtc
argument_list|,
name|curtime
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|error
argument_list|,
operator|(
literal|"vrtc_time_update error %d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curtime
operator|==
name|VRTC_BROKEN_TIME
operator|&&
name|rtc_flag_broken_time
condition|)
name|error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|VRTC_UNLOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vrtc_reset
parameter_list|(
name|struct
name|vrtc
modifier|*
name|vrtc
parameter_list|)
block|{
name|struct
name|rtcdev
modifier|*
name|rtc
decl_stmt|;
name|VRTC_LOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
name|rtc
operator|=
operator|&
name|vrtc
operator|->
name|rtcdev
expr_stmt|;
name|vrtc_set_reg_b
argument_list|(
name|vrtc
argument_list|,
name|rtc
operator|->
name|reg_b
operator|&
operator|~
operator|(
name|RTCSB_ALL_INTRS
operator||
name|RTCSB_SQWE
operator|)
argument_list|)
expr_stmt|;
name|vrtc_set_reg_c
argument_list|(
name|vrtc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|callout_active
argument_list|(
operator|&
name|vrtc
operator|->
name|callout
argument_list|)
argument_list|,
operator|(
literal|"rtc callout still active"
operator|)
argument_list|)
expr_stmt|;
name|VRTC_UNLOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|vrtc
modifier|*
name|vrtc_init
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|)
block|{
name|struct
name|vrtc
modifier|*
name|vrtc
decl_stmt|;
name|struct
name|rtcdev
modifier|*
name|rtc
decl_stmt|;
name|time_t
name|curtime
decl_stmt|;
name|vrtc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vrtc
argument_list|)
argument_list|,
name|M_VRTC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vrtc
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|vrtc
operator|->
name|mtx
argument_list|,
literal|"vrtc lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|vrtc
operator|->
name|callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Allow dividers to keep time but disable everything else */
name|rtc
operator|=
operator|&
name|vrtc
operator|->
name|rtcdev
expr_stmt|;
name|rtc
operator|->
name|reg_a
operator|=
literal|0x20
expr_stmt|;
name|rtc
operator|->
name|reg_b
operator|=
name|RTCSB_24HR
expr_stmt|;
name|rtc
operator|->
name|reg_c
operator|=
literal|0
expr_stmt|;
name|rtc
operator|->
name|reg_d
operator|=
name|RTCSD_PWR
expr_stmt|;
comment|/* Reset the index register to a safe value. */
name|vrtc
operator|->
name|addr
operator|=
name|RTC_STATUSD
expr_stmt|;
comment|/* 	 * Initialize RTC time to 00:00:00 Jan 1, 1970. 	 */
name|curtime
operator|=
literal|0
expr_stmt|;
name|VRTC_LOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
name|vrtc
operator|->
name|base_rtctime
operator|=
name|VRTC_BROKEN_TIME
expr_stmt|;
name|vrtc_time_update
argument_list|(
name|vrtc
argument_list|,
name|curtime
argument_list|)
expr_stmt|;
name|secs_to_rtc
argument_list|(
name|curtime
argument_list|,
name|vrtc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VRTC_UNLOCK
argument_list|(
name|vrtc
argument_list|)
expr_stmt|;
return|return
operator|(
name|vrtc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vrtc_cleanup
parameter_list|(
name|struct
name|vrtc
modifier|*
name|vrtc
parameter_list|)
block|{
name|callout_drain
argument_list|(
operator|&
name|vrtc
operator|->
name|callout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vrtc
argument_list|,
name|M_VRTC
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

