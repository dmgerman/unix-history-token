begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013, Anish Gupta (akgupt3@gmail.com)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm_dev.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm_instruction_emul.h>
end_include

begin_include
include|#
directive|include
file|<x86/apicreg.h>
end_include

begin_include
include|#
directive|include
file|"vmm_lapic.h"
end_include

begin_include
include|#
directive|include
file|"vmm_msr.h"
end_include

begin_include
include|#
directive|include
file|"vmm_stat.h"
end_include

begin_include
include|#
directive|include
file|"vmm_ktr.h"
end_include

begin_include
include|#
directive|include
file|"vmm_ioport.h"
end_include

begin_include
include|#
directive|include
file|"vatpic.h"
end_include

begin_include
include|#
directive|include
file|"vlapic.h"
end_include

begin_include
include|#
directive|include
file|"vlapic_priv.h"
end_include

begin_include
include|#
directive|include
file|"x86.h"
end_include

begin_include
include|#
directive|include
file|"vmcb.h"
end_include

begin_include
include|#
directive|include
file|"svm.h"
end_include

begin_include
include|#
directive|include
file|"svm_softc.h"
end_include

begin_include
include|#
directive|include
file|"npt.h"
end_include

begin_comment
comment|/*  * SVM CPUID function 0x8000_000A, edx bit decoding.  */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_NP
value|BIT(0)
end_define

begin_comment
comment|/* Nested paging or RVI */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_LBR
value|BIT(1)
end_define

begin_comment
comment|/* Last branch virtualization */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_SVML
value|BIT(2)
end_define

begin_comment
comment|/* SVM lock */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_NRIP_SAVE
value|BIT(3)
end_define

begin_comment
comment|/* Next RIP is saved */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_TSC_RATE
value|BIT(4)
end_define

begin_comment
comment|/* TSC rate control. */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_VMCB_CLEAN
value|BIT(5)
end_define

begin_comment
comment|/* VMCB state caching */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_FLUSH_BY_ASID
value|BIT(6)
end_define

begin_comment
comment|/* Flush by ASID */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_DECODE_ASSIST
value|BIT(7)
end_define

begin_comment
comment|/* Decode assist */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_PAUSE_INC
value|BIT(10)
end_define

begin_comment
comment|/* Pause intercept filter. */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_PAUSE_FTH
value|BIT(12)
end_define

begin_comment
comment|/* Pause filter threshold */
end_comment

begin_define
define|#
directive|define
name|VMCB_CACHE_DEFAULT
define|\
value|(VMCB_CACHE_ASID | VMCB_CACHE_IOPM | VMCB_CACHE_NP)
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_SVM
argument_list|,
literal|"svm"
argument_list|,
literal|"svm"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_SVM_VLAPIC
argument_list|,
literal|"svm-vlapic"
argument_list|,
literal|"svm-vlapic"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Per-CPU context area. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pcpu
name|__pcpu
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|svm_getdesc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|seg_desc
modifier|*
name|desc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|uint32_t
name|svm_feature
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AMD SVM features. */
end_comment

begin_comment
comment|/* Maximum ASIDs supported by the processor */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|nasid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current ASID generation for each host cpu */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|asid
name|asid
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * SVM host state saved area of size 4KB for each core.  */
end_comment

begin_function_decl
specifier|static
name|uint8_t
name|hsave
index|[
name|MAXCPU
index|]
index|[
name|PAGE_SIZE
index|]
name|__aligned
parameter_list|(
name|PAGE_SIZE
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * S/w saved host context.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|svm_regctx
name|host_ctx
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|VMM_STAT_AMD
argument_list|(
name|VCPU_EXITINTINFO
argument_list|,
literal|"Valid VMCB EXITINTINFO"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VMM_STAT_AMD
argument_list|(
name|VCPU_INTINFO_INJECTED
argument_list|,
literal|"VMM pending exception injected"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*   * Common function to enable or disabled SVM for a CPU.  */
end_comment

begin_function
specifier|static
name|int
name|cpu_svm_enable_disable
parameter_list|(
name|boolean_t
name|enable
parameter_list|)
block|{
name|uint64_t
name|efer_msr
decl_stmt|;
name|efer_msr
operator|=
name|rdmsr
argument_list|(
name|MSR_EFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|efer_msr
operator||=
name|EFER_SVM
expr_stmt|;
else|else
name|efer_msr
operator|&=
operator|~
name|EFER_SVM
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_EFER
argument_list|,
name|efer_msr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disable SVM on a CPU.  */
end_comment

begin_function
specifier|static
name|void
name|svm_disable
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
operator|(
name|void
operator|)
name|cpu_svm_enable_disable
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disable SVM for all CPUs.  */
end_comment

begin_function
specifier|static
name|int
name|svm_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|svm_disable
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for required BHyVe SVM features in a CPU.  */
end_comment

begin_function
specifier|static
name|int
name|svm_cpuid_features
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|regs
index|[
literal|4
index|]
decl_stmt|;
comment|/* CPUID Fn8000_000A is for SVM */
name|do_cpuid
argument_list|(
literal|0x8000000A
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|svm_feature
operator|=
name|regs
index|[
literal|3
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"SVM rev: 0x%x NASID:0x%x\n"
argument_list|,
name|regs
index|[
literal|0
index|]
operator|&
literal|0xFF
argument_list|,
name|regs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|nasid
operator|=
name|regs
index|[
literal|1
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|nasid
operator|>
literal|1
argument_list|,
operator|(
literal|"Insufficient ASIDs for guests: %#x"
operator|,
name|nasid
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SVM Features:0x%b\n"
argument_list|,
name|svm_feature
argument_list|,
literal|"\020"
literal|"\001NP"
comment|/* Nested paging */
literal|"\002LbrVirt"
comment|/* LBR virtualization */
literal|"\003SVML"
comment|/* SVM lock */
literal|"\004NRIPS"
comment|/* NRIP save */
literal|"\005TscRateMsr"
comment|/* MSR based TSC rate control */
literal|"\006VmcbClean"
comment|/* VMCB clean bits */
literal|"\007FlushByAsid"
comment|/* Flush by ASID */
literal|"\010DecodeAssist"
comment|/* Decode assist */
literal|"\011<b20>"
literal|"\012<b20>"
literal|"\013PauseFilter"
literal|"\014<b20>"
literal|"\015PauseFilterThreshold"
literal|"\016AVIC"
argument_list|)
expr_stmt|;
comment|/* SVM Lock */
if|if
condition|(
operator|!
operator|(
name|svm_feature
operator|&
name|AMD_CPUID_SVM_SVML
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"SVM is disabled by BIOS, please enable in BIOS.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * bhyve need RVI to work. 	 */
if|if
condition|(
operator|!
operator|(
name|svm_feature
operator|&
name|AMD_CPUID_SVM_NP
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Missing Nested paging or RVI SVM support in processor.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|svm_feature
operator|&
name|AMD_CPUID_SVM_NRIP_SAVE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|flush_by_asid
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|svm_feature
operator|&
name|AMD_CPUID_SVM_FLUSH_BY_ASID
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable SVM for a CPU.  */
end_comment

begin_function
specifier|static
name|void
name|svm_enable
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|uint64_t
name|hsave_pa
decl_stmt|;
operator|(
name|void
operator|)
name|cpu_svm_enable_disable
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|hsave_pa
operator|=
name|vtophys
argument_list|(
name|hsave
index|[
name|curcpu
index|]
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_VM_HSAVE_PA
argument_list|,
name|hsave_pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdmsr
argument_list|(
name|MSR_VM_HSAVE_PA
argument_list|)
operator|!=
name|hsave_pa
condition|)
block|{
name|panic
argument_list|(
literal|"VM_HSAVE_PA is wrong on CPU%d\n"
argument_list|,
name|curcpu
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check if a processor support SVM.  */
end_comment

begin_function
specifier|static
name|int
name|is_svm_enabled
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|msr
decl_stmt|;
comment|/* Section 15.4 Enabling SVM from APM2. */
if|if
condition|(
operator|(
name|amd_feature2
operator|&
name|AMDID2_SVM
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"SVM is not supported on this processor.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_VM_CR
argument_list|)
expr_stmt|;
comment|/* Make sure SVM is not disabled by BIOS. */
if|if
condition|(
operator|(
name|msr
operator|&
name|VM_CR_SVMDIS
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|svm_cpuid_features
argument_list|()
return|;
block|}
name|printf
argument_list|(
literal|"SVM disabled by Key, consult TPM/BIOS manual.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable SVM on CPU and initialize nested page table h/w.  */
end_comment

begin_function
specifier|static
name|int
name|svm_init
parameter_list|(
name|int
name|ipinum
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|cpu
decl_stmt|;
name|err
operator|=
name|is_svm_enabled
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|MAXCPU
condition|;
name|cpu
operator|++
control|)
block|{
comment|/* 		 * Initialize the host ASIDs to their "highest" valid values. 		 * 		 * The next ASID allocation will rollover both 'gen' and 'num' 		 * and start off the sequence at {1,1}. 		 */
name|asid
index|[
name|cpu
index|]
operator|.
name|gen
operator|=
operator|~
literal|0UL
expr_stmt|;
name|asid
index|[
name|cpu
index|]
operator|.
name|num
operator|=
name|nasid
operator|-
literal|1
expr_stmt|;
block|}
name|svm_npt_init
argument_list|(
name|ipinum
argument_list|)
expr_stmt|;
comment|/* Start SVM on all CPUs */
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|svm_enable
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_restore
parameter_list|(
name|void
parameter_list|)
block|{
name|svm_enable
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get index and bit position for a MSR in MSR permission  * bitmap. Two bits are used for each MSR, lower bit is  * for read and higher bit is for write.  */
end_comment

begin_function
specifier|static
name|int
name|svm_msr_index
parameter_list|(
name|uint64_t
name|msr
parameter_list|,
name|int
modifier|*
name|index
parameter_list|,
name|int
modifier|*
name|bit
parameter_list|)
block|{
name|uint32_t
name|base
decl_stmt|,
name|off
decl_stmt|;
comment|/* Pentium compatible MSRs */
define|#
directive|define
name|MSR_PENTIUM_START
value|0
define|#
directive|define
name|MSR_PENTIUM_END
value|0x1FFF
comment|/* AMD 6th generation and Intel compatible MSRs */
define|#
directive|define
name|MSR_AMD6TH_START
value|0xC0000000UL
define|#
directive|define
name|MSR_AMD6TH_END
value|0xC0001FFFUL
comment|/* AMD 7th and 8th generation compatible MSRs */
define|#
directive|define
name|MSR_AMD7TH_START
value|0xC0010000UL
define|#
directive|define
name|MSR_AMD7TH_END
value|0xC0011FFFUL
operator|*
name|index
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|bit
operator|=
operator|(
name|msr
operator|%
literal|4
operator|)
operator|*
literal|2
expr_stmt|;
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|msr
operator|>=
name|MSR_PENTIUM_START
operator|&&
name|msr
operator|<=
name|MSR_PENTIUM_END
condition|)
block|{
operator|*
name|index
operator|=
name|msr
operator|/
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|base
operator|+=
operator|(
name|MSR_PENTIUM_END
operator|-
name|MSR_PENTIUM_START
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|msr
operator|>=
name|MSR_AMD6TH_START
operator|&&
name|msr
operator|<=
name|MSR_AMD6TH_END
condition|)
block|{
name|off
operator|=
operator|(
name|msr
operator|-
name|MSR_AMD6TH_START
operator|)
expr_stmt|;
operator|*
name|index
operator|=
operator|(
name|off
operator|+
name|base
operator|)
operator|/
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|base
operator|+=
operator|(
name|MSR_AMD6TH_END
operator|-
name|MSR_AMD6TH_START
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|msr
operator|>=
name|MSR_AMD7TH_START
operator|&&
name|msr
operator|<=
name|MSR_AMD7TH_END
condition|)
block|{
name|off
operator|=
operator|(
name|msr
operator|-
name|MSR_AMD7TH_START
operator|)
expr_stmt|;
operator|*
name|index
operator|=
operator|(
name|off
operator|+
name|base
operator|)
operator|/
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give virtual cpu the complete access to MSR(read& write).  */
end_comment

begin_function
specifier|static
name|int
name|svm_msr_perm
parameter_list|(
name|uint8_t
modifier|*
name|perm_bitmap
parameter_list|,
name|uint64_t
name|msr
parameter_list|,
name|bool
name|read
parameter_list|,
name|bool
name|write
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|bit
decl_stmt|,
name|err
decl_stmt|;
name|err
operator|=
name|svm_msr_index
argument_list|(
name|msr
argument_list|,
operator|&
name|index
argument_list|,
operator|&
name|bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ERR
argument_list|(
literal|"MSR 0x%lx is not writeable by guest.\n"
argument_list|,
name|msr
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>
operator|(
name|SVM_MSR_BITMAP_SIZE
operator|)
condition|)
block|{
name|ERR
argument_list|(
literal|"MSR 0x%lx index out of range(%d).\n"
argument_list|,
name|msr
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|bit
operator|<
literal|0
operator|||
name|bit
operator|>
literal|8
condition|)
block|{
name|ERR
argument_list|(
literal|"MSR 0x%lx bit out of range(%d).\n"
argument_list|,
name|msr
argument_list|,
name|bit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Disable intercept for read and write. */
if|if
condition|(
name|read
condition|)
name|perm_bitmap
index|[
name|index
index|]
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
name|bit
operator|)
expr_stmt|;
if|if
condition|(
name|write
condition|)
name|perm_bitmap
index|[
name|index
index|]
operator|&=
operator|~
operator|(
literal|2UL
operator|<<
name|bit
operator|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_VMM
argument_list|,
literal|"Guest has control:0x%x on SVM:MSR(0x%lx).\n"
argument_list|,
operator|(
name|perm_bitmap
index|[
name|index
index|]
operator|>>
name|bit
operator|)
operator|&
literal|0x3
argument_list|,
name|msr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_msr_rw_ok
parameter_list|(
name|uint8_t
modifier|*
name|perm_bitmap
parameter_list|,
name|uint64_t
name|msr
parameter_list|)
block|{
return|return
name|svm_msr_perm
argument_list|(
name|perm_bitmap
argument_list|,
name|msr
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_msr_rd_ok
parameter_list|(
name|uint8_t
modifier|*
name|perm_bitmap
parameter_list|,
name|uint64_t
name|msr
parameter_list|)
block|{
return|return
name|svm_msr_perm
argument_list|(
name|perm_bitmap
argument_list|,
name|msr
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|vcpu_set_dirty
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|uint32_t
name|dirtybits
parameter_list|)
block|{
name|struct
name|svm_vcpu
modifier|*
name|vcpustate
decl_stmt|;
name|vcpustate
operator|=
name|svm_get_vcpu
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|vcpustate
operator|->
name|dirty
operator||=
name|dirtybits
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmcb_init
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|uint64_t
name|iopm_base_pa
parameter_list|,
name|uint64_t
name|msrpm_base_pa
parameter_list|,
name|uint64_t
name|np_pml4
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|uint16_t
name|cr_shadow
decl_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctrl
operator|->
name|iopm_base_pa
operator|=
name|iopm_base_pa
expr_stmt|;
name|ctrl
operator|->
name|msrpm_base_pa
operator|=
name|msrpm_base_pa
expr_stmt|;
comment|/* Enable nested paging */
name|ctrl
operator|->
name|np_enable
operator|=
literal|1
expr_stmt|;
name|ctrl
operator|->
name|n_cr3
operator|=
name|np_pml4
expr_stmt|;
comment|/* 	 * Intercept accesses to the control registers that are not shadowed 	 * in the VMCB - i.e. all except cr0, cr2, cr3, cr4 and cr8. 	 */
name|cr_shadow
operator|=
name|BIT
argument_list|(
literal|0
argument_list|)
operator||
name|BIT
argument_list|(
literal|2
argument_list|)
operator||
name|BIT
argument_list|(
literal|3
argument_list|)
operator||
name|BIT
argument_list|(
literal|4
argument_list|)
operator||
name|BIT
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|ctrl
operator|->
name|cr_write
operator|=
name|ctrl
operator|->
name|cr_read
operator|=
operator|~
name|cr_shadow
expr_stmt|;
comment|/* Intercept Machine Check exceptions. */
name|ctrl
operator|->
name|exception
operator|=
name|BIT
argument_list|(
name|IDT_MC
argument_list|)
expr_stmt|;
comment|/* Intercept various events (for e.g. I/O, MSR and CPUID accesses) */
name|ctrl
operator|->
name|ctrl1
operator|=
name|VMCB_INTCPT_IO
operator||
name|VMCB_INTCPT_MSR
operator||
name|VMCB_INTCPT_HLT
operator||
name|VMCB_INTCPT_CPUID
operator||
name|VMCB_INTCPT_INTR
operator||
name|VMCB_INTCPT_VINTR
operator||
name|VMCB_INTCPT_INIT
operator||
name|VMCB_INTCPT_NMI
operator||
name|VMCB_INTCPT_SMI
operator||
name|VMCB_INTCPT_FERR_FREEZE
operator||
name|VMCB_INTCPT_SHUTDOWN
expr_stmt|;
comment|/* 	 * From section "Canonicalization and Consistency Checks" in APMv2 	 * the VMRUN intercept bit must be set to pass the consistency check. 	 */
name|ctrl
operator|->
name|ctrl2
operator|=
name|VMCB_INTCPT_VMRUN
expr_stmt|;
comment|/* 	 * The ASID will be set to a non-zero value just before VMRUN. 	 */
name|ctrl
operator|->
name|asid
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Section 15.21.1, Interrupt Masking in EFLAGS 	 * Section 15.21.2, Virtualizing APIC.TPR 	 * 	 * This must be set for %rflag and %cr8 isolation of guest and host. 	 */
name|ctrl
operator|->
name|v_intr_masking
operator|=
literal|1
expr_stmt|;
comment|/* Enable Last Branch Record aka LBR for debugging */
name|ctrl
operator|->
name|lbr_virt_en
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|dbgctl
operator|=
name|BIT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* EFER_SVM must always be set when the guest is executing */
name|state
operator|->
name|efer
operator|=
name|EFER_SVM
expr_stmt|;
comment|/* Set up the PAT to power-on state */
name|state
operator|->
name|g_pat
operator|=
name|PAT_VALUE
argument_list|(
literal|0
argument_list|,
name|PAT_WRITE_BACK
argument_list|)
operator||
name|PAT_VALUE
argument_list|(
literal|1
argument_list|,
name|PAT_WRITE_THROUGH
argument_list|)
operator||
name|PAT_VALUE
argument_list|(
literal|2
argument_list|,
name|PAT_UNCACHED
argument_list|)
operator||
name|PAT_VALUE
argument_list|(
literal|3
argument_list|,
name|PAT_UNCACHEABLE
argument_list|)
operator||
name|PAT_VALUE
argument_list|(
literal|4
argument_list|,
name|PAT_WRITE_BACK
argument_list|)
operator||
name|PAT_VALUE
argument_list|(
literal|5
argument_list|,
name|PAT_WRITE_THROUGH
argument_list|)
operator||
name|PAT_VALUE
argument_list|(
literal|6
argument_list|,
name|PAT_UNCACHED
argument_list|)
operator||
name|PAT_VALUE
argument_list|(
literal|7
argument_list|,
name|PAT_UNCACHEABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialise a virtual machine.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|svm_vminit
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|pmap_t
name|pmap
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|svm_vcpu
modifier|*
name|vcpu
decl_stmt|;
name|vm_paddr_t
name|msrpm_pa
decl_stmt|,
name|iopm_pa
decl_stmt|,
name|pml4_pa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svm_sc
operator|=
operator|(
expr|struct
name|svm_softc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|svm_softc
argument_list|)
argument_list|,
name|M_SVM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|svm_sc
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|svm_sc
operator|->
name|svm_feature
operator|=
name|svm_feature
expr_stmt|;
name|svm_sc
operator|->
name|vcpu_cnt
operator|=
name|VM_MAXCPU
expr_stmt|;
name|svm_sc
operator|->
name|nptp
operator|=
operator|(
name|vm_offset_t
operator|)
name|vtophys
argument_list|(
name|pmap
operator|->
name|pm_pml4
argument_list|)
expr_stmt|;
comment|/* 	 * Intercept MSR access to all MSRs except GSBASE, FSBASE,... etc. 	 */
name|memset
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
literal|0xFF
argument_list|,
sizeof|sizeof
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Following MSR can be completely controlled by virtual machines 	 * since access to following are translated to access to VMCB. 	 */
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_GSBASE
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_FSBASE
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_KGSBASE
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_STAR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_LSTAR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_CSTAR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_SF_MASK
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_SYSENTER_CS_MSR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_SYSENTER_ESP_MSR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_SYSENTER_EIP_MSR
argument_list|)
expr_stmt|;
comment|/* For Nested Paging/RVI only. */
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_PAT
argument_list|)
expr_stmt|;
name|svm_msr_rd_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_TSC
argument_list|)
expr_stmt|;
name|svm_msr_rd_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_EFER
argument_list|)
expr_stmt|;
comment|/* Intercept access to all I/O ports. */
name|memset
argument_list|(
name|svm_sc
operator|->
name|iopm_bitmap
argument_list|,
literal|0xFF
argument_list|,
sizeof|sizeof
argument_list|(
name|svm_sc
operator|->
name|iopm_bitmap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cache physical address for multiple vcpus. */
name|iopm_pa
operator|=
name|vtophys
argument_list|(
name|svm_sc
operator|->
name|iopm_bitmap
argument_list|)
expr_stmt|;
name|msrpm_pa
operator|=
name|vtophys
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|)
expr_stmt|;
name|pml4_pa
operator|=
name|svm_sc
operator|->
name|nptp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
condition|;
name|i
operator|++
control|)
block|{
name|vcpu
operator|=
name|svm_get_vcpu
argument_list|(
name|svm_sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vcpu
operator|->
name|lastcpu
operator|=
name|NOCPU
expr_stmt|;
name|vcpu
operator|->
name|vmcb_pa
operator|=
name|vtophys
argument_list|(
operator|&
name|vcpu
operator|->
name|vmcb
argument_list|)
expr_stmt|;
name|vmcb_init
argument_list|(
name|svm_sc
argument_list|,
name|i
argument_list|,
name|iopm_pa
argument_list|,
name|msrpm_pa
argument_list|,
name|pml4_pa
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|svm_sc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_cpl
parameter_list|(
name|struct
name|vmcb_state
modifier|*
name|state
parameter_list|)
block|{
comment|/* 	 * From APMv2: 	 *   "Retrieve the CPL from the CPL field in the VMCB, not 	 *    from any segment DPL" 	 */
return|return
operator|(
name|state
operator|->
name|cpl
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|vm_cpu_mode
name|svm_vcpu_mode
parameter_list|(
name|struct
name|vmcb
modifier|*
name|vmcb
parameter_list|)
block|{
name|struct
name|vmcb_segment
modifier|*
name|seg
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|&
name|vmcb
operator|->
name|state
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|efer
operator|&
name|EFER_LMA
condition|)
block|{
name|seg
operator|=
name|vmcb_seg
argument_list|(
name|vmcb
argument_list|,
name|VM_REG_GUEST_CS
argument_list|)
expr_stmt|;
comment|/* 		 * Section 4.8.1 for APM2, check if Code Segment has 		 * Long attribute set in descriptor. 		 */
if|if
condition|(
name|seg
operator|->
name|attrib
operator|&
name|VMCB_CS_ATTRIB_L
condition|)
return|return
operator|(
name|CPU_MODE_64BIT
operator|)
return|;
else|else
return|return
operator|(
name|CPU_MODE_COMPATIBILITY
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|state
operator|->
name|cr0
operator|&
name|CR0_PE
condition|)
block|{
return|return
operator|(
name|CPU_MODE_PROTECTED
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|CPU_MODE_REAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|vm_paging_mode
name|svm_paging_mode
parameter_list|(
name|uint64_t
name|cr0
parameter_list|,
name|uint64_t
name|cr4
parameter_list|,
name|uint64_t
name|efer
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cr0
operator|&
name|CR0_PG
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|PAGING_MODE_FLAT
operator|)
return|;
if|if
condition|(
operator|(
name|cr4
operator|&
name|CR4_PAE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|PAGING_MODE_32
operator|)
return|;
if|if
condition|(
name|efer
operator|&
name|EFER_LME
condition|)
return|return
operator|(
name|PAGING_MODE_64
operator|)
return|;
else|else
return|return
operator|(
name|PAGING_MODE_PAE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ins/outs utility routines  */
end_comment

begin_function
specifier|static
name|uint64_t
name|svm_inout_str_index
parameter_list|(
name|struct
name|svm_regctx
modifier|*
name|regs
parameter_list|,
name|int
name|in
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|in
condition|?
name|regs
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rdi
else|:
name|regs
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rsi
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|svm_inout_str_count
parameter_list|(
name|struct
name|svm_regctx
modifier|*
name|regs
parameter_list|,
name|int
name|rep
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|rep
condition|?
name|regs
operator|->
name|sctx_rcx
else|:
literal|1
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_inout_str_seginfo
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int64_t
name|info1
parameter_list|,
name|int
name|in
parameter_list|,
name|struct
name|vm_inout_str
modifier|*
name|vis
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|in
condition|)
block|{
name|vis
operator|->
name|seg_name
operator|=
name|VM_REG_GUEST_ES
expr_stmt|;
block|}
else|else
block|{
comment|/* The segment field has standard encoding */
name|s
operator|=
operator|(
name|info1
operator|>>
literal|10
operator|)
operator|&
literal|0x7
expr_stmt|;
name|vis
operator|->
name|seg_name
operator|=
name|vm_segment_name
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|svm_getdesc
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|vis
operator|->
name|seg_name
argument_list|,
operator|&
name|vis
operator|->
name|seg_desc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: svm_getdesc error %d"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_inout_str_addrsize
parameter_list|(
name|uint64_t
name|info1
parameter_list|)
block|{
name|uint32_t
name|size
decl_stmt|;
name|size
operator|=
operator|(
name|info1
operator|>>
literal|7
operator|)
operator|&
literal|0x7
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
literal|2
operator|)
return|;
comment|/* 16 bit */
case|case
literal|2
case|:
return|return
operator|(
literal|4
operator|)
return|;
comment|/* 32 bit */
case|case
literal|4
case|:
return|return
operator|(
literal|8
operator|)
return|;
comment|/* 64 bit */
default|default:
name|panic
argument_list|(
literal|"%s: invalid size encoding %d"
argument_list|,
name|__func__
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|svm_paging_info
parameter_list|(
name|struct
name|vmcb
modifier|*
name|vmcb
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|)
block|{
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|&
name|vmcb
operator|->
name|state
expr_stmt|;
name|paging
operator|->
name|cr3
operator|=
name|state
operator|->
name|cr3
expr_stmt|;
name|paging
operator|->
name|cpl
operator|=
name|svm_cpl
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|paging
operator|->
name|cpu_mode
operator|=
name|svm_vcpu_mode
argument_list|(
name|vmcb
argument_list|)
expr_stmt|;
name|paging
operator|->
name|paging_mode
operator|=
name|svm_paging_mode
argument_list|(
name|state
operator|->
name|cr0
argument_list|,
name|state
operator|->
name|cr4
argument_list|,
name|state
operator|->
name|efer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle guest I/O intercept.  */
end_comment

begin_function
specifier|static
name|bool
name|svm_handle_io
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_exit
modifier|*
name|vmexit
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|struct
name|svm_regctx
modifier|*
name|regs
decl_stmt|;
name|struct
name|vm_inout_str
modifier|*
name|vis
decl_stmt|;
name|uint64_t
name|info1
decl_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|regs
operator|=
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|info1
operator|=
name|ctrl
operator|->
name|exitinfo1
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_INOUT
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|in
operator|=
operator|(
name|info1
operator|&
name|BIT
argument_list|(
literal|0
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|string
operator|=
operator|(
name|info1
operator|&
name|BIT
argument_list|(
literal|2
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|rep
operator|=
operator|(
name|info1
operator|&
name|BIT
argument_list|(
literal|3
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|bytes
operator|=
operator|(
name|info1
operator|>>
literal|4
operator|)
operator|&
literal|0x7
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|port
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|info1
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|eax
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|state
operator|->
name|rax
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|string
condition|)
block|{
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_INOUT_STR
expr_stmt|;
name|vis
operator|=
operator|&
name|vmexit
operator|->
name|u
operator|.
name|inout_str
expr_stmt|;
name|svm_paging_info
argument_list|(
name|svm_get_vmcb
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
operator|&
name|vis
operator|->
name|paging
argument_list|)
expr_stmt|;
name|vis
operator|->
name|rflags
operator|=
name|state
operator|->
name|rflags
expr_stmt|;
name|vis
operator|->
name|cr0
operator|=
name|state
operator|->
name|cr0
expr_stmt|;
name|vis
operator|->
name|index
operator|=
name|svm_inout_str_index
argument_list|(
name|regs
argument_list|,
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|in
argument_list|)
expr_stmt|;
name|vis
operator|->
name|count
operator|=
name|svm_inout_str_count
argument_list|(
name|regs
argument_list|,
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|rep
argument_list|)
expr_stmt|;
name|vis
operator|->
name|addrsize
operator|=
name|svm_inout_str_addrsize
argument_list|(
name|info1
argument_list|)
expr_stmt|;
name|svm_inout_str_seginfo
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|info1
argument_list|,
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|in
argument_list|,
name|vis
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_npf_paging
parameter_list|(
name|uint64_t
name|exitinfo1
parameter_list|)
block|{
if|if
condition|(
name|exitinfo1
operator|&
name|VMCB_NPF_INFO1_W
condition|)
return|return
operator|(
name|VM_PROT_WRITE
operator|)
return|;
return|return
operator|(
name|VM_PROT_READ
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|svm_npf_emul_fault
parameter_list|(
name|uint64_t
name|exitinfo1
parameter_list|)
block|{
if|if
condition|(
name|exitinfo1
operator|&
name|VMCB_NPF_INFO1_ID
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
name|exitinfo1
operator|&
name|VMCB_NPF_INFO1_GPT
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|exitinfo1
operator|&
name|VMCB_NPF_INFO1_GPA
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_handle_inst_emul
parameter_list|(
name|struct
name|vmcb
modifier|*
name|vmcb
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|struct
name|vm_exit
modifier|*
name|vmexit
parameter_list|)
block|{
name|struct
name|vm_guest_paging
modifier|*
name|paging
decl_stmt|;
name|struct
name|vmcb_segment
modifier|*
name|seg
decl_stmt|;
name|paging
operator|=
operator|&
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|paging
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_INST_EMUL
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|gpa
operator|=
name|gpa
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|gla
operator|=
name|VIE_INVALID_GLA
expr_stmt|;
name|svm_paging_info
argument_list|(
name|vmcb
argument_list|,
name|paging
argument_list|)
expr_stmt|;
comment|/* 	 * If DecodeAssist SVM feature doesn't exist, we don't have NPF  	 * instuction length. RIP will be calculated based on the length  	 * determined by instruction emulation. 	 */
name|vmexit
operator|->
name|inst_length
operator|=
name|VIE_INST_SIZE
expr_stmt|;
name|seg
operator|=
name|vmcb_seg
argument_list|(
name|vmcb
argument_list|,
name|VM_REG_GUEST_CS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|paging
operator|->
name|cpu_mode
condition|)
block|{
case|case
name|CPU_MODE_PROTECTED
case|:
case|case
name|CPU_MODE_COMPATIBILITY
case|:
comment|/* 		 * Section 4.8.1 of APM2, Default Operand Size or D bit. 		 */
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|cs_d
operator|=
operator|(
name|seg
operator|->
name|attrib
operator|&
name|VMCB_CS_ATTRIB_D
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
default|default:
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|cs_d
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Intercept access to MSR_EFER to prevent the guest from clearing the  * SVM enable bit.  */
end_comment

begin_function
specifier|static
name|void
name|svm_write_efer
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|uint32_t
name|edx
parameter_list|,
name|uint32_t
name|eax
parameter_list|)
block|{
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|uint64_t
name|oldval
decl_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|state
operator|->
name|efer
expr_stmt|;
name|state
operator|->
name|efer
operator|=
operator|(
name|uint64_t
operator|)
name|edx
operator|<<
literal|32
operator||
name|eax
operator||
name|EFER_SVM
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|efer
operator|!=
name|oldval
condition|)
block|{
name|VCPU_CTR2
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Guest EFER changed from %#lx to %#lx"
argument_list|,
name|oldval
argument_list|,
name|state
operator|->
name|efer
argument_list|)
expr_stmt|;
name|vcpu_set_dirty
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CACHE_CR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|intrtype_to_str
parameter_list|(
name|int
name|intr_type
parameter_list|)
block|{
switch|switch
condition|(
name|intr_type
condition|)
block|{
case|case
name|VMCB_EVENTINJ_TYPE_INTR
case|:
return|return
operator|(
literal|"hwintr"
operator|)
return|;
case|case
name|VMCB_EVENTINJ_TYPE_NMI
case|:
return|return
operator|(
literal|"nmi"
operator|)
return|;
case|case
name|VMCB_EVENTINJ_TYPE_INTn
case|:
return|return
operator|(
literal|"swintr"
operator|)
return|;
case|case
name|VMCB_EVENTINJ_TYPE_EXCEPTION
case|:
return|return
operator|(
literal|"exception"
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"%s: unknown intr_type %d"
argument_list|,
name|__func__
argument_list|,
name|intr_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Inject an event to vcpu as described in section 15.20, "Event injection".  */
end_comment

begin_function
specifier|static
name|void
name|svm_eventinject
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|intr_type
parameter_list|,
name|int
name|vector
parameter_list|,
name|uint32_t
name|error
parameter_list|,
name|bool
name|ec_valid
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ctrl
operator|->
name|eventinj
operator|&
name|VMCB_EVENTINJ_VALID
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: event already pending %#lx"
operator|,
name|__func__
operator|,
name|ctrl
operator|->
name|eventinj
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vector
operator|>=
literal|0
operator|&&
name|vector
operator|<=
literal|255
argument_list|,
operator|(
literal|"%s: invalid vector %d"
operator|,
name|__func__
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intr_type
condition|)
block|{
case|case
name|VMCB_EVENTINJ_TYPE_INTR
case|:
case|case
name|VMCB_EVENTINJ_TYPE_NMI
case|:
case|case
name|VMCB_EVENTINJ_TYPE_INTn
case|:
break|break;
case|case
name|VMCB_EVENTINJ_TYPE_EXCEPTION
case|:
if|if
condition|(
name|vector
operator|>=
literal|0
operator|&&
name|vector
operator|<=
literal|31
operator|&&
name|vector
operator|!=
literal|2
condition|)
break|break;
comment|/* FALLTHROUGH */
default|default:
name|panic
argument_list|(
literal|"%s: invalid intr_type/vector: %d/%d"
argument_list|,
name|__func__
argument_list|,
name|intr_type
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
name|ctrl
operator|->
name|eventinj
operator|=
name|vector
operator||
operator|(
name|intr_type
operator|<<
literal|8
operator|)
operator||
name|VMCB_EVENTINJ_VALID
expr_stmt|;
if|if
condition|(
name|ec_valid
condition|)
block|{
name|ctrl
operator|->
name|eventinj
operator||=
name|VMCB_EVENTINJ_EC_VALID
expr_stmt|;
name|ctrl
operator|->
name|eventinj
operator||=
operator|(
name|uint64_t
operator|)
name|error
operator|<<
literal|32
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Injecting %s at vector %d errcode %#x"
argument_list|,
name|intrtype_to_str
argument_list|(
name|intr_type
argument_list|)
argument_list|,
name|vector
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VCPU_CTR2
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Injecting %s at vector %d"
argument_list|,
name|intrtype_to_str
argument_list|(
name|intr_type
argument_list|)
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|svm_save_intinfo
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|uint64_t
name|intinfo
decl_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|intinfo
operator|=
name|ctrl
operator|->
name|exitintinfo
expr_stmt|;
if|if
condition|(
operator|!
name|VMCB_EXITINTINFO_VALID
argument_list|(
name|intinfo
argument_list|)
condition|)
return|return;
comment|/* 	 * From APMv2, Section "Intercepts during IDT interrupt delivery" 	 * 	 * If a #VMEXIT happened during event delivery then record the event 	 * that was being delivered. 	 */
name|VCPU_CTR2
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Pending INTINFO(0x%lx), vector=%d.\n"
argument_list|,
name|intinfo
argument_list|,
name|VMCB_EXITINTINFO_VECTOR
argument_list|(
name|intinfo
argument_list|)
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VCPU_EXITINTINFO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_exit_intinfo
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|intinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|exit_reason_to_str
parameter_list|(
name|uint64_t
name|reason
parameter_list|)
block|{
specifier|static
name|char
name|reasonbuf
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|VMCB_EXIT_INVALID
case|:
return|return
operator|(
literal|"invalvmcb"
operator|)
return|;
case|case
name|VMCB_EXIT_SHUTDOWN
case|:
return|return
operator|(
literal|"shutdown"
operator|)
return|;
case|case
name|VMCB_EXIT_NPF
case|:
return|return
operator|(
literal|"nptfault"
operator|)
return|;
case|case
name|VMCB_EXIT_PAUSE
case|:
return|return
operator|(
literal|"pause"
operator|)
return|;
case|case
name|VMCB_EXIT_HLT
case|:
return|return
operator|(
literal|"hlt"
operator|)
return|;
case|case
name|VMCB_EXIT_CPUID
case|:
return|return
operator|(
literal|"cpuid"
operator|)
return|;
case|case
name|VMCB_EXIT_IO
case|:
return|return
operator|(
literal|"inout"
operator|)
return|;
case|case
name|VMCB_EXIT_MC
case|:
return|return
operator|(
literal|"mchk"
operator|)
return|;
case|case
name|VMCB_EXIT_INTR
case|:
return|return
operator|(
literal|"extintr"
operator|)
return|;
case|case
name|VMCB_EXIT_VINTR
case|:
return|return
operator|(
literal|"vintr"
operator|)
return|;
case|case
name|VMCB_EXIT_MSR
case|:
return|return
operator|(
literal|"msr"
operator|)
return|;
default|default:
name|snprintf
argument_list|(
name|reasonbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|reasonbuf
argument_list|)
argument_list|,
literal|"%#lx"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
operator|(
name|reasonbuf
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KTR */
end_comment

begin_comment
comment|/*  * Determine the cause of virtual cpu exit and handle VMEXIT.  * Return: false - Break vcpu execution loop and handle vmexit  *		   in kernel or user space.  *	   true  - Continue vcpu run.  */
end_comment

begin_function
specifier|static
name|bool
name|svm_vmexit
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_exit
modifier|*
name|vmexit
parameter_list|)
block|{
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|svm_regctx
modifier|*
name|ctx
decl_stmt|;
name|uint64_t
name|code
decl_stmt|,
name|info1
decl_stmt|,
name|info2
decl_stmt|,
name|val
decl_stmt|;
name|uint32_t
name|eax
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|bool
name|update_rip
decl_stmt|,
name|loop
decl_stmt|,
name|retu
decl_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|code
operator|=
name|ctrl
operator|->
name|exitcode
expr_stmt|;
name|info1
operator|=
name|ctrl
operator|->
name|exitinfo1
expr_stmt|;
name|info2
operator|=
name|ctrl
operator|->
name|exitinfo2
expr_stmt|;
name|update_rip
operator|=
name|true
expr_stmt|;
name|loop
operator|=
name|true
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_VMX
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|vmx
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_COUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ctrl
operator|->
name|eventinj
operator|&
name|VMCB_EVENTINJ_VALID
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: event "
literal|"injection valid bit is set %#lx"
operator|,
name|__func__
operator|,
name|ctrl
operator|->
name|eventinj
operator|)
argument_list|)
expr_stmt|;
name|svm_save_intinfo
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|VMCB_EXIT_MC
case|:
comment|/* Machine Check. */
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_MTRAP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_MTRAP
expr_stmt|;
name|loop
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_MSR
case|:
comment|/* MSR access. */
name|eax
operator|=
name|state
operator|->
name|rax
expr_stmt|;
name|ecx
operator|=
name|ctx
operator|->
name|sctx_rcx
expr_stmt|;
name|edx
operator|=
name|ctx
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rdx
expr_stmt|;
if|if
condition|(
name|ecx
operator|==
name|MSR_EFER
condition|)
block|{
name|KASSERT
argument_list|(
name|info1
operator|!=
literal|0
argument_list|,
operator|(
literal|"rdmsr(MSR_EFER) is not "
literal|"emulated: info1(%#lx) info2(%#lx)"
operator|,
name|info1
operator|,
name|info2
operator|)
argument_list|)
expr_stmt|;
name|svm_write_efer
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|edx
argument_list|,
name|eax
argument_list|)
expr_stmt|;
break|break;
block|}
name|retu
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|info1
condition|)
block|{
comment|/* VM exited because of write MSR */
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_WRMSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_WRMSR
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|msr
operator|.
name|code
operator|=
name|ecx
expr_stmt|;
name|val
operator|=
operator|(
name|uint64_t
operator|)
name|edx
operator|<<
literal|32
operator||
name|eax
expr_stmt|;
if|if
condition|(
name|emulate_wrmsr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|ecx
argument_list|,
name|val
argument_list|,
operator|&
name|retu
argument_list|)
condition|)
block|{
name|vmexit
operator|->
name|u
operator|.
name|msr
operator|.
name|wval
operator|=
name|val
expr_stmt|;
name|loop
operator|=
name|false
expr_stmt|;
block|}
else|else
name|loop
operator|=
name|retu
condition|?
name|false
else|:
name|true
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"VMEXIT WRMSR(%s handling) 0x%lx @0x%x"
argument_list|,
name|loop
condition|?
literal|"kernel"
else|:
literal|"user"
argument_list|,
name|val
argument_list|,
name|ecx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_RDMSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_RDMSR
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|msr
operator|.
name|code
operator|=
name|ecx
expr_stmt|;
if|if
condition|(
name|emulate_rdmsr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|ecx
argument_list|,
operator|&
name|retu
argument_list|)
condition|)
block|{
name|loop
operator|=
name|false
expr_stmt|;
block|}
else|else
name|loop
operator|=
name|retu
condition|?
name|false
else|:
name|true
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:VMEXIT RDMSR"
literal|" MSB=0x%08x, LSB=%08x @0x%x"
argument_list|,
name|ctx
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rdx
argument_list|,
name|state
operator|->
name|rax
argument_list|,
name|ecx
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|MSR_AMDK8_IPM
value|0xc0010055
comment|/* 			 * We can't hide AMD C1E idle capability since its 			 * based on CPU generation, for now ignore access to 			 * this MSR by vcpus 			 * XXX: special handling of AMD C1E - Ignore. 			 */
if|if
condition|(
name|ecx
operator|==
name|MSR_AMDK8_IPM
condition|)
name|loop
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_INTR
case|:
comment|/* 			 * Exit on External Interrupt. 			 * Give host interrupt handler to run and if its guest 			 * interrupt, local APIC will inject event in guest. 			 */
name|update_rip
operator|=
name|false
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_EXTINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_IO
case|:
name|loop
operator|=
name|svm_handle_io
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|vmexit
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_INOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_CPUID
case|:
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_CPUID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|x86_emulate_cpuid
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|state
operator|->
name|rax
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|ctx
operator|->
name|sctx_rbx
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|ctx
operator|->
name|sctx_rcx
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|ctx
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rdx
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_HLT
case|:
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_HLT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_HLT
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|hlt
operator|.
name|rflags
operator|=
name|state
operator|->
name|rflags
expr_stmt|;
name|loop
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_PAUSE
case|:
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_PAUSE
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_PAUSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_NPF
case|:
name|loop
operator|=
name|false
expr_stmt|;
name|update_rip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|info1
operator|&
name|VMCB_NPF_INFO1_RSV
condition|)
block|{
name|VCPU_CTR2
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM_ERR:NPT"
literal|" reserved bit is set,"
literal|"INFO1:0x%lx INFO2:0x%lx .\n"
argument_list|,
name|info1
argument_list|,
name|info2
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* EXITINFO2 has the physical fault address (GPA). */
if|if
condition|(
name|vm_mem_allocated
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|info2
argument_list|)
condition|)
block|{
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_PAGING
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|paging
operator|.
name|gpa
operator|=
name|info2
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|paging
operator|.
name|fault_type
operator|=
name|svm_npf_paging
argument_list|(
name|info1
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_NESTED_FAULT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"nested page fault "
literal|"on gpa %#lx/%#lx at rip %#lx"
argument_list|,
name|info2
argument_list|,
name|info1
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svm_npf_emul_fault
argument_list|(
name|info1
argument_list|)
condition|)
block|{
name|svm_handle_inst_emul
argument_list|(
name|svm_get_vmcb
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
name|info2
argument_list|,
name|vmexit
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_INST_EMUL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"inst_emul fault "
literal|"for gpa %#lx/%#lx at rip %#lx"
argument_list|,
name|info2
argument_list|,
name|info1
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VMCB_EXIT_SHUTDOWN
case|:
name|loop
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_INVALID
case|:
name|loop
operator|=
name|false
expr_stmt|;
break|break;
default|default:
comment|/* Return to user space. */
name|loop
operator|=
name|false
expr_stmt|;
name|update_rip
operator|=
name|false
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"VMEXIT=0x%lx"
literal|" EXITINFO1: 0x%lx EXITINFO2:0x%lx\n"
argument_list|,
name|ctrl
operator|->
name|exitcode
argument_list|,
name|info1
argument_list|,
name|info2
argument_list|)
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:RIP: 0x%lx nRIP:0x%lx"
literal|" Inst decoder len:%d\n"
argument_list|,
name|state
operator|->
name|rip
argument_list|,
name|ctrl
operator|->
name|nrip
argument_list|,
name|ctrl
operator|->
name|inst_decode_size
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_UNKNOWN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|VCPU_CTR4
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"%s %s vmexit at %#lx nrip %#lx"
argument_list|,
name|loop
condition|?
literal|"handled"
else|:
literal|"unhandled"
argument_list|,
name|exit_reason_to_str
argument_list|(
name|code
argument_list|)
argument_list|,
name|state
operator|->
name|rip
argument_list|,
name|update_rip
condition|?
name|ctrl
operator|->
name|nrip
else|:
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|rip
operator|=
name|state
operator|->
name|rip
expr_stmt|;
if|if
condition|(
name|update_rip
condition|)
block|{
if|if
condition|(
name|ctrl
operator|->
name|nrip
operator|==
literal|0
condition|)
block|{
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM_ERR:nRIP is not set "
literal|"for RIP0x%lx.\n"
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_VMX
expr_stmt|;
block|}
else|else
name|vmexit
operator|->
name|rip
operator|=
name|ctrl
operator|->
name|nrip
expr_stmt|;
block|}
comment|/* If vcpu execution is continued, update RIP. */
if|if
condition|(
name|loop
condition|)
block|{
name|state
operator|->
name|rip
operator|=
name|vmexit
operator|->
name|rip
expr_stmt|;
block|}
return|return
operator|(
name|loop
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Inject NMI to virtual cpu.  */
end_comment

begin_function
specifier|static
name|int
name|svm_inject_nmi
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
comment|/* Can't inject another NMI if last one is pending.*/
if|if
condition|(
operator|!
name|vm_nmi_pending
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Inject NMI, vector number is not used.*/
name|svm_eventinject
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_EVENTINJ_TYPE_NMI
argument_list|,
name|IDT_NMI
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Acknowledge the request is accepted.*/
name|vm_nmi_clear
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Injected NMI.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_inj_intinfo
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|uint64_t
name|intinfo
decl_stmt|;
if|if
condition|(
operator|!
name|vm_entry_intinfo
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
operator|&
name|intinfo
argument_list|)
condition|)
return|return;
name|KASSERT
argument_list|(
name|VMCB_EXITINTINFO_VALID
argument_list|(
name|intinfo
argument_list|)
argument_list|,
operator|(
literal|"%s: entry intinfo is not "
literal|"valid: %#lx"
operator|,
name|__func__
operator|,
name|intinfo
operator|)
argument_list|)
expr_stmt|;
name|svm_eventinject
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_EXITINTINFO_TYPE
argument_list|(
name|intinfo
argument_list|)
argument_list|,
name|VMCB_EXITINTINFO_VECTOR
argument_list|(
name|intinfo
argument_list|)
argument_list|,
name|VMCB_EXITINTINFO_EC
argument_list|(
name|intinfo
argument_list|)
argument_list|,
name|VMCB_EXITINTINFO_EC_VALID
argument_list|(
name|intinfo
argument_list|)
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VCPU_INTINFO_INJECTED
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Injected entry intinfo: %#lx"
argument_list|,
name|intinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Inject event to virtual cpu.  */
end_comment

begin_function
specifier|static
name|void
name|svm_inj_interrupts
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|int
name|extint_pending
decl_stmt|;
name|int
name|vector
decl_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|svm_inj_intinfo
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
comment|/* Can't inject multiple events at once. */
if|if
condition|(
name|ctrl
operator|->
name|eventinj
operator|&
name|VMCB_EVENTINJ_VALID
condition|)
block|{
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Last event(0x%lx) is pending.\n"
argument_list|,
name|ctrl
operator|->
name|eventinj
argument_list|)
expr_stmt|;
return|return ;
block|}
comment|/* Wait for guest to come out of interrupt shadow. */
if|if
condition|(
name|ctrl
operator|->
name|intr_shadow
condition|)
block|{
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Guest in interrupt shadow.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* NMI event has priority over interrupts.*/
if|if
condition|(
name|svm_inject_nmi
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
condition|)
block|{
return|return;
block|}
name|extint_pending
operator|=
name|vm_extint_pending
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extint_pending
condition|)
block|{
comment|/* Ask the local apic for a vector to inject */
if|if
condition|(
operator|!
name|vlapic_pending_intr
argument_list|(
name|vlapic
argument_list|,
operator|&
name|vector
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
comment|/* Ask the legacy pic for a vector to inject */
name|vatpic_pending_intr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
operator|&
name|vector
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vector
operator|<
literal|32
operator|||
name|vector
operator|>
literal|255
condition|)
block|{
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM_ERR:Event injection"
literal|"invalid vector=%d.\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"SVM_ERR:Event injection invalid vector=%d.\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|state
operator|->
name|rflags
operator|&
name|PSL_I
operator|)
operator|==
literal|0
condition|)
block|{
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Interrupt is disabled\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|svm_eventinject
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_EVENTINJ_TYPE_INTR
argument_list|,
name|vector
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extint_pending
condition|)
block|{
comment|/* Update the Local APIC ISR */
name|vlapic_intr_accepted
argument_list|(
name|vlapic
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vm_extint_clear
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|vatpic_intr_accepted
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vector
argument_list|)
expr_stmt|;
comment|/* 		 * XXX need to recheck exting_pending ala VT-x 		 */
block|}
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:event injected,vector=%d.\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|restore_host_tss
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|system_segment_descriptor
modifier|*
name|tss_sd
decl_stmt|;
comment|/* 	 * The TSS descriptor was in use prior to launching the guest so it 	 * has been marked busy. 	 * 	 * 'ltr' requires the descriptor to be marked available so change the 	 * type to "64-bit available TSS". 	 */
name|tss_sd
operator|=
name|PCPU_GET
argument_list|(
name|tss
argument_list|)
expr_stmt|;
name|tss_sd
operator|->
name|sd_type
operator|=
name|SDT_SYSTSS
expr_stmt|;
name|ltr
argument_list|(
name|GSEL
argument_list|(
name|GPROC0_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_asid
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|u_int
name|thiscpu
parameter_list|)
block|{
name|struct
name|svm_vcpu
modifier|*
name|vcpustate
decl_stmt|;
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|long
name|eptgen
decl_stmt|;
name|bool
name|alloc_asid
decl_stmt|;
name|KASSERT
argument_list|(
name|CPU_ISSET
argument_list|(
name|thiscpu
argument_list|,
operator|&
name|pmap
operator|->
name|pm_active
argument_list|)
argument_list|,
operator|(
literal|"%s: nested pmap not "
literal|"active on cpu %u"
operator|,
name|__func__
operator|,
name|thiscpu
operator|)
argument_list|)
expr_stmt|;
name|vcpustate
operator|=
name|svm_get_vcpu
argument_list|(
name|sc
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|sc
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
comment|/* 	 * The TLB entries associated with the vcpu's ASID are not valid 	 * if either of the following conditions is true: 	 * 	 * 1. The vcpu's ASID generation is different than the host cpu's 	 *    ASID generation. This happens when the vcpu migrates to a new 	 *    host cpu. It can also happen when the number of vcpus executing 	 *    on a host cpu is greater than the number of ASIDs available. 	 * 	 * 2. The pmap generation number is different than the value cached in 	 *    the 'vcpustate'. This happens when the host invalidates pages 	 *    belonging to the guest. 	 * 	 *	asidgen		eptgen	      Action 	 *	mismatch	mismatch 	 *	   0		   0		(a) 	 *	   0		   1		(b1) or (b2) 	 *	   1		   0		(c) 	 *	   1		   1		(d) 	 * 	 * (a) There is no mismatch in eptgen or ASID generation and therefore 	 *     no further action is needed. 	 * 	 * (b1) If the cpu supports FlushByAsid then the vcpu's ASID is 	 *      retained and the TLB entries associated with this ASID 	 *      are flushed by VMRUN. 	 * 	 * (b2) If the cpu does not support FlushByAsid then a new ASID is 	 *      allocated. 	 * 	 * (c) A new ASID is allocated. 	 * 	 * (d) A new ASID is allocated. 	 */
name|alloc_asid
operator|=
name|false
expr_stmt|;
name|eptgen
operator|=
name|pmap
operator|->
name|pm_eptgen
expr_stmt|;
name|ctrl
operator|->
name|tlb_ctrl
operator|=
name|VMCB_TLB_FLUSH_NOTHING
expr_stmt|;
if|if
condition|(
name|vcpustate
operator|->
name|asid
operator|.
name|gen
operator|!=
name|asid
index|[
name|thiscpu
index|]
operator|.
name|gen
condition|)
block|{
name|alloc_asid
operator|=
name|true
expr_stmt|;
comment|/* (c) and (d) */
block|}
elseif|else
if|if
condition|(
name|vcpustate
operator|->
name|eptgen
operator|!=
name|eptgen
condition|)
block|{
if|if
condition|(
name|flush_by_asid
argument_list|()
condition|)
name|ctrl
operator|->
name|tlb_ctrl
operator|=
name|VMCB_TLB_FLUSH_GUEST
expr_stmt|;
comment|/* (b1) */
else|else
name|alloc_asid
operator|=
name|true
expr_stmt|;
comment|/* (b2) */
block|}
else|else
block|{
comment|/* 		 * This is the common case (a). 		 */
name|KASSERT
argument_list|(
operator|!
name|alloc_asid
argument_list|,
operator|(
literal|"ASID allocation not necessary"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ctrl
operator|->
name|tlb_ctrl
operator|==
name|VMCB_TLB_FLUSH_NOTHING
argument_list|,
operator|(
literal|"Invalid VMCB tlb_ctrl: %#x"
operator|,
name|ctrl
operator|->
name|tlb_ctrl
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alloc_asid
condition|)
block|{
if|if
condition|(
operator|++
name|asid
index|[
name|thiscpu
index|]
operator|.
name|num
operator|>=
name|nasid
condition|)
block|{
name|asid
index|[
name|thiscpu
index|]
operator|.
name|num
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|asid
index|[
name|thiscpu
index|]
operator|.
name|gen
operator|==
literal|0
condition|)
name|asid
index|[
name|thiscpu
index|]
operator|.
name|gen
operator|=
literal|1
expr_stmt|;
comment|/* 			 * If this cpu does not support "flush-by-asid" 			 * then flush the entire TLB on a generation 			 * bump. Subsequent ASID allocation in this 			 * generation can be done without a TLB flush. 			 */
if|if
condition|(
operator|!
name|flush_by_asid
argument_list|()
condition|)
name|ctrl
operator|->
name|tlb_ctrl
operator|=
name|VMCB_TLB_FLUSH_ALL
expr_stmt|;
block|}
name|vcpustate
operator|->
name|asid
operator|.
name|gen
operator|=
name|asid
index|[
name|thiscpu
index|]
operator|.
name|gen
expr_stmt|;
name|vcpustate
operator|->
name|asid
operator|.
name|num
operator|=
name|asid
index|[
name|thiscpu
index|]
operator|.
name|num
expr_stmt|;
name|ctrl
operator|->
name|asid
operator|=
name|vcpustate
operator|->
name|asid
operator|.
name|num
expr_stmt|;
name|vcpu_set_dirty
argument_list|(
name|sc
argument_list|,
name|vcpuid
argument_list|,
name|VMCB_CACHE_ASID
argument_list|)
expr_stmt|;
comment|/* 		 * If this cpu supports "flush-by-asid" then the TLB 		 * was not flushed after the generation bump. The TLB 		 * is flushed selectively after every new ASID allocation. 		 */
if|if
condition|(
name|flush_by_asid
argument_list|()
condition|)
name|ctrl
operator|->
name|tlb_ctrl
operator|=
name|VMCB_TLB_FLUSH_GUEST
expr_stmt|;
block|}
name|vcpustate
operator|->
name|eptgen
operator|=
name|eptgen
expr_stmt|;
name|KASSERT
argument_list|(
name|ctrl
operator|->
name|asid
operator|!=
literal|0
argument_list|,
operator|(
literal|"Guest ASID must be non-zero"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ctrl
operator|->
name|asid
operator|==
name|vcpustate
operator|->
name|asid
operator|.
name|num
argument_list|,
operator|(
literal|"ASID mismatch: %u/%u"
operator|,
name|ctrl
operator|->
name|asid
operator|,
name|vcpustate
operator|->
name|asid
operator|.
name|num
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start vcpu with specified RIP.  */
end_comment

begin_function
specifier|static
name|int
name|svm_vmrun
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|register_t
name|rip
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|void
modifier|*
name|rend_cookie
parameter_list|,
name|void
modifier|*
name|suspended_cookie
parameter_list|)
block|{
name|struct
name|svm_regctx
modifier|*
name|hctx
decl_stmt|,
modifier|*
name|gctx
decl_stmt|;
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|svm_vcpu
modifier|*
name|vcpustate
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|vm_exit
modifier|*
name|vmexit
decl_stmt|;
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
name|uint64_t
name|vmcb_pa
decl_stmt|;
name|u_int
name|thiscpu
decl_stmt|;
name|bool
name|loop
decl_stmt|;
comment|/* Continue vcpu execution loop. */
name|loop
operator|=
name|true
expr_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|vm
operator|=
name|svm_sc
operator|->
name|vm
expr_stmt|;
name|vcpustate
operator|=
name|svm_get_vcpu
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|vmexit
operator|=
name|vm_exitinfo
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|vlapic
operator|=
name|vm_lapic
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
comment|/* 	 * Stash 'curcpu' on the stack as 'thiscpu'. 	 * 	 * The per-cpu data area is not accessible until MSR_GSBASE is restored 	 * after the #VMEXIT. Since VMRUN is executed inside a critical section 	 * 'curcpu' and 'thiscpu' are guaranteed to identical. 	 */
name|thiscpu
operator|=
name|curcpu
expr_stmt|;
name|gctx
operator|=
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|hctx
operator|=
operator|&
name|host_ctx
index|[
name|thiscpu
index|]
expr_stmt|;
name|vmcb_pa
operator|=
name|svm_sc
operator|->
name|vcpu
index|[
name|vcpu
index|]
operator|.
name|vmcb_pa
expr_stmt|;
if|if
condition|(
name|vcpustate
operator|->
name|lastcpu
operator|!=
name|thiscpu
condition|)
block|{
comment|/* 		 * Force new ASID allocation by invalidating the generation. 		 */
name|vcpustate
operator|->
name|asid
operator|.
name|gen
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Invalidate the VMCB state cache by marking all fields dirty. 		 */
name|vcpu_set_dirty
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* 		 * XXX 		 * Setting 'vcpustate->lastcpu' here is bit premature because 		 * we may return from this function without actually executing 		 * the VMRUN  instruction. This could happen if a rendezvous 		 * or an AST is pending on the first time through the loop. 		 * 		 * This works for now but any new side-effects of vcpu 		 * migration should take this case into account. 		 */
name|vcpustate
operator|->
name|lastcpu
operator|=
name|thiscpu
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VCPU_MIGRATIONS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Update Guest RIP */
name|state
operator|->
name|rip
operator|=
name|rip
expr_stmt|;
do|do
block|{
name|vmexit
operator|->
name|inst_length
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Disable global interrupts to guarantee atomicity during 		 * loading of guest state. This includes not only the state 		 * loaded by the "vmrun" instruction but also software state 		 * maintained by the hypervisor: suspended and rendezvous 		 * state, NPT generation number, vlapic interrupts etc. 		 */
name|disable_gintr
argument_list|()
expr_stmt|;
if|if
condition|(
name|vcpu_suspended
argument_list|(
name|suspended_cookie
argument_list|)
condition|)
block|{
name|enable_gintr
argument_list|()
expr_stmt|;
name|vm_exit_suspended
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vcpu_rendezvous_pending
argument_list|(
name|rend_cookie
argument_list|)
condition|)
block|{
name|enable_gintr
argument_list|()
expr_stmt|;
name|vm_exit_rendezvous
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* We are asked to give the cpu by scheduler. */
if|if
condition|(
name|curthread
operator|->
name|td_flags
operator|&
operator|(
name|TDF_ASTPENDING
operator||
name|TDF_NEEDRESCHED
operator|)
condition|)
block|{
name|enable_gintr
argument_list|()
expr_stmt|;
name|vm_exit_astpending
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
break|break;
block|}
name|svm_inj_interrupts
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|vlapic
argument_list|)
expr_stmt|;
comment|/* Activate the nested pmap on 'thiscpu' */
name|CPU_SET_ATOMIC_ACQ
argument_list|(
name|thiscpu
argument_list|,
operator|&
name|pmap
operator|->
name|pm_active
argument_list|)
expr_stmt|;
comment|/* 		 * Check the pmap generation and the ASID generation to 		 * ensure that the vcpu does not use stale TLB mappings. 		 */
name|check_asid
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|pmap
argument_list|,
name|thiscpu
argument_list|)
expr_stmt|;
name|ctrl
operator|->
name|vmcb_clean
operator|=
name|VMCB_CACHE_DEFAULT
operator|&
operator|~
name|vcpustate
operator|->
name|dirty
expr_stmt|;
name|vcpustate
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"vmcb clean %#x"
argument_list|,
name|ctrl
operator|->
name|vmcb_clean
argument_list|)
expr_stmt|;
comment|/* Launch Virtual Machine. */
name|VCPU_CTR1
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Resume execution at %#lx"
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
name|svm_launch
argument_list|(
name|vmcb_pa
argument_list|,
name|gctx
argument_list|,
name|hctx
argument_list|)
expr_stmt|;
name|CPU_CLR_ATOMIC
argument_list|(
name|thiscpu
argument_list|,
operator|&
name|pmap
operator|->
name|pm_active
argument_list|)
expr_stmt|;
comment|/* 		 * Restore MSR_GSBASE to point to the pcpu data area. 		 * 		 * Note that accesses done via PCPU_GET/PCPU_SET will work 		 * only after MSR_GSBASE is restored. 		 * 		 * Also note that we don't bother restoring MSR_KGSBASE 		 * since it is not used in the kernel and will be restored 		 * when the VMRUN ioctl returns to userspace. 		 */
name|wrmsr
argument_list|(
name|MSR_GSBASE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|&
name|__pcpu
index|[
name|thiscpu
index|]
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|curcpu
operator|==
name|thiscpu
argument_list|,
operator|(
literal|"thiscpu/curcpu (%u/%u) mismatch"
operator|,
name|thiscpu
operator|,
name|curcpu
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * The host GDTR and IDTR is saved by VMRUN and restored 		 * automatically on #VMEXIT. However, the host TSS needs 		 * to be restored explicitly. 		 */
name|restore_host_tss
argument_list|()
expr_stmt|;
comment|/* #VMEXIT disables interrupts so re-enable them here. */
name|enable_gintr
argument_list|()
expr_stmt|;
comment|/* Handle #VMEXIT and if required return to user space. */
name|loop
operator|=
name|svm_vmexit
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|vmexit
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|loop
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cleanup for virtual machine.  */
end_comment

begin_function
specifier|static
name|void
name|svm_vmcleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
literal|0
argument_list|,
literal|"SVM:cleanup\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|svm_sc
argument_list|,
name|M_SVM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return pointer to hypervisor saved register state.  */
end_comment

begin_function
specifier|static
name|register_t
modifier|*
name|swctx_regptr
parameter_list|(
name|struct
name|svm_regctx
modifier|*
name|regctx
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|VM_REG_GUEST_RBX
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_rbx
operator|)
return|;
case|case
name|VM_REG_GUEST_RCX
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_rcx
operator|)
return|;
case|case
name|VM_REG_GUEST_RDX
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rdx
operator|)
return|;
case|case
name|VM_REG_GUEST_RDI
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rdi
operator|)
return|;
case|case
name|VM_REG_GUEST_RSI
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rsi
operator|)
return|;
case|case
name|VM_REG_GUEST_RBP
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_rbp
operator|)
return|;
case|case
name|VM_REG_GUEST_R8
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r8
operator|)
return|;
case|case
name|VM_REG_GUEST_R9
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r9
operator|)
return|;
case|case
name|VM_REG_GUEST_R10
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r10
operator|)
return|;
case|case
name|VM_REG_GUEST_R11
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r11
operator|)
return|;
case|case
name|VM_REG_GUEST_R12
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r12
operator|)
return|;
case|case
name|VM_REG_GUEST_R13
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r13
operator|)
return|;
case|case
name|VM_REG_GUEST_R14
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r14
operator|)
return|;
case|case
name|VM_REG_GUEST_R15
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r15
operator|)
return|;
default|default:
name|ERR
argument_list|(
literal|"Unknown register requested, reg=%d.\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interface to read guest registers.  * This can be SVM h/w saved or hypervisor saved register.  */
end_comment

begin_function
specifier|static
name|int
name|svm_getreg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|ident
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|vmcb
modifier|*
name|vmcb
decl_stmt|;
name|register_t
modifier|*
name|reg
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|vmcb
operator|=
name|svm_get_vmcb
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmcb_read
argument_list|(
name|vmcb
argument_list|,
name|ident
argument_list|,
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|reg
operator|=
name|swctx_regptr
argument_list|(
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
block|{
operator|*
name|val
operator|=
operator|*
name|reg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ERR
argument_list|(
literal|"SVM_ERR:reg type %x is not saved in VMCB.\n"
argument_list|,
name|ident
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interface to write to guest registers.  * This can be SVM h/w saved or hypervisor saved register.  */
end_comment

begin_function
specifier|static
name|int
name|svm_setreg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|ident
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|vmcb
modifier|*
name|vmcb
decl_stmt|;
name|register_t
modifier|*
name|reg
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|vmcb
operator|=
name|svm_get_vmcb
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmcb_write
argument_list|(
name|vmcb
argument_list|,
name|ident
argument_list|,
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|reg
operator|=
name|swctx_regptr
argument_list|(
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
block|{
operator|*
name|reg
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * XXX deal with CR3 and invalidate TLB entries tagged with the 	 * vcpu's ASID. This needs to be treated differently depending on 	 * whether 'running' is true/false. 	 */
name|ERR
argument_list|(
literal|"SVM_ERR:reg type %x is not saved in VMCB.\n"
argument_list|,
name|ident
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Inteface to set various descriptors.  */
end_comment

begin_function
specifier|static
name|int
name|svm_setdesc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|seg_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|vmcb
modifier|*
name|vmcb
decl_stmt|;
name|struct
name|vmcb_segment
modifier|*
name|seg
decl_stmt|;
name|uint16_t
name|attrib
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|vmcb
operator|=
name|svm_get_vmcb
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:set_desc: Type%d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|seg
operator|=
name|vmcb_seg
argument_list|(
name|vmcb
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|NULL
condition|)
block|{
name|ERR
argument_list|(
literal|"SVM_ERR:Unsupported segment type%d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Map seg_desc access to VMCB attribute format.*/
name|attrib
operator|=
operator|(
operator|(
name|desc
operator|->
name|access
operator|&
literal|0xF000
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
name|desc
operator|->
name|access
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:[sel %d attribute 0x%x limit:0x%x]\n"
argument_list|,
name|type
argument_list|,
name|desc
operator|->
name|access
argument_list|,
name|desc
operator|->
name|limit
argument_list|)
expr_stmt|;
name|seg
operator|->
name|attrib
operator|=
name|attrib
expr_stmt|;
name|seg
operator|->
name|base
operator|=
name|desc
operator|->
name|base
expr_stmt|;
name|seg
operator|->
name|limit
operator|=
name|desc
operator|->
name|limit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interface to get guest descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|svm_getdesc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|seg_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|vmcb_segment
modifier|*
name|seg
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:get_desc: Type%d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|seg
operator|=
name|vmcb_seg
argument_list|(
name|svm_get_vmcb
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seg
condition|)
block|{
name|ERR
argument_list|(
literal|"SVM_ERR:Unsupported segment type%d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Map seg_desc access to VMCB attribute format.*/
name|desc
operator|->
name|access
operator|=
operator|(
operator|(
name|seg
operator|->
name|attrib
operator|&
literal|0xF00
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|seg
operator|->
name|attrib
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|desc
operator|->
name|base
operator|=
name|seg
operator|->
name|base
expr_stmt|;
name|desc
operator|->
name|limit
operator|=
name|seg
operator|->
name|limit
expr_stmt|;
comment|/* 	 * VT-x uses bit 16 (Unusable) to indicate a segment that has been 	 * loaded with a NULL segment selector. The 'desc->access' field is 	 * interpreted in the VT-x format by the processor-independent code. 	 * 	 * SVM uses the 'P' bit to convey the same information so convert it 	 * into the VT-x format. For more details refer to section 	 * "Segment State in the VMCB" in APMv2. 	 */
if|if
condition|(
name|type
operator|==
name|VM_REG_GUEST_CS
operator|&&
name|type
operator|==
name|VM_REG_GUEST_TR
condition|)
name|desc
operator|->
name|access
operator||=
literal|0x80
expr_stmt|;
comment|/* CS and TS always present */
if|if
condition|(
operator|!
operator|(
name|desc
operator|->
name|access
operator|&
literal|0x80
operator|)
condition|)
name|desc
operator|->
name|access
operator||=
literal|0x10000
expr_stmt|;
comment|/* Unusable segment */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_setcap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|int
name|ret
init|=
name|ENOENT
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|VM_CAP_HALT_EXIT
case|:
if|if
condition|(
name|val
condition|)
name|ctrl
operator|->
name|ctrl1
operator||=
name|VMCB_INTCPT_HLT
expr_stmt|;
else|else
name|ctrl
operator|->
name|ctrl1
operator|&=
operator|~
name|VMCB_INTCPT_HLT
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Set_gap:Halt exit %s.\n"
argument_list|,
name|val
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_PAUSE_EXIT
case|:
if|if
condition|(
name|val
condition|)
name|ctrl
operator|->
name|ctrl1
operator||=
name|VMCB_INTCPT_PAUSE
expr_stmt|;
else|else
name|ctrl
operator|->
name|ctrl1
operator|&=
operator|~
name|VMCB_INTCPT_PAUSE
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Set_gap:Pause exit %s.\n"
argument_list|,
name|val
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_MTRAP_EXIT
case|:
if|if
condition|(
name|val
condition|)
name|ctrl
operator|->
name|exception
operator||=
name|BIT
argument_list|(
name|IDT_MC
argument_list|)
expr_stmt|;
else|else
name|ctrl
operator|->
name|exception
operator|&=
operator|~
name|BIT
argument_list|(
name|IDT_MC
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Set_gap:MC exit %s.\n"
argument_list|,
name|val
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_UNRESTRICTED_GUEST
case|:
comment|/* SVM doesn't need special capability for SMP.*/
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Set_gap:Unrestricted "
literal|"always enabled.\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_getcap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|VM_CAP_HALT_EXIT
case|:
operator|*
name|retval
operator|=
operator|(
name|ctrl
operator|->
name|ctrl1
operator|&
name|VMCB_INTCPT_HLT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:get_cap:Halt exit %s.\n"
argument_list|,
operator|*
name|retval
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_PAUSE_EXIT
case|:
operator|*
name|retval
operator|=
operator|(
name|ctrl
operator|->
name|ctrl1
operator|&
name|VMCB_INTCPT_PAUSE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:get_cap:Pause exit %s.\n"
argument_list|,
operator|*
name|retval
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_MTRAP_EXIT
case|:
operator|*
name|retval
operator|=
operator|(
name|ctrl
operator|->
name|exception
operator|&
name|BIT
argument_list|(
name|IDT_MC
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:get_cap:MC exit %s.\n"
argument_list|,
operator|*
name|retval
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_UNRESTRICTED_GUEST
case|:
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:get_cap:Unrestricted.\n"
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|vlapic
modifier|*
name|svm_vlapic_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpuid
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|vlapic
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vlapic
argument_list|)
argument_list|,
name|M_SVM_VLAPIC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|vm
operator|=
name|svm_sc
operator|->
name|vm
expr_stmt|;
name|vlapic
operator|->
name|vcpuid
operator|=
name|vcpuid
expr_stmt|;
name|vlapic
operator|->
name|apic_page
operator|=
operator|(
expr|struct
name|LAPIC
operator|*
operator|)
operator|&
name|svm_sc
operator|->
name|apic_page
index|[
name|vcpuid
index|]
expr_stmt|;
name|vlapic_init
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
return|return
operator|(
name|vlapic
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_vlapic_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|vlapic_cleanup
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vlapic
argument_list|,
name|M_SVM_VLAPIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|vmm_ops
name|vmm_ops_amd
init|=
block|{
name|svm_init
block|,
name|svm_cleanup
block|,
name|svm_restore
block|,
name|svm_vminit
block|,
name|svm_vmrun
block|,
name|svm_vmcleanup
block|,
name|svm_getreg
block|,
name|svm_setreg
block|,
name|svm_getdesc
block|,
name|svm_setdesc
block|,
name|svm_getcap
block|,
name|svm_setcap
block|,
name|svm_npt_alloc
block|,
name|svm_npt_free
block|,
name|svm_vlapic_init
block|,
name|svm_vlapic_cleanup
block|}
decl_stmt|;
end_decl_stmt

end_unit

