begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013, Anish Gupta (akgupt3@gmail.com)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm_dev.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm_instruction_emul.h>
end_include

begin_include
include|#
directive|include
file|"vmm_lapic.h"
end_include

begin_include
include|#
directive|include
file|"vmm_stat.h"
end_include

begin_include
include|#
directive|include
file|"vmm_ktr.h"
end_include

begin_include
include|#
directive|include
file|"vmm_ioport.h"
end_include

begin_include
include|#
directive|include
file|"vatpic.h"
end_include

begin_include
include|#
directive|include
file|"vlapic.h"
end_include

begin_include
include|#
directive|include
file|"vlapic_priv.h"
end_include

begin_include
include|#
directive|include
file|"x86.h"
end_include

begin_include
include|#
directive|include
file|"vmcb.h"
end_include

begin_include
include|#
directive|include
file|"svm.h"
end_include

begin_include
include|#
directive|include
file|"svm_softc.h"
end_include

begin_include
include|#
directive|include
file|"svm_msr.h"
end_include

begin_include
include|#
directive|include
file|"npt.h"
end_include

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_vmm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_vmm
argument_list|,
name|OID_AUTO
argument_list|,
name|svm
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * SVM CPUID function 0x8000_000A, edx bit decoding.  */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_NP
value|BIT(0)
end_define

begin_comment
comment|/* Nested paging or RVI */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_LBR
value|BIT(1)
end_define

begin_comment
comment|/* Last branch virtualization */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_SVML
value|BIT(2)
end_define

begin_comment
comment|/* SVM lock */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_NRIP_SAVE
value|BIT(3)
end_define

begin_comment
comment|/* Next RIP is saved */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_TSC_RATE
value|BIT(4)
end_define

begin_comment
comment|/* TSC rate control. */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_VMCB_CLEAN
value|BIT(5)
end_define

begin_comment
comment|/* VMCB state caching */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_FLUSH_BY_ASID
value|BIT(6)
end_define

begin_comment
comment|/* Flush by ASID */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_DECODE_ASSIST
value|BIT(7)
end_define

begin_comment
comment|/* Decode assist */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_PAUSE_INC
value|BIT(10)
end_define

begin_comment
comment|/* Pause intercept filter. */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_PAUSE_FTH
value|BIT(12)
end_define

begin_comment
comment|/* Pause filter threshold */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_AVIC
value|BIT(13)
end_define

begin_comment
comment|/* AVIC present */
end_comment

begin_define
define|#
directive|define
name|VMCB_CACHE_DEFAULT
value|(VMCB_CACHE_ASID 	|	\ 				VMCB_CACHE_IOPM		|	\ 				VMCB_CACHE_I		|	\ 				VMCB_CACHE_TPR		|	\ 				VMCB_CACHE_CR2		|	\ 				VMCB_CACHE_CR		|	\ 				VMCB_CACHE_DT		|	\ 				VMCB_CACHE_SEG		|	\ 				VMCB_CACHE_NP)
end_define

begin_decl_stmt
specifier|static
name|uint32_t
name|vmcb_clean
init|=
name|VMCB_CACHE_DEFAULT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_vmm_svm
argument_list|,
name|OID_AUTO
argument_list|,
name|vmcb_clean
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|vmcb_clean
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SVM
argument_list|,
literal|"svm"
argument_list|,
literal|"svm"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SVM_VLAPIC
argument_list|,
literal|"svm-vlapic"
argument_list|,
literal|"svm-vlapic"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Per-CPU context area. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pcpu
name|__pcpu
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|svm_feature
init|=
operator|~
literal|0U
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AMD SVM features. */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_vmm_svm
argument_list|,
name|OID_AUTO
argument_list|,
name|features
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|svm_feature
argument_list|,
literal|0
argument_list|,
literal|"SVM features advertised by CPUID.8000000AH:EDX"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|disable_npf_assist
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_vmm_svm
argument_list|,
name|OID_AUTO
argument_list|,
name|disable_npf_assist
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|disable_npf_assist
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Maximum ASIDs supported by the processor */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|nasid
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_vmm_svm
argument_list|,
name|OID_AUTO
argument_list|,
name|num_asids
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|nasid
argument_list|,
literal|0
argument_list|,
literal|"Number of ASIDs supported by this processor"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Current ASID generation for each host cpu */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|asid
name|asid
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * SVM host state saved area of size 4KB for each core.  */
end_comment

begin_function_decl
specifier|static
name|uint8_t
name|hsave
index|[
name|MAXCPU
index|]
index|[
name|PAGE_SIZE
index|]
name|__aligned
parameter_list|(
name|PAGE_SIZE
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|VMM_STAT_AMD
argument_list|(
name|VCPU_EXITINTINFO
argument_list|,
literal|"VM exits during event delivery"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VMM_STAT_AMD
argument_list|(
name|VCPU_INTINFO_INJECTED
argument_list|,
literal|"Events pending at VM entry"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VMM_STAT_AMD
argument_list|(
name|VMEXIT_VINTR
argument_list|,
literal|"VM exits due to interrupt window"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|svm_setreg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|ident
parameter_list|,
name|uint64_t
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|int
name|flush_by_asid
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|svm_feature
operator|&
name|AMD_CPUID_SVM_FLUSH_BY_ASID
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|decode_assist
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|svm_feature
operator|&
name|AMD_CPUID_SVM_DECODE_ASSIST
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_disable
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|uint64_t
name|efer
decl_stmt|;
name|efer
operator|=
name|rdmsr
argument_list|(
name|MSR_EFER
argument_list|)
expr_stmt|;
name|efer
operator|&=
operator|~
name|EFER_SVM
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_EFER
argument_list|,
name|efer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disable SVM on all CPUs.  */
end_comment

begin_function
specifier|static
name|int
name|svm_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|svm_disable
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that all the features required by bhyve are available.  */
end_comment

begin_function
specifier|static
name|int
name|check_svm_features
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|regs
index|[
literal|4
index|]
decl_stmt|;
comment|/* CPUID Fn8000_000A is for SVM */
name|do_cpuid
argument_list|(
literal|0x8000000A
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|svm_feature
operator|&=
name|regs
index|[
literal|3
index|]
expr_stmt|;
comment|/* 	 * The number of ASIDs can be configured to be less than what is 	 * supported by the hardware but not more. 	 */
if|if
condition|(
name|nasid
operator|==
literal|0
operator|||
name|nasid
operator|>
name|regs
index|[
literal|1
index|]
condition|)
name|nasid
operator|=
name|regs
index|[
literal|1
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|nasid
operator|>
literal|1
argument_list|,
operator|(
literal|"Insufficient ASIDs for guests: %#x"
operator|,
name|nasid
operator|)
argument_list|)
expr_stmt|;
comment|/* bhyve requires the Nested Paging feature */
if|if
condition|(
operator|!
operator|(
name|svm_feature
operator|&
name|AMD_CPUID_SVM_NP
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"SVM: Nested Paging feature not available.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* bhyve requires the NRIP Save feature */
if|if
condition|(
operator|!
operator|(
name|svm_feature
operator|&
name|AMD_CPUID_SVM_NRIP_SAVE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"SVM: NRIP Save feature not available.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_enable
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|uint64_t
name|efer
decl_stmt|;
name|efer
operator|=
name|rdmsr
argument_list|(
name|MSR_EFER
argument_list|)
expr_stmt|;
name|efer
operator||=
name|EFER_SVM
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_EFER
argument_list|,
name|efer
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_VM_HSAVE_PA
argument_list|,
name|vtophys
argument_list|(
name|hsave
index|[
name|curcpu
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return 1 if SVM is enabled on this processor and 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|svm_available
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|msr
decl_stmt|;
comment|/* Section 15.4 Enabling SVM from APM2. */
if|if
condition|(
operator|(
name|amd_feature2
operator|&
name|AMDID2_SVM
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"SVM: not available.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_VM_CR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msr
operator|&
name|VM_CR_SVMDIS
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"SVM: disabled by BIOS.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_init
parameter_list|(
name|int
name|ipinum
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|cpu
decl_stmt|;
if|if
condition|(
operator|!
name|svm_available
argument_list|()
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
name|check_svm_features
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vmcb_clean
operator|&=
name|VMCB_CACHE_DEFAULT
expr_stmt|;
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|MAXCPU
condition|;
name|cpu
operator|++
control|)
block|{
comment|/* 		 * Initialize the host ASIDs to their "highest" valid values. 		 * 		 * The next ASID allocation will rollover both 'gen' and 'num' 		 * and start off the sequence at {1,1}. 		 */
name|asid
index|[
name|cpu
index|]
operator|.
name|gen
operator|=
operator|~
literal|0UL
expr_stmt|;
name|asid
index|[
name|cpu
index|]
operator|.
name|num
operator|=
name|nasid
operator|-
literal|1
expr_stmt|;
block|}
name|svm_msr_init
argument_list|()
expr_stmt|;
name|svm_npt_init
argument_list|(
name|ipinum
argument_list|)
expr_stmt|;
comment|/* Enable SVM on all CPUs */
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|svm_enable
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_restore
parameter_list|(
name|void
parameter_list|)
block|{
name|svm_enable
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pentium compatible MSRs */
end_comment

begin_define
define|#
directive|define
name|MSR_PENTIUM_START
value|0
end_define

begin_define
define|#
directive|define
name|MSR_PENTIUM_END
value|0x1FFF
end_define

begin_comment
comment|/* AMD 6th generation and Intel compatible MSRs */
end_comment

begin_define
define|#
directive|define
name|MSR_AMD6TH_START
value|0xC0000000UL
end_define

begin_define
define|#
directive|define
name|MSR_AMD6TH_END
value|0xC0001FFFUL
end_define

begin_comment
comment|/* AMD 7th and 8th generation compatible MSRs */
end_comment

begin_define
define|#
directive|define
name|MSR_AMD7TH_START
value|0xC0010000UL
end_define

begin_define
define|#
directive|define
name|MSR_AMD7TH_END
value|0xC0011FFFUL
end_define

begin_comment
comment|/*  * Get the index and bit position for a MSR in permission bitmap.  * Two bits are used for each MSR: lower bit for read and higher bit for write.  */
end_comment

begin_function
specifier|static
name|int
name|svm_msr_index
parameter_list|(
name|uint64_t
name|msr
parameter_list|,
name|int
modifier|*
name|index
parameter_list|,
name|int
modifier|*
name|bit
parameter_list|)
block|{
name|uint32_t
name|base
decl_stmt|,
name|off
decl_stmt|;
operator|*
name|index
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|bit
operator|=
operator|(
name|msr
operator|%
literal|4
operator|)
operator|*
literal|2
expr_stmt|;
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|msr
operator|>=
name|MSR_PENTIUM_START
operator|&&
name|msr
operator|<=
name|MSR_PENTIUM_END
condition|)
block|{
operator|*
name|index
operator|=
name|msr
operator|/
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|base
operator|+=
operator|(
name|MSR_PENTIUM_END
operator|-
name|MSR_PENTIUM_START
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|msr
operator|>=
name|MSR_AMD6TH_START
operator|&&
name|msr
operator|<=
name|MSR_AMD6TH_END
condition|)
block|{
name|off
operator|=
operator|(
name|msr
operator|-
name|MSR_AMD6TH_START
operator|)
expr_stmt|;
operator|*
name|index
operator|=
operator|(
name|off
operator|+
name|base
operator|)
operator|/
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|base
operator|+=
operator|(
name|MSR_AMD6TH_END
operator|-
name|MSR_AMD6TH_START
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|msr
operator|>=
name|MSR_AMD7TH_START
operator|&&
name|msr
operator|<=
name|MSR_AMD7TH_END
condition|)
block|{
name|off
operator|=
operator|(
name|msr
operator|-
name|MSR_AMD7TH_START
operator|)
expr_stmt|;
operator|*
name|index
operator|=
operator|(
name|off
operator|+
name|base
operator|)
operator|/
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allow vcpu to read or write the 'msr' without trapping into the hypervisor.  */
end_comment

begin_function
specifier|static
name|void
name|svm_msr_perm
parameter_list|(
name|uint8_t
modifier|*
name|perm_bitmap
parameter_list|,
name|uint64_t
name|msr
parameter_list|,
name|bool
name|read
parameter_list|,
name|bool
name|write
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|bit
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
name|svm_msr_index
argument_list|(
name|msr
argument_list|,
operator|&
name|index
argument_list|,
operator|&
name|bit
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: invalid msr %#lx"
operator|,
name|__func__
operator|,
name|msr
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|SVM_MSR_BITMAP_SIZE
argument_list|,
operator|(
literal|"%s: invalid index %d for msr %#lx"
operator|,
name|__func__
operator|,
name|index
operator|,
name|msr
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bit
operator|>=
literal|0
operator|&&
name|bit
operator|<=
literal|6
argument_list|,
operator|(
literal|"%s: invalid bit position %d "
literal|"msr %#lx"
operator|,
name|__func__
operator|,
name|bit
operator|,
name|msr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
condition|)
name|perm_bitmap
index|[
name|index
index|]
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
name|bit
operator|)
expr_stmt|;
if|if
condition|(
name|write
condition|)
name|perm_bitmap
index|[
name|index
index|]
operator|&=
operator|~
operator|(
literal|2UL
operator|<<
name|bit
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_msr_rw_ok
parameter_list|(
name|uint8_t
modifier|*
name|perm_bitmap
parameter_list|,
name|uint64_t
name|msr
parameter_list|)
block|{
name|svm_msr_perm
argument_list|(
name|perm_bitmap
argument_list|,
name|msr
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_msr_rd_ok
parameter_list|(
name|uint8_t
modifier|*
name|perm_bitmap
parameter_list|,
name|uint64_t
name|msr
parameter_list|)
block|{
name|svm_msr_perm
argument_list|(
name|perm_bitmap
argument_list|,
name|msr
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|svm_get_intercept
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint32_t
name|bitmask
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|KASSERT
argument_list|(
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
literal|5
argument_list|,
operator|(
literal|"invalid intercept index %d"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctrl
operator|->
name|intercept
index|[
name|idx
index|]
operator|&
name|bitmask
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|svm_set_intercept
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint32_t
name|bitmask
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|uint32_t
name|oldval
decl_stmt|;
name|KASSERT
argument_list|(
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
literal|5
argument_list|,
operator|(
literal|"invalid intercept index %d"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|ctrl
operator|->
name|intercept
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|enabled
condition|)
name|ctrl
operator|->
name|intercept
index|[
name|idx
index|]
operator||=
name|bitmask
expr_stmt|;
else|else
name|ctrl
operator|->
name|intercept
index|[
name|idx
index|]
operator|&=
operator|~
name|bitmask
expr_stmt|;
if|if
condition|(
name|ctrl
operator|->
name|intercept
index|[
name|idx
index|]
operator|!=
name|oldval
condition|)
block|{
name|svm_set_dirty
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CACHE_I
argument_list|)
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"intercept[%d] modified "
literal|"from %#x to %#x"
argument_list|,
name|idx
argument_list|,
name|oldval
argument_list|,
name|ctrl
operator|->
name|intercept
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|svm_disable_intercept
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|off
parameter_list|,
name|uint32_t
name|bitmask
parameter_list|)
block|{
name|svm_set_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|off
argument_list|,
name|bitmask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|svm_enable_intercept
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|off
parameter_list|,
name|uint32_t
name|bitmask
parameter_list|)
block|{
name|svm_set_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|off
argument_list|,
name|bitmask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmcb_init
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|uint64_t
name|iopm_base_pa
parameter_list|,
name|uint64_t
name|msrpm_base_pa
parameter_list|,
name|uint64_t
name|np_pml4
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|int
name|n
decl_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctrl
operator|->
name|iopm_base_pa
operator|=
name|iopm_base_pa
expr_stmt|;
name|ctrl
operator|->
name|msrpm_base_pa
operator|=
name|msrpm_base_pa
expr_stmt|;
comment|/* Enable nested paging */
name|ctrl
operator|->
name|np_enable
operator|=
literal|1
expr_stmt|;
name|ctrl
operator|->
name|n_cr3
operator|=
name|np_pml4
expr_stmt|;
comment|/* 	 * Intercept accesses to the control registers that are not shadowed 	 * in the VMCB - i.e. all except cr0, cr2, cr3, cr4 and cr8. 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|16
condition|;
name|n
operator|++
control|)
block|{
name|mask
operator|=
operator|(
name|BIT
argument_list|(
name|n
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|BIT
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|n
operator|==
literal|2
operator|||
name|n
operator|==
literal|3
operator|||
name|n
operator|==
literal|4
operator|||
name|n
operator|==
literal|8
condition|)
name|svm_disable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CR_INTCPT
argument_list|,
name|mask
argument_list|)
expr_stmt|;
else|else
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CR_INTCPT
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Intercept everything when tracing guest exceptions otherwise 	 * just intercept machine check exception. 	 */
if|if
condition|(
name|vcpu_trace_exceptions
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|32
condition|;
name|n
operator|++
control|)
block|{
comment|/* 			 * Skip unimplemented vectors in the exception bitmap. 			 */
if|if
condition|(
name|n
operator|==
literal|2
operator|||
name|n
operator|==
literal|9
condition|)
block|{
continue|continue;
block|}
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_EXC_INTCPT
argument_list|,
name|BIT
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_EXC_INTCPT
argument_list|,
name|BIT
argument_list|(
name|IDT_MC
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Intercept various events (for e.g. I/O, MSR and CPUID accesses) */
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_IO
argument_list|)
expr_stmt|;
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_MSR
argument_list|)
expr_stmt|;
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_CPUID
argument_list|)
expr_stmt|;
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_INTR
argument_list|)
expr_stmt|;
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_INIT
argument_list|)
expr_stmt|;
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_NMI
argument_list|)
expr_stmt|;
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_SMI
argument_list|)
expr_stmt|;
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_SHUTDOWN
argument_list|)
expr_stmt|;
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_FERR_FREEZE
argument_list|)
expr_stmt|;
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL2_INTCPT
argument_list|,
name|VMCB_INTCPT_MONITOR
argument_list|)
expr_stmt|;
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL2_INTCPT
argument_list|,
name|VMCB_INTCPT_MWAIT
argument_list|)
expr_stmt|;
comment|/* 	 * From section "Canonicalization and Consistency Checks" in APMv2 	 * the VMRUN intercept bit must be set to pass the consistency check. 	 */
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL2_INTCPT
argument_list|,
name|VMCB_INTCPT_VMRUN
argument_list|)
expr_stmt|;
comment|/* 	 * The ASID will be set to a non-zero value just before VMRUN. 	 */
name|ctrl
operator|->
name|asid
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Section 15.21.1, Interrupt Masking in EFLAGS 	 * Section 15.21.2, Virtualizing APIC.TPR 	 * 	 * This must be set for %rflag and %cr8 isolation of guest and host. 	 */
name|ctrl
operator|->
name|v_intr_masking
operator|=
literal|1
expr_stmt|;
comment|/* Enable Last Branch Record aka LBR for debugging */
name|ctrl
operator|->
name|lbr_virt_en
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|dbgctl
operator|=
name|BIT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* EFER_SVM must always be set when the guest is executing */
name|state
operator|->
name|efer
operator|=
name|EFER_SVM
expr_stmt|;
comment|/* Set up the PAT to power-on state */
name|state
operator|->
name|g_pat
operator|=
name|PAT_VALUE
argument_list|(
literal|0
argument_list|,
name|PAT_WRITE_BACK
argument_list|)
operator||
name|PAT_VALUE
argument_list|(
literal|1
argument_list|,
name|PAT_WRITE_THROUGH
argument_list|)
operator||
name|PAT_VALUE
argument_list|(
literal|2
argument_list|,
name|PAT_UNCACHED
argument_list|)
operator||
name|PAT_VALUE
argument_list|(
literal|3
argument_list|,
name|PAT_UNCACHEABLE
argument_list|)
operator||
name|PAT_VALUE
argument_list|(
literal|4
argument_list|,
name|PAT_WRITE_BACK
argument_list|)
operator||
name|PAT_VALUE
argument_list|(
literal|5
argument_list|,
name|PAT_WRITE_THROUGH
argument_list|)
operator||
name|PAT_VALUE
argument_list|(
literal|6
argument_list|,
name|PAT_UNCACHED
argument_list|)
operator||
name|PAT_VALUE
argument_list|(
literal|7
argument_list|,
name|PAT_UNCACHEABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a virtual machine.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|svm_vminit
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|pmap_t
name|pmap
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|svm_vcpu
modifier|*
name|vcpu
decl_stmt|;
name|vm_paddr_t
name|msrpm_pa
decl_stmt|,
name|iopm_pa
decl_stmt|,
name|pml4_pa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svm_sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|svm_softc
argument_list|)
argument_list|,
name|M_SVM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|svm_sc
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|svm_sc
operator|->
name|nptp
operator|=
operator|(
name|vm_offset_t
operator|)
name|vtophys
argument_list|(
name|pmap
operator|->
name|pm_pml4
argument_list|)
expr_stmt|;
comment|/* 	 * Intercept read and write accesses to all MSRs. 	 */
name|memset
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
literal|0xFF
argument_list|,
sizeof|sizeof
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Access to the following MSRs is redirected to the VMCB when the 	 * guest is executing. Therefore it is safe to allow the guest to 	 * read/write these MSRs directly without hypervisor involvement. 	 */
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_GSBASE
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_FSBASE
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_KGSBASE
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_STAR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_LSTAR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_CSTAR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_SF_MASK
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_SYSENTER_CS_MSR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_SYSENTER_ESP_MSR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_SYSENTER_EIP_MSR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_PAT
argument_list|)
expr_stmt|;
name|svm_msr_rd_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_TSC
argument_list|)
expr_stmt|;
comment|/* 	 * Intercept writes to make sure that the EFER_SVM bit is not cleared. 	 */
name|svm_msr_rd_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_EFER
argument_list|)
expr_stmt|;
comment|/* Intercept access to all I/O ports. */
name|memset
argument_list|(
name|svm_sc
operator|->
name|iopm_bitmap
argument_list|,
literal|0xFF
argument_list|,
sizeof|sizeof
argument_list|(
name|svm_sc
operator|->
name|iopm_bitmap
argument_list|)
argument_list|)
expr_stmt|;
name|iopm_pa
operator|=
name|vtophys
argument_list|(
name|svm_sc
operator|->
name|iopm_bitmap
argument_list|)
expr_stmt|;
name|msrpm_pa
operator|=
name|vtophys
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|)
expr_stmt|;
name|pml4_pa
operator|=
name|svm_sc
operator|->
name|nptp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VM_MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|vcpu
operator|=
name|svm_get_vcpu
argument_list|(
name|svm_sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vcpu
operator|->
name|nextrip
operator|=
operator|~
literal|0
expr_stmt|;
name|vcpu
operator|->
name|lastcpu
operator|=
name|NOCPU
expr_stmt|;
name|vcpu
operator|->
name|vmcb_pa
operator|=
name|vtophys
argument_list|(
operator|&
name|vcpu
operator|->
name|vmcb
argument_list|)
expr_stmt|;
name|vmcb_init
argument_list|(
name|svm_sc
argument_list|,
name|i
argument_list|,
name|iopm_pa
argument_list|,
name|msrpm_pa
argument_list|,
name|pml4_pa
argument_list|)
expr_stmt|;
name|svm_msr_guest_init
argument_list|(
name|svm_sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|svm_sc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Collateral for a generic SVM VM-exit.  */
end_comment

begin_function
specifier|static
name|void
name|vm_exit_svm
parameter_list|(
name|struct
name|vm_exit
modifier|*
name|vme
parameter_list|,
name|uint64_t
name|code
parameter_list|,
name|uint64_t
name|info1
parameter_list|,
name|uint64_t
name|info2
parameter_list|)
block|{
name|vme
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_SVM
expr_stmt|;
name|vme
operator|->
name|u
operator|.
name|svm
operator|.
name|exitcode
operator|=
name|code
expr_stmt|;
name|vme
operator|->
name|u
operator|.
name|svm
operator|.
name|exitinfo1
operator|=
name|info1
expr_stmt|;
name|vme
operator|->
name|u
operator|.
name|svm
operator|.
name|exitinfo2
operator|=
name|info2
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_cpl
parameter_list|(
name|struct
name|vmcb_state
modifier|*
name|state
parameter_list|)
block|{
comment|/* 	 * From APMv2: 	 *   "Retrieve the CPL from the CPL field in the VMCB, not 	 *    from any segment DPL" 	 */
return|return
operator|(
name|state
operator|->
name|cpl
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|vm_cpu_mode
name|svm_vcpu_mode
parameter_list|(
name|struct
name|vmcb
modifier|*
name|vmcb
parameter_list|)
block|{
name|struct
name|vmcb_segment
name|seg
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|int
name|error
decl_stmt|;
name|state
operator|=
operator|&
name|vmcb
operator|->
name|state
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|efer
operator|&
name|EFER_LMA
condition|)
block|{
name|error
operator|=
name|vmcb_seg
argument_list|(
name|vmcb
argument_list|,
name|VM_REG_GUEST_CS
argument_list|,
operator|&
name|seg
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: vmcb_seg(cs) error %d"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Section 4.8.1 for APM2, check if Code Segment has 		 * Long attribute set in descriptor. 		 */
if|if
condition|(
name|seg
operator|.
name|attrib
operator|&
name|VMCB_CS_ATTRIB_L
condition|)
return|return
operator|(
name|CPU_MODE_64BIT
operator|)
return|;
else|else
return|return
operator|(
name|CPU_MODE_COMPATIBILITY
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|state
operator|->
name|cr0
operator|&
name|CR0_PE
condition|)
block|{
return|return
operator|(
name|CPU_MODE_PROTECTED
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|CPU_MODE_REAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|vm_paging_mode
name|svm_paging_mode
parameter_list|(
name|uint64_t
name|cr0
parameter_list|,
name|uint64_t
name|cr4
parameter_list|,
name|uint64_t
name|efer
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cr0
operator|&
name|CR0_PG
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|PAGING_MODE_FLAT
operator|)
return|;
if|if
condition|(
operator|(
name|cr4
operator|&
name|CR4_PAE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|PAGING_MODE_32
operator|)
return|;
if|if
condition|(
name|efer
operator|&
name|EFER_LME
condition|)
return|return
operator|(
name|PAGING_MODE_64
operator|)
return|;
else|else
return|return
operator|(
name|PAGING_MODE_PAE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ins/outs utility routines  */
end_comment

begin_function
specifier|static
name|uint64_t
name|svm_inout_str_index
parameter_list|(
name|struct
name|svm_regctx
modifier|*
name|regs
parameter_list|,
name|int
name|in
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|in
condition|?
name|regs
operator|->
name|sctx_rdi
else|:
name|regs
operator|->
name|sctx_rsi
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|svm_inout_str_count
parameter_list|(
name|struct
name|svm_regctx
modifier|*
name|regs
parameter_list|,
name|int
name|rep
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|rep
condition|?
name|regs
operator|->
name|sctx_rcx
else|:
literal|1
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_inout_str_seginfo
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int64_t
name|info1
parameter_list|,
name|int
name|in
parameter_list|,
name|struct
name|vm_inout_str
modifier|*
name|vis
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|in
condition|)
block|{
name|vis
operator|->
name|seg_name
operator|=
name|VM_REG_GUEST_ES
expr_stmt|;
block|}
else|else
block|{
comment|/* The segment field has standard encoding */
name|s
operator|=
operator|(
name|info1
operator|>>
literal|10
operator|)
operator|&
literal|0x7
expr_stmt|;
name|vis
operator|->
name|seg_name
operator|=
name|vm_segment_name
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|vmcb_getdesc
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|vis
operator|->
name|seg_name
argument_list|,
operator|&
name|vis
operator|->
name|seg_desc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: svm_getdesc error %d"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_inout_str_addrsize
parameter_list|(
name|uint64_t
name|info1
parameter_list|)
block|{
name|uint32_t
name|size
decl_stmt|;
name|size
operator|=
operator|(
name|info1
operator|>>
literal|7
operator|)
operator|&
literal|0x7
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
literal|2
operator|)
return|;
comment|/* 16 bit */
case|case
literal|2
case|:
return|return
operator|(
literal|4
operator|)
return|;
comment|/* 32 bit */
case|case
literal|4
case|:
return|return
operator|(
literal|8
operator|)
return|;
comment|/* 64 bit */
default|default:
name|panic
argument_list|(
literal|"%s: invalid size encoding %d"
argument_list|,
name|__func__
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|svm_paging_info
parameter_list|(
name|struct
name|vmcb
modifier|*
name|vmcb
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|)
block|{
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|&
name|vmcb
operator|->
name|state
expr_stmt|;
name|paging
operator|->
name|cr3
operator|=
name|state
operator|->
name|cr3
expr_stmt|;
name|paging
operator|->
name|cpl
operator|=
name|svm_cpl
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|paging
operator|->
name|cpu_mode
operator|=
name|svm_vcpu_mode
argument_list|(
name|vmcb
argument_list|)
expr_stmt|;
name|paging
operator|->
name|paging_mode
operator|=
name|svm_paging_mode
argument_list|(
name|state
operator|->
name|cr0
argument_list|,
name|state
operator|->
name|cr4
argument_list|,
name|state
operator|->
name|efer
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|UNHANDLED
value|0
end_define

begin_comment
comment|/*  * Handle guest I/O intercept.  */
end_comment

begin_function
specifier|static
name|int
name|svm_handle_io
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_exit
modifier|*
name|vmexit
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|struct
name|svm_regctx
modifier|*
name|regs
decl_stmt|;
name|struct
name|vm_inout_str
modifier|*
name|vis
decl_stmt|;
name|uint64_t
name|info1
decl_stmt|;
name|int
name|inout_string
decl_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|regs
operator|=
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|info1
operator|=
name|ctrl
operator|->
name|exitinfo1
expr_stmt|;
name|inout_string
operator|=
name|info1
operator|&
name|BIT
argument_list|(
literal|2
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 	 * The effective segment number in EXITINFO1[12:10] is populated 	 * only if the processor has the DecodeAssist capability. 	 * 	 * XXX this is not specified explicitly in APMv2 but can be verified 	 * empirically. 	 */
if|if
condition|(
name|inout_string
operator|&&
operator|!
name|decode_assist
argument_list|()
condition|)
return|return
operator|(
name|UNHANDLED
operator|)
return|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_INOUT
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|in
operator|=
operator|(
name|info1
operator|&
name|BIT
argument_list|(
literal|0
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|string
operator|=
name|inout_string
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|rep
operator|=
operator|(
name|info1
operator|&
name|BIT
argument_list|(
literal|3
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|bytes
operator|=
operator|(
name|info1
operator|>>
literal|4
operator|)
operator|&
literal|0x7
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|port
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|info1
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|eax
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|state
operator|->
name|rax
argument_list|)
expr_stmt|;
if|if
condition|(
name|inout_string
condition|)
block|{
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_INOUT_STR
expr_stmt|;
name|vis
operator|=
operator|&
name|vmexit
operator|->
name|u
operator|.
name|inout_str
expr_stmt|;
name|svm_paging_info
argument_list|(
name|svm_get_vmcb
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
operator|&
name|vis
operator|->
name|paging
argument_list|)
expr_stmt|;
name|vis
operator|->
name|rflags
operator|=
name|state
operator|->
name|rflags
expr_stmt|;
name|vis
operator|->
name|cr0
operator|=
name|state
operator|->
name|cr0
expr_stmt|;
name|vis
operator|->
name|index
operator|=
name|svm_inout_str_index
argument_list|(
name|regs
argument_list|,
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|in
argument_list|)
expr_stmt|;
name|vis
operator|->
name|count
operator|=
name|svm_inout_str_count
argument_list|(
name|regs
argument_list|,
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|rep
argument_list|)
expr_stmt|;
name|vis
operator|->
name|addrsize
operator|=
name|svm_inout_str_addrsize
argument_list|(
name|info1
argument_list|)
expr_stmt|;
name|svm_inout_str_seginfo
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|info1
argument_list|,
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|in
argument_list|,
name|vis
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|UNHANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|npf_fault_type
parameter_list|(
name|uint64_t
name|exitinfo1
parameter_list|)
block|{
if|if
condition|(
name|exitinfo1
operator|&
name|VMCB_NPF_INFO1_W
condition|)
return|return
operator|(
name|VM_PROT_WRITE
operator|)
return|;
elseif|else
if|if
condition|(
name|exitinfo1
operator|&
name|VMCB_NPF_INFO1_ID
condition|)
return|return
operator|(
name|VM_PROT_EXECUTE
operator|)
return|;
else|else
return|return
operator|(
name|VM_PROT_READ
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|svm_npf_emul_fault
parameter_list|(
name|uint64_t
name|exitinfo1
parameter_list|)
block|{
if|if
condition|(
name|exitinfo1
operator|&
name|VMCB_NPF_INFO1_ID
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
name|exitinfo1
operator|&
name|VMCB_NPF_INFO1_GPT
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|exitinfo1
operator|&
name|VMCB_NPF_INFO1_GPA
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_handle_inst_emul
parameter_list|(
name|struct
name|vmcb
modifier|*
name|vmcb
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|struct
name|vm_exit
modifier|*
name|vmexit
parameter_list|)
block|{
name|struct
name|vm_guest_paging
modifier|*
name|paging
decl_stmt|;
name|struct
name|vmcb_segment
name|seg
decl_stmt|;
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|char
modifier|*
name|inst_bytes
decl_stmt|;
name|int
name|error
decl_stmt|,
name|inst_len
decl_stmt|;
name|ctrl
operator|=
operator|&
name|vmcb
operator|->
name|ctrl
expr_stmt|;
name|paging
operator|=
operator|&
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|paging
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_INST_EMUL
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|gpa
operator|=
name|gpa
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|gla
operator|=
name|VIE_INVALID_GLA
expr_stmt|;
name|svm_paging_info
argument_list|(
name|vmcb
argument_list|,
name|paging
argument_list|)
expr_stmt|;
name|error
operator|=
name|vmcb_seg
argument_list|(
name|vmcb
argument_list|,
name|VM_REG_GUEST_CS
argument_list|,
operator|&
name|seg
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: vmcb_seg(CS) error %d"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|paging
operator|->
name|cpu_mode
condition|)
block|{
case|case
name|CPU_MODE_REAL
case|:
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|cs_base
operator|=
name|seg
operator|.
name|base
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|cs_d
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CPU_MODE_PROTECTED
case|:
case|case
name|CPU_MODE_COMPATIBILITY
case|:
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|cs_base
operator|=
name|seg
operator|.
name|base
expr_stmt|;
comment|/* 		 * Section 4.8.1 of APM2, Default Operand Size or D bit. 		 */
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|cs_d
operator|=
operator|(
name|seg
operator|.
name|attrib
operator|&
name|VMCB_CS_ATTRIB_D
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
default|default:
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|cs_base
operator|=
literal|0
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|cs_d
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 	 * Copy the instruction bytes into 'vie' if available. 	 */
if|if
condition|(
name|decode_assist
argument_list|()
operator|&&
operator|!
name|disable_npf_assist
condition|)
block|{
name|inst_len
operator|=
name|ctrl
operator|->
name|inst_len
expr_stmt|;
name|inst_bytes
operator|=
name|ctrl
operator|->
name|inst_bytes
expr_stmt|;
block|}
else|else
block|{
name|inst_len
operator|=
literal|0
expr_stmt|;
name|inst_bytes
operator|=
name|NULL
expr_stmt|;
block|}
name|vie_init
argument_list|(
operator|&
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|vie
argument_list|,
name|inst_bytes
argument_list|,
name|inst_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|intrtype_to_str
parameter_list|(
name|int
name|intr_type
parameter_list|)
block|{
switch|switch
condition|(
name|intr_type
condition|)
block|{
case|case
name|VMCB_EVENTINJ_TYPE_INTR
case|:
return|return
operator|(
literal|"hwintr"
operator|)
return|;
case|case
name|VMCB_EVENTINJ_TYPE_NMI
case|:
return|return
operator|(
literal|"nmi"
operator|)
return|;
case|case
name|VMCB_EVENTINJ_TYPE_INTn
case|:
return|return
operator|(
literal|"swintr"
operator|)
return|;
case|case
name|VMCB_EVENTINJ_TYPE_EXCEPTION
case|:
return|return
operator|(
literal|"exception"
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"%s: unknown intr_type %d"
argument_list|,
name|__func__
argument_list|,
name|intr_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Inject an event to vcpu as described in section 15.20, "Event injection".  */
end_comment

begin_function
specifier|static
name|void
name|svm_eventinject
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|intr_type
parameter_list|,
name|int
name|vector
parameter_list|,
name|uint32_t
name|error
parameter_list|,
name|bool
name|ec_valid
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ctrl
operator|->
name|eventinj
operator|&
name|VMCB_EVENTINJ_VALID
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: event already pending %#lx"
operator|,
name|__func__
operator|,
name|ctrl
operator|->
name|eventinj
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vector
operator|>=
literal|0
operator|&&
name|vector
operator|<=
literal|255
argument_list|,
operator|(
literal|"%s: invalid vector %d"
operator|,
name|__func__
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intr_type
condition|)
block|{
case|case
name|VMCB_EVENTINJ_TYPE_INTR
case|:
case|case
name|VMCB_EVENTINJ_TYPE_NMI
case|:
case|case
name|VMCB_EVENTINJ_TYPE_INTn
case|:
break|break;
case|case
name|VMCB_EVENTINJ_TYPE_EXCEPTION
case|:
if|if
condition|(
name|vector
operator|>=
literal|0
operator|&&
name|vector
operator|<=
literal|31
operator|&&
name|vector
operator|!=
literal|2
condition|)
break|break;
comment|/* FALLTHROUGH */
default|default:
name|panic
argument_list|(
literal|"%s: invalid intr_type/vector: %d/%d"
argument_list|,
name|__func__
argument_list|,
name|intr_type
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
name|ctrl
operator|->
name|eventinj
operator|=
name|vector
operator||
operator|(
name|intr_type
operator|<<
literal|8
operator|)
operator||
name|VMCB_EVENTINJ_VALID
expr_stmt|;
if|if
condition|(
name|ec_valid
condition|)
block|{
name|ctrl
operator|->
name|eventinj
operator||=
name|VMCB_EVENTINJ_EC_VALID
expr_stmt|;
name|ctrl
operator|->
name|eventinj
operator||=
operator|(
name|uint64_t
operator|)
name|error
operator|<<
literal|32
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Injecting %s at vector %d errcode %#x"
argument_list|,
name|intrtype_to_str
argument_list|(
name|intr_type
argument_list|)
argument_list|,
name|vector
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VCPU_CTR2
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Injecting %s at vector %d"
argument_list|,
name|intrtype_to_str
argument_list|(
name|intr_type
argument_list|)
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|svm_update_virqinfo
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|int
name|pending
decl_stmt|;
name|vm
operator|=
name|sc
operator|->
name|vm
expr_stmt|;
name|vlapic
operator|=
name|vm_lapic
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
comment|/* Update %cr8 in the emulated vlapic */
name|vlapic_set_cr8
argument_list|(
name|vlapic
argument_list|,
name|ctrl
operator|->
name|v_tpr
argument_list|)
expr_stmt|;
comment|/* 	 * If V_IRQ indicates that the interrupt injection attempted on then 	 * last VMRUN was successful then update the vlapic accordingly. 	 */
if|if
condition|(
name|ctrl
operator|->
name|v_intr_vector
operator|!=
literal|0
condition|)
block|{
name|pending
operator|=
name|ctrl
operator|->
name|v_irq
expr_stmt|;
name|KASSERT
argument_list|(
name|ctrl
operator|->
name|v_intr_vector
operator|>=
literal|16
argument_list|,
operator|(
literal|"%s: invalid "
literal|"v_intr_vector %d"
operator|,
name|__func__
operator|,
name|ctrl
operator|->
name|v_intr_vector
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|ctrl
operator|->
name|v_ign_tpr
argument_list|,
operator|(
literal|"%s: invalid v_ign_tpr"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|VCPU_CTR2
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"v_intr_vector %d %s"
argument_list|,
name|ctrl
operator|->
name|v_intr_vector
argument_list|,
name|pending
condition|?
literal|"pending"
else|:
literal|"accepted"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pending
condition|)
name|vlapic_intr_accepted
argument_list|(
name|vlapic
argument_list|,
name|ctrl
operator|->
name|v_intr_vector
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|svm_save_intinfo
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|uint64_t
name|intinfo
decl_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|intinfo
operator|=
name|ctrl
operator|->
name|exitintinfo
expr_stmt|;
if|if
condition|(
operator|!
name|VMCB_EXITINTINFO_VALID
argument_list|(
name|intinfo
argument_list|)
condition|)
return|return;
comment|/* 	 * From APMv2, Section "Intercepts during IDT interrupt delivery" 	 * 	 * If a #VMEXIT happened during event delivery then record the event 	 * that was being delivered. 	 */
name|VCPU_CTR2
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Pending INTINFO(0x%lx), vector=%d.\n"
argument_list|,
name|intinfo
argument_list|,
name|VMCB_EXITINTINFO_VECTOR
argument_list|(
name|intinfo
argument_list|)
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VCPU_EXITINTINFO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_exit_intinfo
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|intinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|vintr_intercept_enabled
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
return|return
operator|(
name|svm_get_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_VINTR
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|enable_intr_window_exiting
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctrl
operator|->
name|v_irq
operator|&&
name|ctrl
operator|->
name|v_intr_vector
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|ctrl
operator|->
name|v_ign_tpr
argument_list|,
operator|(
literal|"%s: invalid v_ign_tpr"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vintr_intercept_enabled
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
operator|(
literal|"%s: vintr intercept should be enabled"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|VCPU_CTR0
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Enable intr window exiting"
argument_list|)
expr_stmt|;
name|ctrl
operator|->
name|v_irq
operator|=
literal|1
expr_stmt|;
name|ctrl
operator|->
name|v_ign_tpr
operator|=
literal|1
expr_stmt|;
name|ctrl
operator|->
name|v_intr_vector
operator|=
literal|0
expr_stmt|;
name|svm_set_dirty
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CACHE_TPR
argument_list|)
expr_stmt|;
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_VINTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|disable_intr_window_exiting
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctrl
operator|->
name|v_irq
operator|&&
name|ctrl
operator|->
name|v_intr_vector
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
name|vintr_intercept_enabled
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
operator|(
literal|"%s: vintr intercept should be disabled"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|KTR
if|if
condition|(
name|ctrl
operator|->
name|v_intr_vector
operator|==
literal|0
condition|)
name|VCPU_CTR0
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Disable intr window exiting"
argument_list|)
expr_stmt|;
else|else
name|VCPU_CTR0
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Clearing V_IRQ interrupt injection"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctrl
operator|->
name|v_irq
operator|=
literal|0
expr_stmt|;
name|ctrl
operator|->
name|v_intr_vector
operator|=
literal|0
expr_stmt|;
name|svm_set_dirty
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CACHE_TPR
argument_list|)
expr_stmt|;
name|svm_disable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_VINTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_modify_intr_shadow
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|int
name|oldval
decl_stmt|,
name|newval
decl_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|ctrl
operator|->
name|intr_shadow
expr_stmt|;
name|newval
operator|=
name|val
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|newval
operator|!=
name|oldval
condition|)
block|{
name|ctrl
operator|->
name|intr_shadow
operator|=
name|newval
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Setting intr_shadow to %d"
argument_list|,
name|newval
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_get_intr_shadow
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|ctrl
operator|->
name|intr_shadow
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Once an NMI is injected it blocks delivery of further NMIs until the handler  * executes an IRET. The IRET intercept is enabled when an NMI is injected to  * to track when the vcpu is done handling the NMI.  */
end_comment

begin_function
specifier|static
name|int
name|nmi_blocked
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|int
name|blocked
decl_stmt|;
name|blocked
operator|=
name|svm_get_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_IRET
argument_list|)
expr_stmt|;
return|return
operator|(
name|blocked
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_nmi_blocking
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|!
name|nmi_blocked
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
operator|(
literal|"vNMI already blocked"
operator|)
argument_list|)
expr_stmt|;
name|VCPU_CTR0
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"vNMI blocking enabled"
argument_list|)
expr_stmt|;
name|svm_enable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_IRET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_nmi_blocking
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|nmi_blocked
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
operator|(
literal|"vNMI already unblocked"
operator|)
argument_list|)
expr_stmt|;
name|VCPU_CTR0
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"vNMI blocking cleared"
argument_list|)
expr_stmt|;
comment|/* 	 * When the IRET intercept is cleared the vcpu will attempt to execute 	 * the "iret" when it runs next. However, it is possible to inject 	 * another NMI into the vcpu before the "iret" has actually executed. 	 * 	 * For e.g. if the "iret" encounters a #NPF when accessing the stack 	 * it will trap back into the hypervisor. If an NMI is pending for 	 * the vcpu it will be injected into the guest. 	 * 	 * XXX this needs to be fixed 	 */
name|svm_disable_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_IRET
argument_list|)
expr_stmt|;
comment|/* 	 * Set 'intr_shadow' to prevent an NMI from being injected on the 	 * immediate VMRUN. 	 */
name|error
operator|=
name|svm_modify_intr_shadow
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|error
argument_list|,
operator|(
literal|"%s: error %d setting intr_shadow"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|EFER_MBZ_BITS
value|0xFFFFFFFFFFFF0200UL
end_define

begin_function
specifier|static
name|int
name|svm_write_efer
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|uint64_t
name|newval
parameter_list|,
name|bool
modifier|*
name|retu
parameter_list|)
block|{
name|struct
name|vm_exit
modifier|*
name|vme
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|uint64_t
name|changed
decl_stmt|,
name|lma
decl_stmt|,
name|oldval
decl_stmt|;
name|int
name|error
decl_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|state
operator|->
name|efer
expr_stmt|;
name|VCPU_CTR2
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"wrmsr(efer) %#lx/%#lx"
argument_list|,
name|oldval
argument_list|,
name|newval
argument_list|)
expr_stmt|;
name|newval
operator|&=
operator|~
literal|0xFE
expr_stmt|;
comment|/* clear the Read-As-Zero (RAZ) bits */
name|changed
operator|=
name|oldval
operator|^
name|newval
expr_stmt|;
if|if
condition|(
name|newval
operator|&
name|EFER_MBZ_BITS
condition|)
goto|goto
name|gpf
goto|;
comment|/* APMv2 Table 14-5 "Long-Mode Consistency Checks" */
if|if
condition|(
name|changed
operator|&
name|EFER_LME
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|cr0
operator|&
name|CR0_PG
condition|)
goto|goto
name|gpf
goto|;
block|}
comment|/* EFER.LMA = EFER.LME& CR0.PG */
if|if
condition|(
operator|(
name|newval
operator|&
name|EFER_LME
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|state
operator|->
name|cr0
operator|&
name|CR0_PG
operator|)
operator|!=
literal|0
condition|)
name|lma
operator|=
name|EFER_LMA
expr_stmt|;
else|else
name|lma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|newval
operator|&
name|EFER_LMA
operator|)
operator|!=
name|lma
condition|)
goto|goto
name|gpf
goto|;
if|if
condition|(
name|newval
operator|&
name|EFER_NXE
condition|)
block|{
if|if
condition|(
operator|!
name|vm_cpuid_capability
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VCC_NO_EXECUTE
argument_list|)
condition|)
goto|goto
name|gpf
goto|;
block|}
comment|/* 	 * XXX bhyve does not enforce segment limits in 64-bit mode. Until 	 * this is fixed flag guest attempt to set EFER_LMSLE as an error. 	 */
if|if
condition|(
name|newval
operator|&
name|EFER_LMSLE
condition|)
block|{
name|vme
operator|=
name|vm_exitinfo
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|vm_exit_svm
argument_list|(
name|vme
argument_list|,
name|VMCB_EXIT_MSR
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|retu
operator|=
name|true
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|newval
operator|&
name|EFER_FFXSR
condition|)
block|{
if|if
condition|(
operator|!
name|vm_cpuid_capability
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VCC_FFXSR
argument_list|)
condition|)
goto|goto
name|gpf
goto|;
block|}
if|if
condition|(
name|newval
operator|&
name|EFER_TCE
condition|)
block|{
if|if
condition|(
operator|!
name|vm_cpuid_capability
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VCC_TCE
argument_list|)
condition|)
goto|goto
name|gpf
goto|;
block|}
name|error
operator|=
name|svm_setreg
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_EFER
argument_list|,
name|newval
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d updating efer"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|gpf
label|:
name|vm_inject_gp
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_wrmsr
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|u_int
name|num
parameter_list|,
name|uint64_t
name|val
parameter_list|,
name|bool
modifier|*
name|retu
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|lapic_msr
argument_list|(
name|num
argument_list|)
condition|)
name|error
operator|=
name|lapic_wrmsr
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|num
argument_list|,
name|val
argument_list|,
name|retu
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
name|MSR_EFER
condition|)
name|error
operator|=
name|svm_write_efer
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|val
argument_list|,
name|retu
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|svm_wrmsr
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|num
argument_list|,
name|val
argument_list|,
name|retu
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_rdmsr
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|u_int
name|num
parameter_list|,
name|bool
modifier|*
name|retu
parameter_list|)
block|{
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|struct
name|svm_regctx
modifier|*
name|ctx
decl_stmt|;
name|uint64_t
name|result
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|lapic_msr
argument_list|(
name|num
argument_list|)
condition|)
name|error
operator|=
name|lapic_rdmsr
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|num
argument_list|,
operator|&
name|result
argument_list|,
name|retu
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|svm_rdmsr
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|num
argument_list|,
operator|&
name|result
argument_list|,
name|retu
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|svm_get_guest_regctx
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|state
operator|->
name|rax
operator|=
name|result
operator|&
literal|0xffffffff
expr_stmt|;
name|ctx
operator|->
name|sctx_rdx
operator|=
name|result
operator|>>
literal|32
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|exit_reason_to_str
parameter_list|(
name|uint64_t
name|reason
parameter_list|)
block|{
specifier|static
name|char
name|reasonbuf
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|VMCB_EXIT_INVALID
case|:
return|return
operator|(
literal|"invalvmcb"
operator|)
return|;
case|case
name|VMCB_EXIT_SHUTDOWN
case|:
return|return
operator|(
literal|"shutdown"
operator|)
return|;
case|case
name|VMCB_EXIT_NPF
case|:
return|return
operator|(
literal|"nptfault"
operator|)
return|;
case|case
name|VMCB_EXIT_PAUSE
case|:
return|return
operator|(
literal|"pause"
operator|)
return|;
case|case
name|VMCB_EXIT_HLT
case|:
return|return
operator|(
literal|"hlt"
operator|)
return|;
case|case
name|VMCB_EXIT_CPUID
case|:
return|return
operator|(
literal|"cpuid"
operator|)
return|;
case|case
name|VMCB_EXIT_IO
case|:
return|return
operator|(
literal|"inout"
operator|)
return|;
case|case
name|VMCB_EXIT_MC
case|:
return|return
operator|(
literal|"mchk"
operator|)
return|;
case|case
name|VMCB_EXIT_INTR
case|:
return|return
operator|(
literal|"extintr"
operator|)
return|;
case|case
name|VMCB_EXIT_NMI
case|:
return|return
operator|(
literal|"nmi"
operator|)
return|;
case|case
name|VMCB_EXIT_VINTR
case|:
return|return
operator|(
literal|"vintr"
operator|)
return|;
case|case
name|VMCB_EXIT_MSR
case|:
return|return
operator|(
literal|"msr"
operator|)
return|;
case|case
name|VMCB_EXIT_IRET
case|:
return|return
operator|(
literal|"iret"
operator|)
return|;
case|case
name|VMCB_EXIT_MONITOR
case|:
return|return
operator|(
literal|"monitor"
operator|)
return|;
case|case
name|VMCB_EXIT_MWAIT
case|:
return|return
operator|(
literal|"mwait"
operator|)
return|;
default|default:
name|snprintf
argument_list|(
name|reasonbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|reasonbuf
argument_list|)
argument_list|,
literal|"%#lx"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
operator|(
name|reasonbuf
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KTR */
end_comment

begin_comment
comment|/*  * From section "State Saved on Exit" in APMv2: nRIP is saved for all #VMEXITs  * that are due to instruction intercepts as well as MSR and IOIO intercepts  * and exceptions caused by INT3, INTO and BOUND instructions.  *  * Return 1 if the nRIP is valid and 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|nrip_valid
parameter_list|(
name|uint64_t
name|exitcode
parameter_list|)
block|{
switch|switch
condition|(
name|exitcode
condition|)
block|{
case|case
literal|0x00
operator|...
literal|0x0F
case|:
comment|/* read of CR0 through CR15 */
case|case
literal|0x10
operator|...
literal|0x1F
case|:
comment|/* write of CR0 through CR15 */
case|case
literal|0x20
operator|...
literal|0x2F
case|:
comment|/* read of DR0 through DR15 */
case|case
literal|0x30
operator|...
literal|0x3F
case|:
comment|/* write of DR0 through DR15 */
case|case
literal|0x43
case|:
comment|/* INT3 */
case|case
literal|0x44
case|:
comment|/* INTO */
case|case
literal|0x45
case|:
comment|/* BOUND */
case|case
literal|0x65
operator|...
literal|0x7C
case|:
comment|/* VMEXIT_CR0_SEL_WRITE ... VMEXIT_MSR */
case|case
literal|0x80
operator|...
literal|0x8D
case|:
comment|/* VMEXIT_VMRUN ... VMEXIT_XSETBV */
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|svm_vmexit
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_exit
modifier|*
name|vmexit
parameter_list|)
block|{
name|struct
name|vmcb
modifier|*
name|vmcb
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|svm_regctx
modifier|*
name|ctx
decl_stmt|;
name|uint64_t
name|code
decl_stmt|,
name|info1
decl_stmt|,
name|info2
decl_stmt|,
name|val
decl_stmt|;
name|uint32_t
name|eax
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|int
name|error
decl_stmt|,
name|errcode_valid
decl_stmt|,
name|handled
decl_stmt|,
name|idtvec
decl_stmt|,
name|reflect
decl_stmt|;
name|bool
name|retu
decl_stmt|;
name|ctx
operator|=
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|vmcb
operator|=
name|svm_get_vmcb
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|state
operator|=
operator|&
name|vmcb
operator|->
name|state
expr_stmt|;
name|ctrl
operator|=
operator|&
name|vmcb
operator|->
name|ctrl
expr_stmt|;
name|handled
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|ctrl
operator|->
name|exitcode
expr_stmt|;
name|info1
operator|=
name|ctrl
operator|->
name|exitinfo1
expr_stmt|;
name|info2
operator|=
name|ctrl
operator|->
name|exitinfo2
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_BOGUS
expr_stmt|;
name|vmexit
operator|->
name|rip
operator|=
name|state
operator|->
name|rip
expr_stmt|;
name|vmexit
operator|->
name|inst_length
operator|=
name|nrip_valid
argument_list|(
name|code
argument_list|)
condition|?
name|ctrl
operator|->
name|nrip
operator|-
name|state
operator|->
name|rip
else|:
literal|0
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_COUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * #VMEXIT(INVALID) needs to be handled early because the VMCB is 	 * in an inconsistent state and can trigger assertions that would 	 * never happen otherwise. 	 */
if|if
condition|(
name|code
operator|==
name|VMCB_EXIT_INVALID
condition|)
block|{
name|vm_exit_svm
argument_list|(
name|vmexit
argument_list|,
name|code
argument_list|,
name|info1
argument_list|,
name|info2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|KASSERT
argument_list|(
operator|(
name|ctrl
operator|->
name|eventinj
operator|&
name|VMCB_EVENTINJ_VALID
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: event "
literal|"injection valid bit is set %#lx"
operator|,
name|__func__
operator|,
name|ctrl
operator|->
name|eventinj
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vmexit
operator|->
name|inst_length
operator|>=
literal|0
operator|&&
name|vmexit
operator|->
name|inst_length
operator|<=
literal|15
argument_list|,
operator|(
literal|"invalid inst_length %d: code (%#lx), info1 (%#lx), info2 (%#lx)"
operator|,
name|vmexit
operator|->
name|inst_length
operator|,
name|code
operator|,
name|info1
operator|,
name|info2
operator|)
argument_list|)
expr_stmt|;
name|svm_update_virqinfo
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|svm_save_intinfo
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|VMCB_EXIT_IRET
case|:
comment|/* 		 * Restart execution at "iret" but with the intercept cleared. 		 */
name|vmexit
operator|->
name|inst_length
operator|=
literal|0
expr_stmt|;
name|clear_nmi_blocking
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_VINTR
case|:
comment|/* interrupt window exiting */
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_VINTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_INTR
case|:
comment|/* external interrupt */
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_EXTINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_NMI
case|:
comment|/* external NMI */
name|handled
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x40
operator|...
literal|0x5F
case|:
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_EXCEPTION
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|reflect
operator|=
literal|1
expr_stmt|;
name|idtvec
operator|=
name|code
operator|-
literal|0x40
expr_stmt|;
switch|switch
condition|(
name|idtvec
condition|)
block|{
case|case
name|IDT_MC
case|:
comment|/* 			 * Call the machine check handler by hand. Also don't 			 * reflect the machine check back into the guest. 			 */
name|reflect
operator|=
literal|0
expr_stmt|;
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Vectoring to MCE handler"
argument_list|)
expr_stmt|;
asm|__asm __volatile("int $18");
break|break;
case|case
name|IDT_PF
case|:
name|error
operator|=
name|svm_setreg
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_CR2
argument_list|,
name|info2
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d updating cr2"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
comment|/* fallthru */
case|case
name|IDT_NP
case|:
case|case
name|IDT_SS
case|:
case|case
name|IDT_GP
case|:
case|case
name|IDT_AC
case|:
case|case
name|IDT_TS
case|:
name|errcode_valid
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IDT_DF
case|:
name|errcode_valid
operator|=
literal|1
expr_stmt|;
name|info1
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IDT_BP
case|:
case|case
name|IDT_OF
case|:
case|case
name|IDT_BR
case|:
comment|/* 			 * The 'nrip' field is populated for INT3, INTO and 			 * BOUND exceptions and this also implies that 			 * 'inst_length' is non-zero. 			 * 			 * Reset 'inst_length' to zero so the guest %rip at 			 * event injection is identical to what it was when 			 * the exception originally happened. 			 */
name|VCPU_CTR2
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Reset inst_length from %d "
literal|"to zero before injecting exception %d"
argument_list|,
name|vmexit
operator|->
name|inst_length
argument_list|,
name|idtvec
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|inst_length
operator|=
literal|0
expr_stmt|;
comment|/* fallthru */
default|default:
name|errcode_valid
operator|=
literal|0
expr_stmt|;
name|info1
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|KASSERT
argument_list|(
name|vmexit
operator|->
name|inst_length
operator|==
literal|0
argument_list|,
operator|(
literal|"invalid inst_length (%d) "
literal|"when reflecting exception %d into guest"
operator|,
name|vmexit
operator|->
name|inst_length
operator|,
name|idtvec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reflect
condition|)
block|{
comment|/* Reflect the exception back into the guest */
name|VCPU_CTR2
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Reflecting exception "
literal|"%d/%#x into the guest"
argument_list|,
name|idtvec
argument_list|,
operator|(
name|int
operator|)
name|info1
argument_list|)
expr_stmt|;
name|error
operator|=
name|vm_inject_exception
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|idtvec
argument_list|,
name|errcode_valid
argument_list|,
name|info1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: vm_inject_exception error %d"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
block|}
name|handled
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_MSR
case|:
comment|/* MSR access. */
name|eax
operator|=
name|state
operator|->
name|rax
expr_stmt|;
name|ecx
operator|=
name|ctx
operator|->
name|sctx_rcx
expr_stmt|;
name|edx
operator|=
name|ctx
operator|->
name|sctx_rdx
expr_stmt|;
name|retu
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|info1
condition|)
block|{
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_WRMSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|uint64_t
operator|)
name|edx
operator|<<
literal|32
operator||
name|eax
expr_stmt|;
name|VCPU_CTR2
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"wrmsr %#x val %#lx"
argument_list|,
name|ecx
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|emulate_wrmsr
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|ecx
argument_list|,
name|val
argument_list|,
operator|&
name|retu
argument_list|)
condition|)
block|{
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_WRMSR
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|msr
operator|.
name|code
operator|=
name|ecx
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|msr
operator|.
name|wval
operator|=
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|retu
condition|)
block|{
name|handled
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|vmexit
operator|->
name|exitcode
operator|!=
name|VM_EXITCODE_BOGUS
argument_list|,
operator|(
literal|"emulate_wrmsr retu with bogus exitcode"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"rdmsr %#x"
argument_list|,
name|ecx
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_RDMSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|emulate_rdmsr
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|ecx
argument_list|,
operator|&
name|retu
argument_list|)
condition|)
block|{
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_RDMSR
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|msr
operator|.
name|code
operator|=
name|ecx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|retu
condition|)
block|{
name|handled
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|vmexit
operator|->
name|exitcode
operator|!=
name|VM_EXITCODE_BOGUS
argument_list|,
operator|(
literal|"emulate_rdmsr retu with bogus exitcode"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|VMCB_EXIT_IO
case|:
name|handled
operator|=
name|svm_handle_io
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|vmexit
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_INOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_CPUID
case|:
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_CPUID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|handled
operator|=
name|x86_emulate_cpuid
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|state
operator|->
name|rax
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|ctx
operator|->
name|sctx_rbx
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|ctx
operator|->
name|sctx_rcx
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|ctx
operator|->
name|sctx_rdx
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_HLT
case|:
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_HLT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_HLT
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|hlt
operator|.
name|rflags
operator|=
name|state
operator|->
name|rflags
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_PAUSE
case|:
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_PAUSE
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_PAUSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_NPF
case|:
comment|/* EXITINFO2 contains the faulting guest physical address */
if|if
condition|(
name|info1
operator|&
name|VMCB_NPF_INFO1_RSV
condition|)
block|{
name|VCPU_CTR2
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"nested page fault with "
literal|"reserved bits set: info1(%#lx) info2(%#lx)"
argument_list|,
name|info1
argument_list|,
name|info2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vm_mem_allocated
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|info2
argument_list|)
condition|)
block|{
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_PAGING
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|paging
operator|.
name|gpa
operator|=
name|info2
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|paging
operator|.
name|fault_type
operator|=
name|npf_fault_type
argument_list|(
name|info1
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_NESTED_FAULT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"nested page fault "
literal|"on gpa %#lx/%#lx at rip %#lx"
argument_list|,
name|info2
argument_list|,
name|info1
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svm_npf_emul_fault
argument_list|(
name|info1
argument_list|)
condition|)
block|{
name|svm_handle_inst_emul
argument_list|(
name|vmcb
argument_list|,
name|info2
argument_list|,
name|vmexit
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_INST_EMUL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"inst_emul fault "
literal|"for gpa %#lx/%#lx at rip %#lx"
argument_list|,
name|info2
argument_list|,
name|info1
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VMCB_EXIT_MONITOR
case|:
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_MONITOR
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_MWAIT
case|:
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_MWAIT
expr_stmt|;
break|break;
default|default:
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_UNKNOWN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|VCPU_CTR4
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"%s %s vmexit at %#lx/%d"
argument_list|,
name|handled
condition|?
literal|"handled"
else|:
literal|"unhandled"
argument_list|,
name|exit_reason_to_str
argument_list|(
name|code
argument_list|)
argument_list|,
name|vmexit
operator|->
name|rip
argument_list|,
name|vmexit
operator|->
name|inst_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|handled
condition|)
block|{
name|vmexit
operator|->
name|rip
operator|+=
name|vmexit
operator|->
name|inst_length
expr_stmt|;
name|vmexit
operator|->
name|inst_length
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|rip
operator|=
name|vmexit
operator|->
name|rip
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vmexit
operator|->
name|exitcode
operator|==
name|VM_EXITCODE_BOGUS
condition|)
block|{
comment|/* 			 * If this VM exit was not claimed by anybody then 			 * treat it as a generic SVM exit. 			 */
name|vm_exit_svm
argument_list|(
name|vmexit
argument_list|,
name|code
argument_list|,
name|info1
argument_list|,
name|info2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The exitcode and collateral have been populated. 			 * The VM exit will be processed further in userland. 			 */
block|}
block|}
return|return
operator|(
name|handled
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_inj_intinfo
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|uint64_t
name|intinfo
decl_stmt|;
if|if
condition|(
operator|!
name|vm_entry_intinfo
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
operator|&
name|intinfo
argument_list|)
condition|)
return|return;
name|KASSERT
argument_list|(
name|VMCB_EXITINTINFO_VALID
argument_list|(
name|intinfo
argument_list|)
argument_list|,
operator|(
literal|"%s: entry intinfo is not "
literal|"valid: %#lx"
operator|,
name|__func__
operator|,
name|intinfo
operator|)
argument_list|)
expr_stmt|;
name|svm_eventinject
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_EXITINTINFO_TYPE
argument_list|(
name|intinfo
argument_list|)
argument_list|,
name|VMCB_EXITINTINFO_VECTOR
argument_list|(
name|intinfo
argument_list|)
argument_list|,
name|VMCB_EXITINTINFO_EC
argument_list|(
name|intinfo
argument_list|)
argument_list|,
name|VMCB_EXITINTINFO_EC_VALID
argument_list|(
name|intinfo
argument_list|)
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VCPU_INTINFO_INJECTED
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Injected entry intinfo: %#lx"
argument_list|,
name|intinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Inject event to virtual cpu.  */
end_comment

begin_function
specifier|static
name|void
name|svm_inj_interrupts
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|struct
name|svm_vcpu
modifier|*
name|vcpustate
decl_stmt|;
name|uint8_t
name|v_tpr
decl_stmt|;
name|int
name|vector
decl_stmt|,
name|need_intr_window
decl_stmt|,
name|pending_apic_vector
decl_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|vcpustate
operator|=
name|svm_get_vcpu
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|need_intr_window
operator|=
literal|0
expr_stmt|;
name|pending_apic_vector
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vcpustate
operator|->
name|nextrip
operator|!=
name|state
operator|->
name|rip
condition|)
block|{
name|ctrl
operator|->
name|intr_shadow
operator|=
literal|0
expr_stmt|;
name|VCPU_CTR2
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Guest interrupt blocking "
literal|"cleared due to rip change: %#lx/%#lx"
argument_list|,
name|vcpustate
operator|->
name|nextrip
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Inject pending events or exceptions for this vcpu. 	 * 	 * An event might be pending because the previous #VMEXIT happened 	 * during event delivery (i.e. ctrl->exitintinfo). 	 * 	 * An event might also be pending because an exception was injected 	 * by the hypervisor (e.g. #PF during instruction emulation). 	 */
name|svm_inj_intinfo
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
comment|/* NMI event has priority over interrupts. */
if|if
condition|(
name|vm_nmi_pending
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
condition|)
block|{
if|if
condition|(
name|nmi_blocked
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
condition|)
block|{
comment|/* 			 * Can't inject another NMI if the guest has not 			 * yet executed an "iret" after the last NMI. 			 */
name|VCPU_CTR0
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Cannot inject NMI due "
literal|"to NMI-blocking"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctrl
operator|->
name|intr_shadow
condition|)
block|{
comment|/* 			 * Can't inject an NMI if the vcpu is in an intr_shadow. 			 */
name|VCPU_CTR0
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Cannot inject NMI due to "
literal|"interrupt shadow"
argument_list|)
expr_stmt|;
name|need_intr_window
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|ctrl
operator|->
name|eventinj
operator|&
name|VMCB_EVENTINJ_VALID
condition|)
block|{
comment|/* 			 * If there is already an exception/interrupt pending 			 * then defer the NMI until after that. 			 */
name|VCPU_CTR1
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Cannot inject NMI due to "
literal|"eventinj %#lx"
argument_list|,
name|ctrl
operator|->
name|eventinj
argument_list|)
expr_stmt|;
comment|/* 			 * Use self-IPI to trigger a VM-exit as soon as 			 * possible after the event injection is completed. 			 * 			 * This works only if the external interrupt exiting 			 * is at a lower priority than the event injection. 			 * 			 * Although not explicitly specified in APMv2 the 			 * relative priorities were verified empirically. 			 */
name|ipi_cpu
argument_list|(
name|curcpu
argument_list|,
name|IPI_AST
argument_list|)
expr_stmt|;
comment|/* XXX vmm_ipinum? */
block|}
else|else
block|{
name|vm_nmi_clear
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
comment|/* Inject NMI, vector number is not used */
name|svm_eventinject
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_EVENTINJ_TYPE_NMI
argument_list|,
name|IDT_NMI
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* virtual NMI blocking is now in effect */
name|enable_nmi_blocking
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|VCPU_CTR0
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Injecting vNMI"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|vm_extint_pending
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
condition|)
block|{
comment|/* 		 * APIC interrupts are delivered using the V_IRQ offload. 		 * 		 * The primary benefit is that the hypervisor doesn't need to 		 * deal with the various conditions that inhibit interrupts. 		 * It also means that TPR changes via CR8 will be handled 		 * without any hypervisor involvement. 		 * 		 * Note that the APIC vector must remain pending in the vIRR 		 * until it is confirmed that it was delivered to the guest. 		 * This can be confirmed based on the value of V_IRQ at the 		 * next #VMEXIT (1 = pending, 0 = delivered). 		 * 		 * Also note that it is possible that another higher priority 		 * vector can become pending before this vector is delivered 		 * to the guest. This is alright because vcpu_notify_event() 		 * will send an IPI and force the vcpu to trap back into the 		 * hypervisor. The higher priority vector will be injected on 		 * the next VMRUN. 		 */
if|if
condition|(
name|vlapic_pending_intr
argument_list|(
name|vlapic
argument_list|,
operator|&
name|vector
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|vector
operator|>=
literal|16
operator|&&
name|vector
operator|<=
literal|255
argument_list|,
operator|(
literal|"invalid vector %d from local APIC"
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
name|pending_apic_vector
operator|=
name|vector
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* Ask the legacy pic for a vector to inject */
name|vatpic_pending_intr
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
operator|&
name|vector
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vector
operator|>=
literal|0
operator|&&
name|vector
operator|<=
literal|255
argument_list|,
operator|(
literal|"invalid vector %d from INTR"
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the guest has disabled interrupts or is in an interrupt shadow 	 * then we cannot inject the pending interrupt. 	 */
if|if
condition|(
operator|(
name|state
operator|->
name|rflags
operator|&
name|PSL_I
operator|)
operator|==
literal|0
condition|)
block|{
name|VCPU_CTR2
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Cannot inject vector %d due to "
literal|"rflags %#lx"
argument_list|,
name|vector
argument_list|,
name|state
operator|->
name|rflags
argument_list|)
expr_stmt|;
name|need_intr_window
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|ctrl
operator|->
name|intr_shadow
condition|)
block|{
name|VCPU_CTR1
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Cannot inject vector %d due to "
literal|"interrupt shadow"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
name|need_intr_window
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|ctrl
operator|->
name|eventinj
operator|&
name|VMCB_EVENTINJ_VALID
condition|)
block|{
name|VCPU_CTR2
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Cannot inject vector %d due to "
literal|"eventinj %#lx"
argument_list|,
name|vector
argument_list|,
name|ctrl
operator|->
name|eventinj
argument_list|)
expr_stmt|;
name|need_intr_window
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Legacy PIC interrupts are delivered via the event injection 	 * mechanism. 	 */
name|svm_eventinject
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_EVENTINJ_TYPE_INTR
argument_list|,
name|vector
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|vm_extint_clear
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|vatpic_intr_accepted
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vector
argument_list|)
expr_stmt|;
comment|/* 	 * Force a VM-exit as soon as the vcpu is ready to accept another 	 * interrupt. This is done because the PIC might have another vector 	 * that it wants to inject. Also, if the APIC has a pending interrupt 	 * that was preempted by the ExtInt then it allows us to inject the 	 * APIC vector as soon as possible. 	 */
name|need_intr_window
operator|=
literal|1
expr_stmt|;
name|done
label|:
comment|/* 	 * The guest can modify the TPR by writing to %CR8. In guest mode 	 * the processor reflects this write to V_TPR without hypervisor 	 * intervention. 	 * 	 * The guest can also modify the TPR by writing to it via the memory 	 * mapped APIC page. In this case, the write will be emulated by the 	 * hypervisor. For this reason V_TPR must be updated before every 	 * VMRUN. 	 */
name|v_tpr
operator|=
name|vlapic_get_cr8
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|v_tpr
operator|<=
literal|15
argument_list|,
operator|(
literal|"invalid v_tpr %#x"
operator|,
name|v_tpr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctrl
operator|->
name|v_tpr
operator|!=
name|v_tpr
condition|)
block|{
name|VCPU_CTR2
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"VMCB V_TPR changed from %#x to %#x"
argument_list|,
name|ctrl
operator|->
name|v_tpr
argument_list|,
name|v_tpr
argument_list|)
expr_stmt|;
name|ctrl
operator|->
name|v_tpr
operator|=
name|v_tpr
expr_stmt|;
name|svm_set_dirty
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CACHE_TPR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pending_apic_vector
condition|)
block|{
comment|/* 		 * If an APIC vector is being injected then interrupt window 		 * exiting is not possible on this VMRUN. 		 */
name|KASSERT
argument_list|(
operator|!
name|need_intr_window
argument_list|,
operator|(
literal|"intr_window exiting impossible"
operator|)
argument_list|)
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Injecting vector %d using V_IRQ"
argument_list|,
name|pending_apic_vector
argument_list|)
expr_stmt|;
name|ctrl
operator|->
name|v_irq
operator|=
literal|1
expr_stmt|;
name|ctrl
operator|->
name|v_ign_tpr
operator|=
literal|0
expr_stmt|;
name|ctrl
operator|->
name|v_intr_vector
operator|=
name|pending_apic_vector
expr_stmt|;
name|ctrl
operator|->
name|v_intr_prio
operator|=
name|pending_apic_vector
operator|>>
literal|4
expr_stmt|;
name|svm_set_dirty
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CACHE_TPR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|need_intr_window
condition|)
block|{
comment|/* 		 * We use V_IRQ in conjunction with the VINTR intercept to 		 * trap into the hypervisor as soon as a virtual interrupt 		 * can be delivered. 		 * 		 * Since injected events are not subject to intercept checks 		 * we need to ensure that the V_IRQ is not actually going to 		 * be delivered on VM entry. The KASSERT below enforces this. 		 */
name|KASSERT
argument_list|(
operator|(
name|ctrl
operator|->
name|eventinj
operator|&
name|VMCB_EVENTINJ_VALID
operator|)
operator|!=
literal|0
operator|||
operator|(
name|state
operator|->
name|rflags
operator|&
name|PSL_I
operator|)
operator|==
literal|0
operator|||
name|ctrl
operator|->
name|intr_shadow
argument_list|,
operator|(
literal|"Bogus intr_window_exiting: eventinj (%#lx), "
literal|"intr_shadow (%u), rflags (%#lx)"
operator|,
name|ctrl
operator|->
name|eventinj
operator|,
name|ctrl
operator|->
name|intr_shadow
operator|,
name|state
operator|->
name|rflags
operator|)
argument_list|)
expr_stmt|;
name|enable_intr_window_exiting
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|disable_intr_window_exiting
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|restore_host_tss
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|system_segment_descriptor
modifier|*
name|tss_sd
decl_stmt|;
comment|/* 	 * The TSS descriptor was in use prior to launching the guest so it 	 * has been marked busy. 	 * 	 * 'ltr' requires the descriptor to be marked available so change the 	 * type to "64-bit available TSS". 	 */
name|tss_sd
operator|=
name|PCPU_GET
argument_list|(
name|tss
argument_list|)
expr_stmt|;
name|tss_sd
operator|->
name|sd_type
operator|=
name|SDT_SYSTSS
expr_stmt|;
name|ltr
argument_list|(
name|GSEL
argument_list|(
name|GPROC0_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_asid
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|u_int
name|thiscpu
parameter_list|)
block|{
name|struct
name|svm_vcpu
modifier|*
name|vcpustate
decl_stmt|;
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|long
name|eptgen
decl_stmt|;
name|bool
name|alloc_asid
decl_stmt|;
name|KASSERT
argument_list|(
name|CPU_ISSET
argument_list|(
name|thiscpu
argument_list|,
operator|&
name|pmap
operator|->
name|pm_active
argument_list|)
argument_list|,
operator|(
literal|"%s: nested pmap not "
literal|"active on cpu %u"
operator|,
name|__func__
operator|,
name|thiscpu
operator|)
argument_list|)
expr_stmt|;
name|vcpustate
operator|=
name|svm_get_vcpu
argument_list|(
name|sc
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|sc
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
comment|/* 	 * The TLB entries associated with the vcpu's ASID are not valid 	 * if either of the following conditions is true: 	 * 	 * 1. The vcpu's ASID generation is different than the host cpu's 	 *    ASID generation. This happens when the vcpu migrates to a new 	 *    host cpu. It can also happen when the number of vcpus executing 	 *    on a host cpu is greater than the number of ASIDs available. 	 * 	 * 2. The pmap generation number is different than the value cached in 	 *    the 'vcpustate'. This happens when the host invalidates pages 	 *    belonging to the guest. 	 * 	 *	asidgen		eptgen	      Action 	 *	mismatch	mismatch 	 *	   0		   0		(a) 	 *	   0		   1		(b1) or (b2) 	 *	   1		   0		(c) 	 *	   1		   1		(d) 	 * 	 * (a) There is no mismatch in eptgen or ASID generation and therefore 	 *     no further action is needed. 	 * 	 * (b1) If the cpu supports FlushByAsid then the vcpu's ASID is 	 *      retained and the TLB entries associated with this ASID 	 *      are flushed by VMRUN. 	 * 	 * (b2) If the cpu does not support FlushByAsid then a new ASID is 	 *      allocated. 	 * 	 * (c) A new ASID is allocated. 	 * 	 * (d) A new ASID is allocated. 	 */
name|alloc_asid
operator|=
name|false
expr_stmt|;
name|eptgen
operator|=
name|pmap
operator|->
name|pm_eptgen
expr_stmt|;
name|ctrl
operator|->
name|tlb_ctrl
operator|=
name|VMCB_TLB_FLUSH_NOTHING
expr_stmt|;
if|if
condition|(
name|vcpustate
operator|->
name|asid
operator|.
name|gen
operator|!=
name|asid
index|[
name|thiscpu
index|]
operator|.
name|gen
condition|)
block|{
name|alloc_asid
operator|=
name|true
expr_stmt|;
comment|/* (c) and (d) */
block|}
elseif|else
if|if
condition|(
name|vcpustate
operator|->
name|eptgen
operator|!=
name|eptgen
condition|)
block|{
if|if
condition|(
name|flush_by_asid
argument_list|()
condition|)
name|ctrl
operator|->
name|tlb_ctrl
operator|=
name|VMCB_TLB_FLUSH_GUEST
expr_stmt|;
comment|/* (b1) */
else|else
name|alloc_asid
operator|=
name|true
expr_stmt|;
comment|/* (b2) */
block|}
else|else
block|{
comment|/* 		 * This is the common case (a). 		 */
name|KASSERT
argument_list|(
operator|!
name|alloc_asid
argument_list|,
operator|(
literal|"ASID allocation not necessary"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ctrl
operator|->
name|tlb_ctrl
operator|==
name|VMCB_TLB_FLUSH_NOTHING
argument_list|,
operator|(
literal|"Invalid VMCB tlb_ctrl: %#x"
operator|,
name|ctrl
operator|->
name|tlb_ctrl
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alloc_asid
condition|)
block|{
if|if
condition|(
operator|++
name|asid
index|[
name|thiscpu
index|]
operator|.
name|num
operator|>=
name|nasid
condition|)
block|{
name|asid
index|[
name|thiscpu
index|]
operator|.
name|num
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|asid
index|[
name|thiscpu
index|]
operator|.
name|gen
operator|==
literal|0
condition|)
name|asid
index|[
name|thiscpu
index|]
operator|.
name|gen
operator|=
literal|1
expr_stmt|;
comment|/* 			 * If this cpu does not support "flush-by-asid" 			 * then flush the entire TLB on a generation 			 * bump. Subsequent ASID allocation in this 			 * generation can be done without a TLB flush. 			 */
if|if
condition|(
operator|!
name|flush_by_asid
argument_list|()
condition|)
name|ctrl
operator|->
name|tlb_ctrl
operator|=
name|VMCB_TLB_FLUSH_ALL
expr_stmt|;
block|}
name|vcpustate
operator|->
name|asid
operator|.
name|gen
operator|=
name|asid
index|[
name|thiscpu
index|]
operator|.
name|gen
expr_stmt|;
name|vcpustate
operator|->
name|asid
operator|.
name|num
operator|=
name|asid
index|[
name|thiscpu
index|]
operator|.
name|num
expr_stmt|;
name|ctrl
operator|->
name|asid
operator|=
name|vcpustate
operator|->
name|asid
operator|.
name|num
expr_stmt|;
name|svm_set_dirty
argument_list|(
name|sc
argument_list|,
name|vcpuid
argument_list|,
name|VMCB_CACHE_ASID
argument_list|)
expr_stmt|;
comment|/* 		 * If this cpu supports "flush-by-asid" then the TLB 		 * was not flushed after the generation bump. The TLB 		 * is flushed selectively after every new ASID allocation. 		 */
if|if
condition|(
name|flush_by_asid
argument_list|()
condition|)
name|ctrl
operator|->
name|tlb_ctrl
operator|=
name|VMCB_TLB_FLUSH_GUEST
expr_stmt|;
block|}
name|vcpustate
operator|->
name|eptgen
operator|=
name|eptgen
expr_stmt|;
name|KASSERT
argument_list|(
name|ctrl
operator|->
name|asid
operator|!=
literal|0
argument_list|,
operator|(
literal|"Guest ASID must be non-zero"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ctrl
operator|->
name|asid
operator|==
name|vcpustate
operator|->
name|asid
operator|.
name|num
argument_list|,
operator|(
literal|"ASID mismatch: %u/%u"
operator|,
name|ctrl
operator|->
name|asid
operator|,
name|vcpustate
operator|->
name|asid
operator|.
name|num
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|disable_gintr
parameter_list|(
name|void
parameter_list|)
block|{
asm|__asm __volatile("clgi");
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|enable_gintr
parameter_list|(
name|void
parameter_list|)
block|{
asm|__asm __volatile("stgi");
block|}
end_function

begin_comment
comment|/*  * Start vcpu with specified RIP.  */
end_comment

begin_function
specifier|static
name|int
name|svm_vmrun
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|register_t
name|rip
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|struct
name|vm_eventinfo
modifier|*
name|evinfo
parameter_list|)
block|{
name|struct
name|svm_regctx
modifier|*
name|gctx
decl_stmt|;
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|svm_vcpu
modifier|*
name|vcpustate
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|vm_exit
modifier|*
name|vmexit
decl_stmt|;
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
name|uint64_t
name|vmcb_pa
decl_stmt|;
name|u_int
name|thiscpu
decl_stmt|;
name|int
name|handled
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|vm
operator|=
name|svm_sc
operator|->
name|vm
expr_stmt|;
name|vcpustate
operator|=
name|svm_get_vcpu
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|vmexit
operator|=
name|vm_exitinfo
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|vlapic
operator|=
name|vm_lapic
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
comment|/* 	 * Stash 'curcpu' on the stack as 'thiscpu'. 	 * 	 * The per-cpu data area is not accessible until MSR_GSBASE is restored 	 * after the #VMEXIT. Since VMRUN is executed inside a critical section 	 * 'curcpu' and 'thiscpu' are guaranteed to identical. 	 */
name|thiscpu
operator|=
name|curcpu
expr_stmt|;
name|gctx
operator|=
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|vmcb_pa
operator|=
name|svm_sc
operator|->
name|vcpu
index|[
name|vcpu
index|]
operator|.
name|vmcb_pa
expr_stmt|;
if|if
condition|(
name|vcpustate
operator|->
name|lastcpu
operator|!=
name|thiscpu
condition|)
block|{
comment|/* 		 * Force new ASID allocation by invalidating the generation. 		 */
name|vcpustate
operator|->
name|asid
operator|.
name|gen
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Invalidate the VMCB state cache by marking all fields dirty. 		 */
name|svm_set_dirty
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* 		 * XXX 		 * Setting 'vcpustate->lastcpu' here is bit premature because 		 * we may return from this function without actually executing 		 * the VMRUN  instruction. This could happen if a rendezvous 		 * or an AST is pending on the first time through the loop. 		 * 		 * This works for now but any new side-effects of vcpu 		 * migration should take this case into account. 		 */
name|vcpustate
operator|->
name|lastcpu
operator|=
name|thiscpu
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VCPU_MIGRATIONS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|svm_msr_guest_enter
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
comment|/* Update Guest RIP */
name|state
operator|->
name|rip
operator|=
name|rip
expr_stmt|;
do|do
block|{
comment|/* 		 * Disable global interrupts to guarantee atomicity during 		 * loading of guest state. This includes not only the state 		 * loaded by the "vmrun" instruction but also software state 		 * maintained by the hypervisor: suspended and rendezvous 		 * state, NPT generation number, vlapic interrupts etc. 		 */
name|disable_gintr
argument_list|()
expr_stmt|;
if|if
condition|(
name|vcpu_suspended
argument_list|(
name|evinfo
argument_list|)
condition|)
block|{
name|enable_gintr
argument_list|()
expr_stmt|;
name|vm_exit_suspended
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vcpu_rendezvous_pending
argument_list|(
name|evinfo
argument_list|)
condition|)
block|{
name|enable_gintr
argument_list|()
expr_stmt|;
name|vm_exit_rendezvous
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vcpu_reqidle
argument_list|(
name|evinfo
argument_list|)
condition|)
block|{
name|enable_gintr
argument_list|()
expr_stmt|;
name|vm_exit_reqidle
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* We are asked to give the cpu by scheduler. */
if|if
condition|(
name|vcpu_should_yield
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|)
condition|)
block|{
name|enable_gintr
argument_list|()
expr_stmt|;
name|vm_exit_astpending
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
break|break;
block|}
name|svm_inj_interrupts
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|vlapic
argument_list|)
expr_stmt|;
comment|/* Activate the nested pmap on 'thiscpu' */
name|CPU_SET_ATOMIC_ACQ
argument_list|(
name|thiscpu
argument_list|,
operator|&
name|pmap
operator|->
name|pm_active
argument_list|)
expr_stmt|;
comment|/* 		 * Check the pmap generation and the ASID generation to 		 * ensure that the vcpu does not use stale TLB mappings. 		 */
name|check_asid
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|pmap
argument_list|,
name|thiscpu
argument_list|)
expr_stmt|;
name|ctrl
operator|->
name|vmcb_clean
operator|=
name|vmcb_clean
operator|&
operator|~
name|vcpustate
operator|->
name|dirty
expr_stmt|;
name|vcpustate
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"vmcb clean %#x"
argument_list|,
name|ctrl
operator|->
name|vmcb_clean
argument_list|)
expr_stmt|;
comment|/* Launch Virtual Machine. */
name|VCPU_CTR1
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Resume execution at %#lx"
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
name|svm_launch
argument_list|(
name|vmcb_pa
argument_list|,
name|gctx
argument_list|)
expr_stmt|;
name|CPU_CLR_ATOMIC
argument_list|(
name|thiscpu
argument_list|,
operator|&
name|pmap
operator|->
name|pm_active
argument_list|)
expr_stmt|;
comment|/* 		 * Restore MSR_GSBASE to point to the pcpu data area. 		 * 		 * Note that accesses done via PCPU_GET/PCPU_SET will work 		 * only after MSR_GSBASE is restored. 		 * 		 * Also note that we don't bother restoring MSR_KGSBASE 		 * since it is not used in the kernel and will be restored 		 * when the VMRUN ioctl returns to userspace. 		 */
name|wrmsr
argument_list|(
name|MSR_GSBASE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|&
name|__pcpu
index|[
name|thiscpu
index|]
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|curcpu
operator|==
name|thiscpu
argument_list|,
operator|(
literal|"thiscpu/curcpu (%u/%u) mismatch"
operator|,
name|thiscpu
operator|,
name|curcpu
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * The host GDTR and IDTR is saved by VMRUN and restored 		 * automatically on #VMEXIT. However, the host TSS needs 		 * to be restored explicitly. 		 */
name|restore_host_tss
argument_list|()
expr_stmt|;
comment|/* #VMEXIT disables interrupts so re-enable them here. */
name|enable_gintr
argument_list|()
expr_stmt|;
comment|/* Update 'nextrip' */
name|vcpustate
operator|->
name|nextrip
operator|=
name|state
operator|->
name|rip
expr_stmt|;
comment|/* Handle #VMEXIT and if required return to user space. */
name|handled
operator|=
name|svm_vmexit
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|vmexit
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|handled
condition|)
do|;
name|svm_msr_guest_exit
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_vmcleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_SVM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|register_t
modifier|*
name|swctx_regptr
parameter_list|(
name|struct
name|svm_regctx
modifier|*
name|regctx
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|VM_REG_GUEST_RBX
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_rbx
operator|)
return|;
case|case
name|VM_REG_GUEST_RCX
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_rcx
operator|)
return|;
case|case
name|VM_REG_GUEST_RDX
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_rdx
operator|)
return|;
case|case
name|VM_REG_GUEST_RDI
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_rdi
operator|)
return|;
case|case
name|VM_REG_GUEST_RSI
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_rsi
operator|)
return|;
case|case
name|VM_REG_GUEST_RBP
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_rbp
operator|)
return|;
case|case
name|VM_REG_GUEST_R8
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r8
operator|)
return|;
case|case
name|VM_REG_GUEST_R9
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r9
operator|)
return|;
case|case
name|VM_REG_GUEST_R10
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r10
operator|)
return|;
case|case
name|VM_REG_GUEST_R11
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r11
operator|)
return|;
case|case
name|VM_REG_GUEST_R12
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r12
operator|)
return|;
case|case
name|VM_REG_GUEST_R13
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r13
operator|)
return|;
case|case
name|VM_REG_GUEST_R14
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r14
operator|)
return|;
case|case
name|VM_REG_GUEST_R15
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r15
operator|)
return|;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|svm_getreg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|ident
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|register_t
modifier|*
name|reg
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|ident
operator|==
name|VM_REG_GUEST_INTR_SHADOW
condition|)
block|{
return|return
operator|(
name|svm_get_intr_shadow
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|vmcb_read
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|ident
argument_list|,
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|reg
operator|=
name|swctx_regptr
argument_list|(
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
block|{
operator|*
name|val
operator|=
operator|*
name|reg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"svm_getreg: unknown register %#x"
argument_list|,
name|ident
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_setreg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|ident
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|register_t
modifier|*
name|reg
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|ident
operator|==
name|VM_REG_GUEST_INTR_SHADOW
condition|)
block|{
return|return
operator|(
name|svm_modify_intr_shadow
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|vmcb_write
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|ident
argument_list|,
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|reg
operator|=
name|swctx_regptr
argument_list|(
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
block|{
operator|*
name|reg
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * XXX deal with CR3 and invalidate TLB entries tagged with the 	 * vcpu's ASID. This needs to be treated differently depending on 	 * whether 'running' is true/false. 	 */
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"svm_setreg: unknown register %#x"
argument_list|,
name|ident
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_setcap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|VM_CAP_HALT_EXIT
case|:
name|svm_set_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_HLT
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_PAUSE_EXIT
case|:
name|svm_set_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_PAUSE
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_UNRESTRICTED_GUEST
case|:
comment|/* Unrestricted guest execution cannot be disabled in SVM */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_getcap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|VM_CAP_HALT_EXIT
case|:
operator|*
name|retval
operator|=
name|svm_get_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_HLT
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_PAUSE_EXIT
case|:
operator|*
name|retval
operator|=
name|svm_get_intercept
argument_list|(
name|sc
argument_list|,
name|vcpu
argument_list|,
name|VMCB_CTRL1_INTCPT
argument_list|,
name|VMCB_INTCPT_PAUSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_UNRESTRICTED_GUEST
case|:
operator|*
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* unrestricted guest is always enabled */
break|break;
default|default:
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|vlapic
modifier|*
name|svm_vlapic_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpuid
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|vlapic
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vlapic
argument_list|)
argument_list|,
name|M_SVM_VLAPIC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|vm
operator|=
name|svm_sc
operator|->
name|vm
expr_stmt|;
name|vlapic
operator|->
name|vcpuid
operator|=
name|vcpuid
expr_stmt|;
name|vlapic
operator|->
name|apic_page
operator|=
operator|(
expr|struct
name|LAPIC
operator|*
operator|)
operator|&
name|svm_sc
operator|->
name|apic_page
index|[
name|vcpuid
index|]
expr_stmt|;
name|vlapic_init
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
return|return
operator|(
name|vlapic
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_vlapic_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|vlapic_cleanup
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vlapic
argument_list|,
name|M_SVM_VLAPIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|vmm_ops
name|vmm_ops_amd
init|=
block|{
name|svm_init
block|,
name|svm_cleanup
block|,
name|svm_restore
block|,
name|svm_vminit
block|,
name|svm_vmrun
block|,
name|svm_vmcleanup
block|,
name|svm_getreg
block|,
name|svm_setreg
block|,
name|vmcb_getdesc
block|,
name|vmcb_setdesc
block|,
name|svm_getcap
block|,
name|svm_setcap
block|,
name|svm_npt_alloc
block|,
name|svm_npt_free
block|,
name|svm_vlapic_init
block|,
name|svm_vlapic_cleanup
block|}
decl_stmt|;
end_decl_stmt

end_unit

