begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013, Anish Gupta (akgupt3@gmail.com)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm_dev.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm_instruction_emul.h>
end_include

begin_include
include|#
directive|include
file|<x86/apicreg.h>
end_include

begin_include
include|#
directive|include
file|"vmm_lapic.h"
end_include

begin_include
include|#
directive|include
file|"vmm_msr.h"
end_include

begin_include
include|#
directive|include
file|"vmm_stat.h"
end_include

begin_include
include|#
directive|include
file|"vmm_ktr.h"
end_include

begin_include
include|#
directive|include
file|"vmm_ioport.h"
end_include

begin_include
include|#
directive|include
file|"vatpic.h"
end_include

begin_include
include|#
directive|include
file|"vlapic.h"
end_include

begin_include
include|#
directive|include
file|"vlapic_priv.h"
end_include

begin_include
include|#
directive|include
file|"x86.h"
end_include

begin_include
include|#
directive|include
file|"vmcb.h"
end_include

begin_include
include|#
directive|include
file|"svm.h"
end_include

begin_include
include|#
directive|include
file|"svm_softc.h"
end_include

begin_include
include|#
directive|include
file|"npt.h"
end_include

begin_comment
comment|/*  * SVM CPUID function 0x8000_000A, edx bit decoding.  */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_NP
value|BIT(0)
end_define

begin_comment
comment|/* Nested paging or RVI */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_LBR
value|BIT(1)
end_define

begin_comment
comment|/* Last branch virtualization */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_SVML
value|BIT(2)
end_define

begin_comment
comment|/* SVM lock */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_NRIP_SAVE
value|BIT(3)
end_define

begin_comment
comment|/* Next RIP is saved */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_TSC_RATE
value|BIT(4)
end_define

begin_comment
comment|/* TSC rate control. */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_VMCB_CLEAN
value|BIT(5)
end_define

begin_comment
comment|/* VMCB state caching */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_ASID_FLUSH
value|BIT(6)
end_define

begin_comment
comment|/* Flush by ASID */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_DECODE_ASSIST
value|BIT(7)
end_define

begin_comment
comment|/* Decode assist */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_PAUSE_INC
value|BIT(10)
end_define

begin_comment
comment|/* Pause intercept filter. */
end_comment

begin_define
define|#
directive|define
name|AMD_CPUID_SVM_PAUSE_FTH
value|BIT(12)
end_define

begin_comment
comment|/* Pause filter threshold */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_SVM
argument_list|,
literal|"svm"
argument_list|,
literal|"svm"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_SVM_VLAPIC
argument_list|,
literal|"svm-vlapic"
argument_list|,
literal|"svm-vlapic"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Per-CPU context area. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pcpu
name|__pcpu
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bool
name|svm_vmexit
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_exit
modifier|*
name|vmexit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|svm_msr_rw_ok
parameter_list|(
name|uint8_t
modifier|*
name|btmap
parameter_list|,
name|uint64_t
name|msr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|svm_msr_rd_ok
parameter_list|(
name|uint8_t
modifier|*
name|btmap
parameter_list|,
name|uint64_t
name|msr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|svm_msr_index
parameter_list|(
name|uint64_t
name|msr
parameter_list|,
name|int
modifier|*
name|index
parameter_list|,
name|int
modifier|*
name|bit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|svm_getdesc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|seg_desc
modifier|*
name|desc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|uint32_t
name|svm_feature
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AMD SVM features. */
end_comment

begin_comment
comment|/*  * Starting guest ASID, 0 is reserved for host.  * Each guest will have its own unique ASID.  */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|guest_asid
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Max ASID processor can support.  * This limit the maximum number of virtual machines that can be created.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_asid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * SVM host state saved area of size 4KB for each core.  */
end_comment

begin_function_decl
specifier|static
name|uint8_t
name|hsave
index|[
name|MAXCPU
index|]
index|[
name|PAGE_SIZE
index|]
name|__aligned
parameter_list|(
name|PAGE_SIZE
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * S/w saved host context.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|svm_regctx
name|host_ctx
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|VMM_STAT_AMD
argument_list|(
name|VCPU_EXITINTINFO
argument_list|,
literal|"Valid VMCB EXITINTINFO"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VMM_STAT_AMD
argument_list|(
name|VCPU_INTINFO_INJECTED
argument_list|,
literal|"VMM pending exception injected"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*   * Common function to enable or disabled SVM for a CPU.  */
end_comment

begin_function
specifier|static
name|int
name|cpu_svm_enable_disable
parameter_list|(
name|boolean_t
name|enable
parameter_list|)
block|{
name|uint64_t
name|efer_msr
decl_stmt|;
name|efer_msr
operator|=
name|rdmsr
argument_list|(
name|MSR_EFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|efer_msr
operator||=
name|EFER_SVM
expr_stmt|;
else|else
name|efer_msr
operator|&=
operator|~
name|EFER_SVM
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_EFER
argument_list|,
name|efer_msr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disable SVM on a CPU.  */
end_comment

begin_function
specifier|static
name|void
name|svm_disable
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
operator|(
name|void
operator|)
name|cpu_svm_enable_disable
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disable SVM for all CPUs.  */
end_comment

begin_function
specifier|static
name|int
name|svm_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|svm_disable
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for required BHyVe SVM features in a CPU.  */
end_comment

begin_function
specifier|static
name|int
name|svm_cpuid_features
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|regs
index|[
literal|4
index|]
decl_stmt|;
comment|/* CPUID Fn8000_000A is for SVM */
name|do_cpuid
argument_list|(
literal|0x8000000A
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|svm_feature
operator|=
name|regs
index|[
literal|3
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"SVM rev: 0x%x NASID:0x%x\n"
argument_list|,
name|regs
index|[
literal|0
index|]
operator|&
literal|0xFF
argument_list|,
name|regs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|max_asid
operator|=
name|regs
index|[
literal|1
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"SVM Features:0x%b\n"
argument_list|,
name|svm_feature
argument_list|,
literal|"\020"
literal|"\001NP"
comment|/* Nested paging */
literal|"\002LbrVirt"
comment|/* LBR virtualization */
literal|"\003SVML"
comment|/* SVM lock */
literal|"\004NRIPS"
comment|/* NRIP save */
literal|"\005TscRateMsr"
comment|/* MSR based TSC rate control */
literal|"\006VmcbClean"
comment|/* VMCB clean bits */
literal|"\007FlushByAsid"
comment|/* Flush by ASID */
literal|"\010DecodeAssist"
comment|/* Decode assist */
literal|"\011<b20>"
literal|"\012<b20>"
literal|"\013PauseFilter"
literal|"\014<b20>"
literal|"\015PauseFilterThreshold"
literal|"\016AVIC"
argument_list|)
expr_stmt|;
comment|/* SVM Lock */
if|if
condition|(
operator|!
operator|(
name|svm_feature
operator|&
name|AMD_CPUID_SVM_SVML
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"SVM is disabled by BIOS, please enable in BIOS.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * bhyve need RVI to work. 	 */
if|if
condition|(
operator|!
operator|(
name|svm_feature
operator|&
name|AMD_CPUID_SVM_NP
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Missing Nested paging or RVI SVM support in processor.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|svm_feature
operator|&
name|AMD_CPUID_SVM_NRIP_SAVE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable SVM for a CPU.  */
end_comment

begin_function
specifier|static
name|void
name|svm_enable
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|uint64_t
name|hsave_pa
decl_stmt|;
operator|(
name|void
operator|)
name|cpu_svm_enable_disable
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|hsave_pa
operator|=
name|vtophys
argument_list|(
name|hsave
index|[
name|curcpu
index|]
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_VM_HSAVE_PA
argument_list|,
name|hsave_pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdmsr
argument_list|(
name|MSR_VM_HSAVE_PA
argument_list|)
operator|!=
name|hsave_pa
condition|)
block|{
name|panic
argument_list|(
literal|"VM_HSAVE_PA is wrong on CPU%d\n"
argument_list|,
name|curcpu
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check if a processor support SVM.  */
end_comment

begin_function
specifier|static
name|int
name|is_svm_enabled
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|msr
decl_stmt|;
comment|/* Section 15.4 Enabling SVM from APM2. */
if|if
condition|(
operator|(
name|amd_feature2
operator|&
name|AMDID2_SVM
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"SVM is not supported on this processor.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_VM_CR
argument_list|)
expr_stmt|;
comment|/* Make sure SVM is not disabled by BIOS. */
if|if
condition|(
operator|(
name|msr
operator|&
name|VM_CR_SVMDIS
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|svm_cpuid_features
argument_list|()
return|;
block|}
name|printf
argument_list|(
literal|"SVM disabled by Key, consult TPM/BIOS manual.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable SVM on CPU and initialize nested page table h/w.  */
end_comment

begin_function
specifier|static
name|int
name|svm_init
parameter_list|(
name|int
name|ipinum
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|is_svm_enabled
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|svm_npt_init
argument_list|(
name|ipinum
argument_list|)
expr_stmt|;
comment|/* Start SVM on all CPUs */
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|svm_enable
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_restore
parameter_list|(
name|void
parameter_list|)
block|{
name|svm_enable
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get index and bit position for a MSR in MSR permission  * bitmap. Two bits are used for each MSR, lower bit is  * for read and higher bit is for write.  */
end_comment

begin_function
specifier|static
name|int
name|svm_msr_index
parameter_list|(
name|uint64_t
name|msr
parameter_list|,
name|int
modifier|*
name|index
parameter_list|,
name|int
modifier|*
name|bit
parameter_list|)
block|{
name|uint32_t
name|base
decl_stmt|,
name|off
decl_stmt|;
comment|/* Pentium compatible MSRs */
define|#
directive|define
name|MSR_PENTIUM_START
value|0
define|#
directive|define
name|MSR_PENTIUM_END
value|0x1FFF
comment|/* AMD 6th generation and Intel compatible MSRs */
define|#
directive|define
name|MSR_AMD6TH_START
value|0xC0000000UL
define|#
directive|define
name|MSR_AMD6TH_END
value|0xC0001FFFUL
comment|/* AMD 7th and 8th generation compatible MSRs */
define|#
directive|define
name|MSR_AMD7TH_START
value|0xC0010000UL
define|#
directive|define
name|MSR_AMD7TH_END
value|0xC0011FFFUL
operator|*
name|index
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|bit
operator|=
operator|(
name|msr
operator|%
literal|4
operator|)
operator|*
literal|2
expr_stmt|;
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|msr
operator|>=
name|MSR_PENTIUM_START
operator|&&
name|msr
operator|<=
name|MSR_PENTIUM_END
condition|)
block|{
operator|*
name|index
operator|=
name|msr
operator|/
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|base
operator|+=
operator|(
name|MSR_PENTIUM_END
operator|-
name|MSR_PENTIUM_START
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|msr
operator|>=
name|MSR_AMD6TH_START
operator|&&
name|msr
operator|<=
name|MSR_AMD6TH_END
condition|)
block|{
name|off
operator|=
operator|(
name|msr
operator|-
name|MSR_AMD6TH_START
operator|)
expr_stmt|;
operator|*
name|index
operator|=
operator|(
name|off
operator|+
name|base
operator|)
operator|/
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|base
operator|+=
operator|(
name|MSR_AMD6TH_END
operator|-
name|MSR_AMD6TH_START
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|msr
operator|>=
name|MSR_AMD7TH_START
operator|&&
name|msr
operator|<=
name|MSR_AMD7TH_END
condition|)
block|{
name|off
operator|=
operator|(
name|msr
operator|-
name|MSR_AMD7TH_START
operator|)
expr_stmt|;
operator|*
name|index
operator|=
operator|(
name|off
operator|+
name|base
operator|)
operator|/
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give virtual cpu the complete access to MSR(read& write).  */
end_comment

begin_function
specifier|static
name|int
name|svm_msr_perm
parameter_list|(
name|uint8_t
modifier|*
name|perm_bitmap
parameter_list|,
name|uint64_t
name|msr
parameter_list|,
name|bool
name|read
parameter_list|,
name|bool
name|write
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|bit
decl_stmt|,
name|err
decl_stmt|;
name|err
operator|=
name|svm_msr_index
argument_list|(
name|msr
argument_list|,
operator|&
name|index
argument_list|,
operator|&
name|bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ERR
argument_list|(
literal|"MSR 0x%lx is not writeable by guest.\n"
argument_list|,
name|msr
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>
operator|(
name|SVM_MSR_BITMAP_SIZE
operator|)
condition|)
block|{
name|ERR
argument_list|(
literal|"MSR 0x%lx index out of range(%d).\n"
argument_list|,
name|msr
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|bit
operator|<
literal|0
operator|||
name|bit
operator|>
literal|8
condition|)
block|{
name|ERR
argument_list|(
literal|"MSR 0x%lx bit out of range(%d).\n"
argument_list|,
name|msr
argument_list|,
name|bit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Disable intercept for read and write. */
if|if
condition|(
name|read
condition|)
name|perm_bitmap
index|[
name|index
index|]
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
name|bit
operator|)
expr_stmt|;
if|if
condition|(
name|write
condition|)
name|perm_bitmap
index|[
name|index
index|]
operator|&=
operator|~
operator|(
literal|2UL
operator|<<
name|bit
operator|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_VMM
argument_list|,
literal|"Guest has control:0x%x on SVM:MSR(0x%lx).\n"
argument_list|,
operator|(
name|perm_bitmap
index|[
name|index
index|]
operator|>>
name|bit
operator|)
operator|&
literal|0x3
argument_list|,
name|msr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_msr_rw_ok
parameter_list|(
name|uint8_t
modifier|*
name|perm_bitmap
parameter_list|,
name|uint64_t
name|msr
parameter_list|)
block|{
return|return
name|svm_msr_perm
argument_list|(
name|perm_bitmap
argument_list|,
name|msr
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_msr_rd_ok
parameter_list|(
name|uint8_t
modifier|*
name|perm_bitmap
parameter_list|,
name|uint64_t
name|msr
parameter_list|)
block|{
return|return
name|svm_msr_perm
argument_list|(
name|perm_bitmap
argument_list|,
name|msr
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialise VCPU.  */
end_comment

begin_function
specifier|static
name|int
name|svm_init_vcpu
parameter_list|(
name|struct
name|svm_vcpu
modifier|*
name|vcpu
parameter_list|,
name|vm_paddr_t
name|iopm_pa
parameter_list|,
name|vm_paddr_t
name|msrpm_pa
parameter_list|,
name|vm_paddr_t
name|pml4_pa
parameter_list|,
name|uint8_t
name|asid
parameter_list|)
block|{
name|vcpu
operator|->
name|lastcpu
operator|=
name|NOCPU
expr_stmt|;
name|vcpu
operator|->
name|vmcb_pa
operator|=
name|vtophys
argument_list|(
operator|&
name|vcpu
operator|->
name|vmcb
argument_list|)
expr_stmt|;
comment|/*  	 * Initiaise VMCB persistent area of vcpu. 	 * 1. Permission bitmap for MSR and IO space. 	 * 2. Nested paging. 	 * 3. ASID of virtual machine.  	 */
if|if
condition|(
name|svm_init_vmcb
argument_list|(
operator|&
name|vcpu
operator|->
name|vmcb
argument_list|,
name|iopm_pa
argument_list|,
name|msrpm_pa
argument_list|,
name|pml4_pa
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialise a virtual machine.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|svm_vminit
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|pmap_t
name|pmap
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|vm_paddr_t
name|msrpm_pa
decl_stmt|,
name|iopm_pa
decl_stmt|,
name|pml4_pa
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|guest_asid
operator|>=
name|max_asid
condition|)
block|{
name|ERR
argument_list|(
literal|"Host support max ASID:%d, can't create more guests.\n"
argument_list|,
name|max_asid
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|svm_sc
operator|=
operator|(
expr|struct
name|svm_softc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|svm_softc
argument_list|)
argument_list|,
name|M_SVM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|svm_sc
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|svm_sc
operator|->
name|svm_feature
operator|=
name|svm_feature
expr_stmt|;
name|svm_sc
operator|->
name|vcpu_cnt
operator|=
name|VM_MAXCPU
expr_stmt|;
name|svm_sc
operator|->
name|nptp
operator|=
operator|(
name|vm_offset_t
operator|)
name|vtophys
argument_list|(
name|pmap
operator|->
name|pm_pml4
argument_list|)
expr_stmt|;
comment|/* 	 * Each guest has its own unique ASID. 	 * ASID(Address Space Identifier) is used by TLB entry. 	 */
name|svm_sc
operator|->
name|asid
operator|=
name|guest_asid
operator|++
expr_stmt|;
comment|/* 	 * Intercept MSR access to all MSRs except GSBASE, FSBASE,... etc. 	 */
name|memset
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
literal|0xFF
argument_list|,
sizeof|sizeof
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Following MSR can be completely controlled by virtual machines 	 * since access to following are translated to access to VMCB. 	 */
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_GSBASE
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_FSBASE
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_KGSBASE
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_STAR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_LSTAR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_CSTAR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_SF_MASK
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_SYSENTER_CS_MSR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_SYSENTER_ESP_MSR
argument_list|)
expr_stmt|;
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_SYSENTER_EIP_MSR
argument_list|)
expr_stmt|;
comment|/* For Nested Paging/RVI only. */
name|svm_msr_rw_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_PAT
argument_list|)
expr_stmt|;
name|svm_msr_rd_ok
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|,
name|MSR_TSC
argument_list|)
expr_stmt|;
comment|/* Intercept access to all I/O ports. */
name|memset
argument_list|(
name|svm_sc
operator|->
name|iopm_bitmap
argument_list|,
literal|0xFF
argument_list|,
sizeof|sizeof
argument_list|(
name|svm_sc
operator|->
name|iopm_bitmap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cache physical address for multiple vcpus. */
name|iopm_pa
operator|=
name|vtophys
argument_list|(
name|svm_sc
operator|->
name|iopm_bitmap
argument_list|)
expr_stmt|;
name|msrpm_pa
operator|=
name|vtophys
argument_list|(
name|svm_sc
operator|->
name|msr_bitmap
argument_list|)
expr_stmt|;
name|pml4_pa
operator|=
name|svm_sc
operator|->
name|nptp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|svm_init_vcpu
argument_list|(
name|svm_get_vcpu
argument_list|(
name|svm_sc
argument_list|,
name|i
argument_list|)
argument_list|,
name|iopm_pa
argument_list|,
name|msrpm_pa
argument_list|,
name|pml4_pa
argument_list|,
name|svm_sc
operator|->
name|asid
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"SVM couldn't initialise VCPU%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
return|return
operator|(
name|svm_sc
operator|)
return|;
name|cleanup
label|:
name|free
argument_list|(
name|svm_sc
argument_list|,
name|M_SVM
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_cpl
parameter_list|(
name|struct
name|vmcb_state
modifier|*
name|state
parameter_list|)
block|{
comment|/* 	 * From APMv2: 	 *   "Retrieve the CPL from the CPL field in the VMCB, not 	 *    from any segment DPL" 	 */
return|return
operator|(
name|state
operator|->
name|cpl
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|vm_cpu_mode
name|svm_vcpu_mode
parameter_list|(
name|struct
name|vmcb
modifier|*
name|vmcb
parameter_list|)
block|{
name|struct
name|vmcb_segment
modifier|*
name|seg
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|&
name|vmcb
operator|->
name|state
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|efer
operator|&
name|EFER_LMA
condition|)
block|{
name|seg
operator|=
name|vmcb_seg
argument_list|(
name|vmcb
argument_list|,
name|VM_REG_GUEST_CS
argument_list|)
expr_stmt|;
comment|/* 		 * Section 4.8.1 for APM2, check if Code Segment has 		 * Long attribute set in descriptor. 		 */
if|if
condition|(
name|seg
operator|->
name|attrib
operator|&
name|VMCB_CS_ATTRIB_L
condition|)
return|return
operator|(
name|CPU_MODE_64BIT
operator|)
return|;
else|else
return|return
operator|(
name|CPU_MODE_COMPATIBILITY
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|state
operator|->
name|cr0
operator|&
name|CR0_PE
condition|)
block|{
return|return
operator|(
name|CPU_MODE_PROTECTED
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|CPU_MODE_REAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|vm_paging_mode
name|svm_paging_mode
parameter_list|(
name|uint64_t
name|cr0
parameter_list|,
name|uint64_t
name|cr4
parameter_list|,
name|uint64_t
name|efer
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cr0
operator|&
name|CR0_PG
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|PAGING_MODE_FLAT
operator|)
return|;
if|if
condition|(
operator|(
name|cr4
operator|&
name|CR4_PAE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|PAGING_MODE_32
operator|)
return|;
if|if
condition|(
name|efer
operator|&
name|EFER_LME
condition|)
return|return
operator|(
name|PAGING_MODE_64
operator|)
return|;
else|else
return|return
operator|(
name|PAGING_MODE_PAE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ins/outs utility routines  */
end_comment

begin_function
specifier|static
name|uint64_t
name|svm_inout_str_index
parameter_list|(
name|struct
name|svm_regctx
modifier|*
name|regs
parameter_list|,
name|int
name|in
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|in
condition|?
name|regs
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rdi
else|:
name|regs
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rsi
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|svm_inout_str_count
parameter_list|(
name|struct
name|svm_regctx
modifier|*
name|regs
parameter_list|,
name|int
name|rep
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|rep
condition|?
name|regs
operator|->
name|sctx_rcx
else|:
literal|1
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_inout_str_seginfo
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int64_t
name|info1
parameter_list|,
name|int
name|in
parameter_list|,
name|struct
name|vm_inout_str
modifier|*
name|vis
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|in
condition|)
block|{
name|vis
operator|->
name|seg_name
operator|=
name|VM_REG_GUEST_ES
expr_stmt|;
block|}
else|else
block|{
comment|/* The segment field has standard encoding */
name|s
operator|=
operator|(
name|info1
operator|>>
literal|10
operator|)
operator|&
literal|0x7
expr_stmt|;
name|vis
operator|->
name|seg_name
operator|=
name|vm_segment_name
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|svm_getdesc
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|vis
operator|->
name|seg_name
argument_list|,
operator|&
name|vis
operator|->
name|seg_desc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: svm_getdesc error %d"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_inout_str_addrsize
parameter_list|(
name|uint64_t
name|info1
parameter_list|)
block|{
name|uint32_t
name|size
decl_stmt|;
name|size
operator|=
operator|(
name|info1
operator|>>
literal|7
operator|)
operator|&
literal|0x7
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
literal|2
operator|)
return|;
comment|/* 16 bit */
case|case
literal|2
case|:
return|return
operator|(
literal|4
operator|)
return|;
comment|/* 32 bit */
case|case
literal|4
case|:
return|return
operator|(
literal|8
operator|)
return|;
comment|/* 64 bit */
default|default:
name|panic
argument_list|(
literal|"%s: invalid size encoding %d"
argument_list|,
name|__func__
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|svm_paging_info
parameter_list|(
name|struct
name|vmcb
modifier|*
name|vmcb
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|)
block|{
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|&
name|vmcb
operator|->
name|state
expr_stmt|;
name|paging
operator|->
name|cr3
operator|=
name|state
operator|->
name|cr3
expr_stmt|;
name|paging
operator|->
name|cpl
operator|=
name|svm_cpl
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|paging
operator|->
name|cpu_mode
operator|=
name|svm_vcpu_mode
argument_list|(
name|vmcb
argument_list|)
expr_stmt|;
name|paging
operator|->
name|paging_mode
operator|=
name|svm_paging_mode
argument_list|(
name|state
operator|->
name|cr0
argument_list|,
name|state
operator|->
name|cr4
argument_list|,
name|state
operator|->
name|efer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle guest I/O intercept.  */
end_comment

begin_function
specifier|static
name|bool
name|svm_handle_io
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_exit
modifier|*
name|vmexit
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|struct
name|svm_regctx
modifier|*
name|regs
decl_stmt|;
name|struct
name|vm_inout_str
modifier|*
name|vis
decl_stmt|;
name|uint64_t
name|info1
decl_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|regs
operator|=
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|info1
operator|=
name|ctrl
operator|->
name|exitinfo1
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_INOUT
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|in
operator|=
operator|(
name|info1
operator|&
name|BIT
argument_list|(
literal|0
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|string
operator|=
operator|(
name|info1
operator|&
name|BIT
argument_list|(
literal|2
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|rep
operator|=
operator|(
name|info1
operator|&
name|BIT
argument_list|(
literal|3
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|bytes
operator|=
operator|(
name|info1
operator|>>
literal|4
operator|)
operator|&
literal|0x7
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|port
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|info1
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|eax
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|state
operator|->
name|rax
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|string
condition|)
block|{
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_INOUT_STR
expr_stmt|;
name|vis
operator|=
operator|&
name|vmexit
operator|->
name|u
operator|.
name|inout_str
expr_stmt|;
name|svm_paging_info
argument_list|(
name|svm_get_vmcb
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
operator|&
name|vis
operator|->
name|paging
argument_list|)
expr_stmt|;
name|vis
operator|->
name|rflags
operator|=
name|state
operator|->
name|rflags
expr_stmt|;
name|vis
operator|->
name|cr0
operator|=
name|state
operator|->
name|cr0
expr_stmt|;
name|vis
operator|->
name|index
operator|=
name|svm_inout_str_index
argument_list|(
name|regs
argument_list|,
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|in
argument_list|)
expr_stmt|;
name|vis
operator|->
name|count
operator|=
name|svm_inout_str_count
argument_list|(
name|regs
argument_list|,
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|rep
argument_list|)
expr_stmt|;
name|vis
operator|->
name|addrsize
operator|=
name|svm_inout_str_addrsize
argument_list|(
name|info1
argument_list|)
expr_stmt|;
name|svm_inout_str_seginfo
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|info1
argument_list|,
name|vmexit
operator|->
name|u
operator|.
name|inout
operator|.
name|in
argument_list|,
name|vis
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_npf_paging
parameter_list|(
name|uint64_t
name|exitinfo1
parameter_list|)
block|{
if|if
condition|(
name|exitinfo1
operator|&
name|VMCB_NPF_INFO1_W
condition|)
return|return
operator|(
name|VM_PROT_WRITE
operator|)
return|;
return|return
operator|(
name|VM_PROT_READ
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|svm_npf_emul_fault
parameter_list|(
name|uint64_t
name|exitinfo1
parameter_list|)
block|{
if|if
condition|(
name|exitinfo1
operator|&
name|VMCB_NPF_INFO1_ID
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
name|exitinfo1
operator|&
name|VMCB_NPF_INFO1_GPT
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|exitinfo1
operator|&
name|VMCB_NPF_INFO1_GPA
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_handle_inst_emul
parameter_list|(
name|struct
name|vmcb
modifier|*
name|vmcb
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|struct
name|vm_exit
modifier|*
name|vmexit
parameter_list|)
block|{
name|struct
name|vm_guest_paging
modifier|*
name|paging
decl_stmt|;
name|struct
name|vmcb_segment
modifier|*
name|seg
decl_stmt|;
name|paging
operator|=
operator|&
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|paging
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_INST_EMUL
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|gpa
operator|=
name|gpa
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|gla
operator|=
name|VIE_INVALID_GLA
expr_stmt|;
name|svm_paging_info
argument_list|(
name|vmcb
argument_list|,
name|paging
argument_list|)
expr_stmt|;
comment|/* 	 * If DecodeAssist SVM feature doesn't exist, we don't have NPF  	 * instuction length. RIP will be calculated based on the length  	 * determined by instruction emulation. 	 */
name|vmexit
operator|->
name|inst_length
operator|=
name|VIE_INST_SIZE
expr_stmt|;
name|seg
operator|=
name|vmcb_seg
argument_list|(
name|vmcb
argument_list|,
name|VM_REG_GUEST_CS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|paging
operator|->
name|cpu_mode
condition|)
block|{
case|case
name|CPU_MODE_PROTECTED
case|:
case|case
name|CPU_MODE_COMPATIBILITY
case|:
comment|/* 		 * Section 4.8.1 of APM2, Default Operand Size or D bit. 		 */
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|cs_d
operator|=
operator|(
name|seg
operator|->
name|attrib
operator|&
name|VMCB_CS_ATTRIB_D
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
default|default:
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|cs_d
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Special handling of EFER MSR.  * SVM guest must have SVM EFER bit set, prohibit guest from cleareing SVM  * enable bit in EFER.  */
end_comment

begin_function
specifier|static
name|void
name|svm_efer
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|boolean_t
name|write
parameter_list|)
block|{
name|struct
name|svm_regctx
modifier|*
name|swctx
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|swctx
operator|=
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
name|state
operator|->
name|efer
operator|=
operator|(
operator|(
name|swctx
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rdx
operator|&
operator|(
name|uint32_t
operator|)
operator|~
literal|0
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|state
operator|->
name|rax
operator|)
operator||
name|EFER_SVM
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|rax
operator|=
operator|(
name|uint32_t
operator|)
name|state
operator|->
name|efer
expr_stmt|;
name|swctx
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rdx
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|state
operator|->
name|efer
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|svm_save_intinfo
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|uint64_t
name|intinfo
decl_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|intinfo
operator|=
name|ctrl
operator|->
name|exitintinfo
expr_stmt|;
if|if
condition|(
operator|!
name|VMCB_EXITINTINFO_VALID
argument_list|(
name|intinfo
argument_list|)
condition|)
return|return;
comment|/* 	 * From APMv2, Section "Intercepts during IDT interrupt delivery" 	 * 	 * If a #VMEXIT happened during event delivery then record the event 	 * that was being delivered. 	 */
name|VCPU_CTR2
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Pending INTINFO(0x%lx), vector=%d.\n"
argument_list|,
name|intinfo
argument_list|,
name|VMCB_EXITINTINFO_VECTOR
argument_list|(
name|intinfo
argument_list|)
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VCPU_EXITINTINFO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_exit_intinfo
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|intinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine the cause of virtual cpu exit and handle VMEXIT.  * Return: false - Break vcpu execution loop and handle vmexit  *		   in kernel or user space.  *	   true  - Continue vcpu run.  */
end_comment

begin_function
specifier|static
name|bool
name|svm_vmexit
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_exit
modifier|*
name|vmexit
parameter_list|)
block|{
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|svm_regctx
modifier|*
name|ctx
decl_stmt|;
name|uint64_t
name|code
decl_stmt|,
name|info1
decl_stmt|,
name|info2
decl_stmt|,
name|val
decl_stmt|;
name|uint32_t
name|eax
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|bool
name|update_rip
decl_stmt|,
name|loop
decl_stmt|,
name|retu
decl_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|code
operator|=
name|ctrl
operator|->
name|exitcode
expr_stmt|;
name|info1
operator|=
name|ctrl
operator|->
name|exitinfo1
expr_stmt|;
name|info2
operator|=
name|ctrl
operator|->
name|exitinfo2
expr_stmt|;
name|update_rip
operator|=
name|true
expr_stmt|;
name|loop
operator|=
name|true
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_VMX
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|vmx
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ctrl
operator|->
name|eventinj
operator|&
name|VMCB_EVENTINJ_VALID
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: event "
literal|"injection valid bit is set %#lx"
operator|,
name|__func__
operator|,
name|ctrl
operator|->
name|eventinj
operator|)
argument_list|)
expr_stmt|;
name|svm_save_intinfo
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|VMCB_EXIT_MC
case|:
comment|/* Machine Check. */
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_MTRAP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_MTRAP
expr_stmt|;
name|loop
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_MSR
case|:
comment|/* MSR access. */
name|eax
operator|=
name|state
operator|->
name|rax
expr_stmt|;
name|ecx
operator|=
name|ctx
operator|->
name|sctx_rcx
expr_stmt|;
name|edx
operator|=
name|ctx
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rdx
expr_stmt|;
if|if
condition|(
name|ecx
operator|==
name|MSR_EFER
condition|)
block|{
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"VMEXIT EFER\n"
argument_list|)
expr_stmt|;
name|svm_efer
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|info1
argument_list|)
expr_stmt|;
break|break;
block|}
name|retu
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|info1
condition|)
block|{
comment|/* VM exited because of write MSR */
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_WRMSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_WRMSR
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|msr
operator|.
name|code
operator|=
name|ecx
expr_stmt|;
name|val
operator|=
operator|(
name|uint64_t
operator|)
name|edx
operator|<<
literal|32
operator||
name|eax
expr_stmt|;
if|if
condition|(
name|emulate_wrmsr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|ecx
argument_list|,
name|val
argument_list|,
operator|&
name|retu
argument_list|)
condition|)
block|{
name|vmexit
operator|->
name|u
operator|.
name|msr
operator|.
name|wval
operator|=
name|val
expr_stmt|;
name|loop
operator|=
name|false
expr_stmt|;
block|}
else|else
name|loop
operator|=
name|retu
condition|?
name|false
else|:
name|true
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"VMEXIT WRMSR(%s handling) 0x%lx @0x%x"
argument_list|,
name|loop
condition|?
literal|"kernel"
else|:
literal|"user"
argument_list|,
name|val
argument_list|,
name|ecx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_RDMSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_RDMSR
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|msr
operator|.
name|code
operator|=
name|ecx
expr_stmt|;
if|if
condition|(
name|emulate_rdmsr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|ecx
argument_list|,
operator|&
name|retu
argument_list|)
condition|)
block|{
name|loop
operator|=
name|false
expr_stmt|;
block|}
else|else
name|loop
operator|=
name|retu
condition|?
name|false
else|:
name|true
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:VMEXIT RDMSR"
literal|" MSB=0x%08x, LSB=%08x @0x%x"
argument_list|,
name|ctx
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rdx
argument_list|,
name|state
operator|->
name|rax
argument_list|,
name|ecx
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|MSR_AMDK8_IPM
value|0xc0010055
comment|/* 			 * We can't hide AMD C1E idle capability since its 			 * based on CPU generation, for now ignore access to 			 * this MSR by vcpus 			 * XXX: special handling of AMD C1E - Ignore. 			 */
if|if
condition|(
name|ecx
operator|==
name|MSR_AMDK8_IPM
condition|)
name|loop
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_INTR
case|:
comment|/* 			 * Exit on External Interrupt. 			 * Give host interrupt handler to run and if its guest 			 * interrupt, local APIC will inject event in guest. 			 */
name|update_rip
operator|=
name|false
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:VMEXIT ExtInt"
literal|" RIP:0x%lx.\n"
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_EXTINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_IO
case|:
name|loop
operator|=
name|svm_handle_io
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|vmexit
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_INOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_CPUID
case|:
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_CPUID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|x86_emulate_cpuid
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|state
operator|->
name|rax
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|ctx
operator|->
name|sctx_rbx
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|ctx
operator|->
name|sctx_rcx
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|ctx
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rdx
argument_list|)
expr_stmt|;
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:VMEXIT CPUID\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_HLT
case|:
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_HLT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctrl
operator|->
name|v_irq
condition|)
block|{
comment|/* Interrupt is pending, can't halt guest. */
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_HLT_IGNORED
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"VMEXIT halt ignored."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"VMEXIT halted CPU."
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_HLT
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|hlt
operator|.
name|rflags
operator|=
name|state
operator|->
name|rflags
expr_stmt|;
name|loop
operator|=
name|false
expr_stmt|;
block|}
break|break;
case|case
name|VMCB_EXIT_PAUSE
case|:
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:VMEXIT pause"
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_PAUSE
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_PAUSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_NPF
case|:
name|loop
operator|=
name|false
expr_stmt|;
name|update_rip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|info1
operator|&
name|VMCB_NPF_INFO1_RSV
condition|)
block|{
name|VCPU_CTR2
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM_ERR:NPT"
literal|" reserved bit is set,"
literal|"INFO1:0x%lx INFO2:0x%lx .\n"
argument_list|,
name|info1
argument_list|,
name|info2
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* EXITINFO2 has the physical fault address (GPA). */
if|if
condition|(
name|vm_mem_allocated
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|info2
argument_list|)
condition|)
block|{
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:NPF-paging,"
literal|"RIP:0x%lx INFO1:0x%lx INFO2:0x%lx .\n"
argument_list|,
name|state
operator|->
name|rip
argument_list|,
name|info1
argument_list|,
name|info2
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_PAGING
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|paging
operator|.
name|gpa
operator|=
name|info2
expr_stmt|;
name|vmexit
operator|->
name|u
operator|.
name|paging
operator|.
name|fault_type
operator|=
name|svm_npf_paging
argument_list|(
name|info1
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_NESTED_FAULT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svm_npf_emul_fault
argument_list|(
name|info1
argument_list|)
condition|)
block|{
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:NPF inst_emul,"
literal|"RIP:0x%lx INFO1:0x%lx INFO2:0x%lx .\n"
argument_list|,
name|state
operator|->
name|rip
argument_list|,
name|info1
argument_list|,
name|info2
argument_list|)
expr_stmt|;
name|svm_handle_inst_emul
argument_list|(
name|svm_get_vmcb
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
name|info2
argument_list|,
name|vmexit
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_INST_EMUL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VMCB_EXIT_SHUTDOWN
case|:
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:VMEXIT shutdown."
argument_list|)
expr_stmt|;
name|loop
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|VMCB_EXIT_INVALID
case|:
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:VMEXIT INVALID."
argument_list|)
expr_stmt|;
name|loop
operator|=
name|false
expr_stmt|;
break|break;
default|default:
comment|/* Return to user space. */
name|loop
operator|=
name|false
expr_stmt|;
name|update_rip
operator|=
name|false
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"VMEXIT=0x%lx"
literal|" EXITINFO1: 0x%lx EXITINFO2:0x%lx\n"
argument_list|,
name|ctrl
operator|->
name|exitcode
argument_list|,
name|info1
argument_list|,
name|info2
argument_list|)
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:RIP: 0x%lx nRIP:0x%lx"
literal|" Inst decoder len:%d\n"
argument_list|,
name|state
operator|->
name|rip
argument_list|,
name|ctrl
operator|->
name|nrip
argument_list|,
name|ctrl
operator|->
name|inst_decode_size
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_UNKNOWN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|vmexit
operator|->
name|rip
operator|=
name|state
operator|->
name|rip
expr_stmt|;
if|if
condition|(
name|update_rip
condition|)
block|{
if|if
condition|(
name|ctrl
operator|->
name|nrip
operator|==
literal|0
condition|)
block|{
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM_ERR:nRIP is not set "
literal|"for RIP0x%lx.\n"
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_VMX
expr_stmt|;
block|}
else|else
name|vmexit
operator|->
name|rip
operator|=
name|ctrl
operator|->
name|nrip
expr_stmt|;
block|}
comment|/* If vcpu execution is continued, update RIP. */
if|if
condition|(
name|loop
condition|)
block|{
name|state
operator|->
name|rip
operator|=
name|vmexit
operator|->
name|rip
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|->
name|rip
operator|==
literal|0
condition|)
block|{
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM_ERR:RIP is NULL\n"
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_VMX
expr_stmt|;
block|}
return|return
operator|(
name|loop
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Inject NMI to virtual cpu.  */
end_comment

begin_function
specifier|static
name|int
name|svm_inject_nmi
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
comment|/* Can't inject another NMI if last one is pending.*/
if|if
condition|(
operator|!
name|vm_nmi_pending
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Inject NMI, vector number is not used.*/
name|vmcb_eventinject
argument_list|(
name|ctrl
argument_list|,
name|VMCB_EVENTINJ_TYPE_NMI
argument_list|,
name|IDT_NMI
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Acknowledge the request is accepted.*/
name|vm_nmi_clear
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Injected NMI.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_inj_intinfo
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|uint64_t
name|intinfo
decl_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_entry_intinfo
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
operator|&
name|intinfo
argument_list|)
condition|)
return|return;
name|KASSERT
argument_list|(
name|VMCB_EXITINTINFO_VALID
argument_list|(
name|intinfo
argument_list|)
argument_list|,
operator|(
literal|"%s: entry intinfo is not "
literal|"valid: %#lx"
operator|,
name|__func__
operator|,
name|intinfo
operator|)
argument_list|)
expr_stmt|;
name|vmcb_eventinject
argument_list|(
name|ctrl
argument_list|,
name|VMCB_EXITINTINFO_TYPE
argument_list|(
name|intinfo
argument_list|)
argument_list|,
name|VMCB_EXITINTINFO_VECTOR
argument_list|(
name|intinfo
argument_list|)
argument_list|,
name|VMCB_EXITINTINFO_EC
argument_list|(
name|intinfo
argument_list|)
argument_list|,
name|VMCB_EXITINTINFO_EC_VALID
argument_list|(
name|intinfo
argument_list|)
argument_list|)
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VCPU_INTINFO_INJECTED
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"Injected entry intinfo: %#lx"
argument_list|,
name|intinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Inject event to virtual cpu.  */
end_comment

begin_function
specifier|static
name|void
name|svm_inj_interrupts
parameter_list|(
name|struct
name|svm_softc
modifier|*
name|svm_sc
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|int
name|extint_pending
decl_stmt|;
name|int
name|vector
decl_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|svm_inj_intinfo
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
comment|/* Can't inject multiple events at once. */
if|if
condition|(
name|ctrl
operator|->
name|eventinj
operator|&
name|VMCB_EVENTINJ_VALID
condition|)
block|{
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Last event(0x%lx) is pending.\n"
argument_list|,
name|ctrl
operator|->
name|eventinj
argument_list|)
expr_stmt|;
return|return ;
block|}
comment|/* Wait for guest to come out of interrupt shadow. */
if|if
condition|(
name|ctrl
operator|->
name|intr_shadow
condition|)
block|{
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Guest in interrupt shadow.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* NMI event has priority over interrupts.*/
if|if
condition|(
name|svm_inject_nmi
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
condition|)
block|{
return|return;
block|}
name|extint_pending
operator|=
name|vm_extint_pending
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extint_pending
condition|)
block|{
comment|/* Ask the local apic for a vector to inject */
if|if
condition|(
operator|!
name|vlapic_pending_intr
argument_list|(
name|vlapic
argument_list|,
operator|&
name|vector
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
comment|/* Ask the legacy pic for a vector to inject */
name|vatpic_pending_intr
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
operator|&
name|vector
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vector
operator|<
literal|32
operator|||
name|vector
operator|>
literal|255
condition|)
block|{
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM_ERR:Event injection"
literal|"invalid vector=%d.\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
literal|"SVM_ERR:Event injection invalid vector=%d.\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|state
operator|->
name|rflags
operator|&
name|PSL_I
operator|)
operator|==
literal|0
condition|)
block|{
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Interrupt is disabled\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|vmcb_eventinject
argument_list|(
name|ctrl
argument_list|,
name|VMCB_EVENTINJ_TYPE_INTR
argument_list|,
name|vector
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extint_pending
condition|)
block|{
comment|/* Update the Local APIC ISR */
name|vlapic_intr_accepted
argument_list|(
name|vlapic
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vm_extint_clear
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|vatpic_intr_accepted
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vector
argument_list|)
expr_stmt|;
comment|/* 		 * XXX need to recheck exting_pending ala VT-x 		 */
block|}
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:event injected,vector=%d.\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore host Task Register selector type after every vcpu exit.  */
end_comment

begin_function
specifier|static
name|void
name|setup_tss_type
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|system_segment_descriptor
modifier|*
name|desc
decl_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|system_segment_descriptor
operator|*
operator|)
operator|&
name|gdt
index|[
name|curcpu
operator|*
name|NGDT
operator|+
name|GPROC0_SEL
index|]
expr_stmt|;
comment|/* 	 * Task selector that should be restored in host is 	 * 64-bit available(9), not what is read(0xb), see 	 * APMvol2 Rev3.21 4.8.3 System Descriptors table. 	 */
name|desc
operator|->
name|sd_type
operator|=
literal|9
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start vcpu with specified RIP.  */
end_comment

begin_function
specifier|static
name|int
name|svm_vmrun
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|register_t
name|rip
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|void
modifier|*
name|rend_cookie
parameter_list|,
name|void
modifier|*
name|suspended_cookie
parameter_list|)
block|{
name|struct
name|svm_regctx
modifier|*
name|hctx
decl_stmt|,
modifier|*
name|gctx
decl_stmt|;
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|svm_vcpu
modifier|*
name|vcpustate
decl_stmt|;
name|struct
name|vmcb_state
modifier|*
name|state
decl_stmt|;
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|vm_exit
modifier|*
name|vmexit
decl_stmt|;
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
name|uint64_t
name|vmcb_pa
decl_stmt|;
name|bool
name|loop
decl_stmt|;
comment|/* Continue vcpu execution loop. */
name|loop
operator|=
name|true
expr_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|vm
operator|=
name|svm_sc
operator|->
name|vm
expr_stmt|;
name|vcpustate
operator|=
name|svm_get_vcpu
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|state
operator|=
name|svm_get_vmcb_state
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|vmexit
operator|=
name|vm_exitinfo
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|vlapic
operator|=
name|vm_lapic
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|gctx
operator|=
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|hctx
operator|=
operator|&
name|host_ctx
index|[
name|curcpu
index|]
expr_stmt|;
name|vmcb_pa
operator|=
name|svm_sc
operator|->
name|vcpu
index|[
name|vcpu
index|]
operator|.
name|vmcb_pa
expr_stmt|;
if|if
condition|(
name|vcpustate
operator|->
name|lastcpu
operator|!=
name|curcpu
condition|)
block|{
comment|/* Virtual CPU is running on a diiferent CPU now.*/
name|vmm_stat_incr
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VCPU_MIGRATIONS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Flush all TLB mappings for this guest on this CPU, 		 * it might have stale entries since vcpu has migrated 		 * or vmm is restarted. 		 */
name|ctrl
operator|->
name|tlb_ctrl
operator|=
name|VMCB_TLB_FLUSH_GUEST
expr_stmt|;
comment|/* Can't use any cached VMCB state by cpu.*/
name|ctrl
operator|->
name|vmcb_clean
operator|=
name|VMCB_CACHE_NONE
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * XXX: Using same ASID for all vcpus of a VM will cause TLB 		 * corruption. This can easily be produced by muxing two vcpus 		 * on same core. 		 * For now, flush guest TLB for every vmrun. 		 */
name|ctrl
operator|->
name|tlb_ctrl
operator|=
name|VMCB_TLB_FLUSH_GUEST
expr_stmt|;
comment|/*  		 * This is the same cpu on which vcpu last ran so don't 		 * need to reload all VMCB state. 		 * ASID is unique for a guest. 		 * IOPM is unchanged. 		 * RVI/EPT is unchanged. 		 * 		 */
name|ctrl
operator|->
name|vmcb_clean
operator|=
name|VMCB_CACHE_ASID
operator||
name|VMCB_CACHE_IOPM
operator||
name|VMCB_CACHE_NP
expr_stmt|;
block|}
name|vcpustate
operator|->
name|lastcpu
operator|=
name|curcpu
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Enter vmrun RIP:0x%lx"
literal|" inst len=%d/%d\n"
argument_list|,
name|rip
argument_list|,
name|vmexit
operator|->
name|inst_length
argument_list|,
name|vmexit
operator|->
name|u
operator|.
name|inst_emul
operator|.
name|vie
operator|.
name|num_valid
argument_list|)
expr_stmt|;
comment|/* Update Guest RIP */
name|state
operator|->
name|rip
operator|=
name|rip
expr_stmt|;
do|do
block|{
name|vmexit
operator|->
name|inst_length
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Disable global interrupts to guarantee atomicity during 		 * loading of guest state. This includes not only the state 		 * loaded by the "vmrun" instruction but also software state 		 * maintained by the hypervisor: suspended and rendezvous 		 * state, NPT generation number, vlapic interrupts etc. 		 */
name|disable_gintr
argument_list|()
expr_stmt|;
if|if
condition|(
name|vcpu_suspended
argument_list|(
name|suspended_cookie
argument_list|)
condition|)
block|{
name|enable_gintr
argument_list|()
expr_stmt|;
name|vm_exit_suspended
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vcpu_rendezvous_pending
argument_list|(
name|rend_cookie
argument_list|)
condition|)
block|{
name|enable_gintr
argument_list|()
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_RENDEZVOUS
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_RENDEZVOUS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM: VCPU rendezvous, RIP:0x%lx\n"
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|rip
operator|=
name|state
operator|->
name|rip
expr_stmt|;
break|break;
block|}
comment|/* We are asked to give the cpu by scheduler. */
if|if
condition|(
name|curthread
operator|->
name|td_flags
operator|&
operator|(
name|TDF_ASTPENDING
operator||
name|TDF_NEEDRESCHED
operator|)
condition|)
block|{
name|enable_gintr
argument_list|()
expr_stmt|;
name|vmexit
operator|->
name|exitcode
operator|=
name|VM_EXITCODE_BOGUS
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_ASTPENDING
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM: ASTPENDING, RIP:0x%lx\n"
argument_list|,
name|state
operator|->
name|rip
argument_list|)
expr_stmt|;
name|vmexit
operator|->
name|rip
operator|=
name|state
operator|->
name|rip
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|svm_set_vmcb
argument_list|(
name|svm_get_vmcb
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
name|svm_sc
operator|->
name|asid
argument_list|)
expr_stmt|;
name|svm_inj_interrupts
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|vlapic
argument_list|)
expr_stmt|;
comment|/* Change TSS type to available.*/
name|setup_tss_type
argument_list|()
expr_stmt|;
comment|/* Launch Virtual Machine. */
name|svm_launch
argument_list|(
name|vmcb_pa
argument_list|,
name|gctx
argument_list|,
name|hctx
argument_list|)
expr_stmt|;
comment|/* 		 * Only GDTR and IDTR of host is saved and restore by SVM, 		 * LDTR and TR need to be restored by VMM. 		 * XXX: kernel doesn't use LDT, only user space. 		 */
name|ltr
argument_list|(
name|GSEL
argument_list|(
name|GPROC0_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Guest FS and GS selector are stashed by vmload and vmsave. 		 * Host FS and GS selector are stashed by svm_launch(). 		 * Host GS base that holds per-cpu need to be restored before 		 * enabling global interrupt. 		 * FS is not used by FreeBSD kernel and kernel does restore 		 * back FS selector and base of user before returning to 		 * userland. 		 * 		 * Note: You can't use 'curcpu' which uses pcpu. 		 */
name|wrmsr
argument_list|(
name|MSR_GSBASE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|&
name|__pcpu
index|[
name|vcpustate
operator|->
name|lastcpu
index|]
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_KGSBASE
argument_list|,
operator|(
name|uint64_t
operator|)
operator|&
name|__pcpu
index|[
name|vcpustate
operator|->
name|lastcpu
index|]
argument_list|)
expr_stmt|;
comment|/* #VMEXIT disables interrupts so re-enable them here. */
name|enable_gintr
argument_list|()
expr_stmt|;
comment|/* Handle #VMEXIT and if required return to user space. */
name|loop
operator|=
name|svm_vmexit
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|,
name|vmexit
argument_list|)
expr_stmt|;
name|vcpustate
operator|->
name|loop
operator|++
expr_stmt|;
name|vmm_stat_incr
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|VMEXIT_COUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|loop
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cleanup for virtual machine.  */
end_comment

begin_function
specifier|static
name|void
name|svm_vmcleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
literal|0
argument_list|,
literal|"SVM:cleanup\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|svm_sc
argument_list|,
name|M_SVM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return pointer to hypervisor saved register state.  */
end_comment

begin_function
specifier|static
name|register_t
modifier|*
name|swctx_regptr
parameter_list|(
name|struct
name|svm_regctx
modifier|*
name|regctx
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|VM_REG_GUEST_RBX
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_rbx
operator|)
return|;
case|case
name|VM_REG_GUEST_RCX
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_rcx
operator|)
return|;
case|case
name|VM_REG_GUEST_RDX
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rdx
operator|)
return|;
case|case
name|VM_REG_GUEST_RDI
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rdi
operator|)
return|;
case|case
name|VM_REG_GUEST_RSI
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|e
operator|.
name|g
operator|.
name|sctx_rsi
operator|)
return|;
case|case
name|VM_REG_GUEST_RBP
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_rbp
operator|)
return|;
case|case
name|VM_REG_GUEST_R8
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r8
operator|)
return|;
case|case
name|VM_REG_GUEST_R9
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r9
operator|)
return|;
case|case
name|VM_REG_GUEST_R10
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r10
operator|)
return|;
case|case
name|VM_REG_GUEST_R11
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r11
operator|)
return|;
case|case
name|VM_REG_GUEST_R12
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r12
operator|)
return|;
case|case
name|VM_REG_GUEST_R13
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r13
operator|)
return|;
case|case
name|VM_REG_GUEST_R14
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r14
operator|)
return|;
case|case
name|VM_REG_GUEST_R15
case|:
return|return
operator|(
operator|&
name|regctx
operator|->
name|sctx_r15
operator|)
return|;
default|default:
name|ERR
argument_list|(
literal|"Unknown register requested, reg=%d.\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interface to read guest registers.  * This can be SVM h/w saved or hypervisor saved register.  */
end_comment

begin_function
specifier|static
name|int
name|svm_getreg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|ident
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|vmcb
modifier|*
name|vmcb
decl_stmt|;
name|register_t
modifier|*
name|reg
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|vmcb
operator|=
name|svm_get_vmcb
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmcb_read
argument_list|(
name|vmcb
argument_list|,
name|ident
argument_list|,
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|reg
operator|=
name|swctx_regptr
argument_list|(
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
block|{
operator|*
name|val
operator|=
operator|*
name|reg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ERR
argument_list|(
literal|"SVM_ERR:reg type %x is not saved in VMCB.\n"
argument_list|,
name|ident
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interface to write to guest registers.  * This can be SVM h/w saved or hypervisor saved register.  */
end_comment

begin_function
specifier|static
name|int
name|svm_setreg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|ident
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|vmcb
modifier|*
name|vmcb
decl_stmt|;
name|register_t
modifier|*
name|reg
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|vmcb
operator|=
name|svm_get_vmcb
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmcb_write
argument_list|(
name|vmcb
argument_list|,
name|ident
argument_list|,
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|reg
operator|=
name|swctx_regptr
argument_list|(
name|svm_get_guest_regctx
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
block|{
operator|*
name|reg
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ERR
argument_list|(
literal|"SVM_ERR:reg type %x is not saved in VMCB.\n"
argument_list|,
name|ident
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Inteface to set various descriptors.  */
end_comment

begin_function
specifier|static
name|int
name|svm_setdesc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|seg_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|vmcb
modifier|*
name|vmcb
decl_stmt|;
name|struct
name|vmcb_segment
modifier|*
name|seg
decl_stmt|;
name|uint16_t
name|attrib
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|vmcb
operator|=
name|svm_get_vmcb
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:set_desc: Type%d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|seg
operator|=
name|vmcb_seg
argument_list|(
name|vmcb
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|NULL
condition|)
block|{
name|ERR
argument_list|(
literal|"SVM_ERR:Unsupported segment type%d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Map seg_desc access to VMCB attribute format.*/
name|attrib
operator|=
operator|(
operator|(
name|desc
operator|->
name|access
operator|&
literal|0xF000
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
name|desc
operator|->
name|access
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|VCPU_CTR3
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:[sel %d attribute 0x%x limit:0x%x]\n"
argument_list|,
name|type
argument_list|,
name|desc
operator|->
name|access
argument_list|,
name|desc
operator|->
name|limit
argument_list|)
expr_stmt|;
name|seg
operator|->
name|attrib
operator|=
name|attrib
expr_stmt|;
name|seg
operator|->
name|base
operator|=
name|desc
operator|->
name|base
expr_stmt|;
name|seg
operator|->
name|limit
operator|=
name|desc
operator|->
name|limit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interface to get guest descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|svm_getdesc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|seg_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|vmcb_segment
modifier|*
name|seg
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:get_desc: Type%d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|seg
operator|=
name|vmcb_seg
argument_list|(
name|svm_get_vmcb
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seg
condition|)
block|{
name|ERR
argument_list|(
literal|"SVM_ERR:Unsupported segment type%d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Map seg_desc access to VMCB attribute format.*/
name|desc
operator|->
name|access
operator|=
operator|(
operator|(
name|seg
operator|->
name|attrib
operator|&
literal|0xF00
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|seg
operator|->
name|attrib
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|desc
operator|->
name|base
operator|=
name|seg
operator|->
name|base
expr_stmt|;
name|desc
operator|->
name|limit
operator|=
name|seg
operator|->
name|limit
expr_stmt|;
comment|/* 	 * VT-x uses bit 16 (Unusable) to indicate a segment that has been 	 * loaded with a NULL segment selector. The 'desc->access' field is 	 * interpreted in the VT-x format by the processor-independent code. 	 * 	 * SVM uses the 'P' bit to convey the same information so convert it 	 * into the VT-x format. For more details refer to section 	 * "Segment State in the VMCB" in APMv2. 	 */
if|if
condition|(
name|type
operator|==
name|VM_REG_GUEST_CS
operator|&&
name|type
operator|==
name|VM_REG_GUEST_TR
condition|)
name|desc
operator|->
name|access
operator||=
literal|0x80
expr_stmt|;
comment|/* CS and TS always present */
if|if
condition|(
operator|!
operator|(
name|desc
operator|->
name|access
operator|&
literal|0x80
operator|)
condition|)
name|desc
operator|->
name|access
operator||=
literal|0x10000
expr_stmt|;
comment|/* Unusable segment */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_setcap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|int
name|ret
init|=
name|ENOENT
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|VM_CAP_HALT_EXIT
case|:
if|if
condition|(
name|val
condition|)
name|ctrl
operator|->
name|ctrl1
operator||=
name|VMCB_INTCPT_HLT
expr_stmt|;
else|else
name|ctrl
operator|->
name|ctrl1
operator|&=
operator|~
name|VMCB_INTCPT_HLT
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Set_gap:Halt exit %s.\n"
argument_list|,
name|val
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_PAUSE_EXIT
case|:
if|if
condition|(
name|val
condition|)
name|ctrl
operator|->
name|ctrl1
operator||=
name|VMCB_INTCPT_PAUSE
expr_stmt|;
else|else
name|ctrl
operator|->
name|ctrl1
operator|&=
operator|~
name|VMCB_INTCPT_PAUSE
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Set_gap:Pause exit %s.\n"
argument_list|,
name|val
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_MTRAP_EXIT
case|:
if|if
condition|(
name|val
condition|)
name|ctrl
operator|->
name|exception
operator||=
name|BIT
argument_list|(
name|IDT_MC
argument_list|)
expr_stmt|;
else|else
name|ctrl
operator|->
name|exception
operator|&=
operator|~
name|BIT
argument_list|(
name|IDT_MC
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Set_gap:MC exit %s.\n"
argument_list|,
name|val
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_UNRESTRICTED_GUEST
case|:
comment|/* SVM doesn't need special capability for SMP.*/
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:Set_gap:Unrestricted "
literal|"always enabled.\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svm_getcap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|vmcb_ctrl
modifier|*
name|ctrl
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|vcpu
operator|<
name|svm_sc
operator|->
name|vcpu_cnt
argument_list|,
operator|(
literal|"Guest doesn't have VCPU%d"
operator|,
name|vcpu
operator|)
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|svm_get_vmcb_ctrl
argument_list|(
name|svm_sc
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|VM_CAP_HALT_EXIT
case|:
operator|*
name|retval
operator|=
operator|(
name|ctrl
operator|->
name|ctrl1
operator|&
name|VMCB_INTCPT_HLT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:get_cap:Halt exit %s.\n"
argument_list|,
operator|*
name|retval
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_PAUSE_EXIT
case|:
operator|*
name|retval
operator|=
operator|(
name|ctrl
operator|->
name|ctrl1
operator|&
name|VMCB_INTCPT_PAUSE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:get_cap:Pause exit %s.\n"
argument_list|,
operator|*
name|retval
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_MTRAP_EXIT
case|:
operator|*
name|retval
operator|=
operator|(
name|ctrl
operator|->
name|exception
operator|&
name|BIT
argument_list|(
name|IDT_MC
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|VCPU_CTR1
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:get_cap:MC exit %s.\n"
argument_list|,
operator|*
name|retval
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_CAP_UNRESTRICTED_GUEST
case|:
name|VCPU_CTR0
argument_list|(
name|svm_sc
operator|->
name|vm
argument_list|,
name|vcpu
argument_list|,
literal|"SVM:get_cap:Unrestricted.\n"
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|vlapic
modifier|*
name|svm_vlapic_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|vcpuid
parameter_list|)
block|{
name|struct
name|svm_softc
modifier|*
name|svm_sc
decl_stmt|;
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|svm_sc
operator|=
name|arg
expr_stmt|;
name|vlapic
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vlapic
argument_list|)
argument_list|,
name|M_SVM_VLAPIC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vlapic
operator|->
name|vm
operator|=
name|svm_sc
operator|->
name|vm
expr_stmt|;
name|vlapic
operator|->
name|vcpuid
operator|=
name|vcpuid
expr_stmt|;
name|vlapic
operator|->
name|apic_page
operator|=
operator|(
expr|struct
name|LAPIC
operator|*
operator|)
operator|&
name|svm_sc
operator|->
name|apic_page
index|[
name|vcpuid
index|]
expr_stmt|;
name|vlapic_init
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
return|return
operator|(
name|vlapic
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svm_vlapic_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|vlapic
modifier|*
name|vlapic
parameter_list|)
block|{
name|vlapic_cleanup
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vlapic
argument_list|,
name|M_SVM_VLAPIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|vmm_ops
name|vmm_ops_amd
init|=
block|{
name|svm_init
block|,
name|svm_cleanup
block|,
name|svm_restore
block|,
name|svm_vminit
block|,
name|svm_vmrun
block|,
name|svm_vmcleanup
block|,
name|svm_getreg
block|,
name|svm_setreg
block|,
name|svm_getdesc
block|,
name|svm_setdesc
block|,
name|svm_getcap
block|,
name|svm_setcap
block|,
name|svm_npt_alloc
block|,
name|svm_npt_free
block|,
name|svm_vlapic_init
block|,
name|svm_vlapic_cleanup
block|}
decl_stmt|;
end_decl_stmt

end_unit

