begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 NetApp, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|"vmm_host.h"
end_include

begin_include
include|#
directive|include
file|"vmm_ktr.h"
end_include

begin_include
include|#
directive|include
file|"vmm_util.h"
end_include

begin_include
include|#
directive|include
file|"x86.h"
end_include

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_vmm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw_vmm
argument_list|,
name|OID_AUTO
argument_list|,
name|topology
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CPUID_VM_HIGH
value|0x40000000
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|bhyve_id
index|[
literal|12
index|]
init|=
literal|"bhyve bhyve "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|bhyve_xcpuids
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_hw_vmm
argument_list|,
name|OID_AUTO
argument_list|,
name|bhyve_xcpuids
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bhyve_xcpuids
argument_list|,
literal|0
argument_list|,
literal|"Number of times an unknown cpuid leaf was accessed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The default CPU topology is a single thread per package.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|threads_per_core
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_vmm_topology
argument_list|,
name|OID_AUTO
argument_list|,
name|threads_per_core
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|threads_per_core
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cores_per_package
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_vmm_topology
argument_list|,
name|OID_AUTO
argument_list|,
name|cores_per_package
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|cores_per_package
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cpuid_leaf_b
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_vmm_topology
argument_list|,
name|OID_AUTO
argument_list|,
name|cpuid_leaf_b
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|cpuid_leaf_b
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Round up to the next power of two, if necessary, and then take log2.  * Returns -1 if argument is zero.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|log2
parameter_list|(
name|u_int
name|x
parameter_list|)
block|{
return|return
operator|(
name|fls
argument_list|(
name|x
operator|<<
operator|(
literal|1
operator|-
name|powerof2
argument_list|(
name|x
argument_list|)
operator|)
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|x86_emulate_cpuid
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vcpu_id
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|,
name|uint32_t
modifier|*
name|ebx
parameter_list|,
name|uint32_t
modifier|*
name|ecx
parameter_list|,
name|uint32_t
modifier|*
name|edx
parameter_list|)
block|{
specifier|const
name|struct
name|xsave_limits
modifier|*
name|limits
decl_stmt|;
name|uint64_t
name|cr4
decl_stmt|;
name|int
name|error
decl_stmt|,
name|enable_invpcid
decl_stmt|,
name|level
decl_stmt|,
name|width
decl_stmt|,
name|x2apic_id
decl_stmt|;
name|unsigned
name|int
name|func
decl_stmt|,
name|regs
index|[
literal|4
index|]
decl_stmt|,
name|logical_cpus
decl_stmt|;
name|enum
name|x2apic_state
name|x2apic_state
decl_stmt|;
name|VCPU_CTR2
argument_list|(
name|vm
argument_list|,
name|vcpu_id
argument_list|,
literal|"cpuid %#x,%#x"
argument_list|,
operator|*
name|eax
argument_list|,
operator|*
name|ecx
argument_list|)
expr_stmt|;
comment|/* 	 * Requests for invalid CPUID levels should map to the highest 	 * available level instead. 	 */
if|if
condition|(
name|cpu_exthigh
operator|!=
literal|0
operator|&&
operator|*
name|eax
operator|>=
literal|0x80000000
condition|)
block|{
if|if
condition|(
operator|*
name|eax
operator|>
name|cpu_exthigh
condition|)
operator|*
name|eax
operator|=
name|cpu_exthigh
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|eax
operator|>=
literal|0x40000000
condition|)
block|{
if|if
condition|(
operator|*
name|eax
operator|>
name|CPUID_VM_HIGH
condition|)
operator|*
name|eax
operator|=
name|CPUID_VM_HIGH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|eax
operator|>
name|cpu_high
condition|)
block|{
operator|*
name|eax
operator|=
name|cpu_high
expr_stmt|;
block|}
name|func
operator|=
operator|*
name|eax
expr_stmt|;
comment|/* 	 * In general the approach used for CPU topology is to 	 * advertise a flat topology where all CPUs are packages with 	 * no multi-core or SMT. 	 */
switch|switch
condition|(
name|func
condition|)
block|{
comment|/* 		 * Pass these through to the guest 		 */
case|case
name|CPUID_0000_0000
case|:
case|case
name|CPUID_0000_0002
case|:
case|case
name|CPUID_0000_0003
case|:
case|case
name|CPUID_8000_0000
case|:
case|case
name|CPUID_8000_0002
case|:
case|case
name|CPUID_8000_0003
case|:
case|case
name|CPUID_8000_0004
case|:
case|case
name|CPUID_8000_0006
case|:
name|cpuid_count
argument_list|(
operator|*
name|eax
argument_list|,
operator|*
name|ecx
argument_list|,
name|regs
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPUID_8000_0008
case|:
name|cpuid_count
argument_list|(
operator|*
name|eax
argument_list|,
operator|*
name|ecx
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmm_is_amd
argument_list|()
condition|)
block|{
comment|/* 				 * XXX this might appear silly because AMD 				 * cpus don't have threads. 				 * 				 * However this matches the logical cpus as 				 * advertised by leaf 0x1 and will work even 				 * if the 'threads_per_core' tunable is set 				 * incorrectly on an AMD host. 				 */
name|logical_cpus
operator|=
name|threads_per_core
operator|*
name|cores_per_package
expr_stmt|;
name|regs
index|[
literal|2
index|]
operator|=
name|logical_cpus
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CPUID_8000_0001
case|:
name|cpuid_count
argument_list|(
operator|*
name|eax
argument_list|,
operator|*
name|ecx
argument_list|,
name|regs
argument_list|)
expr_stmt|;
comment|/* 			 * Hide SVM and Topology Extension features from guest. 			 */
name|regs
index|[
literal|2
index|]
operator|&=
operator|~
operator|(
name|AMDID2_SVM
operator||
name|AMDID2_TOPOLOGY
operator|)
expr_stmt|;
comment|/* 			 * Don't advertise extended performance counter MSRs 			 * to the guest. 			 */
name|regs
index|[
literal|2
index|]
operator|&=
operator|~
name|AMDID2_PCXC
expr_stmt|;
name|regs
index|[
literal|2
index|]
operator|&=
operator|~
name|AMDID2_PNXC
expr_stmt|;
name|regs
index|[
literal|2
index|]
operator|&=
operator|~
name|AMDID2_PTSCEL2I
expr_stmt|;
comment|/* 			 * Don't advertise Instruction Based Sampling feature. 			 */
name|regs
index|[
literal|2
index|]
operator|&=
operator|~
name|AMDID2_IBS
expr_stmt|;
comment|/* NodeID MSR not available */
name|regs
index|[
literal|2
index|]
operator|&=
operator|~
name|AMDID2_NODE_ID
expr_stmt|;
comment|/* Don't advertise the OS visible workaround feature */
name|regs
index|[
literal|2
index|]
operator|&=
operator|~
name|AMDID2_OSVW
expr_stmt|;
comment|/* 			 * Hide rdtscp/ia32_tsc_aux until we know how 			 * to deal with them. 			 */
name|regs
index|[
literal|3
index|]
operator|&=
operator|~
name|AMDID_RDTSCP
expr_stmt|;
break|break;
case|case
name|CPUID_8000_0007
case|:
comment|/* 			 * AMD uses this leaf to advertise the processor's 			 * power monitoring and RAS capabilities. These 			 * features are hardware-specific and exposing 			 * them to a guest doesn't make a lot of sense. 			 * 			 * Intel uses this leaf only to advertise the 			 * "Invariant TSC" feature with all other bits 			 * being reserved (set to zero). 			 */
name|regs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 			 * "Invariant TSC" can be advertised to the guest if: 			 * - host TSC frequency is invariant 			 * - host TSCs are synchronized across physical cpus 			 * 			 * XXX This still falls short because the vcpu 			 * can observe the TSC moving backwards as it 			 * migrates across physical cpus. But at least 			 * it should discourage the guest from using the 			 * TSC to keep track of time. 			 */
if|if
condition|(
name|tsc_is_invariant
operator|&&
name|smp_tsc
condition|)
name|regs
index|[
literal|3
index|]
operator||=
name|AMDPM_TSC_INVARIANT
expr_stmt|;
break|break;
case|case
name|CPUID_0000_0001
case|:
name|do_cpuid
argument_list|(
literal|1
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|error
operator|=
name|vm_get_x2apic_state
argument_list|(
name|vm
argument_list|,
name|vcpu_id
argument_list|,
operator|&
name|x2apic_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|panic
argument_list|(
literal|"x86_emulate_cpuid: error %d "
literal|"fetching x2apic state"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Override the APIC ID only in ebx 			 */
name|regs
index|[
literal|1
index|]
operator|&=
operator|~
operator|(
name|CPUID_LOCAL_APIC_ID
operator|)
expr_stmt|;
name|regs
index|[
literal|1
index|]
operator||=
operator|(
name|vcpu_id
operator|<<
name|CPUID_0000_0001_APICID_SHIFT
operator|)
expr_stmt|;
comment|/* 			 * Don't expose VMX, SpeedStep or TME capability. 			 * Advertise x2APIC capability and Hypervisor guest. 			 */
name|regs
index|[
literal|2
index|]
operator|&=
operator|~
operator|(
name|CPUID2_VMX
operator||
name|CPUID2_EST
operator||
name|CPUID2_TM2
operator|)
expr_stmt|;
name|regs
index|[
literal|2
index|]
operator||=
name|CPUID2_HV
expr_stmt|;
if|if
condition|(
name|x2apic_state
operator|!=
name|X2APIC_DISABLED
condition|)
name|regs
index|[
literal|2
index|]
operator||=
name|CPUID2_X2APIC
expr_stmt|;
else|else
name|regs
index|[
literal|2
index|]
operator|&=
operator|~
name|CPUID2_X2APIC
expr_stmt|;
comment|/* 			 * Only advertise CPUID2_XSAVE in the guest if 			 * the host is using XSAVE. 			 */
if|if
condition|(
operator|!
operator|(
name|regs
index|[
literal|2
index|]
operator|&
name|CPUID2_OSXSAVE
operator|)
condition|)
name|regs
index|[
literal|2
index|]
operator|&=
operator|~
name|CPUID2_XSAVE
expr_stmt|;
comment|/* 			 * If CPUID2_XSAVE is being advertised and the 			 * guest has set CR4_XSAVE, set 			 * CPUID2_OSXSAVE. 			 */
name|regs
index|[
literal|2
index|]
operator|&=
operator|~
name|CPUID2_OSXSAVE
expr_stmt|;
if|if
condition|(
name|regs
index|[
literal|2
index|]
operator|&
name|CPUID2_XSAVE
condition|)
block|{
name|error
operator|=
name|vm_get_register
argument_list|(
name|vm
argument_list|,
name|vcpu_id
argument_list|,
name|VM_REG_GUEST_CR4
argument_list|,
operator|&
name|cr4
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"x86_emulate_cpuid: error %d "
literal|"fetching %%cr4"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr4
operator|&
name|CR4_XSAVE
condition|)
name|regs
index|[
literal|2
index|]
operator||=
name|CPUID2_OSXSAVE
expr_stmt|;
block|}
comment|/* 			 * Hide monitor/mwait until we know how to deal with 			 * these instructions. 			 */
name|regs
index|[
literal|2
index|]
operator|&=
operator|~
name|CPUID2_MON
expr_stmt|;
comment|/* 			 * Hide the performance and debug features. 			 */
name|regs
index|[
literal|2
index|]
operator|&=
operator|~
name|CPUID2_PDCM
expr_stmt|;
comment|/* 			 * No TSC deadline support in the APIC yet 			 */
name|regs
index|[
literal|2
index|]
operator|&=
operator|~
name|CPUID2_TSCDLT
expr_stmt|;
comment|/* 			 * Hide thermal monitoring 			 */
name|regs
index|[
literal|3
index|]
operator|&=
operator|~
operator|(
name|CPUID_ACPI
operator||
name|CPUID_TM
operator|)
expr_stmt|;
comment|/* 			 * Machine check handling is done in the host. 			 * Hide MTRR capability. 			 */
name|regs
index|[
literal|3
index|]
operator|&=
operator|~
operator|(
name|CPUID_MCA
operator||
name|CPUID_MCE
operator||
name|CPUID_MTRR
operator|)
expr_stmt|;
comment|/*                         * Hide the debug store capability.                         */
name|regs
index|[
literal|3
index|]
operator|&=
operator|~
name|CPUID_DS
expr_stmt|;
name|logical_cpus
operator|=
name|threads_per_core
operator|*
name|cores_per_package
expr_stmt|;
name|regs
index|[
literal|1
index|]
operator|&=
operator|~
name|CPUID_HTT_CORES
expr_stmt|;
name|regs
index|[
literal|1
index|]
operator||=
operator|(
name|logical_cpus
operator|&
literal|0xff
operator|)
operator|<<
literal|16
expr_stmt|;
name|regs
index|[
literal|3
index|]
operator||=
name|CPUID_HTT
expr_stmt|;
break|break;
case|case
name|CPUID_0000_0004
case|:
name|cpuid_count
argument_list|(
operator|*
name|eax
argument_list|,
operator|*
name|ecx
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
index|[
literal|0
index|]
operator|||
name|regs
index|[
literal|1
index|]
operator|||
name|regs
index|[
literal|2
index|]
operator|||
name|regs
index|[
literal|3
index|]
condition|)
block|{
name|regs
index|[
literal|0
index|]
operator|&=
literal|0x3ff
expr_stmt|;
name|regs
index|[
literal|0
index|]
operator||=
operator|(
name|cores_per_package
operator|-
literal|1
operator|)
operator|<<
literal|26
expr_stmt|;
comment|/* 				 * Cache topology: 				 * - L1 and L2 are shared only by the logical 				 *   processors in a single core. 				 * - L3 and above are shared by all logical 				 *   processors in the package. 				 */
name|logical_cpus
operator|=
name|threads_per_core
expr_stmt|;
name|level
operator|=
operator|(
name|regs
index|[
literal|0
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
name|level
operator|>=
literal|3
condition|)
name|logical_cpus
operator|*=
name|cores_per_package
expr_stmt|;
name|regs
index|[
literal|0
index|]
operator||=
operator|(
name|logical_cpus
operator|-
literal|1
operator|)
operator|<<
literal|14
expr_stmt|;
block|}
break|break;
case|case
name|CPUID_0000_0007
case|:
name|regs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* leaf 0 */
if|if
condition|(
operator|*
name|ecx
operator|==
literal|0
condition|)
block|{
name|cpuid_count
argument_list|(
operator|*
name|eax
argument_list|,
operator|*
name|ecx
argument_list|,
name|regs
argument_list|)
expr_stmt|;
comment|/* Only leaf 0 is supported */
name|regs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Expose known-safe features. 				 */
name|regs
index|[
literal|1
index|]
operator|&=
operator|(
name|CPUID_STDEXT_FSGSBASE
operator||
name|CPUID_STDEXT_BMI1
operator||
name|CPUID_STDEXT_HLE
operator||
name|CPUID_STDEXT_AVX2
operator||
name|CPUID_STDEXT_BMI2
operator||
name|CPUID_STDEXT_ERMS
operator||
name|CPUID_STDEXT_RTM
operator||
name|CPUID_STDEXT_AVX512F
operator||
name|CPUID_STDEXT_AVX512PF
operator||
name|CPUID_STDEXT_AVX512ER
operator||
name|CPUID_STDEXT_AVX512CD
operator|)
expr_stmt|;
name|regs
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Advertise INVPCID if it is enabled. */
name|error
operator|=
name|vm_get_capability
argument_list|(
name|vm
argument_list|,
name|vcpu_id
argument_list|,
name|VM_CAP_ENABLE_INVPCID
argument_list|,
operator|&
name|enable_invpcid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|enable_invpcid
condition|)
name|regs
index|[
literal|1
index|]
operator||=
name|CPUID_STDEXT_INVPCID
expr_stmt|;
block|}
break|break;
case|case
name|CPUID_0000_0006
case|:
case|case
name|CPUID_0000_000A
case|:
comment|/* 			 * Handle the access, but report 0 for 			 * all options 			 */
name|regs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CPUID_0000_000B
case|:
comment|/* 			 * Processor topology enumeration 			 */
if|if
condition|(
operator|*
name|ecx
operator|==
literal|0
condition|)
block|{
name|logical_cpus
operator|=
name|threads_per_core
expr_stmt|;
name|width
operator|=
name|log2
argument_list|(
name|logical_cpus
argument_list|)
expr_stmt|;
name|level
operator|=
name|CPUID_TYPE_SMT
expr_stmt|;
name|x2apic_id
operator|=
name|vcpu_id
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ecx
operator|==
literal|1
condition|)
block|{
name|logical_cpus
operator|=
name|threads_per_core
operator|*
name|cores_per_package
expr_stmt|;
name|width
operator|=
name|log2
argument_list|(
name|logical_cpus
argument_list|)
expr_stmt|;
name|level
operator|=
name|CPUID_TYPE_CORE
expr_stmt|;
name|x2apic_id
operator|=
name|vcpu_id
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cpuid_leaf_b
operator|||
operator|*
name|ecx
operator|>=
literal|2
condition|)
block|{
name|width
operator|=
literal|0
expr_stmt|;
name|logical_cpus
operator|=
literal|0
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
name|x2apic_id
operator|=
literal|0
expr_stmt|;
block|}
name|regs
index|[
literal|0
index|]
operator|=
name|width
operator|&
literal|0x1f
expr_stmt|;
name|regs
index|[
literal|1
index|]
operator|=
name|logical_cpus
operator|&
literal|0xffff
expr_stmt|;
name|regs
index|[
literal|2
index|]
operator|=
operator|(
name|level
operator|<<
literal|8
operator|)
operator||
operator|(
operator|*
name|ecx
operator|&
literal|0xff
operator|)
expr_stmt|;
name|regs
index|[
literal|3
index|]
operator|=
name|x2apic_id
expr_stmt|;
break|break;
case|case
name|CPUID_0000_000D
case|:
name|limits
operator|=
name|vmm_get_xsave_limits
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|limits
operator|->
name|xsave_enabled
condition|)
block|{
name|regs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|cpuid_count
argument_list|(
operator|*
name|eax
argument_list|,
operator|*
name|ecx
argument_list|,
name|regs
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|ecx
condition|)
block|{
case|case
literal|0
case|:
comment|/* 				 * Only permit the guest to use bits 				 * that are active in the host in 				 * %xcr0.  Also, claim that the 				 * maximum save area size is 				 * equivalent to the host's current 				 * save area size.  Since this runs 				 * "inside" of vmrun(), it runs with 				 * the guest's xcr0, so the current 				 * save area size is correct as-is. 				 */
name|regs
index|[
literal|0
index|]
operator|&=
name|limits
operator|->
name|xcr0_allowed
expr_stmt|;
name|regs
index|[
literal|2
index|]
operator|=
name|limits
operator|->
name|xsave_max_size
expr_stmt|;
name|regs
index|[
literal|3
index|]
operator|&=
operator|(
name|limits
operator|->
name|xcr0_allowed
operator|>>
literal|32
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Only permit XSAVEOPT. */
name|regs
index|[
literal|0
index|]
operator|&=
name|CPUID_EXTSTATE_XSAVEOPT
expr_stmt|;
name|regs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* 				 * If the leaf is for a permitted feature, 				 * pass through as-is, otherwise return 				 * all zeroes. 				 */
if|if
condition|(
operator|!
operator|(
name|limits
operator|->
name|xcr0_allowed
operator|&
operator|(
literal|1ul
operator|<<
operator|*
name|ecx
operator|)
operator|)
condition|)
block|{
name|regs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
literal|0x40000000
case|:
name|regs
index|[
literal|0
index|]
operator|=
name|CPUID_VM_HIGH
expr_stmt|;
name|bcopy
argument_list|(
name|bhyve_id
argument_list|,
operator|&
name|regs
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bhyve_id
operator|+
literal|4
argument_list|,
operator|&
name|regs
index|[
literal|2
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bhyve_id
operator|+
literal|8
argument_list|,
operator|&
name|regs
index|[
literal|3
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 			 * The leaf value has already been clamped so 			 * simply pass this through, keeping count of 			 * how many unhandled leaf values have been seen. 			 */
name|atomic_add_long
argument_list|(
operator|&
name|bhyve_xcpuids
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cpuid_count
argument_list|(
operator|*
name|eax
argument_list|,
operator|*
name|ecx
argument_list|,
name|regs
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|eax
operator|=
name|regs
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|ebx
operator|=
name|regs
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|ecx
operator|=
name|regs
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|edx
operator|=
name|regs
index|[
literal|3
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

