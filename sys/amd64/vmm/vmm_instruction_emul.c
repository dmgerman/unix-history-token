begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Sandvine, Inc.  * Copyright (c) 2012 NetApp, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_KERNEL */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/_iovec.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<vmmapi.h>
end_include

begin_define
define|#
directive|define
name|KASSERT
parameter_list|(
name|exp
parameter_list|,
name|msg
parameter_list|)
value|assert((exp))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|<machine/vmm_instruction_emul.h>
end_include

begin_include
include|#
directive|include
file|<x86/psl.h>
end_include

begin_include
include|#
directive|include
file|<x86/specialreg.h>
end_include

begin_comment
comment|/* struct vie_op.op_type */
end_comment

begin_enum
enum|enum
block|{
name|VIE_OP_TYPE_NONE
init|=
literal|0
block|,
name|VIE_OP_TYPE_MOV
block|,
name|VIE_OP_TYPE_MOVSX
block|,
name|VIE_OP_TYPE_MOVZX
block|,
name|VIE_OP_TYPE_AND
block|,
name|VIE_OP_TYPE_OR
block|,
name|VIE_OP_TYPE_SUB
block|,
name|VIE_OP_TYPE_TWO_BYTE
block|,
name|VIE_OP_TYPE_PUSH
block|,
name|VIE_OP_TYPE_CMP
block|,
name|VIE_OP_TYPE_POP
block|,
name|VIE_OP_TYPE_MOVS
block|,
name|VIE_OP_TYPE_GROUP1
block|,
name|VIE_OP_TYPE_STOS
block|,
name|VIE_OP_TYPE_BITTEST
block|,
name|VIE_OP_TYPE_LAST
block|}
enum|;
end_enum

begin_comment
comment|/* struct vie_op.op_flags */
end_comment

begin_define
define|#
directive|define
name|VIE_OP_F_IMM
value|(1<< 0)
end_define

begin_comment
comment|/* 16/32-bit immediate operand */
end_comment

begin_define
define|#
directive|define
name|VIE_OP_F_IMM8
value|(1<< 1)
end_define

begin_comment
comment|/* 8-bit immediate operand */
end_comment

begin_define
define|#
directive|define
name|VIE_OP_F_MOFFSET
value|(1<< 2)
end_define

begin_comment
comment|/* 16/32/64-bit immediate moffset */
end_comment

begin_define
define|#
directive|define
name|VIE_OP_F_NO_MODRM
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|VIE_OP_F_NO_GLA_VERIFICATION
value|(1<< 4)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|vie_op
name|two_byte_opcodes
index|[
literal|256
index|]
init|=
block|{
index|[
literal|0xB6
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0xB6
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_MOVZX
block|, 	}
block|,
index|[
literal|0xB7
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0xB7
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_MOVZX
block|, 	}
block|,
index|[
literal|0xBA
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0xBA
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_BITTEST
block|,
operator|.
name|op_flags
operator|=
name|VIE_OP_F_IMM8
block|, 	}
block|,
index|[
literal|0xBE
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0xBE
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_MOVSX
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|vie_op
name|one_byte_opcodes
index|[
literal|256
index|]
init|=
block|{
index|[
literal|0x0F
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0x0F
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_TWO_BYTE
block|}
block|,
index|[
literal|0x2B
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0x2B
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_SUB
block|, 	}
block|,
index|[
literal|0x3B
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0x3B
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_CMP
block|, 	}
block|,
index|[
literal|0x88
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0x88
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_MOV
block|, 	}
block|,
index|[
literal|0x89
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0x89
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_MOV
block|, 	}
block|,
index|[
literal|0x8A
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0x8A
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_MOV
block|, 	}
block|,
index|[
literal|0x8B
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0x8B
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_MOV
block|, 	}
block|,
index|[
literal|0xA1
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0xA1
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_MOV
block|,
operator|.
name|op_flags
operator|=
name|VIE_OP_F_MOFFSET
operator||
name|VIE_OP_F_NO_MODRM
block|, 	}
block|,
index|[
literal|0xA3
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0xA3
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_MOV
block|,
operator|.
name|op_flags
operator|=
name|VIE_OP_F_MOFFSET
operator||
name|VIE_OP_F_NO_MODRM
block|, 	}
block|,
index|[
literal|0xA4
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0xA4
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_MOVS
block|,
operator|.
name|op_flags
operator|=
name|VIE_OP_F_NO_MODRM
operator||
name|VIE_OP_F_NO_GLA_VERIFICATION
block|}
block|,
index|[
literal|0xA5
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0xA5
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_MOVS
block|,
operator|.
name|op_flags
operator|=
name|VIE_OP_F_NO_MODRM
operator||
name|VIE_OP_F_NO_GLA_VERIFICATION
block|}
block|,
index|[
literal|0xAA
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0xAA
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_STOS
block|,
operator|.
name|op_flags
operator|=
name|VIE_OP_F_NO_MODRM
operator||
name|VIE_OP_F_NO_GLA_VERIFICATION
block|}
block|,
index|[
literal|0xAB
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0xAB
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_STOS
block|,
operator|.
name|op_flags
operator|=
name|VIE_OP_F_NO_MODRM
operator||
name|VIE_OP_F_NO_GLA_VERIFICATION
block|}
block|,
index|[
literal|0xC6
index|]
operator|=
block|{
comment|/* XXX Group 11 extended opcode - not just MOV */
operator|.
name|op_byte
operator|=
literal|0xC6
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_MOV
block|,
operator|.
name|op_flags
operator|=
name|VIE_OP_F_IMM8
block|, 	}
block|,
index|[
literal|0xC7
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0xC7
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_MOV
block|,
operator|.
name|op_flags
operator|=
name|VIE_OP_F_IMM
block|, 	}
block|,
index|[
literal|0x23
index|]
operator|=
block|{
operator|.
name|op_byte
operator|=
literal|0x23
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_AND
block|, 	}
block|,
index|[
literal|0x80
index|]
operator|=
block|{
comment|/* Group 1 extended opcode */
operator|.
name|op_byte
operator|=
literal|0x80
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_GROUP1
block|,
operator|.
name|op_flags
operator|=
name|VIE_OP_F_IMM8
block|, 	}
block|,
index|[
literal|0x81
index|]
operator|=
block|{
comment|/* Group 1 extended opcode */
operator|.
name|op_byte
operator|=
literal|0x81
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_GROUP1
block|,
operator|.
name|op_flags
operator|=
name|VIE_OP_F_IMM
block|, 	}
block|,
index|[
literal|0x83
index|]
operator|=
block|{
comment|/* Group 1 extended opcode */
operator|.
name|op_byte
operator|=
literal|0x83
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_GROUP1
block|,
operator|.
name|op_flags
operator|=
name|VIE_OP_F_IMM8
block|, 	}
block|,
index|[
literal|0x8F
index|]
operator|=
block|{
comment|/* XXX Group 1A extended opcode - not just POP */
operator|.
name|op_byte
operator|=
literal|0x8F
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_POP
block|, 	}
block|,
index|[
literal|0xFF
index|]
operator|=
block|{
comment|/* XXX Group 5 extended opcode - not just PUSH */
operator|.
name|op_byte
operator|=
literal|0xFF
block|,
operator|.
name|op_type
operator|=
name|VIE_OP_TYPE_PUSH
block|, 	}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* struct vie.mod */
end_comment

begin_define
define|#
directive|define
name|VIE_MOD_INDIRECT
value|0
end_define

begin_define
define|#
directive|define
name|VIE_MOD_INDIRECT_DISP8
value|1
end_define

begin_define
define|#
directive|define
name|VIE_MOD_INDIRECT_DISP32
value|2
end_define

begin_define
define|#
directive|define
name|VIE_MOD_DIRECT
value|3
end_define

begin_comment
comment|/* struct vie.rm */
end_comment

begin_define
define|#
directive|define
name|VIE_RM_SIB
value|4
end_define

begin_define
define|#
directive|define
name|VIE_RM_DISP32
value|5
end_define

begin_define
define|#
directive|define
name|GB
value|(1024 * 1024 * 1024)
end_define

begin_decl_stmt
specifier|static
name|enum
name|vm_reg_name
name|gpr_map
index|[
literal|16
index|]
init|=
block|{
name|VM_REG_GUEST_RAX
block|,
name|VM_REG_GUEST_RCX
block|,
name|VM_REG_GUEST_RDX
block|,
name|VM_REG_GUEST_RBX
block|,
name|VM_REG_GUEST_RSP
block|,
name|VM_REG_GUEST_RBP
block|,
name|VM_REG_GUEST_RSI
block|,
name|VM_REG_GUEST_RDI
block|,
name|VM_REG_GUEST_R8
block|,
name|VM_REG_GUEST_R9
block|,
name|VM_REG_GUEST_R10
block|,
name|VM_REG_GUEST_R11
block|,
name|VM_REG_GUEST_R12
block|,
name|VM_REG_GUEST_R13
block|,
name|VM_REG_GUEST_R14
block|,
name|VM_REG_GUEST_R15
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|size2mask
index|[]
init|=
block|{
index|[
literal|1
index|]
operator|=
literal|0xff
block|,
index|[
literal|2
index|]
operator|=
literal|0xffff
block|,
index|[
literal|4
index|]
operator|=
literal|0xffffffff
block|,
index|[
literal|8
index|]
operator|=
literal|0xffffffffffffffff
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|vie_read_register
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|enum
name|vm_reg_name
name|reg
parameter_list|,
name|uint64_t
modifier|*
name|rval
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|vm_get_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
name|rval
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vie_calc_bytereg
parameter_list|(
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|enum
name|vm_reg_name
modifier|*
name|reg
parameter_list|,
name|int
modifier|*
name|lhbr
parameter_list|)
block|{
operator|*
name|lhbr
operator|=
literal|0
expr_stmt|;
operator|*
name|reg
operator|=
name|gpr_map
index|[
name|vie
operator|->
name|reg
index|]
expr_stmt|;
comment|/* 	 * 64-bit mode imposes limitations on accessing legacy high byte 	 * registers (lhbr). 	 * 	 * The legacy high-byte registers cannot be addressed if the REX 	 * prefix is present. In this case the values 4, 5, 6 and 7 of the 	 * 'ModRM:reg' field address %spl, %bpl, %sil and %dil respectively. 	 * 	 * If the REX prefix is not present then the values 4, 5, 6 and 7 	 * of the 'ModRM:reg' field address the legacy high-byte registers, 	 * %ah, %ch, %dh and %bh respectively. 	 */
if|if
condition|(
operator|!
name|vie
operator|->
name|rex_present
condition|)
block|{
if|if
condition|(
name|vie
operator|->
name|reg
operator|&
literal|0x4
condition|)
block|{
operator|*
name|lhbr
operator|=
literal|1
expr_stmt|;
operator|*
name|reg
operator|=
name|gpr_map
index|[
name|vie
operator|->
name|reg
operator|&
literal|0x3
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vie_read_bytereg
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|uint8_t
modifier|*
name|rval
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|int
name|error
decl_stmt|,
name|lhbr
decl_stmt|;
name|enum
name|vm_reg_name
name|reg
decl_stmt|;
name|vie_calc_bytereg
argument_list|(
name|vie
argument_list|,
operator|&
name|reg
argument_list|,
operator|&
name|lhbr
argument_list|)
expr_stmt|;
name|error
operator|=
name|vm_get_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* 	 * To obtain the value of a legacy high byte register shift the 	 * base register right by 8 bits (%ah = %rax>> 8). 	 */
if|if
condition|(
name|lhbr
condition|)
operator|*
name|rval
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
else|else
operator|*
name|rval
operator|=
name|val
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vie_write_bytereg
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|uint8_t
name|byte
parameter_list|)
block|{
name|uint64_t
name|origval
decl_stmt|,
name|val
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|error
decl_stmt|,
name|lhbr
decl_stmt|;
name|enum
name|vm_reg_name
name|reg
decl_stmt|;
name|vie_calc_bytereg
argument_list|(
name|vie
argument_list|,
operator|&
name|reg
argument_list|,
operator|&
name|lhbr
argument_list|)
expr_stmt|;
name|error
operator|=
name|vm_get_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
operator|&
name|origval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|byte
expr_stmt|;
name|mask
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|lhbr
condition|)
block|{
comment|/* 			 * Shift left by 8 to store 'byte' in a legacy high 			 * byte register. 			 */
name|val
operator|<<=
literal|8
expr_stmt|;
name|mask
operator|<<=
literal|8
expr_stmt|;
block|}
name|val
operator||=
name|origval
operator|&
operator|~
name|mask
expr_stmt|;
name|error
operator|=
name|vm_set_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vie_update_register
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|enum
name|vm_reg_name
name|reg
parameter_list|,
name|uint64_t
name|val
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
name|origval
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
operator|&
name|origval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|val
operator|&=
name|size2mask
index|[
name|size
index|]
expr_stmt|;
name|val
operator||=
name|origval
operator|&
operator|~
name|size2mask
index|[
name|size
index|]
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|val
operator|&=
literal|0xffffffffUL
expr_stmt|;
break|break;
case|case
literal|8
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|vm_set_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|RFLAGS_STATUS_BITS
value|(PSL_C | PSL_PF | PSL_AF | PSL_Z | PSL_N | PSL_V)
end_define

begin_comment
comment|/*  * Return the status flags that would result from doing (x - y).  */
end_comment

begin_define
define|#
directive|define
name|GETCC
parameter_list|(
name|sz
parameter_list|)
define|\
value|static u_long								\ getcc##sz(uint##sz##_t x, uint##sz##_t y)				\ {									\ 	u_long rflags;							\ 									\ 	__asm __volatile("sub %2,%1; pushfq; popq %0" :			\ 	    "=r" (rflags), "+r" (x) : "m" (y));				\ 	return (rflags);						\ } struct __hack
end_define

begin_expr_stmt
name|GETCC
argument_list|(
literal|8
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|GETCC
argument_list|(
literal|16
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|GETCC
argument_list|(
literal|32
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|GETCC
argument_list|(
literal|64
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|u_long
name|getcc
parameter_list|(
name|int
name|opsize
parameter_list|,
name|uint64_t
name|x
parameter_list|,
name|uint64_t
name|y
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|opsize
operator|==
literal|1
operator|||
name|opsize
operator|==
literal|2
operator|||
name|opsize
operator|==
literal|4
operator|||
name|opsize
operator|==
literal|8
argument_list|,
operator|(
literal|"getcc: invalid operand size %d"
operator|,
name|opsize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opsize
operator|==
literal|1
condition|)
return|return
operator|(
name|getcc8
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|opsize
operator|==
literal|2
condition|)
return|return
operator|(
name|getcc16
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|opsize
operator|==
literal|4
condition|)
return|return
operator|(
name|getcc32
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|getcc64
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_mov
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|mem_region_read_t
name|memread
parameter_list|,
name|mem_region_write_t
name|memwrite
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|size
decl_stmt|;
name|enum
name|vm_reg_name
name|reg
decl_stmt|;
name|uint8_t
name|byte
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|size
operator|=
name|vie
operator|->
name|opsize
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
switch|switch
condition|(
name|vie
operator|->
name|op
operator|.
name|op_byte
condition|)
block|{
case|case
literal|0x88
case|:
comment|/* 		 * MOV byte from reg (ModRM:reg) to mem (ModRM:r/m) 		 * 88/r:	mov r/m8, r8 		 * REX + 88/r:	mov r/m8, r8 (%ah, %ch, %dh, %bh not available) 		 */
name|size
operator|=
literal|1
expr_stmt|;
comment|/* override for byte operation */
name|error
operator|=
name|vie_read_bytereg
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|vie
argument_list|,
operator|&
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|memwrite
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|byte
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x89
case|:
comment|/* 		 * MOV from reg (ModRM:reg) to mem (ModRM:r/m) 		 * 89/r:	mov r/m16, r16 		 * 89/r:	mov r/m32, r32 		 * REX.W + 89/r	mov r/m64, r64 		 */
name|reg
operator|=
name|gpr_map
index|[
name|vie
operator|->
name|reg
index|]
expr_stmt|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|val
operator|&=
name|size2mask
index|[
name|size
index|]
expr_stmt|;
name|error
operator|=
name|memwrite
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|val
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x8A
case|:
comment|/* 		 * MOV byte from mem (ModRM:r/m) to reg (ModRM:reg) 		 * 8A/r:	mov r8, r/m8 		 * REX + 8A/r:	mov r8, r/m8 		 */
name|size
operator|=
literal|1
expr_stmt|;
comment|/* override for byte operation */
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
operator|&
name|val
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|vie_write_bytereg
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|vie
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x8B
case|:
comment|/* 		 * MOV from mem (ModRM:r/m) to reg (ModRM:reg) 		 * 8B/r:	mov r16, r/m16 		 * 8B/r:	mov r32, r/m32 		 * REX.W 8B/r:	mov r64, r/m64 		 */
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
operator|&
name|val
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|gpr_map
index|[
name|vie
operator|->
name|reg
index|]
expr_stmt|;
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0xA1
case|:
comment|/* 		 * MOV from seg:moffset to AX/EAX/RAX 		 * A1:		mov AX, moffs16 		 * A1:		mov EAX, moffs32 		 * REX.W + A1:	mov RAX, moffs64 		 */
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
operator|&
name|val
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|VM_REG_GUEST_RAX
expr_stmt|;
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0xA3
case|:
comment|/* 		 * MOV from AX/EAX/RAX to seg:moffset 		 * A3:		mov moffs16, AX 		 * A3:		mov moffs32, EAX  		 * REX.W + A3:	mov moffs64, RAX 		 */
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RAX
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|val
operator|&=
name|size2mask
index|[
name|size
index|]
expr_stmt|;
name|error
operator|=
name|memwrite
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|val
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0xC6
case|:
comment|/* 		 * MOV from imm8 to mem (ModRM:r/m) 		 * C6/0		mov r/m8, imm8 		 * REX + C6/0	mov r/m8, imm8 		 */
name|size
operator|=
literal|1
expr_stmt|;
comment|/* override for byte operation */
name|error
operator|=
name|memwrite
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
operator|->
name|immediate
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xC7
case|:
comment|/* 		 * MOV from imm16/imm32 to mem (ModRM:r/m) 		 * C7/0		mov r/m16, imm16 		 * C7/0		mov r/m32, imm32 		 * REX.W + C7/0	mov r/m64, imm32 (sign-extended to 64-bits) 		 */
name|val
operator|=
name|vie
operator|->
name|immediate
operator|&
name|size2mask
index|[
name|size
index|]
expr_stmt|;
name|error
operator|=
name|memwrite
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|val
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_movx
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|mem_region_read_t
name|memread
parameter_list|,
name|mem_region_write_t
name|memwrite
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|size
decl_stmt|;
name|enum
name|vm_reg_name
name|reg
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|size
operator|=
name|vie
operator|->
name|opsize
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
switch|switch
condition|(
name|vie
operator|->
name|op
operator|.
name|op_byte
condition|)
block|{
case|case
literal|0xB6
case|:
comment|/* 		 * MOV and zero extend byte from mem (ModRM:r/m) to 		 * reg (ModRM:reg). 		 * 		 * 0F B6/r		movzx r16, r/m8 		 * 0F B6/r		movzx r32, r/m8 		 * REX.W + 0F B6/r	movzx r64, r/m8 		 */
comment|/* get the first operand */
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* get the second operand */
name|reg
operator|=
name|gpr_map
index|[
name|vie
operator|->
name|reg
index|]
expr_stmt|;
comment|/* zero-extend byte */
name|val
operator|=
operator|(
name|uint8_t
operator|)
name|val
expr_stmt|;
comment|/* write the result */
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xB7
case|:
comment|/* 		 * MOV and zero extend word from mem (ModRM:r/m) to 		 * reg (ModRM:reg). 		 * 		 * 0F B7/r		movzx r32, r/m16 		 * REX.W + 0F B7/r	movzx r64, r/m16 		 */
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|reg
operator|=
name|gpr_map
index|[
name|vie
operator|->
name|reg
index|]
expr_stmt|;
comment|/* zero-extend word */
name|val
operator|=
operator|(
name|uint16_t
operator|)
name|val
expr_stmt|;
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xBE
case|:
comment|/* 		 * MOV and sign extend byte from mem (ModRM:r/m) to 		 * reg (ModRM:reg). 		 * 		 * 0F BE/r		movsx r16, r/m8 		 * 0F BE/r		movsx r32, r/m8 		 * REX.W + 0F BE/r	movsx r64, r/m8 		 */
comment|/* get the first operand */
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* get the second operand */
name|reg
operator|=
name|gpr_map
index|[
name|vie
operator|->
name|reg
index|]
expr_stmt|;
comment|/* sign extend byte */
name|val
operator|=
operator|(
name|int8_t
operator|)
name|val
expr_stmt|;
comment|/* write the result */
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Helper function to calculate and validate a linear address.  *  * Returns 0 on success and 1 if an exception was injected into the guest.  */
end_comment

begin_function
specifier|static
name|int
name|get_gla
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|,
name|int
name|opsize
parameter_list|,
name|int
name|addrsize
parameter_list|,
name|int
name|prot
parameter_list|,
name|enum
name|vm_reg_name
name|seg
parameter_list|,
name|enum
name|vm_reg_name
name|gpr
parameter_list|,
name|uint64_t
modifier|*
name|gla
parameter_list|)
block|{
name|struct
name|seg_desc
name|desc
decl_stmt|;
name|uint64_t
name|cr0
decl_stmt|,
name|val
decl_stmt|,
name|rflags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_CR0
argument_list|,
operator|&
name|cr0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d getting cr0"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|,
operator|&
name|rflags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d getting rflags"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vm_get_seg_desc
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|seg
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d getting segment descriptor %d"
operator|,
name|__func__
operator|,
name|error
operator|,
name|seg
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpr
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d getting register %d"
operator|,
name|__func__
operator|,
name|error
operator|,
name|gpr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vie_calculate_gla
argument_list|(
name|paging
operator|->
name|cpu_mode
argument_list|,
name|seg
argument_list|,
operator|&
name|desc
argument_list|,
name|val
argument_list|,
name|opsize
argument_list|,
name|addrsize
argument_list|,
name|prot
argument_list|,
name|gla
argument_list|)
condition|)
block|{
if|if
condition|(
name|seg
operator|==
name|VM_REG_GUEST_SS
condition|)
name|vm_inject_ss
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|vm_inject_gp
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|vie_canonical_check
argument_list|(
name|paging
operator|->
name|cpu_mode
argument_list|,
operator|*
name|gla
argument_list|)
condition|)
block|{
if|if
condition|(
name|seg
operator|==
name|VM_REG_GUEST_SS
condition|)
name|vm_inject_ss
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|vm_inject_gp
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|vie_alignment_check
argument_list|(
name|paging
operator|->
name|cpl
argument_list|,
name|opsize
argument_list|,
name|cr0
argument_list|,
name|rflags
argument_list|,
operator|*
name|gla
argument_list|)
condition|)
block|{
name|vm_inject_ac
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_movs
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|,
name|mem_region_read_t
name|memread
parameter_list|,
name|mem_region_write_t
name|memwrite
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|struct
name|vm_copyinfo
name|copyinfo
index|[
literal|2
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|iovec
name|copyinfo
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|uint64_t
name|dstaddr
decl_stmt|,
name|srcaddr
decl_stmt|,
name|dstgpa
decl_stmt|,
name|srcgpa
decl_stmt|,
name|val
decl_stmt|;
name|uint64_t
name|rcx
decl_stmt|,
name|rdi
decl_stmt|,
name|rsi
decl_stmt|,
name|rflags
decl_stmt|;
name|int
name|error
decl_stmt|,
name|opsize
decl_stmt|,
name|seg
decl_stmt|,
name|repeat
decl_stmt|;
name|opsize
operator|=
operator|(
name|vie
operator|->
name|op
operator|.
name|op_byte
operator|==
literal|0xA4
operator|)
condition|?
literal|1
else|:
name|vie
operator|->
name|opsize
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * XXX although the MOVS instruction is only supposed to be used with 	 * the "rep" prefix some guests like FreeBSD will use "repnz" instead. 	 * 	 * Empirically the "repnz" prefix has identical behavior to "rep" 	 * and the zero flag does not make a difference. 	 */
name|repeat
operator|=
name|vie
operator|->
name|repz_present
operator||
name|vie
operator|->
name|repnz_present
expr_stmt|;
if|if
condition|(
name|repeat
condition|)
block|{
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RCX
argument_list|,
operator|&
name|rcx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|error
argument_list|,
operator|(
literal|"%s: error %d getting rcx"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * The count register is %rcx, %ecx or %cx depending on the 		 * address size of the instruction. 		 */
if|if
condition|(
operator|(
name|rcx
operator|&
name|vie_size2mask
argument_list|(
name|vie
operator|->
name|addrsize
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 *	Source		Destination	Comments 	 *	-------------------------------------------- 	 * (1)  memory		memory		n/a 	 * (2)  memory		mmio		emulated 	 * (3)  mmio		memory		emulated 	 * (4)  mmio		mmio		emulated 	 * 	 * At this point we don't have sufficient information to distinguish 	 * between (2), (3) and (4). We use 'vm_copy_setup()' to tease this 	 * out because it will succeed only when operating on regular memory. 	 * 	 * XXX the emulation doesn't properly handle the case where 'gpa' 	 * is straddling the boundary between the normal memory and MMIO. 	 */
name|seg
operator|=
name|vie
operator|->
name|segment_override
condition|?
name|vie
operator|->
name|segment_register
else|:
name|VM_REG_GUEST_DS
expr_stmt|;
name|error
operator|=
name|get_gla
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|vie
argument_list|,
name|paging
argument_list|,
name|opsize
argument_list|,
name|vie
operator|->
name|addrsize
argument_list|,
name|PROT_READ
argument_list|,
name|seg
argument_list|,
name|VM_REG_GUEST_RSI
argument_list|,
operator|&
name|srcaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|error
operator|=
name|vm_copy_setup
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|paging
argument_list|,
name|srcaddr
argument_list|,
name|opsize
argument_list|,
name|PROT_READ
argument_list|,
name|copyinfo
argument_list|,
name|nitems
argument_list|(
name|copyinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * case (2): read from system memory and write to mmio. 		 */
name|vm_copyin
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|copyinfo
argument_list|,
operator|&
name|val
argument_list|,
name|opsize
argument_list|)
expr_stmt|;
name|vm_copy_teardown
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|copyinfo
argument_list|,
name|nitems
argument_list|(
name|copyinfo
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|memwrite
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|val
argument_list|,
name|opsize
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Resume guest execution to handle fault. 		 */
goto|goto
name|done
goto|;
block|}
else|else
block|{
comment|/* 		 * 'vm_copy_setup()' is expected to fail for cases (3) and (4) 		 * if 'srcaddr' is in the mmio space. 		 */
name|error
operator|=
name|get_gla
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|vie
argument_list|,
name|paging
argument_list|,
name|opsize
argument_list|,
name|vie
operator|->
name|addrsize
argument_list|,
name|PROT_WRITE
argument_list|,
name|VM_REG_GUEST_ES
argument_list|,
name|VM_REG_GUEST_RDI
argument_list|,
operator|&
name|dstaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|error
operator|=
name|vm_copy_setup
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|paging
argument_list|,
name|dstaddr
argument_list|,
name|opsize
argument_list|,
name|PROT_WRITE
argument_list|,
name|copyinfo
argument_list|,
name|nitems
argument_list|(
name|copyinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 			 * case (3): read from MMIO and write to system memory. 			 * 			 * A MMIO read can have side-effects so we 			 * commit to it only after vm_copy_setup() is 			 * successful. If a page-fault needs to be 			 * injected into the guest then it will happen 			 * before the MMIO read is attempted. 			 */
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
operator|&
name|val
argument_list|,
name|opsize
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|vm_copyout
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
operator|&
name|val
argument_list|,
name|copyinfo
argument_list|,
name|opsize
argument_list|)
expr_stmt|;
name|vm_copy_teardown
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|copyinfo
argument_list|,
name|nitems
argument_list|(
name|copyinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Resume guest execution to handle fault. 			 */
goto|goto
name|done
goto|;
block|}
else|else
block|{
comment|/* 			 * Case (4): read from and write to mmio. 			 */
name|error
operator|=
name|vm_gla2gpa
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|paging
argument_list|,
name|srcaddr
argument_list|,
name|PROT_READ
argument_list|,
operator|&
name|srcgpa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|srcgpa
argument_list|,
operator|&
name|val
argument_list|,
name|opsize
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|error
operator|=
name|vm_gla2gpa
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|paging
argument_list|,
name|dstaddr
argument_list|,
name|PROT_WRITE
argument_list|,
operator|&
name|dstgpa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|error
operator|=
name|memwrite
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|dstgpa
argument_list|,
name|val
argument_list|,
name|opsize
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
block|}
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RSI
argument_list|,
operator|&
name|rsi
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d getting rsi"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RDI
argument_list|,
operator|&
name|rdi
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d getting rdi"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|,
operator|&
name|rflags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d getting rflags"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflags
operator|&
name|PSL_D
condition|)
block|{
name|rsi
operator|-=
name|opsize
expr_stmt|;
name|rdi
operator|-=
name|opsize
expr_stmt|;
block|}
else|else
block|{
name|rsi
operator|+=
name|opsize
expr_stmt|;
name|rdi
operator|+=
name|opsize
expr_stmt|;
block|}
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RSI
argument_list|,
name|rsi
argument_list|,
name|vie
operator|->
name|addrsize
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d updating rsi"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RDI
argument_list|,
name|rdi
argument_list|,
name|vie
operator|->
name|addrsize
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d updating rdi"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|repeat
condition|)
block|{
name|rcx
operator|=
name|rcx
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RCX
argument_list|,
name|rcx
argument_list|,
name|vie
operator|->
name|addrsize
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|error
argument_list|,
operator|(
literal|"%s: error %d updating rcx"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Repeat the instruction if the count register is not zero. 		 */
if|if
condition|(
operator|(
name|rcx
operator|&
name|vie_size2mask
argument_list|(
name|vie
operator|->
name|addrsize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|vm_restart_instruction
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|error
operator|<
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_stos
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|,
name|mem_region_read_t
name|memread
parameter_list|,
name|mem_region_write_t
name|memwrite
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|opsize
decl_stmt|,
name|repeat
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|uint64_t
name|rcx
decl_stmt|,
name|rdi
decl_stmt|,
name|rflags
decl_stmt|;
name|opsize
operator|=
operator|(
name|vie
operator|->
name|op
operator|.
name|op_byte
operator|==
literal|0xAA
operator|)
condition|?
literal|1
else|:
name|vie
operator|->
name|opsize
expr_stmt|;
name|repeat
operator|=
name|vie
operator|->
name|repz_present
operator||
name|vie
operator|->
name|repnz_present
expr_stmt|;
if|if
condition|(
name|repeat
condition|)
block|{
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RCX
argument_list|,
operator|&
name|rcx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|error
argument_list|,
operator|(
literal|"%s: error %d getting rcx"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * The count register is %rcx, %ecx or %cx depending on the 		 * address size of the instruction. 		 */
if|if
condition|(
operator|(
name|rcx
operator|&
name|vie_size2mask
argument_list|(
name|vie
operator|->
name|addrsize
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RAX
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|error
argument_list|,
operator|(
literal|"%s: error %d getting rax"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|memwrite
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|val
argument_list|,
name|opsize
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RDI
argument_list|,
operator|&
name|rdi
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d getting rdi"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|,
operator|&
name|rflags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d getting rflags"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflags
operator|&
name|PSL_D
condition|)
name|rdi
operator|-=
name|opsize
expr_stmt|;
else|else
name|rdi
operator|+=
name|opsize
expr_stmt|;
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RDI
argument_list|,
name|rdi
argument_list|,
name|vie
operator|->
name|addrsize
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d updating rdi"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|repeat
condition|)
block|{
name|rcx
operator|=
name|rcx
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RCX
argument_list|,
name|rcx
argument_list|,
name|vie
operator|->
name|addrsize
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|error
argument_list|,
operator|(
literal|"%s: error %d updating rcx"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Repeat the instruction if the count register is not zero. 		 */
if|if
condition|(
operator|(
name|rcx
operator|&
name|vie_size2mask
argument_list|(
name|vie
operator|->
name|addrsize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|vm_restart_instruction
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_and
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|mem_region_read_t
name|memread
parameter_list|,
name|mem_region_write_t
name|memwrite
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|size
decl_stmt|;
name|enum
name|vm_reg_name
name|reg
decl_stmt|;
name|uint64_t
name|result
decl_stmt|,
name|rflags
decl_stmt|,
name|rflags2
decl_stmt|,
name|val1
decl_stmt|,
name|val2
decl_stmt|;
name|size
operator|=
name|vie
operator|->
name|opsize
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
switch|switch
condition|(
name|vie
operator|->
name|op
operator|.
name|op_byte
condition|)
block|{
case|case
literal|0x23
case|:
comment|/* 		 * AND reg (ModRM:reg) and mem (ModRM:r/m) and store the 		 * result in reg. 		 * 		 * 23/r		and r16, r/m16 		 * 23/r		and r32, r/m32 		 * REX.W + 23/r	and r64, r/m64 		 */
comment|/* get the first operand */
name|reg
operator|=
name|gpr_map
index|[
name|vie
operator|->
name|reg
index|]
expr_stmt|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* get the second operand */
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
operator|&
name|val2
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* perform the operation and write the result */
name|result
operator|=
name|val1
operator|&
name|val2
expr_stmt|;
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
name|result
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x81
case|:
case|case
literal|0x83
case|:
comment|/* 		 * AND mem (ModRM:r/m) with immediate and store the 		 * result in mem. 		 * 		 * 81 /4		and r/m16, imm16 		 * 81 /4		and r/m32, imm32 		 * REX.W + 81 /4	and r/m64, imm32 sign-extended to 64 		 * 		 * 83 /4		and r/m16, imm8 sign-extended to 16 		 * 83 /4		and r/m32, imm8 sign-extended to 32 		 * REX.W + 83/4		and r/m64, imm8 sign-extended to 64 		 */
comment|/* get the first operand */
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
operator|&
name|val1
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* 		 * perform the operation with the pre-fetched immediate 		 * operand and write the result 		 */
name|result
operator|=
name|val1
operator|&
name|vie
operator|->
name|immediate
expr_stmt|;
name|error
operator|=
name|memwrite
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|result
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|,
operator|&
name|rflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * OF and CF are cleared; the SF, ZF and PF flags are set according 	 * to the result; AF is undefined. 	 * 	 * The updated status flags are obtained by subtracting 0 from 'result'. 	 */
name|rflags2
operator|=
name|getcc
argument_list|(
name|size
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rflags
operator|&=
operator|~
name|RFLAGS_STATUS_BITS
expr_stmt|;
name|rflags
operator||=
name|rflags2
operator|&
operator|(
name|PSL_PF
operator||
name|PSL_Z
operator||
name|PSL_N
operator|)
expr_stmt|;
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|,
name|rflags
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_or
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|mem_region_read_t
name|memread
parameter_list|,
name|mem_region_write_t
name|memwrite
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|size
decl_stmt|;
name|uint64_t
name|val1
decl_stmt|,
name|result
decl_stmt|,
name|rflags
decl_stmt|,
name|rflags2
decl_stmt|;
name|size
operator|=
name|vie
operator|->
name|opsize
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
switch|switch
condition|(
name|vie
operator|->
name|op
operator|.
name|op_byte
condition|)
block|{
case|case
literal|0x81
case|:
case|case
literal|0x83
case|:
comment|/* 		 * OR mem (ModRM:r/m) with immediate and store the 		 * result in mem. 		 * 		 * 81 /1		or r/m16, imm16 		 * 81 /1		or r/m32, imm32 		 * REX.W + 81 /1	or r/m64, imm32 sign-extended to 64 		 * 		 * 83 /1		or r/m16, imm8 sign-extended to 16 		 * 83 /1		or r/m32, imm8 sign-extended to 32 		 * REX.W + 83/1		or r/m64, imm8 sign-extended to 64 		 */
comment|/* get the first operand */
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
operator|&
name|val1
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* 		 * perform the operation with the pre-fetched immediate 		 * operand and write the result 		 */
name|result
operator|=
name|val1
operator||
name|vie
operator|->
name|immediate
expr_stmt|;
name|error
operator|=
name|memwrite
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|result
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|,
operator|&
name|rflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * OF and CF are cleared; the SF, ZF and PF flags are set according 	 * to the result; AF is undefined. 	 * 	 * The updated status flags are obtained by subtracting 0 from 'result'. 	 */
name|rflags2
operator|=
name|getcc
argument_list|(
name|size
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rflags
operator|&=
operator|~
name|RFLAGS_STATUS_BITS
expr_stmt|;
name|rflags
operator||=
name|rflags2
operator|&
operator|(
name|PSL_PF
operator||
name|PSL_Z
operator||
name|PSL_N
operator|)
expr_stmt|;
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|,
name|rflags
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_cmp
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|mem_region_read_t
name|memread
parameter_list|,
name|mem_region_write_t
name|memwrite
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|size
decl_stmt|;
name|uint64_t
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|rflags
decl_stmt|,
name|rflags2
decl_stmt|;
name|enum
name|vm_reg_name
name|reg
decl_stmt|;
name|size
operator|=
name|vie
operator|->
name|opsize
expr_stmt|;
switch|switch
condition|(
name|vie
operator|->
name|op
operator|.
name|op_byte
condition|)
block|{
case|case
literal|0x3B
case|:
comment|/* 		 * 3B/r		CMP r16, r/m16 		 * 3B/r		CMP r32, r/m32 		 * REX.W + 3B/r	CMP r64, r/m64 		 * 		 * Compare first operand (reg) with second operand (r/m) and 		 * set status flags in EFLAGS register. The comparison is 		 * performed by subtracting the second operand from the first 		 * operand and then setting the status flags. 		 */
comment|/* Get the first operand */
name|reg
operator|=
name|gpr_map
index|[
name|vie
operator|->
name|reg
index|]
expr_stmt|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Get the second operand */
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
operator|&
name|op2
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|rflags2
operator|=
name|getcc
argument_list|(
name|size
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
case|case
literal|0x81
case|:
case|case
literal|0x83
case|:
comment|/* 		 * 80 /7		cmp r/m8, imm8 		 * REX + 80 /7		cmp r/m8, imm8 		 * 		 * 81 /7		cmp r/m16, imm16 		 * 81 /7		cmp r/m32, imm32 		 * REX.W + 81 /7	cmp r/m64, imm32 sign-extended to 64 		 * 		 * 83 /7		cmp r/m16, imm8 sign-extended to 16 		 * 83 /7		cmp r/m32, imm8 sign-extended to 32 		 * REX.W + 83 /7	cmp r/m64, imm8 sign-extended to 64 		 * 		 * Compare mem (ModRM:r/m) with immediate and set 		 * status flags according to the results.  The 		 * comparison is performed by subtracting the 		 * immediate from the first operand and then setting 		 * the status flags. 		 * 		 */
if|if
condition|(
name|vie
operator|->
name|op
operator|.
name|op_byte
operator|==
literal|0x80
condition|)
name|size
operator|=
literal|1
expr_stmt|;
comment|/* get the first operand */
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
operator|&
name|op1
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|rflags2
operator|=
name|getcc
argument_list|(
name|size
argument_list|,
name|op1
argument_list|,
name|vie
operator|->
name|immediate
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|,
operator|&
name|rflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|rflags
operator|&=
operator|~
name|RFLAGS_STATUS_BITS
expr_stmt|;
name|rflags
operator||=
name|rflags2
operator|&
name|RFLAGS_STATUS_BITS
expr_stmt|;
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|,
name|rflags
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_sub
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|mem_region_read_t
name|memread
parameter_list|,
name|mem_region_write_t
name|memwrite
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|size
decl_stmt|;
name|uint64_t
name|nval
decl_stmt|,
name|rflags
decl_stmt|,
name|rflags2
decl_stmt|,
name|val1
decl_stmt|,
name|val2
decl_stmt|;
name|enum
name|vm_reg_name
name|reg
decl_stmt|;
name|size
operator|=
name|vie
operator|->
name|opsize
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
switch|switch
condition|(
name|vie
operator|->
name|op
operator|.
name|op_byte
condition|)
block|{
case|case
literal|0x2B
case|:
comment|/* 		 * SUB r/m from r and store the result in r 		 *  		 * 2B/r            SUB r16, r/m16 		 * 2B/r            SUB r32, r/m32 		 * REX.W + 2B/r    SUB r64, r/m64 		 */
comment|/* get the first operand */
name|reg
operator|=
name|gpr_map
index|[
name|vie
operator|->
name|reg
index|]
expr_stmt|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* get the second operand */
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
operator|&
name|val2
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* perform the operation and write the result */
name|nval
operator|=
name|val1
operator|-
name|val2
expr_stmt|;
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|reg
argument_list|,
name|nval
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|rflags2
operator|=
name|getcc
argument_list|(
name|size
argument_list|,
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|,
operator|&
name|rflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|rflags
operator|&=
operator|~
name|RFLAGS_STATUS_BITS
expr_stmt|;
name|rflags
operator||=
name|rflags2
operator|&
name|RFLAGS_STATUS_BITS
expr_stmt|;
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|,
name|rflags
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_stack_op
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|mmio_gpa
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|,
name|mem_region_read_t
name|memread
parameter_list|,
name|mem_region_write_t
name|memwrite
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|struct
name|vm_copyinfo
name|copyinfo
index|[
literal|2
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|iovec
name|copyinfo
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|seg_desc
name|ss_desc
decl_stmt|;
name|uint64_t
name|cr0
decl_stmt|,
name|rflags
decl_stmt|,
name|rsp
decl_stmt|,
name|stack_gla
decl_stmt|,
name|val
decl_stmt|;
name|int
name|error
decl_stmt|,
name|size
decl_stmt|,
name|stackaddrsize
decl_stmt|,
name|pushop
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|size
operator|=
name|vie
operator|->
name|opsize
expr_stmt|;
name|pushop
operator|=
operator|(
name|vie
operator|->
name|op
operator|.
name|op_type
operator|==
name|VIE_OP_TYPE_PUSH
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 	 * From "Address-Size Attributes for Stack Accesses", Intel SDL, Vol 1 	 */
if|if
condition|(
name|paging
operator|->
name|cpu_mode
operator|==
name|CPU_MODE_REAL
condition|)
block|{
name|stackaddrsize
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paging
operator|->
name|cpu_mode
operator|==
name|CPU_MODE_64BIT
condition|)
block|{
comment|/* 		 * "Stack Manipulation Instructions in 64-bit Mode", SDM, Vol 3 		 * - Stack pointer size is always 64-bits. 		 * - PUSH/POP of 32-bit values is not possible in 64-bit mode. 		 * - 16-bit PUSH/POP is supported by using the operand size 		 *   override prefix (66H). 		 */
name|stackaddrsize
operator|=
literal|8
expr_stmt|;
name|size
operator|=
name|vie
operator|->
name|opsize_override
condition|?
literal|2
else|:
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * In protected or compability mode the 'B' flag in the 		 * stack-segment descriptor determines the size of the 		 * stack pointer. 		 */
name|error
operator|=
name|vm_get_seg_desc
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_SS
argument_list|,
operator|&
name|ss_desc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d getting SS descriptor"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEG_DESC_DEF32
argument_list|(
name|ss_desc
operator|.
name|access
argument_list|)
condition|)
name|stackaddrsize
operator|=
literal|4
expr_stmt|;
else|else
name|stackaddrsize
operator|=
literal|2
expr_stmt|;
block|}
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_CR0
argument_list|,
operator|&
name|cr0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d getting cr0"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|,
operator|&
name|rflags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d getting rflags"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RSP
argument_list|,
operator|&
name|rsp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d getting rsp"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pushop
condition|)
block|{
name|rsp
operator|-=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|vie_calculate_gla
argument_list|(
name|paging
operator|->
name|cpu_mode
argument_list|,
name|VM_REG_GUEST_SS
argument_list|,
operator|&
name|ss_desc
argument_list|,
name|rsp
argument_list|,
name|size
argument_list|,
name|stackaddrsize
argument_list|,
name|pushop
condition|?
name|PROT_WRITE
else|:
name|PROT_READ
argument_list|,
operator|&
name|stack_gla
argument_list|)
condition|)
block|{
name|vm_inject_ss
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|vie_canonical_check
argument_list|(
name|paging
operator|->
name|cpu_mode
argument_list|,
name|stack_gla
argument_list|)
condition|)
block|{
name|vm_inject_ss
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|vie_alignment_check
argument_list|(
name|paging
operator|->
name|cpl
argument_list|,
name|size
argument_list|,
name|cr0
argument_list|,
name|rflags
argument_list|,
name|stack_gla
argument_list|)
condition|)
block|{
name|vm_inject_ac
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|vm_copy_setup
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|paging
argument_list|,
name|stack_gla
argument_list|,
name|size
argument_list|,
name|pushop
condition|?
name|PROT_WRITE
else|:
name|PROT_READ
argument_list|,
name|copyinfo
argument_list|,
name|nitems
argument_list|(
name|copyinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * XXX cannot return a negative error value here because it 		 * ends up being the return value of the VM_RUN() ioctl and 		 * is interpreted as a pseudo-error (for e.g. ERESTART). 		 */
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
literal|1
condition|)
block|{
comment|/* Resume guest execution to handle page fault */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pushop
condition|)
block|{
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|mmio_gpa
argument_list|,
operator|&
name|val
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|vm_copyout
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
operator|&
name|val
argument_list|,
name|copyinfo
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vm_copyin
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|copyinfo
argument_list|,
operator|&
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|memwrite
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|mmio_gpa
argument_list|,
name|val
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|rsp
operator|+=
name|size
expr_stmt|;
block|}
name|vm_copy_teardown
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|copyinfo
argument_list|,
name|nitems
argument_list|(
name|copyinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RSP
argument_list|,
name|rsp
argument_list|,
name|stackaddrsize
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"error %d updating rsp"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_push
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|mmio_gpa
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|,
name|mem_region_read_t
name|memread
parameter_list|,
name|mem_region_write_t
name|memwrite
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * Table A-6, "Opcode Extensions", Intel SDM, Vol 2. 	 * 	 * PUSH is part of the group 5 extended opcodes and is identified 	 * by ModRM:reg = b110. 	 */
if|if
condition|(
operator|(
name|vie
operator|->
name|reg
operator|&
literal|7
operator|)
operator|!=
literal|6
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|emulate_stack_op
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|mmio_gpa
argument_list|,
name|vie
argument_list|,
name|paging
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_pop
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|mmio_gpa
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|,
name|mem_region_read_t
name|memread
parameter_list|,
name|mem_region_write_t
name|memwrite
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * Table A-6, "Opcode Extensions", Intel SDM, Vol 2. 	 * 	 * POP is part of the group 1A extended opcodes and is identified 	 * by ModRM:reg = b000. 	 */
if|if
condition|(
operator|(
name|vie
operator|->
name|reg
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|emulate_stack_op
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|mmio_gpa
argument_list|,
name|vie
argument_list|,
name|paging
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_group1
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|,
name|mem_region_read_t
name|memread
parameter_list|,
name|mem_region_write_t
name|memwrite
parameter_list|,
name|void
modifier|*
name|memarg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|vie
operator|->
name|reg
operator|&
literal|7
condition|)
block|{
case|case
literal|0x1
case|:
comment|/* OR */
name|error
operator|=
name|emulate_or
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
comment|/* AND */
name|error
operator|=
name|emulate_and
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
comment|/* CMP */
name|error
operator|=
name|emulate_cmp
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_bittest
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|mem_region_read_t
name|memread
parameter_list|,
name|mem_region_write_t
name|memwrite
parameter_list|,
name|void
modifier|*
name|memarg
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|,
name|rflags
decl_stmt|;
name|int
name|error
decl_stmt|,
name|bitmask
decl_stmt|,
name|bitoff
decl_stmt|;
comment|/* 	 * 0F BA is a Group 8 extended opcode. 	 * 	 * Currently we only emulate the 'Bit Test' instruction which is 	 * identified by a ModR/M:reg encoding of 100b. 	 */
if|if
condition|(
operator|(
name|vie
operator|->
name|reg
operator|&
literal|7
operator|)
operator|!=
literal|4
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|vie_read_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|,
operator|&
name|rflags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d getting rflags"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|memread
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
operator|&
name|val
argument_list|,
name|vie
operator|->
name|opsize
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Intel SDM, Vol 2, Table 3-2: 	 * "Range of Bit Positions Specified by Bit Offset Operands" 	 */
name|bitmask
operator|=
name|vie
operator|->
name|opsize
operator|*
literal|8
operator|-
literal|1
expr_stmt|;
name|bitoff
operator|=
name|vie
operator|->
name|immediate
operator|&
name|bitmask
expr_stmt|;
comment|/* Copy the bit into the Carry flag in %rflags */
if|if
condition|(
name|val
operator|&
operator|(
literal|1UL
operator|<<
name|bitoff
operator|)
condition|)
name|rflags
operator||=
name|PSL_C
expr_stmt|;
else|else
name|rflags
operator|&=
operator|~
name|PSL_C
expr_stmt|;
name|error
operator|=
name|vie_update_register
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|,
name|rflags
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: error %d updating rflags"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vmm_emulate_instruction
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|,
name|mem_region_read_t
name|memread
parameter_list|,
name|mem_region_write_t
name|memwrite
parameter_list|,
name|void
modifier|*
name|memarg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|vie
operator|->
name|decoded
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|vie
operator|->
name|op
operator|.
name|op_type
condition|)
block|{
case|case
name|VIE_OP_TYPE_GROUP1
case|:
name|error
operator|=
name|emulate_group1
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
argument_list|,
name|paging
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIE_OP_TYPE_POP
case|:
name|error
operator|=
name|emulate_pop
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
argument_list|,
name|paging
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIE_OP_TYPE_PUSH
case|:
name|error
operator|=
name|emulate_push
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
argument_list|,
name|paging
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIE_OP_TYPE_CMP
case|:
name|error
operator|=
name|emulate_cmp
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIE_OP_TYPE_MOV
case|:
name|error
operator|=
name|emulate_mov
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIE_OP_TYPE_MOVSX
case|:
case|case
name|VIE_OP_TYPE_MOVZX
case|:
name|error
operator|=
name|emulate_movx
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIE_OP_TYPE_MOVS
case|:
name|error
operator|=
name|emulate_movs
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
argument_list|,
name|paging
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIE_OP_TYPE_STOS
case|:
name|error
operator|=
name|emulate_stos
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
argument_list|,
name|paging
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIE_OP_TYPE_AND
case|:
name|error
operator|=
name|emulate_and
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIE_OP_TYPE_OR
case|:
name|error
operator|=
name|emulate_or
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIE_OP_TYPE_SUB
case|:
name|error
operator|=
name|emulate_sub
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIE_OP_TYPE_BITTEST
case|:
name|error
operator|=
name|emulate_bittest
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|vie
argument_list|,
name|memread
argument_list|,
name|memwrite
argument_list|,
name|memarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vie_alignment_check
parameter_list|(
name|int
name|cpl
parameter_list|,
name|int
name|size
parameter_list|,
name|uint64_t
name|cr0
parameter_list|,
name|uint64_t
name|rf
parameter_list|,
name|uint64_t
name|gla
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|size
operator|==
literal|1
operator|||
name|size
operator|==
literal|2
operator|||
name|size
operator|==
literal|4
operator|||
name|size
operator|==
literal|8
argument_list|,
operator|(
literal|"%s: invalid size %d"
operator|,
name|__func__
operator|,
name|size
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cpl
operator|>=
literal|0
operator|&&
name|cpl
operator|<=
literal|3
argument_list|,
operator|(
literal|"%s: invalid cpl %d"
operator|,
name|__func__
operator|,
name|cpl
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpl
operator|!=
literal|3
operator|||
operator|(
name|cr0
operator|&
name|CR0_AM
operator|)
operator|==
literal|0
operator|||
operator|(
name|rf
operator|&
name|PSL_AC
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|(
name|gla
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vie_canonical_check
parameter_list|(
name|enum
name|vm_cpu_mode
name|cpu_mode
parameter_list|,
name|uint64_t
name|gla
parameter_list|)
block|{
name|uint64_t
name|mask
decl_stmt|;
if|if
condition|(
name|cpu_mode
operator|!=
name|CPU_MODE_64BIT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * The value of the bit 47 in the 'gla' should be replicated in the 	 * most significant 16 bits. 	 */
name|mask
operator|=
operator|~
operator|(
operator|(
literal|1UL
operator|<<
literal|48
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|gla
operator|&
operator|(
literal|1UL
operator|<<
literal|47
operator|)
condition|)
return|return
operator|(
operator|(
name|gla
operator|&
name|mask
operator|)
operator|!=
name|mask
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|gla
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|vie_size2mask
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|size
operator|==
literal|1
operator|||
name|size
operator|==
literal|2
operator|||
name|size
operator|==
literal|4
operator|||
name|size
operator|==
literal|8
argument_list|,
operator|(
literal|"vie_size2mask: invalid size %d"
operator|,
name|size
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|size2mask
index|[
name|size
index|]
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vie_calculate_gla
parameter_list|(
name|enum
name|vm_cpu_mode
name|cpu_mode
parameter_list|,
name|enum
name|vm_reg_name
name|seg
parameter_list|,
name|struct
name|seg_desc
modifier|*
name|desc
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|addrsize
parameter_list|,
name|int
name|prot
parameter_list|,
name|uint64_t
modifier|*
name|gla
parameter_list|)
block|{
name|uint64_t
name|firstoff
decl_stmt|,
name|low_limit
decl_stmt|,
name|high_limit
decl_stmt|,
name|segbase
decl_stmt|;
name|int
name|glasize
decl_stmt|,
name|type
decl_stmt|;
name|KASSERT
argument_list|(
name|seg
operator|>=
name|VM_REG_GUEST_ES
operator|&&
name|seg
operator|<=
name|VM_REG_GUEST_GS
argument_list|,
operator|(
literal|"%s: invalid segment %d"
operator|,
name|__func__
operator|,
name|seg
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|length
operator|==
literal|1
operator|||
name|length
operator|==
literal|2
operator|||
name|length
operator|==
literal|4
operator|||
name|length
operator|==
literal|8
argument_list|,
operator|(
literal|"%s: invalid operand size %d"
operator|,
name|__func__
operator|,
name|length
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|prot
operator|&
operator|~
operator|(
name|PROT_READ
operator||
name|PROT_WRITE
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: invalid prot %#x"
operator|,
name|__func__
operator|,
name|prot
operator|)
argument_list|)
expr_stmt|;
name|firstoff
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|cpu_mode
operator|==
name|CPU_MODE_64BIT
condition|)
block|{
name|KASSERT
argument_list|(
name|addrsize
operator|==
literal|4
operator|||
name|addrsize
operator|==
literal|8
argument_list|,
operator|(
literal|"%s: invalid address "
literal|"size %d for cpu_mode %d"
operator|,
name|__func__
operator|,
name|addrsize
operator|,
name|cpu_mode
operator|)
argument_list|)
expr_stmt|;
name|glasize
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|addrsize
operator|==
literal|2
operator|||
name|addrsize
operator|==
literal|4
argument_list|,
operator|(
literal|"%s: invalid address "
literal|"size %d for cpu mode %d"
operator|,
name|__func__
operator|,
name|addrsize
operator|,
name|cpu_mode
operator|)
argument_list|)
expr_stmt|;
name|glasize
operator|=
literal|4
expr_stmt|;
comment|/* 		 * If the segment selector is loaded with a NULL selector 		 * then the descriptor is unusable and attempting to use 		 * it results in a #GP(0). 		 */
if|if
condition|(
name|SEG_DESC_UNUSABLE
argument_list|(
name|desc
operator|->
name|access
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*  		 * The processor generates a #NP exception when a segment 		 * register is loaded with a selector that points to a 		 * descriptor that is not present. If this was the case then 		 * it would have been checked before the VM-exit. 		 */
name|KASSERT
argument_list|(
name|SEG_DESC_PRESENT
argument_list|(
name|desc
operator|->
name|access
argument_list|)
argument_list|,
operator|(
literal|"segment %d not present: %#x"
operator|,
name|seg
operator|,
name|desc
operator|->
name|access
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * The descriptor type must indicate a code/data segment. 		 */
name|type
operator|=
name|SEG_DESC_TYPE
argument_list|(
name|desc
operator|->
name|access
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|type
operator|>=
literal|16
operator|&&
name|type
operator|<=
literal|31
argument_list|,
operator|(
literal|"segment %d has invalid "
literal|"descriptor type %#x"
operator|,
name|seg
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|PROT_READ
condition|)
block|{
comment|/* #GP on a read access to a exec-only code segment */
if|if
condition|(
operator|(
name|type
operator|&
literal|0xA
operator|)
operator|==
literal|0x8
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|prot
operator|&
name|PROT_WRITE
condition|)
block|{
comment|/* 			 * #GP on a write access to a code segment or a 			 * read-only data segment. 			 */
if|if
condition|(
name|type
operator|&
literal|0x8
condition|)
comment|/* code segment */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|type
operator|&
literal|0xA
operator|)
operator|==
literal|0
condition|)
comment|/* read-only data seg */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * 'desc->limit' is fully expanded taking granularity into 		 * account. 		 */
if|if
condition|(
operator|(
name|type
operator|&
literal|0xC
operator|)
operator|==
literal|0x4
condition|)
block|{
comment|/* expand-down data segment */
name|low_limit
operator|=
name|desc
operator|->
name|limit
operator|+
literal|1
expr_stmt|;
name|high_limit
operator|=
name|SEG_DESC_DEF32
argument_list|(
name|desc
operator|->
name|access
argument_list|)
condition|?
literal|0xffffffff
else|:
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
comment|/* code segment or expand-up data segment */
name|low_limit
operator|=
literal|0
expr_stmt|;
name|high_limit
operator|=
name|desc
operator|->
name|limit
expr_stmt|;
block|}
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|offset
operator|&=
name|vie_size2mask
argument_list|(
name|addrsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|low_limit
operator|||
name|offset
operator|>
name|high_limit
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|offset
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * In 64-bit mode all segments except %fs and %gs have a segment 	 * base address of 0. 	 */
if|if
condition|(
name|cpu_mode
operator|==
name|CPU_MODE_64BIT
operator|&&
name|seg
operator|!=
name|VM_REG_GUEST_FS
operator|&&
name|seg
operator|!=
name|VM_REG_GUEST_GS
condition|)
block|{
name|segbase
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|segbase
operator|=
name|desc
operator|->
name|base
expr_stmt|;
block|}
comment|/* 	 * Truncate 'firstoff' to the effective address size before adding 	 * it to the segment base. 	 */
name|firstoff
operator|&=
name|vie_size2mask
argument_list|(
name|addrsize
argument_list|)
expr_stmt|;
operator|*
name|gla
operator|=
operator|(
name|segbase
operator|+
name|firstoff
operator|)
operator|&
name|vie_size2mask
argument_list|(
name|glasize
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
name|void
name|vie_init
parameter_list|(
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
specifier|const
name|char
modifier|*
name|inst_bytes
parameter_list|,
name|int
name|inst_length
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|inst_length
operator|>=
literal|0
operator|&&
name|inst_length
operator|<=
name|VIE_INST_SIZE
argument_list|,
operator|(
literal|"%s: invalid instruction length (%d)"
operator|,
name|__func__
operator|,
name|inst_length
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|vie
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vie
argument_list|)
argument_list|)
expr_stmt|;
name|vie
operator|->
name|base_register
operator|=
name|VM_REG_LAST
expr_stmt|;
name|vie
operator|->
name|index_register
operator|=
name|VM_REG_LAST
expr_stmt|;
name|vie
operator|->
name|segment_register
operator|=
name|VM_REG_LAST
expr_stmt|;
if|if
condition|(
name|inst_length
condition|)
block|{
name|bcopy
argument_list|(
name|inst_bytes
argument_list|,
name|vie
operator|->
name|inst
argument_list|,
name|inst_length
argument_list|)
expr_stmt|;
name|vie
operator|->
name|num_valid
operator|=
name|inst_length
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pf_error_code
parameter_list|(
name|int
name|usermode
parameter_list|,
name|int
name|prot
parameter_list|,
name|int
name|rsvd
parameter_list|,
name|uint64_t
name|pte
parameter_list|)
block|{
name|int
name|error_code
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pte
operator|&
name|PG_V
condition|)
name|error_code
operator||=
name|PGEX_P
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
name|error_code
operator||=
name|PGEX_W
expr_stmt|;
if|if
condition|(
name|usermode
condition|)
name|error_code
operator||=
name|PGEX_U
expr_stmt|;
if|if
condition|(
name|rsvd
condition|)
name|error_code
operator||=
name|PGEX_RSV
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_EXECUTE
condition|)
name|error_code
operator||=
name|PGEX_I
expr_stmt|;
return|return
operator|(
name|error_code
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptp_release
parameter_list|(
name|void
modifier|*
modifier|*
name|cookie
parameter_list|)
block|{
if|if
condition|(
operator|*
name|cookie
operator|!=
name|NULL
condition|)
block|{
name|vm_gpa_release
argument_list|(
operator|*
name|cookie
argument_list|)
expr_stmt|;
operator|*
name|cookie
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ptp_hold
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|vm_paddr_t
name|ptpphys
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
modifier|*
modifier|*
name|cookie
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|ptp_release
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|vm_gpa_hold
argument_list|(
name|vm
argument_list|,
name|ptpphys
argument_list|,
name|len
argument_list|,
name|VM_PROT_RW
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vm_gla2gpa
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|,
name|uint64_t
name|gla
parameter_list|,
name|int
name|prot
parameter_list|,
name|uint64_t
modifier|*
name|gpa
parameter_list|)
block|{
name|int
name|nlevels
decl_stmt|,
name|pfcode
decl_stmt|,
name|ptpshift
decl_stmt|,
name|ptpindex
decl_stmt|,
name|retval
decl_stmt|,
name|usermode
decl_stmt|,
name|writable
decl_stmt|;
name|u_int
name|retries
decl_stmt|;
name|uint64_t
modifier|*
name|ptpbase
decl_stmt|,
name|ptpphys
decl_stmt|,
name|pte
decl_stmt|,
name|pgsize
decl_stmt|;
name|uint32_t
modifier|*
name|ptpbase32
decl_stmt|,
name|pte32
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|usermode
operator|=
operator|(
name|paging
operator|->
name|cpl
operator|==
literal|3
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|writable
operator|=
name|prot
operator|&
name|VM_PROT_WRITE
expr_stmt|;
name|cookie
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|retries
operator|=
literal|0
expr_stmt|;
name|restart
label|:
name|ptpphys
operator|=
name|paging
operator|->
name|cr3
expr_stmt|;
comment|/* root of the page tables */
name|ptp_release
argument_list|(
operator|&
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|retries
operator|++
operator|>
literal|0
condition|)
name|maybe_yield
argument_list|()
expr_stmt|;
if|if
condition|(
name|vie_canonical_check
argument_list|(
name|paging
operator|->
name|cpu_mode
argument_list|,
name|gla
argument_list|)
condition|)
block|{
comment|/* 		 * XXX assuming a non-stack reference otherwise a stack fault 		 * should be generated. 		 */
name|vm_inject_gp
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
goto|goto
name|fault
goto|;
block|}
if|if
condition|(
name|paging
operator|->
name|paging_mode
operator|==
name|PAGING_MODE_FLAT
condition|)
block|{
operator|*
name|gpa
operator|=
name|gla
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|paging
operator|->
name|paging_mode
operator|==
name|PAGING_MODE_32
condition|)
block|{
name|nlevels
operator|=
literal|2
expr_stmt|;
while|while
condition|(
operator|--
name|nlevels
operator|>=
literal|0
condition|)
block|{
comment|/* Zero out the lower 12 bits. */
name|ptpphys
operator|&=
operator|~
literal|0xfff
expr_stmt|;
name|ptpbase32
operator|=
name|ptp_hold
argument_list|(
name|vm
argument_list|,
name|ptpphys
argument_list|,
name|PAGE_SIZE
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptpbase32
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|ptpshift
operator|=
name|PAGE_SHIFT
operator|+
name|nlevels
operator|*
literal|10
expr_stmt|;
name|ptpindex
operator|=
operator|(
name|gla
operator|>>
name|ptpshift
operator|)
operator|&
literal|0x3FF
expr_stmt|;
name|pgsize
operator|=
literal|1UL
operator|<<
name|ptpshift
expr_stmt|;
name|pte32
operator|=
name|ptpbase32
index|[
name|ptpindex
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pte32
operator|&
name|PG_V
operator|)
operator|==
literal|0
operator|||
operator|(
name|usermode
operator|&&
operator|(
name|pte32
operator|&
name|PG_U
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|writable
operator|&&
operator|(
name|pte32
operator|&
name|PG_RW
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|pfcode
operator|=
name|pf_error_code
argument_list|(
name|usermode
argument_list|,
name|prot
argument_list|,
literal|0
argument_list|,
name|pte32
argument_list|)
expr_stmt|;
name|vm_inject_pf
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|pfcode
argument_list|,
name|gla
argument_list|)
expr_stmt|;
goto|goto
name|fault
goto|;
block|}
comment|/* 			 * Emulate the x86 MMU's management of the accessed 			 * and dirty flags. While the accessed flag is set 			 * at every level of the page table, the dirty flag 			 * is only set at the last level providing the guest 			 * physical address. 			 */
if|if
condition|(
operator|(
name|pte32
operator|&
name|PG_A
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|atomic_cmpset_32
argument_list|(
operator|&
name|ptpbase32
index|[
name|ptpindex
index|]
argument_list|,
name|pte32
argument_list|,
name|pte32
operator||
name|PG_A
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|restart
goto|;
block|}
block|}
comment|/* XXX must be ignored if CR4.PSE=0 */
if|if
condition|(
name|nlevels
operator|>
literal|0
operator|&&
operator|(
name|pte32
operator|&
name|PG_PS
operator|)
operator|!=
literal|0
condition|)
break|break;
name|ptpphys
operator|=
name|pte32
expr_stmt|;
block|}
comment|/* Set the dirty bit in the page table entry if necessary */
if|if
condition|(
name|writable
operator|&&
operator|(
name|pte32
operator|&
name|PG_M
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|atomic_cmpset_32
argument_list|(
operator|&
name|ptpbase32
index|[
name|ptpindex
index|]
argument_list|,
name|pte32
argument_list|,
name|pte32
operator||
name|PG_M
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|restart
goto|;
block|}
block|}
comment|/* Zero out the lower 'ptpshift' bits */
name|pte32
operator|>>=
name|ptpshift
expr_stmt|;
name|pte32
operator|<<=
name|ptpshift
expr_stmt|;
operator|*
name|gpa
operator|=
name|pte32
operator||
operator|(
name|gla
operator|&
operator|(
name|pgsize
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|paging
operator|->
name|paging_mode
operator|==
name|PAGING_MODE_PAE
condition|)
block|{
comment|/* Zero out the lower 5 bits and the upper 32 bits */
name|ptpphys
operator|&=
literal|0xffffffe0UL
expr_stmt|;
name|ptpbase
operator|=
name|ptp_hold
argument_list|(
name|vm
argument_list|,
name|ptpphys
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ptpbase
argument_list|)
operator|*
literal|4
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptpbase
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|ptpindex
operator|=
operator|(
name|gla
operator|>>
literal|30
operator|)
operator|&
literal|0x3
expr_stmt|;
name|pte
operator|=
name|ptpbase
index|[
name|ptpindex
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|&
name|PG_V
operator|)
operator|==
literal|0
condition|)
block|{
name|pfcode
operator|=
name|pf_error_code
argument_list|(
name|usermode
argument_list|,
name|prot
argument_list|,
literal|0
argument_list|,
name|pte
argument_list|)
expr_stmt|;
name|vm_inject_pf
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|pfcode
argument_list|,
name|gla
argument_list|)
expr_stmt|;
goto|goto
name|fault
goto|;
block|}
name|ptpphys
operator|=
name|pte
expr_stmt|;
name|nlevels
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|nlevels
operator|=
literal|4
expr_stmt|;
while|while
condition|(
operator|--
name|nlevels
operator|>=
literal|0
condition|)
block|{
comment|/* Zero out the lower 12 bits and the upper 12 bits */
name|ptpphys
operator|>>=
literal|12
expr_stmt|;
name|ptpphys
operator|<<=
literal|24
expr_stmt|;
name|ptpphys
operator|>>=
literal|12
expr_stmt|;
name|ptpbase
operator|=
name|ptp_hold
argument_list|(
name|vm
argument_list|,
name|ptpphys
argument_list|,
name|PAGE_SIZE
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptpbase
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|ptpshift
operator|=
name|PAGE_SHIFT
operator|+
name|nlevels
operator|*
literal|9
expr_stmt|;
name|ptpindex
operator|=
operator|(
name|gla
operator|>>
name|ptpshift
operator|)
operator|&
literal|0x1FF
expr_stmt|;
name|pgsize
operator|=
literal|1UL
operator|<<
name|ptpshift
expr_stmt|;
name|pte
operator|=
name|ptpbase
index|[
name|ptpindex
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|&
name|PG_V
operator|)
operator|==
literal|0
operator|||
operator|(
name|usermode
operator|&&
operator|(
name|pte
operator|&
name|PG_U
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|writable
operator|&&
operator|(
name|pte
operator|&
name|PG_RW
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|pfcode
operator|=
name|pf_error_code
argument_list|(
name|usermode
argument_list|,
name|prot
argument_list|,
literal|0
argument_list|,
name|pte
argument_list|)
expr_stmt|;
name|vm_inject_pf
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|pfcode
argument_list|,
name|gla
argument_list|)
expr_stmt|;
goto|goto
name|fault
goto|;
block|}
comment|/* Set the accessed bit in the page table entry */
if|if
condition|(
operator|(
name|pte
operator|&
name|PG_A
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|atomic_cmpset_64
argument_list|(
operator|&
name|ptpbase
index|[
name|ptpindex
index|]
argument_list|,
name|pte
argument_list|,
name|pte
operator||
name|PG_A
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|restart
goto|;
block|}
block|}
if|if
condition|(
name|nlevels
operator|>
literal|0
operator|&&
operator|(
name|pte
operator|&
name|PG_PS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pgsize
operator|>
literal|1
operator|*
name|GB
condition|)
block|{
name|pfcode
operator|=
name|pf_error_code
argument_list|(
name|usermode
argument_list|,
name|prot
argument_list|,
literal|1
argument_list|,
name|pte
argument_list|)
expr_stmt|;
name|vm_inject_pf
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|pfcode
argument_list|,
name|gla
argument_list|)
expr_stmt|;
goto|goto
name|fault
goto|;
block|}
break|break;
block|}
name|ptpphys
operator|=
name|pte
expr_stmt|;
block|}
comment|/* Set the dirty bit in the page table entry if necessary */
if|if
condition|(
name|writable
operator|&&
operator|(
name|pte
operator|&
name|PG_M
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|atomic_cmpset_64
argument_list|(
operator|&
name|ptpbase
index|[
name|ptpindex
index|]
argument_list|,
name|pte
argument_list|,
name|pte
operator||
name|PG_M
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|restart
goto|;
block|}
comment|/* Zero out the lower 'ptpshift' bits and the upper 12 bits */
name|pte
operator|>>=
name|ptpshift
expr_stmt|;
name|pte
operator|<<=
operator|(
name|ptpshift
operator|+
literal|12
operator|)
expr_stmt|;
name|pte
operator|>>=
literal|12
expr_stmt|;
operator|*
name|gpa
operator|=
name|pte
operator||
operator|(
name|gla
operator|&
operator|(
name|pgsize
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|done
label|:
name|ptp_release
argument_list|(
operator|&
name|cookie
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
name|error
label|:
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
name|fault
label|:
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
end_function

begin_function
name|int
name|vmm_fetch_instruction
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|,
name|uint64_t
name|rip
parameter_list|,
name|int
name|inst_length
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|)
block|{
name|struct
name|vm_copyinfo
name|copyinfo
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|prot
decl_stmt|;
if|if
condition|(
name|inst_length
operator|>
name|VIE_INST_SIZE
condition|)
name|panic
argument_list|(
literal|"vmm_fetch_instruction: invalid length %d"
argument_list|,
name|inst_length
argument_list|)
expr_stmt|;
name|prot
operator|=
name|PROT_READ
operator||
name|PROT_EXEC
expr_stmt|;
name|error
operator|=
name|vm_copy_setup
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|paging
argument_list|,
name|rip
argument_list|,
name|inst_length
argument_list|,
name|prot
argument_list|,
name|copyinfo
argument_list|,
name|nitems
argument_list|(
name|copyinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|vm_copyin
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|copyinfo
argument_list|,
name|vie
operator|->
name|inst
argument_list|,
name|inst_length
argument_list|)
expr_stmt|;
name|vm_copy_teardown
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|copyinfo
argument_list|,
name|nitems
argument_list|(
name|copyinfo
argument_list|)
argument_list|)
expr_stmt|;
name|vie
operator|->
name|num_valid
operator|=
name|inst_length
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vie_peek
parameter_list|(
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|uint8_t
modifier|*
name|x
parameter_list|)
block|{
if|if
condition|(
name|vie
operator|->
name|num_processed
operator|<
name|vie
operator|->
name|num_valid
condition|)
block|{
operator|*
name|x
operator|=
name|vie
operator|->
name|inst
index|[
name|vie
operator|->
name|num_processed
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vie_advance
parameter_list|(
name|struct
name|vie
modifier|*
name|vie
parameter_list|)
block|{
name|vie
operator|->
name|num_processed
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|segment_override
parameter_list|(
name|uint8_t
name|x
parameter_list|,
name|int
modifier|*
name|seg
parameter_list|)
block|{
switch|switch
condition|(
name|x
condition|)
block|{
case|case
literal|0x2E
case|:
operator|*
name|seg
operator|=
name|VM_REG_GUEST_CS
expr_stmt|;
break|break;
case|case
literal|0x36
case|:
operator|*
name|seg
operator|=
name|VM_REG_GUEST_SS
expr_stmt|;
break|break;
case|case
literal|0x3E
case|:
operator|*
name|seg
operator|=
name|VM_REG_GUEST_DS
expr_stmt|;
break|break;
case|case
literal|0x26
case|:
operator|*
name|seg
operator|=
name|VM_REG_GUEST_ES
expr_stmt|;
break|break;
case|case
literal|0x64
case|:
operator|*
name|seg
operator|=
name|VM_REG_GUEST_FS
expr_stmt|;
break|break;
case|case
literal|0x65
case|:
operator|*
name|seg
operator|=
name|VM_REG_GUEST_GS
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|false
operator|)
return|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decode_prefixes
parameter_list|(
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|enum
name|vm_cpu_mode
name|cpu_mode
parameter_list|,
name|int
name|cs_d
parameter_list|)
block|{
name|uint8_t
name|x
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|vie_peek
argument_list|(
name|vie
argument_list|,
operator|&
name|x
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|x
operator|==
literal|0x66
condition|)
name|vie
operator|->
name|opsize_override
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
literal|0x67
condition|)
name|vie
operator|->
name|addrsize_override
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
literal|0xF3
condition|)
name|vie
operator|->
name|repz_present
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
literal|0xF2
condition|)
name|vie
operator|->
name|repnz_present
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|segment_override
argument_list|(
name|x
argument_list|,
operator|&
name|vie
operator|->
name|segment_register
argument_list|)
condition|)
name|vie
operator|->
name|segment_override
operator|=
literal|1
expr_stmt|;
else|else
break|break;
name|vie_advance
argument_list|(
name|vie
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * From section 2.2.1, "REX Prefixes", Intel SDM Vol 2: 	 * - Only one REX prefix is allowed per instruction. 	 * - The REX prefix must immediately precede the opcode byte or the 	 *   escape opcode byte. 	 * - If an instruction has a mandatory prefix (0x66, 0xF2 or 0xF3) 	 *   the mandatory prefix must come before the REX prefix. 	 */
if|if
condition|(
name|cpu_mode
operator|==
name|CPU_MODE_64BIT
operator|&&
name|x
operator|>=
literal|0x40
operator|&&
name|x
operator|<=
literal|0x4F
condition|)
block|{
name|vie
operator|->
name|rex_present
operator|=
literal|1
expr_stmt|;
name|vie
operator|->
name|rex_w
operator|=
name|x
operator|&
literal|0x8
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vie
operator|->
name|rex_r
operator|=
name|x
operator|&
literal|0x4
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vie
operator|->
name|rex_x
operator|=
name|x
operator|&
literal|0x2
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vie
operator|->
name|rex_b
operator|=
name|x
operator|&
literal|0x1
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vie_advance
argument_list|(
name|vie
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Section "Operand-Size And Address-Size Attributes", Intel SDM, Vol 1 	 */
if|if
condition|(
name|cpu_mode
operator|==
name|CPU_MODE_64BIT
condition|)
block|{
comment|/* 		 * Default address size is 64-bits and default operand size 		 * is 32-bits. 		 */
name|vie
operator|->
name|addrsize
operator|=
name|vie
operator|->
name|addrsize_override
condition|?
literal|4
else|:
literal|8
expr_stmt|;
if|if
condition|(
name|vie
operator|->
name|rex_w
condition|)
name|vie
operator|->
name|opsize
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|vie
operator|->
name|opsize_override
condition|)
name|vie
operator|->
name|opsize
operator|=
literal|2
expr_stmt|;
else|else
name|vie
operator|->
name|opsize
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cs_d
condition|)
block|{
comment|/* Default address and operand sizes are 32-bits */
name|vie
operator|->
name|addrsize
operator|=
name|vie
operator|->
name|addrsize_override
condition|?
literal|2
else|:
literal|4
expr_stmt|;
name|vie
operator|->
name|opsize
operator|=
name|vie
operator|->
name|opsize_override
condition|?
literal|2
else|:
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* Default address and operand sizes are 16-bits */
name|vie
operator|->
name|addrsize
operator|=
name|vie
operator|->
name|addrsize_override
condition|?
literal|4
else|:
literal|2
expr_stmt|;
name|vie
operator|->
name|opsize
operator|=
name|vie
operator|->
name|opsize_override
condition|?
literal|4
else|:
literal|2
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decode_two_byte_opcode
parameter_list|(
name|struct
name|vie
modifier|*
name|vie
parameter_list|)
block|{
name|uint8_t
name|x
decl_stmt|;
if|if
condition|(
name|vie_peek
argument_list|(
name|vie
argument_list|,
operator|&
name|x
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|vie
operator|->
name|op
operator|=
name|two_byte_opcodes
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|vie
operator|->
name|op
operator|.
name|op_type
operator|==
name|VIE_OP_TYPE_NONE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|vie_advance
argument_list|(
name|vie
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decode_opcode
parameter_list|(
name|struct
name|vie
modifier|*
name|vie
parameter_list|)
block|{
name|uint8_t
name|x
decl_stmt|;
if|if
condition|(
name|vie_peek
argument_list|(
name|vie
argument_list|,
operator|&
name|x
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|vie
operator|->
name|op
operator|=
name|one_byte_opcodes
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|vie
operator|->
name|op
operator|.
name|op_type
operator|==
name|VIE_OP_TYPE_NONE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|vie_advance
argument_list|(
name|vie
argument_list|)
expr_stmt|;
if|if
condition|(
name|vie
operator|->
name|op
operator|.
name|op_type
operator|==
name|VIE_OP_TYPE_TWO_BYTE
condition|)
return|return
operator|(
name|decode_two_byte_opcode
argument_list|(
name|vie
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decode_modrm
parameter_list|(
name|struct
name|vie
modifier|*
name|vie
parameter_list|,
name|enum
name|vm_cpu_mode
name|cpu_mode
parameter_list|)
block|{
name|uint8_t
name|x
decl_stmt|;
if|if
condition|(
name|vie
operator|->
name|op
operator|.
name|op_flags
operator|&
name|VIE_OP_F_NO_MODRM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|cpu_mode
operator|==
name|CPU_MODE_REAL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|vie_peek
argument_list|(
name|vie
argument_list|,
operator|&
name|x
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|vie
operator|->
name|mod
operator|=
operator|(
name|x
operator|>>
literal|6
operator|)
operator|&
literal|0x3
expr_stmt|;
name|vie
operator|->
name|rm
operator|=
operator|(
name|x
operator|>>
literal|0
operator|)
operator|&
literal|0x7
expr_stmt|;
name|vie
operator|->
name|reg
operator|=
operator|(
name|x
operator|>>
literal|3
operator|)
operator|&
literal|0x7
expr_stmt|;
comment|/* 	 * A direct addressing mode makes no sense in the context of an EPT 	 * fault. There has to be a memory access involved to cause the 	 * EPT fault. 	 */
if|if
condition|(
name|vie
operator|->
name|mod
operator|==
name|VIE_MOD_DIRECT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|vie
operator|->
name|mod
operator|==
name|VIE_MOD_INDIRECT
operator|&&
name|vie
operator|->
name|rm
operator|==
name|VIE_RM_DISP32
operator|)
operator|||
operator|(
name|vie
operator|->
name|mod
operator|!=
name|VIE_MOD_DIRECT
operator|&&
name|vie
operator|->
name|rm
operator|==
name|VIE_RM_SIB
operator|)
condition|)
block|{
comment|/* 		 * Table 2-5: Special Cases of REX Encodings 		 * 		 * mod=0, r/m=5 is used in the compatibility mode to 		 * indicate a disp32 without a base register. 		 * 		 * mod!=3, r/m=4 is used in the compatibility mode to 		 * indicate that the SIB byte is present. 		 * 		 * The 'b' bit in the REX prefix is don't care in 		 * this case. 		 */
block|}
else|else
block|{
name|vie
operator|->
name|rm
operator||=
operator|(
name|vie
operator|->
name|rex_b
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
name|vie
operator|->
name|reg
operator||=
operator|(
name|vie
operator|->
name|rex_r
operator|<<
literal|3
operator|)
expr_stmt|;
comment|/* SIB */
if|if
condition|(
name|vie
operator|->
name|mod
operator|!=
name|VIE_MOD_DIRECT
operator|&&
name|vie
operator|->
name|rm
operator|==
name|VIE_RM_SIB
condition|)
goto|goto
name|done
goto|;
name|vie
operator|->
name|base_register
operator|=
name|gpr_map
index|[
name|vie
operator|->
name|rm
index|]
expr_stmt|;
switch|switch
condition|(
name|vie
operator|->
name|mod
condition|)
block|{
case|case
name|VIE_MOD_INDIRECT_DISP8
case|:
name|vie
operator|->
name|disp_bytes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VIE_MOD_INDIRECT_DISP32
case|:
name|vie
operator|->
name|disp_bytes
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|VIE_MOD_INDIRECT
case|:
if|if
condition|(
name|vie
operator|->
name|rm
operator|==
name|VIE_RM_DISP32
condition|)
block|{
name|vie
operator|->
name|disp_bytes
operator|=
literal|4
expr_stmt|;
comment|/* 			 * Table 2-7. RIP-Relative Addressing 			 * 			 * In 64-bit mode mod=00 r/m=101 implies [rip] + disp32 			 * whereas in compatibility mode it just implies disp32. 			 */
if|if
condition|(
name|cpu_mode
operator|==
name|CPU_MODE_64BIT
condition|)
name|vie
operator|->
name|base_register
operator|=
name|VM_REG_GUEST_RIP
expr_stmt|;
else|else
name|vie
operator|->
name|base_register
operator|=
name|VM_REG_LAST
expr_stmt|;
block|}
break|break;
block|}
name|done
label|:
name|vie_advance
argument_list|(
name|vie
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decode_sib
parameter_list|(
name|struct
name|vie
modifier|*
name|vie
parameter_list|)
block|{
name|uint8_t
name|x
decl_stmt|;
comment|/* Proceed only if SIB byte is present */
if|if
condition|(
name|vie
operator|->
name|mod
operator|==
name|VIE_MOD_DIRECT
operator|||
name|vie
operator|->
name|rm
operator|!=
name|VIE_RM_SIB
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|vie_peek
argument_list|(
name|vie
argument_list|,
operator|&
name|x
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* De-construct the SIB byte */
name|vie
operator|->
name|ss
operator|=
operator|(
name|x
operator|>>
literal|6
operator|)
operator|&
literal|0x3
expr_stmt|;
name|vie
operator|->
name|index
operator|=
operator|(
name|x
operator|>>
literal|3
operator|)
operator|&
literal|0x7
expr_stmt|;
name|vie
operator|->
name|base
operator|=
operator|(
name|x
operator|>>
literal|0
operator|)
operator|&
literal|0x7
expr_stmt|;
comment|/* Apply the REX prefix modifiers */
name|vie
operator|->
name|index
operator||=
name|vie
operator|->
name|rex_x
operator|<<
literal|3
expr_stmt|;
name|vie
operator|->
name|base
operator||=
name|vie
operator|->
name|rex_b
operator|<<
literal|3
expr_stmt|;
switch|switch
condition|(
name|vie
operator|->
name|mod
condition|)
block|{
case|case
name|VIE_MOD_INDIRECT_DISP8
case|:
name|vie
operator|->
name|disp_bytes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VIE_MOD_INDIRECT_DISP32
case|:
name|vie
operator|->
name|disp_bytes
operator|=
literal|4
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vie
operator|->
name|mod
operator|==
name|VIE_MOD_INDIRECT
operator|&&
operator|(
name|vie
operator|->
name|base
operator|==
literal|5
operator|||
name|vie
operator|->
name|base
operator|==
literal|13
operator|)
condition|)
block|{
comment|/* 		 * Special case when base register is unused if mod = 0 		 * and base = %rbp or %r13. 		 * 		 * Documented in: 		 * Table 2-3: 32-bit Addressing Forms with the SIB Byte 		 * Table 2-5: Special Cases of REX Encodings 		 */
name|vie
operator|->
name|disp_bytes
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|vie
operator|->
name|base_register
operator|=
name|gpr_map
index|[
name|vie
operator|->
name|base
index|]
expr_stmt|;
block|}
comment|/* 	 * All encodings of 'index' are valid except for %rsp (4). 	 * 	 * Documented in: 	 * Table 2-3: 32-bit Addressing Forms with the SIB Byte 	 * Table 2-5: Special Cases of REX Encodings 	 */
if|if
condition|(
name|vie
operator|->
name|index
operator|!=
literal|4
condition|)
name|vie
operator|->
name|index_register
operator|=
name|gpr_map
index|[
name|vie
operator|->
name|index
index|]
expr_stmt|;
comment|/* 'scale' makes sense only in the context of an index register */
if|if
condition|(
name|vie
operator|->
name|index_register
operator|<
name|VM_REG_LAST
condition|)
name|vie
operator|->
name|scale
operator|=
literal|1
operator|<<
name|vie
operator|->
name|ss
expr_stmt|;
name|vie_advance
argument_list|(
name|vie
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decode_displacement
parameter_list|(
name|struct
name|vie
modifier|*
name|vie
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
union|union
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|int8_t
name|signed8
decl_stmt|;
name|int32_t
name|signed32
decl_stmt|;
block|}
name|u
union|;
if|if
condition|(
operator|(
name|n
operator|=
name|vie
operator|->
name|disp_bytes
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|n
operator|!=
literal|1
operator|&&
name|n
operator|!=
literal|4
condition|)
name|panic
argument_list|(
literal|"decode_displacement: invalid disp_bytes %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vie_peek
argument_list|(
name|vie
argument_list|,
operator|&
name|x
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|u
operator|.
name|buf
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
name|vie_advance
argument_list|(
name|vie
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|1
condition|)
name|vie
operator|->
name|displacement
operator|=
name|u
operator|.
name|signed8
expr_stmt|;
comment|/* sign-extended */
else|else
name|vie
operator|->
name|displacement
operator|=
name|u
operator|.
name|signed32
expr_stmt|;
comment|/* sign-extended */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decode_immediate
parameter_list|(
name|struct
name|vie
modifier|*
name|vie
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
union|union
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|int8_t
name|signed8
decl_stmt|;
name|int16_t
name|signed16
decl_stmt|;
name|int32_t
name|signed32
decl_stmt|;
block|}
name|u
union|;
comment|/* Figure out immediate operand size (if any) */
if|if
condition|(
name|vie
operator|->
name|op
operator|.
name|op_flags
operator|&
name|VIE_OP_F_IMM
condition|)
block|{
comment|/* 		 * Section 2.2.1.5 "Immediates", Intel SDM: 		 * In 64-bit mode the typical size of immediate operands 		 * remains 32-bits. When the operand size if 64-bits, the 		 * processor sign-extends all immediates to 64-bits prior 		 * to their use. 		 */
if|if
condition|(
name|vie
operator|->
name|opsize
operator|==
literal|4
operator|||
name|vie
operator|->
name|opsize
operator|==
literal|8
condition|)
name|vie
operator|->
name|imm_bytes
operator|=
literal|4
expr_stmt|;
else|else
name|vie
operator|->
name|imm_bytes
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vie
operator|->
name|op
operator|.
name|op_flags
operator|&
name|VIE_OP_F_IMM8
condition|)
block|{
name|vie
operator|->
name|imm_bytes
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|vie
operator|->
name|imm_bytes
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KASSERT
argument_list|(
name|n
operator|==
literal|1
operator|||
name|n
operator|==
literal|2
operator|||
name|n
operator|==
literal|4
argument_list|,
operator|(
literal|"%s: invalid number of immediate bytes: %d"
operator|,
name|__func__
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vie_peek
argument_list|(
name|vie
argument_list|,
operator|&
name|x
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|u
operator|.
name|buf
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
name|vie_advance
argument_list|(
name|vie
argument_list|)
expr_stmt|;
block|}
comment|/* sign-extend the immediate value before use */
if|if
condition|(
name|n
operator|==
literal|1
condition|)
name|vie
operator|->
name|immediate
operator|=
name|u
operator|.
name|signed8
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|==
literal|2
condition|)
name|vie
operator|->
name|immediate
operator|=
name|u
operator|.
name|signed16
expr_stmt|;
else|else
name|vie
operator|->
name|immediate
operator|=
name|u
operator|.
name|signed32
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decode_moffset
parameter_list|(
name|struct
name|vie
modifier|*
name|vie
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
union|union
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|uint64_t
name|u64
decl_stmt|;
block|}
name|u
union|;
if|if
condition|(
operator|(
name|vie
operator|->
name|op
operator|.
name|op_flags
operator|&
name|VIE_OP_F_MOFFSET
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Section 2.2.1.4, "Direct Memory-Offset MOVs", Intel SDM: 	 * The memory offset size follows the address-size of the instruction. 	 */
name|n
operator|=
name|vie
operator|->
name|addrsize
expr_stmt|;
name|KASSERT
argument_list|(
name|n
operator|==
literal|2
operator|||
name|n
operator|==
literal|4
operator|||
name|n
operator|==
literal|8
argument_list|,
operator|(
literal|"invalid moffset bytes: %d"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|u
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vie_peek
argument_list|(
name|vie
argument_list|,
operator|&
name|x
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|u
operator|.
name|buf
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
name|vie_advance
argument_list|(
name|vie
argument_list|)
expr_stmt|;
block|}
name|vie
operator|->
name|displacement
operator|=
name|u
operator|.
name|u64
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that all the bytes in the instruction buffer were consumed.  */
end_comment

begin_function
specifier|static
name|int
name|verify_inst_length
parameter_list|(
name|struct
name|vie
modifier|*
name|vie
parameter_list|)
block|{
if|if
condition|(
name|vie
operator|->
name|num_processed
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that the 'guest linear address' provided as collateral of the nested  * page table fault matches with our instruction decoding.  */
end_comment

begin_function
specifier|static
name|int
name|verify_gla
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|cpuid
parameter_list|,
name|uint64_t
name|gla
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
name|base
decl_stmt|,
name|idx
decl_stmt|,
name|gla2
decl_stmt|;
comment|/* Skip 'gla' verification */
if|if
condition|(
name|gla
operator|==
name|VIE_INVALID_GLA
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vie
operator|->
name|base_register
operator|!=
name|VM_REG_LAST
condition|)
block|{
name|error
operator|=
name|vm_get_register
argument_list|(
name|vm
argument_list|,
name|cpuid
argument_list|,
name|vie
operator|->
name|base_register
argument_list|,
operator|&
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"verify_gla: error %d getting base reg %d\n"
argument_list|,
name|error
argument_list|,
name|vie
operator|->
name|base_register
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * RIP-relative addressing starts from the following 		 * instruction 		 */
if|if
condition|(
name|vie
operator|->
name|base_register
operator|==
name|VM_REG_GUEST_RIP
condition|)
name|base
operator|+=
name|vie
operator|->
name|num_valid
expr_stmt|;
block|}
name|idx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vie
operator|->
name|index_register
operator|!=
name|VM_REG_LAST
condition|)
block|{
name|error
operator|=
name|vm_get_register
argument_list|(
name|vm
argument_list|,
name|cpuid
argument_list|,
name|vie
operator|->
name|index_register
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"verify_gla: error %d getting index reg %d\n"
argument_list|,
name|error
argument_list|,
name|vie
operator|->
name|index_register
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* XXX assuming that the base address of the segment is 0 */
name|gla2
operator|=
name|base
operator|+
name|vie
operator|->
name|scale
operator|*
name|idx
operator|+
name|vie
operator|->
name|displacement
expr_stmt|;
name|gla2
operator|&=
name|size2mask
index|[
name|vie
operator|->
name|addrsize
index|]
expr_stmt|;
if|if
condition|(
name|gla
operator|!=
name|gla2
condition|)
block|{
name|printf
argument_list|(
literal|"verify_gla mismatch: "
literal|"base(0x%0lx), scale(%d), index(0x%0lx), "
literal|"disp(0x%0lx), gla(0x%0lx), gla2(0x%0lx)\n"
argument_list|,
name|base
argument_list|,
name|vie
operator|->
name|scale
argument_list|,
name|idx
argument_list|,
name|vie
operator|->
name|displacement
argument_list|,
name|gla
argument_list|,
name|gla2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vmm_decode_instruction
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|cpuid
parameter_list|,
name|uint64_t
name|gla
parameter_list|,
name|enum
name|vm_cpu_mode
name|cpu_mode
parameter_list|,
name|int
name|cs_d
parameter_list|,
name|struct
name|vie
modifier|*
name|vie
parameter_list|)
block|{
if|if
condition|(
name|decode_prefixes
argument_list|(
name|vie
argument_list|,
name|cpu_mode
argument_list|,
name|cs_d
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|decode_opcode
argument_list|(
name|vie
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|decode_modrm
argument_list|(
name|vie
argument_list|,
name|cpu_mode
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|decode_sib
argument_list|(
name|vie
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|decode_displacement
argument_list|(
name|vie
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|decode_immediate
argument_list|(
name|vie
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|decode_moffset
argument_list|(
name|vie
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|verify_inst_length
argument_list|(
name|vie
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|vie
operator|->
name|op
operator|.
name|op_flags
operator|&
name|VIE_OP_F_NO_GLA_VERIFICATION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verify_gla
argument_list|(
name|vm
argument_list|,
name|cpuid
argument_list|,
name|gla
argument_list|,
name|vie
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|vie
operator|->
name|decoded
operator|=
literal|1
expr_stmt|;
comment|/* success */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

end_unit

