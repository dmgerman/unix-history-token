begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 NetApp, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/metadata.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/bios.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|"vmm_util.h"
end_include

begin_include
include|#
directive|include
file|"vmm_mem.h"
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VMM_MEM
argument_list|,
literal|"vmm memory"
argument_list|,
literal|"vmm memory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MB
value|(1024 * 1024)
end_define

begin_define
define|#
directive|define
name|GB
value|(1024 * MB)
end_define

begin_define
define|#
directive|define
name|VMM_MEM_MAXSEGS
value|64
end_define

begin_comment
comment|/* protected by vmm_mem_mtx */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|vm_paddr_t
name|base
decl_stmt|;
name|vm_size_t
name|length
decl_stmt|;
block|}
name|vmm_mem_avail
index|[
name|VMM_MEM_MAXSEGS
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|vmm_mem_nsegs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_paddr_t
name|maxaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|vmm_mem_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Steal any memory that was deliberately hidden from FreeBSD either by  * the use of MAXMEM kernel config option or the hw.physmem loader tunable.  */
end_comment

begin_function
specifier|static
name|int
name|vmm_mem_steal_memory
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nsegs
decl_stmt|;
name|caddr_t
name|kmdp
decl_stmt|;
name|uint32_t
name|smapsize
decl_stmt|;
name|uint64_t
name|base
decl_stmt|,
name|length
decl_stmt|;
name|struct
name|bios_smap
modifier|*
name|smapbase
decl_stmt|,
modifier|*
name|smap
decl_stmt|,
modifier|*
name|smapend
decl_stmt|;
comment|/* 	 * Borrowed from hammer_time() and getmemsize() in machdep.c 	 */
name|kmdp
operator|=
name|preload_search_by_type
argument_list|(
literal|"elf kernel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmdp
operator|==
name|NULL
condition|)
name|kmdp
operator|=
name|preload_search_by_type
argument_list|(
literal|"elf64 kernel"
argument_list|)
expr_stmt|;
name|smapbase
operator|=
operator|(
expr|struct
name|bios_smap
operator|*
operator|)
name|preload_search_info
argument_list|(
name|kmdp
argument_list|,
name|MODINFO_METADATA
operator||
name|MODINFOMD_SMAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|smapbase
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"No BIOS smap info from loader!"
argument_list|)
expr_stmt|;
name|smapsize
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|smapbase
operator|-
literal|1
operator|)
expr_stmt|;
name|smapend
operator|=
operator|(
expr|struct
name|bios_smap
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|smapbase
operator|+
name|smapsize
operator|)
expr_stmt|;
name|nsegs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|smap
operator|=
name|smapbase
init|;
name|smap
operator|<
name|smapend
condition|;
name|smap
operator|++
control|)
block|{
comment|/* 		 * XXX 		 * Assuming non-overlapping, monotonically increasing 		 * memory segments. 		 */
if|if
condition|(
name|smap
operator|->
name|type
operator|!=
name|SMAP_TYPE_MEMORY
condition|)
continue|continue;
if|if
condition|(
name|smap
operator|->
name|length
operator|==
literal|0
condition|)
break|break;
name|base
operator|=
name|roundup
argument_list|(
name|smap
operator|->
name|base
argument_list|,
name|NBPDR
argument_list|)
expr_stmt|;
name|length
operator|=
name|rounddown
argument_list|(
name|smap
operator|->
name|length
argument_list|,
name|NBPDR
argument_list|)
expr_stmt|;
comment|/* Skip this segment if FreeBSD is using all of it. */
if|if
condition|(
name|base
operator|+
name|length
operator|<=
name|ptoa
argument_list|(
name|Maxmem
argument_list|)
condition|)
continue|continue;
comment|/* 		 * If FreeBSD is using part of this segment then adjust 		 * 'base' and 'length' accordingly. 		 */
if|if
condition|(
name|base
operator|<
name|ptoa
argument_list|(
name|Maxmem
argument_list|)
condition|)
block|{
name|uint64_t
name|used
decl_stmt|;
name|used
operator|=
name|roundup
argument_list|(
name|ptoa
argument_list|(
name|Maxmem
argument_list|)
argument_list|,
name|NBPDR
argument_list|)
operator|-
name|base
expr_stmt|;
name|base
operator|+=
name|used
expr_stmt|;
name|length
operator|-=
name|used
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|==
literal|0
condition|)
continue|continue;
name|vmm_mem_avail
index|[
name|nsegs
index|]
operator|.
name|base
operator|=
name|base
expr_stmt|;
name|vmm_mem_avail
index|[
name|nsegs
index|]
operator|.
name|length
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|base
operator|+
name|length
operator|>
name|maxaddr
condition|)
name|maxaddr
operator|=
name|base
operator|+
name|length
expr_stmt|;
if|if
condition|(
literal|0
operator|&&
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"vmm_mem_populate: index %d, base 0x%0lx, "
literal|"length %ld\n"
argument_list|,
name|nsegs
argument_list|,
name|vmm_mem_avail
index|[
name|nsegs
index|]
operator|.
name|base
argument_list|,
name|vmm_mem_avail
index|[
name|nsegs
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|nsegs
operator|++
expr_stmt|;
if|if
condition|(
name|nsegs
operator|>=
name|VMM_MEM_MAXSEGS
condition|)
block|{
name|printf
argument_list|(
literal|"vmm_mem_populate: maximum number of vmm memory "
literal|"segments reached!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
block|}
name|vmm_mem_nsegs
operator|=
name|nsegs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmm_mem_direct_map
parameter_list|(
name|vm_paddr_t
name|start
parameter_list|,
name|vm_paddr_t
name|end
parameter_list|)
block|{
name|vm_paddr_t
name|addr
decl_stmt|,
name|remaining
decl_stmt|;
name|int
name|pdpi
decl_stmt|,
name|pdi
decl_stmt|,
name|superpage_size
decl_stmt|;
name|pml4_entry_t
modifier|*
name|pml4p
decl_stmt|;
name|pdp_entry_t
modifier|*
name|pdp
decl_stmt|;
name|pd_entry_t
modifier|*
name|pd
decl_stmt|;
name|uint64_t
name|page_attr_bits
decl_stmt|;
if|if
condition|(
name|end
operator|>=
name|NBPML4
condition|)
name|panic
argument_list|(
literal|"Cannot map memory beyond %ldGB"
argument_list|,
name|NBPML4
operator|/
name|GB
argument_list|)
expr_stmt|;
comment|/* XXX FreeBSD 8.1 does not use 1G superpages in the direct map */
if|if
condition|(
literal|0
operator|&&
name|vmm_supports_1G_pages
argument_list|()
condition|)
name|superpage_size
operator|=
name|NBPDP
expr_stmt|;
else|else
name|superpage_size
operator|=
name|NBPDR
expr_stmt|;
comment|/* 	 * Get the page directory pointer page that contains the direct 	 * map address mappings. 	 */
name|pml4p
operator|=
name|kernel_pmap
operator|->
name|pm_pml4
expr_stmt|;
name|pdp
operator|=
operator|(
name|pdp_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|pml4p
index|[
name|DMPML4I
index|]
operator|&
operator|~
name|PAGE_MASK
argument_list|)
expr_stmt|;
name|page_attr_bits
operator|=
name|PG_RW
operator||
name|PG_V
operator||
name|PG_PS
operator||
name|PG_G
expr_stmt|;
name|addr
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|addr
operator|<
name|end
condition|)
block|{
name|remaining
operator|=
name|end
operator|-
name|addr
expr_stmt|;
name|pdpi
operator|=
name|addr
operator|/
name|NBPDP
expr_stmt|;
if|if
condition|(
name|superpage_size
operator|==
name|NBPDP
operator|&&
name|remaining
operator|>=
name|NBPDP
operator|&&
name|addr
operator|%
name|NBPDP
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If there isn't a mapping for this address then 			 * create one but if there is one already make sure 			 * it matches what we expect it to be. 			 */
if|if
condition|(
name|pdp
index|[
name|pdpi
index|]
operator|==
literal|0
condition|)
block|{
name|pdp
index|[
name|pdpi
index|]
operator|=
name|addr
operator||
name|page_attr_bits
expr_stmt|;
if|if
condition|(
literal|0
operator|&&
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"vmm_mem_populate: mapping "
literal|"0x%lx with 1GB page at "
literal|"pdpi %d\n"
argument_list|,
name|addr
argument_list|,
name|pdpi
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pdp_entry_t
name|pdpe
init|=
name|pdp
index|[
name|pdpi
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|pdpe
operator|&
operator|~
name|PAGE_MASK
operator|)
operator|!=
name|addr
operator|||
operator|(
name|pdpe
operator|&
name|page_attr_bits
operator|)
operator|!=
name|page_attr_bits
condition|)
block|{
name|panic
argument_list|(
literal|"An invalid mapping 0x%016lx "
literal|"already exists for 0x%016lx\n"
argument_list|,
name|pdpe
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
name|addr
operator|+=
name|NBPDP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|remaining
operator|<
name|NBPDR
condition|)
block|{
name|panic
argument_list|(
literal|"vmm_mem_populate: remaining (%ld) must "
literal|"be greater than NBPDR (%d)\n"
argument_list|,
name|remaining
argument_list|,
name|NBPDR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pdp
index|[
name|pdpi
index|]
operator|==
literal|0
condition|)
block|{
comment|/* 				 * XXX we lose this memory forever because 				 * we do not keep track of the virtual address 				 * that would be required to free this page. 				 */
name|pd
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_VMM_MEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|pd
operator|&
name|PAGE_MASK
condition|)
block|{
name|panic
argument_list|(
literal|"vmm_mem_populate: page directory"
literal|"page not aligned on %d "
literal|"boundary\n"
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
name|pdp
index|[
name|pdpi
index|]
operator|=
name|vtophys
argument_list|(
name|pd
argument_list|)
expr_stmt|;
name|pdp
index|[
name|pdpi
index|]
operator||=
name|PG_RW
operator||
name|PG_V
operator||
name|PG_U
expr_stmt|;
if|if
condition|(
literal|0
operator|&&
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"Creating page directory "
literal|"at pdp index %d for 0x%016lx\n"
argument_list|,
name|pdpi
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
name|pdi
operator|=
operator|(
name|addr
operator|%
name|NBPDP
operator|)
operator|/
name|NBPDR
expr_stmt|;
name|pd
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|pdp
index|[
name|pdpi
index|]
operator|&
operator|~
name|PAGE_MASK
argument_list|)
expr_stmt|;
comment|/* 			 * Create a new mapping if one doesn't already exist 			 * or validate it if it does. 			 */
if|if
condition|(
name|pd
index|[
name|pdi
index|]
operator|==
literal|0
condition|)
block|{
name|pd
index|[
name|pdi
index|]
operator|=
name|addr
operator||
name|page_attr_bits
expr_stmt|;
if|if
condition|(
literal|0
operator|&&
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"vmm_mem_populate: mapping "
literal|"0x%lx with 2MB page at "
literal|"pdpi %d, pdi %d\n"
argument_list|,
name|addr
argument_list|,
name|pdpi
argument_list|,
name|pdi
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pd_entry_t
name|pde
init|=
name|pd
index|[
name|pdi
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|pde
operator|&
operator|~
name|PAGE_MASK
operator|)
operator|!=
name|addr
operator|||
operator|(
name|pde
operator|&
name|page_attr_bits
operator|)
operator|!=
name|page_attr_bits
condition|)
block|{
name|panic
argument_list|(
literal|"An invalid mapping 0x%016lx "
literal|"already exists for 0x%016lx\n"
argument_list|,
name|pde
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
name|addr
operator|+=
name|NBPDR
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vmm_mem_populate
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|seg
decl_stmt|,
name|error
decl_stmt|;
name|vm_paddr_t
name|start
decl_stmt|,
name|end
decl_stmt|;
comment|/* populate the vmm_mem_avail[] array */
name|error
operator|=
name|vmm_mem_steal_memory
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Now map the memory that was hidden from FreeBSD in 	 * the direct map VA space. 	 */
for|for
control|(
name|seg
operator|=
literal|0
init|;
name|seg
operator|<
name|vmm_mem_nsegs
condition|;
name|seg
operator|++
control|)
block|{
name|start
operator|=
name|vmm_mem_avail
index|[
name|seg
index|]
operator|.
name|base
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|vmm_mem_avail
index|[
name|seg
index|]
operator|.
name|length
expr_stmt|;
if|if
condition|(
operator|(
name|start
operator|&
name|PDRMASK
operator|)
operator|!=
literal|0
operator|||
operator|(
name|end
operator|&
name|PDRMASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"start (0x%016lx) and end (0x%016lx) must be "
literal|"aligned on a %dMB boundary\n"
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|NBPDR
operator|/
name|MB
argument_list|)
expr_stmt|;
block|}
name|vmm_mem_direct_map
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vmm_mem_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|vmm_mem_mtx
argument_list|,
literal|"vmm_mem_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|error
operator|=
name|vmm_mem_populate
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|vm_paddr_t
name|vmm_mem_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_paddr_t
name|addr
decl_stmt|;
if|if
condition|(
operator|(
name|size
operator|&
name|PDRMASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"vmm_mem_alloc: size 0x%0lx must be "
literal|"aligned on a 0x%0x boundary\n"
argument_list|,
name|size
argument_list|,
name|NBPDR
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vmm_mem_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vmm_mem_nsegs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vmm_mem_avail
index|[
name|i
index|]
operator|.
name|length
operator|>=
name|size
condition|)
block|{
name|addr
operator|=
name|vmm_mem_avail
index|[
name|i
index|]
operator|.
name|base
expr_stmt|;
name|vmm_mem_avail
index|[
name|i
index|]
operator|.
name|base
operator|+=
name|size
expr_stmt|;
name|vmm_mem_avail
index|[
name|i
index|]
operator|.
name|length
operator|-=
name|size
expr_stmt|;
comment|/* remove a zero length segment */
if|if
condition|(
name|vmm_mem_avail
index|[
name|i
index|]
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|memmove
argument_list|(
operator|&
name|vmm_mem_avail
index|[
name|i
index|]
argument_list|,
operator|&
name|vmm_mem_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|vmm_mem_nsegs
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|vmm_mem_avail
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|vmm_mem_nsegs
operator|--
expr_stmt|;
block|}
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|vmm_mem_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vmm_mem_free
parameter_list|(
name|vm_paddr_t
name|base
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|base
operator|&
name|PDRMASK
operator|)
operator|!=
literal|0
operator|||
operator|(
name|length
operator|&
name|PDRMASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"vmm_mem_free: base 0x%0lx and length 0x%0lx must be "
literal|"aligned on a 0x%0x boundary\n"
argument_list|,
name|base
argument_list|,
name|length
argument_list|,
name|NBPDR
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|vmm_mem_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vmm_mem_nsegs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vmm_mem_avail
index|[
name|i
index|]
operator|.
name|base
operator|>
name|base
condition|)
break|break;
block|}
if|if
condition|(
name|vmm_mem_nsegs
operator|>=
name|VMM_MEM_MAXSEGS
condition|)
name|panic
argument_list|(
literal|"vmm_mem_free: cannot free any more segments"
argument_list|)
expr_stmt|;
comment|/* Create a new segment at index 'i' */
name|memmove
argument_list|(
operator|&
name|vmm_mem_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|vmm_mem_avail
index|[
name|i
index|]
argument_list|,
operator|(
name|vmm_mem_nsegs
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|vmm_mem_avail
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|vmm_mem_avail
index|[
name|i
index|]
operator|.
name|base
operator|=
name|base
expr_stmt|;
name|vmm_mem_avail
index|[
name|i
index|]
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|vmm_mem_nsegs
operator|++
expr_stmt|;
name|coalesce_some_more
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vmm_mem_nsegs
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vmm_mem_avail
index|[
name|i
index|]
operator|.
name|base
operator|+
name|vmm_mem_avail
index|[
name|i
index|]
operator|.
name|length
operator|==
name|vmm_mem_avail
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|base
condition|)
block|{
name|vmm_mem_avail
index|[
name|i
index|]
operator|.
name|length
operator|+=
name|vmm_mem_avail
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|length
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|vmm_mem_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|vmm_mem_avail
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
operator|(
name|vmm_mem_nsegs
operator|-
operator|(
name|i
operator|+
literal|2
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|vmm_mem_avail
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|vmm_mem_nsegs
operator|--
expr_stmt|;
goto|goto
name|coalesce_some_more
goto|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|vmm_mem_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vm_paddr_t
name|vmm_mem_maxaddr
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|maxaddr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vmm_mem_dump
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_paddr_t
name|base
decl_stmt|;
name|vm_size_t
name|length
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vmm_mem_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vmm_mem_nsegs
condition|;
name|i
operator|++
control|)
block|{
name|base
operator|=
name|vmm_mem_avail
index|[
name|i
index|]
operator|.
name|base
expr_stmt|;
name|length
operator|=
name|vmm_mem_avail
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
name|printf
argument_list|(
literal|"%-4d0x%016lx    0x%016lx\n"
argument_list|,
name|i
argument_list|,
name|base
argument_list|,
name|base
operator|+
name|length
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|vmm_mem_mtx
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

