begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001, 2002 Ian Dowse.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This implements a hash-based lookup scheme for UFS directories.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ufs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|UFS_DIRHASH
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fnv_hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dirhash.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/extattr.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufs_extern.h>
end_include

begin_define
define|#
directive|define
name|WRAPINCR
parameter_list|(
name|val
parameter_list|,
name|limit
parameter_list|)
value|(((val) + 1 == (limit)) ? 0 : ((val) + 1))
end_define

begin_define
define|#
directive|define
name|WRAPDECR
parameter_list|(
name|val
parameter_list|,
name|limit
parameter_list|)
value|(((val) == 0) ? ((limit) - 1) : ((val) - 1))
end_define

begin_define
define|#
directive|define
name|OFSFMT
parameter_list|(
name|vp
parameter_list|)
value|((vp)->v_mount->mnt_maxsymlinklen<= 0)
end_define

begin_define
define|#
directive|define
name|BLKFREE2IDX
parameter_list|(
name|n
parameter_list|)
value|((n)> DH_NFSTATS ? DH_NFSTATS : (n))
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_DIRHASH
argument_list|,
literal|"ufs_dirhash"
argument_list|,
literal|"UFS directory hash tables"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|ufs
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"UFS filesystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ufs_mindirhashsize
init|=
name|DIRBLKSIZ
operator|*
literal|5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_ufs
argument_list|,
name|OID_AUTO
argument_list|,
name|dirhash_minsize
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ufs_mindirhashsize
argument_list|,
literal|0
argument_list|,
literal|"minimum directory size in bytes for which to use hashed lookup"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ufs_dirhashmaxmem
init|=
literal|2
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_ufs
argument_list|,
name|OID_AUTO
argument_list|,
name|dirhash_maxmem
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ufs_dirhashmaxmem
argument_list|,
literal|0
argument_list|,
literal|"maximum allowed dirhash memory usage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ufs_dirhashmem
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_ufs
argument_list|,
name|OID_AUTO
argument_list|,
name|dirhash_mem
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ufs_dirhashmem
argument_list|,
literal|0
argument_list|,
literal|"current dirhash memory usage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ufs_dirhashcheck
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_ufs
argument_list|,
name|OID_AUTO
argument_list|,
name|dirhash_docheck
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ufs_dirhashcheck
argument_list|,
literal|0
argument_list|,
literal|"enable extra sanity tests"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|ufsdirhash_hash
parameter_list|(
name|struct
name|dirhash
modifier|*
name|dh
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ufsdirhash_adjfree
parameter_list|(
name|struct
name|dirhash
modifier|*
name|dh
parameter_list|,
name|doff_t
name|offset
parameter_list|,
name|int
name|diff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ufsdirhash_delslot
parameter_list|(
name|struct
name|dirhash
modifier|*
name|dh
parameter_list|,
name|int
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ufsdirhash_findslot
parameter_list|(
name|struct
name|dirhash
modifier|*
name|dh
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|doff_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|doff_t
name|ufsdirhash_getprev
parameter_list|(
name|struct
name|direct
modifier|*
name|dp
parameter_list|,
name|doff_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ufsdirhash_recycle
parameter_list|(
name|int
name|wanted
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ufsdirhash_free_locked
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|uma_zone_t
name|ufsdirhash_zone
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DIRHASHLIST_LOCK
parameter_list|()
value|mtx_lock(&ufsdirhash_mtx)
end_define

begin_define
define|#
directive|define
name|DIRHASHLIST_UNLOCK
parameter_list|()
value|mtx_unlock(&ufsdirhash_mtx)
end_define

begin_define
define|#
directive|define
name|DIRHASH_BLKALLOC_WAITOK
parameter_list|()
value|uma_zalloc(ufsdirhash_zone, M_WAITOK)
end_define

begin_define
define|#
directive|define
name|DIRHASH_BLKFREE
parameter_list|(
name|ptr
parameter_list|)
value|uma_zfree(ufsdirhash_zone, (ptr))
end_define

begin_define
define|#
directive|define
name|DIRHASH_ASSERT_LOCKED
parameter_list|(
name|dh
parameter_list|)
define|\
value|sx_assert(&(dh)->dh_lock, SA_LOCKED)
end_define

begin_comment
comment|/* Dirhash list; recently-used entries are near the tail. */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|dirhash
argument_list|)
name|ufsdirhash_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Protects: ufsdirhash_list, `dh_list' field, ufs_dirhashmem. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ufsdirhash_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Locking:  *  * The relationship between inode and dirhash is protected either by an  * exclusive vnode lock or the vnode interlock where a shared vnode lock  * may be used.  The dirhash_mtx is acquired after the dirhash lock.  To  * handle teardown races, code wishing to lock the dirhash for an inode  * when using a shared vnode lock must obtain a private reference on the  * dirhash while holding the vnode interlock.  They can drop it once they  * have obtained the dirhash lock and verified that the dirhash wasn't  * recycled while they waited for the dirhash lock.  *  * ufsdirhash_build() acquires a shared lock on the dirhash when it is  * successful.  This lock is released after a call to ufsdirhash_lookup().  *  * Functions requiring exclusive access use ufsdirhash_acquire() which may  * free a dirhash structure that was recycled by ufsdirhash_recycle().  *  * The dirhash lock may be held across io operations.  *  * WITNESS reports a lock order reversal between the "bufwait" lock  * and the "dirhash" lock.  However, this specific reversal will not  * cause a deadlock.  To get a deadlock, one would have to lock a  * buffer followed by the dirhash while a second thread locked a  * buffer while holding the dirhash lock.  The second order can happen  * under a shared or exclusive vnode lock for the associated directory  * in lookup().  The first order, however, can only happen under an  * exclusive vnode lock (e.g. unlink(), rename(), etc.).  Thus, for  * a thread to be doing a "bufwait" -> "dirhash" order, it has to hold  * an exclusive vnode lock.  That exclusive vnode lock will prevent  * any other threads from doing a "dirhash" -> "bufwait" order.  */
end_comment

begin_function
specifier|static
name|void
name|ufsdirhash_hold
parameter_list|(
name|struct
name|dirhash
modifier|*
name|dh
parameter_list|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|dh
operator|->
name|dh_refcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ufsdirhash_drop
parameter_list|(
name|struct
name|dirhash
modifier|*
name|dh
parameter_list|)
block|{
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|dh
operator|->
name|dh_refcount
argument_list|)
condition|)
block|{
name|sx_destroy
argument_list|(
operator|&
name|dh
operator|->
name|dh_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dh
argument_list|,
name|M_DIRHASH
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Release the lock on a dirhash.  */
end_comment

begin_function
specifier|static
name|void
name|ufsdirhash_release
parameter_list|(
name|struct
name|dirhash
modifier|*
name|dh
parameter_list|)
block|{
name|sx_unlock
argument_list|(
operator|&
name|dh
operator|->
name|dh_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Either acquire an existing hash locked shared or create a new hash and  * return it exclusively locked.  May return NULL if the allocation fails.  *  * The vnode interlock is used to protect the i_dirhash pointer from  * simultaneous access while only a shared vnode lock is held.  */
end_comment

begin_function
specifier|static
name|struct
name|dirhash
modifier|*
name|ufsdirhash_create
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|)
block|{
name|struct
name|dirhash
modifier|*
name|ndh
decl_stmt|;
name|struct
name|dirhash
modifier|*
name|dh
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ndh
operator|=
name|dh
operator|=
name|NULL
expr_stmt|;
name|vp
operator|=
name|ip
operator|->
name|i_vnode
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Racy check for i_dirhash to prefetch an dirhash structure. */
if|if
condition|(
name|ip
operator|->
name|i_dirhash
operator|==
name|NULL
operator|&&
name|ndh
operator|==
name|NULL
condition|)
block|{
name|MALLOC
argument_list|(
name|ndh
argument_list|,
expr|struct
name|dirhash
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|dh
argument_list|,
name|M_DIRHASH
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndh
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|refcount_init
argument_list|(
operator|&
name|ndh
operator|->
name|dh_refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|ndh
operator|->
name|dh_lock
argument_list|,
literal|"dirhash"
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|ndh
operator|->
name|dh_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Check i_dirhash.  If it's NULL just try to use a 		 * preallocated structure.  If none exists loop and try again. 		 */
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|dh
operator|=
name|ip
operator|->
name|i_dirhash
expr_stmt|;
if|if
condition|(
name|dh
operator|==
name|NULL
condition|)
block|{
name|ip
operator|->
name|i_dirhash
operator|=
name|ndh
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndh
operator|==
name|NULL
condition|)
continue|continue;
return|return
operator|(
name|ndh
operator|)
return|;
block|}
name|ufsdirhash_hold
argument_list|(
name|dh
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* Acquire a shared lock on existing hashes. */
name|sx_slock
argument_list|(
operator|&
name|dh
operator|->
name|dh_lock
argument_list|)
expr_stmt|;
comment|/* The hash could've been recycled while we were waiting. */
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_dirhash
operator|!=
name|dh
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ufsdirhash_release
argument_list|(
name|dh
argument_list|)
expr_stmt|;
name|ufsdirhash_drop
argument_list|(
name|dh
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ufsdirhash_drop
argument_list|(
name|dh
argument_list|)
expr_stmt|;
comment|/* If the hash is still valid we've succeeded. */
if|if
condition|(
name|dh
operator|->
name|dh_hash
operator|!=
name|NULL
condition|)
break|break;
comment|/* 		 * If the hash is NULL it has been recycled.  Try to upgrade 		 * so we can recreate it.  If we fail the upgrade, drop our 		 * lock and try again. 		 */
if|if
condition|(
name|sx_try_upgrade
argument_list|(
operator|&
name|dh
operator|->
name|dh_lock
argument_list|)
condition|)
break|break;
name|sx_sunlock
argument_list|(
operator|&
name|dh
operator|->
name|dh_lock
argument_list|)
expr_stmt|;
block|}
comment|/* Free the preallocated structure if it was not necessary. */
if|if
condition|(
name|ndh
condition|)
block|{
name|ufsdirhash_release
argument_list|(
name|ndh
argument_list|)
expr_stmt|;
name|ufsdirhash_drop
argument_list|(
name|ndh
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dh
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Acquire an exclusive lock on an existing hash.  Requires an exclusive  * vnode lock to protect the i_dirhash pointer.  hashes that have been  * recycled are reclaimed here and NULL is returned.  */
end_comment

begin_function
specifier|static
name|struct
name|dirhash
modifier|*
name|ufsdirhash_acquire
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|)
block|{
name|struct
name|dirhash
modifier|*
name|dh
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ASSERT_VOP_ELOCKED
argument_list|(
name|ip
operator|->
name|i_vnode
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ip
operator|->
name|i_vnode
expr_stmt|;
name|dh
operator|=
name|ip
operator|->
name|i_dirhash
expr_stmt|;
if|if
condition|(
name|dh
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|dh
operator|->
name|dh_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|->
name|dh_hash
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dh
operator|)
return|;
name|ufsdirhash_free_locked
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Acquire exclusively and free the hash pointed to by ip.  Works with a  * shared or exclusive vnode lock.  */
end_comment

begin_function
name|void
name|ufsdirhash_free
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|)
block|{
name|struct
name|dirhash
modifier|*
name|dh
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|ip
operator|->
name|i_vnode
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Grab a reference on this inode's dirhash if it has one. */
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|dh
operator|=
name|ip
operator|->
name|i_dirhash
expr_stmt|;
if|if
condition|(
name|dh
operator|==
name|NULL
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return;
block|}
name|ufsdirhash_hold
argument_list|(
name|dh
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* Exclusively lock the dirhash. */
name|sx_xlock
argument_list|(
operator|&
name|dh
operator|->
name|dh_lock
argument_list|)
expr_stmt|;
comment|/* If this dirhash still belongs to this inode, then free it. */
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_dirhash
operator|==
name|dh
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ufsdirhash_drop
argument_list|(
name|dh
argument_list|)
expr_stmt|;
break|break;
block|}
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 		 * This inode's dirhash has changed while we were 		 * waiting for the dirhash lock, so try again. 		 */
name|ufsdirhash_release
argument_list|(
name|dh
argument_list|)
expr_stmt|;
name|ufsdirhash_drop
argument_list|(
name|dh
argument_list|)
expr_stmt|;
block|}
name|ufsdirhash_free_locked
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt to build up a hash table for the directory contents in  * inode 'ip'. Returns 0 on success, or -1 of the operation failed.  */
end_comment

begin_function
name|int
name|ufsdirhash_build
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|)
block|{
name|struct
name|dirhash
modifier|*
name|dh
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|struct
name|direct
modifier|*
name|ep
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|doff_t
name|bmask
decl_stmt|,
name|pos
decl_stmt|;
name|int
name|dirblocks
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|memreqd
decl_stmt|,
name|nblocks
decl_stmt|,
name|narrays
decl_stmt|,
name|nslots
decl_stmt|,
name|slot
decl_stmt|;
comment|/* Take care of a decreased sysctl value. */
while|while
condition|(
name|ufs_dirhashmem
operator|>
name|ufs_dirhashmaxmem
condition|)
if|if
condition|(
name|ufsdirhash_recycle
argument_list|(
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Check if we can/should use dirhash. */
if|if
condition|(
name|ip
operator|->
name|i_size
operator|<
name|ufs_mindirhashsize
operator|||
name|OFSFMT
argument_list|(
name|ip
operator|->
name|i_vnode
argument_list|)
operator|||
name|ip
operator|->
name|i_effnlink
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_dirhash
condition|)
name|ufsdirhash_free
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dh
operator|=
name|ufsdirhash_create
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dh
operator|->
name|dh_hash
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vp
operator|=
name|ip
operator|->
name|i_vnode
expr_stmt|;
comment|/* Allocate 50% more entries than this dir size could ever need. */
name|KASSERT
argument_list|(
name|ip
operator|->
name|i_size
operator|>=
name|DIRBLKSIZ
argument_list|,
operator|(
literal|"ufsdirhash_build size"
operator|)
argument_list|)
expr_stmt|;
name|nslots
operator|=
name|ip
operator|->
name|i_size
operator|/
name|DIRECTSIZ
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nslots
operator|=
operator|(
name|nslots
operator|*
literal|3
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|narrays
operator|=
name|howmany
argument_list|(
name|nslots
argument_list|,
name|DH_NBLKOFF
argument_list|)
expr_stmt|;
name|nslots
operator|=
name|narrays
operator|*
name|DH_NBLKOFF
expr_stmt|;
name|dirblocks
operator|=
name|howmany
argument_list|(
name|ip
operator|->
name|i_size
argument_list|,
name|DIRBLKSIZ
argument_list|)
expr_stmt|;
name|nblocks
operator|=
operator|(
name|dirblocks
operator|*
literal|3
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|memreqd
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|dh
argument_list|)
operator|+
name|narrays
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dh
operator|->
name|dh_hash
argument_list|)
operator|+
name|narrays
operator|*
name|DH_NBLKOFF
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|dh
operator|->
name|dh_hash
argument_list|)
operator|+
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dh
operator|->
name|dh_blkfree
argument_list|)
expr_stmt|;
name|DIRHASHLIST_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|memreqd
operator|+
name|ufs_dirhashmem
operator|>
name|ufs_dirhashmaxmem
condition|)
block|{
name|DIRHASHLIST_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|memreqd
operator|>
name|ufs_dirhashmaxmem
operator|/
literal|2
condition|)
goto|goto
name|fail
goto|;
comment|/* Try to free some space. */
if|if
condition|(
name|ufsdirhash_recycle
argument_list|(
name|memreqd
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Enough was freed, and list has been locked. */
block|}
name|ufs_dirhashmem
operator|+=
name|memreqd
expr_stmt|;
name|DIRHASHLIST_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Initialise the hash table and block statistics. */
name|dh
operator|->
name|dh_memreq
operator|=
name|memreqd
expr_stmt|;
name|dh
operator|->
name|dh_narrays
operator|=
name|narrays
expr_stmt|;
name|dh
operator|->
name|dh_hlen
operator|=
name|nslots
expr_stmt|;
name|dh
operator|->
name|dh_nblk
operator|=
name|nblocks
expr_stmt|;
name|dh
operator|->
name|dh_dirblks
operator|=
name|dirblocks
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DH_NFSTATS
condition|;
name|i
operator|++
control|)
name|dh
operator|->
name|dh_firstfree
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|dh
operator|->
name|dh_firstfree
index|[
name|DH_NFSTATS
index|]
operator|=
literal|0
expr_stmt|;
name|dh
operator|->
name|dh_hused
operator|=
literal|0
expr_stmt|;
name|dh
operator|->
name|dh_seqopt
operator|=
literal|0
expr_stmt|;
name|dh
operator|->
name|dh_seqoff
operator|=
literal|0
expr_stmt|;
name|dh
operator|->
name|dh_score
operator|=
name|DH_SCOREINIT
expr_stmt|;
comment|/* 	 * Use non-blocking mallocs so that we will revert to a linear 	 * lookup on failure rather than potentially blocking forever. 	 */
name|MALLOC
argument_list|(
name|dh
operator|->
name|dh_hash
argument_list|,
name|doff_t
operator|*
operator|*
argument_list|,
name|narrays
operator|*
sizeof|sizeof
argument_list|(
name|dh
operator|->
name|dh_hash
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_DIRHASH
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|->
name|dh_hash
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|MALLOC
argument_list|(
name|dh
operator|->
name|dh_blkfree
argument_list|,
name|u_int8_t
operator|*
argument_list|,
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
name|dh
operator|->
name|dh_blkfree
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_DIRHASH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|->
name|dh_blkfree
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narrays
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dh
operator|->
name|dh_hash
index|[
name|i
index|]
operator|=
name|DIRHASH_BLKALLOC_WAITOK
argument_list|()
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|DH_NBLKOFF
condition|;
name|j
operator|++
control|)
name|dh
operator|->
name|dh_hash
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|DIRHASH_EMPTY
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dirblocks
condition|;
name|i
operator|++
control|)
name|dh
operator|->
name|dh_blkfree
index|[
name|i
index|]
operator|=
name|DIRBLKSIZ
operator|/
name|DIRALIGN
expr_stmt|;
name|bmask
operator|=
name|VFSTOUFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|->
name|um_mountp
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|-
literal|1
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|ip
operator|->
name|i_size
condition|)
block|{
comment|/* If necessary, get the next directory block. */
if|if
condition|(
operator|(
name|pos
operator|&
name|bmask
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|UFS_BLKATOFF
argument_list|(
name|vp
argument_list|,
operator|(
name|off_t
operator|)
name|pos
argument_list|,
name|NULL
argument_list|,
operator|&
name|bp
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/* Add this entry to the hash. */
name|ep
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
operator|(
name|pos
operator|&
name|bmask
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|d_reclen
operator|==
literal|0
operator|||
name|ep
operator|->
name|d_reclen
operator|>
name|DIRBLKSIZ
operator|-
operator|(
name|pos
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* Corrupted directory. */
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|ep
operator|->
name|d_ino
operator|!=
literal|0
condition|)
block|{
comment|/* Add the entry (simplified ufsdirhash_add). */
name|slot
operator|=
name|ufsdirhash_hash
argument_list|(
name|dh
argument_list|,
name|ep
operator|->
name|d_name
argument_list|,
name|ep
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
while|while
condition|(
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|slot
argument_list|)
operator|!=
name|DIRHASH_EMPTY
condition|)
name|slot
operator|=
name|WRAPINCR
argument_list|(
name|slot
argument_list|,
name|dh
operator|->
name|dh_hlen
argument_list|)
expr_stmt|;
name|dh
operator|->
name|dh_hused
operator|++
expr_stmt|;
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|slot
argument_list|)
operator|=
name|pos
expr_stmt|;
name|ufsdirhash_adjfree
argument_list|(
name|dh
argument_list|,
name|pos
argument_list|,
operator|-
name|DIRSIZ
argument_list|(
literal|0
argument_list|,
name|ep
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
name|ep
operator|->
name|d_reclen
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|DIRHASHLIST_LOCK
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ufsdirhash_list
argument_list|,
name|dh
argument_list|,
name|dh_list
argument_list|)
expr_stmt|;
name|dh
operator|->
name|dh_onlist
operator|=
literal|1
expr_stmt|;
name|DIRHASHLIST_UNLOCK
argument_list|()
expr_stmt|;
name|sx_downgrade
argument_list|(
operator|&
name|dh
operator|->
name|dh_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|ufsdirhash_free_locked
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free any hash table associated with inode 'ip'.  */
end_comment

begin_function
specifier|static
name|void
name|ufsdirhash_free_locked
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|)
block|{
name|struct
name|dirhash
modifier|*
name|dh
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DIRHASH_ASSERT_LOCKED
argument_list|(
name|ip
operator|->
name|i_dirhash
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the pointer in the inode to prevent new threads from 	 * finding the dead structure. 	 */
name|vp
operator|=
name|ip
operator|->
name|i_vnode
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|dh
operator|=
name|ip
operator|->
name|i_dirhash
expr_stmt|;
name|ip
operator|->
name|i_dirhash
operator|=
name|NULL
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the hash from the list since we are going to free its 	 * memory. 	 */
name|DIRHASHLIST_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|dh
operator|->
name|dh_onlist
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ufsdirhash_list
argument_list|,
name|dh
argument_list|,
name|dh_list
argument_list|)
expr_stmt|;
name|ufs_dirhashmem
operator|-=
name|dh
operator|->
name|dh_memreq
expr_stmt|;
name|DIRHASHLIST_UNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * At this point, any waiters for the lock should hold their 	 * own reference on the dirhash structure.  They will drop 	 * that reference once they grab the vnode interlock and see 	 * that ip->i_dirhash is NULL. 	 */
name|sx_xunlock
argument_list|(
operator|&
name|dh
operator|->
name|dh_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Handle partially recycled as well as fully constructed hashes. 	 */
if|if
condition|(
name|dh
operator|->
name|dh_hash
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dh
operator|->
name|dh_narrays
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dh
operator|->
name|dh_hash
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|DIRHASH_BLKFREE
argument_list|(
name|dh
operator|->
name|dh_hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|dh
operator|->
name|dh_hash
argument_list|,
name|M_DIRHASH
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|->
name|dh_blkfree
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|dh
operator|->
name|dh_blkfree
argument_list|,
name|M_DIRHASH
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Drop the inode's reference to the data structure. 	 */
name|ufsdirhash_drop
argument_list|(
name|dh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the offset of the specified name within the given inode.  * Returns 0 on success, ENOENT if the entry does not exist, or  * EJUSTRETURN if the caller should revert to a linear search.  *  * If successful, the directory offset is stored in *offp, and a  * pointer to a struct buf containing the entry is stored in *bpp. If  * prevoffp is non-NULL, the offset of the previous entry within  * the DIRBLKSIZ-sized block is stored in *prevoffp (if the entry  * is the first in a block, the start of the block is used).  *  * Must be called with the hash locked.  Returns with the hash unlocked.  */
end_comment

begin_function
name|int
name|ufsdirhash_lookup
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|doff_t
modifier|*
name|offp
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|bpp
parameter_list|,
name|doff_t
modifier|*
name|prevoffp
parameter_list|)
block|{
name|struct
name|dirhash
modifier|*
name|dh
decl_stmt|,
modifier|*
name|dh_next
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|doff_t
name|blkoff
decl_stmt|,
name|bmask
decl_stmt|,
name|offset
decl_stmt|,
name|prevoff
decl_stmt|;
name|int
name|i
decl_stmt|,
name|slot
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dh
operator|=
name|ip
operator|->
name|i_dirhash
expr_stmt|;
name|KASSERT
argument_list|(
name|dh
operator|!=
name|NULL
operator|&&
name|dh
operator|->
name|dh_hash
operator|!=
name|NULL
argument_list|,
operator|(
literal|"ufsdirhash_lookup: Invalid dirhash %p\n"
operator|,
name|dh
operator|)
argument_list|)
expr_stmt|;
name|DIRHASH_ASSERT_LOCKED
argument_list|(
name|dh
argument_list|)
expr_stmt|;
comment|/* 	 * Move this dirhash towards the end of the list if it has a 	 * score higher than the next entry, and acquire the dh_lock. 	 */
name|DIRHASHLIST_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|TAILQ_NEXT
argument_list|(
name|dh
argument_list|,
name|dh_list
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If the new score will be greater than that of the next 		 * entry, then move this entry past it. With both mutexes 		 * held, dh_next won't go away, but its dh_score could 		 * change; that's not important since it is just a hint. 		 */
if|if
condition|(
operator|(
name|dh_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|dh
argument_list|,
name|dh_list
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|dh
operator|->
name|dh_score
operator|>=
name|dh_next
operator|->
name|dh_score
condition|)
block|{
name|KASSERT
argument_list|(
name|dh
operator|->
name|dh_onlist
argument_list|,
operator|(
literal|"dirhash: not on list"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ufsdirhash_list
argument_list|,
name|dh
argument_list|,
name|dh_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|ufsdirhash_list
argument_list|,
name|dh_next
argument_list|,
name|dh
argument_list|,
name|dh_list
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Update the score. */
if|if
condition|(
name|dh
operator|->
name|dh_score
operator|<
name|DH_SCOREMAX
condition|)
name|dh
operator|->
name|dh_score
operator|++
expr_stmt|;
name|DIRHASHLIST_UNLOCK
argument_list|()
expr_stmt|;
name|vp
operator|=
name|ip
operator|->
name|i_vnode
expr_stmt|;
name|bmask
operator|=
name|VFSTOUFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|->
name|um_mountp
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|-
literal|1
expr_stmt|;
name|blkoff
operator|=
operator|-
literal|1
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|restart
label|:
name|slot
operator|=
name|ufsdirhash_hash
argument_list|(
name|dh
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|->
name|dh_seqopt
condition|)
block|{
comment|/* 		 * Sequential access optimisation. dh_seqoff contains the 		 * offset of the directory entry immediately following 		 * the last entry that was looked up. Check if this offset 		 * appears in the hash chain for the name we are looking for. 		 */
for|for
control|(
name|i
operator|=
name|slot
init|;
operator|(
name|offset
operator|=
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
name|DIRHASH_EMPTY
condition|;
name|i
operator|=
name|WRAPINCR
argument_list|(
name|i
argument_list|,
name|dh
operator|->
name|dh_hlen
argument_list|)
control|)
if|if
condition|(
name|offset
operator|==
name|dh
operator|->
name|dh_seqoff
condition|)
break|break;
if|if
condition|(
name|offset
operator|==
name|dh
operator|->
name|dh_seqoff
condition|)
block|{
comment|/* 			 * We found an entry with the expected offset. This 			 * is probably the entry we want, but if not, the 			 * code below will turn off seqopt and retry. 			 */
name|slot
operator|=
name|i
expr_stmt|;
block|}
else|else
name|dh
operator|->
name|dh_seqopt
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
operator|(
name|offset
operator|=
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|slot
argument_list|)
operator|)
operator|!=
name|DIRHASH_EMPTY
condition|;
name|slot
operator|=
name|WRAPINCR
argument_list|(
name|slot
argument_list|,
name|dh
operator|->
name|dh_hlen
argument_list|)
control|)
block|{
if|if
condition|(
name|offset
operator|==
name|DIRHASH_DEL
condition|)
continue|continue;
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>=
name|ip
operator|->
name|i_size
condition|)
name|panic
argument_list|(
literal|"ufsdirhash_lookup: bad offset in hash array"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
operator|~
name|bmask
operator|)
operator|!=
name|blkoff
condition|)
block|{
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|blkoff
operator|=
name|offset
operator|&
operator|~
name|bmask
expr_stmt|;
if|if
condition|(
name|UFS_BLKATOFF
argument_list|(
name|vp
argument_list|,
operator|(
name|off_t
operator|)
name|blkoff
argument_list|,
name|NULL
argument_list|,
operator|&
name|bp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EJUSTRETURN
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|dp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_data
operator|+
operator|(
name|offset
operator|&
name|bmask
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_reclen
operator|==
literal|0
operator|||
name|dp
operator|->
name|d_reclen
operator|>
name|DIRBLKSIZ
operator|-
operator|(
name|offset
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* Corrupted directory. */
name|error
operator|=
name|EJUSTRETURN
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_namlen
operator|==
name|namelen
operator|&&
name|bcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found. Get the prev offset if needed. */
if|if
condition|(
name|prevoffp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|offset
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
condition|)
block|{
name|prevoff
operator|=
name|ufsdirhash_getprev
argument_list|(
name|dp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevoff
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EJUSTRETURN
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
else|else
name|prevoff
operator|=
name|offset
expr_stmt|;
operator|*
name|prevoffp
operator|=
name|prevoff
expr_stmt|;
block|}
comment|/* Check for sequential access, and update offset. */
if|if
condition|(
name|dh
operator|->
name|dh_seqopt
operator|==
literal|0
operator|&&
name|dh
operator|->
name|dh_seqoff
operator|==
name|offset
condition|)
name|dh
operator|->
name|dh_seqopt
operator|=
literal|1
expr_stmt|;
name|dh
operator|->
name|dh_seqoff
operator|=
name|offset
operator|+
name|DIRSIZ
argument_list|(
literal|0
argument_list|,
name|dp
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
operator|*
name|offp
operator|=
name|offset
expr_stmt|;
name|ufsdirhash_release
argument_list|(
name|dh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * When the name doesn't match in the seqopt case, go back 		 * and search normally. 		 */
if|if
condition|(
name|dh
operator|->
name|dh_seqopt
condition|)
block|{
name|dh
operator|->
name|dh_seqopt
operator|=
literal|0
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|error
operator|=
name|ENOENT
expr_stmt|;
name|fail
label|:
name|ufsdirhash_release
argument_list|(
name|dh
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a directory block with room for 'slotneeded' bytes. Returns  * the offset of the directory entry that begins the free space.  * This will either be the offset of an existing entry that has free  * space at the end, or the offset of an entry with d_ino == 0 at  * the start of a DIRBLKSIZ block.  *  * To use the space, the caller may need to compact existing entries in  * the directory. The total number of bytes in all of the entries involved  * in the compaction is stored in *slotsize. In other words, all of  * the entries that must be compacted are exactly contained in the  * region beginning at the returned offset and spanning *slotsize bytes.  *  * Returns -1 if no space was found, indicating that the directory  * must be extended.  */
end_comment

begin_function
name|doff_t
name|ufsdirhash_findfree
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|int
name|slotneeded
parameter_list|,
name|int
modifier|*
name|slotsize
parameter_list|)
block|{
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|struct
name|dirhash
modifier|*
name|dh
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|doff_t
name|pos
decl_stmt|,
name|slotstart
decl_stmt|;
name|int
name|dirblock
decl_stmt|,
name|error
decl_stmt|,
name|freebytes
decl_stmt|,
name|i
decl_stmt|;
name|dh
operator|=
name|ip
operator|->
name|i_dirhash
expr_stmt|;
name|KASSERT
argument_list|(
name|dh
operator|!=
name|NULL
operator|&&
name|dh
operator|->
name|dh_hash
operator|!=
name|NULL
argument_list|,
operator|(
literal|"ufsdirhash_findfree: Invalid dirhash %p\n"
operator|,
name|dh
operator|)
argument_list|)
expr_stmt|;
name|DIRHASH_ASSERT_LOCKED
argument_list|(
name|dh
argument_list|)
expr_stmt|;
comment|/* Find a directory block with the desired free space. */
name|dirblock
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|howmany
argument_list|(
name|slotneeded
argument_list|,
name|DIRALIGN
argument_list|)
init|;
name|i
operator|<=
name|DH_NFSTATS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|dirblock
operator|=
name|dh
operator|->
name|dh_firstfree
index|[
name|i
index|]
operator|)
operator|!=
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|dirblock
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|KASSERT
argument_list|(
name|dirblock
operator|<
name|dh
operator|->
name|dh_nblk
operator|&&
name|dh
operator|->
name|dh_blkfree
index|[
name|dirblock
index|]
operator|>=
name|howmany
argument_list|(
name|slotneeded
argument_list|,
name|DIRALIGN
argument_list|)
argument_list|,
operator|(
literal|"ufsdirhash_findfree: bad stats"
operator|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|dirblock
operator|*
name|DIRBLKSIZ
expr_stmt|;
name|error
operator|=
name|UFS_BLKATOFF
argument_list|(
name|ip
operator|->
name|i_vnode
argument_list|,
operator|(
name|off_t
operator|)
name|pos
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|dp
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Find the first entry with free space. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DIRBLKSIZ
condition|;
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_reclen
operator|==
literal|0
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|==
literal|0
operator|||
name|dp
operator|->
name|d_reclen
operator|>
name|DIRSIZ
argument_list|(
literal|0
argument_list|,
name|dp
argument_list|)
condition|)
break|break;
name|i
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|+
name|dp
operator|->
name|d_reclen
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
name|DIRBLKSIZ
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|slotstart
operator|=
name|pos
operator|+
name|i
expr_stmt|;
comment|/* Find the range of entries needed to get enough space */
name|freebytes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|DIRBLKSIZ
operator|&&
name|freebytes
operator|<
name|slotneeded
condition|)
block|{
name|freebytes
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|!=
literal|0
condition|)
name|freebytes
operator|-=
name|DIRSIZ
argument_list|(
literal|0
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_reclen
operator|==
literal|0
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|i
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|+
name|dp
operator|->
name|d_reclen
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
name|DIRBLKSIZ
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|freebytes
operator|<
name|slotneeded
condition|)
name|panic
argument_list|(
literal|"ufsdirhash_findfree: free mismatch"
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|*
name|slotsize
operator|=
name|pos
operator|+
name|i
operator|-
name|slotstart
expr_stmt|;
return|return
operator|(
name|slotstart
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the start of the unused space at the end of a directory, or  * -1 if there are no trailing unused blocks.  */
end_comment

begin_function
name|doff_t
name|ufsdirhash_enduseful
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|)
block|{
name|struct
name|dirhash
modifier|*
name|dh
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dh
operator|=
name|ip
operator|->
name|i_dirhash
expr_stmt|;
name|DIRHASH_ASSERT_LOCKED
argument_list|(
name|dh
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|dh
operator|!=
name|NULL
operator|&&
name|dh
operator|->
name|dh_hash
operator|!=
name|NULL
argument_list|,
operator|(
literal|"ufsdirhash_enduseful: Invalid dirhash %p\n"
operator|,
name|dh
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|->
name|dh_blkfree
index|[
name|dh
operator|->
name|dh_dirblks
operator|-
literal|1
index|]
operator|!=
name|DIRBLKSIZ
operator|/
name|DIRALIGN
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
name|dh
operator|->
name|dh_dirblks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|dh
operator|->
name|dh_blkfree
index|[
name|i
index|]
operator|!=
name|DIRBLKSIZ
operator|/
name|DIRALIGN
condition|)
break|break;
return|return
operator|(
call|(
name|doff_t
call|)
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|*
name|DIRBLKSIZ
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert information into the hash about a new directory entry. dirp  * points to a struct direct containing the entry, and offset specifies  * the offset of this entry.  */
end_comment

begin_function
name|void
name|ufsdirhash_add
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|struct
name|direct
modifier|*
name|dirp
parameter_list|,
name|doff_t
name|offset
parameter_list|)
block|{
name|struct
name|dirhash
modifier|*
name|dh
decl_stmt|;
name|int
name|slot
decl_stmt|;
if|if
condition|(
operator|(
name|dh
operator|=
name|ufsdirhash_acquire
argument_list|(
name|ip
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|KASSERT
argument_list|(
name|offset
operator|<
name|dh
operator|->
name|dh_dirblks
operator|*
name|DIRBLKSIZ
argument_list|,
operator|(
literal|"ufsdirhash_add: bad offset"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Normal hash usage is< 66%. If the usage gets too high then 	 * remove the hash entirely and let it be rebuilt later. 	 */
if|if
condition|(
name|dh
operator|->
name|dh_hused
operator|>=
operator|(
name|dh
operator|->
name|dh_hlen
operator|*
literal|3
operator|)
operator|/
literal|4
condition|)
block|{
name|ufsdirhash_free_locked
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find a free hash slot (empty or deleted), and add the entry. */
name|slot
operator|=
name|ufsdirhash_hash
argument_list|(
name|dh
argument_list|,
name|dirp
operator|->
name|d_name
argument_list|,
name|dirp
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
while|while
condition|(
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|slot
argument_list|)
operator|>=
literal|0
condition|)
name|slot
operator|=
name|WRAPINCR
argument_list|(
name|slot
argument_list|,
name|dh
operator|->
name|dh_hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|slot
argument_list|)
operator|==
name|DIRHASH_EMPTY
condition|)
name|dh
operator|->
name|dh_hused
operator|++
expr_stmt|;
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|slot
argument_list|)
operator|=
name|offset
expr_stmt|;
comment|/* Update the per-block summary info. */
name|ufsdirhash_adjfree
argument_list|(
name|dh
argument_list|,
name|offset
argument_list|,
operator|-
name|DIRSIZ
argument_list|(
literal|0
argument_list|,
name|dirp
argument_list|)
argument_list|)
expr_stmt|;
name|ufsdirhash_release
argument_list|(
name|dh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the specified directory entry from the hash. The entry to remove  * is defined by the name in `dirp', which must exist at the specified  * `offset' within the directory.  */
end_comment

begin_function
name|void
name|ufsdirhash_remove
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|struct
name|direct
modifier|*
name|dirp
parameter_list|,
name|doff_t
name|offset
parameter_list|)
block|{
name|struct
name|dirhash
modifier|*
name|dh
decl_stmt|;
name|int
name|slot
decl_stmt|;
if|if
condition|(
operator|(
name|dh
operator|=
name|ufsdirhash_acquire
argument_list|(
name|ip
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|KASSERT
argument_list|(
name|offset
operator|<
name|dh
operator|->
name|dh_dirblks
operator|*
name|DIRBLKSIZ
argument_list|,
operator|(
literal|"ufsdirhash_remove: bad offset"
operator|)
argument_list|)
expr_stmt|;
comment|/* Find the entry */
name|slot
operator|=
name|ufsdirhash_findslot
argument_list|(
name|dh
argument_list|,
name|dirp
operator|->
name|d_name
argument_list|,
name|dirp
operator|->
name|d_namlen
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* Remove the hash entry. */
name|ufsdirhash_delslot
argument_list|(
name|dh
argument_list|,
name|slot
argument_list|)
expr_stmt|;
comment|/* Update the per-block summary info. */
name|ufsdirhash_adjfree
argument_list|(
name|dh
argument_list|,
name|offset
argument_list|,
name|DIRSIZ
argument_list|(
literal|0
argument_list|,
name|dirp
argument_list|)
argument_list|)
expr_stmt|;
name|ufsdirhash_release
argument_list|(
name|dh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change the offset associated with a directory entry in the hash. Used  * when compacting directory blocks.  */
end_comment

begin_function
name|void
name|ufsdirhash_move
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|struct
name|direct
modifier|*
name|dirp
parameter_list|,
name|doff_t
name|oldoff
parameter_list|,
name|doff_t
name|newoff
parameter_list|)
block|{
name|struct
name|dirhash
modifier|*
name|dh
decl_stmt|;
name|int
name|slot
decl_stmt|;
if|if
condition|(
operator|(
name|dh
operator|=
name|ufsdirhash_acquire
argument_list|(
name|ip
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|KASSERT
argument_list|(
name|oldoff
operator|<
name|dh
operator|->
name|dh_dirblks
operator|*
name|DIRBLKSIZ
operator|&&
name|newoff
operator|<
name|dh
operator|->
name|dh_dirblks
operator|*
name|DIRBLKSIZ
argument_list|,
operator|(
literal|"ufsdirhash_move: bad offset"
operator|)
argument_list|)
expr_stmt|;
comment|/* Find the entry, and update the offset. */
name|slot
operator|=
name|ufsdirhash_findslot
argument_list|(
name|dh
argument_list|,
name|dirp
operator|->
name|d_name
argument_list|,
name|dirp
operator|->
name|d_namlen
argument_list|,
name|oldoff
argument_list|)
expr_stmt|;
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|slot
argument_list|)
operator|=
name|newoff
expr_stmt|;
name|ufsdirhash_release
argument_list|(
name|dh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Inform dirhash that the directory has grown by one block that  * begins at offset (i.e. the new length is offset + DIRBLKSIZ).  */
end_comment

begin_function
name|void
name|ufsdirhash_newblk
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|doff_t
name|offset
parameter_list|)
block|{
name|struct
name|dirhash
modifier|*
name|dh
decl_stmt|;
name|int
name|block
decl_stmt|;
if|if
condition|(
operator|(
name|dh
operator|=
name|ufsdirhash_acquire
argument_list|(
name|ip
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|KASSERT
argument_list|(
name|offset
operator|==
name|dh
operator|->
name|dh_dirblks
operator|*
name|DIRBLKSIZ
argument_list|,
operator|(
literal|"ufsdirhash_newblk: bad offset"
operator|)
argument_list|)
expr_stmt|;
name|block
operator|=
name|offset
operator|/
name|DIRBLKSIZ
expr_stmt|;
if|if
condition|(
name|block
operator|>=
name|dh
operator|->
name|dh_nblk
condition|)
block|{
comment|/* Out of space; must rebuild. */
name|ufsdirhash_free_locked
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
name|dh
operator|->
name|dh_dirblks
operator|=
name|block
operator|+
literal|1
expr_stmt|;
comment|/* Account for the new free block. */
name|dh
operator|->
name|dh_blkfree
index|[
name|block
index|]
operator|=
name|DIRBLKSIZ
operator|/
name|DIRALIGN
expr_stmt|;
if|if
condition|(
name|dh
operator|->
name|dh_firstfree
index|[
name|DH_NFSTATS
index|]
operator|==
operator|-
literal|1
condition|)
name|dh
operator|->
name|dh_firstfree
index|[
name|DH_NFSTATS
index|]
operator|=
name|block
expr_stmt|;
name|ufsdirhash_release
argument_list|(
name|dh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Inform dirhash that the directory is being truncated.  */
end_comment

begin_function
name|void
name|ufsdirhash_dirtrunc
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|doff_t
name|offset
parameter_list|)
block|{
name|struct
name|dirhash
modifier|*
name|dh
decl_stmt|;
name|int
name|block
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|dh
operator|=
name|ufsdirhash_acquire
argument_list|(
name|ip
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|KASSERT
argument_list|(
name|offset
operator|<=
name|dh
operator|->
name|dh_dirblks
operator|*
name|DIRBLKSIZ
argument_list|,
operator|(
literal|"ufsdirhash_dirtrunc: bad offset"
operator|)
argument_list|)
expr_stmt|;
name|block
operator|=
name|howmany
argument_list|(
name|offset
argument_list|,
name|DIRBLKSIZ
argument_list|)
expr_stmt|;
comment|/* 	 * If the directory shrinks to less than 1/8 of dh_nblk blocks 	 * (about 20% of its original size due to the 50% extra added in 	 * ufsdirhash_build) then free it, and let the caller rebuild 	 * if necessary. 	 */
if|if
condition|(
name|block
operator|<
name|dh
operator|->
name|dh_nblk
operator|/
literal|8
operator|&&
name|dh
operator|->
name|dh_narrays
operator|>
literal|1
condition|)
block|{
name|ufsdirhash_free_locked
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Remove any `first free' information pertaining to the 	 * truncated blocks. All blocks we're removing should be 	 * completely unused. 	 */
if|if
condition|(
name|dh
operator|->
name|dh_firstfree
index|[
name|DH_NFSTATS
index|]
operator|>=
name|block
condition|)
name|dh
operator|->
name|dh_firstfree
index|[
name|DH_NFSTATS
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|block
init|;
name|i
operator|<
name|dh
operator|->
name|dh_dirblks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dh
operator|->
name|dh_blkfree
index|[
name|i
index|]
operator|!=
name|DIRBLKSIZ
operator|/
name|DIRALIGN
condition|)
name|panic
argument_list|(
literal|"ufsdirhash_dirtrunc: blocks in use"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DH_NFSTATS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dh
operator|->
name|dh_firstfree
index|[
name|i
index|]
operator|>=
name|block
condition|)
name|panic
argument_list|(
literal|"ufsdirhash_dirtrunc: first free corrupt"
argument_list|)
expr_stmt|;
name|dh
operator|->
name|dh_dirblks
operator|=
name|block
expr_stmt|;
name|ufsdirhash_release
argument_list|(
name|dh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Debugging function to check that the dirhash information about  * a directory block matches its actual contents. Panics if a mismatch  * is detected.  *  * On entry, `buf' should point to the start of an in-core  * DIRBLKSIZ-sized directory block, and `offset' should contain the  * offset from the start of the directory of that block.  */
end_comment

begin_function
name|void
name|ufsdirhash_checkblock
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|doff_t
name|offset
parameter_list|)
block|{
name|struct
name|dirhash
modifier|*
name|dh
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|int
name|block
decl_stmt|,
name|ffslot
decl_stmt|,
name|i
decl_stmt|,
name|nfree
decl_stmt|;
if|if
condition|(
operator|!
name|ufs_dirhashcheck
condition|)
return|return;
if|if
condition|(
operator|(
name|dh
operator|=
name|ufsdirhash_acquire
argument_list|(
name|ip
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|block
operator|=
name|offset
operator|/
name|DIRBLKSIZ
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
operator|||
name|block
operator|>=
name|dh
operator|->
name|dh_dirblks
condition|)
name|panic
argument_list|(
literal|"ufsdirhash_checkblock: bad offset"
argument_list|)
expr_stmt|;
name|nfree
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DIRBLKSIZ
condition|;
name|i
operator|+=
name|dp
operator|->
name|d_reclen
control|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
name|buf
operator|+
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_reclen
operator|==
literal|0
operator|||
name|i
operator|+
name|dp
operator|->
name|d_reclen
operator|>
name|DIRBLKSIZ
condition|)
name|panic
argument_list|(
literal|"ufsdirhash_checkblock: bad dir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* 			 * XXX entries with d_ino == 0 should only occur 			 * at the start of a DIRBLKSIZ block. However the 			 * ufs code is tolerant of such entries at other 			 * offsets, and fsck does not fix them. 			 */
block|if (i != 0) 				panic("ufsdirhash_checkblock: bad dir inode");
endif|#
directive|endif
name|nfree
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
continue|continue;
block|}
comment|/* Check that the entry	exists (will panic if it doesn't). */
name|ufsdirhash_findslot
argument_list|(
name|dh
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|dp
operator|->
name|d_namlen
argument_list|,
name|offset
operator|+
name|i
argument_list|)
expr_stmt|;
name|nfree
operator|+=
name|dp
operator|->
name|d_reclen
operator|-
name|DIRSIZ
argument_list|(
literal|0
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|DIRBLKSIZ
condition|)
name|panic
argument_list|(
literal|"ufsdirhash_checkblock: bad dir end"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|->
name|dh_blkfree
index|[
name|block
index|]
operator|*
name|DIRALIGN
operator|!=
name|nfree
condition|)
name|panic
argument_list|(
literal|"ufsdirhash_checkblock: bad free count"
argument_list|)
expr_stmt|;
name|ffslot
operator|=
name|BLKFREE2IDX
argument_list|(
name|nfree
operator|/
name|DIRALIGN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|DH_NFSTATS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dh
operator|->
name|dh_firstfree
index|[
name|i
index|]
operator|==
name|block
operator|&&
name|i
operator|!=
name|ffslot
condition|)
name|panic
argument_list|(
literal|"ufsdirhash_checkblock: bad first-free"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|->
name|dh_firstfree
index|[
name|ffslot
index|]
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"ufsdirhash_checkblock: missing first-free entry"
argument_list|)
expr_stmt|;
name|ufsdirhash_release
argument_list|(
name|dh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hash the specified filename into a dirhash slot.  */
end_comment

begin_function
specifier|static
name|int
name|ufsdirhash_hash
parameter_list|(
name|struct
name|dirhash
modifier|*
name|dh
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
name|u_int32_t
name|hash
decl_stmt|;
comment|/* 	 * We hash the name and then some other bit of data that is 	 * invariant over the dirhash's lifetime. Otherwise names 	 * differing only in the last byte are placed close to one 	 * another in the table, which is bad for linear probing. 	 */
name|hash
operator|=
name|fnv_32_buf
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
name|FNV1_32_INIT
argument_list|)
expr_stmt|;
name|hash
operator|=
name|fnv_32_buf
argument_list|(
operator|&
name|dh
argument_list|,
sizeof|sizeof
argument_list|(
name|dh
argument_list|)
argument_list|,
name|hash
argument_list|)
expr_stmt|;
return|return
operator|(
name|hash
operator|%
name|dh
operator|->
name|dh_hlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust the number of free bytes in the block containing `offset'  * by the value specified by `diff'.  *  * The caller must ensure we have exclusive access to `dh'; normally  * that means that dh_lock should be held, but this is also called  * from ufsdirhash_build() where exclusive access can be assumed.  */
end_comment

begin_function
specifier|static
name|void
name|ufsdirhash_adjfree
parameter_list|(
name|struct
name|dirhash
modifier|*
name|dh
parameter_list|,
name|doff_t
name|offset
parameter_list|,
name|int
name|diff
parameter_list|)
block|{
name|int
name|block
decl_stmt|,
name|i
decl_stmt|,
name|nfidx
decl_stmt|,
name|ofidx
decl_stmt|;
comment|/* Update the per-block summary info. */
name|block
operator|=
name|offset
operator|/
name|DIRBLKSIZ
expr_stmt|;
name|KASSERT
argument_list|(
name|block
operator|<
name|dh
operator|->
name|dh_nblk
operator|&&
name|block
operator|<
name|dh
operator|->
name|dh_dirblks
argument_list|,
operator|(
literal|"dirhash bad offset"
operator|)
argument_list|)
expr_stmt|;
name|ofidx
operator|=
name|BLKFREE2IDX
argument_list|(
name|dh
operator|->
name|dh_blkfree
index|[
name|block
index|]
argument_list|)
expr_stmt|;
name|dh
operator|->
name|dh_blkfree
index|[
name|block
index|]
operator|=
operator|(
name|int
operator|)
name|dh
operator|->
name|dh_blkfree
index|[
name|block
index|]
operator|+
operator|(
name|diff
operator|/
name|DIRALIGN
operator|)
expr_stmt|;
name|nfidx
operator|=
name|BLKFREE2IDX
argument_list|(
name|dh
operator|->
name|dh_blkfree
index|[
name|block
index|]
argument_list|)
expr_stmt|;
comment|/* Update the `first free' list if necessary. */
if|if
condition|(
name|ofidx
operator|!=
name|nfidx
condition|)
block|{
comment|/* If removing, scan forward for the next block. */
if|if
condition|(
name|dh
operator|->
name|dh_firstfree
index|[
name|ofidx
index|]
operator|==
name|block
condition|)
block|{
for|for
control|(
name|i
operator|=
name|block
operator|+
literal|1
init|;
name|i
operator|<
name|dh
operator|->
name|dh_dirblks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|BLKFREE2IDX
argument_list|(
name|dh
operator|->
name|dh_blkfree
index|[
name|i
index|]
argument_list|)
operator|==
name|ofidx
condition|)
break|break;
name|dh
operator|->
name|dh_firstfree
index|[
name|ofidx
index|]
operator|=
operator|(
name|i
operator|<
name|dh
operator|->
name|dh_dirblks
operator|)
condition|?
name|i
else|:
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Make this the new `first free' if necessary */
if|if
condition|(
name|dh
operator|->
name|dh_firstfree
index|[
name|nfidx
index|]
operator|>
name|block
operator|||
name|dh
operator|->
name|dh_firstfree
index|[
name|nfidx
index|]
operator|==
operator|-
literal|1
condition|)
name|dh
operator|->
name|dh_firstfree
index|[
name|nfidx
index|]
operator|=
name|block
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find the specified name which should have the specified offset.  * Returns a slot number, and panics on failure.  *  * `dh' must be locked on entry and remains so on return.  */
end_comment

begin_function
specifier|static
name|int
name|ufsdirhash_findslot
parameter_list|(
name|struct
name|dirhash
modifier|*
name|dh
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|doff_t
name|offset
parameter_list|)
block|{
name|int
name|slot
decl_stmt|;
name|DIRHASH_ASSERT_LOCKED
argument_list|(
name|dh
argument_list|)
expr_stmt|;
comment|/* Find the entry. */
name|KASSERT
argument_list|(
name|dh
operator|->
name|dh_hused
operator|<
name|dh
operator|->
name|dh_hlen
argument_list|,
operator|(
literal|"dirhash find full"
operator|)
argument_list|)
expr_stmt|;
name|slot
operator|=
name|ufsdirhash_hash
argument_list|(
name|dh
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
while|while
condition|(
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|slot
argument_list|)
operator|!=
name|offset
operator|&&
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|slot
argument_list|)
operator|!=
name|DIRHASH_EMPTY
condition|)
name|slot
operator|=
name|WRAPINCR
argument_list|(
name|slot
argument_list|,
name|dh
operator|->
name|dh_hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|slot
argument_list|)
operator|!=
name|offset
condition|)
name|panic
argument_list|(
literal|"ufsdirhash_findslot: '%.*s' not found"
argument_list|,
name|namelen
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|slot
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the entry corresponding to the specified slot from the hash array.  *  * `dh' must be locked on entry and remains so on return.  */
end_comment

begin_function
specifier|static
name|void
name|ufsdirhash_delslot
parameter_list|(
name|struct
name|dirhash
modifier|*
name|dh
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DIRHASH_ASSERT_LOCKED
argument_list|(
name|dh
argument_list|)
expr_stmt|;
comment|/* Mark the entry as deleted. */
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|slot
argument_list|)
operator|=
name|DIRHASH_DEL
expr_stmt|;
comment|/* If this is the end of a chain of DIRHASH_DEL slots, remove them. */
for|for
control|(
name|i
operator|=
name|slot
init|;
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|i
argument_list|)
operator|==
name|DIRHASH_DEL
condition|;
control|)
name|i
operator|=
name|WRAPINCR
argument_list|(
name|i
argument_list|,
name|dh
operator|->
name|dh_hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|i
argument_list|)
operator|==
name|DIRHASH_EMPTY
condition|)
block|{
name|i
operator|=
name|WRAPDECR
argument_list|(
name|i
argument_list|,
name|dh
operator|->
name|dh_hlen
argument_list|)
expr_stmt|;
while|while
condition|(
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|i
argument_list|)
operator|==
name|DIRHASH_DEL
condition|)
block|{
name|DH_ENTRY
argument_list|(
name|dh
argument_list|,
name|i
argument_list|)
operator|=
name|DIRHASH_EMPTY
expr_stmt|;
name|dh
operator|->
name|dh_hused
operator|--
expr_stmt|;
name|i
operator|=
name|WRAPDECR
argument_list|(
name|i
argument_list|,
name|dh
operator|->
name|dh_hlen
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|dh
operator|->
name|dh_hused
operator|>=
literal|0
argument_list|,
operator|(
literal|"ufsdirhash_delslot neg hlen"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Given a directory entry and its offset, find the offset of the  * previous entry in the same DIRBLKSIZ-sized block. Returns an  * offset, or -1 if there is no previous entry in the block or some  * other problem occurred.  */
end_comment

begin_function
specifier|static
name|doff_t
name|ufsdirhash_getprev
parameter_list|(
name|struct
name|direct
modifier|*
name|dirp
parameter_list|,
name|doff_t
name|offset
parameter_list|)
block|{
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|blkbuf
decl_stmt|;
name|doff_t
name|blkoff
decl_stmt|,
name|prevoff
decl_stmt|;
name|int
name|entrypos
decl_stmt|,
name|i
decl_stmt|;
name|blkoff
operator|=
name|offset
operator|&
operator|~
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* offset of start of block */
name|entrypos
operator|=
name|offset
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* entry relative to block */
name|blkbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|dirp
operator|-
name|entrypos
expr_stmt|;
name|prevoff
operator|=
name|blkoff
expr_stmt|;
comment|/* If `offset' is the start of a block, there is no previous entry. */
if|if
condition|(
name|entrypos
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Scan from the start of the block until we get to the entry. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entrypos
condition|;
name|i
operator|+=
name|dp
operator|->
name|d_reclen
control|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
name|blkbuf
operator|+
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_reclen
operator|==
literal|0
operator|||
name|i
operator|+
name|dp
operator|->
name|d_reclen
operator|>
name|entrypos
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Corrupted directory. */
name|prevoff
operator|=
name|blkoff
operator|+
name|i
expr_stmt|;
block|}
return|return
operator|(
name|prevoff
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to free up `wanted' bytes by stealing memory from existing  * dirhashes. Returns zero with list locked if successful.  */
end_comment

begin_function
specifier|static
name|int
name|ufsdirhash_recycle
parameter_list|(
name|int
name|wanted
parameter_list|)
block|{
name|struct
name|dirhash
modifier|*
name|dh
decl_stmt|;
name|doff_t
modifier|*
modifier|*
name|hash
decl_stmt|;
name|u_int8_t
modifier|*
name|blkfree
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mem
decl_stmt|,
name|narrays
decl_stmt|;
name|DIRHASHLIST_LOCK
argument_list|()
expr_stmt|;
name|dh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ufsdirhash_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|wanted
operator|+
name|ufs_dirhashmem
operator|>
name|ufs_dirhashmaxmem
condition|)
block|{
comment|/* Decrement the score; only recycle if it becomes zero. */
if|if
condition|(
name|dh
operator|==
name|NULL
operator|||
operator|--
name|dh
operator|->
name|dh_score
operator|>
literal|0
condition|)
block|{
name|DIRHASHLIST_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * If we can't lock it it's in use and we don't want to 		 * recycle it anyway. 		 */
if|if
condition|(
operator|!
name|sx_try_xlock
argument_list|(
operator|&
name|dh
operator|->
name|dh_lock
argument_list|)
condition|)
block|{
name|dh
operator|=
name|TAILQ_NEXT
argument_list|(
name|dh
argument_list|,
name|dh_list
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|KASSERT
argument_list|(
name|dh
operator|->
name|dh_hash
operator|!=
name|NULL
argument_list|,
operator|(
literal|"dirhash: NULL hash on list"
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove it from the list and detach its memory. */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ufsdirhash_list
argument_list|,
name|dh
argument_list|,
name|dh_list
argument_list|)
expr_stmt|;
name|dh
operator|->
name|dh_onlist
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
name|dh
operator|->
name|dh_hash
expr_stmt|;
name|dh
operator|->
name|dh_hash
operator|=
name|NULL
expr_stmt|;
name|blkfree
operator|=
name|dh
operator|->
name|dh_blkfree
expr_stmt|;
name|dh
operator|->
name|dh_blkfree
operator|=
name|NULL
expr_stmt|;
name|narrays
operator|=
name|dh
operator|->
name|dh_narrays
expr_stmt|;
name|mem
operator|=
name|dh
operator|->
name|dh_memreq
expr_stmt|;
name|dh
operator|->
name|dh_memreq
operator|=
literal|0
expr_stmt|;
comment|/* Unlock everything, free the detached memory. */
name|ufsdirhash_release
argument_list|(
name|dh
argument_list|)
expr_stmt|;
name|DIRHASHLIST_UNLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narrays
condition|;
name|i
operator|++
control|)
name|DIRHASH_BLKFREE
argument_list|(
name|hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|hash
argument_list|,
name|M_DIRHASH
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|blkfree
argument_list|,
name|M_DIRHASH
argument_list|)
expr_stmt|;
comment|/* Account for the returned memory, and repeat if necessary. */
name|DIRHASHLIST_LOCK
argument_list|()
expr_stmt|;
name|ufs_dirhashmem
operator|-=
name|mem
expr_stmt|;
name|dh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ufsdirhash_list
argument_list|)
expr_stmt|;
block|}
comment|/* Success; return with list locked. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ufsdirhash_init
parameter_list|()
block|{
name|ufsdirhash_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"DIRHASH"
argument_list|,
name|DH_NBLKOFF
operator|*
sizeof|sizeof
argument_list|(
name|doff_t
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ufsdirhash_mtx
argument_list|,
literal|"dirhash list"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ufsdirhash_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ufsdirhash_uninit
parameter_list|()
block|{
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ufsdirhash_list
argument_list|)
argument_list|,
operator|(
literal|"ufsdirhash_uninit"
operator|)
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|ufsdirhash_zone
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ufsdirhash_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UFS_DIRHASH */
end_comment

end_unit

