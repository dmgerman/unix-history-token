begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 1998, 2000 Marshall Kirk McKusick.  * Copyright 2009, 2010 Jeffrey W. Roberson<jeff@FreeBSD.org>  * All rights reserved.  *  * The soft updates code is derived from the appendix of a University  * of Michigan technical report (Gregory R. Ganger and Yale N. Patt,  * "Soft Updates: A Solution to the Metadata Update Problem in File  * Systems", CSE-TR-254-95, August 1995).  *  * Further information about soft updates can be obtained from:  *  *	Marshall Kirk McKusick		http://www.mckusick.com/softdep/  *	1614 Oxford Street		mckusick@mckusick.com  *	Berkeley, CA 94709-1608		+1-510-843-9542  *	USA  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS  * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	from: @(#)ffs_softdep.c	9.59 (McKusick) 6/21/00  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ffs.h"
end_include

begin_include
include|#
directive|include
file|"opt_quota.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_comment
comment|/*  * For now we want the safety net that the DEBUG flag provides.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/racct.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/extattr.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/softdep.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/ffs_extern.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufs_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_define
define|#
directive|define
name|KTR_SUJ
value|0
end_define

begin_comment
comment|/* Define to KTR_SPARE. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTUPDATES
end_ifndef

begin_function
name|int
name|softdep_flushfiles
parameter_list|(
name|oldmnt
parameter_list|,
name|flags
parameter_list|,
name|td
parameter_list|)
name|struct
name|mount
modifier|*
name|oldmnt
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_flushfiles called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|softdep_mount
parameter_list|(
name|devvp
parameter_list|,
name|mp
parameter_list|,
name|fs
parameter_list|,
name|cred
parameter_list|)
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|softdep_initialize
parameter_list|()
block|{
return|return;
block|}
end_function

begin_function
name|void
name|softdep_uninitialize
parameter_list|()
block|{
return|return;
block|}
end_function

begin_function
name|void
name|softdep_unmount
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_unmount called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_sbupdate
parameter_list|(
name|ump
parameter_list|,
name|fs
parameter_list|,
name|bp
parameter_list|)
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_setup_sbupdate called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_inomapdep
parameter_list|(
name|bp
parameter_list|,
name|ip
parameter_list|,
name|newinum
parameter_list|,
name|mode
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ino_t
name|newinum
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_setup_inomapdep called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_blkmapdep
parameter_list|(
name|bp
parameter_list|,
name|mp
parameter_list|,
name|newblkno
parameter_list|,
name|frags
parameter_list|,
name|oldfrags
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|ufs2_daddr_t
name|newblkno
decl_stmt|;
name|int
name|frags
decl_stmt|;
name|int
name|oldfrags
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_setup_blkmapdep called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_allocdirect
parameter_list|(
name|ip
parameter_list|,
name|lbn
parameter_list|,
name|newblkno
parameter_list|,
name|oldblkno
parameter_list|,
name|newsize
parameter_list|,
name|oldsize
parameter_list|,
name|bp
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|ufs2_daddr_t
name|newblkno
decl_stmt|;
name|ufs2_daddr_t
name|oldblkno
decl_stmt|;
name|long
name|newsize
decl_stmt|;
name|long
name|oldsize
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_setup_allocdirect called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_allocext
parameter_list|(
name|ip
parameter_list|,
name|lbn
parameter_list|,
name|newblkno
parameter_list|,
name|oldblkno
parameter_list|,
name|newsize
parameter_list|,
name|oldsize
parameter_list|,
name|bp
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|ufs2_daddr_t
name|newblkno
decl_stmt|;
name|ufs2_daddr_t
name|oldblkno
decl_stmt|;
name|long
name|newsize
decl_stmt|;
name|long
name|oldsize
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_setup_allocext called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_allocindir_page
parameter_list|(
name|ip
parameter_list|,
name|lbn
parameter_list|,
name|bp
parameter_list|,
name|ptrno
parameter_list|,
name|newblkno
parameter_list|,
name|oldblkno
parameter_list|,
name|nbp
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|ptrno
decl_stmt|;
name|ufs2_daddr_t
name|newblkno
decl_stmt|;
name|ufs2_daddr_t
name|oldblkno
decl_stmt|;
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_setup_allocindir_page called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_allocindir_meta
parameter_list|(
name|nbp
parameter_list|,
name|ip
parameter_list|,
name|bp
parameter_list|,
name|ptrno
parameter_list|,
name|newblkno
parameter_list|)
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|ptrno
decl_stmt|;
name|ufs2_daddr_t
name|newblkno
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_setup_allocindir_meta called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_journal_freeblocks
parameter_list|(
name|ip
parameter_list|,
name|cred
parameter_list|,
name|length
parameter_list|,
name|flags
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|off_t
name|length
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_journal_freeblocks called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_journal_fsync
parameter_list|(
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_journal_fsync called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_freeblocks
parameter_list|(
name|ip
parameter_list|,
name|length
parameter_list|,
name|flags
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|off_t
name|length
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_setup_freeblocks called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_freefile
parameter_list|(
name|pvp
parameter_list|,
name|ino
parameter_list|,
name|mode
parameter_list|)
name|struct
name|vnode
modifier|*
name|pvp
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_freefile called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|softdep_setup_directory_add
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|,
name|diroffset
parameter_list|,
name|newinum
parameter_list|,
name|newdirbp
parameter_list|,
name|isnewblk
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|off_t
name|diroffset
decl_stmt|;
name|ino_t
name|newinum
decl_stmt|;
name|struct
name|buf
modifier|*
name|newdirbp
decl_stmt|;
name|int
name|isnewblk
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_setup_directory_add called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_change_directoryentry_offset
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|,
name|base
parameter_list|,
name|oldloc
parameter_list|,
name|newloc
parameter_list|,
name|entrysize
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|caddr_t
name|base
decl_stmt|;
name|caddr_t
name|oldloc
decl_stmt|;
name|caddr_t
name|newloc
decl_stmt|;
name|int
name|entrysize
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_change_directoryentry_offset called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_remove
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|,
name|ip
parameter_list|,
name|isrmdir
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|int
name|isrmdir
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_setup_remove called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_directory_change
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|,
name|ip
parameter_list|,
name|newinum
parameter_list|,
name|isrmdir
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ino_t
name|newinum
decl_stmt|;
name|int
name|isrmdir
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_setup_directory_change called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_blkfree
parameter_list|(
name|mp
parameter_list|,
name|bp
parameter_list|,
name|blkno
parameter_list|,
name|frags
parameter_list|,
name|wkhd
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
name|int
name|frags
decl_stmt|;
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"%s called"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_inofree
parameter_list|(
name|mp
parameter_list|,
name|bp
parameter_list|,
name|ino
parameter_list|,
name|wkhd
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"%s called"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_unlink
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"%s called"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_link
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"%s called"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_revert_link
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"%s called"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_rmdir
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"%s called"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_revert_rmdir
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"%s called"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_create
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"%s called"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_revert_create
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"%s called"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_mkdir
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"%s called"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_revert_mkdir
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"%s called"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_setup_dotdot_link
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"%s called"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|softdep_prealloc
parameter_list|(
name|vp
parameter_list|,
name|waitok
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|waitok
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"%s called"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|softdep_journal_lookup
parameter_list|(
name|mp
parameter_list|,
name|vpp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|void
name|softdep_change_linkcnt
parameter_list|(
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_change_linkcnt called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_load_inodeblock
parameter_list|(
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_load_inodeblock called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_update_inodeblock
parameter_list|(
name|ip
parameter_list|,
name|bp
parameter_list|,
name|waitfor
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|waitfor
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_update_inodeblock called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|softdep_fsync
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
comment|/* the "in_core" copy of the inode */
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|softdep_fsync_mountdev
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
return|return;
block|}
end_function

begin_function
name|int
name|softdep_flushworklist
parameter_list|(
name|oldmnt
parameter_list|,
name|countp
parameter_list|,
name|td
parameter_list|)
name|struct
name|mount
modifier|*
name|oldmnt
decl_stmt|;
name|int
modifier|*
name|countp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|softdep_sync_metadata
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
name|panic
argument_list|(
literal|"softdep_sync_metadata called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|softdep_sync_buf
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|waitfor
parameter_list|)
block|{
name|panic
argument_list|(
literal|"softdep_sync_buf called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|softdep_slowdown
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_slowdown called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|softdep_request_cleanup
parameter_list|(
name|fs
parameter_list|,
name|vp
parameter_list|,
name|cred
parameter_list|,
name|resource
parameter_list|)
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|resource
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|softdep_check_suspend
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|vnode
modifier|*
name|devvp
parameter_list|,
name|int
name|softdep_depcnt
parameter_list|,
name|int
name|softdep_accdepcnt
parameter_list|,
name|int
name|secondary_writes
parameter_list|,
name|int
name|secondary_accwrites
parameter_list|)
block|{
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|softdep_depcnt
operator|,
operator|(
name|void
operator|)
name|softdep_accdepcnt
expr_stmt|;
name|bo
operator|=
operator|&
name|devvp
operator|->
name|v_bufobj
expr_stmt|;
name|ASSERT_BO_WLOCKED
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
while|while
condition|(
name|mp
operator|->
name|mnt_secondary_writes
operator|!=
literal|0
condition|)
block|{
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|mp
operator|->
name|mnt_secondary_writes
argument_list|,
name|MNT_MTX
argument_list|(
name|mp
argument_list|)
argument_list|,
operator|(
name|PUSER
operator|-
literal|1
operator|)
operator||
name|PDROP
argument_list|,
literal|"secwr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reasons for needing more work before suspend: 	 * - Dirty buffers on devvp. 	 * - Secondary writes occurred after start of vnode sync loop 	 */
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bo
operator|->
name|bo_numoutput
operator|>
literal|0
operator|||
name|bo
operator|->
name|bo_dirty
operator|.
name|bv_cnt
operator|>
literal|0
operator|||
name|secondary_writes
operator|!=
literal|0
operator|||
name|mp
operator|->
name|mnt_secondary_writes
operator|!=
literal|0
operator|||
name|secondary_accwrites
operator|!=
name|mp
operator|->
name|mnt_secondary_accwrites
condition|)
name|error
operator|=
name|EAGAIN
expr_stmt|;
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|softdep_get_depcounts
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|softdepactivep
parameter_list|,
name|int
modifier|*
name|softdepactiveaccp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|mp
expr_stmt|;
operator|*
name|softdepactivep
operator|=
literal|0
expr_stmt|;
operator|*
name|softdepactiveaccp
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_buf_append
parameter_list|(
name|bp
parameter_list|,
name|wkhd
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_buf_appendwork called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_inode_append
parameter_list|(
name|ip
parameter_list|,
name|cred
parameter_list|,
name|wkhd
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_inode_appendwork called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_freework
parameter_list|(
name|wkhd
parameter_list|)
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"softdep_freework called"
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|FEATURE
argument_list|(
name|softupdates
argument_list|,
literal|"FFS soft-updates support"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|softdep
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"soft updates stats"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|total
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"total dependencies allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|highuse
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"high use dependencies allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|current
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"current dependencies allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|write
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"current dependencies written"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|long
name|dep_current
index|[
name|D_LAST
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|dep_highuse
index|[
name|D_LAST
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|dep_total
index|[
name|D_LAST
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|dep_write
index|[
name|D_LAST
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SOFTDEP_TYPE
parameter_list|(
name|type
parameter_list|,
name|str
parameter_list|,
name|long
parameter_list|)
define|\
value|static MALLOC_DEFINE(M_ ## type, #str, long);			\     SYSCTL_ULONG(_debug_softdep_total, OID_AUTO, str, CTLFLAG_RD,	\&dep_total[D_ ## type], 0, "");					\     SYSCTL_ULONG(_debug_softdep_current, OID_AUTO, str, CTLFLAG_RD, 	\&dep_current[D_ ## type], 0, "");				\     SYSCTL_ULONG(_debug_softdep_highuse, OID_AUTO, str, CTLFLAG_RD, 	\&dep_highuse[D_ ## type], 0, "");				\     SYSCTL_ULONG(_debug_softdep_write, OID_AUTO, str, CTLFLAG_RD, 	\&dep_write[D_ ## type], 0, "");
end_define

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|PAGEDEP
argument_list|,
name|pagedep
argument_list|,
literal|"File page dependencies"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|INODEDEP
argument_list|,
name|inodedep
argument_list|,
literal|"Inode dependencies"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|BMSAFEMAP
argument_list|,
name|bmsafemap
argument_list|,
literal|"Block or frag allocated from cyl group map"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|NEWBLK
argument_list|,
name|newblk
argument_list|,
literal|"New block or frag allocation dependency"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|ALLOCDIRECT
argument_list|,
name|allocdirect
argument_list|,
literal|"Block or frag dependency for an inode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|INDIRDEP
argument_list|,
name|indirdep
argument_list|,
literal|"Indirect block dependencies"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|ALLOCINDIR
argument_list|,
name|allocindir
argument_list|,
literal|"Block dependency for an indirect block"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|FREEFRAG
argument_list|,
name|freefrag
argument_list|,
literal|"Previously used frag for an inode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|FREEBLKS
argument_list|,
name|freeblks
argument_list|,
literal|"Blocks freed from an inode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|FREEFILE
argument_list|,
name|freefile
argument_list|,
literal|"Inode deallocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|DIRADD
argument_list|,
name|diradd
argument_list|,
literal|"New directory entry"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|MKDIR
argument_list|,
name|mkdir
argument_list|,
literal|"New directory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|DIRREM
argument_list|,
name|dirrem
argument_list|,
literal|"Directory entry deleted"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|NEWDIRBLK
argument_list|,
name|newdirblk
argument_list|,
literal|"Unclaimed new directory block"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|FREEWORK
argument_list|,
name|freework
argument_list|,
literal|"free an inode block"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|FREEDEP
argument_list|,
name|freedep
argument_list|,
literal|"track a block free"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|JADDREF
argument_list|,
name|jaddref
argument_list|,
literal|"Journal inode ref add"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|JREMREF
argument_list|,
name|jremref
argument_list|,
literal|"Journal inode ref remove"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|JMVREF
argument_list|,
name|jmvref
argument_list|,
literal|"Journal inode ref move"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|JNEWBLK
argument_list|,
name|jnewblk
argument_list|,
literal|"Journal new block"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|JFREEBLK
argument_list|,
name|jfreeblk
argument_list|,
literal|"Journal free block"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|JFREEFRAG
argument_list|,
name|jfreefrag
argument_list|,
literal|"Journal free frag"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|JSEG
argument_list|,
name|jseg
argument_list|,
literal|"Journal segment"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|JSEGDEP
argument_list|,
name|jsegdep
argument_list|,
literal|"Journal segment complete"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|SBDEP
argument_list|,
name|sbdep
argument_list|,
literal|"Superblock write dependency"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|JTRUNC
argument_list|,
name|jtrunc
argument_list|,
literal|"Journal inode truncation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SOFTDEP_TYPE
argument_list|(
name|JFSYNC
argument_list|,
name|jfsync
argument_list|,
literal|"Journal fsync complete"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SENTINEL
argument_list|,
literal|"sentinel"
argument_list|,
literal|"Worklist sentinel"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SAVEDINO
argument_list|,
literal|"savedino"
argument_list|,
literal|"Saved inodes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_JBLOCKS
argument_list|,
literal|"jblocks"
argument_list|,
literal|"Journal block locations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MOUNTDATA
argument_list|,
literal|"softdep"
argument_list|,
literal|"Softdep per-mount data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|M_SOFTDEP_FLAGS
value|(M_WAITOK)
end_define

begin_comment
comment|/*   * translate from workitem type to memory type  * MUST match the defines above, such that memtype[D_XXX] == M_XXX  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|malloc_type
modifier|*
name|memtype
index|[]
init|=
block|{
name|M_PAGEDEP
block|,
name|M_INODEDEP
block|,
name|M_BMSAFEMAP
block|,
name|M_NEWBLK
block|,
name|M_ALLOCDIRECT
block|,
name|M_INDIRDEP
block|,
name|M_ALLOCINDIR
block|,
name|M_FREEFRAG
block|,
name|M_FREEBLKS
block|,
name|M_FREEFILE
block|,
name|M_DIRADD
block|,
name|M_MKDIR
block|,
name|M_DIRREM
block|,
name|M_NEWDIRBLK
block|,
name|M_FREEWORK
block|,
name|M_FREEDEP
block|,
name|M_JADDREF
block|,
name|M_JREMREF
block|,
name|M_JMVREF
block|,
name|M_JNEWBLK
block|,
name|M_JFREEBLK
block|,
name|M_JFREEFRAG
block|,
name|M_JSEG
block|,
name|M_JSEGDEP
block|,
name|M_SBDEP
block|,
name|M_JTRUNC
block|,
name|M_JFSYNC
block|,
name|M_SENTINEL
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DtoM
parameter_list|(
name|type
parameter_list|)
value|(memtype[type])
end_define

begin_comment
comment|/*  * Names of malloc types.  */
end_comment

begin_define
define|#
directive|define
name|TYPENAME
parameter_list|(
name|type
parameter_list|)
define|\
value|((unsigned)(type)<= D_LAST ? memtype[type]->ks_shortdesc : "???")
end_define

begin_comment
comment|/*  * End system adaptation definitions.  */
end_comment

begin_define
define|#
directive|define
name|DOTDOT_OFFSET
value|offsetof(struct dirtemplate, dotdot_ino)
end_define

begin_define
define|#
directive|define
name|DOT_OFFSET
value|offsetof(struct dirtemplate, dot_ino)
end_define

begin_comment
comment|/*  * Internal function prototypes.  */
end_comment

begin_function_decl
specifier|static
name|void
name|check_clear_deps
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|softdep_error
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|softdep_process_worklist
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|softdep_waitidle
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|drain_output
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|buf
modifier|*
name|getdirtybuf
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|,
name|struct
name|rwlock
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_inodedep_free
parameter_list|(
name|struct
name|inodedep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_remove
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_inodedeps
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unlinked_inodedep
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|inodedep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_unlinked_inodedep
parameter_list|(
name|struct
name|inodedep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|inodedep
modifier|*
name|first_unlinked_inodedep
parameter_list|(
name|struct
name|ufsmount
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|flush_pagedep_deps
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|diraddhd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_pagedep
parameter_list|(
name|struct
name|pagedep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|flush_newblk_dep
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|mount
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|flush_inodedep_deps
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|mount
modifier|*
parameter_list|,
name|ino_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|flush_deplist
parameter_list|(
name|struct
name|allocdirectlst
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sync_cgs
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|handle_written_filepage
parameter_list|(
name|struct
name|pagedep
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|handle_written_sbdep
parameter_list|(
name|struct
name|sbdep
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initiate_write_sbdep
parameter_list|(
name|struct
name|sbdep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|diradd_inode_written
parameter_list|(
name|struct
name|diradd
modifier|*
parameter_list|,
name|struct
name|inodedep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|handle_written_indirdep
parameter_list|(
name|struct
name|indirdep
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|handle_written_inodeblock
parameter_list|(
name|struct
name|inodedep
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jnewblk_rollforward
parameter_list|(
name|struct
name|jnewblk
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|struct
name|cg
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|handle_written_bmsafemap
parameter_list|(
name|struct
name|bmsafemap
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_written_jaddref
parameter_list|(
name|struct
name|jaddref
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_written_jremref
parameter_list|(
name|struct
name|jremref
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_written_jseg
parameter_list|(
name|struct
name|jseg
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_written_jnewblk
parameter_list|(
name|struct
name|jnewblk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_written_jblkdep
parameter_list|(
name|struct
name|jblkdep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_written_jfreefrag
parameter_list|(
name|struct
name|jfreefrag
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|complete_jseg
parameter_list|(
name|struct
name|jseg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|complete_jsegs
parameter_list|(
name|struct
name|jseg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jseg_write
parameter_list|(
name|struct
name|ufsmount
modifier|*
name|ump
parameter_list|,
name|struct
name|jseg
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jaddref_write
parameter_list|(
name|struct
name|jaddref
modifier|*
parameter_list|,
name|struct
name|jseg
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jremref_write
parameter_list|(
name|struct
name|jremref
modifier|*
parameter_list|,
name|struct
name|jseg
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jmvref_write
parameter_list|(
name|struct
name|jmvref
modifier|*
parameter_list|,
name|struct
name|jseg
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jtrunc_write
parameter_list|(
name|struct
name|jtrunc
modifier|*
parameter_list|,
name|struct
name|jseg
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jfsync_write
parameter_list|(
name|struct
name|jfsync
modifier|*
parameter_list|,
name|struct
name|jseg
modifier|*
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jnewblk_write
parameter_list|(
name|struct
name|jnewblk
modifier|*
parameter_list|,
name|struct
name|jseg
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jfreeblk_write
parameter_list|(
name|struct
name|jfreeblk
modifier|*
parameter_list|,
name|struct
name|jseg
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jfreefrag_write
parameter_list|(
name|struct
name|jfreefrag
modifier|*
parameter_list|,
name|struct
name|jseg
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|inoref_write
parameter_list|(
name|struct
name|inoref
modifier|*
parameter_list|,
name|struct
name|jseg
modifier|*
parameter_list|,
name|struct
name|jrefrec
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_allocdirect_partdone
parameter_list|(
name|struct
name|allocdirect
modifier|*
parameter_list|,
name|struct
name|workhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|jnewblk
modifier|*
name|cancel_newblk
parameter_list|(
name|struct
name|newblk
modifier|*
parameter_list|,
name|struct
name|worklist
modifier|*
parameter_list|,
name|struct
name|workhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|indirdep_complete
parameter_list|(
name|struct
name|indirdep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|indirblk_lookup
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|ufs2_daddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|indirblk_insert
parameter_list|(
name|struct
name|freework
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|indirblk_remove
parameter_list|(
name|struct
name|freework
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_allocindir_partdone
parameter_list|(
name|struct
name|allocindir
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initiate_write_filepage
parameter_list|(
name|struct
name|pagedep
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initiate_write_indirdep
parameter_list|(
name|struct
name|indirdep
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_written_mkdir
parameter_list|(
name|struct
name|mkdir
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jnewblk_rollback
parameter_list|(
name|struct
name|jnewblk
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|struct
name|cg
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initiate_write_bmsafemap
parameter_list|(
name|struct
name|bmsafemap
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initiate_write_inodeblock_ufs1
parameter_list|(
name|struct
name|inodedep
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initiate_write_inodeblock_ufs2
parameter_list|(
name|struct
name|inodedep
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_workitem_freefile
parameter_list|(
name|struct
name|freefile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|handle_workitem_remove
parameter_list|(
name|struct
name|dirrem
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|dirrem
modifier|*
name|newdirrem
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|,
name|struct
name|inode
modifier|*
parameter_list|,
name|struct
name|inode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|dirrem
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|indirdep
modifier|*
name|indirdep_lookup
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|inode
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cancel_indirdep
parameter_list|(
name|struct
name|indirdep
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|struct
name|freeblks
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_indirdep
parameter_list|(
name|struct
name|indirdep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_diradd
parameter_list|(
name|struct
name|diradd
modifier|*
parameter_list|,
name|struct
name|workhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|merge_diradd
parameter_list|(
name|struct
name|inodedep
modifier|*
parameter_list|,
name|struct
name|diradd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|complete_diradd
parameter_list|(
name|struct
name|diradd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|diradd
modifier|*
name|diradd_lookup
parameter_list|(
name|struct
name|pagedep
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|jremref
modifier|*
name|cancel_diradd_dotdot
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|,
name|struct
name|dirrem
modifier|*
parameter_list|,
name|struct
name|jremref
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|jremref
modifier|*
name|cancel_mkdir_dotdot
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|,
name|struct
name|dirrem
modifier|*
parameter_list|,
name|struct
name|jremref
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cancel_diradd
parameter_list|(
name|struct
name|diradd
modifier|*
parameter_list|,
name|struct
name|dirrem
modifier|*
parameter_list|,
name|struct
name|jremref
modifier|*
parameter_list|,
name|struct
name|jremref
modifier|*
parameter_list|,
name|struct
name|jremref
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dirrem_journal
parameter_list|(
name|struct
name|dirrem
modifier|*
parameter_list|,
name|struct
name|jremref
modifier|*
parameter_list|,
name|struct
name|jremref
modifier|*
parameter_list|,
name|struct
name|jremref
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cancel_allocindir
parameter_list|(
name|struct
name|allocindir
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|freeblks
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setup_trunc_indir
parameter_list|(
name|struct
name|freeblks
modifier|*
parameter_list|,
name|struct
name|inode
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|ufs2_daddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|complete_trunc_indir
parameter_list|(
name|struct
name|freework
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunc_indirdep
parameter_list|(
name|struct
name|indirdep
modifier|*
parameter_list|,
name|struct
name|freeblks
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|complete_mkdir
parameter_list|(
name|struct
name|mkdir
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_newdirblk
parameter_list|(
name|struct
name|newdirblk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_jremref
parameter_list|(
name|struct
name|jremref
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_jaddref
parameter_list|(
name|struct
name|jaddref
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_jsegdep
parameter_list|(
name|struct
name|jsegdep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_jsegs
parameter_list|(
name|struct
name|jblocks
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rele_jseg
parameter_list|(
name|struct
name|jseg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_jseg
parameter_list|(
name|struct
name|jseg
modifier|*
parameter_list|,
name|struct
name|jblocks
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_jnewblk
parameter_list|(
name|struct
name|jnewblk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_jblkdep
parameter_list|(
name|struct
name|jblkdep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_jfreefrag
parameter_list|(
name|struct
name|jfreefrag
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_freedep
parameter_list|(
name|struct
name|freedep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|journal_jremref
parameter_list|(
name|struct
name|dirrem
modifier|*
parameter_list|,
name|struct
name|jremref
modifier|*
parameter_list|,
name|struct
name|inodedep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cancel_jnewblk
parameter_list|(
name|struct
name|jnewblk
modifier|*
parameter_list|,
name|struct
name|workhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cancel_jaddref
parameter_list|(
name|struct
name|jaddref
modifier|*
parameter_list|,
name|struct
name|inodedep
modifier|*
parameter_list|,
name|struct
name|workhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cancel_jfreefrag
parameter_list|(
name|struct
name|jfreefrag
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|setup_freedirect
parameter_list|(
name|struct
name|freeblks
modifier|*
parameter_list|,
name|struct
name|inode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|setup_freeext
parameter_list|(
name|struct
name|freeblks
modifier|*
parameter_list|,
name|struct
name|inode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|setup_freeindir
parameter_list|(
name|struct
name|freeblks
modifier|*
parameter_list|,
name|struct
name|inode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|struct
name|freeblks
modifier|*
name|newfreeblks
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|inode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freeblks_free
parameter_list|(
name|struct
name|ufsmount
modifier|*
parameter_list|,
name|struct
name|freeblks
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|indir_trunc
parameter_list|(
name|struct
name|freework
modifier|*
parameter_list|,
name|ufs2_daddr_t
parameter_list|,
name|ufs_lbn_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ufs2_daddr_t
name|blkcount
parameter_list|(
name|struct
name|fs
modifier|*
parameter_list|,
name|ufs2_daddr_t
parameter_list|,
name|off_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunc_check_buf
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunc_dependencies
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|,
name|struct
name|freeblks
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunc_pages
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|,
name|off_t
parameter_list|,
name|ufs2_daddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cancel_pagedep
parameter_list|(
name|struct
name|pagedep
modifier|*
parameter_list|,
name|struct
name|freeblks
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|deallocate_dependencies
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|,
name|struct
name|freeblks
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newblk_freefrag
parameter_list|(
name|struct
name|newblk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_newblk
parameter_list|(
name|struct
name|newblk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cancel_allocdirect
parameter_list|(
name|struct
name|allocdirectlst
modifier|*
parameter_list|,
name|struct
name|allocdirect
modifier|*
parameter_list|,
name|struct
name|freeblks
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_inode_unwritten
parameter_list|(
name|struct
name|inodedep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_inodedep
parameter_list|(
name|struct
name|inodedep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freework_freeblock
parameter_list|(
name|struct
name|freework
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freework_enqueue
parameter_list|(
name|struct
name|freework
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|handle_workitem_freeblocks
parameter_list|(
name|struct
name|freeblks
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|handle_complete_freeblocks
parameter_list|(
name|struct
name|freeblks
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_workitem_indirblk
parameter_list|(
name|struct
name|freework
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_written_freework
parameter_list|(
name|struct
name|freework
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|merge_inode_lists
parameter_list|(
name|struct
name|allocdirectlst
modifier|*
parameter_list|,
name|struct
name|allocdirectlst
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|worklist
modifier|*
name|jnewblk_merge
parameter_list|(
name|struct
name|worklist
modifier|*
parameter_list|,
name|struct
name|worklist
modifier|*
parameter_list|,
name|struct
name|workhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|freefrag
modifier|*
name|setup_allocindir_phase2
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|,
name|struct
name|inode
modifier|*
parameter_list|,
name|struct
name|inodedep
modifier|*
parameter_list|,
name|struct
name|allocindir
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|allocindir
modifier|*
name|newallocindir
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|ufs2_daddr_t
parameter_list|,
name|ufs2_daddr_t
parameter_list|,
name|ufs_lbn_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_workitem_freefrag
parameter_list|(
name|struct
name|freefrag
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|freefrag
modifier|*
name|newfreefrag
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|,
name|ufs2_daddr_t
parameter_list|,
name|long
parameter_list|,
name|ufs_lbn_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|allocdirect_merge
parameter_list|(
name|struct
name|allocdirectlst
modifier|*
parameter_list|,
name|struct
name|allocdirect
modifier|*
parameter_list|,
name|struct
name|allocdirect
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|freefrag
modifier|*
name|allocindir_merge
parameter_list|(
name|struct
name|allocindir
modifier|*
parameter_list|,
name|struct
name|allocindir
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bmsafemap_find
parameter_list|(
name|struct
name|bmsafemap_hashhead
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|bmsafemap
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bmsafemap
modifier|*
name|bmsafemap_lookup
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|int
name|cg
parameter_list|,
name|struct
name|bmsafemap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|newblk_find
parameter_list|(
name|struct
name|newblk_hashhead
modifier|*
parameter_list|,
name|ufs2_daddr_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|newblk
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|newblk_lookup
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|ufs2_daddr_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|newblk
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inodedep_find
parameter_list|(
name|struct
name|inodedep_hashhead
modifier|*
parameter_list|,
name|ino_t
parameter_list|,
name|struct
name|inodedep
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inodedep_lookup
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|ino_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|inodedep
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pagedep_lookup
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|ino_t
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|pagedep
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pagedep_find
parameter_list|(
name|struct
name|pagedep_hashhead
modifier|*
parameter_list|,
name|ino_t
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|struct
name|pagedep
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pause_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|request_cleanup
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|softdep_request_cleanup_flush
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|ufsmount
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|schedule_cleanup
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|softdep_ast_cleanup_proc
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|process_worklist_item
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_removes
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_truncates
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jwork_move
parameter_list|(
name|struct
name|workhead
modifier|*
parameter_list|,
name|struct
name|workhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jwork_insert
parameter_list|(
name|struct
name|workhead
modifier|*
parameter_list|,
name|struct
name|jsegdep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_to_worklist
parameter_list|(
name|struct
name|worklist
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wake_worklist
parameter_list|(
name|struct
name|worklist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wait_worklist
parameter_list|(
name|struct
name|worklist
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_from_worklist
parameter_list|(
name|struct
name|worklist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|softdep_flush
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|softdep_flushjournal
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|softdep_speedup
parameter_list|(
name|struct
name|ufsmount
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|worklist_speedup
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|journal_mount
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|fs
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|journal_unmount
parameter_list|(
name|struct
name|ufsmount
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|journal_space
parameter_list|(
name|struct
name|ufsmount
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|journal_suspend
parameter_list|(
name|struct
name|ufsmount
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|journal_unsuspend
parameter_list|(
name|struct
name|ufsmount
modifier|*
name|ump
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|softdep_prelink
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|vnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_to_journal
parameter_list|(
name|struct
name|worklist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_from_journal
parameter_list|(
name|struct
name|worklist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|softdep_excess_items
parameter_list|(
name|struct
name|ufsmount
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|softdep_process_journal
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|worklist
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|jremref
modifier|*
name|newjremref
parameter_list|(
name|struct
name|dirrem
modifier|*
parameter_list|,
name|struct
name|inode
modifier|*
parameter_list|,
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|off_t
parameter_list|,
name|nlink_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|jaddref
modifier|*
name|newjaddref
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|,
name|ino_t
parameter_list|,
name|off_t
parameter_list|,
name|int16_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|newinoref
parameter_list|(
name|struct
name|inoref
modifier|*
parameter_list|,
name|ino_t
parameter_list|,
name|ino_t
parameter_list|,
name|off_t
parameter_list|,
name|nlink_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|struct
name|jsegdep
modifier|*
name|inoref_jseg
parameter_list|(
name|struct
name|inoref
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|jmvref
modifier|*
name|newjmvref
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|,
name|ino_t
parameter_list|,
name|off_t
parameter_list|,
name|off_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|jfreeblk
modifier|*
name|newjfreeblk
parameter_list|(
name|struct
name|freeblks
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|ufs2_daddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adjust_newfreework
parameter_list|(
name|struct
name|freeblks
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|jtrunc
modifier|*
name|newjtrunc
parameter_list|(
name|struct
name|freeblks
modifier|*
parameter_list|,
name|off_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|move_newblock_dep
parameter_list|(
name|struct
name|jaddref
modifier|*
parameter_list|,
name|struct
name|inodedep
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cancel_jfreeblk
parameter_list|(
name|struct
name|freeblks
modifier|*
parameter_list|,
name|ufs2_daddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|jfreefrag
modifier|*
name|newjfreefrag
parameter_list|(
name|struct
name|freefrag
modifier|*
parameter_list|,
name|struct
name|inode
modifier|*
parameter_list|,
name|ufs2_daddr_t
parameter_list|,
name|long
parameter_list|,
name|ufs_lbn_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|freework
modifier|*
name|newfreework
parameter_list|(
name|struct
name|ufsmount
modifier|*
parameter_list|,
name|struct
name|freeblks
modifier|*
parameter_list|,
name|struct
name|freework
modifier|*
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|ufs2_daddr_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jwait
parameter_list|(
name|struct
name|worklist
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|inodedep
modifier|*
name|inodedep_lookup_ip
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bmsafemap_backgroundwrite
parameter_list|(
name|struct
name|bmsafemap
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|freefile
modifier|*
name|handle_bufwait
parameter_list|(
name|struct
name|inodedep
modifier|*
parameter_list|,
name|struct
name|workhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_jwork
parameter_list|(
name|struct
name|workhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mkdir
modifier|*
name|setup_newdir
parameter_list|(
name|struct
name|diradd
modifier|*
parameter_list|,
name|ino_t
parameter_list|,
name|ino_t
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|struct
name|mkdir
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|jblocks
modifier|*
name|jblocks_create
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ufs2_daddr_t
name|jblocks_alloc
parameter_list|(
name|struct
name|jblocks
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jblocks_free
parameter_list|(
name|struct
name|jblocks
modifier|*
parameter_list|,
name|struct
name|mount
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jblocks_destroy
parameter_list|(
name|struct
name|jblocks
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jblocks_add
parameter_list|(
name|struct
name|jblocks
modifier|*
parameter_list|,
name|ufs2_daddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Exported softdep operations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|softdep_disk_io_initiation
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|softdep_disk_write_complete
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|softdep_deallocate_dependencies
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|softdep_count_dependencies
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Global lock over all of soft updates.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|lk
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|softdep_lock
argument_list|,
operator|&
name|lk
argument_list|,
literal|"Global Softdep Lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|ACQUIRE_GBLLOCK
parameter_list|(
name|lk
parameter_list|)
value|mtx_lock(lk)
end_define

begin_define
define|#
directive|define
name|FREE_GBLLOCK
parameter_list|(
name|lk
parameter_list|)
value|mtx_unlock(lk)
end_define

begin_define
define|#
directive|define
name|GBLLOCK_OWNED
parameter_list|(
name|lk
parameter_list|)
value|mtx_assert((lk), MA_OWNED)
end_define

begin_comment
comment|/*  * Per-filesystem soft-updates locking.  */
end_comment

begin_define
define|#
directive|define
name|LOCK_PTR
parameter_list|(
name|ump
parameter_list|)
value|(&(ump)->um_softdep->sd_fslock)
end_define

begin_define
define|#
directive|define
name|TRY_ACQUIRE_LOCK
parameter_list|(
name|ump
parameter_list|)
value|rw_try_wlock(&(ump)->um_softdep->sd_fslock)
end_define

begin_define
define|#
directive|define
name|ACQUIRE_LOCK
parameter_list|(
name|ump
parameter_list|)
value|rw_wlock(&(ump)->um_softdep->sd_fslock)
end_define

begin_define
define|#
directive|define
name|FREE_LOCK
parameter_list|(
name|ump
parameter_list|)
value|rw_wunlock(&(ump)->um_softdep->sd_fslock)
end_define

begin_define
define|#
directive|define
name|LOCK_OWNED
parameter_list|(
name|ump
parameter_list|)
value|rw_assert(&(ump)->um_softdep->sd_fslock, \ 				    RA_WLOCKED)
end_define

begin_define
define|#
directive|define
name|BUF_AREC
parameter_list|(
name|bp
parameter_list|)
value|lockallowrecurse(&(bp)->b_lock)
end_define

begin_define
define|#
directive|define
name|BUF_NOREC
parameter_list|(
name|bp
parameter_list|)
value|lockdisablerecurse(&(bp)->b_lock)
end_define

begin_comment
comment|/*  * Worklist queue management.  * These routines require that the lock be held.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
comment|/* NOT */
name|DEBUG
end_ifndef

begin_define
define|#
directive|define
name|WORKLIST_INSERT
parameter_list|(
name|head
parameter_list|,
name|item
parameter_list|)
value|do {	\ 	(item)->wk_state |= ONWORKLIST;		\ 	LIST_INSERT_HEAD(head, item, wk_list);	\ } while (0)
end_define

begin_define
define|#
directive|define
name|WORKLIST_REMOVE
parameter_list|(
name|item
parameter_list|)
value|do {		\ 	(item)->wk_state&= ~ONWORKLIST;	\ 	LIST_REMOVE(item, wk_list);		\ } while (0)
end_define

begin_define
define|#
directive|define
name|WORKLIST_INSERT_UNLOCKED
value|WORKLIST_INSERT
end_define

begin_define
define|#
directive|define
name|WORKLIST_REMOVE_UNLOCKED
value|WORKLIST_REMOVE
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG */
end_comment

begin_function_decl
specifier|static
name|void
name|worklist_insert
parameter_list|(
name|struct
name|workhead
modifier|*
parameter_list|,
name|struct
name|worklist
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|worklist_remove
parameter_list|(
name|struct
name|worklist
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|WORKLIST_INSERT
parameter_list|(
name|head
parameter_list|,
name|item
parameter_list|)
value|worklist_insert(head, item, 1)
end_define

begin_define
define|#
directive|define
name|WORKLIST_INSERT_UNLOCKED
parameter_list|(
name|head
parameter_list|,
name|item
parameter_list|)
value|worklist_insert(head, item, 0)
end_define

begin_define
define|#
directive|define
name|WORKLIST_REMOVE
parameter_list|(
name|item
parameter_list|)
value|worklist_remove(item, 1)
end_define

begin_define
define|#
directive|define
name|WORKLIST_REMOVE_UNLOCKED
parameter_list|(
name|item
parameter_list|)
value|worklist_remove(item, 0)
end_define

begin_function
specifier|static
name|void
name|worklist_insert
parameter_list|(
name|head
parameter_list|,
name|item
parameter_list|,
name|locked
parameter_list|)
name|struct
name|workhead
modifier|*
name|head
decl_stmt|;
name|struct
name|worklist
modifier|*
name|item
decl_stmt|;
name|int
name|locked
decl_stmt|;
block|{
if|if
condition|(
name|locked
condition|)
name|LOCK_OWNED
argument_list|(
name|VFSTOUFS
argument_list|(
name|item
operator|->
name|wk_mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|wk_state
operator|&
name|ONWORKLIST
condition|)
name|panic
argument_list|(
literal|"worklist_insert: %p %s(0x%X) already on list"
argument_list|,
name|item
argument_list|,
name|TYPENAME
argument_list|(
name|item
operator|->
name|wk_type
argument_list|)
argument_list|,
name|item
operator|->
name|wk_state
argument_list|)
expr_stmt|;
name|item
operator|->
name|wk_state
operator||=
name|ONWORKLIST
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|item
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|worklist_remove
parameter_list|(
name|item
parameter_list|,
name|locked
parameter_list|)
name|struct
name|worklist
modifier|*
name|item
decl_stmt|;
name|int
name|locked
decl_stmt|;
block|{
if|if
condition|(
name|locked
condition|)
name|LOCK_OWNED
argument_list|(
name|VFSTOUFS
argument_list|(
name|item
operator|->
name|wk_mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|item
operator|->
name|wk_state
operator|&
name|ONWORKLIST
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"worklist_remove: %p %s(0x%X) not on list"
argument_list|,
name|item
argument_list|,
name|TYPENAME
argument_list|(
name|item
operator|->
name|wk_type
argument_list|)
argument_list|,
name|item
operator|->
name|wk_state
argument_list|)
expr_stmt|;
name|item
operator|->
name|wk_state
operator|&=
operator|~
name|ONWORKLIST
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|item
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Merge two jsegdeps keeping only the oldest one as newer references  * can't be discarded until after older references.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|jsegdep
modifier|*
name|jsegdep_merge
parameter_list|(
name|struct
name|jsegdep
modifier|*
name|one
parameter_list|,
name|struct
name|jsegdep
modifier|*
name|two
parameter_list|)
block|{
name|struct
name|jsegdep
modifier|*
name|swp
decl_stmt|;
if|if
condition|(
name|two
operator|==
name|NULL
condition|)
return|return
operator|(
name|one
operator|)
return|;
if|if
condition|(
name|one
operator|->
name|jd_seg
operator|->
name|js_seq
operator|>
name|two
operator|->
name|jd_seg
operator|->
name|js_seq
condition|)
block|{
name|swp
operator|=
name|one
expr_stmt|;
name|one
operator|=
name|two
expr_stmt|;
name|two
operator|=
name|swp
expr_stmt|;
block|}
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|two
operator|->
name|jd_list
argument_list|)
expr_stmt|;
name|free_jsegdep
argument_list|(
name|two
argument_list|)
expr_stmt|;
return|return
operator|(
name|one
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If two freedeps are compatible free one to reduce list size.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|freedep
modifier|*
name|freedep_merge
parameter_list|(
name|struct
name|freedep
modifier|*
name|one
parameter_list|,
name|struct
name|freedep
modifier|*
name|two
parameter_list|)
block|{
if|if
condition|(
name|two
operator|==
name|NULL
condition|)
return|return
operator|(
name|one
operator|)
return|;
if|if
condition|(
name|one
operator|->
name|fd_freework
operator|==
name|two
operator|->
name|fd_freework
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|two
operator|->
name|fd_list
argument_list|)
expr_stmt|;
name|free_freedep
argument_list|(
name|two
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|one
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move journal work from one list to another.  Duplicate freedeps and  * jsegdeps are coalesced to keep the lists as small as possible.  */
end_comment

begin_function
specifier|static
name|void
name|jwork_move
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|struct
name|workhead
modifier|*
name|dst
decl_stmt|;
name|struct
name|workhead
modifier|*
name|src
decl_stmt|;
block|{
name|struct
name|freedep
modifier|*
name|freedep
decl_stmt|;
name|struct
name|jsegdep
modifier|*
name|jsegdep
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wkn
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|KASSERT
argument_list|(
name|dst
operator|!=
name|src
argument_list|,
operator|(
literal|"jwork_move: dst == src"
operator|)
argument_list|)
expr_stmt|;
name|freedep
operator|=
name|NULL
expr_stmt|;
name|jsegdep
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|wk
argument_list|,
argument|dst
argument_list|,
argument|wk_list
argument_list|,
argument|wkn
argument_list|)
block|{
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|==
name|D_JSEGDEP
condition|)
name|jsegdep
operator|=
name|jsegdep_merge
argument_list|(
name|WK_JSEGDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|jsegdep
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|==
name|D_FREEDEP
condition|)
name|freedep
operator|=
name|freedep_merge
argument_list|(
name|WK_FREEDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|freedep
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
name|src
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
name|dst
argument_list|,
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|==
name|D_JSEGDEP
condition|)
block|{
name|jsegdep
operator|=
name|jsegdep_merge
argument_list|(
name|WK_JSEGDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|jsegdep
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|==
name|D_FREEDEP
condition|)
name|freedep
operator|=
name|freedep_merge
argument_list|(
name|WK_FREEDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|freedep
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|jwork_insert
parameter_list|(
name|dst
parameter_list|,
name|jsegdep
parameter_list|)
name|struct
name|workhead
modifier|*
name|dst
decl_stmt|;
name|struct
name|jsegdep
modifier|*
name|jsegdep
decl_stmt|;
block|{
name|struct
name|jsegdep
modifier|*
name|jsegdepn
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|dst
argument_list|,
argument|wk_list
argument_list|)
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|==
name|D_JSEGDEP
condition|)
break|break;
if|if
condition|(
name|wk
operator|==
name|NULL
condition|)
block|{
name|WORKLIST_INSERT
argument_list|(
name|dst
argument_list|,
operator|&
name|jsegdep
operator|->
name|jd_list
argument_list|)
expr_stmt|;
return|return;
block|}
name|jsegdepn
operator|=
name|WK_JSEGDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|jsegdep
operator|->
name|jd_seg
operator|->
name|js_seq
operator|<
name|jsegdepn
operator|->
name|jd_seg
operator|->
name|js_seq
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|free_jsegdep
argument_list|(
name|jsegdepn
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
name|dst
argument_list|,
operator|&
name|jsegdep
operator|->
name|jd_list
argument_list|)
expr_stmt|;
block|}
else|else
name|free_jsegdep
argument_list|(
name|jsegdep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routines for tracking and managing workitems.  */
end_comment

begin_function_decl
specifier|static
name|void
name|workitem_free
parameter_list|(
name|struct
name|worklist
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|workitem_alloc
parameter_list|(
name|struct
name|worklist
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|mount
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|workitem_reassign
parameter_list|(
name|struct
name|worklist
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|WORKITEM_FREE
parameter_list|(
name|item
parameter_list|,
name|type
parameter_list|)
define|\
value|workitem_free((struct worklist *)(item), (type))
end_define

begin_define
define|#
directive|define
name|WORKITEM_REASSIGN
parameter_list|(
name|item
parameter_list|,
name|type
parameter_list|)
define|\
value|workitem_reassign((struct worklist *)(item), (type))
end_define

begin_function
specifier|static
name|void
name|workitem_free
parameter_list|(
name|item
parameter_list|,
name|type
parameter_list|)
name|struct
name|worklist
modifier|*
name|item
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|item
operator|->
name|wk_state
operator|&
name|ONWORKLIST
condition|)
name|panic
argument_list|(
literal|"workitem_free: %s(0x%X) still on list"
argument_list|,
name|TYPENAME
argument_list|(
name|item
operator|->
name|wk_type
argument_list|)
argument_list|,
name|item
operator|->
name|wk_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|wk_type
operator|!=
name|type
operator|&&
name|type
operator|!=
name|D_NEWBLK
condition|)
name|panic
argument_list|(
literal|"workitem_free: type mismatch %s != %s"
argument_list|,
name|TYPENAME
argument_list|(
name|item
operator|->
name|wk_type
argument_list|)
argument_list|,
name|TYPENAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|item
operator|->
name|wk_state
operator|&
name|IOWAITING
condition|)
name|wakeup
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|item
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ump
operator|->
name|softdep_deps
operator|>
literal|0
argument_list|,
operator|(
literal|"workitem_free: %s: softdep_deps going negative"
operator|,
name|ump
operator|->
name|um_fs
operator|->
name|fs_fsmnt
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|ump
operator|->
name|softdep_deps
operator|==
literal|0
operator|&&
name|ump
operator|->
name|softdep_req
condition|)
name|wakeup
argument_list|(
operator|&
name|ump
operator|->
name|softdep_deps
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|dep_current
index|[
name|item
operator|->
name|wk_type
index|]
operator|>
literal|0
argument_list|,
operator|(
literal|"workitem_free: %s: dep_current[%s] going negative"
operator|,
name|ump
operator|->
name|um_fs
operator|->
name|fs_fsmnt
operator|,
name|TYPENAME
argument_list|(
name|item
operator|->
name|wk_type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ump
operator|->
name|softdep_curdeps
index|[
name|item
operator|->
name|wk_type
index|]
operator|>
literal|0
argument_list|,
operator|(
literal|"workitem_free: %s: softdep_curdeps[%s] going negative"
operator|,
name|ump
operator|->
name|um_fs
operator|->
name|fs_fsmnt
operator|,
name|TYPENAME
argument_list|(
name|item
operator|->
name|wk_type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|atomic_subtract_long
argument_list|(
operator|&
name|dep_current
index|[
name|item
operator|->
name|wk_type
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ump
operator|->
name|softdep_curdeps
index|[
name|item
operator|->
name|wk_type
index|]
operator|-=
literal|1
expr_stmt|;
name|free
argument_list|(
name|item
argument_list|,
name|DtoM
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|workitem_alloc
parameter_list|(
name|item
parameter_list|,
name|type
parameter_list|,
name|mp
parameter_list|)
name|struct
name|worklist
modifier|*
name|item
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|item
operator|->
name|wk_type
operator|=
name|type
expr_stmt|;
name|item
operator|->
name|wk_mp
operator|=
name|mp
expr_stmt|;
name|item
operator|->
name|wk_state
operator|=
literal|0
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|dep_current
index|[
name|type
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|dep_current
index|[
name|type
index|]
operator|>
name|dep_highuse
index|[
name|type
index|]
condition|)
name|dep_highuse
index|[
name|type
index|]
operator|=
name|dep_current
index|[
name|type
index|]
expr_stmt|;
name|dep_total
index|[
name|type
index|]
operator|++
expr_stmt|;
name|FREE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|ump
operator|->
name|softdep_curdeps
index|[
name|type
index|]
operator|+=
literal|1
expr_stmt|;
name|ump
operator|->
name|softdep_deps
operator|++
expr_stmt|;
name|ump
operator|->
name|softdep_accdeps
operator|++
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|workitem_reassign
parameter_list|(
name|item
parameter_list|,
name|newtype
parameter_list|)
name|struct
name|worklist
modifier|*
name|item
decl_stmt|;
name|int
name|newtype
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|item
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ump
operator|->
name|softdep_curdeps
index|[
name|item
operator|->
name|wk_type
index|]
operator|>
literal|0
argument_list|,
operator|(
literal|"workitem_reassign: %s: softdep_curdeps[%s] going negative"
operator|,
name|VFSTOUFS
argument_list|(
name|item
operator|->
name|wk_mp
argument_list|)
operator|->
name|um_fs
operator|->
name|fs_fsmnt
operator|,
name|TYPENAME
argument_list|(
name|item
operator|->
name|wk_type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ump
operator|->
name|softdep_curdeps
index|[
name|item
operator|->
name|wk_type
index|]
operator|-=
literal|1
expr_stmt|;
name|ump
operator|->
name|softdep_curdeps
index|[
name|newtype
index|]
operator|+=
literal|1
expr_stmt|;
name|KASSERT
argument_list|(
name|dep_current
index|[
name|item
operator|->
name|wk_type
index|]
operator|>
literal|0
argument_list|,
operator|(
literal|"workitem_reassign: %s: dep_current[%s] going negative"
operator|,
name|VFSTOUFS
argument_list|(
name|item
operator|->
name|wk_mp
argument_list|)
operator|->
name|um_fs
operator|->
name|fs_fsmnt
operator|,
name|TYPENAME
argument_list|(
name|item
operator|->
name|wk_type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ACQUIRE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|dep_current
index|[
name|newtype
index|]
operator|++
expr_stmt|;
name|dep_current
index|[
name|item
operator|->
name|wk_type
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|dep_current
index|[
name|newtype
index|]
operator|>
name|dep_highuse
index|[
name|newtype
index|]
condition|)
name|dep_highuse
index|[
name|newtype
index|]
operator|=
name|dep_current
index|[
name|newtype
index|]
expr_stmt|;
name|dep_total
index|[
name|newtype
index|]
operator|++
expr_stmt|;
name|FREE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|item
operator|->
name|wk_type
operator|=
name|newtype
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Workitem queue management  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_softdeps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum number of structs before slowdown */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tickdelay
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of ticks to pause during slowdown */
end_comment

begin_decl_stmt
specifier|static
name|int
name|proc_waiting
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tracks whether we have a timeout posted */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|stat_countp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* statistic to count in proc_waiting timeout */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|callout
name|softdep_callout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|req_clear_inodedeps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* syncer process flush some inodedeps */
end_comment

begin_decl_stmt
specifier|static
name|int
name|req_clear_remove
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* syncer process flush some freeblks */
end_comment

begin_decl_stmt
specifier|static
name|int
name|softdep_flushcache
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we do BIO_FLUSH? */
end_comment

begin_comment
comment|/*  * runtime statistics  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_flush_threads
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of softdep flushing threads */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_worklist_push
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of worklist cleanups */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_blk_limit_push
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of times block limit neared */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_ino_limit_push
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of times inode limit neared */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_blk_limit_hit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of times block slowdown imposed */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_ino_limit_hit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of times inode slowdown imposed */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_sync_limit_hit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of synchronous slowdowns imposed */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_indir_blk_ptrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bufs redirtied as indir ptrs not written */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_inode_bitmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bufs redirtied as inode bitmap not written */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_direct_blk_ptrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bufs redirtied as direct ptrs not written */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_dir_entry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bufs redirtied as dir entry cannot write */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_jaddref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bufs redirtied as ino bitmap can not write */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_jnewblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bufs redirtied as blk bitmap can not write */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_journal_min
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Times hit journal min threshold */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_journal_low
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Times hit journal low threshold */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_journal_wait
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Times blocked in jwait(). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_jwait_filepage
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Times blocked in jwait() for filepage. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_jwait_freeblks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Times blocked in jwait() for freeblks. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_jwait_inode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Times blocked in jwait() for inodes. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_jwait_newblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Times blocked in jwait() for newblks. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_cleanup_high_delay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum cleanup delay (in ticks) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_cleanup_blkrequests
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of block cleanup requests */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_cleanup_inorequests
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of inode cleanup requests */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_cleanup_retries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of cleanups that needed to flush */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_cleanup_failures
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of cleanup requests that failed */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stat_emptyjblocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of potentially empty journal blocks */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|max_softdeps
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_softdeps
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|tickdelay
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|tickdelay
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|flush_threads
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stat_flush_threads
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|worklist_push
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_worklist_push
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|blk_limit_push
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_blk_limit_push
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|ino_limit_push
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_ino_limit_push
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|blk_limit_hit
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_blk_limit_hit
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|ino_limit_hit
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_ino_limit_hit
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|sync_limit_hit
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_sync_limit_hit
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|indir_blk_ptrs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_indir_blk_ptrs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|inode_bitmap
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_inode_bitmap
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|direct_blk_ptrs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_direct_blk_ptrs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|dir_entry
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_dir_entry
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|jaddref_rollback
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_jaddref
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|jnewblk_rollback
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_jnewblk
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|journal_low
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_journal_low
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|journal_min
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_journal_min
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|journal_wait
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_journal_wait
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|jwait_filepage
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_jwait_filepage
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|jwait_freeblks
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_jwait_freeblks
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|jwait_inode
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_jwait_inode
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|jwait_newblk
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_jwait_newblk
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|cleanup_blkrequests
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_cleanup_blkrequests
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|cleanup_inorequests
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_cleanup_inorequests
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|cleanup_high_delay
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_cleanup_high_delay
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|cleanup_retries
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_cleanup_retries
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|cleanup_failures
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stat_cleanup_failures
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|flushcache
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|softdep_flushcache
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|emptyjblocks
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stat_emptyjblocks
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_ffs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Whether to recompute the summary at mount time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|compute_summary_at_mount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_ffs
argument_list|,
name|OID_AUTO
argument_list|,
name|compute_summary_at_mount
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|compute_summary_at_mount
argument_list|,
literal|0
argument_list|,
literal|"Recompute summary at mount"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|print_threads
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_softdep
argument_list|,
name|OID_AUTO
argument_list|,
name|print_threads
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|print_threads
argument_list|,
literal|0
argument_list|,
literal|"Notify flusher thread start/stop"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* List of all filesystems mounted with soft updates */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|mount_softdeps
argument_list|)
name|softdepmounts
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This function cleans the worklist for a filesystem.  * Each filesystem running with soft dependencies gets its own  * thread to run in this function. The thread is started up in  * softdep_mount and shutdown in softdep_unmount. They show up  * as part of the kernel "bufdaemon" process whose process  * entry is available in bufdaemonproc.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|searchfailed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|proc
modifier|*
name|bufdaemonproc
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|softdep_flush
parameter_list|(
name|addr
parameter_list|)
name|void
modifier|*
name|addr
decl_stmt|;
block|{
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|td
operator|->
name|td_pflags
operator||=
name|TDP_NORUNNINGBUF
expr_stmt|;
name|mp
operator|=
operator|(
expr|struct
name|mount
operator|*
operator|)
name|addr
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stat_flush_threads
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|ump
operator|->
name|softdep_flags
operator|&=
operator|~
name|FLUSH_STARTING
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|ump
operator|->
name|softdep_flushtd
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_threads
condition|)
block|{
if|if
condition|(
name|stat_flush_threads
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"Running %s at pid %d\n"
argument_list|,
name|bufdaemonproc
operator|->
name|p_comm
argument_list|,
name|bufdaemonproc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Start thread %s\n"
argument_list|,
name|td
operator|->
name|td_name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|softdep_process_worklist
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
operator|||
operator|(
name|MOUNTEDSUJ
argument_list|(
name|mp
argument_list|)
operator|&&
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|softdep_jblocks
operator|->
name|jb_suspended
operator|)
condition|)
name|kthread_suspend_check
argument_list|()
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ump
operator|->
name|softdep_flags
operator|&
operator|(
name|FLUSH_CLEANUP
operator||
name|FLUSH_EXIT
operator|)
operator|)
operator|==
literal|0
condition|)
name|msleep
argument_list|(
operator|&
name|ump
operator|->
name|softdep_flushtd
argument_list|,
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|,
name|PVM
argument_list|,
literal|"sdflush"
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
name|ump
operator|->
name|softdep_flags
operator|&=
operator|~
name|FLUSH_CLEANUP
expr_stmt|;
comment|/* 		 * Check to see if we are done and need to exit. 		 */
if|if
condition|(
operator|(
name|ump
operator|->
name|softdep_flags
operator|&
name|FLUSH_EXIT
operator|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ump
operator|->
name|softdep_flags
operator|&=
operator|~
name|FLUSH_EXIT
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|ump
operator|->
name|softdep_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_threads
condition|)
name|printf
argument_list|(
literal|"Stop thread %s: searchfailed %d, did cleanups %d\n"
argument_list|,
name|td
operator|->
name|td_name
argument_list|,
name|searchfailed
argument_list|,
name|ump
operator|->
name|um_softdep
operator|->
name|sd_cleanups
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stat_flush_threads
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|()
expr_stmt|;
name|panic
argument_list|(
literal|"kthread_exit failed\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|worklist_speedup
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ump
operator|->
name|softdep_flags
operator|&
operator|(
name|FLUSH_CLEANUP
operator||
name|FLUSH_EXIT
operator|)
operator|)
operator|==
literal|0
condition|)
name|ump
operator|->
name|softdep_flags
operator||=
name|FLUSH_CLEANUP
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|ump
operator|->
name|softdep_flushtd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|softdep_speedup
parameter_list|(
name|ump
parameter_list|)
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|altump
decl_stmt|;
name|struct
name|mount_softdeps
modifier|*
name|sdp
decl_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|worklist_speedup
argument_list|(
name|ump
operator|->
name|um_mountp
argument_list|)
expr_stmt|;
name|bd_speedup
argument_list|()
expr_stmt|;
comment|/* 	 * If we have global shortages, then we need other 	 * filesystems to help with the cleanup. Here we wakeup a 	 * flusher thread for a filesystem that is over its fair 	 * share of resources. 	 */
if|if
condition|(
name|req_clear_inodedeps
operator|||
name|req_clear_remove
condition|)
block|{
name|ACQUIRE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sdp
argument_list|,
argument|&softdepmounts
argument_list|,
argument|sd_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|altump
operator|=
name|sdp
operator|->
name|sd_ump
operator|)
operator|==
name|ump
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|req_clear_inodedeps
operator|&&
name|altump
operator|->
name|softdep_curdeps
index|[
name|D_INODEDEP
index|]
operator|>
name|max_softdeps
operator|/
name|stat_flush_threads
operator|)
operator|||
operator|(
name|req_clear_remove
operator|&&
name|altump
operator|->
name|softdep_curdeps
index|[
name|D_DIRREM
index|]
operator|>
operator|(
name|max_softdeps
operator|/
literal|2
operator|)
operator|/
name|stat_flush_threads
operator|)
operator|)
operator|&&
name|TRY_ACQUIRE_LOCK
argument_list|(
name|altump
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|sdp
operator|==
name|NULL
condition|)
block|{
name|searchfailed
operator|++
expr_stmt|;
name|FREE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Move to the end of the list so we pick a 			 * different one on out next try. 			 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softdepmounts
argument_list|,
name|sdp
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softdepmounts
argument_list|,
name|sdp
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
name|FREE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|altump
operator|->
name|softdep_flags
operator|&
operator|(
name|FLUSH_CLEANUP
operator||
name|FLUSH_EXIT
operator|)
operator|)
operator|==
literal|0
condition|)
name|altump
operator|->
name|softdep_flags
operator||=
name|FLUSH_CLEANUP
expr_stmt|;
name|altump
operator|->
name|um_softdep
operator|->
name|sd_cleanups
operator|++
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|altump
operator|->
name|softdep_flushtd
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|altump
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|speedup_syncer
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an item to the end of the work queue.  * This routine requires that the lock be held.  * This is the only routine that adds items to the list.  * The following routine is the only one that removes items  * and does so in order from first to last.  */
end_comment

begin_define
define|#
directive|define
name|WK_HEAD
value|0x0001
end_define

begin_comment
comment|/* Add to HEAD. */
end_comment

begin_define
define|#
directive|define
name|WK_NODELAY
value|0x0002
end_define

begin_comment
comment|/* Process immediately. */
end_comment

begin_function
specifier|static
name|void
name|add_to_worklist
parameter_list|(
name|wk
parameter_list|,
name|flags
parameter_list|)
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|wk
operator|->
name|wk_state
operator|&
name|ONWORKLIST
condition|)
name|panic
argument_list|(
literal|"add_to_worklist: %s(0x%X) already on list"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|,
name|wk
operator|->
name|wk_state
argument_list|)
expr_stmt|;
name|wk
operator|->
name|wk_state
operator||=
name|ONWORKLIST
expr_stmt|;
if|if
condition|(
name|ump
operator|->
name|softdep_on_worklist
operator|==
literal|0
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ump
operator|->
name|softdep_workitem_pending
argument_list|,
name|wk
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
name|ump
operator|->
name|softdep_worklist_tail
operator|=
name|wk
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|WK_HEAD
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ump
operator|->
name|softdep_workitem_pending
argument_list|,
name|wk
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|ump
operator|->
name|softdep_worklist_tail
argument_list|,
name|wk
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
name|ump
operator|->
name|softdep_worklist_tail
operator|=
name|wk
expr_stmt|;
block|}
name|ump
operator|->
name|softdep_on_worklist
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|WK_NODELAY
condition|)
name|worklist_speedup
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the item to be processed. If we are removing the last  * item on the list, we need to recalculate the tail pointer.  */
end_comment

begin_function
specifier|static
name|void
name|remove_from_worklist
parameter_list|(
name|wk
parameter_list|)
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ump
operator|->
name|softdep_worklist_tail
operator|==
name|wk
condition|)
name|ump
operator|->
name|softdep_worklist_tail
operator|=
operator|(
expr|struct
name|worklist
operator|*
operator|)
name|wk
operator|->
name|wk_list
operator|.
name|le_prev
expr_stmt|;
name|ump
operator|->
name|softdep_on_worklist
operator|-=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wake_worklist
parameter_list|(
name|wk
parameter_list|)
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
block|{
if|if
condition|(
name|wk
operator|->
name|wk_state
operator|&
name|IOWAITING
condition|)
block|{
name|wk
operator|->
name|wk_state
operator|&=
operator|~
name|IOWAITING
expr_stmt|;
name|wakeup
argument_list|(
name|wk
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wait_worklist
parameter_list|(
name|wk
parameter_list|,
name|wmesg
parameter_list|)
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|char
modifier|*
name|wmesg
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
name|wk
operator|->
name|wk_state
operator||=
name|IOWAITING
expr_stmt|;
name|msleep
argument_list|(
name|wk
argument_list|,
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|,
name|PVM
argument_list|,
name|wmesg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process that runs once per second to handle items in the background queue.  *  * Note that we ensure that everything is done in the order in which they  * appear in the queue. The code below depends on this property to ensure  * that blocks of a file are freed before the inode itself is freed. This  * ordering ensures that no new<vfsid, inum, lbn> triples will be generated  * until all the old ones have been purged from the dependency lists.  */
end_comment

begin_function
specifier|static
name|int
name|softdep_process_worklist
parameter_list|(
name|mp
parameter_list|,
name|full
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|full
decl_stmt|;
block|{
name|int
name|cnt
decl_stmt|,
name|matchcnt
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|long
name|starttime
decl_stmt|;
name|KASSERT
argument_list|(
name|mp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"softdep_process_worklist: NULL mp"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|matchcnt
operator|=
literal|0
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|starttime
operator|=
name|time_second
expr_stmt|;
name|softdep_process_journal
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|full
condition|?
name|MNT_WAIT
else|:
literal|0
argument_list|)
expr_stmt|;
name|check_clear_deps
argument_list|(
name|mp
argument_list|)
expr_stmt|;
while|while
condition|(
name|ump
operator|->
name|softdep_on_worklist
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cnt
operator|=
name|process_worklist_item
argument_list|(
name|mp
argument_list|,
literal|10
argument_list|,
name|LK_NOWAIT
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
else|else
name|matchcnt
operator|+=
name|cnt
expr_stmt|;
name|check_clear_deps
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 		 * We do not generally want to stop for buffer space, but if 		 * we are really being a buffer hog, we will stop and wait. 		 */
if|if
condition|(
name|should_yield
argument_list|()
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|kern_yield
argument_list|(
name|PRI_USER
argument_list|)
expr_stmt|;
name|bwillwrite
argument_list|()
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Never allow processing to run for more than one 		 * second. This gives the syncer thread the opportunity 		 * to pause if appropriate. 		 */
if|if
condition|(
operator|!
name|full
operator|&&
name|starttime
operator|!=
name|time_second
condition|)
break|break;
block|}
if|if
condition|(
name|full
operator|==
literal|0
condition|)
name|journal_unsuspend
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
name|matchcnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process all removes associated with a vnode if we are running out of  * journal space.  Any other process which attempts to flush these will  * be unable as we have the vnodes locked.  */
end_comment

begin_function
specifier|static
name|void
name|process_removes
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
name|mp
operator|=
name|vp
operator|->
name|v_mount
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|inum
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|->
name|i_number
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|top
label|:
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|inum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|LIST_FOREACH
argument_list|(
argument|dirrem
argument_list|,
argument|&inodedep->id_dirremhd
argument_list|,
argument|dm_inonext
argument_list|)
block|{
comment|/* 			 * If another thread is trying to lock this vnode 			 * it will fail but we must wait for it to do so 			 * before we can proceed. 			 */
if|if
condition|(
name|dirrem
operator|->
name|dm_state
operator|&
name|INPROGRESS
condition|)
block|{
name|wait_worklist
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|,
literal|"pwrwait"
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
operator|(
name|dirrem
operator|->
name|dm_state
operator|&
operator|(
name|COMPLETE
operator||
name|ONWORKLIST
operator|)
operator|)
operator|==
operator|(
name|COMPLETE
operator||
name|ONWORKLIST
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|dirrem
operator|==
name|NULL
condition|)
return|return;
name|remove_from_worklist
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_start_secondary_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|mp
argument_list|,
name|V_NOWAIT
argument_list|)
condition|)
name|panic
argument_list|(
literal|"process_removes: suspended filesystem"
argument_list|)
expr_stmt|;
name|handle_workitem_remove
argument_list|(
name|dirrem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_finished_secondary_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process all truncations associated with a vnode if we are running out  * of journal space.  This is called when the vnode lock is already held  * and no other process can clear the truncation.  This function returns  * a value greater than zero if it did any work.  */
end_comment

begin_function
specifier|static
name|void
name|process_truncates
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
name|int
name|cgwait
decl_stmt|;
name|mp
operator|=
name|vp
operator|->
name|v_mount
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|inum
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|->
name|i_number
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|inum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|cgwait
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|freeblks
argument_list|,
argument|&inodedep->id_freeblklst
argument_list|,
argument|fb_next
argument_list|)
block|{
comment|/* Journal entries not yet written.  */
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|)
condition|)
block|{
name|jwait
argument_list|(
operator|&
name|LIST_FIRST
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|)
operator|->
name|jb_list
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Another thread is executing this item. */
if|if
condition|(
name|freeblks
operator|->
name|fb_state
operator|&
name|INPROGRESS
condition|)
block|{
name|wait_worklist
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_list
argument_list|,
literal|"ptrwait"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Freeblks is waiting on a inode write. */
if|if
condition|(
operator|(
name|freeblks
operator|->
name|fb_state
operator|&
name|COMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|ffs_update
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|freeblks
operator|->
name|fb_state
operator|&
operator|(
name|ALLCOMPLETE
operator||
name|ONWORKLIST
operator|)
operator|)
operator|==
operator|(
name|ALLCOMPLETE
operator||
name|ONWORKLIST
operator|)
condition|)
block|{
name|remove_from_worklist
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_list
argument_list|)
expr_stmt|;
name|freeblks
operator|->
name|fb_state
operator||=
name|INPROGRESS
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_start_secondary_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|mp
argument_list|,
name|V_NOWAIT
argument_list|)
condition|)
name|panic
argument_list|(
literal|"process_truncates: "
literal|"suspended filesystem"
argument_list|)
expr_stmt|;
name|handle_workitem_freeblocks
argument_list|(
name|freeblks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_finished_secondary_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|freeblks
operator|->
name|fb_cgwait
condition|)
name|cgwait
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cgwait
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|sync_cgs
argument_list|(
name|mp
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
name|ffs_sync_snap
argument_list|(
name|mp
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|freeblks
operator|==
name|NULL
condition|)
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Process one item on the worklist.  */
end_comment

begin_function
specifier|static
name|int
name|process_worklist_item
parameter_list|(
name|mp
parameter_list|,
name|target
parameter_list|,
name|flags
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|worklist
name|sentinel
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|int
name|matchcnt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|mp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"process_worklist_item: NULL mp"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we are being called because of a process doing a 	 * copy-on-write, then it is not safe to write as we may 	 * recurse into the copy-on-write routine. 	 */
if|if
condition|(
name|curthread
operator|->
name|td_pflags
operator|&
name|TDP_COWINPROGRESS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|PHOLD
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
comment|/* Don't let the stack go away. */
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|matchcnt
operator|=
literal|0
expr_stmt|;
name|sentinel
operator|.
name|wk_mp
operator|=
name|NULL
expr_stmt|;
name|sentinel
operator|.
name|wk_type
operator|=
name|D_SENTINEL
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ump
operator|->
name|softdep_workitem_pending
argument_list|,
operator|&
name|sentinel
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
for|for
control|(
name|wk
operator|=
name|LIST_NEXT
argument_list|(
operator|&
name|sentinel
argument_list|,
name|wk_list
argument_list|)
init|;
name|wk
operator|!=
name|NULL
condition|;
name|wk
operator|=
name|LIST_NEXT
argument_list|(
operator|&
name|sentinel
argument_list|,
name|wk_list
argument_list|)
control|)
block|{
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|==
name|D_SENTINEL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
operator|&
name|sentinel
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_AFTER
argument_list|(
name|wk
argument_list|,
operator|&
name|sentinel
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|wk
operator|->
name|wk_state
operator|&
name|INPROGRESS
condition|)
name|panic
argument_list|(
literal|"process_worklist_item: %p already in progress."
argument_list|,
name|wk
argument_list|)
expr_stmt|;
name|wk
operator|->
name|wk_state
operator||=
name|INPROGRESS
expr_stmt|;
name|remove_from_worklist
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_start_secondary_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|mp
argument_list|,
name|V_NOWAIT
argument_list|)
condition|)
name|panic
argument_list|(
literal|"process_worklist_item: suspended filesystem"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_DIRREM
case|:
comment|/* removal of a directory entry */
name|error
operator|=
name|handle_workitem_remove
argument_list|(
name|WK_DIRREM
argument_list|(
name|wk
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_FREEBLKS
case|:
comment|/* releasing blocks and/or fragments from a file */
name|error
operator|=
name|handle_workitem_freeblocks
argument_list|(
name|WK_FREEBLKS
argument_list|(
name|wk
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_FREEFRAG
case|:
comment|/* releasing a fragment when replaced as a file grows */
name|handle_workitem_freefrag
argument_list|(
name|WK_FREEFRAG
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|D_FREEFILE
case|:
comment|/* releasing an inode when its link count drops to 0 */
name|handle_workitem_freefile
argument_list|(
name|WK_FREEFILE
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s_process_worklist: Unknown type %s"
argument_list|,
literal|"softdep"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|vn_finished_secondary_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|matchcnt
operator|==
name|target
condition|)
break|break;
continue|continue;
block|}
comment|/* 		 * We have to retry the worklist item later.  Wake up any 		 * waiters who may be able to complete it immediately and 		 * add the item back to the head so we don't try to execute 		 * it again. 		 */
name|wk
operator|->
name|wk_state
operator|&=
operator|~
name|INPROGRESS
expr_stmt|;
name|wake_worklist
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|add_to_worklist
argument_list|(
name|wk
argument_list|,
name|WK_HEAD
argument_list|)
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
operator|&
name|sentinel
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
comment|/* Sentinal could've become the tail from remove_from_worklist. */
if|if
condition|(
name|ump
operator|->
name|softdep_worklist_tail
operator|==
operator|&
name|sentinel
condition|)
name|ump
operator|->
name|softdep_worklist_tail
operator|=
operator|(
expr|struct
name|worklist
operator|*
operator|)
name|sentinel
operator|.
name|wk_list
operator|.
name|le_prev
expr_stmt|;
name|PRELE
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
return|return
operator|(
name|matchcnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move dependencies from one buffer to another.  */
end_comment

begin_function
name|int
name|softdep_move_dependencies
parameter_list|(
name|oldbp
parameter_list|,
name|newbp
parameter_list|)
name|struct
name|buf
modifier|*
name|oldbp
decl_stmt|;
name|struct
name|buf
modifier|*
name|newbp
decl_stmt|;
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|,
modifier|*
name|wktail
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|int
name|dirty
decl_stmt|;
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|oldbp
operator|->
name|b_dep
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_move_dependencies called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|dirty
operator|=
literal|0
expr_stmt|;
name|wktail
operator|=
name|NULL
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|oldbp
operator|->
name|b_dep
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|wk
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|==
name|D_BMSAFEMAP
operator|&&
name|bmsafemap_backgroundwrite
argument_list|(
name|WK_BMSAFEMAP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|newbp
argument_list|)
condition|)
name|dirty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wktail
operator|==
name|NULL
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|newbp
operator|->
name|b_dep
argument_list|,
name|wk
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_AFTER
argument_list|(
name|wktail
argument_list|,
name|wk
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
name|wktail
operator|=
name|wk
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
name|dirty
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Purge the work list of all items associated with a particular mount point.  */
end_comment

begin_function
name|int
name|softdep_flushworklist
parameter_list|(
name|oldmnt
parameter_list|,
name|countp
parameter_list|,
name|td
parameter_list|)
name|struct
name|mount
modifier|*
name|oldmnt
decl_stmt|;
name|int
modifier|*
name|countp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|int
name|count
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 * Alternately flush the block device associated with the mount 	 * point and process any dependencies that the flushing 	 * creates. We continue until no more worklist dependencies 	 * are found. 	 */
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|oldmnt
argument_list|)
expr_stmt|;
name|devvp
operator|=
name|ump
operator|->
name|um_devvp
expr_stmt|;
while|while
condition|(
operator|(
name|count
operator|=
name|softdep_process_worklist
argument_list|(
name|oldmnt
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
operator|*
name|countp
operator|+=
name|count
expr_stmt|;
name|vn_lock
argument_list|(
name|devvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|devvp
argument_list|,
name|MNT_WAIT
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SU_WAITIDLE_RETRIES
value|20
end_define

begin_function
specifier|static
name|int
name|softdep_waitidle
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|devvp
operator|=
name|ump
operator|->
name|um_devvp
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SU_WAITIDLE_RETRIES
operator|&&
name|ump
operator|->
name|softdep_deps
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|ump
operator|->
name|softdep_req
operator|=
literal|1
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
name|FORCECLOSE
operator|)
operator|==
literal|0
operator|||
name|ump
operator|->
name|softdep_on_worklist
operator|==
literal|0
argument_list|,
operator|(
literal|"softdep_waitidle: work added after flush"
operator|)
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|ump
operator|->
name|softdep_deps
argument_list|,
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|,
name|PVM
operator||
name|PDROP
argument_list|,
literal|"softdeps"
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|devvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|devvp
argument_list|,
name|MNT_WAIT
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
name|ump
operator|->
name|softdep_req
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|SU_WAITIDLE_RETRIES
operator|&&
name|error
operator|==
literal|0
operator|&&
name|ump
operator|->
name|softdep_deps
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|printf
argument_list|(
literal|"softdep_waitidle: Failed to flush worklist for %p\n"
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush all vnodes and worklist items associated with a specified mount point.  */
end_comment

begin_function
name|int
name|softdep_flushfiles
parameter_list|(
name|oldmnt
parameter_list|,
name|flags
parameter_list|,
name|td
parameter_list|)
name|struct
name|mount
modifier|*
name|oldmnt
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|QUOTA
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|,
name|early
decl_stmt|,
name|depcount
decl_stmt|,
name|loopcnt
decl_stmt|,
name|retry_flush_count
decl_stmt|,
name|retry
decl_stmt|;
name|int
name|morework
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|oldmnt
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_flushfiles called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|loopcnt
operator|=
literal|10
expr_stmt|;
name|retry_flush_count
operator|=
literal|3
expr_stmt|;
name|retry_flush
label|:
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Alternately flush the vnodes associated with the mount 	 * point and process any dependencies that the flushing 	 * creates. In theory, this loop can happen at most twice, 	 * but we give it a few extra just to be sure. 	 */
for|for
control|(
init|;
name|loopcnt
operator|>
literal|0
condition|;
name|loopcnt
operator|--
control|)
block|{
comment|/* 		 * Do another flush in case any vnodes were brought in 		 * as part of the cleanup operations. 		 */
name|early
operator|=
name|retry_flush_count
operator|==
literal|1
operator|||
operator|(
name|oldmnt
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNT
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
name|EARLYFLUSH
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ffs_flushfiles
argument_list|(
name|oldmnt
argument_list|,
name|flags
operator||
name|early
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|softdep_flushworklist
argument_list|(
name|oldmnt
argument_list|,
operator|&
name|depcount
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
operator|||
name|depcount
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* 	 * If we are unmounting then it is an error to fail. If we 	 * are simply trying to downgrade to read-only, then filesystem 	 * activity can keep us busy forever, so we just fail with EBUSY. 	 */
if|if
condition|(
name|loopcnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|oldmnt
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNT
condition|)
name|panic
argument_list|(
literal|"softdep_flushfiles: looping"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|softdep_waitidle
argument_list|(
name|oldmnt
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|oldmnt
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNT
condition|)
block|{
name|retry
operator|=
literal|0
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|oldmnt
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|oldmnt
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_NOINSMNTQ
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_flushfiles: !MNTK_NOINSMNTQ"
operator|)
argument_list|)
expr_stmt|;
name|morework
operator|=
name|oldmnt
operator|->
name|mnt_nvnodelistsize
operator|>
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|QUOTA
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|oldmnt
argument_list|)
expr_stmt|;
name|UFS_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXQUOTAS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ump
operator|->
name|um_quotas
index|[
name|i
index|]
operator|!=
name|NULLVP
condition|)
name|morework
operator|=
literal|1
expr_stmt|;
block|}
name|UFS_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|morework
condition|)
block|{
if|if
condition|(
operator|--
name|retry_flush_count
operator|>
literal|0
condition|)
block|{
name|retry
operator|=
literal|1
expr_stmt|;
name|loopcnt
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
name|MNT_IUNLOCK
argument_list|(
name|oldmnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
condition|)
goto|goto
name|retry_flush
goto|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Structure hashing.  *   * There are four types of structures that can be looked up:  *	1) pagedep structures identified by mount point, inode number,  *	   and logical block.  *	2) inodedep structures identified by mount point and inode number.  *	3) newblk structures identified by mount point and  *	   physical block number.  *	4) bmsafemap structures identified by mount point and  *	   cylinder group number.  *  * The "pagedep" and "inodedep" dependency structures are hashed  * separately from the file blocks and inodes to which they correspond.  * This separation helps when the in-memory copy of an inode or  * file block must be replaced. It also obviates the need to access  * an inode or file page when simply updating (or de-allocating)  * dependency structures. Lookup of newblk structures is needed to  * find newly allocated blocks when trying to associate them with  * their allocdirect or allocindir structure.  *  * The lookup routines optionally create and hash a new instance when  * an existing entry is not found. The bmsafemap lookup routine always  * allocates a new structure if an existing one is not found.  */
end_comment

begin_define
define|#
directive|define
name|DEPALLOC
value|0x0001
end_define

begin_comment
comment|/* allocate structure if lookup fails */
end_comment

begin_comment
comment|/*  * Structures and routines associated with pagedep caching.  */
end_comment

begin_define
define|#
directive|define
name|PAGEDEP_HASH
parameter_list|(
name|ump
parameter_list|,
name|inum
parameter_list|,
name|lbn
parameter_list|)
define|\
value|(&(ump)->pagedep_hashtbl[((inum) + (lbn))& (ump)->pagedep_hash_size])
end_define

begin_function
specifier|static
name|int
name|pagedep_find
parameter_list|(
name|pagedephd
parameter_list|,
name|ino
parameter_list|,
name|lbn
parameter_list|,
name|pagedeppp
parameter_list|)
name|struct
name|pagedep_hashhead
modifier|*
name|pagedephd
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|struct
name|pagedep
modifier|*
modifier|*
name|pagedeppp
decl_stmt|;
block|{
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pagedep
argument_list|,
argument|pagedephd
argument_list|,
argument|pd_hash
argument_list|)
block|{
if|if
condition|(
name|ino
operator|==
name|pagedep
operator|->
name|pd_ino
operator|&&
name|lbn
operator|==
name|pagedep
operator|->
name|pd_lbn
condition|)
block|{
operator|*
name|pagedeppp
operator|=
name|pagedep
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
operator|*
name|pagedeppp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a pagedep. Return 1 if found, 0 otherwise.  * If not found, allocate if DEPALLOC flag is passed.  * Found or allocated entry is returned in pagedeppp.  * This routine must be called with splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|int
name|pagedep_lookup
parameter_list|(
name|mp
parameter_list|,
name|bp
parameter_list|,
name|ino
parameter_list|,
name|lbn
parameter_list|,
name|flags
parameter_list|,
name|pagedeppp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|pagedep
modifier|*
modifier|*
name|pagedeppp
decl_stmt|;
block|{
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|pagedep_hashhead
modifier|*
name|pagedephd
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&bp->b_dep
argument_list|,
argument|wk_list
argument_list|)
block|{
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|==
name|D_PAGEDEP
condition|)
block|{
operator|*
name|pagedeppp
operator|=
name|WK_PAGEDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
name|pagedephd
operator|=
name|PAGEDEP_HASH
argument_list|(
name|ump
argument_list|,
name|ino
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pagedep_find
argument_list|(
name|pagedephd
argument_list|,
name|ino
argument_list|,
name|lbn
argument_list|,
name|pagedeppp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|pagedeppp
operator|)
operator|->
name|pd_state
operator|&
name|ONWORKLIST
operator|)
operator|==
literal|0
operator|&&
name|bp
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
operator|(
operator|*
name|pagedeppp
operator|)
operator|->
name|pd_list
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DEPALLOC
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|pagedep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pagedep
argument_list|)
argument_list|,
name|M_PAGEDEP
argument_list|,
name|M_SOFTDEP_FLAGS
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_list
argument_list|,
name|D_PAGEDEP
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pagedep_find
argument_list|(
name|pagedephd
argument_list|,
name|ino
argument_list|,
name|lbn
argument_list|,
name|pagedeppp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pagedeppp
condition|)
block|{
comment|/* 		 * This should never happen since we only create pagedeps 		 * with the vnode lock held.  Could be an assert. 		 */
name|WORKITEM_FREE
argument_list|(
name|pagedep
argument_list|,
name|D_PAGEDEP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|pagedep
operator|->
name|pd_ino
operator|=
name|ino
expr_stmt|;
name|pagedep
operator|->
name|pd_lbn
operator|=
name|lbn
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_dirremhd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DAHASHSZ
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|pagedephd
argument_list|,
name|pagedep
argument_list|,
name|pd_hash
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|pagedep
operator|->
name|pd_list
argument_list|)
expr_stmt|;
operator|*
name|pagedeppp
operator|=
name|pagedep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Structures and routines associated with inodedep caching.  */
end_comment

begin_define
define|#
directive|define
name|INODEDEP_HASH
parameter_list|(
name|ump
parameter_list|,
name|inum
parameter_list|)
define|\
value|(&(ump)->inodedep_hashtbl[(inum)& (ump)->inodedep_hash_size])
end_define

begin_function
specifier|static
name|int
name|inodedep_find
parameter_list|(
name|inodedephd
parameter_list|,
name|inum
parameter_list|,
name|inodedeppp
parameter_list|)
name|struct
name|inodedep_hashhead
modifier|*
name|inodedephd
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
name|struct
name|inodedep
modifier|*
modifier|*
name|inodedeppp
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|inodedep
argument_list|,
argument|inodedephd
argument_list|,
argument|id_hash
argument_list|)
if|if
condition|(
name|inum
operator|==
name|inodedep
operator|->
name|id_ino
condition|)
break|break;
if|if
condition|(
name|inodedep
condition|)
block|{
operator|*
name|inodedeppp
operator|=
name|inodedep
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|inodedeppp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up an inodedep. Return 1 if found, 0 if not found.  * If not found, allocate if DEPALLOC flag is passed.  * Found or allocated entry is returned in inodedeppp.  * This routine must be called with splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|int
name|inodedep_lookup
parameter_list|(
name|mp
parameter_list|,
name|inum
parameter_list|,
name|flags
parameter_list|,
name|inodedeppp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|inodedep
modifier|*
modifier|*
name|inodedeppp
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|inodedep_hashhead
modifier|*
name|inodedephd
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
name|inodedephd
operator|=
name|INODEDEP_HASH
argument_list|(
name|ump
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep_find
argument_list|(
name|inodedephd
argument_list|,
name|inum
argument_list|,
name|inodedeppp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DEPALLOC
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the system is over its limit and our filesystem is 	 * responsible for more than our share of that usage and 	 * we are not in a rush, request some inodedep cleanup. 	 */
if|if
condition|(
name|softdep_excess_items
argument_list|(
name|ump
argument_list|,
name|D_INODEDEP
argument_list|)
condition|)
name|schedule_cleanup
argument_list|(
name|mp
argument_list|)
expr_stmt|;
else|else
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|inodedep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|inodedep
argument_list|)
argument_list|,
name|M_INODEDEP
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|inodedep
operator|->
name|id_list
argument_list|,
name|D_INODEDEP
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep_find
argument_list|(
name|inodedephd
argument_list|,
name|inum
argument_list|,
name|inodedeppp
argument_list|)
condition|)
block|{
name|WORKITEM_FREE
argument_list|(
name|inodedep
argument_list|,
name|D_INODEDEP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|inodedep
operator|->
name|id_fs
operator|=
name|fs
expr_stmt|;
name|inodedep
operator|->
name|id_ino
operator|=
name|inum
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator|=
name|ALLCOMPLETE
expr_stmt|;
name|inodedep
operator|->
name|id_nlinkdelta
operator|=
literal|0
expr_stmt|;
name|inodedep
operator|->
name|id_savedino1
operator|=
name|NULL
expr_stmt|;
name|inodedep
operator|->
name|id_savedsize
operator|=
operator|-
literal|1
expr_stmt|;
name|inodedep
operator|->
name|id_savedextsize
operator|=
operator|-
literal|1
expr_stmt|;
name|inodedep
operator|->
name|id_savednlink
operator|=
operator|-
literal|1
expr_stmt|;
name|inodedep
operator|->
name|id_bmsafemap
operator|=
name|NULL
expr_stmt|;
name|inodedep
operator|->
name|id_mkdiradd
operator|=
name|NULL
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_dirremhd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_pendinghd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newextupdt
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_freeblklst
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|inodedephd
argument_list|,
name|inodedep
argument_list|,
name|id_hash
argument_list|)
expr_stmt|;
operator|*
name|inodedeppp
operator|=
name|inodedep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Structures and routines associated with newblk caching.  */
end_comment

begin_define
define|#
directive|define
name|NEWBLK_HASH
parameter_list|(
name|ump
parameter_list|,
name|inum
parameter_list|)
define|\
value|(&(ump)->newblk_hashtbl[(inum)& (ump)->newblk_hash_size])
end_define

begin_function
specifier|static
name|int
name|newblk_find
parameter_list|(
name|newblkhd
parameter_list|,
name|newblkno
parameter_list|,
name|flags
parameter_list|,
name|newblkpp
parameter_list|)
name|struct
name|newblk_hashhead
modifier|*
name|newblkhd
decl_stmt|;
name|ufs2_daddr_t
name|newblkno
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|newblk
modifier|*
modifier|*
name|newblkpp
decl_stmt|;
block|{
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|newblk
argument_list|,
argument|newblkhd
argument_list|,
argument|nb_hash
argument_list|)
block|{
if|if
condition|(
name|newblkno
operator|!=
name|newblk
operator|->
name|nb_newblkno
condition|)
continue|continue;
comment|/* 		 * If we're creating a new dependency don't match those that 		 * have already been converted to allocdirects.  This is for 		 * a frag extend. 		 */
if|if
condition|(
operator|(
name|flags
operator|&
name|DEPALLOC
operator|)
operator|&&
name|newblk
operator|->
name|nb_list
operator|.
name|wk_type
operator|!=
name|D_NEWBLK
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|newblk
condition|)
block|{
operator|*
name|newblkpp
operator|=
name|newblk
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|newblkpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a newblk. Return 1 if found, 0 if not found.  * If not found, allocate if DEPALLOC flag is passed.  * Found or allocated entry is returned in newblkpp.  */
end_comment

begin_function
specifier|static
name|int
name|newblk_lookup
parameter_list|(
name|mp
parameter_list|,
name|newblkno
parameter_list|,
name|flags
parameter_list|,
name|newblkpp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|ufs2_daddr_t
name|newblkno
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|newblk
modifier|*
modifier|*
name|newblkpp
decl_stmt|;
block|{
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|newblk_hashhead
modifier|*
name|newblkhd
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|newblkhd
operator|=
name|NEWBLK_HASH
argument_list|(
name|ump
argument_list|,
name|newblkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|newblk_find
argument_list|(
name|newblkhd
argument_list|,
name|newblkno
argument_list|,
name|flags
argument_list|,
name|newblkpp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DEPALLOC
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|softdep_excess_items
argument_list|(
name|ump
argument_list|,
name|D_NEWBLK
argument_list|)
operator|||
name|softdep_excess_items
argument_list|(
name|ump
argument_list|,
name|D_ALLOCDIRECT
argument_list|)
operator|||
name|softdep_excess_items
argument_list|(
name|ump
argument_list|,
name|D_ALLOCINDIR
argument_list|)
condition|)
name|schedule_cleanup
argument_list|(
name|mp
argument_list|)
expr_stmt|;
else|else
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|newblk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|union
name|allblk
argument_list|)
argument_list|,
name|M_NEWBLK
argument_list|,
name|M_SOFTDEP_FLAGS
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|newblk
operator|->
name|nb_list
argument_list|,
name|D_NEWBLK
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|newblk_find
argument_list|(
name|newblkhd
argument_list|,
name|newblkno
argument_list|,
name|flags
argument_list|,
name|newblkpp
argument_list|)
condition|)
block|{
name|WORKITEM_FREE
argument_list|(
name|newblk
argument_list|,
name|D_NEWBLK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|newblk
operator|->
name|nb_freefrag
operator|=
name|NULL
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|newblk
operator|->
name|nb_indirdeps
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|newblk
operator|->
name|nb_newdirblk
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|newblk
operator|->
name|nb_jwork
argument_list|)
expr_stmt|;
name|newblk
operator|->
name|nb_state
operator|=
name|ATTACHED
expr_stmt|;
name|newblk
operator|->
name|nb_newblkno
operator|=
name|newblkno
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|newblkhd
argument_list|,
name|newblk
argument_list|,
name|nb_hash
argument_list|)
expr_stmt|;
operator|*
name|newblkpp
operator|=
name|newblk
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Structures and routines associated with freed indirect block caching.  */
end_comment

begin_define
define|#
directive|define
name|INDIR_HASH
parameter_list|(
name|ump
parameter_list|,
name|blkno
parameter_list|)
define|\
value|(&(ump)->indir_hashtbl[(blkno)& (ump)->indir_hash_size])
end_define

begin_comment
comment|/*  * Lookup an indirect block in the indir hash table.  The freework is  * removed and potentially freed.  The caller must do a blocking journal  * write before writing to the blkno.  */
end_comment

begin_function
specifier|static
name|int
name|indirblk_lookup
parameter_list|(
name|mp
parameter_list|,
name|blkno
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
block|{
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
name|struct
name|indir_hashhead
modifier|*
name|wkhd
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|wkhd
operator|=
name|INDIR_HASH
argument_list|(
name|ump
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|freework
argument_list|,
argument|wkhd
argument_list|,
argument|fw_next
argument_list|)
block|{
if|if
condition|(
name|freework
operator|->
name|fw_blkno
operator|!=
name|blkno
condition|)
continue|continue;
name|indirblk_remove
argument_list|(
name|freework
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert an indirect block represented by freework into the indirblk  * hash table so that it may prevent the block from being re-used prior  * to the journal being written.  */
end_comment

begin_function
specifier|static
name|void
name|indirblk_insert
parameter_list|(
name|freework
parameter_list|)
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
block|{
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|freework
operator|->
name|fw_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|jblocks
operator|=
name|ump
operator|->
name|softdep_jblocks
expr_stmt|;
name|jseg
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|jblocks
operator|->
name|jb_segs
argument_list|,
name|jseglst
argument_list|)
expr_stmt|;
if|if
condition|(
name|jseg
operator|==
name|NULL
condition|)
return|return;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|jseg
operator|->
name|js_indirs
argument_list|,
name|freework
argument_list|,
name|fw_segs
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
name|INDIR_HASH
argument_list|(
name|ump
argument_list|,
name|freework
operator|->
name|fw_blkno
argument_list|)
argument_list|,
name|freework
argument_list|,
name|fw_next
argument_list|)
expr_stmt|;
name|freework
operator|->
name|fw_state
operator|&=
operator|~
name|DEPCOMPLETE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|indirblk_remove
parameter_list|(
name|freework
parameter_list|)
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|freework
operator|->
name|fw_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|freework
argument_list|,
name|fw_segs
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|INDIR_HASH
argument_list|(
name|ump
argument_list|,
name|freework
operator|->
name|fw_blkno
argument_list|)
argument_list|,
name|freework
argument_list|,
name|fw_next
argument_list|)
expr_stmt|;
name|freework
operator|->
name|fw_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
if|if
condition|(
operator|(
name|freework
operator|->
name|fw_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
name|WORKITEM_FREE
argument_list|(
name|freework
argument_list|,
name|D_FREEWORK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Executed during filesystem system initialization before  * mounting any filesystems.  */
end_comment

begin_function
name|void
name|softdep_initialize
parameter_list|()
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|softdepmounts
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__LP64__
name|max_softdeps
operator|=
name|desiredvnodes
operator|*
literal|4
expr_stmt|;
else|#
directive|else
name|max_softdeps
operator|=
name|desiredvnodes
operator|*
literal|2
expr_stmt|;
endif|#
directive|endif
comment|/* initialise bioops hack */
name|bioops
operator|.
name|io_start
operator|=
name|softdep_disk_io_initiation
expr_stmt|;
name|bioops
operator|.
name|io_complete
operator|=
name|softdep_disk_write_complete
expr_stmt|;
name|bioops
operator|.
name|io_deallocate
operator|=
name|softdep_deallocate_dependencies
expr_stmt|;
name|bioops
operator|.
name|io_countdeps
operator|=
name|softdep_count_dependencies
expr_stmt|;
name|softdep_ast_cleanup
operator|=
name|softdep_ast_cleanup_proc
expr_stmt|;
comment|/* Initialize the callout with an mtx. */
name|callout_init_mtx
argument_list|(
operator|&
name|softdep_callout
argument_list|,
operator|&
name|lk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Executed after all filesystems have been unmounted during  * filesystem module unload.  */
end_comment

begin_function
name|void
name|softdep_uninitialize
parameter_list|()
block|{
comment|/* clear bioops hack */
name|bioops
operator|.
name|io_start
operator|=
name|NULL
expr_stmt|;
name|bioops
operator|.
name|io_complete
operator|=
name|NULL
expr_stmt|;
name|bioops
operator|.
name|io_deallocate
operator|=
name|NULL
expr_stmt|;
name|bioops
operator|.
name|io_countdeps
operator|=
name|NULL
expr_stmt|;
name|softdep_ast_cleanup
operator|=
name|NULL
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|softdep_callout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called at mount time to notify the dependency code that a  * filesystem wishes to use it.  */
end_comment

begin_function
name|int
name|softdep_mount
parameter_list|(
name|devvp
parameter_list|,
name|mp
parameter_list|,
name|fs
parameter_list|,
name|cred
parameter_list|)
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|struct
name|csum_total
name|cstotal
decl_stmt|;
name|struct
name|mount_softdeps
modifier|*
name|sdp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|cyl
decl_stmt|;
name|sdp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mount_softdeps
argument_list|)
argument_list|,
name|M_MOUNTDATA
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|=
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
operator|~
name|MNT_ASYNC
operator|)
operator||
name|MNT_SOFTDEP
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_SOFTDEP
operator|)
operator|==
literal|0
condition|)
block|{
name|mp
operator|->
name|mnt_kern_flag
operator|=
operator|(
name|mp
operator|->
name|mnt_kern_flag
operator|&
operator|~
name|MNTK_ASYNC
operator|)
operator||
name|MNTK_SOFTDEP
operator||
name|MNTK_NOASYNC
expr_stmt|;
block|}
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ump
operator|->
name|um_softdep
operator|=
name|sdp
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|,
literal|"Per-Filesystem Softdep Lock"
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|sd_ump
operator|=
name|ump
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ump
operator|->
name|softdep_workitem_pending
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ump
operator|->
name|softdep_journal_pending
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ump
operator|->
name|softdep_unlinked
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ump
operator|->
name|softdep_dirtycg
argument_list|)
expr_stmt|;
name|ump
operator|->
name|softdep_worklist_tail
operator|=
name|NULL
expr_stmt|;
name|ump
operator|->
name|softdep_on_worklist
operator|=
literal|0
expr_stmt|;
name|ump
operator|->
name|softdep_deps
operator|=
literal|0
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ump
operator|->
name|softdep_mkdirlisthd
argument_list|)
expr_stmt|;
name|ump
operator|->
name|pagedep_hashtbl
operator|=
name|hashinit
argument_list|(
name|desiredvnodes
operator|/
literal|5
argument_list|,
name|M_PAGEDEP
argument_list|,
operator|&
name|ump
operator|->
name|pagedep_hash_size
argument_list|)
expr_stmt|;
name|ump
operator|->
name|pagedep_nextclean
operator|=
literal|0
expr_stmt|;
name|ump
operator|->
name|inodedep_hashtbl
operator|=
name|hashinit
argument_list|(
name|desiredvnodes
argument_list|,
name|M_INODEDEP
argument_list|,
operator|&
name|ump
operator|->
name|inodedep_hash_size
argument_list|)
expr_stmt|;
name|ump
operator|->
name|inodedep_nextclean
operator|=
literal|0
expr_stmt|;
name|ump
operator|->
name|newblk_hashtbl
operator|=
name|hashinit
argument_list|(
name|max_softdeps
operator|/
literal|2
argument_list|,
name|M_NEWBLK
argument_list|,
operator|&
name|ump
operator|->
name|newblk_hash_size
argument_list|)
expr_stmt|;
name|ump
operator|->
name|bmsafemap_hashtbl
operator|=
name|hashinit
argument_list|(
literal|1024
argument_list|,
name|M_BMSAFEMAP
argument_list|,
operator|&
name|ump
operator|->
name|bmsafemap_hash_size
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
operator|<<
operator|(
name|ffs
argument_list|(
name|desiredvnodes
operator|/
literal|10
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|ump
operator|->
name|indir_hashtbl
operator|=
name|malloc
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|indir_hashhead
argument_list|)
argument_list|,
name|M_FREEWORK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ump
operator|->
name|indir_hash_size
operator|=
name|i
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ump
operator|->
name|indir_hash_size
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|ump
operator|->
name|indir_hashtbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ACQUIRE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|softdepmounts
argument_list|,
name|sdp
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
name|FREE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FS_SUJ
operator|)
operator|&&
operator|(
name|error
operator|=
name|journal_mount
argument_list|(
name|mp
argument_list|,
name|fs
argument_list|,
name|cred
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to start journal: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|softdep_unmount
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Start our flushing thread in the bufdaemon process. 	 */
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|ump
operator|->
name|softdep_flags
operator||=
name|FLUSH_STARTING
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|kproc_kthread_add
argument_list|(
operator|&
name|softdep_flush
argument_list|,
name|mp
argument_list|,
operator|&
name|bufdaemonproc
argument_list|,
operator|&
name|ump
operator|->
name|softdep_flushtd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"softdepflush"
argument_list|,
literal|"%s worker"
argument_list|,
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ump
operator|->
name|softdep_flags
operator|&
name|FLUSH_STARTING
operator|)
operator|!=
literal|0
condition|)
block|{
name|msleep
argument_list|(
operator|&
name|ump
operator|->
name|softdep_flushtd
argument_list|,
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|,
name|PVM
argument_list|,
literal|"sdstart"
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * When doing soft updates, the counters in the 	 * superblock may have gotten out of sync. Recomputation 	 * can take a long time and can be deferred for background 	 * fsck.  However, the old behavior of scanning the cylinder 	 * groups and recalculating them at mount time is available 	 * by setting vfs.ffs.compute_summary_at_mount to one. 	 */
if|if
condition|(
name|compute_summary_at_mount
operator|==
literal|0
operator|||
name|fs
operator|->
name|fs_clean
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|cstotal
argument_list|,
sizeof|sizeof
name|cstotal
argument_list|)
expr_stmt|;
for|for
control|(
name|cyl
operator|=
literal|0
init|;
name|cyl
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|cyl
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bread
argument_list|(
name|devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cyl
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_cgsize
argument_list|,
name|cred
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|softdep_unmount
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cgp
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|cstotal
operator|.
name|cs_nffree
operator|+=
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nffree
expr_stmt|;
name|cstotal
operator|.
name|cs_nbfree
operator|+=
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nbfree
expr_stmt|;
name|cstotal
operator|.
name|cs_nifree
operator|+=
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nifree
expr_stmt|;
name|cstotal
operator|.
name|cs_ndir
operator|+=
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_ndir
expr_stmt|;
name|fs
operator|->
name|fs_cs
argument_list|(
name|fs
argument_list|,
name|cyl
argument_list|)
operator|=
name|cgp
operator|->
name|cg_cs
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|cstotal
argument_list|,
operator|&
name|fs
operator|->
name|fs_cstotal
argument_list|,
sizeof|sizeof
name|cstotal
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s: superblock summary recomputed\n"
argument_list|,
name|fs
operator|->
name|fs_fsmnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
operator|&
name|cstotal
argument_list|,
operator|&
name|fs
operator|->
name|fs_cstotal
argument_list|,
sizeof|sizeof
name|cstotal
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|softdep_unmount
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_unmount called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_SOFTDEP
expr_stmt|;
if|if
condition|(
name|MOUNTEDSUJ
argument_list|(
name|mp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_SUJ
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|journal_unmount
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Shut down our flushing thread. Check for NULL is if 	 * softdep_mount errors out before the thread has been created. 	 */
if|if
condition|(
name|ump
operator|->
name|softdep_flushtd
operator|!=
name|NULL
condition|)
block|{
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|ump
operator|->
name|softdep_flags
operator||=
name|FLUSH_EXIT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|ump
operator|->
name|softdep_flushtd
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|ump
operator|->
name|softdep_flags
argument_list|,
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|,
name|PVM
operator||
name|PDROP
argument_list|,
literal|"sdwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ump
operator|->
name|softdep_flags
operator|&
name|FLUSH_EXIT
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"Thread shutdown failed"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free up our resources. 	 */
name|ACQUIRE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|softdepmounts
argument_list|,
name|ump
operator|->
name|um_softdep
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
name|FREE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|)
expr_stmt|;
name|hashdestroy
argument_list|(
name|ump
operator|->
name|pagedep_hashtbl
argument_list|,
name|M_PAGEDEP
argument_list|,
name|ump
operator|->
name|pagedep_hash_size
argument_list|)
expr_stmt|;
name|hashdestroy
argument_list|(
name|ump
operator|->
name|inodedep_hashtbl
argument_list|,
name|M_INODEDEP
argument_list|,
name|ump
operator|->
name|inodedep_hash_size
argument_list|)
expr_stmt|;
name|hashdestroy
argument_list|(
name|ump
operator|->
name|newblk_hashtbl
argument_list|,
name|M_NEWBLK
argument_list|,
name|ump
operator|->
name|newblk_hash_size
argument_list|)
expr_stmt|;
name|hashdestroy
argument_list|(
name|ump
operator|->
name|bmsafemap_hashtbl
argument_list|,
name|M_BMSAFEMAP
argument_list|,
name|ump
operator|->
name|bmsafemap_hash_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ump
operator|->
name|indir_hashtbl
argument_list|,
name|M_FREEWORK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|D_LAST
condition|;
name|i
operator|++
control|)
name|KASSERT
argument_list|(
name|ump
operator|->
name|softdep_curdeps
index|[
name|i
index|]
operator|==
literal|0
argument_list|,
operator|(
literal|"Unmount %s: Dep type %s != 0 (%ld)"
operator|,
name|ump
operator|->
name|um_fs
operator|->
name|fs_fsmnt
operator|,
name|TYPENAME
argument_list|(
name|i
argument_list|)
operator|,
name|ump
operator|->
name|softdep_curdeps
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|ump
operator|->
name|um_softdep
argument_list|,
name|M_MOUNTDATA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|jblocks
modifier|*
name|jblocks_create
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
name|jblocks
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|jblocks
argument_list|)
argument_list|,
name|M_JBLOCKS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|jblocks
operator|->
name|jb_segs
argument_list|)
expr_stmt|;
name|jblocks
operator|->
name|jb_avail
operator|=
literal|10
expr_stmt|;
name|jblocks
operator|->
name|jb_extent
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|jextent
argument_list|)
operator|*
name|jblocks
operator|->
name|jb_avail
argument_list|,
name|M_JBLOCKS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
return|return
operator|(
name|jblocks
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ufs2_daddr_t
name|jblocks_alloc
parameter_list|(
name|jblocks
parameter_list|,
name|bytes
parameter_list|,
name|actual
parameter_list|)
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|int
modifier|*
name|actual
decl_stmt|;
block|{
name|ufs2_daddr_t
name|daddr
decl_stmt|;
name|struct
name|jextent
modifier|*
name|jext
decl_stmt|;
name|int
name|freecnt
decl_stmt|;
name|int
name|blocks
decl_stmt|;
name|blocks
operator|=
name|bytes
operator|/
name|DEV_BSIZE
expr_stmt|;
name|jext
operator|=
operator|&
name|jblocks
operator|->
name|jb_extent
index|[
name|jblocks
operator|->
name|jb_head
index|]
expr_stmt|;
name|freecnt
operator|=
name|jext
operator|->
name|je_blocks
operator|-
name|jblocks
operator|->
name|jb_off
expr_stmt|;
if|if
condition|(
name|freecnt
operator|==
literal|0
condition|)
block|{
name|jblocks
operator|->
name|jb_off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|jblocks
operator|->
name|jb_head
operator|>
name|jblocks
operator|->
name|jb_used
condition|)
name|jblocks
operator|->
name|jb_head
operator|=
literal|0
expr_stmt|;
name|jext
operator|=
operator|&
name|jblocks
operator|->
name|jb_extent
index|[
name|jblocks
operator|->
name|jb_head
index|]
expr_stmt|;
name|freecnt
operator|=
name|jext
operator|->
name|je_blocks
expr_stmt|;
block|}
if|if
condition|(
name|freecnt
operator|>
name|blocks
condition|)
name|freecnt
operator|=
name|blocks
expr_stmt|;
operator|*
name|actual
operator|=
name|freecnt
operator|*
name|DEV_BSIZE
expr_stmt|;
name|daddr
operator|=
name|jext
operator|->
name|je_daddr
operator|+
name|jblocks
operator|->
name|jb_off
expr_stmt|;
name|jblocks
operator|->
name|jb_off
operator|+=
name|freecnt
expr_stmt|;
name|jblocks
operator|->
name|jb_free
operator|-=
name|freecnt
expr_stmt|;
return|return
operator|(
name|daddr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|jblocks_free
parameter_list|(
name|jblocks
parameter_list|,
name|mp
parameter_list|,
name|bytes
parameter_list|)
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|{
name|LOCK_OWNED
argument_list|(
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|jblocks
operator|->
name|jb_free
operator|+=
name|bytes
operator|/
name|DEV_BSIZE
expr_stmt|;
if|if
condition|(
name|jblocks
operator|->
name|jb_suspended
condition|)
name|worklist_speedup
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|jblocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jblocks_destroy
parameter_list|(
name|jblocks
parameter_list|)
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
block|{
if|if
condition|(
name|jblocks
operator|->
name|jb_extent
condition|)
name|free
argument_list|(
name|jblocks
operator|->
name|jb_extent
argument_list|,
name|M_JBLOCKS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|jblocks
argument_list|,
name|M_JBLOCKS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jblocks_add
parameter_list|(
name|jblocks
parameter_list|,
name|daddr
parameter_list|,
name|blocks
parameter_list|)
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
name|ufs2_daddr_t
name|daddr
decl_stmt|;
name|int
name|blocks
decl_stmt|;
block|{
name|struct
name|jextent
modifier|*
name|jext
decl_stmt|;
name|jblocks
operator|->
name|jb_blocks
operator|+=
name|blocks
expr_stmt|;
name|jblocks
operator|->
name|jb_free
operator|+=
name|blocks
expr_stmt|;
name|jext
operator|=
operator|&
name|jblocks
operator|->
name|jb_extent
index|[
name|jblocks
operator|->
name|jb_used
index|]
expr_stmt|;
comment|/* Adding the first block. */
if|if
condition|(
name|jext
operator|->
name|je_daddr
operator|==
literal|0
condition|)
block|{
name|jext
operator|->
name|je_daddr
operator|=
name|daddr
expr_stmt|;
name|jext
operator|->
name|je_blocks
operator|=
name|blocks
expr_stmt|;
return|return;
block|}
comment|/* Extending the last extent. */
if|if
condition|(
name|jext
operator|->
name|je_daddr
operator|+
name|jext
operator|->
name|je_blocks
operator|==
name|daddr
condition|)
block|{
name|jext
operator|->
name|je_blocks
operator|+=
name|blocks
expr_stmt|;
return|return;
block|}
comment|/* Adding a new extent. */
if|if
condition|(
operator|++
name|jblocks
operator|->
name|jb_used
operator|==
name|jblocks
operator|->
name|jb_avail
condition|)
block|{
name|jblocks
operator|->
name|jb_avail
operator|*=
literal|2
expr_stmt|;
name|jext
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|jextent
argument_list|)
operator|*
name|jblocks
operator|->
name|jb_avail
argument_list|,
name|M_JBLOCKS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|jext
argument_list|,
name|jblocks
operator|->
name|jb_extent
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|jextent
argument_list|)
operator|*
name|jblocks
operator|->
name|jb_used
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|jblocks
operator|->
name|jb_extent
argument_list|,
name|M_JBLOCKS
argument_list|)
expr_stmt|;
name|jblocks
operator|->
name|jb_extent
operator|=
name|jext
expr_stmt|;
block|}
name|jext
operator|=
operator|&
name|jblocks
operator|->
name|jb_extent
index|[
name|jblocks
operator|->
name|jb_used
index|]
expr_stmt|;
name|jext
operator|->
name|je_daddr
operator|=
name|daddr
expr_stmt|;
name|jext
operator|->
name|je_blocks
operator|=
name|blocks
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|softdep_journal_lookup
parameter_list|(
name|mp
parameter_list|,
name|vpp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
block|{
name|struct
name|componentname
name|cnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|ino_t
name|sujournal
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|UFS_ROOTINO
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|cnp
argument_list|,
sizeof|sizeof
argument_list|(
name|cnp
argument_list|)
argument_list|)
expr_stmt|;
name|cnp
operator|.
name|cn_nameiop
operator|=
name|LOOKUP
expr_stmt|;
name|cnp
operator|.
name|cn_flags
operator|=
name|ISLASTCN
expr_stmt|;
name|cnp
operator|.
name|cn_thread
operator|=
name|curthread
expr_stmt|;
name|cnp
operator|.
name|cn_cred
operator|=
name|curthread
operator|->
name|td_ucred
expr_stmt|;
name|cnp
operator|.
name|cn_pnbuf
operator|=
name|SUJ_FILE
expr_stmt|;
name|cnp
operator|.
name|cn_nameptr
operator|=
name|SUJ_FILE
expr_stmt|;
name|cnp
operator|.
name|cn_namelen
operator|=
name|strlen
argument_list|(
name|SUJ_FILE
argument_list|)
expr_stmt|;
name|error
operator|=
name|ufs_lookup_ino
argument_list|(
name|dvp
argument_list|,
name|NULL
argument_list|,
operator|&
name|cnp
argument_list|,
operator|&
name|sujournal
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|sujournal
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open and verify the journal file.  */
end_comment

begin_function
specifier|static
name|int
name|journal_mount
parameter_list|(
name|mp
parameter_list|,
name|fs
parameter_list|,
name|cred
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
name|int
name|bcount
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ump
operator|->
name|softdep_journal_tail
operator|=
name|NULL
expr_stmt|;
name|ump
operator|->
name|softdep_on_journal
operator|=
literal|0
expr_stmt|;
name|ump
operator|->
name|softdep_accdeps
operator|=
literal|0
expr_stmt|;
name|ump
operator|->
name|softdep_req
operator|=
literal|0
expr_stmt|;
name|ump
operator|->
name|softdep_jblocks
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|softdep_journal_lookup
argument_list|(
name|mp
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to find journal.  Use tunefs to create one\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_size
operator|<
name|SUJ_MIN
condition|)
block|{
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bcount
operator|=
name|lblkno
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_size
argument_list|)
expr_stmt|;
comment|/* Only use whole blocks. */
name|jblocks
operator|=
name|jblocks_create
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bcount
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|ufs_bmaparray
argument_list|(
name|vp
argument_list|,
name|i
argument_list|,
operator|&
name|blkno
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|jblocks_add
argument_list|(
name|jblocks
argument_list|,
name|blkno
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|jblocks_destroy
argument_list|(
name|jblocks
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|jblocks
operator|->
name|jb_low
operator|=
name|jblocks
operator|->
name|jb_free
operator|/
literal|3
expr_stmt|;
comment|/* Reserve 33%. */
name|jblocks
operator|->
name|jb_min
operator|=
name|jblocks
operator|->
name|jb_free
operator|/
literal|10
expr_stmt|;
comment|/* Suspend at 10%. */
name|ump
operator|->
name|softdep_jblocks
operator|=
name|jblocks
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_SUJ
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_SOFTDEP
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 		 * Only validate the journal contents if the 		 * filesystem is clean, otherwise we write the logs 		 * but they'll never be used.  If the filesystem was 		 * still dirty when we mounted it the journal is 		 * invalid and a new journal can only be valid if it 		 * starts from a clean mount. 		 */
if|if
condition|(
name|fs
operator|->
name|fs_clean
condition|)
block|{
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_modrev
argument_list|,
name|fs
operator|->
name|fs_mtime
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flags
operator||=
name|IN_MODIFIED
expr_stmt|;
name|ffs_update
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|journal_unmount
parameter_list|(
name|ump
parameter_list|)
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
block|{
if|if
condition|(
name|ump
operator|->
name|softdep_jblocks
condition|)
name|jblocks_destroy
argument_list|(
name|ump
operator|->
name|softdep_jblocks
argument_list|)
expr_stmt|;
name|ump
operator|->
name|softdep_jblocks
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when a journal record is ready to be written.  Space is allocated  * and the journal entry is created when the journal is flushed to stable  * store.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_journal
parameter_list|(
name|wk
parameter_list|)
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|wk
operator|->
name|wk_state
operator|&
name|ONWORKLIST
condition|)
name|panic
argument_list|(
literal|"add_to_journal: %s(0x%X) already on list"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|,
name|wk
operator|->
name|wk_state
argument_list|)
expr_stmt|;
name|wk
operator|->
name|wk_state
operator||=
name|ONWORKLIST
operator||
name|DEPCOMPLETE
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|ump
operator|->
name|softdep_journal_pending
argument_list|)
condition|)
block|{
name|ump
operator|->
name|softdep_jblocks
operator|->
name|jb_age
operator|=
name|ticks
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ump
operator|->
name|softdep_journal_pending
argument_list|,
name|wk
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
block|}
else|else
name|LIST_INSERT_AFTER
argument_list|(
name|ump
operator|->
name|softdep_journal_tail
argument_list|,
name|wk
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
name|ump
operator|->
name|softdep_journal_tail
operator|=
name|wk
expr_stmt|;
name|ump
operator|->
name|softdep_on_journal
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove an arbitrary item for the journal worklist maintain the tail  * pointer.  This happens when a new operation obviates the need to  * journal an old operation.  */
end_comment

begin_function
specifier|static
name|void
name|remove_from_journal
parameter_list|(
name|wk
parameter_list|)
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUJ_DEBUG
block|{
name|struct
name|worklist
modifier|*
name|wkn
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|wkn
argument_list|,
argument|&ump->softdep_journal_pending
argument_list|,
argument|wk_list
argument_list|)
if|if
condition|(
name|wkn
operator|==
name|wk
condition|)
break|break;
if|if
condition|(
name|wkn
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"remove_from_journal: %p is not in journal"
argument_list|,
name|wk
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * We emulate a TAILQ to save space in most structures which do not 	 * require TAILQ semantics.  Here we must update the tail position 	 * when removing the tail which is not the final entry. This works 	 * only if the worklist linkage are at the beginning of the structure. 	 */
if|if
condition|(
name|ump
operator|->
name|softdep_journal_tail
operator|==
name|wk
condition|)
name|ump
operator|->
name|softdep_journal_tail
operator|=
operator|(
expr|struct
name|worklist
operator|*
operator|)
name|wk
operator|->
name|wk_list
operator|.
name|le_prev
expr_stmt|;
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|ump
operator|->
name|softdep_on_journal
operator|-=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check for journal space as well as dependency limits so the prelink  * code can throttle both journaled and non-journaled filesystems.  * Threshold is 0 for low and 1 for min.  */
end_comment

begin_function
specifier|static
name|int
name|journal_space
parameter_list|(
name|ump
parameter_list|,
name|thresh
parameter_list|)
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|int
name|thresh
decl_stmt|;
block|{
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
name|int
name|limit
decl_stmt|,
name|avail
decl_stmt|;
name|jblocks
operator|=
name|ump
operator|->
name|softdep_jblocks
expr_stmt|;
if|if
condition|(
name|jblocks
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * We use a tighter restriction here to prevent request_cleanup() 	 * running in threads from running into locks we currently hold. 	 * We have to be over the limit and our filesystem has to be 	 * responsible for more than our share of that usage. 	 */
name|limit
operator|=
operator|(
name|max_softdeps
operator|/
literal|10
operator|)
operator|*
literal|9
expr_stmt|;
if|if
condition|(
name|dep_current
index|[
name|D_INODEDEP
index|]
operator|>
name|limit
operator|&&
name|ump
operator|->
name|softdep_curdeps
index|[
name|D_INODEDEP
index|]
operator|>
name|limit
operator|/
name|stat_flush_threads
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|thresh
condition|)
name|thresh
operator|=
name|jblocks
operator|->
name|jb_min
expr_stmt|;
else|else
name|thresh
operator|=
name|jblocks
operator|->
name|jb_low
expr_stmt|;
name|avail
operator|=
operator|(
name|ump
operator|->
name|softdep_on_journal
operator|*
name|JREC_SIZE
operator|)
operator|/
name|DEV_BSIZE
expr_stmt|;
name|avail
operator|=
name|jblocks
operator|->
name|jb_free
operator|-
name|avail
expr_stmt|;
return|return
operator|(
name|avail
operator|>
name|thresh
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|journal_suspend
parameter_list|(
name|ump
parameter_list|)
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
block|{
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|jblocks
operator|=
name|ump
operator|->
name|softdep_jblocks
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_SUSPEND
operator|)
operator|==
literal|0
condition|)
block|{
name|stat_journal_min
operator|++
expr_stmt|;
name|mp
operator|->
name|mnt_kern_flag
operator||=
name|MNTK_SUSPEND
expr_stmt|;
name|mp
operator|->
name|mnt_susp_owner
operator|=
name|ump
operator|->
name|softdep_flushtd
expr_stmt|;
block|}
name|jblocks
operator|->
name|jb_suspended
operator|=
literal|1
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|journal_unsuspend
parameter_list|(
name|struct
name|ufsmount
modifier|*
name|ump
parameter_list|)
block|{
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|jblocks
operator|=
name|ump
operator|->
name|softdep_jblocks
expr_stmt|;
if|if
condition|(
name|jblocks
operator|!=
name|NULL
operator|&&
name|jblocks
operator|->
name|jb_suspended
operator|&&
name|journal_space
argument_list|(
name|ump
argument_list|,
name|jblocks
operator|->
name|jb_min
argument_list|)
condition|)
block|{
name|jblocks
operator|->
name|jb_suspended
operator|=
literal|0
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_susp_owner
operator|=
name|curthread
expr_stmt|;
name|vfs_write_resume
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called before any allocation function to be certain that there is  * sufficient space in the journal prior to creating any new records.  * Since in the case of block allocation we may have multiple locked  * buffers at the time of the actual allocation we can not block  * when the journal records are created.  Doing so would create a deadlock  * if any of these buffers needed to be flushed to reclaim space.  Instead  * we require a sufficiently large amount of available space such that  * each thread in the system could have passed this allocation check and  * still have sufficient free space.  With 20% of a minimum journal size  * of 1MB we have 6553 records available.  */
end_comment

begin_function
name|int
name|softdep_prealloc
parameter_list|(
name|vp
parameter_list|,
name|waitok
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|waitok
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_prealloc called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Nothing to do if we are not running journaled soft updates. 	 * If we currently hold the snapshot lock, we must avoid 	 * handling other resources that could cause deadlock.  Do not 	 * touch quotas vnode since it is typically recursed with 	 * other vnode locks held. 	 */
if|if
condition|(
name|DOINGSUJ
argument_list|(
name|vp
argument_list|)
operator|==
literal|0
operator|||
name|IS_SNAPSHOT
argument_list|(
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|)
operator|||
operator|(
name|vp
operator|->
name|v_vflag
operator|&
name|VV_SYSTEM
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|journal_space
argument_list|(
name|ump
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|stat_journal_low
operator|++
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitok
operator|==
name|MNT_NOWAIT
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 	 * Attempt to sync this vnode once to flush any journal 	 * work attached to it. 	 */
if|if
condition|(
operator|(
name|curthread
operator|->
name|td_pflags
operator|&
name|TDP_COWINPROGRESS
operator|)
operator|==
literal|0
condition|)
name|ffs_syncvnode
argument_list|(
name|vp
argument_list|,
name|waitok
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|process_removes
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|process_truncates
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|journal_space
argument_list|(
name|ump
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|softdep_speedup
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|journal_space
argument_list|(
name|ump
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|journal_suspend
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Before adjusting a link count on a vnode verify that we have sufficient  * journal space.  If not, process operations that depend on the currently  * locked pair of vnodes to try to flush space as the syncer, buf daemon,  * and softdep flush threads can not acquire these locks to reclaim space.  */
end_comment

begin_function
specifier|static
name|void
name|softdep_prelink
parameter_list|(
name|dvp
parameter_list|,
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * Nothing to do if we have sufficient journal space. 	 * If we currently hold the snapshot lock, we must avoid 	 * handling other resources that could cause deadlock. 	 */
if|if
condition|(
name|journal_space
argument_list|(
name|ump
argument_list|,
literal|0
argument_list|)
operator|||
operator|(
name|vp
operator|&&
name|IS_SNAPSHOT
argument_list|(
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|)
operator|)
condition|)
return|return;
name|stat_journal_low
operator|++
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
condition|)
name|ffs_syncvnode
argument_list|(
name|vp
argument_list|,
name|MNT_NOWAIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ffs_syncvnode
argument_list|(
name|dvp
argument_list|,
name|MNT_WAIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* Process vp before dvp as it may create .. removes. */
if|if
condition|(
name|vp
condition|)
block|{
name|process_removes
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|process_truncates
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|process_removes
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|process_truncates
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|softdep_speedup
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|process_worklist_item
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|,
literal|2
argument_list|,
name|LK_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|journal_space
argument_list|(
name|ump
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|softdep_speedup
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|journal_space
argument_list|(
name|ump
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|journal_suspend
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|jseg_write
parameter_list|(
name|ump
parameter_list|,
name|jseg
parameter_list|,
name|data
parameter_list|)
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|jsegrec
modifier|*
name|rec
decl_stmt|;
name|rec
operator|=
operator|(
expr|struct
name|jsegrec
operator|*
operator|)
name|data
expr_stmt|;
name|rec
operator|->
name|jsr_seq
operator|=
name|jseg
operator|->
name|js_seq
expr_stmt|;
name|rec
operator|->
name|jsr_oldest
operator|=
name|jseg
operator|->
name|js_oldseq
expr_stmt|;
name|rec
operator|->
name|jsr_cnt
operator|=
name|jseg
operator|->
name|js_cnt
expr_stmt|;
name|rec
operator|->
name|jsr_blocks
operator|=
name|jseg
operator|->
name|js_size
operator|/
name|ump
operator|->
name|um_devvp
operator|->
name|v_bufobj
operator|.
name|bo_bsize
expr_stmt|;
name|rec
operator|->
name|jsr_crc
operator|=
literal|0
expr_stmt|;
name|rec
operator|->
name|jsr_time
operator|=
name|ump
operator|->
name|um_fs
operator|->
name|fs_mtime
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|inoref_write
parameter_list|(
name|inoref
parameter_list|,
name|jseg
parameter_list|,
name|rec
parameter_list|)
name|struct
name|inoref
modifier|*
name|inoref
decl_stmt|;
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
name|struct
name|jrefrec
modifier|*
name|rec
decl_stmt|;
block|{
name|inoref
operator|->
name|if_jsegdep
operator|->
name|jd_seg
operator|=
name|jseg
expr_stmt|;
name|rec
operator|->
name|jr_ino
operator|=
name|inoref
operator|->
name|if_ino
expr_stmt|;
name|rec
operator|->
name|jr_parent
operator|=
name|inoref
operator|->
name|if_parent
expr_stmt|;
name|rec
operator|->
name|jr_nlink
operator|=
name|inoref
operator|->
name|if_nlink
expr_stmt|;
name|rec
operator|->
name|jr_mode
operator|=
name|inoref
operator|->
name|if_mode
expr_stmt|;
name|rec
operator|->
name|jr_diroff
operator|=
name|inoref
operator|->
name|if_diroff
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jaddref_write
parameter_list|(
name|jaddref
parameter_list|,
name|jseg
parameter_list|,
name|data
parameter_list|)
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|jrefrec
modifier|*
name|rec
decl_stmt|;
name|rec
operator|=
operator|(
expr|struct
name|jrefrec
operator|*
operator|)
name|data
expr_stmt|;
name|rec
operator|->
name|jr_op
operator|=
name|JOP_ADDREF
expr_stmt|;
name|inoref_write
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_ref
argument_list|,
name|jseg
argument_list|,
name|rec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jremref_write
parameter_list|(
name|jremref
parameter_list|,
name|jseg
parameter_list|,
name|data
parameter_list|)
name|struct
name|jremref
modifier|*
name|jremref
decl_stmt|;
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|jrefrec
modifier|*
name|rec
decl_stmt|;
name|rec
operator|=
operator|(
expr|struct
name|jrefrec
operator|*
operator|)
name|data
expr_stmt|;
name|rec
operator|->
name|jr_op
operator|=
name|JOP_REMREF
expr_stmt|;
name|inoref_write
argument_list|(
operator|&
name|jremref
operator|->
name|jr_ref
argument_list|,
name|jseg
argument_list|,
name|rec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jmvref_write
parameter_list|(
name|jmvref
parameter_list|,
name|jseg
parameter_list|,
name|data
parameter_list|)
name|struct
name|jmvref
modifier|*
name|jmvref
decl_stmt|;
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|jmvrec
modifier|*
name|rec
decl_stmt|;
name|rec
operator|=
operator|(
expr|struct
name|jmvrec
operator|*
operator|)
name|data
expr_stmt|;
name|rec
operator|->
name|jm_op
operator|=
name|JOP_MVREF
expr_stmt|;
name|rec
operator|->
name|jm_ino
operator|=
name|jmvref
operator|->
name|jm_ino
expr_stmt|;
name|rec
operator|->
name|jm_parent
operator|=
name|jmvref
operator|->
name|jm_parent
expr_stmt|;
name|rec
operator|->
name|jm_oldoff
operator|=
name|jmvref
operator|->
name|jm_oldoff
expr_stmt|;
name|rec
operator|->
name|jm_newoff
operator|=
name|jmvref
operator|->
name|jm_newoff
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jnewblk_write
parameter_list|(
name|jnewblk
parameter_list|,
name|jseg
parameter_list|,
name|data
parameter_list|)
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|;
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|jblkrec
modifier|*
name|rec
decl_stmt|;
name|jnewblk
operator|->
name|jn_jsegdep
operator|->
name|jd_seg
operator|=
name|jseg
expr_stmt|;
name|rec
operator|=
operator|(
expr|struct
name|jblkrec
operator|*
operator|)
name|data
expr_stmt|;
name|rec
operator|->
name|jb_op
operator|=
name|JOP_NEWBLK
expr_stmt|;
name|rec
operator|->
name|jb_ino
operator|=
name|jnewblk
operator|->
name|jn_ino
expr_stmt|;
name|rec
operator|->
name|jb_blkno
operator|=
name|jnewblk
operator|->
name|jn_blkno
expr_stmt|;
name|rec
operator|->
name|jb_lbn
operator|=
name|jnewblk
operator|->
name|jn_lbn
expr_stmt|;
name|rec
operator|->
name|jb_frags
operator|=
name|jnewblk
operator|->
name|jn_frags
expr_stmt|;
name|rec
operator|->
name|jb_oldfrags
operator|=
name|jnewblk
operator|->
name|jn_oldfrags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jfreeblk_write
parameter_list|(
name|jfreeblk
parameter_list|,
name|jseg
parameter_list|,
name|data
parameter_list|)
name|struct
name|jfreeblk
modifier|*
name|jfreeblk
decl_stmt|;
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|jblkrec
modifier|*
name|rec
decl_stmt|;
name|jfreeblk
operator|->
name|jf_dep
operator|.
name|jb_jsegdep
operator|->
name|jd_seg
operator|=
name|jseg
expr_stmt|;
name|rec
operator|=
operator|(
expr|struct
name|jblkrec
operator|*
operator|)
name|data
expr_stmt|;
name|rec
operator|->
name|jb_op
operator|=
name|JOP_FREEBLK
expr_stmt|;
name|rec
operator|->
name|jb_ino
operator|=
name|jfreeblk
operator|->
name|jf_ino
expr_stmt|;
name|rec
operator|->
name|jb_blkno
operator|=
name|jfreeblk
operator|->
name|jf_blkno
expr_stmt|;
name|rec
operator|->
name|jb_lbn
operator|=
name|jfreeblk
operator|->
name|jf_lbn
expr_stmt|;
name|rec
operator|->
name|jb_frags
operator|=
name|jfreeblk
operator|->
name|jf_frags
expr_stmt|;
name|rec
operator|->
name|jb_oldfrags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jfreefrag_write
parameter_list|(
name|jfreefrag
parameter_list|,
name|jseg
parameter_list|,
name|data
parameter_list|)
name|struct
name|jfreefrag
modifier|*
name|jfreefrag
decl_stmt|;
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|jblkrec
modifier|*
name|rec
decl_stmt|;
name|jfreefrag
operator|->
name|fr_jsegdep
operator|->
name|jd_seg
operator|=
name|jseg
expr_stmt|;
name|rec
operator|=
operator|(
expr|struct
name|jblkrec
operator|*
operator|)
name|data
expr_stmt|;
name|rec
operator|->
name|jb_op
operator|=
name|JOP_FREEBLK
expr_stmt|;
name|rec
operator|->
name|jb_ino
operator|=
name|jfreefrag
operator|->
name|fr_ino
expr_stmt|;
name|rec
operator|->
name|jb_blkno
operator|=
name|jfreefrag
operator|->
name|fr_blkno
expr_stmt|;
name|rec
operator|->
name|jb_lbn
operator|=
name|jfreefrag
operator|->
name|fr_lbn
expr_stmt|;
name|rec
operator|->
name|jb_frags
operator|=
name|jfreefrag
operator|->
name|fr_frags
expr_stmt|;
name|rec
operator|->
name|jb_oldfrags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jtrunc_write
parameter_list|(
name|jtrunc
parameter_list|,
name|jseg
parameter_list|,
name|data
parameter_list|)
name|struct
name|jtrunc
modifier|*
name|jtrunc
decl_stmt|;
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|jtrncrec
modifier|*
name|rec
decl_stmt|;
name|jtrunc
operator|->
name|jt_dep
operator|.
name|jb_jsegdep
operator|->
name|jd_seg
operator|=
name|jseg
expr_stmt|;
name|rec
operator|=
operator|(
expr|struct
name|jtrncrec
operator|*
operator|)
name|data
expr_stmt|;
name|rec
operator|->
name|jt_op
operator|=
name|JOP_TRUNC
expr_stmt|;
name|rec
operator|->
name|jt_ino
operator|=
name|jtrunc
operator|->
name|jt_ino
expr_stmt|;
name|rec
operator|->
name|jt_size
operator|=
name|jtrunc
operator|->
name|jt_size
expr_stmt|;
name|rec
operator|->
name|jt_extsize
operator|=
name|jtrunc
operator|->
name|jt_extsize
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jfsync_write
parameter_list|(
name|jfsync
parameter_list|,
name|jseg
parameter_list|,
name|data
parameter_list|)
name|struct
name|jfsync
modifier|*
name|jfsync
decl_stmt|;
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|jtrncrec
modifier|*
name|rec
decl_stmt|;
name|rec
operator|=
operator|(
expr|struct
name|jtrncrec
operator|*
operator|)
name|data
expr_stmt|;
name|rec
operator|->
name|jt_op
operator|=
name|JOP_SYNC
expr_stmt|;
name|rec
operator|->
name|jt_ino
operator|=
name|jfsync
operator|->
name|jfs_ino
expr_stmt|;
name|rec
operator|->
name|jt_size
operator|=
name|jfsync
operator|->
name|jfs_size
expr_stmt|;
name|rec
operator|->
name|jt_extsize
operator|=
name|jfsync
operator|->
name|jfs_extsize
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|softdep_flushjournal
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
if|if
condition|(
name|MOUNTEDSUJ
argument_list|(
name|mp
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|jblocks
operator|=
name|ump
operator|->
name|softdep_jblocks
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
while|while
condition|(
name|ump
operator|->
name|softdep_on_journal
condition|)
block|{
name|jblocks
operator|->
name|jb_needseg
operator|=
literal|1
expr_stmt|;
name|softdep_process_journal
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|softdep_synchronize_completed
parameter_list|(
name|struct
name|bio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|softdep_synchronize
parameter_list|(
name|struct
name|bio
modifier|*
parameter_list|,
name|struct
name|ufsmount
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|softdep_synchronize_completed
parameter_list|(
name|bp
parameter_list|)
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|jseg
modifier|*
name|oldest
decl_stmt|;
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
comment|/* 	 * caller1 marks the last segment written before we issued the 	 * synchronize cache. 	 */
name|jseg
operator|=
name|bp
operator|->
name|bio_caller1
expr_stmt|;
if|if
condition|(
name|jseg
operator|==
name|NULL
condition|)
block|{
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|jseg
operator|->
name|js_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|oldest
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Mark all the journal entries waiting on the synchronize cache 	 * as completed so they may continue on. 	 */
while|while
condition|(
name|jseg
operator|!=
name|NULL
operator|&&
operator|(
name|jseg
operator|->
name|js_state
operator|&
name|COMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|jseg
operator|->
name|js_state
operator||=
name|COMPLETE
expr_stmt|;
name|oldest
operator|=
name|jseg
expr_stmt|;
name|jseg
operator|=
name|TAILQ_PREV
argument_list|(
name|jseg
argument_list|,
name|jseglst
argument_list|,
name|js_next
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Restart deferred journal entry processing from the oldest 	 * completed jseg. 	 */
if|if
condition|(
name|oldest
condition|)
name|complete_jsegs
argument_list|(
name|oldest
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send BIO_FLUSH/SYNCHRONIZE CACHE to the device to enforce write ordering  * barriers.  The journal must be written prior to any blocks that depend  * on it and the journal can not be released until the blocks have be  * written.  This code handles both barriers simultaneously.  */
end_comment

begin_function
specifier|static
name|void
name|softdep_synchronize
parameter_list|(
name|bp
parameter_list|,
name|ump
parameter_list|,
name|caller1
parameter_list|)
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|void
modifier|*
name|caller1
decl_stmt|;
block|{
name|bp
operator|->
name|bio_cmd
operator|=
name|BIO_FLUSH
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ORDERED
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|NULL
expr_stmt|;
name|bp
operator|->
name|bio_offset
operator|=
name|ump
operator|->
name|um_cp
operator|->
name|provider
operator|->
name|mediasize
expr_stmt|;
name|bp
operator|->
name|bio_length
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bio_done
operator|=
name|softdep_synchronize_completed
expr_stmt|;
name|bp
operator|->
name|bio_caller1
operator|=
name|caller1
expr_stmt|;
name|g_io_request
argument_list|(
name|bp
argument_list|,
operator|(
expr|struct
name|g_consumer
operator|*
operator|)
name|ump
operator|->
name|um_devvp
operator|->
name|v_bufobj
operator|.
name|bo_private
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush some journal records to disk.  */
end_comment

begin_function
specifier|static
name|void
name|softdep_process_journal
parameter_list|(
name|mp
parameter_list|,
name|needwk
parameter_list|,
name|flags
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|worklist
modifier|*
name|needwk
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|int
name|shouldflush
decl_stmt|;
name|int
name|segwritten
decl_stmt|;
name|int
name|jrecmin
decl_stmt|;
comment|/* Minimum records per block. */
name|int
name|jrecmax
decl_stmt|;
comment|/* Maximum records per block. */
name|int
name|size
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|devbsize
decl_stmt|;
if|if
condition|(
name|MOUNTEDSUJ
argument_list|(
name|mp
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|shouldflush
operator|=
name|softdep_flushcache
expr_stmt|;
name|bio
operator|=
name|NULL
expr_stmt|;
name|jseg
operator|=
name|NULL
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
name|jblocks
operator|=
name|ump
operator|->
name|softdep_jblocks
expr_stmt|;
name|devbsize
operator|=
name|ump
operator|->
name|um_devvp
operator|->
name|v_bufobj
operator|.
name|bo_bsize
expr_stmt|;
comment|/* 	 * We write anywhere between a disk block and fs block.  The upper 	 * bound is picked to prevent buffer cache fragmentation and limit 	 * processing time per I/O. 	 */
name|jrecmin
operator|=
operator|(
name|devbsize
operator|/
name|JREC_SIZE
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* -1 for seg header */
name|jrecmax
operator|=
operator|(
name|fs
operator|->
name|fs_bsize
operator|/
name|devbsize
operator|)
operator|*
name|jrecmin
expr_stmt|;
name|segwritten
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cnt
operator|=
name|ump
operator|->
name|softdep_on_journal
expr_stmt|;
comment|/* 		 * Criteria for writing a segment: 		 * 1) We have a full block. 		 * 2) We're called from jwait() and haven't found the 		 *    journal item yet. 		 * 3) Always write if needseg is set. 		 * 4) If we are called from process_worklist and have 		 *    not yet written anything we write a partial block 		 *    to enforce a 1 second maximum latency on journal 		 *    entries. 		 */
if|if
condition|(
name|cnt
operator|<
operator|(
name|jrecmax
operator|-
literal|1
operator|)
operator|&&
name|needwk
operator|==
name|NULL
operator|&&
name|jblocks
operator|->
name|jb_needseg
operator|==
literal|0
operator|&&
operator|(
name|segwritten
operator|||
name|cnt
operator|==
literal|0
operator|)
condition|)
break|break;
name|cnt
operator|++
expr_stmt|;
comment|/* 		 * Verify some free journal space.  softdep_prealloc() should 		 * guarantee that we don't run out so this is indicative of 		 * a problem with the flow control.  Try to recover 		 * gracefully in any event. 		 */
while|while
condition|(
name|jblocks
operator|->
name|jb_free
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|!=
name|MNT_WAIT
condition|)
break|break;
name|printf
argument_list|(
literal|"softdep: Out of journal space!\n"
argument_list|)
expr_stmt|;
name|softdep_speedup
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
name|jblocks
argument_list|,
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|,
name|PRIBIO
argument_list|,
literal|"jblocks"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|jseg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|jseg
argument_list|)
argument_list|,
name|M_JSEG
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|jseg
operator|->
name|js_list
argument_list|,
name|D_JSEG
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|jseg
operator|->
name|js_entries
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|jseg
operator|->
name|js_indirs
argument_list|)
expr_stmt|;
name|jseg
operator|->
name|js_state
operator|=
name|ATTACHED
expr_stmt|;
if|if
condition|(
name|shouldflush
operator|==
literal|0
condition|)
name|jseg
operator|->
name|js_state
operator||=
name|COMPLETE
expr_stmt|;
elseif|else
if|if
condition|(
name|bio
operator|==
name|NULL
condition|)
name|bio
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
name|jseg
operator|->
name|js_jblocks
operator|=
name|jblocks
expr_stmt|;
name|bp
operator|=
name|geteblk
argument_list|(
name|fs
operator|->
name|fs_bsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 		 * If there was a race while we were allocating the block 		 * and jseg the entry we care about was likely written. 		 * We bail out in both the WAIT and NOWAIT case and assume 		 * the caller will loop if the entry it cares about is 		 * not written. 		 */
name|cnt
operator|=
name|ump
operator|->
name|softdep_on_journal
expr_stmt|;
if|if
condition|(
name|cnt
operator|+
name|jblocks
operator|->
name|jb_needseg
operator|==
literal|0
operator|||
name|jblocks
operator|->
name|jb_free
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_NOCACHE
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|jseg
argument_list|,
name|D_JSEG
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Calculate the disk block size required for the available 		 * records rounded to the min size. 		 */
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
name|size
operator|=
name|devbsize
expr_stmt|;
elseif|else
if|if
condition|(
name|cnt
operator|<
name|jrecmax
condition|)
name|size
operator|=
name|howmany
argument_list|(
name|cnt
argument_list|,
name|jrecmin
argument_list|)
operator|*
name|devbsize
expr_stmt|;
else|else
name|size
operator|=
name|fs
operator|->
name|fs_bsize
expr_stmt|;
comment|/* 		 * Allocate a disk block for this journal data and account 		 * for truncation of the requested size if enough contiguous 		 * space was not available. 		 */
name|bp
operator|->
name|b_blkno
operator|=
name|jblocks_alloc
argument_list|(
name|jblocks
argument_list|,
name|size
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_lblkno
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|bp
operator|->
name|b_offset
operator|=
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|size
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_INVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_VALIDSUSPWRT
operator||
name|B_NOCOPY
expr_stmt|;
comment|/* 		 * Initialize our jseg with cnt records.  Assign the next 		 * sequence number to it and link it in-order. 		 */
name|cnt
operator|=
name|MIN
argument_list|(
name|cnt
argument_list|,
operator|(
name|size
operator|/
name|devbsize
operator|)
operator|*
name|jrecmin
argument_list|)
expr_stmt|;
name|jseg
operator|->
name|js_buf
operator|=
name|bp
expr_stmt|;
name|jseg
operator|->
name|js_cnt
operator|=
name|cnt
expr_stmt|;
name|jseg
operator|->
name|js_refs
operator|=
name|cnt
operator|+
literal|1
expr_stmt|;
comment|/* Self ref. */
name|jseg
operator|->
name|js_size
operator|=
name|size
expr_stmt|;
name|jseg
operator|->
name|js_seq
operator|=
name|jblocks
operator|->
name|jb_nextseq
operator|++
expr_stmt|;
if|if
condition|(
name|jblocks
operator|->
name|jb_oldestseg
operator|==
name|NULL
condition|)
name|jblocks
operator|->
name|jb_oldestseg
operator|=
name|jseg
expr_stmt|;
name|jseg
operator|->
name|js_oldseq
operator|=
name|jblocks
operator|->
name|jb_oldestseg
operator|->
name|js_seq
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|jblocks
operator|->
name|jb_segs
argument_list|,
name|jseg
argument_list|,
name|js_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|jblocks
operator|->
name|jb_writeseg
operator|==
name|NULL
condition|)
name|jblocks
operator|->
name|jb_writeseg
operator|=
name|jseg
expr_stmt|;
comment|/* 		 * Start filling in records from the pending list. 		 */
name|data
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Always put a header on the first block. 		 * XXX As with below, there might not be a chance to get 		 * into the loop.  Ensure that something valid is written. 		 */
name|jseg_write
argument_list|(
name|ump
argument_list|,
name|jseg
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|off
operator|+=
name|JREC_SIZE
expr_stmt|;
name|data
operator|=
name|bp
operator|->
name|b_data
operator|+
name|off
expr_stmt|;
comment|/* 		 * XXX Something is wrong here.  There's no work to do, 		 * but we need to perform and I/O and allow it to complete 		 * anyways. 		 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|ump
operator|->
name|softdep_journal_pending
argument_list|)
condition|)
name|stat_emptyjblocks
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ump
operator|->
name|softdep_journal_pending
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
break|break;
comment|/* Place a segment header on every device block. */
if|if
condition|(
operator|(
name|off
operator|%
name|devbsize
operator|)
operator|==
literal|0
condition|)
block|{
name|jseg_write
argument_list|(
name|ump
argument_list|,
name|jseg
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|off
operator|+=
name|JREC_SIZE
expr_stmt|;
name|data
operator|=
name|bp
operator|->
name|b_data
operator|+
name|off
expr_stmt|;
block|}
if|if
condition|(
name|wk
operator|==
name|needwk
condition|)
name|needwk
operator|=
name|NULL
expr_stmt|;
name|remove_from_journal
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|wk
operator|->
name|wk_state
operator||=
name|INPROGRESS
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|jseg
operator|->
name|js_entries
argument_list|,
name|wk
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_JADDREF
case|:
name|jaddref_write
argument_list|(
name|WK_JADDREF
argument_list|(
name|wk
argument_list|)
argument_list|,
name|jseg
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_JREMREF
case|:
name|jremref_write
argument_list|(
name|WK_JREMREF
argument_list|(
name|wk
argument_list|)
argument_list|,
name|jseg
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_JMVREF
case|:
name|jmvref_write
argument_list|(
name|WK_JMVREF
argument_list|(
name|wk
argument_list|)
argument_list|,
name|jseg
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_JNEWBLK
case|:
name|jnewblk_write
argument_list|(
name|WK_JNEWBLK
argument_list|(
name|wk
argument_list|)
argument_list|,
name|jseg
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_JFREEBLK
case|:
name|jfreeblk_write
argument_list|(
name|WK_JFREEBLK
argument_list|(
name|wk
argument_list|)
argument_list|,
name|jseg
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_JFREEFRAG
case|:
name|jfreefrag_write
argument_list|(
name|WK_JFREEFRAG
argument_list|(
name|wk
argument_list|)
argument_list|,
name|jseg
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_JTRUNC
case|:
name|jtrunc_write
argument_list|(
name|WK_JTRUNC
argument_list|(
name|wk
argument_list|)
argument_list|,
name|jseg
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_JFSYNC
case|:
name|jfsync_write
argument_list|(
name|WK_JFSYNC
argument_list|(
name|wk
argument_list|)
argument_list|,
name|jseg
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"process_journal: Unknown type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|off
operator|+=
name|JREC_SIZE
expr_stmt|;
name|data
operator|=
name|bp
operator|->
name|b_data
operator|+
name|off
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
block|}
comment|/* Clear any remaining space so we don't leak kernel data */
if|if
condition|(
name|size
operator|>
name|off
condition|)
name|bzero
argument_list|(
name|data
argument_list|,
name|size
operator|-
name|off
argument_list|)
expr_stmt|;
comment|/* 		 * Write this one buffer and continue. 		 */
name|segwritten
operator|=
literal|1
expr_stmt|;
name|jblocks
operator|->
name|jb_needseg
operator|=
literal|0
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|jseg
operator|->
name|js_list
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|pbgetvp
argument_list|(
name|ump
operator|->
name|um_devvp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * We only do the blocking wait once we find the journal 		 * entry we're looking for. 		 */
if|if
condition|(
name|needwk
operator|==
name|NULL
operator|&&
name|flags
operator|==
name|MNT_WAIT
condition|)
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we wrote a segment issue a synchronize cache so the journal 	 * is reflected on disk before the data is written.  Since reclaiming 	 * journal space also requires writing a journal record this 	 * process also enforces a barrier before reclamation. 	 */
if|if
condition|(
name|segwritten
operator|&&
name|shouldflush
condition|)
block|{
name|softdep_synchronize
argument_list|(
name|bio
argument_list|,
name|ump
argument_list|,
name|TAILQ_LAST
argument_list|(
operator|&
name|jblocks
operator|->
name|jb_segs
argument_list|,
name|jseglst
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bio
condition|)
name|g_destroy_bio
argument_list|(
name|bio
argument_list|)
expr_stmt|;
comment|/* 	 * If we've suspended the filesystem because we ran out of journal 	 * space either try to sync it here to make some progress or 	 * unsuspend it if we already have. 	 */
if|if
condition|(
name|flags
operator|==
literal|0
operator|&&
name|jblocks
operator|->
name|jb_suspended
condition|)
block|{
if|if
condition|(
name|journal_unsuspend
argument_list|(
name|ump
argument_list|)
condition|)
return|return;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|VFS_SYNC
argument_list|(
name|mp
argument_list|,
name|MNT_NOWAIT
argument_list|)
expr_stmt|;
name|ffs_sbupdate
argument_list|(
name|ump
argument_list|,
name|MNT_WAIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Complete a jseg, allowing all dependencies awaiting journal writes  * to proceed.  Each journal dependency also attaches a jsegdep to dependent  * structures so that the journal segment can be freed to reclaim space.  */
end_comment

begin_function
specifier|static
name|void
name|complete_jseg
parameter_list|(
name|jseg
parameter_list|)
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|jmvref
modifier|*
name|jmvref
decl_stmt|;
name|int
name|waiting
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|int
name|i
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|jseg
operator|->
name|js_entries
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|waiting
operator|=
name|wk
operator|->
name|wk_state
operator|&
name|IOWAITING
expr_stmt|;
name|wk
operator|->
name|wk_state
operator|&=
operator|~
operator|(
name|INPROGRESS
operator||
name|IOWAITING
operator|)
expr_stmt|;
name|wk
operator|->
name|wk_state
operator||=
name|COMPLETE
expr_stmt|;
name|KASSERT
argument_list|(
name|i
operator|++
operator|<
name|jseg
operator|->
name|js_cnt
argument_list|,
operator|(
literal|"handle_written_jseg: overflow %d>= %d"
operator|,
name|i
operator|-
literal|1
operator|,
name|jseg
operator|->
name|js_cnt
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_JADDREF
case|:
name|handle_written_jaddref
argument_list|(
name|WK_JADDREF
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_JREMREF
case|:
name|handle_written_jremref
argument_list|(
name|WK_JREMREF
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_JMVREF
case|:
name|rele_jseg
argument_list|(
name|jseg
argument_list|)
expr_stmt|;
comment|/* No jsegdep. */
name|jmvref
operator|=
name|WK_JMVREF
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|jmvref
argument_list|,
name|jm_deps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|jmvref
operator|->
name|jm_pagedep
operator|->
name|pd_state
operator|&
name|ONWORKLIST
operator|)
operator|==
literal|0
condition|)
name|free_pagedep
argument_list|(
name|jmvref
operator|->
name|jm_pagedep
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|jmvref
argument_list|,
name|D_JMVREF
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_JNEWBLK
case|:
name|handle_written_jnewblk
argument_list|(
name|WK_JNEWBLK
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_JFREEBLK
case|:
name|handle_written_jblkdep
argument_list|(
operator|&
name|WK_JFREEBLK
argument_list|(
name|wk
argument_list|)
operator|->
name|jf_dep
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_JTRUNC
case|:
name|handle_written_jblkdep
argument_list|(
operator|&
name|WK_JTRUNC
argument_list|(
name|wk
argument_list|)
operator|->
name|jt_dep
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_JFSYNC
case|:
name|rele_jseg
argument_list|(
name|jseg
argument_list|)
expr_stmt|;
comment|/* No jsegdep. */
name|WORKITEM_FREE
argument_list|(
name|wk
argument_list|,
name|D_JFSYNC
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_JFREEFRAG
case|:
name|handle_written_jfreefrag
argument_list|(
name|WK_JFREEFRAG
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"handle_written_jseg: Unknown type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|waiting
condition|)
name|wakeup
argument_list|(
name|wk
argument_list|)
expr_stmt|;
block|}
comment|/* Release the self reference so the structure may be freed. */
name|rele_jseg
argument_list|(
name|jseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine which jsegs are ready for completion processing.  Waits for  * synchronize cache to complete as well as forcing in-order completion  * of journal entries.  */
end_comment

begin_function
specifier|static
name|void
name|complete_jsegs
parameter_list|(
name|jseg
parameter_list|)
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
block|{
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
name|struct
name|jseg
modifier|*
name|jsegn
decl_stmt|;
name|jblocks
operator|=
name|jseg
operator|->
name|js_jblocks
expr_stmt|;
comment|/* 	 * Don't allow out of order completions.  If this isn't the first 	 * block wait for it to write before we're done. 	 */
if|if
condition|(
name|jseg
operator|!=
name|jblocks
operator|->
name|jb_writeseg
condition|)
return|return;
comment|/* Iterate through available jsegs processing their entries. */
while|while
condition|(
name|jseg
operator|&&
operator|(
name|jseg
operator|->
name|js_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
block|{
name|jblocks
operator|->
name|jb_oldestwrseq
operator|=
name|jseg
operator|->
name|js_oldseq
expr_stmt|;
name|jsegn
operator|=
name|TAILQ_NEXT
argument_list|(
name|jseg
argument_list|,
name|js_next
argument_list|)
expr_stmt|;
name|complete_jseg
argument_list|(
name|jseg
argument_list|)
expr_stmt|;
name|jseg
operator|=
name|jsegn
expr_stmt|;
block|}
name|jblocks
operator|->
name|jb_writeseg
operator|=
name|jseg
expr_stmt|;
comment|/* 	 * Attempt to free jsegs now that oldestwrseq may have advanced.  	 */
name|free_jsegs
argument_list|(
name|jblocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark a jseg as DEPCOMPLETE and throw away the buffer.  Attempt to handle  * the final completions.  */
end_comment

begin_function
specifier|static
name|void
name|handle_written_jseg
parameter_list|(
name|jseg
parameter_list|,
name|bp
parameter_list|)
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
if|if
condition|(
name|jseg
operator|->
name|js_refs
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"handle_written_jseg: No self-reference on %p"
argument_list|,
name|jseg
argument_list|)
expr_stmt|;
name|jseg
operator|->
name|js_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
comment|/* 	 * We'll never need this buffer again, set flags so it will be 	 * discarded. 	 */
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_NOCACHE
expr_stmt|;
name|pbrelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|complete_jsegs
argument_list|(
name|jseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|jsegdep
modifier|*
name|inoref_jseg
parameter_list|(
name|inoref
parameter_list|)
name|struct
name|inoref
modifier|*
name|inoref
decl_stmt|;
block|{
name|struct
name|jsegdep
modifier|*
name|jsegdep
decl_stmt|;
name|jsegdep
operator|=
name|inoref
operator|->
name|if_jsegdep
expr_stmt|;
name|inoref
operator|->
name|if_jsegdep
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|jsegdep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called once a jremref has made it to stable store.  The jremref is marked  * complete and we attempt to free it.  Any pagedeps writes sleeping waiting  * for the jremref to complete will be awoken by free_jremref.  */
end_comment

begin_function
specifier|static
name|void
name|handle_written_jremref
parameter_list|(
name|jremref
parameter_list|)
name|struct
name|jremref
modifier|*
name|jremref
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|jsegdep
modifier|*
name|jsegdep
decl_stmt|;
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
comment|/* Grab the jsegdep. */
name|jsegdep
operator|=
name|inoref_jseg
argument_list|(
operator|&
name|jremref
operator|->
name|jr_ref
argument_list|)
expr_stmt|;
comment|/* 	 * Remove us from the inoref list. 	 */
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|jremref
operator|->
name|jr_list
operator|.
name|wk_mp
argument_list|,
name|jremref
operator|->
name|jr_ref
operator|.
name|if_ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"handle_written_jremref: Lost inodedep"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
operator|&
name|jremref
operator|->
name|jr_ref
argument_list|,
name|if_deps
argument_list|)
expr_stmt|;
comment|/* 	 * Complete the dirrem. 	 */
name|dirrem
operator|=
name|jremref
operator|->
name|jr_dirrem
expr_stmt|;
name|jremref
operator|->
name|jr_dirrem
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|jremref
argument_list|,
name|jr_deps
argument_list|)
expr_stmt|;
name|jsegdep
operator|->
name|jd_state
operator||=
name|jremref
operator|->
name|jr_state
operator|&
name|MKDIR_PARENT
expr_stmt|;
name|jwork_insert
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jwork
argument_list|,
name|jsegdep
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jremrefhd
argument_list|)
operator|&&
operator|(
name|dirrem
operator|->
name|dm_state
operator|&
name|COMPLETE
operator|)
operator|!=
literal|0
condition|)
name|add_to_worklist
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_jremref
argument_list|(
name|jremref
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called once a jaddref has made it to stable store.  The dependency is  * marked complete and any dependent structures are added to the inode  * bufwait list to be completed as soon as it is written.  If a bitmap write  * depends on this entry we move the inode into the inodedephd of the  * bmsafemap dependency and attempt to remove the jaddref from the bmsafemap.  */
end_comment

begin_function
specifier|static
name|void
name|handle_written_jaddref
parameter_list|(
name|jaddref
parameter_list|)
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
block|{
name|struct
name|jsegdep
modifier|*
name|jsegdep
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|diradd
modifier|*
name|diradd
decl_stmt|;
name|struct
name|mkdir
modifier|*
name|mkdir
decl_stmt|;
comment|/* Grab the jsegdep. */
name|jsegdep
operator|=
name|inoref_jseg
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_ref
argument_list|)
expr_stmt|;
name|mkdir
operator|=
name|NULL
expr_stmt|;
name|diradd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|jaddref
operator|->
name|ja_list
operator|.
name|wk_mp
argument_list|,
name|jaddref
operator|->
name|ja_ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"handle_written_jaddref: Lost inodedep."
argument_list|)
expr_stmt|;
if|if
condition|(
name|jaddref
operator|->
name|ja_diradd
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"handle_written_jaddref: No dependency"
argument_list|)
expr_stmt|;
if|if
condition|(
name|jaddref
operator|->
name|ja_diradd
operator|->
name|da_list
operator|.
name|wk_type
operator|==
name|D_DIRADD
condition|)
block|{
name|diradd
operator|=
name|jaddref
operator|->
name|ja_diradd
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|,
operator|&
name|diradd
operator|->
name|da_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jaddref
operator|->
name|ja_state
operator|&
name|MKDIR_PARENT
condition|)
block|{
name|mkdir
operator|=
name|jaddref
operator|->
name|ja_mkdir
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|,
operator|&
name|mkdir
operator|->
name|md_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jaddref
operator|->
name|ja_state
operator|&
name|MKDIR_BODY
condition|)
name|mkdir
operator|=
name|jaddref
operator|->
name|ja_mkdir
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"handle_written_jaddref: Unknown dependency %p"
argument_list|,
name|jaddref
operator|->
name|ja_diradd
argument_list|)
expr_stmt|;
name|jaddref
operator|->
name|ja_diradd
operator|=
name|NULL
expr_stmt|;
comment|/* also clears ja_mkdir */
comment|/* 	 * Remove us from the inode list. 	 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
operator|&
name|jaddref
operator|->
name|ja_ref
argument_list|,
name|if_deps
argument_list|)
expr_stmt|;
comment|/* 	 * The mkdir may be waiting on the jaddref to clear before freeing. 	 */
if|if
condition|(
name|mkdir
condition|)
block|{
name|KASSERT
argument_list|(
name|mkdir
operator|->
name|md_list
operator|.
name|wk_type
operator|==
name|D_MKDIR
argument_list|,
operator|(
literal|"handle_written_jaddref: Incorrect type for mkdir %s"
operator|,
name|TYPENAME
argument_list|(
name|mkdir
operator|->
name|md_list
operator|.
name|wk_type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mkdir
operator|->
name|md_jaddref
operator|=
name|NULL
expr_stmt|;
name|diradd
operator|=
name|mkdir
operator|->
name|md_diradd
expr_stmt|;
name|mkdir
operator|->
name|md_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|complete_mkdir
argument_list|(
name|mkdir
argument_list|)
expr_stmt|;
block|}
name|jwork_insert
argument_list|(
operator|&
name|diradd
operator|->
name|da_jwork
argument_list|,
name|jsegdep
argument_list|)
expr_stmt|;
if|if
condition|(
name|jaddref
operator|->
name|ja_state
operator|&
name|NEWBLOCK
condition|)
block|{
name|inodedep
operator|->
name|id_state
operator||=
name|ONDEPLIST
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bmsafemap
operator|->
name|sm_inodedephd
argument_list|,
name|inodedep
argument_list|,
name|id_deps
argument_list|)
expr_stmt|;
block|}
name|free_jaddref
argument_list|(
name|jaddref
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called once a jnewblk journal is written.  The allocdirect or allocindir  * is placed in the bmsafemap to await notification of a written bitmap.  If  * the operation was canceled we add the segdep to the appropriate  * dependency to free the journal space once the canceling operation  * completes.  */
end_comment

begin_function
specifier|static
name|void
name|handle_written_jnewblk
parameter_list|(
name|jnewblk
parameter_list|)
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|;
block|{
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
name|struct
name|jsegdep
modifier|*
name|jsegdep
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
comment|/* Grab the jsegdep. */
name|jsegdep
operator|=
name|jnewblk
operator|->
name|jn_jsegdep
expr_stmt|;
name|jnewblk
operator|->
name|jn_jsegdep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|jnewblk
operator|->
name|jn_dep
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"handle_written_jnewblk: No dependency for the segdep."
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|jnewblk
operator|->
name|jn_dep
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_NEWBLK
case|:
case|case
name|D_ALLOCDIRECT
case|:
case|case
name|D_ALLOCINDIR
case|:
comment|/* 		 * Add the written block to the bmsafemap so it can 		 * be notified when the bitmap is on disk. 		 */
name|newblk
operator|=
name|WK_NEWBLK
argument_list|(
name|jnewblk
operator|->
name|jn_dep
argument_list|)
expr_stmt|;
name|newblk
operator|->
name|nb_jnewblk
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|newblk
operator|->
name|nb_state
operator|&
name|GOINGAWAY
operator|)
operator|==
literal|0
condition|)
block|{
name|bmsafemap
operator|=
name|newblk
operator|->
name|nb_bmsafemap
expr_stmt|;
name|newblk
operator|->
name|nb_state
operator||=
name|ONDEPLIST
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_newblkhd
argument_list|,
name|newblk
argument_list|,
name|nb_deps
argument_list|)
expr_stmt|;
block|}
name|jwork_insert
argument_list|(
operator|&
name|newblk
operator|->
name|nb_jwork
argument_list|,
name|jsegdep
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_FREEFRAG
case|:
comment|/* 		 * A newblock being removed by a freefrag when replaced by 		 * frag extension. 		 */
name|freefrag
operator|=
name|WK_FREEFRAG
argument_list|(
name|jnewblk
operator|->
name|jn_dep
argument_list|)
expr_stmt|;
name|freefrag
operator|->
name|ff_jdep
operator|=
name|NULL
expr_stmt|;
name|jwork_insert
argument_list|(
operator|&
name|freefrag
operator|->
name|ff_jwork
argument_list|,
name|jsegdep
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_FREEWORK
case|:
comment|/* 		 * A direct block was removed by truncate. 		 */
name|freework
operator|=
name|WK_FREEWORK
argument_list|(
name|jnewblk
operator|->
name|jn_dep
argument_list|)
expr_stmt|;
name|freework
operator|->
name|fw_jnewblk
operator|=
name|NULL
expr_stmt|;
name|jwork_insert
argument_list|(
operator|&
name|freework
operator|->
name|fw_freeblks
operator|->
name|fb_jwork
argument_list|,
name|jsegdep
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"handle_written_jnewblk: Unknown type %d."
argument_list|,
name|jnewblk
operator|->
name|jn_dep
operator|->
name|wk_type
argument_list|)
expr_stmt|;
block|}
name|jnewblk
operator|->
name|jn_dep
operator|=
name|NULL
expr_stmt|;
name|free_jnewblk
argument_list|(
name|jnewblk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cancel a jfreefrag that won't be needed, probably due to colliding with  * an in-flight allocation that has not yet been committed.  Divorce us  * from the freefrag and mark it DEPCOMPLETE so that it may be added  * to the worklist.  */
end_comment

begin_function
specifier|static
name|void
name|cancel_jfreefrag
parameter_list|(
name|jfreefrag
parameter_list|)
name|struct
name|jfreefrag
modifier|*
name|jfreefrag
decl_stmt|;
block|{
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
if|if
condition|(
name|jfreefrag
operator|->
name|fr_jsegdep
condition|)
block|{
name|free_jsegdep
argument_list|(
name|jfreefrag
operator|->
name|fr_jsegdep
argument_list|)
expr_stmt|;
name|jfreefrag
operator|->
name|fr_jsegdep
operator|=
name|NULL
expr_stmt|;
block|}
name|freefrag
operator|=
name|jfreefrag
operator|->
name|fr_freefrag
expr_stmt|;
name|jfreefrag
operator|->
name|fr_freefrag
operator|=
name|NULL
expr_stmt|;
name|free_jfreefrag
argument_list|(
name|jfreefrag
argument_list|)
expr_stmt|;
name|freefrag
operator|->
name|ff_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"cancel_jfreefrag: blkno %jd"
argument_list|,
name|freefrag
operator|->
name|ff_blkno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a jfreefrag when the parent freefrag is rendered obsolete.  */
end_comment

begin_function
specifier|static
name|void
name|free_jfreefrag
parameter_list|(
name|jfreefrag
parameter_list|)
name|struct
name|jfreefrag
modifier|*
name|jfreefrag
decl_stmt|;
block|{
if|if
condition|(
name|jfreefrag
operator|->
name|fr_state
operator|&
name|INPROGRESS
condition|)
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|jfreefrag
operator|->
name|fr_list
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|jfreefrag
operator|->
name|fr_state
operator|&
name|ONWORKLIST
condition|)
name|remove_from_journal
argument_list|(
operator|&
name|jfreefrag
operator|->
name|fr_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|jfreefrag
operator|->
name|fr_freefrag
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"free_jfreefrag:  Still attached to a freefrag."
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|jfreefrag
argument_list|,
name|D_JFREEFRAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when the journal write for a jfreefrag completes.  The parent  * freefrag is added to the worklist if this completes its dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|handle_written_jfreefrag
parameter_list|(
name|jfreefrag
parameter_list|)
name|struct
name|jfreefrag
modifier|*
name|jfreefrag
decl_stmt|;
block|{
name|struct
name|jsegdep
modifier|*
name|jsegdep
decl_stmt|;
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
comment|/* Grab the jsegdep. */
name|jsegdep
operator|=
name|jfreefrag
operator|->
name|fr_jsegdep
expr_stmt|;
name|jfreefrag
operator|->
name|fr_jsegdep
operator|=
name|NULL
expr_stmt|;
name|freefrag
operator|=
name|jfreefrag
operator|->
name|fr_freefrag
expr_stmt|;
if|if
condition|(
name|freefrag
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"handle_written_jfreefrag: No freefrag."
argument_list|)
expr_stmt|;
name|freefrag
operator|->
name|ff_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|freefrag
operator|->
name|ff_jdep
operator|=
name|NULL
expr_stmt|;
name|jwork_insert
argument_list|(
operator|&
name|freefrag
operator|->
name|ff_jwork
argument_list|,
name|jsegdep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|freefrag
operator|->
name|ff_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
name|add_to_worklist
argument_list|(
operator|&
name|freefrag
operator|->
name|ff_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jfreefrag
operator|->
name|fr_freefrag
operator|=
name|NULL
expr_stmt|;
name|free_jfreefrag
argument_list|(
name|jfreefrag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when the journal write for a jfreeblk completes.  The jfreeblk  * is removed from the freeblks list of pending journal writes and the  * jsegdep is moved to the freeblks jwork to be completed when all blocks  * have been reclaimed.  */
end_comment

begin_function
specifier|static
name|void
name|handle_written_jblkdep
parameter_list|(
name|jblkdep
parameter_list|)
name|struct
name|jblkdep
modifier|*
name|jblkdep
decl_stmt|;
block|{
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|jsegdep
modifier|*
name|jsegdep
decl_stmt|;
comment|/* Grab the jsegdep. */
name|jsegdep
operator|=
name|jblkdep
operator|->
name|jb_jsegdep
expr_stmt|;
name|jblkdep
operator|->
name|jb_jsegdep
operator|=
name|NULL
expr_stmt|;
name|freeblks
operator|=
name|jblkdep
operator|->
name|jb_freeblks
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|jblkdep
argument_list|,
name|jb_deps
argument_list|)
expr_stmt|;
name|jwork_insert
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jwork
argument_list|,
name|jsegdep
argument_list|)
expr_stmt|;
comment|/* 	 * If the freeblks is all journaled, we can add it to the worklist. 	 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|)
operator|&&
operator|(
name|freeblks
operator|->
name|fb_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
name|add_to_worklist
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_list
argument_list|,
name|WK_NODELAY
argument_list|)
expr_stmt|;
name|free_jblkdep
argument_list|(
name|jblkdep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|jsegdep
modifier|*
name|newjsegdep
parameter_list|(
name|struct
name|worklist
modifier|*
name|wk
parameter_list|)
block|{
name|struct
name|jsegdep
modifier|*
name|jsegdep
decl_stmt|;
name|jsegdep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|jsegdep
argument_list|)
argument_list|,
name|M_JSEGDEP
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|jsegdep
operator|->
name|jd_list
argument_list|,
name|D_JSEGDEP
argument_list|,
name|wk
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
name|jsegdep
operator|->
name|jd_seg
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|jsegdep
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|jmvref
modifier|*
name|newjmvref
parameter_list|(
name|dp
parameter_list|,
name|ino
parameter_list|,
name|oldoff
parameter_list|,
name|newoff
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|off_t
name|oldoff
decl_stmt|;
name|off_t
name|newoff
decl_stmt|;
block|{
name|struct
name|jmvref
modifier|*
name|jmvref
decl_stmt|;
name|jmvref
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|jmvref
argument_list|)
argument_list|,
name|M_JMVREF
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|jmvref
operator|->
name|jm_list
argument_list|,
name|D_JMVREF
argument_list|,
name|ITOVFS
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|jmvref
operator|->
name|jm_list
operator|.
name|wk_state
operator|=
name|ATTACHED
operator||
name|DEPCOMPLETE
expr_stmt|;
name|jmvref
operator|->
name|jm_parent
operator|=
name|dp
operator|->
name|i_number
expr_stmt|;
name|jmvref
operator|->
name|jm_ino
operator|=
name|ino
expr_stmt|;
name|jmvref
operator|->
name|jm_oldoff
operator|=
name|oldoff
expr_stmt|;
name|jmvref
operator|->
name|jm_newoff
operator|=
name|newoff
expr_stmt|;
return|return
operator|(
name|jmvref
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new jremref that tracks the removal of ip from dp with the  * directory entry offset of diroff.  Mark the entry as ATTACHED and  * DEPCOMPLETE as we have all the information required for the journal write  * and the directory has already been removed from the buffer.  The caller  * is responsible for linking the jremref into the pagedep and adding it  * to the journal to write.  The MKDIR_PARENT flag is set if we're doing  * a DOTDOT addition so handle_workitem_remove() can properly assign  * the jsegdep when we're done.  */
end_comment

begin_function
specifier|static
name|struct
name|jremref
modifier|*
name|newjremref
parameter_list|(
name|struct
name|dirrem
modifier|*
name|dirrem
parameter_list|,
name|struct
name|inode
modifier|*
name|dp
parameter_list|,
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|off_t
name|diroff
parameter_list|,
name|nlink_t
name|nlink
parameter_list|)
block|{
name|struct
name|jremref
modifier|*
name|jremref
decl_stmt|;
name|jremref
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|jremref
argument_list|)
argument_list|,
name|M_JREMREF
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|jremref
operator|->
name|jr_list
argument_list|,
name|D_JREMREF
argument_list|,
name|ITOVFS
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|jremref
operator|->
name|jr_state
operator|=
name|ATTACHED
expr_stmt|;
name|newinoref
argument_list|(
operator|&
name|jremref
operator|->
name|jr_ref
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|dp
operator|->
name|i_number
argument_list|,
name|diroff
argument_list|,
name|nlink
argument_list|,
name|ip
operator|->
name|i_mode
argument_list|)
expr_stmt|;
name|jremref
operator|->
name|jr_dirrem
operator|=
name|dirrem
expr_stmt|;
return|return
operator|(
name|jremref
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|newinoref
parameter_list|(
name|struct
name|inoref
modifier|*
name|inoref
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|ino_t
name|parent
parameter_list|,
name|off_t
name|diroff
parameter_list|,
name|nlink_t
name|nlink
parameter_list|,
name|uint16_t
name|mode
parameter_list|)
block|{
name|inoref
operator|->
name|if_jsegdep
operator|=
name|newjsegdep
argument_list|(
operator|&
name|inoref
operator|->
name|if_list
argument_list|)
expr_stmt|;
name|inoref
operator|->
name|if_diroff
operator|=
name|diroff
expr_stmt|;
name|inoref
operator|->
name|if_ino
operator|=
name|ino
expr_stmt|;
name|inoref
operator|->
name|if_parent
operator|=
name|parent
expr_stmt|;
name|inoref
operator|->
name|if_nlink
operator|=
name|nlink
expr_stmt|;
name|inoref
operator|->
name|if_mode
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new jaddref to track the addition of ino to dp at diroff.  The  * directory offset may not be known until later.  The caller is responsible  * adding the entry to the journal when this information is available.  nlink  * should be the link count prior to the addition and mode is only required  * to have the correct FMT.  */
end_comment

begin_function
specifier|static
name|struct
name|jaddref
modifier|*
name|newjaddref
parameter_list|(
name|struct
name|inode
modifier|*
name|dp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|off_t
name|diroff
parameter_list|,
name|int16_t
name|nlink
parameter_list|,
name|uint16_t
name|mode
parameter_list|)
block|{
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|jaddref
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|jaddref
argument_list|)
argument_list|,
name|M_JADDREF
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_list
argument_list|,
name|D_JADDREF
argument_list|,
name|ITOVFS
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|jaddref
operator|->
name|ja_state
operator|=
name|ATTACHED
expr_stmt|;
name|jaddref
operator|->
name|ja_mkdir
operator|=
name|NULL
expr_stmt|;
name|newinoref
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_ref
argument_list|,
name|ino
argument_list|,
name|dp
operator|->
name|i_number
argument_list|,
name|diroff
argument_list|,
name|nlink
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|jaddref
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new free dependency for a freework.  The caller is responsible  * for adjusting the reference count when it has the lock held.  The freedep  * will track an outstanding bitmap write that will ultimately clear the  * freework to continue.  */
end_comment

begin_function
specifier|static
name|struct
name|freedep
modifier|*
name|newfreedep
parameter_list|(
name|struct
name|freework
modifier|*
name|freework
parameter_list|)
block|{
name|struct
name|freedep
modifier|*
name|freedep
decl_stmt|;
name|freedep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|freedep
argument_list|)
argument_list|,
name|M_FREEDEP
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|freedep
operator|->
name|fd_list
argument_list|,
name|D_FREEDEP
argument_list|,
name|freework
operator|->
name|fw_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|freedep
operator|->
name|fd_freework
operator|=
name|freework
expr_stmt|;
return|return
operator|(
name|freedep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a freedep structure once the buffer it is linked to is written.  If  * this is the last reference to the freework schedule it for completion.  */
end_comment

begin_function
specifier|static
name|void
name|free_freedep
parameter_list|(
name|freedep
parameter_list|)
name|struct
name|freedep
modifier|*
name|freedep
decl_stmt|;
block|{
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
name|freework
operator|=
name|freedep
operator|->
name|fd_freework
expr_stmt|;
name|freework
operator|->
name|fw_freeblks
operator|->
name|fb_cgwait
operator|--
expr_stmt|;
if|if
condition|(
operator|--
name|freework
operator|->
name|fw_ref
operator|==
literal|0
condition|)
name|freework_enqueue
argument_list|(
name|freework
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|freedep
argument_list|,
name|D_FREEDEP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new freework structure that may be a level in an indirect  * when parent is not NULL or a top level block when it is.  The top level  * freework structures are allocated without the per-filesystem lock held  * and before the freeblks is visible outside of softdep_setup_freeblocks().  */
end_comment

begin_function
specifier|static
name|struct
name|freework
modifier|*
name|newfreework
parameter_list|(
name|ump
parameter_list|,
name|freeblks
parameter_list|,
name|parent
parameter_list|,
name|lbn
parameter_list|,
name|nb
parameter_list|,
name|frags
parameter_list|,
name|off
parameter_list|,
name|journal
parameter_list|)
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|freework
modifier|*
name|parent
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|ufs2_daddr_t
name|nb
decl_stmt|;
name|int
name|frags
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|journal
decl_stmt|;
block|{
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
name|freework
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|freework
argument_list|)
argument_list|,
name|M_FREEWORK
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|freework
operator|->
name|fw_list
argument_list|,
name|D_FREEWORK
argument_list|,
name|freeblks
operator|->
name|fb_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|freework
operator|->
name|fw_state
operator|=
name|ATTACHED
expr_stmt|;
name|freework
operator|->
name|fw_jnewblk
operator|=
name|NULL
expr_stmt|;
name|freework
operator|->
name|fw_freeblks
operator|=
name|freeblks
expr_stmt|;
name|freework
operator|->
name|fw_parent
operator|=
name|parent
expr_stmt|;
name|freework
operator|->
name|fw_lbn
operator|=
name|lbn
expr_stmt|;
name|freework
operator|->
name|fw_blkno
operator|=
name|nb
expr_stmt|;
name|freework
operator|->
name|fw_frags
operator|=
name|frags
expr_stmt|;
name|freework
operator|->
name|fw_indir
operator|=
name|NULL
expr_stmt|;
name|freework
operator|->
name|fw_ref
operator|=
operator|(
name|MOUNTEDSUJ
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|lbn
operator|>=
operator|-
name|UFS_NXADDR
operator|)
condition|?
literal|0
else|:
name|NINDIR
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|)
operator|+
literal|1
expr_stmt|;
name|freework
operator|->
name|fw_start
operator|=
name|freework
operator|->
name|fw_off
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|journal
condition|)
name|newjfreeblk
argument_list|(
name|freeblks
argument_list|,
name|lbn
argument_list|,
name|nb
argument_list|,
name|frags
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
block|{
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_freeworkhd
argument_list|,
operator|&
name|freework
operator|->
name|fw_list
argument_list|)
expr_stmt|;
name|freeblks
operator|->
name|fb_ref
operator|++
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|freework
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Eliminate a jfreeblk for a block that does not need journaling.  */
end_comment

begin_function
specifier|static
name|void
name|cancel_jfreeblk
parameter_list|(
name|freeblks
parameter_list|,
name|blkno
parameter_list|)
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
block|{
name|struct
name|jfreeblk
modifier|*
name|jfreeblk
decl_stmt|;
name|struct
name|jblkdep
modifier|*
name|jblkdep
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|jblkdep
argument_list|,
argument|&freeblks->fb_jblkdephd
argument_list|,
argument|jb_deps
argument_list|)
block|{
if|if
condition|(
name|jblkdep
operator|->
name|jb_list
operator|.
name|wk_type
operator|!=
name|D_JFREEBLK
condition|)
continue|continue;
name|jfreeblk
operator|=
name|WK_JFREEBLK
argument_list|(
operator|&
name|jblkdep
operator|->
name|jb_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|jfreeblk
operator|->
name|jf_blkno
operator|==
name|blkno
condition|)
break|break;
block|}
if|if
condition|(
name|jblkdep
operator|==
name|NULL
condition|)
return|return;
name|CTR1
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"cancel_jfreeblk: blkno %jd"
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|free_jsegdep
argument_list|(
name|jblkdep
operator|->
name|jb_jsegdep
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|jblkdep
argument_list|,
name|jb_deps
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|jfreeblk
argument_list|,
name|D_JFREEBLK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new jfreeblk to journal top level block pointer when truncating  * a file.  The caller must add this to the worklist when the per-filesystem  * lock is held.  */
end_comment

begin_function
specifier|static
name|struct
name|jfreeblk
modifier|*
name|newjfreeblk
parameter_list|(
name|freeblks
parameter_list|,
name|lbn
parameter_list|,
name|blkno
parameter_list|,
name|frags
parameter_list|)
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
name|int
name|frags
decl_stmt|;
block|{
name|struct
name|jfreeblk
modifier|*
name|jfreeblk
decl_stmt|;
name|jfreeblk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|jfreeblk
argument_list|)
argument_list|,
name|M_JFREEBLK
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|jfreeblk
operator|->
name|jf_dep
operator|.
name|jb_list
argument_list|,
name|D_JFREEBLK
argument_list|,
name|freeblks
operator|->
name|fb_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|jfreeblk
operator|->
name|jf_dep
operator|.
name|jb_jsegdep
operator|=
name|newjsegdep
argument_list|(
operator|&
name|jfreeblk
operator|->
name|jf_dep
operator|.
name|jb_list
argument_list|)
expr_stmt|;
name|jfreeblk
operator|->
name|jf_dep
operator|.
name|jb_freeblks
operator|=
name|freeblks
expr_stmt|;
name|jfreeblk
operator|->
name|jf_ino
operator|=
name|freeblks
operator|->
name|fb_inum
expr_stmt|;
name|jfreeblk
operator|->
name|jf_lbn
operator|=
name|lbn
expr_stmt|;
name|jfreeblk
operator|->
name|jf_blkno
operator|=
name|blkno
expr_stmt|;
name|jfreeblk
operator|->
name|jf_frags
operator|=
name|frags
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|,
operator|&
name|jfreeblk
operator|->
name|jf_dep
argument_list|,
name|jb_deps
argument_list|)
expr_stmt|;
return|return
operator|(
name|jfreeblk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The journal is only prepared to handle full-size block numbers, so we  * have to adjust the record to reflect the change to a full-size block.  * For example, suppose we have a block made up of fragments 8-15 and  * want to free its last two fragments. We are given a request that says:  *     FREEBLK ino=5, blkno=14, lbn=0, frags=2, oldfrags=0  * where frags are the number of fragments to free and oldfrags are the  * number of fragments to keep. To block align it, we have to change it to  * have a valid full-size blkno, so it becomes:  *     FREEBLK ino=5, blkno=8, lbn=0, frags=2, oldfrags=6  */
end_comment

begin_function
specifier|static
name|void
name|adjust_newfreework
parameter_list|(
name|freeblks
parameter_list|,
name|frag_offset
parameter_list|)
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|int
name|frag_offset
decl_stmt|;
block|{
name|struct
name|jfreeblk
modifier|*
name|jfreeblk
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|LIST_FIRST
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|)
operator|!=
name|NULL
operator|&&
name|LIST_FIRST
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|)
operator|->
name|jb_list
operator|.
name|wk_type
operator|==
name|D_JFREEBLK
operator|)
argument_list|,
operator|(
literal|"adjust_newfreework: Missing freeblks dependency"
operator|)
argument_list|)
expr_stmt|;
name|jfreeblk
operator|=
name|WK_JFREEBLK
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|)
argument_list|)
expr_stmt|;
name|jfreeblk
operator|->
name|jf_blkno
operator|-=
name|frag_offset
expr_stmt|;
name|jfreeblk
operator|->
name|jf_frags
operator|+=
name|frag_offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new jtrunc to track a partial truncation.  */
end_comment

begin_function
specifier|static
name|struct
name|jtrunc
modifier|*
name|newjtrunc
parameter_list|(
name|freeblks
parameter_list|,
name|size
parameter_list|,
name|extsize
parameter_list|)
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|int
name|extsize
decl_stmt|;
block|{
name|struct
name|jtrunc
modifier|*
name|jtrunc
decl_stmt|;
name|jtrunc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|jtrunc
argument_list|)
argument_list|,
name|M_JTRUNC
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|jtrunc
operator|->
name|jt_dep
operator|.
name|jb_list
argument_list|,
name|D_JTRUNC
argument_list|,
name|freeblks
operator|->
name|fb_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|jtrunc
operator|->
name|jt_dep
operator|.
name|jb_jsegdep
operator|=
name|newjsegdep
argument_list|(
operator|&
name|jtrunc
operator|->
name|jt_dep
operator|.
name|jb_list
argument_list|)
expr_stmt|;
name|jtrunc
operator|->
name|jt_dep
operator|.
name|jb_freeblks
operator|=
name|freeblks
expr_stmt|;
name|jtrunc
operator|->
name|jt_ino
operator|=
name|freeblks
operator|->
name|fb_inum
expr_stmt|;
name|jtrunc
operator|->
name|jt_size
operator|=
name|size
expr_stmt|;
name|jtrunc
operator|->
name|jt_extsize
operator|=
name|extsize
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|,
operator|&
name|jtrunc
operator|->
name|jt_dep
argument_list|,
name|jb_deps
argument_list|)
expr_stmt|;
return|return
operator|(
name|jtrunc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If we're canceling a new bitmap we have to search for another ref  * to move into the bmsafemap dep.  This might be better expressed  * with another structure.  */
end_comment

begin_function
specifier|static
name|void
name|move_newblock_dep
parameter_list|(
name|jaddref
parameter_list|,
name|inodedep
parameter_list|)
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
block|{
name|struct
name|inoref
modifier|*
name|inoref
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddrefn
decl_stmt|;
name|jaddrefn
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|inoref
operator|=
name|TAILQ_NEXT
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_ref
argument_list|,
name|if_deps
argument_list|)
init|;
name|inoref
condition|;
name|inoref
operator|=
name|TAILQ_NEXT
argument_list|(
name|inoref
argument_list|,
name|if_deps
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|jaddref
operator|->
name|ja_state
operator|&
name|NEWBLOCK
operator|)
operator|&&
name|inoref
operator|->
name|if_list
operator|.
name|wk_type
operator|==
name|D_JADDREF
condition|)
block|{
name|jaddrefn
operator|=
operator|(
expr|struct
name|jaddref
operator|*
operator|)
name|inoref
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|jaddrefn
operator|==
name|NULL
condition|)
return|return;
name|jaddrefn
operator|->
name|ja_state
operator|&=
operator|~
operator|(
name|ATTACHED
operator||
name|UNDONE
operator|)
expr_stmt|;
name|jaddrefn
operator|->
name|ja_state
operator||=
name|jaddref
operator|->
name|ja_state
operator|&
operator|(
name|ATTACHED
operator||
name|UNDONE
operator||
name|NEWBLOCK
operator|)
expr_stmt|;
name|jaddref
operator|->
name|ja_state
operator|&=
operator|~
operator|(
name|ATTACHED
operator||
name|UNDONE
operator||
name|NEWBLOCK
operator|)
expr_stmt|;
name|jaddref
operator|->
name|ja_state
operator||=
name|ATTACHED
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|jaddref
argument_list|,
name|ja_bmdeps
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bmsafemap
operator|->
name|sm_jaddrefhd
argument_list|,
name|jaddrefn
argument_list|,
name|ja_bmdeps
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cancel a jaddref either before it has been written or while it is being  * written.  This happens when a link is removed before the add reaches  * the disk.  The jaddref dependency is kept linked into the bmsafemap  * and inode to prevent the link count or bitmap from reaching the disk  * until handle_workitem_remove() re-adjusts the counts and bitmaps as  * required.  *  * Returns 1 if the canceled addref requires journaling of the remove and  * 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|cancel_jaddref
parameter_list|(
name|jaddref
parameter_list|,
name|inodedep
parameter_list|,
name|wkhd
parameter_list|)
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|struct
name|inoref
modifier|*
name|inoref
decl_stmt|;
name|struct
name|jsegdep
modifier|*
name|jsegdep
decl_stmt|;
name|int
name|needsj
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|jaddref
operator|->
name|ja_state
operator|&
name|COMPLETE
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"cancel_jaddref: Canceling complete jaddref"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|jaddref
operator|->
name|ja_state
operator|&
operator|(
name|INPROGRESS
operator||
name|COMPLETE
operator|)
condition|)
name|needsj
operator|=
literal|1
expr_stmt|;
else|else
name|needsj
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inodedep
operator|==
name|NULL
condition|)
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|jaddref
operator|->
name|ja_list
operator|.
name|wk_mp
argument_list|,
name|jaddref
operator|->
name|ja_ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"cancel_jaddref: Lost inodedep"
argument_list|)
expr_stmt|;
comment|/* 	 * We must adjust the nlink of any reference operation that follows 	 * us so that it is consistent with the in-memory reference.  This 	 * ensures that inode nlink rollbacks always have the correct link. 	 */
if|if
condition|(
name|needsj
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|inoref
operator|=
name|TAILQ_NEXT
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_ref
argument_list|,
name|if_deps
argument_list|)
init|;
name|inoref
condition|;
name|inoref
operator|=
name|TAILQ_NEXT
argument_list|(
name|inoref
argument_list|,
name|if_deps
argument_list|)
control|)
block|{
if|if
condition|(
name|inoref
operator|->
name|if_state
operator|&
name|GOINGAWAY
condition|)
break|break;
name|inoref
operator|->
name|if_nlink
operator|--
expr_stmt|;
block|}
block|}
name|jsegdep
operator|=
name|inoref_jseg
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|jaddref
operator|->
name|ja_state
operator|&
name|NEWBLOCK
condition|)
name|move_newblock_dep
argument_list|(
name|jaddref
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
name|wake_worklist
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_list
argument_list|)
expr_stmt|;
name|jaddref
operator|->
name|ja_mkdir
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|jaddref
operator|->
name|ja_state
operator|&
name|INPROGRESS
condition|)
block|{
name|jaddref
operator|->
name|ja_state
operator|&=
operator|~
name|INPROGRESS
expr_stmt|;
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_list
argument_list|)
expr_stmt|;
name|jwork_insert
argument_list|(
name|wkhd
argument_list|,
name|jsegdep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free_jsegdep
argument_list|(
name|jsegdep
argument_list|)
expr_stmt|;
if|if
condition|(
name|jaddref
operator|->
name|ja_state
operator|&
name|DEPCOMPLETE
condition|)
name|remove_from_journal
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_list
argument_list|)
expr_stmt|;
block|}
name|jaddref
operator|->
name|ja_state
operator||=
operator|(
name|GOINGAWAY
operator||
name|DEPCOMPLETE
operator|)
expr_stmt|;
comment|/* 	 * Leave NEWBLOCK jaddrefs on the inodedep so handle_workitem_remove 	 * can arrange for them to be freed with the bitmap.  Otherwise we 	 * no longer need this addref attached to the inoreflst and it 	 * will incorrectly adjust nlink if we leave it. 	 */
if|if
condition|(
operator|(
name|jaddref
operator|->
name|ja_state
operator|&
name|NEWBLOCK
operator|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
operator|&
name|jaddref
operator|->
name|ja_ref
argument_list|,
name|if_deps
argument_list|)
expr_stmt|;
name|jaddref
operator|->
name|ja_state
operator||=
name|COMPLETE
expr_stmt|;
name|free_jaddref
argument_list|(
name|jaddref
argument_list|)
expr_stmt|;
return|return
operator|(
name|needsj
operator|)
return|;
block|}
comment|/* 	 * Leave the head of the list for jsegdeps for fast merging. 	 */
if|if
condition|(
name|LIST_FIRST
argument_list|(
name|wkhd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|jaddref
operator|->
name|ja_state
operator||=
name|ONWORKLIST
expr_stmt|;
name|LIST_INSERT_AFTER
argument_list|(
name|LIST_FIRST
argument_list|(
name|wkhd
argument_list|)
argument_list|,
operator|&
name|jaddref
operator|->
name|ja_list
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
block|}
else|else
name|WORKLIST_INSERT
argument_list|(
name|wkhd
argument_list|,
operator|&
name|jaddref
operator|->
name|ja_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|needsj
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Attempt to free a jaddref structure when some work completes.  This  * should only succeed once the entry is written and all dependencies have  * been notified.  */
end_comment

begin_function
specifier|static
name|void
name|free_jaddref
parameter_list|(
name|jaddref
parameter_list|)
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|jaddref
operator|->
name|ja_state
operator|&
name|ALLCOMPLETE
operator|)
operator|!=
name|ALLCOMPLETE
condition|)
return|return;
if|if
condition|(
name|jaddref
operator|->
name|ja_ref
operator|.
name|if_jsegdep
condition|)
name|panic
argument_list|(
literal|"free_jaddref: segdep attached to jaddref %p(0x%X)\n"
argument_list|,
name|jaddref
argument_list|,
name|jaddref
operator|->
name|ja_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|jaddref
operator|->
name|ja_state
operator|&
name|NEWBLOCK
condition|)
name|LIST_REMOVE
argument_list|(
name|jaddref
argument_list|,
name|ja_bmdeps
argument_list|)
expr_stmt|;
if|if
condition|(
name|jaddref
operator|->
name|ja_state
operator|&
operator|(
name|INPROGRESS
operator||
name|ONWORKLIST
operator|)
condition|)
name|panic
argument_list|(
literal|"free_jaddref: Bad state %p(0x%X)"
argument_list|,
name|jaddref
argument_list|,
name|jaddref
operator|->
name|ja_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|jaddref
operator|->
name|ja_mkdir
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"free_jaddref: Work pending, 0x%X\n"
argument_list|,
name|jaddref
operator|->
name|ja_state
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|jaddref
argument_list|,
name|D_JADDREF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a jremref structure once it has been written or discarded.  */
end_comment

begin_function
specifier|static
name|void
name|free_jremref
parameter_list|(
name|jremref
parameter_list|)
name|struct
name|jremref
modifier|*
name|jremref
decl_stmt|;
block|{
if|if
condition|(
name|jremref
operator|->
name|jr_ref
operator|.
name|if_jsegdep
condition|)
name|free_jsegdep
argument_list|(
name|jremref
operator|->
name|jr_ref
operator|.
name|if_jsegdep
argument_list|)
expr_stmt|;
if|if
condition|(
name|jremref
operator|->
name|jr_state
operator|&
name|INPROGRESS
condition|)
name|panic
argument_list|(
literal|"free_jremref: IO still pending"
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|jremref
argument_list|,
name|D_JREMREF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a jnewblk structure.  */
end_comment

begin_function
specifier|static
name|void
name|free_jnewblk
parameter_list|(
name|jnewblk
parameter_list|)
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|jnewblk
operator|->
name|jn_state
operator|&
name|ALLCOMPLETE
operator|)
operator|!=
name|ALLCOMPLETE
condition|)
return|return;
name|LIST_REMOVE
argument_list|(
name|jnewblk
argument_list|,
name|jn_deps
argument_list|)
expr_stmt|;
if|if
condition|(
name|jnewblk
operator|->
name|jn_dep
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"free_jnewblk: Dependency still attached."
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|jnewblk
argument_list|,
name|D_JNEWBLK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cancel a jnewblk which has been been made redundant by frag extension.  */
end_comment

begin_function
specifier|static
name|void
name|cancel_jnewblk
parameter_list|(
name|jnewblk
parameter_list|,
name|wkhd
parameter_list|)
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|;
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|struct
name|jsegdep
modifier|*
name|jsegdep
decl_stmt|;
name|CTR1
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"cancel_jnewblk: blkno %jd"
argument_list|,
name|jnewblk
operator|->
name|jn_blkno
argument_list|)
expr_stmt|;
name|jsegdep
operator|=
name|jnewblk
operator|->
name|jn_jsegdep
expr_stmt|;
if|if
condition|(
name|jnewblk
operator|->
name|jn_jsegdep
operator|==
name|NULL
operator|||
name|jnewblk
operator|->
name|jn_dep
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"cancel_jnewblk: Invalid state"
argument_list|)
expr_stmt|;
name|jnewblk
operator|->
name|jn_jsegdep
operator|=
name|NULL
expr_stmt|;
name|jnewblk
operator|->
name|jn_dep
operator|=
name|NULL
expr_stmt|;
name|jnewblk
operator|->
name|jn_state
operator||=
name|GOINGAWAY
expr_stmt|;
if|if
condition|(
name|jnewblk
operator|->
name|jn_state
operator|&
name|INPROGRESS
condition|)
block|{
name|jnewblk
operator|->
name|jn_state
operator|&=
operator|~
name|INPROGRESS
expr_stmt|;
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|jnewblk
operator|->
name|jn_list
argument_list|)
expr_stmt|;
name|jwork_insert
argument_list|(
name|wkhd
argument_list|,
name|jsegdep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free_jsegdep
argument_list|(
name|jsegdep
argument_list|)
expr_stmt|;
name|remove_from_journal
argument_list|(
operator|&
name|jnewblk
operator|->
name|jn_list
argument_list|)
expr_stmt|;
block|}
name|wake_worklist
argument_list|(
operator|&
name|jnewblk
operator|->
name|jn_list
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
name|wkhd
argument_list|,
operator|&
name|jnewblk
operator|->
name|jn_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_jblkdep
parameter_list|(
name|jblkdep
parameter_list|)
name|struct
name|jblkdep
modifier|*
name|jblkdep
decl_stmt|;
block|{
if|if
condition|(
name|jblkdep
operator|->
name|jb_list
operator|.
name|wk_type
operator|==
name|D_JFREEBLK
condition|)
name|WORKITEM_FREE
argument_list|(
name|jblkdep
argument_list|,
name|D_JFREEBLK
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|jblkdep
operator|->
name|jb_list
operator|.
name|wk_type
operator|==
name|D_JTRUNC
condition|)
name|WORKITEM_FREE
argument_list|(
name|jblkdep
argument_list|,
name|D_JTRUNC
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"free_jblkdep: Unexpected type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|jblkdep
operator|->
name|jb_list
operator|.
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a single jseg once it is no longer referenced in memory or on  * disk.  Reclaim journal blocks and dependencies waiting for the segment  * to disappear.  */
end_comment

begin_function
specifier|static
name|void
name|free_jseg
parameter_list|(
name|jseg
parameter_list|,
name|jblocks
parameter_list|)
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
block|{
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
comment|/* 	 * Free freework structures that were lingering to indicate freed 	 * indirect blocks that forced journal write ordering on reallocate. 	 */
while|while
condition|(
operator|(
name|freework
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|jseg
operator|->
name|js_indirs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|indirblk_remove
argument_list|(
name|freework
argument_list|)
expr_stmt|;
if|if
condition|(
name|jblocks
operator|->
name|jb_oldestseg
operator|==
name|jseg
condition|)
name|jblocks
operator|->
name|jb_oldestseg
operator|=
name|TAILQ_NEXT
argument_list|(
name|jseg
argument_list|,
name|js_next
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|jblocks
operator|->
name|jb_segs
argument_list|,
name|jseg
argument_list|,
name|js_next
argument_list|)
expr_stmt|;
name|jblocks_free
argument_list|(
name|jblocks
argument_list|,
name|jseg
operator|->
name|js_list
operator|.
name|wk_mp
argument_list|,
name|jseg
operator|->
name|js_size
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|jseg
operator|->
name|js_entries
argument_list|)
argument_list|,
operator|(
literal|"free_jseg: Freed jseg has valid entries."
operator|)
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|jseg
argument_list|,
name|D_JSEG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free all jsegs that meet the criteria for being reclaimed and update  * oldestseg.  */
end_comment

begin_function
specifier|static
name|void
name|free_jsegs
parameter_list|(
name|jblocks
parameter_list|)
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
block|{
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
comment|/* 	 * Free only those jsegs which have none allocated before them to 	 * preserve the journal space ordering. 	 */
while|while
condition|(
operator|(
name|jseg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|jblocks
operator|->
name|jb_segs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Only reclaim space when nothing depends on this journal 		 * set and another set has written that it is no longer 		 * valid. 		 */
if|if
condition|(
name|jseg
operator|->
name|js_refs
operator|!=
literal|0
condition|)
block|{
name|jblocks
operator|->
name|jb_oldestseg
operator|=
name|jseg
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|jseg
operator|->
name|js_state
operator|&
name|ALLCOMPLETE
operator|)
operator|!=
name|ALLCOMPLETE
condition|)
break|break;
if|if
condition|(
name|jseg
operator|->
name|js_seq
operator|>
name|jblocks
operator|->
name|jb_oldestwrseq
condition|)
break|break;
comment|/* 		 * We can free jsegs that didn't write entries when 		 * oldestwrseq == js_seq. 		 */
if|if
condition|(
name|jseg
operator|->
name|js_seq
operator|==
name|jblocks
operator|->
name|jb_oldestwrseq
operator|&&
name|jseg
operator|->
name|js_cnt
operator|!=
literal|0
condition|)
break|break;
name|free_jseg
argument_list|(
name|jseg
argument_list|,
name|jblocks
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we exited the loop above we still must discover the 	 * oldest valid segment. 	 */
if|if
condition|(
name|jseg
condition|)
for|for
control|(
name|jseg
operator|=
name|jblocks
operator|->
name|jb_oldestseg
init|;
name|jseg
operator|!=
name|NULL
condition|;
name|jseg
operator|=
name|TAILQ_NEXT
argument_list|(
name|jseg
argument_list|,
name|js_next
argument_list|)
control|)
if|if
condition|(
name|jseg
operator|->
name|js_refs
operator|!=
literal|0
condition|)
break|break;
name|jblocks
operator|->
name|jb_oldestseg
operator|=
name|jseg
expr_stmt|;
comment|/* 	 * The journal has no valid records but some jsegs may still be 	 * waiting on oldestwrseq to advance.  We force a small record 	 * out to permit these lingering records to be reclaimed. 	 */
if|if
condition|(
name|jblocks
operator|->
name|jb_oldestseg
operator|==
name|NULL
operator|&&
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|jblocks
operator|->
name|jb_segs
argument_list|)
condition|)
name|jblocks
operator|->
name|jb_needseg
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release one reference to a jseg and free it if the count reaches 0.  This  * should eventually reclaim journal space as well.  */
end_comment

begin_function
specifier|static
name|void
name|rele_jseg
parameter_list|(
name|jseg
parameter_list|)
name|struct
name|jseg
modifier|*
name|jseg
decl_stmt|;
block|{
name|KASSERT
argument_list|(
name|jseg
operator|->
name|js_refs
operator|>
literal|0
argument_list|,
operator|(
literal|"free_jseg: Invalid refcnt %d"
operator|,
name|jseg
operator|->
name|js_refs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|jseg
operator|->
name|js_refs
operator|!=
literal|0
condition|)
return|return;
name|free_jsegs
argument_list|(
name|jseg
operator|->
name|js_jblocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release a jsegdep and decrement the jseg count.  */
end_comment

begin_function
specifier|static
name|void
name|free_jsegdep
parameter_list|(
name|jsegdep
parameter_list|)
name|struct
name|jsegdep
modifier|*
name|jsegdep
decl_stmt|;
block|{
if|if
condition|(
name|jsegdep
operator|->
name|jd_seg
condition|)
name|rele_jseg
argument_list|(
name|jsegdep
operator|->
name|jd_seg
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|jsegdep
argument_list|,
name|D_JSEGDEP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for a journal item to make it to disk.  Initiate journal processing  * if required.  */
end_comment

begin_function
specifier|static
name|int
name|jwait
parameter_list|(
name|wk
parameter_list|,
name|waitfor
parameter_list|)
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|int
name|waitfor
decl_stmt|;
block|{
name|LOCK_OWNED
argument_list|(
name|VFSTOUFS
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Blocking journal waits cause slow synchronous behavior.  Record 	 * stats on the frequency of these blocking operations. 	 */
if|if
condition|(
name|waitfor
operator|==
name|MNT_WAIT
condition|)
block|{
name|stat_journal_wait
operator|++
expr_stmt|;
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_JREMREF
case|:
case|case
name|D_JMVREF
case|:
name|stat_jwait_filepage
operator|++
expr_stmt|;
break|break;
case|case
name|D_JTRUNC
case|:
case|case
name|D_JFREEBLK
case|:
name|stat_jwait_freeblks
operator|++
expr_stmt|;
break|break;
case|case
name|D_JNEWBLK
case|:
name|stat_jwait_newblk
operator|++
expr_stmt|;
break|break;
case|case
name|D_JADDREF
case|:
name|stat_jwait_inode
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * If IO has not started we process the journal.  We can't mark the 	 * worklist item as IOWAITING because we drop the lock while 	 * processing the journal and the worklist entry may be freed after 	 * this point.  The caller may call back in and re-issue the request. 	 */
if|if
condition|(
operator|(
name|wk
operator|->
name|wk_state
operator|&
name|INPROGRESS
operator|)
operator|==
literal|0
condition|)
block|{
name|softdep_process_journal
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|,
name|wk
argument_list|,
name|waitfor
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitfor
operator|!=
name|MNT_WAIT
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|waitfor
operator|!=
name|MNT_WAIT
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|wait_worklist
argument_list|(
name|wk
argument_list|,
literal|"jwait"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup an inodedep based on an inode pointer and set the nlinkdelta as  * appropriate.  This is a convenience function to reduce duplicate code  * for the setup and revert functions below.  */
end_comment

begin_function
specifier|static
name|struct
name|inodedep
modifier|*
name|inodedep_lookup_ip
parameter_list|(
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|KASSERT
argument_list|(
name|ip
operator|->
name|i_nlink
operator|>=
name|ip
operator|->
name|i_effnlink
argument_list|,
operator|(
literal|"inodedep_lookup_ip: bad delta"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inodedep_lookup
argument_list|(
name|ITOVFS
argument_list|(
name|ip
argument_list|)
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_nlinkdelta
operator|=
name|ip
operator|->
name|i_nlink
operator|-
name|ip
operator|->
name|i_effnlink
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|UNLINKED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"inode unlinked"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|inodedep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called prior to creating a new inode and linking it to a directory.  The  * jaddref structure must already be allocated by softdep_setup_inomapdep  * and it is discovered here so we can initialize the mode and update  * nlinkdelta.  */
end_comment

begin_function
name|void
name|softdep_setup_create
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|ITOVFS
argument_list|(
name|dp
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_create called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ip
operator|->
name|i_nlink
operator|==
literal|1
argument_list|,
operator|(
literal|"softdep_setup_create: Invalid link count."
operator|)
argument_list|)
expr_stmt|;
name|dvp
operator|=
name|ITOV
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|inodedep
operator|=
name|inodedep_lookup_ip
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|DOINGSUJ
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
name|jaddref
operator|=
operator|(
expr|struct
name|jaddref
operator|*
operator|)
name|TAILQ_LAST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
name|inoreflst
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|jaddref
operator|!=
name|NULL
operator|&&
name|jaddref
operator|->
name|ja_parent
operator|==
name|dp
operator|->
name|i_number
argument_list|,
operator|(
literal|"softdep_setup_create: No addref structure present."
operator|)
argument_list|)
expr_stmt|;
block|}
name|softdep_prelink
argument_list|(
name|dvp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a jaddref structure to track the addition of a DOTDOT link when  * we are reparenting an inode as part of a rename.  This jaddref will be  * found by softdep_setup_directory_change.  Adjusts nlinkdelta for  * non-journaling softdep.  */
end_comment

begin_function
name|void
name|softdep_setup_dotdot_link
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|ITOVFS
argument_list|(
name|dp
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_dotdot_link called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|dvp
operator|=
name|ITOV
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|jaddref
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * We don't set MKDIR_PARENT as this is not tied to a mkdir and 	 * is used as a normal link would be. 	 */
if|if
condition|(
name|DOINGSUJ
argument_list|(
name|dvp
argument_list|)
condition|)
name|jaddref
operator|=
name|newjaddref
argument_list|(
name|ip
argument_list|,
name|dp
operator|->
name|i_number
argument_list|,
name|DOTDOT_OFFSET
argument_list|,
name|dp
operator|->
name|i_effnlink
operator|-
literal|1
argument_list|,
name|dp
operator|->
name|i_mode
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|inodedep
operator|=
name|inodedep_lookup_ip
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|jaddref
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
operator|&
name|jaddref
operator|->
name|ja_ref
argument_list|,
name|if_deps
argument_list|)
expr_stmt|;
name|softdep_prelink
argument_list|(
name|dvp
argument_list|,
name|ITOV
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a jaddref structure to track a new link to an inode.  The directory  * offset is not known until softdep_setup_directory_add or  * softdep_setup_directory_change.  Adjusts nlinkdelta for non-journaling  * softdep.  */
end_comment

begin_function
name|void
name|softdep_setup_link
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|ITOVFS
argument_list|(
name|dp
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_link called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|dvp
operator|=
name|ITOV
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|jaddref
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|DOINGSUJ
argument_list|(
name|dvp
argument_list|)
condition|)
name|jaddref
operator|=
name|newjaddref
argument_list|(
name|dp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
name|ip
operator|->
name|i_effnlink
operator|-
literal|1
argument_list|,
name|ip
operator|->
name|i_mode
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|inodedep
operator|=
name|inodedep_lookup_ip
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|jaddref
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
operator|&
name|jaddref
operator|->
name|ja_ref
argument_list|,
name|if_deps
argument_list|)
expr_stmt|;
name|softdep_prelink
argument_list|(
name|dvp
argument_list|,
name|ITOV
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called to create the jaddref structures to track . and .. references as  * well as lookup and further initialize the incomplete jaddref created  * by softdep_setup_inomapdep when the inode was allocated.  Adjusts  * nlinkdelta for non-journaling softdep.  */
end_comment

begin_function
name|void
name|softdep_setup_mkdir
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|dotdotaddref
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|dotaddref
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|ITOVFS
argument_list|(
name|dp
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_mkdir called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|dvp
operator|=
name|ITOV
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dotaddref
operator|=
name|dotdotaddref
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|DOINGSUJ
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
name|dotaddref
operator|=
name|newjaddref
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|DOT_OFFSET
argument_list|,
literal|1
argument_list|,
name|ip
operator|->
name|i_mode
argument_list|)
expr_stmt|;
name|dotaddref
operator|->
name|ja_state
operator||=
name|MKDIR_BODY
expr_stmt|;
name|dotdotaddref
operator|=
name|newjaddref
argument_list|(
name|ip
argument_list|,
name|dp
operator|->
name|i_number
argument_list|,
name|DOTDOT_OFFSET
argument_list|,
name|dp
operator|->
name|i_effnlink
operator|-
literal|1
argument_list|,
name|dp
operator|->
name|i_mode
argument_list|)
expr_stmt|;
name|dotdotaddref
operator|->
name|ja_state
operator||=
name|MKDIR_PARENT
expr_stmt|;
block|}
name|ACQUIRE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|inodedep
operator|=
name|inodedep_lookup_ip
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|DOINGSUJ
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
name|jaddref
operator|=
operator|(
expr|struct
name|jaddref
operator|*
operator|)
name|TAILQ_LAST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
name|inoreflst
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|jaddref
operator|!=
name|NULL
argument_list|,
operator|(
literal|"softdep_setup_mkdir: No addref structure present."
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|jaddref
operator|->
name|ja_parent
operator|==
name|dp
operator|->
name|i_number
argument_list|,
operator|(
literal|"softdep_setup_mkdir: bad parent %ju"
operator|,
operator|(
name|uintmax_t
operator|)
name|jaddref
operator|->
name|ja_parent
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_ref
argument_list|,
operator|&
name|dotaddref
operator|->
name|ja_ref
argument_list|,
name|if_deps
argument_list|)
expr_stmt|;
block|}
name|inodedep
operator|=
name|inodedep_lookup_ip
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|DOINGSUJ
argument_list|(
name|dvp
argument_list|)
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
operator|&
name|dotdotaddref
operator|->
name|ja_ref
argument_list|,
name|if_deps
argument_list|)
expr_stmt|;
name|softdep_prelink
argument_list|(
name|ITOV
argument_list|(
name|dp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called to track nlinkdelta of the inode and parent directories prior to  * unlinking a directory.  */
end_comment

begin_function
name|void
name|softdep_setup_rmdir
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|ITOVFS
argument_list|(
name|dp
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_rmdir called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|dvp
operator|=
name|ITOV
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inodedep_lookup_ip
argument_list|(
name|ip
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inodedep_lookup_ip
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|softdep_prelink
argument_list|(
name|dvp
argument_list|,
name|ITOV
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called to track nlinkdelta of the inode and parent directories prior to  * unlink.  */
end_comment

begin_function
name|void
name|softdep_setup_unlink
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|ITOVFS
argument_list|(
name|dp
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_unlink called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|dvp
operator|=
name|ITOV
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inodedep_lookup_ip
argument_list|(
name|ip
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inodedep_lookup_ip
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|softdep_prelink
argument_list|(
name|dvp
argument_list|,
name|ITOV
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called to release the journal structures created by a failed non-directory  * creation.  Adjusts nlinkdelta for non-journaling softdep.  */
end_comment

begin_function
name|void
name|softdep_revert_create
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|ITOVFS
argument_list|(
operator|(
name|dp
operator|)
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_revert_create called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|dvp
operator|=
name|ITOV
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|inodedep
operator|=
name|inodedep_lookup_ip
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|DOINGSUJ
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
name|jaddref
operator|=
operator|(
expr|struct
name|jaddref
operator|*
operator|)
name|TAILQ_LAST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
name|inoreflst
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|jaddref
operator|->
name|ja_parent
operator|==
name|dp
operator|->
name|i_number
argument_list|,
operator|(
literal|"softdep_revert_create: addref parent mismatch"
operator|)
argument_list|)
expr_stmt|;
name|cancel_jaddref
argument_list|(
name|jaddref
argument_list|,
name|inodedep
argument_list|,
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called to release the journal structures created by a failed link  * addition.  Adjusts nlinkdelta for non-journaling softdep.  */
end_comment

begin_function
name|void
name|softdep_revert_link
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|ITOVFS
argument_list|(
name|dp
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_revert_link called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|dvp
operator|=
name|ITOV
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|inodedep
operator|=
name|inodedep_lookup_ip
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|DOINGSUJ
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
name|jaddref
operator|=
operator|(
expr|struct
name|jaddref
operator|*
operator|)
name|TAILQ_LAST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
name|inoreflst
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|jaddref
operator|->
name|ja_parent
operator|==
name|dp
operator|->
name|i_number
argument_list|,
operator|(
literal|"softdep_revert_link: addref parent mismatch"
operator|)
argument_list|)
expr_stmt|;
name|cancel_jaddref
argument_list|(
name|jaddref
argument_list|,
name|inodedep
argument_list|,
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called to release the journal structures created by a failed mkdir  * attempt.  Adjusts nlinkdelta for non-journaling softdep.  */
end_comment

begin_function
name|void
name|softdep_revert_mkdir
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|dotaddref
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|ITOVFS
argument_list|(
name|dp
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_revert_mkdir called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|dvp
operator|=
name|ITOV
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|inodedep
operator|=
name|inodedep_lookup_ip
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|DOINGSUJ
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
name|jaddref
operator|=
operator|(
expr|struct
name|jaddref
operator|*
operator|)
name|TAILQ_LAST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
name|inoreflst
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|jaddref
operator|->
name|ja_parent
operator|==
name|ip
operator|->
name|i_number
argument_list|,
operator|(
literal|"softdep_revert_mkdir: dotdot addref parent mismatch"
operator|)
argument_list|)
expr_stmt|;
name|cancel_jaddref
argument_list|(
name|jaddref
argument_list|,
name|inodedep
argument_list|,
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
expr_stmt|;
block|}
name|inodedep
operator|=
name|inodedep_lookup_ip
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|DOINGSUJ
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
name|jaddref
operator|=
operator|(
expr|struct
name|jaddref
operator|*
operator|)
name|TAILQ_LAST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
name|inoreflst
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|jaddref
operator|->
name|ja_parent
operator|==
name|dp
operator|->
name|i_number
argument_list|,
operator|(
literal|"softdep_revert_mkdir: addref parent mismatch"
operator|)
argument_list|)
expr_stmt|;
name|dotaddref
operator|=
operator|(
expr|struct
name|jaddref
operator|*
operator|)
name|TAILQ_PREV
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_ref
argument_list|,
name|inoreflst
argument_list|,
name|if_deps
argument_list|)
expr_stmt|;
name|cancel_jaddref
argument_list|(
name|jaddref
argument_list|,
name|inodedep
argument_list|,
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|dotaddref
operator|->
name|ja_parent
operator|==
name|ip
operator|->
name|i_number
argument_list|,
operator|(
literal|"softdep_revert_mkdir: dot addref parent mismatch"
operator|)
argument_list|)
expr_stmt|;
name|cancel_jaddref
argument_list|(
name|dotaddref
argument_list|,
name|inodedep
argument_list|,
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Called to correct nlinkdelta after a failed rmdir.  */
end_comment

begin_function
name|void
name|softdep_revert_rmdir
parameter_list|(
name|dp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|ITOVFS
argument_list|(
name|dp
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_revert_rmdir called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inodedep_lookup_ip
argument_list|(
name|ip
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inodedep_lookup_ip
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Protecting the freemaps (or bitmaps).  *   * To eliminate the need to execute fsck before mounting a filesystem  * after a power failure, one must (conservatively) guarantee that the  * on-disk copy of the bitmaps never indicate that a live inode or block is  * free.  So, when a block or inode is allocated, the bitmap should be  * updated (on disk) before any new pointers.  When a block or inode is  * freed, the bitmap should not be updated until all pointers have been  * reset.  The latter dependency is handled by the delayed de-allocation  * approach described below for block and inode de-allocation.  The former  * dependency is handled by calling the following procedure when a block or  * inode is allocated. When an inode is allocated an "inodedep" is created  * with its DEPCOMPLETE flag cleared until its bitmap is written to disk.  * Each "inodedep" is also inserted into the hash indexing structure so  * that any additional link additions can be made dependent on the inode  * allocation.  *   * The ufs filesystem maintains a number of free block counts (e.g., per  * cylinder group, per cylinder and per<cylinder, rotational position> pair)  * in addition to the bitmaps.  These counts are used to improve efficiency  * during allocation and therefore must be consistent with the bitmaps.  * There is no convenient way to guarantee post-crash consistency of these  * counts with simple update ordering, for two main reasons: (1) The counts  * and bitmaps for a single cylinder group block are not in the same disk  * sector.  If a disk write is interrupted (e.g., by power failure), one may  * be written and the other not.  (2) Some of the counts are located in the  * superblock rather than the cylinder group block. So, we focus our soft  * updates implementation on protecting the bitmaps. When mounting a  * filesystem, we recompute the auxiliary counts from the bitmaps.  */
end_comment

begin_comment
comment|/*  * Called just after updating the cylinder group block to allocate an inode.  */
end_comment

begin_function
name|void
name|softdep_setup_inomapdep
parameter_list|(
name|bp
parameter_list|,
name|ip
parameter_list|,
name|newinum
parameter_list|,
name|mode
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer for cylgroup block with inode map */
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode related to allocation */
name|ino_t
name|newinum
decl_stmt|;
comment|/* new inode number being allocated */
name|int
name|mode
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|mp
operator|=
name|ITOVFS
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_inomapdep called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_fs
expr_stmt|;
name|jaddref
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Allocate the journal reference add structure so that the bitmap 	 * can be dependent on it. 	 */
if|if
condition|(
name|MOUNTEDSUJ
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|jaddref
operator|=
name|newjaddref
argument_list|(
name|ip
argument_list|,
name|newinum
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|jaddref
operator|->
name|ja_state
operator||=
name|NEWBLOCK
expr_stmt|;
block|}
comment|/* 	 * Create a dependency for the newly allocated inode. 	 * Panic if it already exists as something is seriously wrong. 	 * Otherwise add it to the dependency list for the buffer holding 	 * the cylinder group map from which it was allocated. 	 * 	 * We have to preallocate a bmsafemap entry in case it is needed 	 * in bmsafemap_lookup since once we allocate the inodedep, we 	 * have to finish initializing it before we can FREE_LOCK(). 	 * By preallocating, we avoid FREE_LOCK() while doing a malloc 	 * in bmsafemap_lookup. We cannot call bmsafemap_lookup before 	 * creating the inodedep as it can be freed during the time 	 * that we FREE_LOCK() while allocating the inodedep. We must 	 * call workitem_alloc() before entering the locked section as 	 * it also acquires the lock and we must avoid trying doing so 	 * recursively. 	 */
name|bmsafemap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bmsafemap
argument_list|)
argument_list|,
name|M_BMSAFEMAP
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_list
argument_list|,
name|D_BMSAFEMAP
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|newinum
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|)
condition|)
name|panic
argument_list|(
literal|"softdep_setup_inomapdep: dependency %p for new"
literal|"inode already exists"
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
name|bmsafemap
operator|=
name|bmsafemap_lookup
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|,
name|ino_to_cg
argument_list|(
name|fs
argument_list|,
name|newinum
argument_list|)
argument_list|,
name|bmsafemap
argument_list|)
expr_stmt|;
if|if
condition|(
name|jaddref
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_jaddrefhd
argument_list|,
name|jaddref
argument_list|,
name|ja_bmdeps
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
operator|&
name|jaddref
operator|->
name|ja_ref
argument_list|,
name|if_deps
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inodedep
operator|->
name|id_state
operator||=
name|ONDEPLIST
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_inodedephd
argument_list|,
name|inodedep
argument_list|,
name|id_deps
argument_list|)
expr_stmt|;
block|}
name|inodedep
operator|->
name|id_bmsafemap
operator|=
name|bmsafemap
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator|&=
operator|~
name|DEPCOMPLETE
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called just after updating the cylinder group block to  * allocate block or fragment.  */
end_comment

begin_function
name|void
name|softdep_setup_blkmapdep
parameter_list|(
name|bp
parameter_list|,
name|mp
parameter_list|,
name|newblkno
parameter_list|,
name|frags
parameter_list|,
name|oldfrags
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer for cylgroup block with block map */
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem doing allocation */
name|ufs2_daddr_t
name|newblkno
decl_stmt|;
comment|/* number of newly allocated block */
name|int
name|frags
decl_stmt|;
comment|/* Number of fragments. */
name|int
name|oldfrags
decl_stmt|;
comment|/* Previous number of fragments for extend. */
block|{
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_blkmapdep called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
name|jnewblk
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Create a dependency for the newly allocated block. 	 * Add it to the dependency list for the buffer holding 	 * the cylinder group map from which it was allocated. 	 */
if|if
condition|(
name|MOUNTEDSUJ
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|jnewblk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|jnewblk
argument_list|)
argument_list|,
name|M_JNEWBLK
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|jnewblk
operator|->
name|jn_list
argument_list|,
name|D_JNEWBLK
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|jnewblk
operator|->
name|jn_jsegdep
operator|=
name|newjsegdep
argument_list|(
operator|&
name|jnewblk
operator|->
name|jn_list
argument_list|)
expr_stmt|;
name|jnewblk
operator|->
name|jn_state
operator|=
name|ATTACHED
expr_stmt|;
name|jnewblk
operator|->
name|jn_blkno
operator|=
name|newblkno
expr_stmt|;
name|jnewblk
operator|->
name|jn_frags
operator|=
name|frags
expr_stmt|;
name|jnewblk
operator|->
name|jn_oldfrags
operator|=
name|oldfrags
expr_stmt|;
ifdef|#
directive|ifdef
name|SUJ_DEBUG
block|{
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|uint8_t
modifier|*
name|blksfree
decl_stmt|;
name|long
name|bno
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cgp
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|blksfree
operator|=
name|cg_blksfree
argument_list|(
name|cgp
argument_list|)
expr_stmt|;
name|bno
operator|=
name|dtogd
argument_list|(
name|fs
argument_list|,
name|jnewblk
operator|->
name|jn_blkno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|jnewblk
operator|->
name|jn_oldfrags
init|;
name|i
operator|<
name|jnewblk
operator|->
name|jn_frags
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isset
argument_list|(
name|blksfree
argument_list|,
name|bno
operator|+
name|i
argument_list|)
condition|)
name|panic
argument_list|(
literal|"softdep_setup_blkmapdep: "
literal|"free fragment %d from %d-%d "
literal|"state 0x%X dep %p"
argument_list|,
name|i
argument_list|,
name|jnewblk
operator|->
name|jn_oldfrags
argument_list|,
name|jnewblk
operator|->
name|jn_frags
argument_list|,
name|jnewblk
operator|->
name|jn_state
argument_list|,
name|jnewblk
operator|->
name|jn_dep
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
name|CTR3
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"softdep_setup_blkmapdep: blkno %jd frags %d oldfrags %d"
argument_list|,
name|newblkno
argument_list|,
name|frags
argument_list|,
name|oldfrags
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|newblk_lookup
argument_list|(
name|mp
argument_list|,
name|newblkno
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|newblk
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_setup_blkmapdep: found block"
argument_list|)
expr_stmt|;
name|newblk
operator|->
name|nb_bmsafemap
operator|=
name|bmsafemap
operator|=
name|bmsafemap_lookup
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|,
name|dtog
argument_list|(
name|fs
argument_list|,
name|newblkno
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|jnewblk
condition|)
block|{
name|jnewblk
operator|->
name|jn_dep
operator|=
operator|(
expr|struct
name|worklist
operator|*
operator|)
name|newblk
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_jnewblkhd
argument_list|,
name|jnewblk
argument_list|,
name|jn_deps
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newblk
operator|->
name|nb_state
operator||=
name|ONDEPLIST
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_newblkhd
argument_list|,
name|newblk
argument_list|,
name|nb_deps
argument_list|)
expr_stmt|;
block|}
name|newblk
operator|->
name|nb_bmsafemap
operator|=
name|bmsafemap
expr_stmt|;
name|newblk
operator|->
name|nb_jnewblk
operator|=
name|jnewblk
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|BMSAFEMAP_HASH
parameter_list|(
name|ump
parameter_list|,
name|cg
parameter_list|)
define|\
value|(&(ump)->bmsafemap_hashtbl[(cg)& (ump)->bmsafemap_hash_size])
end_define

begin_function
specifier|static
name|int
name|bmsafemap_find
parameter_list|(
name|bmsafemaphd
parameter_list|,
name|cg
parameter_list|,
name|bmsafemapp
parameter_list|)
name|struct
name|bmsafemap_hashhead
modifier|*
name|bmsafemaphd
decl_stmt|;
name|int
name|cg
decl_stmt|;
name|struct
name|bmsafemap
modifier|*
modifier|*
name|bmsafemapp
decl_stmt|;
block|{
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bmsafemap
argument_list|,
argument|bmsafemaphd
argument_list|,
argument|sm_hash
argument_list|)
if|if
condition|(
name|bmsafemap
operator|->
name|sm_cg
operator|==
name|cg
condition|)
break|break;
if|if
condition|(
name|bmsafemap
condition|)
block|{
operator|*
name|bmsafemapp
operator|=
name|bmsafemap
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|bmsafemapp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the bmsafemap associated with a cylinder group buffer.  * If none exists, create one. The buffer must be locked when  * this routine is called and this routine must be called with  * the softdep lock held. To avoid giving up the lock while  * allocating a new bmsafemap, a preallocated bmsafemap may be  * provided. If it is provided but not needed, it is freed.  */
end_comment

begin_function
specifier|static
name|struct
name|bmsafemap
modifier|*
name|bmsafemap_lookup
parameter_list|(
name|mp
parameter_list|,
name|bp
parameter_list|,
name|cg
parameter_list|,
name|newbmsafemap
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|cg
decl_stmt|;
name|struct
name|bmsafemap
modifier|*
name|newbmsafemap
decl_stmt|;
block|{
name|struct
name|bmsafemap_hashhead
modifier|*
name|bmsafemaphd
decl_stmt|;
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|,
modifier|*
name|collision
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"bmsafemap_lookup: missing buffer"
operator|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&bp->b_dep
argument_list|,
argument|wk_list
argument_list|)
block|{
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|==
name|D_BMSAFEMAP
condition|)
block|{
if|if
condition|(
name|newbmsafemap
condition|)
name|WORKITEM_FREE
argument_list|(
name|newbmsafemap
argument_list|,
name|D_BMSAFEMAP
argument_list|)
expr_stmt|;
return|return
operator|(
name|WK_BMSAFEMAP
argument_list|(
name|wk
argument_list|)
operator|)
return|;
block|}
block|}
name|bmsafemaphd
operator|=
name|BMSAFEMAP_HASH
argument_list|(
name|ump
argument_list|,
name|cg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmsafemap_find
argument_list|(
name|bmsafemaphd
argument_list|,
name|cg
argument_list|,
operator|&
name|bmsafemap
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|newbmsafemap
condition|)
name|WORKITEM_FREE
argument_list|(
name|newbmsafemap
argument_list|,
name|D_BMSAFEMAP
argument_list|)
expr_stmt|;
return|return
operator|(
name|bmsafemap
operator|)
return|;
block|}
if|if
condition|(
name|newbmsafemap
condition|)
block|{
name|bmsafemap
operator|=
name|newbmsafemap
expr_stmt|;
block|}
else|else
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|bmsafemap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bmsafemap
argument_list|)
argument_list|,
name|M_BMSAFEMAP
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_list
argument_list|,
name|D_BMSAFEMAP
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
name|bmsafemap
operator|->
name|sm_buf
operator|=
name|bp
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_inodedephd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_inodedepwr
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_newblkhd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_newblkwr
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_jaddrefhd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_jnewblkhd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_freehd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_freewr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmsafemap_find
argument_list|(
name|bmsafemaphd
argument_list|,
name|cg
argument_list|,
operator|&
name|collision
argument_list|)
operator|==
literal|1
condition|)
block|{
name|WORKITEM_FREE
argument_list|(
name|bmsafemap
argument_list|,
name|D_BMSAFEMAP
argument_list|)
expr_stmt|;
return|return
operator|(
name|collision
operator|)
return|;
block|}
name|bmsafemap
operator|->
name|sm_cg
operator|=
name|cg
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|bmsafemaphd
argument_list|,
name|bmsafemap
argument_list|,
name|sm_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ump
operator|->
name|softdep_dirtycg
argument_list|,
name|bmsafemap
argument_list|,
name|sm_next
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|bmsafemap
operator|->
name|sm_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|bmsafemap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Direct block allocation dependencies.  *   * When a new block is allocated, the corresponding disk locations must be  * initialized (with zeros or new data) before the on-disk inode points to  * them.  Also, the freemap from which the block was allocated must be  * updated (on disk) before the inode's pointer. These two dependencies are  * independent of each other and are needed for all file blocks and indirect  * blocks that are pointed to directly by the inode.  Just before the  * "in-core" version of the inode is updated with a newly allocated block  * number, a procedure (below) is called to setup allocation dependency  * structures.  These structures are removed when the corresponding  * dependencies are satisfied or when the block allocation becomes obsolete  * (i.e., the file is deleted, the block is de-allocated, or the block is a  * fragment that gets upgraded).  All of these cases are handled in  * procedures described later.  *   * When a file extension causes a fragment to be upgraded, either to a larger  * fragment or to a full block, the on-disk location may change (if the  * previous fragment could not simply be extended). In this case, the old  * fragment must be de-allocated, but not until after the inode's pointer has  * been updated. In most cases, this is handled by later procedures, which  * will construct a "freefrag" structure to be added to the workitem queue  * when the inode update is complete (or obsolete).  The main exception to  * this is when an allocation occurs while a pending allocation dependency  * (for the same block pointer) remains.  This case is handled in the main  * allocation dependency setup procedure by immediately freeing the  * unreferenced fragments.  */
end_comment

begin_function
name|void
name|softdep_setup_allocdirect
parameter_list|(
name|ip
parameter_list|,
name|off
parameter_list|,
name|newblkno
parameter_list|,
name|oldblkno
parameter_list|,
name|newsize
parameter_list|,
name|oldsize
parameter_list|,
name|bp
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode to which block is being added */
name|ufs_lbn_t
name|off
decl_stmt|;
comment|/* block pointer within inode */
name|ufs2_daddr_t
name|newblkno
decl_stmt|;
comment|/* disk block number being added */
name|ufs2_daddr_t
name|oldblkno
decl_stmt|;
comment|/* previous block number, 0 unless frag */
name|long
name|newsize
decl_stmt|;
comment|/* size of new block */
name|long
name|oldsize
decl_stmt|;
comment|/* size of new block */
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* bp for allocated block */
block|{
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|,
modifier|*
name|oldadp
decl_stmt|;
name|struct
name|allocdirectlst
modifier|*
name|adphead
decl_stmt|;
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|lbn
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
name|mp
operator|=
name|ITOVFS
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_allocdirect called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldblkno
operator|&&
name|oldblkno
operator|!=
name|newblkno
condition|)
name|freefrag
operator|=
name|newfreefrag
argument_list|(
name|ip
argument_list|,
name|oldblkno
argument_list|,
name|oldsize
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
else|else
name|freefrag
operator|=
name|NULL
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"softdep_setup_allocdirect: ino %d blkno %jd oldblkno %jd "
literal|"off %jd newsize %ld oldsize %d"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|newblkno
argument_list|,
name|oldblkno
argument_list|,
name|off
argument_list|,
name|newsize
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|UFS_NDADDR
condition|)
block|{
if|if
condition|(
name|lbn
operator|>
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_setup_allocdirect: bad lbn %jd, off %jd"
argument_list|,
name|lbn
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* allocating an indirect block */
if|if
condition|(
name|oldblkno
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_setup_allocdirect: non-zero indir"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|off
operator|!=
name|lbn
condition|)
name|panic
argument_list|(
literal|"softdep_setup_allocdirect: lbn %jd != off %jd"
argument_list|,
name|lbn
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* 		 * Allocating a direct block. 		 * 		 * If we are allocating a directory block, then we must 		 * allocate an associated pagedep to track additions and 		 * deletions. 		 */
if|if
condition|(
operator|(
name|ip
operator|->
name|i_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
condition|)
name|pagedep_lookup
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|off
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|pagedep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newblk_lookup
argument_list|(
name|mp
argument_list|,
name|newblkno
argument_list|,
literal|0
argument_list|,
operator|&
name|newblk
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_setup_allocdirect: lost block"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|newblk
operator|->
name|nb_list
operator|.
name|wk_type
operator|==
name|D_NEWBLK
argument_list|,
operator|(
literal|"softdep_setup_allocdirect: newblk already initialized"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Convert the newblk to an allocdirect. 	 */
name|WORKITEM_REASSIGN
argument_list|(
name|newblk
argument_list|,
name|D_ALLOCDIRECT
argument_list|)
expr_stmt|;
name|adp
operator|=
operator|(
expr|struct
name|allocdirect
operator|*
operator|)
name|newblk
expr_stmt|;
name|newblk
operator|->
name|nb_freefrag
operator|=
name|freefrag
expr_stmt|;
name|adp
operator|->
name|ad_offset
operator|=
name|off
expr_stmt|;
name|adp
operator|->
name|ad_oldblkno
operator|=
name|oldblkno
expr_stmt|;
name|adp
operator|->
name|ad_newsize
operator|=
name|newsize
expr_stmt|;
name|adp
operator|->
name|ad_oldsize
operator|=
name|oldsize
expr_stmt|;
comment|/* 	 * Finish initializing the journal. 	 */
if|if
condition|(
operator|(
name|jnewblk
operator|=
name|newblk
operator|->
name|nb_jnewblk
operator|)
operator|!=
name|NULL
condition|)
block|{
name|jnewblk
operator|->
name|jn_ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|jnewblk
operator|->
name|jn_lbn
operator|=
name|lbn
expr_stmt|;
name|add_to_journal
argument_list|(
operator|&
name|jnewblk
operator|->
name|jn_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freefrag
operator|&&
name|freefrag
operator|->
name|ff_jdep
operator|!=
name|NULL
operator|&&
name|freefrag
operator|->
name|ff_jdep
operator|->
name|wk_type
operator|==
name|D_JFREEFRAG
condition|)
name|add_to_journal
argument_list|(
name|freefrag
operator|->
name|ff_jdep
argument_list|)
expr_stmt|;
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
name|adp
operator|->
name|ad_inodedep
operator|=
name|inodedep
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|newblk
operator|->
name|nb_list
argument_list|)
expr_stmt|;
comment|/* 	 * The list of allocdirects must be kept in sorted and ascending 	 * order so that the rollback routines can quickly determine the 	 * first uncommitted block (the size of the file stored on disk 	 * ends at the end of the lowest committed fragment, or if there 	 * are no fragments, at the end of the highest committed block). 	 * Since files generally grow, the typical case is that the new 	 * block is to be added at the end of the list. We speed this 	 * special case by checking against the last allocdirect in the 	 * list before laboriously traversing the list looking for the 	 * insertion point. 	 */
name|adphead
operator|=
operator|&
name|inodedep
operator|->
name|id_newinoupdt
expr_stmt|;
name|oldadp
operator|=
name|TAILQ_LAST
argument_list|(
name|adphead
argument_list|,
name|allocdirectlst
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldadp
operator|==
name|NULL
operator|||
name|oldadp
operator|->
name|ad_offset
operator|<=
name|off
condition|)
block|{
comment|/* insert at end of list */
name|TAILQ_INSERT_TAIL
argument_list|(
name|adphead
argument_list|,
name|adp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldadp
operator|!=
name|NULL
operator|&&
name|oldadp
operator|->
name|ad_offset
operator|==
name|off
condition|)
name|allocdirect_merge
argument_list|(
name|adphead
argument_list|,
name|adp
argument_list|,
name|oldadp
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|oldadp
argument_list|,
argument|adphead
argument_list|,
argument|ad_next
argument_list|)
block|{
if|if
condition|(
name|oldadp
operator|->
name|ad_offset
operator|>=
name|off
condition|)
break|break;
block|}
if|if
condition|(
name|oldadp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"softdep_setup_allocdirect: lost entry"
argument_list|)
expr_stmt|;
comment|/* insert in middle of list */
name|TAILQ_INSERT_BEFORE
argument_list|(
name|oldadp
argument_list|,
name|adp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldadp
operator|->
name|ad_offset
operator|==
name|off
condition|)
name|allocdirect_merge
argument_list|(
name|adphead
argument_list|,
name|adp
argument_list|,
name|oldadp
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Merge a newer and older journal record to be stored either in a  * newblock or freefrag.  This handles aggregating journal records for  * fragment allocation into a second record as well as replacing a  * journal free with an aborted journal allocation.  A segment for the  * oldest record will be placed on wkhd if it has been written.  If not  * the segment for the newer record will suffice.  */
end_comment

begin_function
specifier|static
name|struct
name|worklist
modifier|*
name|jnewblk_merge
parameter_list|(
name|new
parameter_list|,
name|old
parameter_list|,
name|wkhd
parameter_list|)
name|struct
name|worklist
modifier|*
name|new
decl_stmt|;
name|struct
name|worklist
modifier|*
name|old
decl_stmt|;
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|struct
name|jnewblk
modifier|*
name|njnewblk
decl_stmt|;
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|;
comment|/* Handle NULLs to simplify callers. */
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return
operator|(
name|old
operator|)
return|;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
return|return
operator|(
name|new
operator|)
return|;
comment|/* Replace a jfreefrag with a jnewblk. */
if|if
condition|(
name|new
operator|->
name|wk_type
operator|==
name|D_JFREEFRAG
condition|)
block|{
if|if
condition|(
name|WK_JNEWBLK
argument_list|(
name|old
argument_list|)
operator|->
name|jn_blkno
operator|!=
name|WK_JFREEFRAG
argument_list|(
name|new
argument_list|)
operator|->
name|fr_blkno
condition|)
name|panic
argument_list|(
literal|"jnewblk_merge: blkno mismatch: %p, %p"
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|cancel_jfreefrag
argument_list|(
name|WK_JFREEFRAG
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
if|if
condition|(
name|old
operator|->
name|wk_type
operator|!=
name|D_JNEWBLK
operator|||
name|new
operator|->
name|wk_type
operator|!=
name|D_JNEWBLK
condition|)
name|panic
argument_list|(
literal|"jnewblk_merge: Bad type: old %d new %d\n"
argument_list|,
name|old
operator|->
name|wk_type
argument_list|,
name|new
operator|->
name|wk_type
argument_list|)
expr_stmt|;
comment|/* 	 * Handle merging of two jnewblk records that describe 	 * different sets of fragments in the same block. 	 */
name|jnewblk
operator|=
name|WK_JNEWBLK
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|njnewblk
operator|=
name|WK_JNEWBLK
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|jnewblk
operator|->
name|jn_blkno
operator|!=
name|njnewblk
operator|->
name|jn_blkno
condition|)
name|panic
argument_list|(
literal|"jnewblk_merge: Merging disparate blocks."
argument_list|)
expr_stmt|;
comment|/* 	 * The record may be rolled back in the cg. 	 */
if|if
condition|(
name|jnewblk
operator|->
name|jn_state
operator|&
name|UNDONE
condition|)
block|{
name|jnewblk
operator|->
name|jn_state
operator|&=
operator|~
name|UNDONE
expr_stmt|;
name|njnewblk
operator|->
name|jn_state
operator||=
name|UNDONE
expr_stmt|;
name|njnewblk
operator|->
name|jn_state
operator|&=
operator|~
name|ATTACHED
expr_stmt|;
block|}
comment|/* 	 * We modify the newer addref and free the older so that if neither 	 * has been written the most up-to-date copy will be on disk.  If 	 * both have been written but rolled back we only temporarily need 	 * one of them to fix the bits when the cg write completes. 	 */
name|jnewblk
operator|->
name|jn_state
operator||=
name|ATTACHED
operator||
name|COMPLETE
expr_stmt|;
name|njnewblk
operator|->
name|jn_oldfrags
operator|=
name|jnewblk
operator|->
name|jn_oldfrags
expr_stmt|;
name|cancel_jnewblk
argument_list|(
name|jnewblk
argument_list|,
name|wkhd
argument_list|)
expr_stmt|;
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|jnewblk
operator|->
name|jn_list
argument_list|)
expr_stmt|;
name|free_jnewblk
argument_list|(
name|jnewblk
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Replace an old allocdirect dependency with a newer one.  * This routine must be called with splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|void
name|allocdirect_merge
parameter_list|(
name|adphead
parameter_list|,
name|newadp
parameter_list|,
name|oldadp
parameter_list|)
name|struct
name|allocdirectlst
modifier|*
name|adphead
decl_stmt|;
comment|/* head of list holding allocdirects */
name|struct
name|allocdirect
modifier|*
name|newadp
decl_stmt|;
comment|/* allocdirect being added */
name|struct
name|allocdirect
modifier|*
name|oldadp
decl_stmt|;
comment|/* existing allocdirect being checked */
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
name|freefrag
operator|=
name|NULL
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|VFSTOUFS
argument_list|(
name|newadp
operator|->
name|ad_list
operator|.
name|wk_mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newadp
operator|->
name|ad_oldblkno
operator|!=
name|oldadp
operator|->
name|ad_newblkno
operator|||
name|newadp
operator|->
name|ad_oldsize
operator|!=
name|oldadp
operator|->
name|ad_newsize
operator|||
name|newadp
operator|->
name|ad_offset
operator|>=
name|UFS_NDADDR
condition|)
name|panic
argument_list|(
literal|"%s %jd != new %jd || old size %ld != new %ld"
argument_list|,
literal|"allocdirect_merge: old blkno"
argument_list|,
operator|(
name|intmax_t
operator|)
name|newadp
operator|->
name|ad_oldblkno
argument_list|,
operator|(
name|intmax_t
operator|)
name|oldadp
operator|->
name|ad_newblkno
argument_list|,
name|newadp
operator|->
name|ad_oldsize
argument_list|,
name|oldadp
operator|->
name|ad_newsize
argument_list|)
expr_stmt|;
name|newadp
operator|->
name|ad_oldblkno
operator|=
name|oldadp
operator|->
name|ad_oldblkno
expr_stmt|;
name|newadp
operator|->
name|ad_oldsize
operator|=
name|oldadp
operator|->
name|ad_oldsize
expr_stmt|;
comment|/* 	 * If the old dependency had a fragment to free or had never 	 * previously had a block allocated, then the new dependency 	 * can immediately post its freefrag and adopt the old freefrag. 	 * This action is done by swapping the freefrag dependencies. 	 * The new dependency gains the old one's freefrag, and the 	 * old one gets the new one and then immediately puts it on 	 * the worklist when it is freed by free_newblk. It is 	 * not possible to do this swap when the old dependency had a 	 * non-zero size but no previous fragment to free. This condition 	 * arises when the new block is an extension of the old block. 	 * Here, the first part of the fragment allocated to the new 	 * dependency is part of the block currently claimed on disk by 	 * the old dependency, so cannot legitimately be freed until the 	 * conditions for the new dependency are fulfilled. 	 */
name|freefrag
operator|=
name|newadp
operator|->
name|ad_freefrag
expr_stmt|;
if|if
condition|(
name|oldadp
operator|->
name|ad_freefrag
operator|!=
name|NULL
operator|||
name|oldadp
operator|->
name|ad_oldblkno
operator|==
literal|0
condition|)
block|{
name|newadp
operator|->
name|ad_freefrag
operator|=
name|oldadp
operator|->
name|ad_freefrag
expr_stmt|;
name|oldadp
operator|->
name|ad_freefrag
operator|=
name|freefrag
expr_stmt|;
block|}
comment|/* 	 * If we are tracking a new directory-block allocation, 	 * move it from the old allocdirect to the new allocdirect. 	 */
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|oldadp
operator|->
name|ad_newdirblk
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|oldadp
operator|->
name|ad_newdirblk
argument_list|)
condition|)
name|panic
argument_list|(
literal|"allocdirect_merge: extra newdirblk"
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|newadp
operator|->
name|ad_newdirblk
argument_list|,
name|wk
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
name|adphead
argument_list|,
name|oldadp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
comment|/* 	 * We need to move any journal dependencies over to the freefrag 	 * that releases this block if it exists.  Otherwise we are 	 * extending an existing block and we'll wait until that is 	 * complete to release the journal space and extend the 	 * new journal to cover this old space as well. 	 */
if|if
condition|(
name|freefrag
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|oldadp
operator|->
name|ad_newblkno
operator|!=
name|newadp
operator|->
name|ad_newblkno
condition|)
name|panic
argument_list|(
literal|"allocdirect_merge: %jd != %jd"
argument_list|,
name|oldadp
operator|->
name|ad_newblkno
argument_list|,
name|newadp
operator|->
name|ad_newblkno
argument_list|)
expr_stmt|;
name|newadp
operator|->
name|ad_block
operator|.
name|nb_jnewblk
operator|=
operator|(
expr|struct
name|jnewblk
operator|*
operator|)
name|jnewblk_merge
argument_list|(
operator|&
name|newadp
operator|->
name|ad_block
operator|.
name|nb_jnewblk
operator|->
name|jn_list
argument_list|,
operator|&
name|oldadp
operator|->
name|ad_block
operator|.
name|nb_jnewblk
operator|->
name|jn_list
argument_list|,
operator|&
name|newadp
operator|->
name|ad_block
operator|.
name|nb_jwork
argument_list|)
expr_stmt|;
name|oldadp
operator|->
name|ad_block
operator|.
name|nb_jnewblk
operator|=
name|NULL
expr_stmt|;
name|cancel_newblk
argument_list|(
operator|&
name|oldadp
operator|->
name|ad_block
argument_list|,
name|NULL
argument_list|,
operator|&
name|newadp
operator|->
name|ad_block
operator|.
name|nb_jwork
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wk
operator|=
operator|(
expr|struct
name|worklist
operator|*
operator|)
name|cancel_newblk
argument_list|(
operator|&
name|oldadp
operator|->
name|ad_block
argument_list|,
operator|&
name|freefrag
operator|->
name|ff_list
argument_list|,
operator|&
name|freefrag
operator|->
name|ff_jwork
argument_list|)
expr_stmt|;
name|freefrag
operator|->
name|ff_jdep
operator|=
name|jnewblk_merge
argument_list|(
name|freefrag
operator|->
name|ff_jdep
argument_list|,
name|wk
argument_list|,
operator|&
name|freefrag
operator|->
name|ff_jwork
argument_list|)
expr_stmt|;
block|}
name|free_newblk
argument_list|(
operator|&
name|oldadp
operator|->
name|ad_block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a jfreefrag structure to journal a single block free.  */
end_comment

begin_function
specifier|static
name|struct
name|jfreefrag
modifier|*
name|newjfreefrag
parameter_list|(
name|freefrag
parameter_list|,
name|ip
parameter_list|,
name|blkno
parameter_list|,
name|size
parameter_list|,
name|lbn
parameter_list|)
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
name|long
name|size
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
block|{
name|struct
name|jfreefrag
modifier|*
name|jfreefrag
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|fs
operator|=
name|ITOFS
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|jfreefrag
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|jfreefrag
argument_list|)
argument_list|,
name|M_JFREEFRAG
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|jfreefrag
operator|->
name|fr_list
argument_list|,
name|D_JFREEFRAG
argument_list|,
name|ITOVFS
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|jfreefrag
operator|->
name|fr_jsegdep
operator|=
name|newjsegdep
argument_list|(
operator|&
name|jfreefrag
operator|->
name|fr_list
argument_list|)
expr_stmt|;
name|jfreefrag
operator|->
name|fr_state
operator|=
name|ATTACHED
operator||
name|DEPCOMPLETE
expr_stmt|;
name|jfreefrag
operator|->
name|fr_ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|jfreefrag
operator|->
name|fr_lbn
operator|=
name|lbn
expr_stmt|;
name|jfreefrag
operator|->
name|fr_blkno
operator|=
name|blkno
expr_stmt|;
name|jfreefrag
operator|->
name|fr_frags
operator|=
name|numfrags
argument_list|(
name|fs
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|jfreefrag
operator|->
name|fr_freefrag
operator|=
name|freefrag
expr_stmt|;
return|return
operator|(
name|jfreefrag
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new freefrag structure.  */
end_comment

begin_function
specifier|static
name|struct
name|freefrag
modifier|*
name|newfreefrag
parameter_list|(
name|ip
parameter_list|,
name|blkno
parameter_list|,
name|size
parameter_list|,
name|lbn
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
name|long
name|size
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
block|{
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"newfreefrag: ino %d blkno %jd size %ld lbn %jd"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|blkno
argument_list|,
name|size
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
name|ump
operator|=
name|ITOUMP
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
if|if
condition|(
name|fragnum
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
operator|+
name|numfrags
argument_list|(
name|fs
argument_list|,
name|size
argument_list|)
operator|>
name|fs
operator|->
name|fs_frag
condition|)
name|panic
argument_list|(
literal|"newfreefrag: frag size"
argument_list|)
expr_stmt|;
name|freefrag
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|freefrag
argument_list|)
argument_list|,
name|M_FREEFRAG
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|freefrag
operator|->
name|ff_list
argument_list|,
name|D_FREEFRAG
argument_list|,
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
expr_stmt|;
name|freefrag
operator|->
name|ff_state
operator|=
name|ATTACHED
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|freefrag
operator|->
name|ff_jwork
argument_list|)
expr_stmt|;
name|freefrag
operator|->
name|ff_inum
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|freefrag
operator|->
name|ff_vtype
operator|=
name|ITOV
argument_list|(
name|ip
argument_list|)
operator|->
name|v_type
expr_stmt|;
name|freefrag
operator|->
name|ff_blkno
operator|=
name|blkno
expr_stmt|;
name|freefrag
operator|->
name|ff_fragsize
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|MOUNTEDSUJ
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
condition|)
block|{
name|freefrag
operator|->
name|ff_jdep
operator|=
operator|(
expr|struct
name|worklist
operator|*
operator|)
name|newjfreefrag
argument_list|(
name|freefrag
argument_list|,
name|ip
argument_list|,
name|blkno
argument_list|,
name|size
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|freefrag
operator|->
name|ff_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|freefrag
operator|->
name|ff_jdep
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|freefrag
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This workitem de-allocates fragments that were replaced during  * file block allocation.  */
end_comment

begin_function
specifier|static
name|void
name|handle_workitem_freefrag
parameter_list|(
name|freefrag
parameter_list|)
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
init|=
name|VFSTOUFS
argument_list|(
name|freefrag
operator|->
name|ff_list
operator|.
name|wk_mp
argument_list|)
decl_stmt|;
name|struct
name|workhead
name|wkhd
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"handle_workitem_freefrag: ino %d blkno %jd size %ld"
argument_list|,
name|freefrag
operator|->
name|ff_inum
argument_list|,
name|freefrag
operator|->
name|ff_blkno
argument_list|,
name|freefrag
operator|->
name|ff_fragsize
argument_list|)
expr_stmt|;
comment|/* 	 * It would be illegal to add new completion items to the 	 * freefrag after it was schedule to be done so it must be 	 * safe to modify the list head here. 	 */
name|LIST_INIT
argument_list|(
operator|&
name|wkhd
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|LIST_SWAP
argument_list|(
operator|&
name|freefrag
operator|->
name|ff_jwork
argument_list|,
operator|&
name|wkhd
argument_list|,
name|worklist
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
comment|/* 	 * If the journal has not been written we must cancel it here. 	 */
if|if
condition|(
name|freefrag
operator|->
name|ff_jdep
condition|)
block|{
if|if
condition|(
name|freefrag
operator|->
name|ff_jdep
operator|->
name|wk_type
operator|!=
name|D_JNEWBLK
condition|)
name|panic
argument_list|(
literal|"handle_workitem_freefrag: Unexpected type %d\n"
argument_list|,
name|freefrag
operator|->
name|ff_jdep
operator|->
name|wk_type
argument_list|)
expr_stmt|;
name|cancel_jnewblk
argument_list|(
name|WK_JNEWBLK
argument_list|(
name|freefrag
operator|->
name|ff_jdep
argument_list|)
argument_list|,
operator|&
name|wkhd
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|ffs_blkfree
argument_list|(
name|ump
argument_list|,
name|ump
operator|->
name|um_fs
argument_list|,
name|ump
operator|->
name|um_devvp
argument_list|,
name|freefrag
operator|->
name|ff_blkno
argument_list|,
name|freefrag
operator|->
name|ff_fragsize
argument_list|,
name|freefrag
operator|->
name|ff_inum
argument_list|,
name|freefrag
operator|->
name|ff_vtype
argument_list|,
operator|&
name|wkhd
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|freefrag
argument_list|,
name|D_FREEFRAG
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up a dependency structure for an external attributes data block.  * This routine follows much of the structure of softdep_setup_allocdirect.  * See the description of softdep_setup_allocdirect above for details.  */
end_comment

begin_function
name|void
name|softdep_setup_allocext
parameter_list|(
name|ip
parameter_list|,
name|off
parameter_list|,
name|newblkno
parameter_list|,
name|oldblkno
parameter_list|,
name|newsize
parameter_list|,
name|oldsize
parameter_list|,
name|bp
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ufs_lbn_t
name|off
decl_stmt|;
name|ufs2_daddr_t
name|newblkno
decl_stmt|;
name|ufs2_daddr_t
name|oldblkno
decl_stmt|;
name|long
name|newsize
decl_stmt|;
name|long
name|oldsize
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|,
modifier|*
name|oldadp
decl_stmt|;
name|struct
name|allocdirectlst
modifier|*
name|adphead
decl_stmt|;
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|mp
operator|=
name|ITOVFS
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_allocext called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|off
operator|<
name|UFS_NXADDR
argument_list|,
operator|(
literal|"softdep_setup_allocext: lbn %lld> UFS_NXADDR"
operator|,
operator|(
name|long
name|long
operator|)
name|off
operator|)
argument_list|)
expr_stmt|;
name|lbn
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
if|if
condition|(
name|oldblkno
operator|&&
name|oldblkno
operator|!=
name|newblkno
condition|)
name|freefrag
operator|=
name|newfreefrag
argument_list|(
name|ip
argument_list|,
name|oldblkno
argument_list|,
name|oldsize
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
else|else
name|freefrag
operator|=
name|NULL
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|newblk_lookup
argument_list|(
name|mp
argument_list|,
name|newblkno
argument_list|,
literal|0
argument_list|,
operator|&
name|newblk
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_setup_allocext: lost block"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|newblk
operator|->
name|nb_list
operator|.
name|wk_type
operator|==
name|D_NEWBLK
argument_list|,
operator|(
literal|"softdep_setup_allocext: newblk already initialized"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Convert the newblk to an allocdirect. 	 */
name|WORKITEM_REASSIGN
argument_list|(
name|newblk
argument_list|,
name|D_ALLOCDIRECT
argument_list|)
expr_stmt|;
name|adp
operator|=
operator|(
expr|struct
name|allocdirect
operator|*
operator|)
name|newblk
expr_stmt|;
name|newblk
operator|->
name|nb_freefrag
operator|=
name|freefrag
expr_stmt|;
name|adp
operator|->
name|ad_offset
operator|=
name|off
expr_stmt|;
name|adp
operator|->
name|ad_oldblkno
operator|=
name|oldblkno
expr_stmt|;
name|adp
operator|->
name|ad_newsize
operator|=
name|newsize
expr_stmt|;
name|adp
operator|->
name|ad_oldsize
operator|=
name|oldsize
expr_stmt|;
name|adp
operator|->
name|ad_state
operator||=
name|EXTDATA
expr_stmt|;
comment|/* 	 * Finish initializing the journal. 	 */
if|if
condition|(
operator|(
name|jnewblk
operator|=
name|newblk
operator|->
name|nb_jnewblk
operator|)
operator|!=
name|NULL
condition|)
block|{
name|jnewblk
operator|->
name|jn_ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|jnewblk
operator|->
name|jn_lbn
operator|=
name|lbn
expr_stmt|;
name|add_to_journal
argument_list|(
operator|&
name|jnewblk
operator|->
name|jn_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freefrag
operator|&&
name|freefrag
operator|->
name|ff_jdep
operator|!=
name|NULL
operator|&&
name|freefrag
operator|->
name|ff_jdep
operator|->
name|wk_type
operator|==
name|D_JFREEFRAG
condition|)
name|add_to_journal
argument_list|(
name|freefrag
operator|->
name|ff_jdep
argument_list|)
expr_stmt|;
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
name|adp
operator|->
name|ad_inodedep
operator|=
name|inodedep
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|newblk
operator|->
name|nb_list
argument_list|)
expr_stmt|;
comment|/* 	 * The list of allocdirects must be kept in sorted and ascending 	 * order so that the rollback routines can quickly determine the 	 * first uncommitted block (the size of the file stored on disk 	 * ends at the end of the lowest committed fragment, or if there 	 * are no fragments, at the end of the highest committed block). 	 * Since files generally grow, the typical case is that the new 	 * block is to be added at the end of the list. We speed this 	 * special case by checking against the last allocdirect in the 	 * list before laboriously traversing the list looking for the 	 * insertion point. 	 */
name|adphead
operator|=
operator|&
name|inodedep
operator|->
name|id_newextupdt
expr_stmt|;
name|oldadp
operator|=
name|TAILQ_LAST
argument_list|(
name|adphead
argument_list|,
name|allocdirectlst
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldadp
operator|==
name|NULL
operator|||
name|oldadp
operator|->
name|ad_offset
operator|<=
name|off
condition|)
block|{
comment|/* insert at end of list */
name|TAILQ_INSERT_TAIL
argument_list|(
name|adphead
argument_list|,
name|adp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldadp
operator|!=
name|NULL
operator|&&
name|oldadp
operator|->
name|ad_offset
operator|==
name|off
condition|)
name|allocdirect_merge
argument_list|(
name|adphead
argument_list|,
name|adp
argument_list|,
name|oldadp
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|oldadp
argument_list|,
argument|adphead
argument_list|,
argument|ad_next
argument_list|)
block|{
if|if
condition|(
name|oldadp
operator|->
name|ad_offset
operator|>=
name|off
condition|)
break|break;
block|}
if|if
condition|(
name|oldadp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"softdep_setup_allocext: lost entry"
argument_list|)
expr_stmt|;
comment|/* insert in middle of list */
name|TAILQ_INSERT_BEFORE
argument_list|(
name|oldadp
argument_list|,
name|adp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldadp
operator|->
name|ad_offset
operator|==
name|off
condition|)
name|allocdirect_merge
argument_list|(
name|adphead
argument_list|,
name|adp
argument_list|,
name|oldadp
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Indirect block allocation dependencies.  *   * The same dependencies that exist for a direct block also exist when  * a new block is allocated and pointed to by an entry in a block of  * indirect pointers. The undo/redo states described above are also  * used here. Because an indirect block contains many pointers that  * may have dependencies, a second copy of the entire in-memory indirect  * block is kept. The buffer cache copy is always completely up-to-date.  * The second copy, which is used only as a source for disk writes,  * contains only the safe pointers (i.e., those that have no remaining  * update dependencies). The second copy is freed when all pointers  * are safe. The cache is not allowed to replace indirect blocks with  * pending update dependencies. If a buffer containing an indirect  * block with dependencies is written, these routines will mark it  * dirty again. It can only be successfully written once all the  * dependencies are removed. The ffs_fsync routine in conjunction with  * softdep_sync_metadata work together to get all the dependencies  * removed so that a file can be successfully written to disk. Three  * procedures are used when setting up indirect block pointer  * dependencies. The division is necessary because of the organization  * of the "balloc" routine and because of the distinction between file  * pages and file metadata blocks.  */
end_comment

begin_comment
comment|/*  * Allocate a new allocindir structure.  */
end_comment

begin_function
specifier|static
name|struct
name|allocindir
modifier|*
name|newallocindir
parameter_list|(
name|ip
parameter_list|,
name|ptrno
parameter_list|,
name|newblkno
parameter_list|,
name|oldblkno
parameter_list|,
name|lbn
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode for file being extended */
name|int
name|ptrno
decl_stmt|;
comment|/* offset of pointer in indirect block */
name|ufs2_daddr_t
name|newblkno
decl_stmt|;
comment|/* disk block number being added */
name|ufs2_daddr_t
name|oldblkno
decl_stmt|;
comment|/* previous block number, 0 if none */
name|ufs_lbn_t
name|lbn
decl_stmt|;
block|{
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|;
if|if
condition|(
name|oldblkno
condition|)
name|freefrag
operator|=
name|newfreefrag
argument_list|(
name|ip
argument_list|,
name|oldblkno
argument_list|,
name|ITOFS
argument_list|(
name|ip
argument_list|)
operator|->
name|fs_bsize
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
else|else
name|freefrag
operator|=
name|NULL
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ITOUMP
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newblk_lookup
argument_list|(
name|ITOVFS
argument_list|(
name|ip
argument_list|)
argument_list|,
name|newblkno
argument_list|,
literal|0
argument_list|,
operator|&
name|newblk
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"new_allocindir: lost block"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|newblk
operator|->
name|nb_list
operator|.
name|wk_type
operator|==
name|D_NEWBLK
argument_list|,
operator|(
literal|"newallocindir: newblk already initialized"
operator|)
argument_list|)
expr_stmt|;
name|WORKITEM_REASSIGN
argument_list|(
name|newblk
argument_list|,
name|D_ALLOCINDIR
argument_list|)
expr_stmt|;
name|newblk
operator|->
name|nb_freefrag
operator|=
name|freefrag
expr_stmt|;
name|aip
operator|=
operator|(
expr|struct
name|allocindir
operator|*
operator|)
name|newblk
expr_stmt|;
name|aip
operator|->
name|ai_offset
operator|=
name|ptrno
expr_stmt|;
name|aip
operator|->
name|ai_oldblkno
operator|=
name|oldblkno
expr_stmt|;
name|aip
operator|->
name|ai_lbn
operator|=
name|lbn
expr_stmt|;
if|if
condition|(
operator|(
name|jnewblk
operator|=
name|newblk
operator|->
name|nb_jnewblk
operator|)
operator|!=
name|NULL
condition|)
block|{
name|jnewblk
operator|->
name|jn_ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|jnewblk
operator|->
name|jn_lbn
operator|=
name|lbn
expr_stmt|;
name|add_to_journal
argument_list|(
operator|&
name|jnewblk
operator|->
name|jn_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freefrag
operator|&&
name|freefrag
operator|->
name|ff_jdep
operator|!=
name|NULL
operator|&&
name|freefrag
operator|->
name|ff_jdep
operator|->
name|wk_type
operator|==
name|D_JFREEFRAG
condition|)
name|add_to_journal
argument_list|(
name|freefrag
operator|->
name|ff_jdep
argument_list|)
expr_stmt|;
return|return
operator|(
name|aip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called just before setting an indirect block pointer  * to a newly allocated file page.  */
end_comment

begin_function
name|void
name|softdep_setup_allocindir_page
parameter_list|(
name|ip
parameter_list|,
name|lbn
parameter_list|,
name|bp
parameter_list|,
name|ptrno
parameter_list|,
name|newblkno
parameter_list|,
name|oldblkno
parameter_list|,
name|nbp
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode for file being extended */
name|ufs_lbn_t
name|lbn
decl_stmt|;
comment|/* allocated block number within file */
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer with indirect blk referencing page */
name|int
name|ptrno
decl_stmt|;
comment|/* offset of pointer in indirect block */
name|ufs2_daddr_t
name|newblkno
decl_stmt|;
comment|/* disk block number being added */
name|ufs2_daddr_t
name|oldblkno
decl_stmt|;
comment|/* previous block number, 0 if none */
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
comment|/* buffer holding allocated page */
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|mp
operator|=
name|ITOVFS
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_allocindir_page called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lbn
operator|==
name|nbp
operator|->
name|b_lblkno
argument_list|,
operator|(
literal|"softdep_setup_allocindir_page: lbn %jd != lblkno %jd"
operator|,
name|lbn
operator|,
name|bp
operator|->
name|b_lblkno
operator|)
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"softdep_setup_allocindir_page: ino %d blkno %jd oldblkno %jd "
literal|"lbn %jd"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|newblkno
argument_list|,
name|oldblkno
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|ITOV
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|"softdep_setup_allocindir_page"
argument_list|)
expr_stmt|;
name|aip
operator|=
name|newallocindir
argument_list|(
name|ip
argument_list|,
name|ptrno
argument_list|,
name|newblkno
argument_list|,
name|oldblkno
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
comment|/* 	 * If we are allocating a directory page, then we must 	 * allocate an associated pagedep to track additions and 	 * deletions. 	 */
if|if
condition|(
operator|(
name|ip
operator|->
name|i_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
condition|)
name|pagedep_lookup
argument_list|(
name|mp
argument_list|,
name|nbp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|lbn
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|pagedep
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|nbp
operator|->
name|b_dep
argument_list|,
operator|&
name|aip
operator|->
name|ai_block
operator|.
name|nb_list
argument_list|)
expr_stmt|;
name|freefrag
operator|=
name|setup_allocindir_phase2
argument_list|(
name|bp
argument_list|,
name|ip
argument_list|,
name|inodedep
argument_list|,
name|aip
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|freefrag
condition|)
name|handle_workitem_freefrag
argument_list|(
name|freefrag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called just before setting an indirect block pointer to a  * newly allocated indirect block.  */
end_comment

begin_function
name|void
name|softdep_setup_allocindir_meta
parameter_list|(
name|nbp
parameter_list|,
name|ip
parameter_list|,
name|bp
parameter_list|,
name|ptrno
parameter_list|,
name|newblkno
parameter_list|)
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
comment|/* newly allocated indirect block */
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode for file being extended */
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* indirect block referencing allocated block */
name|int
name|ptrno
decl_stmt|;
comment|/* offset of pointer in indirect block */
name|ufs2_daddr_t
name|newblkno
decl_stmt|;
comment|/* disk block number being added */
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|ump
operator|=
name|ITOUMP
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_allocindir_meta called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"softdep_setup_allocindir_meta: ino %d blkno %jd ptrno %d"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|newblkno
argument_list|,
name|ptrno
argument_list|)
expr_stmt|;
name|lbn
operator|=
name|nbp
operator|->
name|b_lblkno
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|ITOV
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|"softdep_setup_allocindir_meta"
argument_list|)
expr_stmt|;
name|aip
operator|=
name|newallocindir
argument_list|(
name|ip
argument_list|,
name|ptrno
argument_list|,
name|newblkno
argument_list|,
literal|0
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
name|inodedep_lookup
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|nbp
operator|->
name|b_dep
argument_list|,
operator|&
name|aip
operator|->
name|ai_block
operator|.
name|nb_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|setup_allocindir_phase2
argument_list|(
name|bp
argument_list|,
name|ip
argument_list|,
name|inodedep
argument_list|,
name|aip
argument_list|,
name|lbn
argument_list|)
condition|)
name|panic
argument_list|(
literal|"softdep_setup_allocindir_meta: Block already existed"
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|indirdep_complete
parameter_list|(
name|indirdep
parameter_list|)
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
block|{
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|indirdep
argument_list|,
name|ir_next
argument_list|)
expr_stmt|;
name|indirdep
operator|->
name|ir_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
while|while
condition|(
operator|(
name|aip
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_completehd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|aip
argument_list|,
name|ai_next
argument_list|)
expr_stmt|;
name|free_newblk
argument_list|(
operator|&
name|aip
operator|->
name|ai_block
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this indirdep is not attached to a buf it was simply waiting 	 * on completion to clear completehd.  free_indirdep() asserts 	 * that nothing is dangling. 	 */
if|if
condition|(
operator|(
name|indirdep
operator|->
name|ir_state
operator|&
name|ONWORKLIST
operator|)
operator|==
literal|0
condition|)
name|free_indirdep
argument_list|(
name|indirdep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|indirdep
modifier|*
name|indirdep_lookup
parameter_list|(
name|mp
parameter_list|,
name|ip
parameter_list|,
name|bp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|,
modifier|*
name|newindirdep
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|indirdep
operator|=
name|NULL
expr_stmt|;
name|newindirdep
operator|=
name|NULL
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&bp->b_dep
argument_list|,
argument|wk_list
argument_list|)
block|{
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|!=
name|D_INDIRDEP
condition|)
continue|continue;
name|indirdep
operator|=
name|WK_INDIRDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Found on the buffer worklist, no new structure to free. */
if|if
condition|(
name|indirdep
operator|!=
name|NULL
operator|&&
name|newindirdep
operator|==
name|NULL
condition|)
return|return
operator|(
name|indirdep
operator|)
return|;
if|if
condition|(
name|indirdep
operator|!=
name|NULL
operator|&&
name|newindirdep
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"indirdep_lookup: simultaneous create"
argument_list|)
expr_stmt|;
comment|/* None found on the buffer and a new structure is ready. */
if|if
condition|(
name|indirdep
operator|==
name|NULL
operator|&&
name|newindirdep
operator|!=
name|NULL
condition|)
break|break;
comment|/* None found and no new structure available. */
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|newindirdep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|indirdep
argument_list|)
argument_list|,
name|M_INDIRDEP
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|newindirdep
operator|->
name|ir_list
argument_list|,
name|D_INDIRDEP
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|newindirdep
operator|->
name|ir_state
operator|=
name|ATTACHED
expr_stmt|;
if|if
condition|(
name|I_IS_UFS1
argument_list|(
name|ip
argument_list|)
condition|)
name|newindirdep
operator|->
name|ir_state
operator||=
name|UFS1FMT
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|newindirdep
operator|->
name|ir_trunc
argument_list|)
expr_stmt|;
name|newindirdep
operator|->
name|ir_saveddata
operator|=
name|NULL
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|newindirdep
operator|->
name|ir_deplisthd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|newindirdep
operator|->
name|ir_donehd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|newindirdep
operator|->
name|ir_writehd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|newindirdep
operator|->
name|ir_completehd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|bp
operator|->
name|b_lblkno
condition|)
block|{
name|ufs_bmaparray
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
operator|&
name|blkno
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|blkno
expr_stmt|;
block|}
name|newindirdep
operator|->
name|ir_freeblks
operator|=
name|NULL
expr_stmt|;
name|newindirdep
operator|->
name|ir_savebp
operator|=
name|getblk
argument_list|(
name|ump
operator|->
name|um_devvp
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newindirdep
operator|->
name|ir_bp
operator|=
name|bp
expr_stmt|;
name|BUF_KERNPROC
argument_list|(
name|newindirdep
operator|->
name|ir_savebp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|newindirdep
operator|->
name|ir_savebp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
name|indirdep
operator|=
name|newindirdep
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|indirdep
operator|->
name|ir_list
argument_list|)
expr_stmt|;
comment|/* 	 * If the block is not yet allocated we don't set DEPCOMPLETE so 	 * that we don't free dependencies until the pointers are valid. 	 * This could search b_dep for D_ALLOCDIRECT/D_ALLOCINDIR rather 	 * than using the hash. 	 */
if|if
condition|(
name|newblk_lookup
argument_list|(
name|mp
argument_list|,
name|dbtofsb
argument_list|(
name|fs
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|newblk
argument_list|)
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|newblk
operator|->
name|nb_indirdeps
argument_list|,
name|indirdep
argument_list|,
name|ir_next
argument_list|)
expr_stmt|;
else|else
name|indirdep
operator|->
name|ir_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
return|return
operator|(
name|indirdep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called to finish the allocation of the "aip" allocated  * by one of the two routines above.  */
end_comment

begin_function
specifier|static
name|struct
name|freefrag
modifier|*
name|setup_allocindir_phase2
parameter_list|(
name|bp
parameter_list|,
name|ip
parameter_list|,
name|inodedep
parameter_list|,
name|aip
parameter_list|,
name|lbn
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* in-memory copy of the indirect block */
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode for file being extended */
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
comment|/* Inodedep for ip */
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
comment|/* allocindir allocated by the above routines */
name|ufs_lbn_t
name|lbn
decl_stmt|;
comment|/* Logical block number for this block. */
block|{
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|allocindir
modifier|*
name|oldaip
decl_stmt|;
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|mp
operator|=
name|ITOVFS
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_lblkno
operator|>=
literal|0
condition|)
name|panic
argument_list|(
literal|"setup_allocindir_phase2: not indir blk"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|aip
operator|->
name|ai_offset
operator|>=
literal|0
operator|&&
name|aip
operator|->
name|ai_offset
operator|<
name|NINDIR
argument_list|(
name|fs
argument_list|)
argument_list|,
operator|(
literal|"setup_allocindir_phase2: Bad offset %d"
operator|,
name|aip
operator|->
name|ai_offset
operator|)
argument_list|)
expr_stmt|;
name|indirdep
operator|=
name|indirdep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|indirdep
operator|->
name|ir_savebp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"setup_allocindir_phase2 NULL ir_savebp"
operator|)
argument_list|)
expr_stmt|;
name|aip
operator|->
name|ai_indirdep
operator|=
name|indirdep
expr_stmt|;
comment|/* 	 * Check for an unwritten dependency for this indirect offset.  If 	 * there is, merge the old dependency into the new one.  This happens 	 * as a result of reallocblk only. 	 */
name|freefrag
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|aip
operator|->
name|ai_oldblkno
operator|!=
literal|0
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|oldaip
argument_list|,
argument|&indirdep->ir_deplisthd
argument_list|,
argument|ai_next
argument_list|)
block|{
if|if
condition|(
name|oldaip
operator|->
name|ai_offset
operator|==
name|aip
operator|->
name|ai_offset
condition|)
block|{
name|freefrag
operator|=
name|allocindir_merge
argument_list|(
name|aip
argument_list|,
name|oldaip
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|LIST_FOREACH
argument_list|(
argument|oldaip
argument_list|,
argument|&indirdep->ir_donehd
argument_list|,
argument|ai_next
argument_list|)
block|{
if|if
condition|(
name|oldaip
operator|->
name|ai_offset
operator|==
name|aip
operator|->
name|ai_offset
condition|)
block|{
name|freefrag
operator|=
name|allocindir_merge
argument_list|(
name|aip
argument_list|,
name|oldaip
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|done
label|:
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_deplisthd
argument_list|,
name|aip
argument_list|,
name|ai_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|freefrag
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Merge two allocindirs which refer to the same block.  Move newblock  * dependencies and setup the freefrags appropriately.  */
end_comment

begin_function
specifier|static
name|struct
name|freefrag
modifier|*
name|allocindir_merge
parameter_list|(
name|aip
parameter_list|,
name|oldaip
parameter_list|)
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|struct
name|allocindir
modifier|*
name|oldaip
decl_stmt|;
block|{
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
if|if
condition|(
name|oldaip
operator|->
name|ai_newblkno
operator|!=
name|aip
operator|->
name|ai_oldblkno
condition|)
name|panic
argument_list|(
literal|"allocindir_merge: blkno"
argument_list|)
expr_stmt|;
name|aip
operator|->
name|ai_oldblkno
operator|=
name|oldaip
operator|->
name|ai_oldblkno
expr_stmt|;
name|freefrag
operator|=
name|aip
operator|->
name|ai_freefrag
expr_stmt|;
name|aip
operator|->
name|ai_freefrag
operator|=
name|oldaip
operator|->
name|ai_freefrag
expr_stmt|;
name|oldaip
operator|->
name|ai_freefrag
operator|=
name|NULL
expr_stmt|;
name|KASSERT
argument_list|(
name|freefrag
operator|!=
name|NULL
argument_list|,
operator|(
literal|"setup_allocindir_phase2: No freefrag"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we are tracking a new directory-block allocation, 	 * move it from the old allocindir to the new allocindir. 	 */
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|oldaip
operator|->
name|ai_newdirblk
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|oldaip
operator|->
name|ai_newdirblk
argument_list|)
condition|)
name|panic
argument_list|(
literal|"allocindir_merge: extra newdirblk"
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|aip
operator|->
name|ai_newdirblk
argument_list|,
name|wk
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We can skip journaling for this freefrag and just complete 	 * any pending journal work for the allocindir that is being 	 * removed after the freefrag completes. 	 */
if|if
condition|(
name|freefrag
operator|->
name|ff_jdep
condition|)
name|cancel_jfreefrag
argument_list|(
name|WK_JFREEFRAG
argument_list|(
name|freefrag
operator|->
name|ff_jdep
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|oldaip
argument_list|,
name|ai_next
argument_list|)
expr_stmt|;
name|freefrag
operator|->
name|ff_jdep
operator|=
operator|(
expr|struct
name|worklist
operator|*
operator|)
name|cancel_newblk
argument_list|(
operator|&
name|oldaip
operator|->
name|ai_block
argument_list|,
operator|&
name|freefrag
operator|->
name|ff_list
argument_list|,
operator|&
name|freefrag
operator|->
name|ff_jwork
argument_list|)
expr_stmt|;
name|free_newblk
argument_list|(
operator|&
name|oldaip
operator|->
name|ai_block
argument_list|)
expr_stmt|;
return|return
operator|(
name|freefrag
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|setup_freedirect
parameter_list|(
name|freeblks
parameter_list|,
name|ip
parameter_list|,
name|i
parameter_list|,
name|needj
parameter_list|)
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|needj
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
name|int
name|frags
decl_stmt|;
name|blkno
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_db
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
condition|)
return|return;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_db
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ump
operator|=
name|ITOUMP
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|frags
operator|=
name|sblksize
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|,
name|ip
operator|->
name|i_size
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|frags
operator|=
name|numfrags
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|,
name|frags
argument_list|)
expr_stmt|;
name|newfreework
argument_list|(
name|ump
argument_list|,
name|freeblks
argument_list|,
name|NULL
argument_list|,
name|i
argument_list|,
name|blkno
argument_list|,
name|frags
argument_list|,
literal|0
argument_list|,
name|needj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|setup_freeext
parameter_list|(
name|freeblks
parameter_list|,
name|ip
parameter_list|,
name|i
parameter_list|,
name|needj
parameter_list|)
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|needj
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
name|int
name|frags
decl_stmt|;
name|blkno
operator|=
name|ip
operator|->
name|i_din2
operator|->
name|di_extb
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
condition|)
return|return;
name|ip
operator|->
name|i_din2
operator|->
name|di_extb
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ump
operator|=
name|ITOUMP
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|frags
operator|=
name|sblksize
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|,
name|ip
operator|->
name|i_din2
operator|->
name|di_extsize
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|frags
operator|=
name|numfrags
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|,
name|frags
argument_list|)
expr_stmt|;
name|newfreework
argument_list|(
name|ump
argument_list|,
name|freeblks
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
operator|-
name|i
argument_list|,
name|blkno
argument_list|,
name|frags
argument_list|,
literal|0
argument_list|,
name|needj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|setup_freeindir
parameter_list|(
name|freeblks
parameter_list|,
name|ip
parameter_list|,
name|i
parameter_list|,
name|lbn
parameter_list|,
name|needj
parameter_list|)
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|int
name|needj
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
name|blkno
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_ib
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
condition|)
return|return;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_ib
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ump
operator|=
name|ITOUMP
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|newfreework
argument_list|(
name|ump
argument_list|,
name|freeblks
argument_list|,
name|NULL
argument_list|,
name|lbn
argument_list|,
name|blkno
argument_list|,
name|ump
operator|->
name|um_fs
operator|->
name|fs_frag
argument_list|,
literal|0
argument_list|,
name|needj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|freeblks
modifier|*
name|newfreeblks
parameter_list|(
name|mp
parameter_list|,
name|ip
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|freeblks
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|freeblks
argument_list|)
argument_list|,
name|M_FREEBLKS
argument_list|,
name|M_SOFTDEP_FLAGS
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_list
argument_list|,
name|D_FREEBLKS
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jwork
argument_list|)
expr_stmt|;
name|freeblks
operator|->
name|fb_ref
operator|=
literal|0
expr_stmt|;
name|freeblks
operator|->
name|fb_cgwait
operator|=
literal|0
expr_stmt|;
name|freeblks
operator|->
name|fb_state
operator|=
name|ATTACHED
expr_stmt|;
name|freeblks
operator|->
name|fb_uid
operator|=
name|ip
operator|->
name|i_uid
expr_stmt|;
name|freeblks
operator|->
name|fb_inum
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|freeblks
operator|->
name|fb_vtype
operator|=
name|ITOV
argument_list|(
name|ip
argument_list|)
operator|->
name|v_type
expr_stmt|;
name|freeblks
operator|->
name|fb_modrev
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_modrev
argument_list|)
expr_stmt|;
name|freeblks
operator|->
name|fb_devvp
operator|=
name|ITODEVVP
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|freeblks
operator|->
name|fb_chkcnt
operator|=
literal|0
expr_stmt|;
name|freeblks
operator|->
name|fb_len
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|freeblks
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trunc_indirdep
parameter_list|(
name|indirdep
parameter_list|,
name|freeblks
parameter_list|,
name|bp
parameter_list|,
name|off
parameter_list|)
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|off
decl_stmt|;
block|{
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|,
modifier|*
name|aipn
decl_stmt|;
comment|/* 	 * The first set of allocindirs won't be in savedbp. 	 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|aip
argument_list|,
argument|&indirdep->ir_deplisthd
argument_list|,
argument|ai_next
argument_list|,
argument|aipn
argument_list|)
if|if
condition|(
name|aip
operator|->
name|ai_offset
operator|>
name|off
condition|)
name|cancel_allocindir
argument_list|(
name|aip
argument_list|,
name|bp
argument_list|,
name|freeblks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|aip
argument_list|,
argument|&indirdep->ir_donehd
argument_list|,
argument|ai_next
argument_list|,
argument|aipn
argument_list|)
if|if
condition|(
name|aip
operator|->
name|ai_offset
operator|>
name|off
condition|)
name|cancel_allocindir
argument_list|(
name|aip
argument_list|,
name|bp
argument_list|,
name|freeblks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * These will exist in savedbp. 	 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|aip
argument_list|,
argument|&indirdep->ir_writehd
argument_list|,
argument|ai_next
argument_list|,
argument|aipn
argument_list|)
if|if
condition|(
name|aip
operator|->
name|ai_offset
operator|>
name|off
condition|)
name|cancel_allocindir
argument_list|(
name|aip
argument_list|,
name|NULL
argument_list|,
name|freeblks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|aip
argument_list|,
argument|&indirdep->ir_completehd
argument_list|,
argument|ai_next
argument_list|,
argument|aipn
argument_list|)
if|if
condition|(
name|aip
operator|->
name|ai_offset
operator|>
name|off
condition|)
name|cancel_allocindir
argument_list|(
name|aip
argument_list|,
name|NULL
argument_list|,
name|freeblks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Follow the chain of indirects down to lastlbn creating a freework  * structure for each.  This will be used to start indir_trunc() at  * the right offset and create the journal records for the parrtial  * truncation.  A second step will handle the truncated dependencies.  */
end_comment

begin_function
specifier|static
name|int
name|setup_trunc_indir
parameter_list|(
name|freeblks
parameter_list|,
name|ip
parameter_list|,
name|lbn
parameter_list|,
name|lastlbn
parameter_list|,
name|blkno
parameter_list|)
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|ufs_lbn_t
name|lastlbn
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
block|{
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|indirdep
modifier|*
name|indirn
decl_stmt|;
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|uint8_t
modifier|*
name|start
decl_stmt|;
name|uint8_t
modifier|*
name|end
decl_stmt|;
name|ufs_lbn_t
name|lbnadd
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|off
decl_stmt|;
name|freework
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mp
operator|=
name|freeblks
operator|->
name|fb_list
operator|.
name|wk_mp
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|getblk
argument_list|(
name|ITOV
argument_list|(
name|ip
argument_list|)
argument_list|,
name|lbn
argument_list|,
name|mp
operator|->
name|mnt_stat
operator|.
name|f_iosize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_blkno
operator|=
name|blkptrtodb
argument_list|(
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_iocmd
operator|=
name|BIO_READ
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_INVAL
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator|&=
operator|~
name|BIO_ERROR
expr_stmt|;
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_iooffset
operator|=
name|dbtob
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|bstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RACCT
if|if
condition|(
name|racct_enable
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|racct_add_buf
argument_list|(
name|curproc
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RACCT */
name|curthread
operator|->
name|td_ru
operator|.
name|ru_inblock
operator|++
expr_stmt|;
name|error
operator|=
name|bufwait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|level
operator|=
name|lbn_level
argument_list|(
name|lbn
argument_list|)
expr_stmt|;
name|lbnadd
operator|=
name|lbn_offset
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|,
name|level
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the offset of the last block we want to keep.  Store 	 * in the freework the first block we want to completely free. 	 */
name|off
operator|=
operator|(
name|lastlbn
operator|-
operator|-
operator|(
name|lbn
operator|+
name|level
operator|)
operator|)
operator|/
name|lbnadd
expr_stmt|;
if|if
condition|(
name|off
operator|+
literal|1
operator|==
name|NINDIR
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|)
condition|)
goto|goto
name|nowork
goto|;
name|freework
operator|=
name|newfreework
argument_list|(
name|ump
argument_list|,
name|freeblks
argument_list|,
name|NULL
argument_list|,
name|lbn
argument_list|,
name|blkno
argument_list|,
literal|0
argument_list|,
name|off
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Link the freework into the indirdep.  This will prevent any new 	 * allocations from proceeding until we are finished with the 	 * truncate and the block is written. 	 */
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|indirdep
operator|=
name|indirdep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirdep
operator|->
name|ir_freeblks
condition|)
name|panic
argument_list|(
literal|"setup_trunc_indir: indirdep already truncated."
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|,
name|freework
argument_list|,
name|fw_next
argument_list|)
expr_stmt|;
name|freework
operator|->
name|fw_indir
operator|=
name|indirdep
expr_stmt|;
comment|/* 	 * Cancel any allocindirs that will not make it to disk. 	 * We have to do this for all copies of the indirdep that 	 * live on this newblk. 	 */
if|if
condition|(
operator|(
name|indirdep
operator|->
name|ir_state
operator|&
name|DEPCOMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|newblk_lookup
argument_list|(
name|mp
argument_list|,
name|dbtofsb
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|newblk
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|indirn
argument_list|,
argument|&newblk->nb_indirdeps
argument_list|,
argument|ir_next
argument_list|)
name|trunc_indirdep
argument_list|(
name|indirn
argument_list|,
name|freeblks
argument_list|,
name|bp
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
else|else
name|trunc_indirdep
argument_list|(
name|indirdep
argument_list|,
name|freeblks
argument_list|,
name|bp
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * Creation is protected by the buf lock. The saveddata is only 	 * needed if a full truncation follows a partial truncation but it 	 * is difficult to allocate in that case so we fetch it anyway. 	 */
if|if
condition|(
name|indirdep
operator|->
name|ir_saveddata
operator|==
name|NULL
condition|)
name|indirdep
operator|->
name|ir_saveddata
operator|=
name|malloc
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|,
name|M_INDIRDEP
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|nowork
label|:
comment|/* Fetch the blkno of the child and the zero start offset. */
if|if
condition|(
name|I_IS_UFS1
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|blkno
operator|=
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|)
index|[
name|off
index|]
expr_stmt|;
name|start
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|)
index|[
name|off
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|blkno
operator|=
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|)
index|[
name|off
index|]
expr_stmt|;
name|start
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|)
index|[
name|off
operator|+
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|freework
condition|)
block|{
comment|/* Zero the truncated pointers. */
name|end
operator|=
name|bp
operator|->
name|b_data
operator|+
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bzero
argument_list|(
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lbn
operator|++
expr_stmt|;
comment|/* adjust level */
name|lbn
operator|-=
operator|(
name|off
operator|*
name|lbnadd
operator|)
expr_stmt|;
return|return
name|setup_trunc_indir
argument_list|(
name|freeblks
argument_list|,
name|ip
argument_list|,
name|lbn
argument_list|,
name|lastlbn
argument_list|,
name|blkno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Complete the partial truncation of an indirect block setup by  * setup_trunc_indir().  This zeros the truncated pointers in the saved  * copy and writes them to disk before the freeblks is allowed to complete.  */
end_comment

begin_function
specifier|static
name|void
name|complete_trunc_indir
parameter_list|(
name|freework
parameter_list|)
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
block|{
name|struct
name|freework
modifier|*
name|fwn
decl_stmt|;
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|uintptr_t
name|start
decl_stmt|;
name|int
name|count
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|freework
operator|->
name|fw_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|indirdep
operator|=
name|freework
operator|->
name|fw_indir
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bp
operator|=
name|indirdep
operator|->
name|ir_bp
expr_stmt|;
comment|/* See if the block was discarded. */
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
break|break;
comment|/* Inline part of getdirtybuf().  We dont want bremfree. */
if|if
condition|(
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_NOWAIT
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_SLEEPFAIL
operator||
name|LK_INTERLOCK
argument_list|,
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|BUF_UNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
name|freework
operator|->
name|fw_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|,
name|freework
argument_list|,
name|fw_next
argument_list|)
expr_stmt|;
comment|/* 	 * Zero the pointers in the saved copy. 	 */
if|if
condition|(
name|indirdep
operator|->
name|ir_state
operator|&
name|UFS1FMT
condition|)
name|start
operator|=
sizeof|sizeof
argument_list|(
name|ufs1_daddr_t
argument_list|)
expr_stmt|;
else|else
name|start
operator|=
sizeof|sizeof
argument_list|(
name|ufs2_daddr_t
argument_list|)
expr_stmt|;
name|start
operator|*=
name|freework
operator|->
name|fw_start
expr_stmt|;
name|count
operator|=
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_bcount
operator|-
name|start
expr_stmt|;
name|start
operator|+=
operator|(
name|uintptr_t
operator|)
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_data
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|start
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 	 * We need to start the next truncation in the list if it has not 	 * been started yet. 	 */
name|fwn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwn
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fwn
operator|->
name|fw_freeblks
operator|==
name|indirdep
operator|->
name|ir_freeblks
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|,
name|fwn
argument_list|,
name|fw_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fwn
operator|->
name|fw_state
operator|&
name|ONWORKLIST
operator|)
operator|==
literal|0
condition|)
name|freework_enqueue
argument_list|(
name|fwn
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If bp is NULL the block was fully truncated, restore 	 * the saved block list otherwise free it if it is no 	 * longer needed. 	 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|)
condition|)
block|{
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|bcopy
argument_list|(
name|indirdep
operator|->
name|ir_saveddata
argument_list|,
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_data
argument_list|,
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|indirdep
operator|->
name|ir_saveddata
argument_list|,
name|M_INDIRDEP
argument_list|)
expr_stmt|;
name|indirdep
operator|->
name|ir_saveddata
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * When bp is NULL there is a full truncation pending.  We 	 * must wait for this full truncation to be journaled before 	 * we can release this freework because the disk pointers will 	 * never be written as zero. 	 */
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_freeblks
operator|->
name|fb_jblkdephd
argument_list|)
condition|)
name|handle_written_freework
argument_list|(
name|freework
argument_list|)
expr_stmt|;
else|else
name|WORKLIST_INSERT
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_freeblks
operator|->
name|fb_freeworkhd
argument_list|,
operator|&
name|freework
operator|->
name|fw_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Complete when the real copy is written. */
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|freework
operator|->
name|fw_list
argument_list|)
expr_stmt|;
name|BUF_UNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Calculate the number of blocks we are going to release where datablocks  * is the current total and length is the new file size.  */
end_comment

begin_function
specifier|static
name|ufs2_daddr_t
name|blkcount
parameter_list|(
name|fs
parameter_list|,
name|datablocks
parameter_list|,
name|length
parameter_list|)
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ufs2_daddr_t
name|datablocks
decl_stmt|;
name|off_t
name|length
decl_stmt|;
block|{
name|off_t
name|totblks
decl_stmt|,
name|numblks
decl_stmt|;
name|totblks
operator|=
literal|0
expr_stmt|;
name|numblks
operator|=
name|howmany
argument_list|(
name|length
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|numblks
operator|<=
name|UFS_NDADDR
condition|)
block|{
name|totblks
operator|=
name|howmany
argument_list|(
name|length
argument_list|,
name|fs
operator|->
name|fs_fsize
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|totblks
operator|=
name|blkstofrags
argument_list|(
name|fs
argument_list|,
name|numblks
argument_list|)
expr_stmt|;
name|numblks
operator|-=
name|UFS_NDADDR
expr_stmt|;
comment|/* 	 * Count all single, then double, then triple indirects required. 	 * Subtracting one indirects worth of blocks for each pass 	 * acknowledges one of each pointed to by the inode. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|totblks
operator|+=
name|blkstofrags
argument_list|(
name|fs
argument_list|,
name|howmany
argument_list|(
name|numblks
argument_list|,
name|NINDIR
argument_list|(
name|fs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|numblks
operator|-=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|numblks
operator|<=
literal|0
condition|)
break|break;
name|numblks
operator|=
name|howmany
argument_list|(
name|numblks
argument_list|,
name|NINDIR
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|totblks
operator|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|totblks
argument_list|)
expr_stmt|;
comment|/* 	 * Handle sparse files.  We can't reclaim more blocks than the inode 	 * references.  We will correct it later in handle_complete_freeblks() 	 * when we know the real count. 	 */
if|if
condition|(
name|totblks
operator|>
name|datablocks
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|datablocks
operator|-
name|totblks
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle freeblocks for journaled softupdate filesystems.  *  * Contrary to normal softupdates, we must preserve the block pointers in  * indirects until their subordinates are free.  This is to avoid journaling  * every block that is freed which may consume more space than the journal  * itself.  The recovery program will see the free block journals at the  * base of the truncated area and traverse them to reclaim space.  The  * pointers in the inode may be cleared immediately after the journal  * records are written because each direct and indirect pointer in the  * inode is recorded in a journal.  This permits full truncation to proceed  * asynchronously.  The write order is journal -> inode -> cgs -> indirects.  *  * The algorithm is as follows:  * 1) Traverse the in-memory state and create journal entries to release  *    the relevant blocks and full indirect trees.  * 2) Traverse the indirect block chain adding partial truncation freework  *    records to indirects in the path to lastlbn.  The freework will  *    prevent new allocation dependencies from being satisfied in this  *    indirect until the truncation completes.  * 3) Read and lock the inode block, performing an update with the new size  *    and pointers.  This prevents truncated data from becoming valid on  *    disk through step 4.  * 4) Reap unsatisfied dependencies that are beyond the truncated area,  *    eliminate journal work for those records that do not require it.  * 5) Schedule the journal records to be written followed by the inode block.  * 6) Allocate any necessary frags for the end of file.  * 7) Zero any partially truncated blocks.  *  * From this truncation proceeds asynchronously using the freework and  * indir_trunc machinery.  The file will not be extended again into a  * partially truncated indirect block until all work is completed but  * the normal dependency mechanism ensures that it is rolled back/forward  * as appropriate.  Further truncation may occur without delay and is  * serialized in indir_trunc().  */
end_comment

begin_function
name|void
name|softdep_journal_freeblocks
parameter_list|(
name|ip
parameter_list|,
name|cred
parameter_list|,
name|length
parameter_list|,
name|flags
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* The inode whose length is to be reduced */
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|off_t
name|length
decl_stmt|;
comment|/* The new length for the file */
name|int
name|flags
decl_stmt|;
comment|/* IO_EXT and/or IO_NORMAL */
block|{
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|,
modifier|*
name|fbn
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|,
modifier|*
name|wkn
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|jblkdep
modifier|*
name|jblkdep
decl_stmt|;
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|,
modifier|*
name|adpn
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|ufs2_daddr_t
name|extblocks
decl_stmt|,
name|datablocks
decl_stmt|;
name|ufs_lbn_t
name|tmpval
decl_stmt|,
name|lbn
decl_stmt|,
name|lastlbn
decl_stmt|;
name|int
name|frags
decl_stmt|,
name|lastoff
decl_stmt|,
name|iboff
decl_stmt|,
name|allocblock
decl_stmt|,
name|needj
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|ump
operator|=
name|ITOUMP
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|mp
operator|=
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_journal_freeblocks called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|needj
operator|=
literal|1
expr_stmt|;
name|iboff
operator|=
operator|-
literal|1
expr_stmt|;
name|allocblock
operator|=
literal|0
expr_stmt|;
name|extblocks
operator|=
literal|0
expr_stmt|;
name|datablocks
operator|=
literal|0
expr_stmt|;
name|frags
operator|=
literal|0
expr_stmt|;
name|freeblks
operator|=
name|newfreeblks
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * If we're truncating a removed file that will never be written 	 * we don't need to journal the block frees.  The canceled journals 	 * for the allocations will suffice. 	 */
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
operator|(
name|UNLINKED
operator||
name|DEPCOMPLETE
operator|)
operator|)
operator|==
name|UNLINKED
operator|&&
name|length
operator|==
literal|0
condition|)
name|needj
operator|=
literal|0
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"softdep_journal_freeblks: ip %d length %ld needj %d"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|length
argument_list|,
name|needj
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the lbn that we are truncating to.  This results in -1 	 * if we're truncating the 0 bytes.  So it is the last lbn we want 	 * to keep, not the first lbn we want to truncate. 	 */
name|lastlbn
operator|=
name|lblkno
argument_list|(
name|fs
argument_list|,
name|length
operator|+
name|fs
operator|->
name|fs_bsize
operator|-
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
name|lastoff
operator|=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * Compute frags we are keeping in lastlbn.  0 means all. 	 */
if|if
condition|(
name|lastlbn
operator|>=
literal|0
operator|&&
name|lastlbn
operator|<
name|UFS_NDADDR
condition|)
block|{
name|frags
operator|=
name|fragroundup
argument_list|(
name|fs
argument_list|,
name|lastoff
argument_list|)
expr_stmt|;
comment|/* adp offset of last valid allocdirect. */
name|iboff
operator|=
name|lastlbn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastlbn
operator|>
literal|0
condition|)
name|iboff
operator|=
name|UFS_NDADDR
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_magic
operator|==
name|FS_UFS2_MAGIC
condition|)
name|extblocks
operator|=
name|btodb
argument_list|(
name|fragroundup
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_din2
operator|->
name|di_extsize
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Handle normal data blocks and indirects.  This section saves 	 * values used after the inode update to complete frag and indirect 	 * truncation. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|IO_NORMAL
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Handle truncation of whole direct and indirect blocks. 		 */
for|for
control|(
name|i
operator|=
name|iboff
operator|+
literal|1
init|;
name|i
operator|<
name|UFS_NDADDR
condition|;
name|i
operator|++
control|)
name|setup_freedirect
argument_list|(
name|freeblks
argument_list|,
name|ip
argument_list|,
name|i
argument_list|,
name|needj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmpval
operator|=
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|,
name|lbn
operator|=
name|UFS_NDADDR
init|;
name|i
operator|<
name|UFS_NIADDR
condition|;
name|i
operator|++
operator|,
name|lbn
operator|+=
name|tmpval
operator|,
name|tmpval
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
control|)
block|{
comment|/* Release a whole indirect tree. */
if|if
condition|(
name|lbn
operator|>
name|lastlbn
condition|)
block|{
name|setup_freeindir
argument_list|(
name|freeblks
argument_list|,
name|ip
argument_list|,
name|i
argument_list|,
operator|-
name|lbn
operator|-
name|i
argument_list|,
name|needj
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|iboff
operator|=
name|i
operator|+
name|UFS_NDADDR
expr_stmt|;
comment|/* 			 * Traverse partially truncated indirect tree. 			 */
if|if
condition|(
name|lbn
operator|<=
name|lastlbn
operator|&&
name|lbn
operator|+
name|tmpval
operator|-
literal|1
operator|>
name|lastlbn
condition|)
name|setup_trunc_indir
argument_list|(
name|freeblks
argument_list|,
name|ip
argument_list|,
operator|-
name|lbn
operator|-
name|i
argument_list|,
name|lastlbn
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_ib
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Handle partial truncation to a frag boundary. 		 */
if|if
condition|(
name|frags
condition|)
block|{
name|ufs2_daddr_t
name|blkno
decl_stmt|;
name|long
name|oldfrags
decl_stmt|;
name|oldfrags
operator|=
name|blksize
argument_list|(
name|fs
argument_list|,
name|ip
argument_list|,
name|lastlbn
argument_list|)
expr_stmt|;
name|blkno
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_db
index|[
name|lastlbn
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkno
operator|&&
name|oldfrags
operator|!=
name|frags
condition|)
block|{
name|oldfrags
operator|-=
name|frags
expr_stmt|;
name|oldfrags
operator|=
name|numfrags
argument_list|(
name|fs
argument_list|,
name|oldfrags
argument_list|)
expr_stmt|;
name|blkno
operator|+=
name|numfrags
argument_list|(
name|fs
argument_list|,
name|frags
argument_list|)
expr_stmt|;
name|newfreework
argument_list|(
name|ump
argument_list|,
name|freeblks
argument_list|,
name|NULL
argument_list|,
name|lastlbn
argument_list|,
name|blkno
argument_list|,
name|oldfrags
argument_list|,
literal|0
argument_list|,
name|needj
argument_list|)
expr_stmt|;
if|if
condition|(
name|needj
condition|)
name|adjust_newfreework
argument_list|(
name|freeblks
argument_list|,
name|numfrags
argument_list|(
name|fs
argument_list|,
name|frags
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blkno
operator|==
literal|0
condition|)
name|allocblock
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * Add a journal record for partial truncate if we are 		 * handling indirect blocks.  Non-indirects need no extra 		 * journaling. 		 */
if|if
condition|(
name|length
operator|!=
literal|0
operator|&&
name|lastlbn
operator|>=
name|UFS_NDADDR
condition|)
block|{
name|ip
operator|->
name|i_flag
operator||=
name|IN_TRUNCATED
expr_stmt|;
name|newjtrunc
argument_list|(
name|freeblks
argument_list|,
name|length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|i_size
operator|=
name|length
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_size
argument_list|,
name|ip
operator|->
name|i_size
argument_list|)
expr_stmt|;
name|datablocks
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_blocks
argument_list|)
operator|-
name|extblocks
expr_stmt|;
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
name|datablocks
operator|=
name|blkcount
argument_list|(
name|fs
argument_list|,
name|datablocks
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|freeblks
operator|->
name|fb_len
operator|=
name|length
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|IO_EXT
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UFS_NXADDR
condition|;
name|i
operator|++
control|)
name|setup_freeext
argument_list|(
name|freeblks
argument_list|,
name|ip
argument_list|,
name|i
argument_list|,
name|needj
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_din2
operator|->
name|di_extsize
operator|=
literal|0
expr_stmt|;
name|datablocks
operator|+=
name|extblocks
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QUOTA
comment|/* Reference the quotas in case the block count is wrong in the end. */
name|quotaref
argument_list|(
name|vp
argument_list|,
name|freeblks
operator|->
name|fb_quota
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chkdq
argument_list|(
name|ip
argument_list|,
operator|-
name|datablocks
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|freeblks
operator|->
name|fb_chkcnt
operator|=
operator|-
name|datablocks
expr_stmt|;
name|UFS_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_pendingblocks
operator|+=
name|datablocks
expr_stmt|;
name|UFS_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_blocks
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_blocks
argument_list|)
operator|-
name|datablocks
argument_list|)
expr_stmt|;
comment|/* 	 * Handle truncation of incomplete alloc direct dependencies.  We 	 * hold the inode block locked to prevent incomplete dependencies 	 * from reaching the disk while we are eliminating those that 	 * have been truncated.  This is a partially inlined ffs_update(). 	 */
name|ufs_itimes
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator|&=
operator|~
operator|(
name|IN_LAZYACCESS
operator||
name|IN_LAZYMOD
operator||
name|IN_MODIFIED
operator|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|ump
operator|->
name|um_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_bsize
argument_list|,
name|cred
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|softdep_error
argument_list|(
literal|"softdep_journal_freeblocks"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|b_bufsize
operator|==
name|fs
operator|->
name|fs_bsize
condition|)
name|bp
operator|->
name|b_flags
operator||=
name|B_CLUSTEROK
expr_stmt|;
name|softdep_update_inodeblock
argument_list|(
name|ip
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ump
operator|->
name|um_fstype
operator|==
name|UFS1
condition|)
operator|*
operator|(
operator|(
expr|struct
name|ufs1_dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
operator|)
operator|=
operator|*
name|ip
operator|->
name|i_din1
expr_stmt|;
else|else
operator|*
operator|(
operator|(
expr|struct
name|ufs2_dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
operator|)
operator|=
operator|*
name|ip
operator|->
name|i_din2
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|IOSTARTED
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_setup_freeblocks: inode busy"
argument_list|)
expr_stmt|;
comment|/* 	 * Add the freeblks structure to the list of operations that 	 * must await the zero'ed inode being written to disk. If we 	 * still have a bitmap dependency (needj), then the inode 	 * has never been written to disk, so we can process the 	 * freeblks below once we have deleted the dependencies. 	 */
if|if
condition|(
name|needj
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|freeblks
operator|->
name|fb_list
argument_list|)
expr_stmt|;
else|else
name|freeblks
operator|->
name|fb_state
operator||=
name|COMPLETE
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|IO_NORMAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|adp
argument_list|,
argument|&inodedep->id_inoupdt
argument_list|,
argument|ad_next
argument_list|,
argument|adpn
argument_list|)
block|{
if|if
condition|(
name|adp
operator|->
name|ad_offset
operator|>
name|iboff
condition|)
name|cancel_allocdirect
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|,
name|adp
argument_list|,
name|freeblks
argument_list|)
expr_stmt|;
comment|/* 			 * Truncate the allocdirect.  We could eliminate 			 * or modify journal records as well. 			 */
elseif|else
if|if
condition|(
name|adp
operator|->
name|ad_offset
operator|==
name|iboff
operator|&&
name|frags
condition|)
name|adp
operator|->
name|ad_newsize
operator|=
name|frags
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|IO_EXT
operator|)
operator|!=
literal|0
condition|)
while|while
condition|(
operator|(
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cancel_allocdirect
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|,
name|adp
argument_list|,
name|freeblks
argument_list|)
expr_stmt|;
comment|/* 	 * Scan the bufwait list for newblock dependencies that will never 	 * make it to disk. 	 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|wk
argument_list|,
argument|&inodedep->id_bufwait
argument_list|,
argument|wk_list
argument_list|,
argument|wkn
argument_list|)
block|{
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|!=
name|D_ALLOCDIRECT
condition|)
continue|continue;
name|adp
operator|=
name|WK_ALLOCDIRECT
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|IO_NORMAL
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|adp
operator|->
name|ad_offset
operator|>
name|iboff
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|IO_EXT
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|adp
operator|->
name|ad_state
operator|&
name|EXTDATA
operator|)
operator|)
condition|)
block|{
name|cancel_jfreeblk
argument_list|(
name|freeblks
argument_list|,
name|adp
operator|->
name|ad_newblkno
argument_list|)
expr_stmt|;
name|cancel_newblk
argument_list|(
name|WK_NEWBLK
argument_list|(
name|wk
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|freeblks
operator|->
name|fb_jwork
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_freeworkhd
argument_list|,
name|wk
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Add journal work. 	 */
name|LIST_FOREACH
argument_list|(
argument|jblkdep
argument_list|,
argument|&freeblks->fb_jblkdephd
argument_list|,
argument|jb_deps
argument_list|)
name|add_to_journal
argument_list|(
operator|&
name|jblkdep
operator|->
name|jb_list
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Truncate dependency structures beyond length. 	 */
name|trunc_dependencies
argument_list|(
name|ip
argument_list|,
name|freeblks
argument_list|,
name|lastlbn
argument_list|,
name|frags
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * This is only set when we need to allocate a fragment because 	 * none existed at the end of a frag-sized file.  It handles only 	 * allocating a new, zero filled block. 	 */
if|if
condition|(
name|allocblock
condition|)
block|{
name|ip
operator|->
name|i_size
operator|=
name|length
operator|-
name|lastoff
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_size
argument_list|,
name|ip
operator|->
name|i_size
argument_list|)
expr_stmt|;
name|error
operator|=
name|UFS_BALLOC
argument_list|(
name|vp
argument_list|,
name|length
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|cred
argument_list|,
name|BA_CLRBUF
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|softdep_error
argument_list|(
literal|"softdep_journal_freeblks"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|->
name|i_size
operator|=
name|length
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_size
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|frags
argument_list|)
expr_stmt|;
name|ffs_update
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastoff
operator|!=
literal|0
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|int
name|size
decl_stmt|;
comment|/* 		 * Zero the end of a truncated frag or block. 		 */
name|size
operator|=
name|sblksize
argument_list|(
name|fs
argument_list|,
name|length
argument_list|,
name|lastlbn
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|lastlbn
argument_list|,
name|size
argument_list|,
name|cred
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|softdep_error
argument_list|(
literal|"softdep_journal_freeblks"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|lastoff
argument_list|,
name|size
operator|-
name|lastoff
argument_list|)
expr_stmt|;
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|inodedep
operator|->
name|id_freeblklst
argument_list|,
name|freeblks
argument_list|,
name|fb_next
argument_list|)
expr_stmt|;
name|freeblks
operator|->
name|fb_state
operator||=
name|DEPCOMPLETE
operator||
name|ONDEPLIST
expr_stmt|;
comment|/* 	 * We zero earlier truncations so they don't erroneously 	 * update i_blocks. 	 */
if|if
condition|(
name|freeblks
operator|->
name|fb_len
operator|==
literal|0
operator|&&
operator|(
name|flags
operator|&
name|IO_NORMAL
operator|)
operator|!=
literal|0
condition|)
name|TAILQ_FOREACH
argument_list|(
argument|fbn
argument_list|,
argument|&inodedep->id_freeblklst
argument_list|,
argument|fb_next
argument_list|)
name|fbn
operator|->
name|fb_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|freeblks
operator|->
name|fb_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|)
condition|)
name|freeblks
operator|->
name|fb_state
operator||=
name|INPROGRESS
expr_stmt|;
else|else
name|freeblks
operator|=
name|NULL
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeblks
condition|)
name|handle_workitem_freeblocks
argument_list|(
name|freeblks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|trunc_pages
argument_list|(
name|ip
argument_list|,
name|length
argument_list|,
name|extblocks
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush a JOP_SYNC to the journal.  */
end_comment

begin_function
name|void
name|softdep_journal_fsync
parameter_list|(
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|jfsync
modifier|*
name|jfsync
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|ITOUMP
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_journal_fsync called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_flag
operator|&
name|IN_TRUNCATED
operator|)
operator|==
literal|0
condition|)
return|return;
name|ip
operator|->
name|i_flag
operator|&=
operator|~
name|IN_TRUNCATED
expr_stmt|;
name|jfsync
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|jfsync
argument_list|)
argument_list|,
name|M_JFSYNC
argument_list|,
name|M_SOFTDEP_FLAGS
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|jfsync
operator|->
name|jfs_list
argument_list|,
name|D_JFSYNC
argument_list|,
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
expr_stmt|;
name|jfsync
operator|->
name|jfs_size
operator|=
name|ip
operator|->
name|i_size
expr_stmt|;
name|jfsync
operator|->
name|jfs_ino
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|add_to_journal
argument_list|(
operator|&
name|jfsync
operator|->
name|jfs_list
argument_list|)
expr_stmt|;
name|jwait
argument_list|(
operator|&
name|jfsync
operator|->
name|jfs_list
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Block de-allocation dependencies.  *   * When blocks are de-allocated, the on-disk pointers must be nullified before  * the blocks are made available for use by other files.  (The true  * requirement is that old pointers must be nullified before new on-disk  * pointers are set.  We chose this slightly more stringent requirement to  * reduce complexity.) Our implementation handles this dependency by updating  * the inode (or indirect block) appropriately but delaying the actual block  * de-allocation (i.e., freemap and free space count manipulation) until  * after the updated versions reach stable storage.  After the disk is  * updated, the blocks can be safely de-allocated whenever it is convenient.  * This implementation handles only the common case of reducing a file's  * length to zero. Other cases are handled by the conventional synchronous  * write approach.  *  * The ffs implementation with which we worked double-checks  * the state of the block pointers and file size as it reduces  * a file's length.  Some of this code is replicated here in our  * soft updates implementation.  The freeblks->fb_chkcnt field is  * used to transfer a part of this information to the procedure  * that eventually de-allocates the blocks.  *  * This routine should be called from the routine that shortens  * a file's length, before the inode's size or block pointers  * are modified. It will save the block pointer information for  * later release and zero the inode so that the calling routine  * can release it.  */
end_comment

begin_function
name|void
name|softdep_setup_freeblocks
parameter_list|(
name|ip
parameter_list|,
name|length
parameter_list|,
name|flags
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* The inode whose length is to be reduced */
name|off_t
name|length
decl_stmt|;
comment|/* The new length for the file */
name|int
name|flags
decl_stmt|;
comment|/* IO_EXT and/or IO_NORMAL */
block|{
name|struct
name|ufs1_dinode
modifier|*
name|dp1
decl_stmt|;
name|struct
name|ufs2_dinode
modifier|*
name|dp2
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ufs2_daddr_t
name|extblocks
decl_stmt|,
name|datablocks
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|delay
decl_stmt|,
name|error
decl_stmt|;
name|ufs_lbn_t
name|tmpval
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|ump
operator|=
name|ITOUMP
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|mp
operator|=
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_freeblocks called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"softdep_setup_freeblks: ip %d length %ld"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|length
operator|==
literal|0
argument_list|,
operator|(
literal|"softdep_setup_freeblocks: non-zero length"
operator|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bread
argument_list|(
name|ump
operator|->
name|um_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|softdep_error
argument_list|(
literal|"softdep_setup_freeblocks"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|freeblks
operator|=
name|newfreeblks
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|extblocks
operator|=
literal|0
expr_stmt|;
name|datablocks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_magic
operator|==
name|FS_UFS2_MAGIC
condition|)
name|extblocks
operator|=
name|btodb
argument_list|(
name|fragroundup
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_din2
operator|->
name|di_extsize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|IO_NORMAL
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UFS_NDADDR
condition|;
name|i
operator|++
control|)
name|setup_freedirect
argument_list|(
name|freeblks
argument_list|,
name|ip
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmpval
operator|=
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|,
name|lbn
operator|=
name|UFS_NDADDR
init|;
name|i
operator|<
name|UFS_NIADDR
condition|;
name|i
operator|++
operator|,
name|lbn
operator|+=
name|tmpval
operator|,
name|tmpval
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
control|)
name|setup_freeindir
argument_list|(
name|freeblks
argument_list|,
name|ip
argument_list|,
name|i
argument_list|,
operator|-
name|lbn
operator|-
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_size
operator|=
literal|0
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|datablocks
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_blocks
argument_list|)
operator|-
name|extblocks
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|IO_EXT
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UFS_NXADDR
condition|;
name|i
operator|++
control|)
name|setup_freeext
argument_list|(
name|freeblks
argument_list|,
name|ip
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_din2
operator|->
name|di_extsize
operator|=
literal|0
expr_stmt|;
name|datablocks
operator|+=
name|extblocks
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QUOTA
comment|/* Reference the quotas in case the block count is wrong in the end. */
name|quotaref
argument_list|(
name|ITOV
argument_list|(
name|ip
argument_list|)
argument_list|,
name|freeblks
operator|->
name|fb_quota
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chkdq
argument_list|(
name|ip
argument_list|,
operator|-
name|datablocks
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|freeblks
operator|->
name|fb_chkcnt
operator|=
operator|-
name|datablocks
expr_stmt|;
name|UFS_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_pendingblocks
operator|+=
name|datablocks
expr_stmt|;
name|UFS_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_blocks
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_blocks
argument_list|)
operator|-
name|datablocks
argument_list|)
expr_stmt|;
comment|/* 	 * Push the zero'ed inode to to its disk buffer so that we are free 	 * to delete its dependencies below. Once the dependencies are gone 	 * the buffer can be safely released. 	 */
if|if
condition|(
name|ump
operator|->
name|um_fstype
operator|==
name|UFS1
condition|)
block|{
name|dp1
operator|=
operator|(
operator|(
expr|struct
name|ufs1_dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
operator|)
expr_stmt|;
name|ip
operator|->
name|i_din1
operator|->
name|di_freelink
operator|=
name|dp1
operator|->
name|di_freelink
expr_stmt|;
operator|*
name|dp1
operator|=
operator|*
name|ip
operator|->
name|i_din1
expr_stmt|;
block|}
else|else
block|{
name|dp2
operator|=
operator|(
operator|(
expr|struct
name|ufs2_dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
operator|)
expr_stmt|;
name|ip
operator|->
name|i_din2
operator|->
name|di_freelink
operator|=
name|dp2
operator|->
name|di_freelink
expr_stmt|;
operator|*
name|dp2
operator|=
operator|*
name|ip
operator|->
name|i_din2
expr_stmt|;
block|}
comment|/* 	 * Find and eliminate any inode dependencies. 	 */
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|IOSTARTED
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_setup_freeblocks: inode busy"
argument_list|)
expr_stmt|;
comment|/* 	 * Add the freeblks structure to the list of operations that 	 * must await the zero'ed inode being written to disk. If we 	 * still have a bitmap dependency (delay == 0), then the inode 	 * has never been written to disk, so we can process the 	 * freeblks below once we have deleted the dependencies. 	 */
name|delay
operator|=
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|DEPCOMPLETE
operator|)
expr_stmt|;
if|if
condition|(
name|delay
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|freeblks
operator|->
name|fb_list
argument_list|)
expr_stmt|;
else|else
name|freeblks
operator|->
name|fb_state
operator||=
name|COMPLETE
expr_stmt|;
comment|/* 	 * Because the file length has been truncated to zero, any 	 * pending block allocation dependency structures associated 	 * with this inode are obsolete and can simply be de-allocated. 	 * We must first merge the two dependency lists to get rid of 	 * any duplicate freefrag structures, then purge the merged list. 	 * If we still have a bitmap dependency, then the inode has never 	 * been written to disk, so we can free any fragments without delay. 	 */
if|if
condition|(
name|flags
operator|&
name|IO_NORMAL
condition|)
block|{
name|merge_inode_lists
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|,
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cancel_allocdirect
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|,
name|adp
argument_list|,
name|freeblks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|IO_EXT
condition|)
block|{
name|merge_inode_lists
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newextupdt
argument_list|,
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cancel_allocdirect
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|,
name|adp
argument_list|,
name|freeblks
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|trunc_dependencies
argument_list|(
name|ip
argument_list|,
name|freeblks
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|free_inodedep
argument_list|(
name|inodedep
argument_list|)
expr_stmt|;
name|freeblks
operator|->
name|fb_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
comment|/* 	 * If the inode with zeroed block pointers is now on disk 	 * we can start freeing blocks. 	 */
if|if
condition|(
operator|(
name|freeblks
operator|->
name|fb_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
name|freeblks
operator|->
name|fb_state
operator||=
name|INPROGRESS
expr_stmt|;
else|else
name|freeblks
operator|=
name|NULL
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeblks
condition|)
name|handle_workitem_freeblocks
argument_list|(
name|freeblks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|trunc_pages
argument_list|(
name|ip
argument_list|,
name|length
argument_list|,
name|extblocks
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Eliminate pages from the page cache that back parts of this inode and  * adjust the vnode pager's idea of our size.  This prevents stale data  * from hanging around in the page cache.  */
end_comment

begin_function
specifier|static
name|void
name|trunc_pages
parameter_list|(
name|ip
parameter_list|,
name|length
parameter_list|,
name|extblocks
parameter_list|,
name|flags
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|off_t
name|length
decl_stmt|;
name|ufs2_daddr_t
name|extblocks
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|off_t
name|end
decl_stmt|,
name|extend
decl_stmt|;
name|vp
operator|=
name|ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ITOFS
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|extend
operator|=
name|OFF_TO_IDX
argument_list|(
name|lblktosize
argument_list|(
name|fs
argument_list|,
operator|-
name|extblocks
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|IO_EXT
operator|)
operator|!=
literal|0
condition|)
name|vn_pages_remove
argument_list|(
name|vp
argument_list|,
name|extend
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|IO_NORMAL
operator|)
operator|==
literal|0
condition|)
return|return;
name|BO_LOCK
argument_list|(
operator|&
name|vp
operator|->
name|v_bufobj
argument_list|)
expr_stmt|;
name|drain_output
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|BO_UNLOCK
argument_list|(
operator|&
name|vp
operator|->
name|v_bufobj
argument_list|)
expr_stmt|;
comment|/* 	 * The vnode pager eliminates file pages we eliminate indirects 	 * below. 	 */
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the end based on the last indirect we want to keep.  If 	 * the block extends into indirects we can just use the negative of 	 * its lbn.  Doubles and triples exist at lower numbers so we must 	 * be careful not to remove those, if they exist.  double and triple 	 * indirect lbns do not overlap with others so it is not important 	 * to verify how many levels are required. 	 */
name|lbn
operator|=
name|lblkno
argument_list|(
name|fs
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbn
operator|>=
name|UFS_NDADDR
condition|)
block|{
comment|/* Calculate the virtual lbn of the triple indirect. */
name|lbn
operator|=
operator|-
name|lbn
operator|-
operator|(
name|UFS_NIADDR
operator|-
literal|1
operator|)
expr_stmt|;
name|end
operator|=
name|OFF_TO_IDX
argument_list|(
name|lblktosize
argument_list|(
name|fs
argument_list|,
name|lbn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|end
operator|=
name|extend
expr_stmt|;
name|vn_pages_remove
argument_list|(
name|vp
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|OFF_MAX
argument_list|)
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * See if the buf bp is in the range eliminated by truncation.  */
end_comment

begin_function
specifier|static
name|int
name|trunc_check_buf
parameter_list|(
name|bp
parameter_list|,
name|blkoffp
parameter_list|,
name|lastlbn
parameter_list|,
name|lastoff
parameter_list|,
name|flags
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
modifier|*
name|blkoffp
decl_stmt|;
name|ufs_lbn_t
name|lastlbn
decl_stmt|;
name|int
name|lastoff
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|ufs_lbn_t
name|lbn
decl_stmt|;
operator|*
name|blkoffp
operator|=
literal|0
expr_stmt|;
comment|/* Only match ext/normal blocks as appropriate. */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|IO_EXT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|bp
operator|->
name|b_xflags
operator|&
name|BX_ALTDATA
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|IO_NORMAL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|bp
operator|->
name|b_xflags
operator|&
name|BX_ALTDATA
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ALTDATA is always a full truncation. */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_xflags
operator|&
name|BX_ALTDATA
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* -1 is full truncation. */
if|if
condition|(
name|lastlbn
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If this is a partial truncate we only want those 	 * blocks and indirect blocks that cover the range 	 * we're after. 	 */
name|lbn
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
literal|0
condition|)
name|lbn
operator|=
operator|-
operator|(
name|lbn
operator|+
name|lbn_level
argument_list|(
name|lbn
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|lbn
operator|<
name|lastlbn
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Here we only truncate lblkno if it's partial. */
if|if
condition|(
name|lbn
operator|==
name|lastlbn
condition|)
block|{
if|if
condition|(
name|lastoff
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|blkoffp
operator|=
name|lastoff
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Eliminate any dependencies that exist in memory beyond lblkno:off  */
end_comment

begin_function
specifier|static
name|void
name|trunc_dependencies
parameter_list|(
name|ip
parameter_list|,
name|freeblks
parameter_list|,
name|lastlbn
parameter_list|,
name|lastoff
parameter_list|,
name|flags
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|ufs_lbn_t
name|lastlbn
decl_stmt|;
name|int
name|lastoff
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|blkoff
decl_stmt|;
comment|/* 	 * We must wait for any I/O in progress to finish so that 	 * all potential buffers on the dirty list will be visible. 	 * Once they are all there, walk the list and get rid of 	 * any dependencies. 	 */
name|vp
operator|=
name|ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|bo
operator|=
operator|&
name|vp
operator|->
name|v_bufobj
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|drain_output
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bo->bo_dirty.bv_hd
argument_list|,
argument|b_bobufs
argument_list|)
name|bp
operator|->
name|b_vflags
operator|&=
operator|~
name|BV_SCANNED
expr_stmt|;
name|restart
label|:
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bo->bo_dirty.bv_hd
argument_list|,
argument|b_bobufs
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_vflags
operator|&
name|BV_SCANNED
condition|)
continue|continue;
if|if
condition|(
operator|!
name|trunc_check_buf
argument_list|(
name|bp
argument_list|,
operator|&
name|blkoff
argument_list|,
name|lastlbn
argument_list|,
name|lastoff
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_vflags
operator||=
name|BV_SCANNED
expr_stmt|;
continue|continue;
block|}
name|KASSERT
argument_list|(
name|bp
operator|->
name|b_bufobj
operator|==
name|bo
argument_list|,
operator|(
literal|"Wrong object in buffer"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|getdirtybuf
argument_list|(
name|bp
argument_list|,
name|BO_LOCKPTR
argument_list|(
name|bo
argument_list|)
argument_list|,
name|MNT_WAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|restart
goto|;
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
if|if
condition|(
name|deallocate_dependencies
argument_list|(
name|bp
argument_list|,
name|freeblks
argument_list|,
name|blkoff
argument_list|)
condition|)
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* 	 * Now do the work of vtruncbuf while also matching indirect blocks. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bo->bo_clean.bv_hd
argument_list|,
argument|b_bobufs
argument_list|)
name|bp
operator|->
name|b_vflags
operator|&=
operator|~
name|BV_SCANNED
expr_stmt|;
name|cleanrestart
label|:
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bo->bo_clean.bv_hd
argument_list|,
argument|b_bobufs
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_vflags
operator|&
name|BV_SCANNED
condition|)
continue|continue;
if|if
condition|(
operator|!
name|trunc_check_buf
argument_list|(
name|bp
argument_list|,
operator|&
name|blkoff
argument_list|,
name|lastlbn
argument_list|,
name|lastoff
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_vflags
operator||=
name|BV_SCANNED
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_SLEEPFAIL
operator||
name|LK_INTERLOCK
argument_list|,
name|BO_LOCKPTR
argument_list|(
name|bo
argument_list|)
argument_list|)
operator|==
name|ENOLCK
condition|)
block|{
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
goto|goto
name|cleanrestart
goto|;
block|}
name|bp
operator|->
name|b_vflags
operator||=
name|BV_SCANNED
expr_stmt|;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkoff
operator|!=
literal|0
condition|)
block|{
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|blkoff
argument_list|)
expr_stmt|;
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_NOCACHE
operator||
name|B_RELBUF
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
goto|goto
name|cleanrestart
goto|;
block|}
name|drain_output
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cancel_pagedep
parameter_list|(
name|pagedep
parameter_list|,
name|freeblks
parameter_list|,
name|blkoff
parameter_list|)
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|int
name|blkoff
decl_stmt|;
block|{
name|struct
name|jremref
modifier|*
name|jremref
decl_stmt|;
name|struct
name|jmvref
modifier|*
name|jmvref
decl_stmt|;
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Copy any directory remove dependencies to the list 	 * to be processed after the freeblks proceeds.  If 	 * directory entry never made it to disk they 	 * can be dumped directly onto the work list. 	 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|dirrem
argument_list|,
argument|&pagedep->pd_dirremhd
argument_list|,
argument|dm_next
argument_list|,
argument|tmp
argument_list|)
block|{
comment|/* Skip this directory removal if it is intended to remain. */
if|if
condition|(
name|dirrem
operator|->
name|dm_offset
operator|<
name|blkoff
condition|)
continue|continue;
comment|/* 		 * If there are any dirrems we wait for the journal write 		 * to complete and then restart the buf scan as the lock 		 * has been dropped. 		 */
while|while
condition|(
operator|(
name|jremref
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jremrefhd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|jwait
argument_list|(
operator|&
name|jremref
operator|->
name|jr_list
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
name|LIST_REMOVE
argument_list|(
name|dirrem
argument_list|,
name|dm_next
argument_list|)
expr_stmt|;
name|dirrem
operator|->
name|dm_dirinum
operator|=
name|pagedep
operator|->
name|pd_ino
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_freeworkhd
argument_list|,
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|jmvref
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_jmvrefhd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|jwait
argument_list|(
operator|&
name|jmvref
operator|->
name|jm_list
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
comment|/* 	 * When we're partially truncating a pagedep we just want to flush 	 * journal entries and return.  There can not be any adds in the 	 * truncated portion of the directory and newblk must remain if 	 * part of the block remains. 	 */
if|if
condition|(
name|blkoff
operator|!=
literal|0
condition|)
block|{
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|dap
argument_list|,
argument|&pagedep->pd_pendinghd
argument_list|,
argument|da_pdlist
argument_list|)
if|if
condition|(
name|dap
operator|->
name|da_offset
operator|>
name|blkoff
condition|)
name|panic
argument_list|(
literal|"cancel_pagedep: diradd %p off %d> %d"
argument_list|,
name|dap
argument_list|,
name|dap
operator|->
name|da_offset
argument_list|,
name|blkoff
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DAHASHSZ
condition|;
name|i
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|dap
argument_list|,
argument|&pagedep->pd_diraddhd[i]
argument_list|,
argument|da_pdlist
argument_list|)
if|if
condition|(
name|dap
operator|->
name|da_offset
operator|>
name|blkoff
condition|)
name|panic
argument_list|(
literal|"cancel_pagedep: diradd %p off %d> %d"
argument_list|,
name|dap
argument_list|,
name|dap
operator|->
name|da_offset
argument_list|,
name|blkoff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * There should be no directory add dependencies present 	 * as the directory could not be truncated until all 	 * children were removed. 	 */
name|KASSERT
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"deallocate_dependencies: pendinghd != NULL"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DAHASHSZ
condition|;
name|i
operator|++
control|)
name|KASSERT
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|i
index|]
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"deallocate_dependencies: diraddhd != NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pagedep
operator|->
name|pd_state
operator|&
name|NEWBLOCK
operator|)
operator|!=
literal|0
condition|)
name|free_newdirblk
argument_list|(
name|pagedep
operator|->
name|pd_newdirblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_pagedep
argument_list|(
name|pagedep
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"Failed to free pagedep %p"
argument_list|,
name|pagedep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim any dependency structures from a buffer that is about to  * be reallocated to a new vnode. The buffer must be locked, thus,  * no I/O completion operations can occur while we are manipulating  * its associated dependencies. The mutex is held so that other I/O's  * associated with related dependencies do not occur.  */
end_comment

begin_function
specifier|static
name|int
name|deallocate_dependencies
parameter_list|(
name|bp
parameter_list|,
name|freeblks
parameter_list|,
name|off
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|int
name|off
decl_stmt|;
block|{
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|,
modifier|*
name|wkn
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|wk
argument_list|,
argument|&bp->b_dep
argument_list|,
argument|wk_list
argument_list|,
argument|wkn
argument_list|)
block|{
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_INDIRDEP
case|:
name|indirdep
operator|=
name|WK_INDIRDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_lblkno
operator|>=
literal|0
operator|||
name|bp
operator|->
name|b_blkno
operator|!=
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_lblkno
condition|)
name|panic
argument_list|(
literal|"deallocate_dependencies: not indir"
argument_list|)
expr_stmt|;
name|cancel_indirdep
argument_list|(
name|indirdep
argument_list|,
name|bp
argument_list|,
name|freeblks
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_PAGEDEP
case|:
name|pagedep
operator|=
name|WK_PAGEDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_pagedep
argument_list|(
name|pagedep
argument_list|,
name|freeblks
argument_list|,
name|off
argument_list|)
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
continue|continue;
case|case
name|D_ALLOCINDIR
case|:
comment|/* 			 * Simply remove the allocindir, we'll find it via 			 * the indirdep where we can clear pointers if 			 * needed. 			 */
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_FREEWORK
case|:
comment|/* 			 * A truncation is waiting for the zero'd pointers 			 * to be written.  It can be freed when the freeblks 			 * is journaled. 			 */
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|wk
operator|->
name|wk_state
operator||=
name|ONDEPLIST
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_freeworkhd
argument_list|,
name|wk
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_ALLOCDIRECT
case|:
if|if
condition|(
name|off
operator|!=
literal|0
condition|)
continue|continue;
comment|/* FALLTHROUGH */
default|default:
name|panic
argument_list|(
literal|"deallocate_dependencies: Unexpected type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* 	 * Don't throw away this buf, we were partially truncating and 	 * some deps may always remain. 	 */
if|if
condition|(
name|off
condition|)
block|{
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_vflags
operator||=
name|BV_SCANNED
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_NOCACHE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * An allocdirect is being canceled due to a truncate.  We must make sure  * the journal entry is released in concert with the blkfree that releases  * the storage.  Completed journal entries must not be released until the  * space is no longer pointed to by the inode or in the bitmap.  */
end_comment

begin_function
specifier|static
name|void
name|cancel_allocdirect
parameter_list|(
name|adphead
parameter_list|,
name|adp
parameter_list|,
name|freeblks
parameter_list|)
name|struct
name|allocdirectlst
modifier|*
name|adphead
decl_stmt|;
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
block|{
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|adphead
argument_list|,
name|adp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
name|newblk
operator|=
operator|(
expr|struct
name|newblk
operator|*
operator|)
name|adp
expr_stmt|;
name|freework
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Find the correct freework structure. 	 */
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&freeblks->fb_freeworkhd
argument_list|,
argument|wk_list
argument_list|)
block|{
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|!=
name|D_FREEWORK
condition|)
continue|continue;
name|freework
operator|=
name|WK_FREEWORK
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|freework
operator|->
name|fw_blkno
operator|==
name|newblk
operator|->
name|nb_newblkno
condition|)
break|break;
block|}
if|if
condition|(
name|freework
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"cancel_allocdirect: Freework not found"
argument_list|)
expr_stmt|;
comment|/* 	 * If a newblk exists at all we still have the journal entry that 	 * initiated the allocation so we do not need to journal the free. 	 */
name|cancel_jfreeblk
argument_list|(
name|freeblks
argument_list|,
name|freework
operator|->
name|fw_blkno
argument_list|)
expr_stmt|;
comment|/* 	 * If the journal hasn't been written the jnewblk must be passed 	 * to the call to ffs_blkfree that reclaims the space.  We accomplish 	 * this by linking the journal dependency into the freework to be 	 * freed when freework_freeblock() is called.  If the journal has 	 * been written we can simply reclaim the journal space when the 	 * freeblks work is complete. 	 */
name|freework
operator|->
name|fw_jnewblk
operator|=
name|cancel_newblk
argument_list|(
name|newblk
argument_list|,
operator|&
name|freework
operator|->
name|fw_list
argument_list|,
operator|&
name|freeblks
operator|->
name|fb_jwork
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_freeworkhd
argument_list|,
operator|&
name|newblk
operator|->
name|nb_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cancel a new block allocation.  May be an indirect or direct block.  We  * remove it from various lists and return any journal record that needs to  * be resolved by the caller.  *  * A special consideration is made for indirects which were never pointed  * at on disk and will never be found once this block is released.  */
end_comment

begin_function
specifier|static
name|struct
name|jnewblk
modifier|*
name|cancel_newblk
parameter_list|(
name|newblk
parameter_list|,
name|wk
parameter_list|,
name|wkhd
parameter_list|)
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|;
name|CTR1
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"cancel_newblk: blkno %jd"
argument_list|,
name|newblk
operator|->
name|nb_newblkno
argument_list|)
expr_stmt|;
name|newblk
operator|->
name|nb_state
operator||=
name|GOINGAWAY
expr_stmt|;
comment|/* 	 * Previously we traversed the completedhd on each indirdep 	 * attached to this newblk to cancel them and gather journal 	 * work.  Since we need only the oldest journal segment and 	 * the lowest point on the tree will always have the oldest 	 * journal segment we are free to release the segments 	 * of any subordinates and may leave the indirdep list to 	 * indirdep_complete() when this newblk is freed. 	 */
if|if
condition|(
name|newblk
operator|->
name|nb_state
operator|&
name|ONDEPLIST
condition|)
block|{
name|newblk
operator|->
name|nb_state
operator|&=
operator|~
name|ONDEPLIST
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|newblk
argument_list|,
name|nb_deps
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newblk
operator|->
name|nb_state
operator|&
name|ONWORKLIST
condition|)
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|newblk
operator|->
name|nb_list
argument_list|)
expr_stmt|;
comment|/* 	 * If the journal entry hasn't been written we save a pointer to 	 * the dependency that frees it until it is written or the 	 * superseding operation completes. 	 */
name|jnewblk
operator|=
name|newblk
operator|->
name|nb_jnewblk
expr_stmt|;
if|if
condition|(
name|jnewblk
operator|!=
name|NULL
operator|&&
name|wk
operator|!=
name|NULL
condition|)
block|{
name|newblk
operator|->
name|nb_jnewblk
operator|=
name|NULL
expr_stmt|;
name|jnewblk
operator|->
name|jn_dep
operator|=
name|wk
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|newblk
operator|->
name|nb_jwork
argument_list|)
condition|)
name|jwork_move
argument_list|(
name|wkhd
argument_list|,
operator|&
name|newblk
operator|->
name|nb_jwork
argument_list|)
expr_stmt|;
comment|/* 	 * When truncating we must free the newdirblk early to remove 	 * the pagedep from the hash before returning. 	 */
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|newblk
operator|->
name|nb_newdirblk
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|free_newdirblk
argument_list|(
name|WK_NEWDIRBLK
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|newblk
operator|->
name|nb_newdirblk
argument_list|)
condition|)
name|panic
argument_list|(
literal|"cancel_newblk: extra newdirblk"
argument_list|)
expr_stmt|;
return|return
operator|(
name|jnewblk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Schedule the freefrag associated with a newblk to be released once  * the pointers are written and the previous block is no longer needed.  */
end_comment

begin_function
specifier|static
name|void
name|newblk_freefrag
parameter_list|(
name|newblk
parameter_list|)
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
block|{
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
if|if
condition|(
name|newblk
operator|->
name|nb_freefrag
operator|==
name|NULL
condition|)
return|return;
name|freefrag
operator|=
name|newblk
operator|->
name|nb_freefrag
expr_stmt|;
name|newblk
operator|->
name|nb_freefrag
operator|=
name|NULL
expr_stmt|;
name|freefrag
operator|->
name|ff_state
operator||=
name|COMPLETE
expr_stmt|;
if|if
condition|(
operator|(
name|freefrag
operator|->
name|ff_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
name|add_to_worklist
argument_list|(
operator|&
name|freefrag
operator|->
name|ff_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a newblk. Generate a new freefrag work request if appropriate.  * This must be called after the inode pointer and any direct block pointers  * are valid or fully removed via truncate or frag extension.  */
end_comment

begin_function
specifier|static
name|void
name|free_newblk
parameter_list|(
name|newblk
parameter_list|)
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
block|{
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|KASSERT
argument_list|(
name|newblk
operator|->
name|nb_jnewblk
operator|==
name|NULL
argument_list|,
operator|(
literal|"free_newblk: jnewblk %p still attached"
operator|,
name|newblk
operator|->
name|nb_jnewblk
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|newblk
operator|->
name|nb_list
operator|.
name|wk_type
operator|!=
name|D_NEWBLK
argument_list|,
operator|(
literal|"free_newblk: unclaimed newblk"
operator|)
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|VFSTOUFS
argument_list|(
name|newblk
operator|->
name|nb_list
operator|.
name|wk_mp
argument_list|)
argument_list|)
expr_stmt|;
name|newblk_freefrag
argument_list|(
name|newblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|newblk
operator|->
name|nb_state
operator|&
name|ONDEPLIST
condition|)
name|LIST_REMOVE
argument_list|(
name|newblk
argument_list|,
name|nb_deps
argument_list|)
expr_stmt|;
if|if
condition|(
name|newblk
operator|->
name|nb_state
operator|&
name|ONWORKLIST
condition|)
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|newblk
operator|->
name|nb_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|newblk
argument_list|,
name|nb_hash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|newblk
operator|->
name|nb_newdirblk
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|free_newdirblk
argument_list|(
name|WK_NEWDIRBLK
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|newblk
operator|->
name|nb_newdirblk
argument_list|)
condition|)
name|panic
argument_list|(
literal|"free_newblk: extra newdirblk"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|indirdep
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|newblk
operator|->
name|nb_indirdeps
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|indirdep_complete
argument_list|(
name|indirdep
argument_list|)
expr_stmt|;
name|handle_jwork
argument_list|(
operator|&
name|newblk
operator|->
name|nb_jwork
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|newblk
argument_list|,
name|D_NEWBLK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a newdirblk. Clear the NEWBLOCK flag on its associated pagedep.  * This routine must be called with splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|void
name|free_newdirblk
parameter_list|(
name|newdirblk
parameter_list|)
name|struct
name|newdirblk
modifier|*
name|newdirblk
decl_stmt|;
block|{
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|LOCK_OWNED
argument_list|(
name|VFSTOUFS
argument_list|(
name|newdirblk
operator|->
name|db_list
operator|.
name|wk_mp
argument_list|)
argument_list|)
expr_stmt|;
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|newdirblk
operator|->
name|db_list
argument_list|)
expr_stmt|;
comment|/* 	 * If the pagedep is still linked onto the directory buffer 	 * dependency chain, then some of the entries on the 	 * pd_pendinghd list may not be committed to disk yet. In 	 * this case, we will simply clear the NEWBLOCK flag and 	 * let the pd_pendinghd list be processed when the pagedep 	 * is next written. If the pagedep is no longer on the buffer 	 * dependency chain, then all the entries on the pd_pending 	 * list are committed to disk and we can free them here. 	 */
name|pagedep
operator|=
name|newdirblk
operator|->
name|db_pagedep
expr_stmt|;
name|pagedep
operator|->
name|pd_state
operator|&=
operator|~
name|NEWBLOCK
expr_stmt|;
if|if
condition|(
operator|(
name|pagedep
operator|->
name|pd_state
operator|&
name|ONWORKLIST
operator|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|dap
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|free_diradd
argument_list|(
name|dap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * If no dependencies remain, the pagedep will be freed. 		 */
name|free_pagedep
argument_list|(
name|pagedep
argument_list|)
expr_stmt|;
block|}
comment|/* Should only ever be one item in the list. */
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|newdirblk
operator|->
name|db_mkdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|handle_written_mkdir
argument_list|(
name|WK_MKDIR
argument_list|(
name|wk
argument_list|)
argument_list|,
name|MKDIR_BODY
argument_list|)
expr_stmt|;
block|}
name|WORKITEM_FREE
argument_list|(
name|newdirblk
argument_list|,
name|D_NEWDIRBLK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prepare an inode to be freed. The actual free operation is not  * done until the zero'ed inode has been written to disk.  */
end_comment

begin_function
name|void
name|softdep_freefile
parameter_list|(
name|pvp
parameter_list|,
name|ino
parameter_list|,
name|mode
parameter_list|)
name|struct
name|vnode
modifier|*
name|pvp
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|struct
name|inode
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|pvp
argument_list|)
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|freefile
modifier|*
name|freefile
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|ITOUMP
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_freefile called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * This sets up the inode de-allocation dependency. 	 */
name|freefile
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|freefile
argument_list|)
argument_list|,
name|M_FREEFILE
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|freefile
operator|->
name|fx_list
argument_list|,
name|D_FREEFILE
argument_list|,
name|pvp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|freefile
operator|->
name|fx_mode
operator|=
name|mode
expr_stmt|;
name|freefile
operator|->
name|fx_oldinum
operator|=
name|ino
expr_stmt|;
name|freefile
operator|->
name|fx_devvp
operator|=
name|ump
operator|->
name|um_devvp
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|freefile
operator|->
name|fx_jwork
argument_list|)
expr_stmt|;
name|UFS_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|ump
operator|->
name|um_fs
operator|->
name|fs_pendinginodes
operator|+=
literal|1
expr_stmt|;
name|UFS_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * If the inodedep does not exist, then the zero'ed inode has 	 * been written to disk. If the allocated inode has never been 	 * written to disk, then the on-disk inode is zero'ed. In either 	 * case we can free the file immediately.  If the journal was 	 * canceled before being written the inode will never make it to 	 * disk and we must send the canceled journal entrys to 	 * ffs_freefile() to be cleared in conjunction with the bitmap. 	 * Any blocks waiting on the inode to write can be safely freed 	 * here as it will never been written. 	 */
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|inodedep_lookup
argument_list|(
name|pvp
operator|->
name|v_mount
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep
condition|)
block|{
comment|/* 		 * Clear out freeblks that no longer need to reference 		 * this inode. 		 */
while|while
condition|(
operator|(
name|freeblks
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_freeblklst
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inodedep
operator|->
name|id_freeblklst
argument_list|,
name|freeblks
argument_list|,
name|fb_next
argument_list|)
expr_stmt|;
name|freeblks
operator|->
name|fb_state
operator|&=
operator|~
name|ONDEPLIST
expr_stmt|;
block|}
comment|/* 		 * Remove this inode from the unlinked list. 		 */
if|if
condition|(
name|inodedep
operator|->
name|id_state
operator|&
name|UNLINKED
condition|)
block|{
comment|/* 			 * Save the journal work to be freed with the bitmap 			 * before we clear UNLINKED.  Otherwise it can be lost 			 * if the inode block is written. 			 */
name|handle_bufwait
argument_list|(
name|inodedep
argument_list|,
operator|&
name|freefile
operator|->
name|fx_jwork
argument_list|)
expr_stmt|;
name|clear_unlinked_inodedep
argument_list|(
name|inodedep
argument_list|)
expr_stmt|;
comment|/* 			 * Re-acquire inodedep as we've dropped the 			 * per-filesystem lock in clear_unlinked_inodedep(). 			 */
name|inodedep_lookup
argument_list|(
name|pvp
operator|->
name|v_mount
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|inodedep
operator|==
name|NULL
operator|||
name|check_inode_unwritten
argument_list|(
name|inodedep
argument_list|)
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|handle_workitem_freefile
argument_list|(
name|freefile
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|DEPCOMPLETE
operator|)
operator|==
literal|0
condition|)
name|inodedep
operator|->
name|id_state
operator||=
name|GOINGAWAY
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|,
operator|&
name|freefile
operator|->
name|fx_list
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_number
operator|==
name|ino
condition|)
name|ip
operator|->
name|i_flag
operator||=
name|IN_MODIFIED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if an inode has never been written to disk. If  * so free the inodedep and return success, otherwise return failure.  * This routine must be called with splbio interrupts blocked.  *  * If we still have a bitmap dependency, then the inode has never  * been written to disk. Drop the dependency as it is no longer  * necessary since the inode is being deallocated. We set the  * ALLCOMPLETE flags since the bitmap now properly shows that the  * inode is not allocated. Even if the inode is actively being  * written, it has been rolled back to its zero'ed state, so we  * are ensured that a zero inode is what is on the disk. For short  * lived files, this change will usually result in removing all the  * dependencies from the inode so that it can be freed immediately.  */
end_comment

begin_function
specifier|static
name|int
name|check_inode_unwritten
parameter_list|(
name|inodedep
parameter_list|)
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
block|{
name|LOCK_OWNED
argument_list|(
name|VFSTOUFS
argument_list|(
name|inodedep
operator|->
name|id_list
operator|.
name|wk_mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
operator|(
name|DEPCOMPLETE
operator||
name|UNLINKED
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_dirremhd
argument_list|)
operator|||
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_pendinghd
argument_list|)
operator|||
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|)
operator|||
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newextupdt
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_freeblklst
argument_list|)
operator|||
name|inodedep
operator|->
name|id_mkdiradd
operator|!=
name|NULL
operator|||
name|inodedep
operator|->
name|id_nlinkdelta
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Another process might be in initiate_write_inodeblock_ufs[12] 	 * trying to allocate memory without holding "Softdep Lock". 	 */
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|IOSTARTED
operator|)
operator|!=
literal|0
operator|&&
name|inodedep
operator|->
name|id_savedino1
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|inodedep
operator|->
name|id_state
operator|&
name|ONDEPLIST
condition|)
name|LIST_REMOVE
argument_list|(
name|inodedep
argument_list|,
name|id_deps
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator|&=
operator|~
name|ONDEPLIST
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator||=
name|ALLCOMPLETE
expr_stmt|;
name|inodedep
operator|->
name|id_bmsafemap
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|inodedep
operator|->
name|id_state
operator|&
name|ONWORKLIST
condition|)
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|inodedep
operator|->
name|id_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep
operator|->
name|id_savedino1
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|inodedep
operator|->
name|id_savedino1
argument_list|,
name|M_SAVEDINO
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_savedino1
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|free_inodedep
argument_list|(
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"check_inode_unwritten: busy inode"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_inodedep_free
parameter_list|(
name|inodedep
parameter_list|)
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
block|{
name|LOCK_OWNED
argument_list|(
name|VFSTOUFS
argument_list|(
name|inodedep
operator|->
name|id_list
operator|.
name|wk_mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|ALLCOMPLETE
operator|)
operator|!=
name|ALLCOMPLETE
operator|||
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_dirremhd
argument_list|)
operator|||
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_pendinghd
argument_list|)
operator|||
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|)
operator|||
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newextupdt
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_freeblklst
argument_list|)
operator|||
name|inodedep
operator|->
name|id_mkdiradd
operator|!=
name|NULL
operator|||
name|inodedep
operator|->
name|id_nlinkdelta
operator|!=
literal|0
operator|||
name|inodedep
operator|->
name|id_savedino1
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to free an inodedep structure. Return 1 if it could be freed.  */
end_comment

begin_function
specifier|static
name|int
name|free_inodedep
parameter_list|(
name|inodedep
parameter_list|)
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
block|{
name|LOCK_OWNED
argument_list|(
name|VFSTOUFS
argument_list|(
name|inodedep
operator|->
name|id_list
operator|.
name|wk_mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
operator|(
name|ONWORKLIST
operator||
name|UNLINKED
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|!
name|check_inodedep_free
argument_list|(
name|inodedep
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|inodedep
operator|->
name|id_state
operator|&
name|ONDEPLIST
condition|)
name|LIST_REMOVE
argument_list|(
name|inodedep
argument_list|,
name|id_deps
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|inodedep
argument_list|,
name|id_hash
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|inodedep
argument_list|,
name|D_INODEDEP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the block referenced by a freework structure.  The parent freeblks  * structure is released and completed when the final cg bitmap reaches  * the disk.  This routine may be freeing a jnewblk which never made it to  * disk in which case we do not have to wait as the operation is undone  * in memory immediately.  */
end_comment

begin_function
specifier|static
name|void
name|freework_freeblock
parameter_list|(
name|freework
parameter_list|)
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
block|{
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|workhead
name|wkhd
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|int
name|needj
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|freework
operator|->
name|fw_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * Handle partial truncate separately. 	 */
if|if
condition|(
name|freework
operator|->
name|fw_indir
condition|)
block|{
name|complete_trunc_indir
argument_list|(
name|freework
argument_list|)
expr_stmt|;
return|return;
block|}
name|freeblks
operator|=
name|freework
operator|->
name|fw_freeblks
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
name|needj
operator|=
name|MOUNTEDSUJ
argument_list|(
name|freeblks
operator|->
name|fb_list
operator|.
name|wk_mp
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|bsize
operator|=
name|lfragtosize
argument_list|(
name|fs
argument_list|,
name|freework
operator|->
name|fw_frags
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|wkhd
argument_list|)
expr_stmt|;
comment|/* 	 * DEPCOMPLETE is cleared in indirblk_insert() if the block lives 	 * on the indirblk hashtable and prevents premature freeing. 	 */
name|freework
operator|->
name|fw_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
comment|/* 	 * SUJ needs to wait for the segment referencing freed indirect 	 * blocks to expire so that we know the checker will not confuse 	 * a re-allocated indirect block with its old contents. 	 */
if|if
condition|(
name|needj
operator|&&
name|freework
operator|->
name|fw_lbn
operator|<=
operator|-
name|UFS_NDADDR
condition|)
name|indirblk_insert
argument_list|(
name|freework
argument_list|)
expr_stmt|;
comment|/* 	 * If we are canceling an existing jnewblk pass it to the free 	 * routine, otherwise pass the freeblk which will ultimately 	 * release the freeblks.  If we're not journaling, we can just 	 * free the freeblks immediately. 	 */
name|jnewblk
operator|=
name|freework
operator|->
name|fw_jnewblk
expr_stmt|;
if|if
condition|(
name|jnewblk
operator|!=
name|NULL
condition|)
block|{
name|cancel_jnewblk
argument_list|(
name|jnewblk
argument_list|,
operator|&
name|wkhd
argument_list|)
expr_stmt|;
name|needj
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|needj
condition|)
block|{
name|freework
operator|->
name|fw_state
operator||=
name|DELAYEDFREE
expr_stmt|;
name|freeblks
operator|->
name|fb_cgwait
operator|++
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|wkhd
argument_list|,
operator|&
name|freework
operator|->
name|fw_list
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|freeblks_free
argument_list|(
name|ump
argument_list|,
name|freeblks
argument_list|,
name|btodb
argument_list|(
name|bsize
argument_list|)
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"freework_freeblock: ino %d blkno %jd lbn %jd size %ld"
argument_list|,
name|freeblks
operator|->
name|fb_inum
argument_list|,
name|freework
operator|->
name|fw_blkno
argument_list|,
name|freework
operator|->
name|fw_lbn
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|ffs_blkfree
argument_list|(
name|ump
argument_list|,
name|fs
argument_list|,
name|freeblks
operator|->
name|fb_devvp
argument_list|,
name|freework
operator|->
name|fw_blkno
argument_list|,
name|bsize
argument_list|,
name|freeblks
operator|->
name|fb_inum
argument_list|,
name|freeblks
operator|->
name|fb_vtype
argument_list|,
operator|&
name|wkhd
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * The jnewblk will be discarded and the bits in the map never 	 * made it to disk.  We can immediately free the freeblk. 	 */
if|if
condition|(
name|needj
operator|==
literal|0
condition|)
name|handle_written_freework
argument_list|(
name|freework
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We enqueue freework items that need processing back on the freeblks and  * add the freeblks to the worklist.  This makes it easier to find all work  * required to flush a truncation in process_truncates().  */
end_comment

begin_function
specifier|static
name|void
name|freework_enqueue
parameter_list|(
name|freework
parameter_list|)
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
block|{
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|freeblks
operator|=
name|freework
operator|->
name|fw_freeblks
expr_stmt|;
if|if
condition|(
operator|(
name|freework
operator|->
name|fw_state
operator|&
name|INPROGRESS
operator|)
operator|==
literal|0
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_freeworkhd
argument_list|,
operator|&
name|freework
operator|->
name|fw_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|freeblks
operator|->
name|fb_state
operator|&
operator|(
name|ONWORKLIST
operator||
name|INPROGRESS
operator||
name|ALLCOMPLETE
operator|)
operator|)
operator|==
name|ALLCOMPLETE
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|)
condition|)
name|add_to_worklist
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_list
argument_list|,
name|WK_NODELAY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start, continue, or finish the process of freeing an indirect block tree.  * The free operation may be paused at any point with fw_off containing the  * offset to restart from.  This enables us to implement some flow control  * for large truncates which may fan out and generate a huge number of  * dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|handle_workitem_indirblk
parameter_list|(
name|freework
parameter_list|)
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
block|{
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|freeblks
operator|=
name|freework
operator|->
name|fw_freeblks
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|freeblks
operator|->
name|fb_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
if|if
condition|(
name|freework
operator|->
name|fw_state
operator|&
name|DEPCOMPLETE
condition|)
block|{
name|handle_written_freework
argument_list|(
name|freework
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|freework
operator|->
name|fw_off
operator|==
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|freework_freeblock
argument_list|(
name|freework
argument_list|)
expr_stmt|;
return|return;
block|}
name|freework
operator|->
name|fw_state
operator||=
name|INPROGRESS
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|indir_trunc
argument_list|(
name|freework
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|freework
operator|->
name|fw_blkno
argument_list|)
argument_list|,
name|freework
operator|->
name|fw_lbn
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when a freework structure attached to a cg buf is written.  The  * ref on either the parent or the freeblks structure is released and  * the freeblks is added back to the worklist if there is more work to do.  */
end_comment

begin_function
specifier|static
name|void
name|handle_written_freework
parameter_list|(
name|freework
parameter_list|)
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
block|{
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|freework
modifier|*
name|parent
decl_stmt|;
name|freeblks
operator|=
name|freework
operator|->
name|fw_freeblks
expr_stmt|;
name|parent
operator|=
name|freework
operator|->
name|fw_parent
expr_stmt|;
if|if
condition|(
name|freework
operator|->
name|fw_state
operator|&
name|DELAYEDFREE
condition|)
name|freeblks
operator|->
name|fb_cgwait
operator|--
expr_stmt|;
name|freework
operator|->
name|fw_state
operator||=
name|COMPLETE
expr_stmt|;
if|if
condition|(
operator|(
name|freework
operator|->
name|fw_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
name|WORKITEM_FREE
argument_list|(
name|freework
argument_list|,
name|D_FREEWORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
if|if
condition|(
operator|--
name|parent
operator|->
name|fw_ref
operator|==
literal|0
condition|)
name|freework_enqueue
argument_list|(
name|parent
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|--
name|freeblks
operator|->
name|fb_ref
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|freeblks
operator|->
name|fb_state
operator|&
operator|(
name|ALLCOMPLETE
operator||
name|ONWORKLIST
operator||
name|INPROGRESS
operator|)
operator|)
operator|==
name|ALLCOMPLETE
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|)
condition|)
name|add_to_worklist
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_list
argument_list|,
name|WK_NODELAY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This workitem routine performs the block de-allocation.  * The workitem is added to the pending list after the updated  * inode block has been written to disk.  As mentioned above,  * checks regarding the number of blocks de-allocated (compared  * to the number of blocks allocated for the file) are also  * performed in this function.  */
end_comment

begin_function
specifier|static
name|int
name|handle_workitem_freeblocks
parameter_list|(
name|freeblks
parameter_list|,
name|flags
parameter_list|)
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|)
argument_list|,
operator|(
literal|"handle_workitem_freeblocks: Journal entries not written."
operator|)
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|freeblks
operator|->
name|fb_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_freeworkhd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_DIRREM
case|:
name|wk
operator|->
name|wk_state
operator||=
name|COMPLETE
expr_stmt|;
name|add_to_worklist
argument_list|(
name|wk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_ALLOCDIRECT
case|:
name|free_newblk
argument_list|(
name|WK_NEWBLK
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_ALLOCINDIR
case|:
name|aip
operator|=
name|WK_ALLOCINDIR
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|freework
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|aip
operator|->
name|ai_state
operator|&
name|DELAYEDFREE
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|freework
operator|=
name|newfreework
argument_list|(
name|ump
argument_list|,
name|freeblks
argument_list|,
name|NULL
argument_list|,
name|aip
operator|->
name|ai_lbn
argument_list|,
name|aip
operator|->
name|ai_newblkno
argument_list|,
name|ump
operator|->
name|um_fs
operator|->
name|fs_frag
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
name|newblk
operator|=
name|WK_NEWBLK
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|newblk
operator|->
name|nb_jnewblk
condition|)
block|{
name|freework
operator|->
name|fw_jnewblk
operator|=
name|newblk
operator|->
name|nb_jnewblk
expr_stmt|;
name|newblk
operator|->
name|nb_jnewblk
operator|->
name|jn_dep
operator|=
operator|&
name|freework
operator|->
name|fw_list
expr_stmt|;
name|newblk
operator|->
name|nb_jnewblk
operator|=
name|NULL
expr_stmt|;
block|}
name|free_newblk
argument_list|(
name|newblk
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_FREEWORK
case|:
name|freework
operator|=
name|WK_FREEWORK
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|freework
operator|->
name|fw_lbn
operator|<=
operator|-
name|UFS_NDADDR
condition|)
name|handle_workitem_indirblk
argument_list|(
name|freework
argument_list|)
expr_stmt|;
else|else
name|freework_freeblock
argument_list|(
name|freework
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|panic
argument_list|(
literal|"handle_workitem_freeblocks: Unknown type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|freeblks
operator|->
name|fb_ref
operator|!=
literal|0
condition|)
block|{
name|freeblks
operator|->
name|fb_state
operator|&=
operator|~
name|INPROGRESS
expr_stmt|;
name|wake_worklist
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_list
argument_list|)
expr_stmt|;
name|freeblks
operator|=
name|NULL
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeblks
condition|)
return|return
name|handle_complete_freeblocks
argument_list|(
name|freeblks
argument_list|,
name|flags
argument_list|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle completion of block free via truncate.  This allows fs_pending  * to track the actual free block count more closely than if we only updated  * it at the end.  We must be careful to handle cases where the block count  * on free was incorrect.  */
end_comment

begin_function
specifier|static
name|void
name|freeblks_free
parameter_list|(
name|ump
parameter_list|,
name|freeblks
parameter_list|,
name|blocks
parameter_list|)
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|int
name|blocks
decl_stmt|;
block|{
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ufs2_daddr_t
name|remain
decl_stmt|;
name|UFS_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|remain
operator|=
operator|-
name|freeblks
operator|->
name|fb_chkcnt
expr_stmt|;
name|freeblks
operator|->
name|fb_chkcnt
operator|+=
name|blocks
expr_stmt|;
if|if
condition|(
name|remain
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|remain
operator|<
name|blocks
condition|)
name|blocks
operator|=
name|remain
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
name|fs
operator|->
name|fs_pendingblocks
operator|-=
name|blocks
expr_stmt|;
block|}
name|UFS_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Once all of the freework workitems are complete we can retire the  * freeblocks dependency and any journal work awaiting completion.  This  * can not be called until all other dependencies are stable on disk.  */
end_comment

begin_function
specifier|static
name|int
name|handle_complete_freeblocks
parameter_list|(
name|freeblks
parameter_list|,
name|flags
parameter_list|)
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ufs2_daddr_t
name|spare
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|freeblks
operator|->
name|fb_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
name|flags
operator|=
name|LK_EXCLUSIVE
operator||
name|flags
expr_stmt|;
name|spare
operator|=
name|freeblks
operator|->
name|fb_chkcnt
expr_stmt|;
comment|/* 	 * If we did not release the expected number of blocks we may have 	 * to adjust the inode block count here.  Only do so if it wasn't 	 * a truncation to zero and the modrev still matches. 	 */
if|if
condition|(
name|spare
operator|&&
name|freeblks
operator|->
name|fb_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ffs_vgetf
argument_list|(
name|freeblks
operator|->
name|fb_list
operator|.
name|wk_mp
argument_list|,
name|freeblks
operator|->
name|fb_inum
argument_list|,
name|flags
argument_list|,
operator|&
name|vp
argument_list|,
name|FFSV_FORCEINSMQ
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_modrev
argument_list|)
operator|==
name|freeblks
operator|->
name|fb_modrev
condition|)
block|{
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_blocks
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_blocks
argument_list|)
operator|-
name|spare
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
expr_stmt|;
comment|/* 			 * We must wait so this happens before the 			 * journal is reclaimed. 			 */
name|ffs_update
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spare
operator|<
literal|0
condition|)
block|{
name|UFS_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_pendingblocks
operator|+=
name|spare
expr_stmt|;
name|UFS_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QUOTA
comment|/* Handle spare. */
if|if
condition|(
name|spare
condition|)
name|quotaadj
argument_list|(
name|freeblks
operator|->
name|fb_quota
argument_list|,
name|ump
argument_list|,
operator|-
name|spare
argument_list|)
expr_stmt|;
name|quotarele
argument_list|(
name|freeblks
operator|->
name|fb_quota
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeblks
operator|->
name|fb_state
operator|&
name|ONDEPLIST
condition|)
block|{
name|inodedep_lookup
argument_list|(
name|freeblks
operator|->
name|fb_list
operator|.
name|wk_mp
argument_list|,
name|freeblks
operator|->
name|fb_inum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inodedep
operator|->
name|id_freeblklst
argument_list|,
name|freeblks
argument_list|,
name|fb_next
argument_list|)
expr_stmt|;
name|freeblks
operator|->
name|fb_state
operator|&=
operator|~
name|ONDEPLIST
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_freeblklst
argument_list|)
condition|)
name|free_inodedep
argument_list|(
name|inodedep
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * All of the freeblock deps must be complete prior to this call 	 * so it's now safe to complete earlier outstanding journal entries. 	 */
name|handle_jwork
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jwork
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|freeblks
argument_list|,
name|D_FREEBLKS
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release blocks associated with the freeblks and stored in the indirect  * block dbn. If level is greater than SINGLE, the block is an indirect block  * and recursive calls to indirtrunc must be used to cleanse other indirect  * blocks.  *  * This handles partial and complete truncation of blocks.  Partial is noted  * with goingaway == 0.  In this case the freework is completed after the  * zero'd indirects are written to disk.  For full truncation the freework  * is completed after the block is freed.  */
end_comment

begin_function
specifier|static
name|void
name|indir_trunc
parameter_list|(
name|freework
parameter_list|,
name|dbn
parameter_list|,
name|lbn
parameter_list|)
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
name|ufs2_daddr_t
name|dbn
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
block|{
name|struct
name|freework
modifier|*
name|nfreework
decl_stmt|;
name|struct
name|workhead
name|wkhd
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ufs1_daddr_t
modifier|*
name|bap1
decl_stmt|;
name|ufs2_daddr_t
name|nb
decl_stmt|,
name|nnb
decl_stmt|,
modifier|*
name|bap2
decl_stmt|;
name|ufs_lbn_t
name|lbnadd
decl_stmt|,
name|nlbn
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nblocks
decl_stmt|,
name|ufs1fmt
decl_stmt|;
name|int
name|freedblocks
decl_stmt|;
name|int
name|goingaway
decl_stmt|;
name|int
name|freedeps
decl_stmt|;
name|int
name|needj
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|freeblks
operator|=
name|freework
operator|->
name|fw_freeblks
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|freeblks
operator|->
name|fb_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
comment|/* 	 * Get buffer of block pointers to be freed.  There are three cases: 	 *  	 * 1) Partial truncate caches the indirdep pointer in the freework 	 *    which provides us a back copy to the save bp which holds the 	 *    pointers we want to clear.  When this completes the zero 	 *    pointers are written to the real copy. 	 * 2) The indirect is being completely truncated, cancel_indirdep() 	 *    eliminated the real copy and placed the indirdep on the saved 	 *    copy.  The indirdep and buf are discarded when this completes. 	 * 3) The indirect was not in memory, we read a copy off of the disk 	 *    using the devvp and drop and invalidate the buffer when we're 	 *    done. 	 */
name|goingaway
operator|=
literal|1
expr_stmt|;
name|indirdep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|freework
operator|->
name|fw_indir
operator|!=
name|NULL
condition|)
block|{
name|goingaway
operator|=
literal|0
expr_stmt|;
name|indirdep
operator|=
name|freework
operator|->
name|fw_indir
expr_stmt|;
name|bp
operator|=
name|indirdep
operator|->
name|ir_savebp
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
operator|||
name|bp
operator|->
name|b_blkno
operator|!=
name|dbn
condition|)
name|panic
argument_list|(
literal|"indir_trunc: Bad saved buf %p blkno %jd"
argument_list|,
name|bp
argument_list|,
operator|(
name|intmax_t
operator|)
name|dbn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bp
operator|=
name|incore
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_devvp
operator|->
name|v_bufobj
argument_list|,
name|dbn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * The lock prevents the buf dep list from changing and 	 	 * indirects on devvp should only ever have one dependency. 		 */
name|indirdep
operator|=
name|WK_INDIRDEP
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirdep
operator|==
name|NULL
operator|||
operator|(
name|indirdep
operator|->
name|ir_state
operator|&
name|GOINGAWAY
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"indir_trunc: Bad indirdep %p from buf %p"
argument_list|,
name|indirdep
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bread
argument_list|(
name|freeblks
operator|->
name|fb_devvp
argument_list|,
name|dbn
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* Protects against a race with complete_trunc_indir(). */
name|freework
operator|->
name|fw_state
operator|&=
operator|~
name|INPROGRESS
expr_stmt|;
comment|/* 	 * If we have an indirdep we need to enforce the truncation order 	 * and discard it when it is complete. 	 */
if|if
condition|(
name|indirdep
condition|)
block|{
if|if
condition|(
name|freework
operator|!=
name|TAILQ_FIRST
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|)
operator|&&
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|)
condition|)
block|{
comment|/* 			 * Add the complete truncate to the list on the 			 * indirdep to enforce in-order processing. 			 */
if|if
condition|(
name|freework
operator|->
name|fw_indir
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|,
name|freework
argument_list|,
name|fw_next
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * If we're goingaway, free the indirdep.  Otherwise it will 		 * linger until the write completes. 		 */
if|if
condition|(
name|goingaway
condition|)
name|free_indirdep
argument_list|(
name|indirdep
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* Initialize pointers depending on block size. */
if|if
condition|(
name|ump
operator|->
name|um_fstype
operator|==
name|UFS1
condition|)
block|{
name|bap1
operator|=
operator|(
name|ufs1_daddr_t
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|nb
operator|=
name|bap1
index|[
name|freework
operator|->
name|fw_off
index|]
expr_stmt|;
name|ufs1fmt
operator|=
literal|1
expr_stmt|;
name|bap2
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|bap2
operator|=
operator|(
name|ufs2_daddr_t
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|nb
operator|=
name|bap2
index|[
name|freework
operator|->
name|fw_off
index|]
expr_stmt|;
name|ufs1fmt
operator|=
literal|0
expr_stmt|;
name|bap1
operator|=
name|NULL
expr_stmt|;
block|}
name|level
operator|=
name|lbn_level
argument_list|(
name|lbn
argument_list|)
expr_stmt|;
name|needj
operator|=
name|MOUNTEDSUJ
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|lbnadd
operator|=
name|lbn_offset
argument_list|(
name|fs
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|nblocks
operator|=
name|btodb
argument_list|(
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|nfreework
operator|=
name|freework
expr_stmt|;
name|freedeps
operator|=
literal|0
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Reclaim blocks.  Traverses into nested indirect levels and 	 * arranges for the current level to be freed when subordinates 	 * are free when journaling. 	 */
for|for
control|(
name|i
operator|=
name|freework
operator|->
name|fw_off
init|;
name|i
operator|<
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|;
name|i
operator|++
operator|,
name|nb
operator|=
name|nnb
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ufs1fmt
condition|)
name|nnb
operator|=
name|bap1
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|nnb
operator|=
name|bap2
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
name|nnb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nb
operator|==
literal|0
condition|)
continue|continue;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
block|{
name|nlbn
operator|=
operator|(
name|lbn
operator|+
literal|1
operator|)
operator|-
operator|(
name|i
operator|*
name|lbnadd
operator|)
expr_stmt|;
if|if
condition|(
name|needj
operator|!=
literal|0
condition|)
block|{
name|nfreework
operator|=
name|newfreework
argument_list|(
name|ump
argument_list|,
name|freeblks
argument_list|,
name|freework
argument_list|,
name|nlbn
argument_list|,
name|nb
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|freedeps
operator|++
expr_stmt|;
block|}
name|indir_trunc
argument_list|(
name|nfreework
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|nb
argument_list|)
argument_list|,
name|nlbn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|freedep
modifier|*
name|freedep
decl_stmt|;
comment|/* 			 * Attempt to aggregate freedep dependencies for 			 * all blocks being released to the same CG. 			 */
name|LIST_INIT
argument_list|(
operator|&
name|wkhd
argument_list|)
expr_stmt|;
if|if
condition|(
name|needj
operator|!=
literal|0
operator|&&
operator|(
name|nnb
operator|==
literal|0
operator|||
operator|(
name|dtog
argument_list|(
name|fs
argument_list|,
name|nb
argument_list|)
operator|!=
name|dtog
argument_list|(
name|fs
argument_list|,
name|nnb
argument_list|)
operator|)
operator|)
condition|)
block|{
name|freedep
operator|=
name|newfreedep
argument_list|(
name|freework
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT_UNLOCKED
argument_list|(
operator|&
name|wkhd
argument_list|,
operator|&
name|freedep
operator|->
name|fd_list
argument_list|)
expr_stmt|;
name|freedeps
operator|++
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"indir_trunc: ino %d blkno %jd size %ld"
argument_list|,
name|freeblks
operator|->
name|fb_inum
argument_list|,
name|nb
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|ffs_blkfree
argument_list|(
name|ump
argument_list|,
name|fs
argument_list|,
name|freeblks
operator|->
name|fb_devvp
argument_list|,
name|nb
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|freeblks
operator|->
name|fb_inum
argument_list|,
name|freeblks
operator|->
name|fb_vtype
argument_list|,
operator|&
name|wkhd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|goingaway
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_NOCACHE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|freedblocks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|freedblocks
operator|=
operator|(
name|nblocks
operator|*
name|cnt
operator|)
expr_stmt|;
if|if
condition|(
name|needj
operator|==
literal|0
condition|)
name|freedblocks
operator|+=
name|nblocks
expr_stmt|;
name|freeblks_free
argument_list|(
name|ump
argument_list|,
name|freeblks
argument_list|,
name|freedblocks
argument_list|)
expr_stmt|;
comment|/* 	 * If we are journaling set up the ref counts and offset so this 	 * indirect can be completed when its children are free. 	 */
if|if
condition|(
name|needj
condition|)
block|{
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|freework
operator|->
name|fw_off
operator|=
name|i
expr_stmt|;
name|freework
operator|->
name|fw_ref
operator|+=
name|freedeps
expr_stmt|;
name|freework
operator|->
name|fw_ref
operator|-=
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|freeblks
operator|->
name|fb_cgwait
operator|+=
name|freedeps
expr_stmt|;
if|if
condition|(
name|freework
operator|->
name|fw_ref
operator|==
literal|0
condition|)
name|freework_freeblock
argument_list|(
name|freework
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we're not journaling we can free the indirect now. 	 */
name|dbn
operator|=
name|dbtofsb
argument_list|(
name|fs
argument_list|,
name|dbn
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"indir_trunc 2: ino %d blkno %jd size %ld"
argument_list|,
name|freeblks
operator|->
name|fb_inum
argument_list|,
name|dbn
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|ffs_blkfree
argument_list|(
name|ump
argument_list|,
name|fs
argument_list|,
name|freeblks
operator|->
name|fb_devvp
argument_list|,
name|dbn
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|freeblks
operator|->
name|fb_inum
argument_list|,
name|freeblks
operator|->
name|fb_vtype
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Non SUJ softdep does single-threaded truncations. */
if|if
condition|(
name|freework
operator|->
name|fw_blkno
operator|==
name|dbn
condition|)
block|{
name|freework
operator|->
name|fw_state
operator||=
name|ALLCOMPLETE
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|handle_written_freework
argument_list|(
name|freework
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Cancel an allocindir when it is removed via truncation.  When bp is not  * NULL the indirect never appeared on disk and is scheduled to be freed  * independently of the indir so we can more easily track journal work.  */
end_comment

begin_function
specifier|static
name|void
name|cancel_allocindir
parameter_list|(
name|aip
parameter_list|,
name|bp
parameter_list|,
name|freeblks
parameter_list|,
name|trunc
parameter_list|)
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|int
name|trunc
decl_stmt|;
block|{
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|freefrag
modifier|*
name|freefrag
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|newblk
operator|=
operator|(
expr|struct
name|newblk
operator|*
operator|)
name|aip
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|aip
argument_list|,
name|ai_next
argument_list|)
expr_stmt|;
comment|/* 	 * We must eliminate the pointer in bp if it must be freed on its 	 * own due to partial truncate or pending journal work. 	 */
if|if
condition|(
name|bp
operator|&&
operator|(
name|trunc
operator|||
name|newblk
operator|->
name|nb_jnewblk
operator|)
condition|)
block|{
comment|/* 		 * Clear the pointer and mark the aip to be freed 		 * directly if it never existed on disk. 		 */
name|aip
operator|->
name|ai_state
operator||=
name|DELAYEDFREE
expr_stmt|;
name|indirdep
operator|=
name|aip
operator|->
name|ai_indirdep
expr_stmt|;
if|if
condition|(
name|indirdep
operator|->
name|ir_state
operator|&
name|UFS1FMT
condition|)
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|)
index|[
name|aip
operator|->
name|ai_offset
index|]
operator|=
literal|0
expr_stmt|;
else|else
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|)
index|[
name|aip
operator|->
name|ai_offset
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * When truncating the previous pointer will be freed via 	 * savedbp.  Eliminate the freefrag which would dup free. 	 */
if|if
condition|(
name|trunc
operator|&&
operator|(
name|freefrag
operator|=
name|newblk
operator|->
name|nb_freefrag
operator|)
operator|!=
name|NULL
condition|)
block|{
name|newblk
operator|->
name|nb_freefrag
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|freefrag
operator|->
name|ff_jdep
condition|)
name|cancel_jfreefrag
argument_list|(
name|WK_JFREEFRAG
argument_list|(
name|freefrag
operator|->
name|ff_jdep
argument_list|)
argument_list|)
expr_stmt|;
name|jwork_move
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jwork
argument_list|,
operator|&
name|freefrag
operator|->
name|ff_jwork
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|freefrag
argument_list|,
name|D_FREEFRAG
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the journal hasn't been written the jnewblk must be passed 	 * to the call to ffs_blkfree that reclaims the space.  We accomplish 	 * this by leaving the journal dependency on the newblk to be freed 	 * when a freework is created in handle_workitem_freeblocks(). 	 */
name|cancel_newblk
argument_list|(
name|newblk
argument_list|,
name|NULL
argument_list|,
operator|&
name|freeblks
operator|->
name|fb_jwork
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_freeworkhd
argument_list|,
operator|&
name|newblk
operator|->
name|nb_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create the mkdir dependencies for . and .. in a new directory.  Link them  * in to a newdirblk so any subsequent additions are tracked properly.  The  * caller is responsible for adding the mkdir1 dependency to the journal  * and updating id_mkdiradd.  This function returns with the per-filesystem  * lock held.  */
end_comment

begin_function
specifier|static
name|struct
name|mkdir
modifier|*
name|setup_newdir
parameter_list|(
name|dap
parameter_list|,
name|newinum
parameter_list|,
name|dinum
parameter_list|,
name|newdirbp
parameter_list|,
name|mkdirp
parameter_list|)
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|ino_t
name|newinum
decl_stmt|;
name|ino_t
name|dinum
decl_stmt|;
name|struct
name|buf
modifier|*
name|newdirbp
decl_stmt|;
name|struct
name|mkdir
modifier|*
modifier|*
name|mkdirp
decl_stmt|;
block|{
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|newdirblk
modifier|*
name|newdirblk
decl_stmt|;
name|struct
name|mkdir
modifier|*
name|mkdir1
decl_stmt|,
modifier|*
name|mkdir2
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|dap
operator|->
name|da_list
operator|.
name|wk_mp
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|newdirblk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|newdirblk
argument_list|)
argument_list|,
name|M_NEWDIRBLK
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|newdirblk
operator|->
name|db_list
argument_list|,
name|D_NEWDIRBLK
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|newdirblk
operator|->
name|db_mkdir
argument_list|)
expr_stmt|;
name|mkdir1
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mkdir
argument_list|)
argument_list|,
name|M_MKDIR
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|mkdir1
operator|->
name|md_list
argument_list|,
name|D_MKDIR
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|mkdir1
operator|->
name|md_state
operator|=
name|ATTACHED
operator||
name|MKDIR_BODY
expr_stmt|;
name|mkdir1
operator|->
name|md_diradd
operator|=
name|dap
expr_stmt|;
name|mkdir1
operator|->
name|md_jaddref
operator|=
name|NULL
expr_stmt|;
name|mkdir2
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mkdir
argument_list|)
argument_list|,
name|M_MKDIR
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|mkdir2
operator|->
name|md_list
argument_list|,
name|D_MKDIR
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|mkdir2
operator|->
name|md_state
operator|=
name|ATTACHED
operator||
name|MKDIR_PARENT
expr_stmt|;
name|mkdir2
operator|->
name|md_diradd
operator|=
name|dap
expr_stmt|;
name|mkdir2
operator|->
name|md_jaddref
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|MOUNTEDSUJ
argument_list|(
name|mp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mkdir1
operator|->
name|md_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|mkdir2
operator|->
name|md_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
block|}
comment|/* 	 * Dependency on "." and ".." being written to disk. 	 */
name|mkdir1
operator|->
name|md_buf
operator|=
name|newdirbp
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ump
operator|->
name|softdep_mkdirlisthd
argument_list|,
name|mkdir1
argument_list|,
name|md_mkdirs
argument_list|)
expr_stmt|;
comment|/* 	 * We must link the pagedep, allocdirect, and newdirblk for 	 * the initial file page so the pointer to the new directory 	 * is not written until the directory contents are live and 	 * any subsequent additions are not marked live until the 	 * block is reachable via the inode. 	 */
if|if
condition|(
name|pagedep_lookup
argument_list|(
name|mp
argument_list|,
name|newdirbp
argument_list|,
name|newinum
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|pagedep
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"setup_newdir: lost pagedep"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&newdirbp->b_dep
argument_list|,
argument|wk_list
argument_list|)
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|==
name|D_ALLOCDIRECT
condition|)
break|break;
if|if
condition|(
name|wk
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"setup_newdir: lost allocdirect"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pagedep
operator|->
name|pd_state
operator|&
name|NEWBLOCK
condition|)
name|panic
argument_list|(
literal|"setup_newdir: NEWBLOCK already set"
argument_list|)
expr_stmt|;
name|newblk
operator|=
name|WK_NEWBLK
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|pagedep
operator|->
name|pd_state
operator||=
name|NEWBLOCK
expr_stmt|;
name|pagedep
operator|->
name|pd_newdirblk
operator|=
name|newdirblk
expr_stmt|;
name|newdirblk
operator|->
name|db_pagedep
operator|=
name|pagedep
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|newblk
operator|->
name|nb_newdirblk
argument_list|,
operator|&
name|newdirblk
operator|->
name|db_list
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|newdirblk
operator|->
name|db_mkdir
argument_list|,
operator|&
name|mkdir1
operator|->
name|md_list
argument_list|)
expr_stmt|;
comment|/* 	 * Look up the inodedep for the parent directory so that we 	 * can link mkdir2 into the pending dotdot jaddref or 	 * the inode write if there is none.  If the inode is 	 * ALLCOMPLETE and no jaddref is present all dependencies have 	 * been satisfied and mkdir2 can be freed. 	 */
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|dinum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
name|MOUNTEDSUJ
argument_list|(
name|mp
argument_list|)
condition|)
block|{
if|if
condition|(
name|inodedep
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"setup_newdir: Lost parent."
argument_list|)
expr_stmt|;
name|jaddref
operator|=
operator|(
expr|struct
name|jaddref
operator|*
operator|)
name|TAILQ_LAST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
name|inoreflst
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|jaddref
operator|!=
name|NULL
operator|&&
name|jaddref
operator|->
name|ja_parent
operator|==
name|newinum
operator|&&
operator|(
name|jaddref
operator|->
name|ja_state
operator|&
name|MKDIR_PARENT
operator|)
argument_list|,
operator|(
literal|"setup_newdir: bad dotdot jaddref %p"
operator|,
name|jaddref
operator|)
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ump
operator|->
name|softdep_mkdirlisthd
argument_list|,
name|mkdir2
argument_list|,
name|md_mkdirs
argument_list|)
expr_stmt|;
name|mkdir2
operator|->
name|md_jaddref
operator|=
name|jaddref
expr_stmt|;
name|jaddref
operator|->
name|ja_mkdir
operator|=
name|mkdir2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inodedep
operator|==
name|NULL
operator|||
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
block|{
name|dap
operator|->
name|da_state
operator|&=
operator|~
name|MKDIR_PARENT
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|mkdir2
argument_list|,
name|D_MKDIR
argument_list|)
expr_stmt|;
name|mkdir2
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ump
operator|->
name|softdep_mkdirlisthd
argument_list|,
name|mkdir2
argument_list|,
name|md_mkdirs
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|,
operator|&
name|mkdir2
operator|->
name|md_list
argument_list|)
expr_stmt|;
block|}
operator|*
name|mkdirp
operator|=
name|mkdir2
expr_stmt|;
return|return
operator|(
name|mkdir1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Directory entry addition dependencies.  *   * When adding a new directory entry, the inode (with its incremented link  * count) must be written to disk before the directory entry's pointer to it.  * Also, if the inode is newly allocated, the corresponding freemap must be  * updated (on disk) before the directory entry's pointer. These requirements  * are met via undo/redo on the directory entry's pointer, which consists  * simply of the inode number.  *   * As directory entries are added and deleted, the free space within a  * directory block can become fragmented.  The ufs filesystem will compact  * a fragmented directory block to make space for a new entry. When this  * occurs, the offsets of previously added entries change. Any "diradd"  * dependency structures corresponding to these entries must be updated with  * the new offsets.  */
end_comment

begin_comment
comment|/*  * This routine is called after the in-memory inode's link  * count has been incremented, but before the directory entry's  * pointer to the inode has been set.  */
end_comment

begin_function
name|int
name|softdep_setup_directory_add
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|,
name|diroffset
parameter_list|,
name|newinum
parameter_list|,
name|newdirbp
parameter_list|,
name|isnewblk
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing directory block */
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
comment|/* inode for directory */
name|off_t
name|diroffset
decl_stmt|;
comment|/* offset of new entry in directory */
name|ino_t
name|newinum
decl_stmt|;
comment|/* inode referenced by new directory entry */
name|struct
name|buf
modifier|*
name|newdirbp
decl_stmt|;
comment|/* non-NULL => contents of new mkdir */
name|int
name|isnewblk
decl_stmt|;
comment|/* entry is in a newly allocated block */
block|{
name|int
name|offset
decl_stmt|;
comment|/* offset of new entry within directory block */
name|ufs_lbn_t
name|lbn
decl_stmt|;
comment|/* block in directory containing new entry */
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|newdirblk
modifier|*
name|newdirblk
decl_stmt|;
name|struct
name|mkdir
modifier|*
name|mkdir1
decl_stmt|,
modifier|*
name|mkdir2
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|isindir
decl_stmt|;
name|mp
operator|=
name|ITOVFS
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_directory_add called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Whiteouts have no dependencies. 	 */
if|if
condition|(
name|newinum
operator|==
name|UFS_WINO
condition|)
block|{
if|if
condition|(
name|newdirbp
operator|!=
name|NULL
condition|)
name|bdwrite
argument_list|(
name|newdirbp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|jaddref
operator|=
name|NULL
expr_stmt|;
name|mkdir1
operator|=
name|mkdir2
operator|=
name|NULL
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
name|lbn
operator|=
name|lblkno
argument_list|(
name|fs
argument_list|,
name|diroffset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|diroffset
argument_list|)
expr_stmt|;
name|dap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|diradd
argument_list|)
argument_list|,
name|M_DIRADD
argument_list|,
name|M_SOFTDEP_FLAGS
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|dap
operator|->
name|da_list
argument_list|,
name|D_DIRADD
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|dap
operator|->
name|da_offset
operator|=
name|offset
expr_stmt|;
name|dap
operator|->
name|da_newinum
operator|=
name|newinum
expr_stmt|;
name|dap
operator|->
name|da_state
operator|=
name|ATTACHED
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|dap
operator|->
name|da_jwork
argument_list|)
expr_stmt|;
name|isindir
operator|=
name|bp
operator|->
name|b_lblkno
operator|>=
name|UFS_NDADDR
expr_stmt|;
name|newdirblk
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|isnewblk
operator|&&
operator|(
name|isindir
condition|?
name|blkoff
argument_list|(
name|fs
argument_list|,
name|diroffset
argument_list|)
else|:
name|fragoff
argument_list|(
name|fs
argument_list|,
name|diroffset
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|newdirblk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|newdirblk
argument_list|)
argument_list|,
name|M_NEWDIRBLK
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|newdirblk
operator|->
name|db_list
argument_list|,
name|D_NEWDIRBLK
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|newdirblk
operator|->
name|db_mkdir
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're creating a new directory setup the dependencies and set 	 * the dap state to wait for them.  Otherwise it's COMPLETE and 	 * we can move on. 	 */
if|if
condition|(
name|newdirbp
operator|==
name|NULL
condition|)
block|{
name|dap
operator|->
name|da_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dap
operator|->
name|da_state
operator||=
name|MKDIR_BODY
operator||
name|MKDIR_PARENT
expr_stmt|;
name|mkdir1
operator|=
name|setup_newdir
argument_list|(
name|dap
argument_list|,
name|newinum
argument_list|,
name|dp
operator|->
name|i_number
argument_list|,
name|newdirbp
argument_list|,
operator|&
name|mkdir2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Link into parent directory pagedep to await its being written. 	 */
name|pagedep_lookup
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|,
name|dp
operator|->
name|i_number
argument_list|,
name|lbn
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|pagedep
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|diradd_lookup
argument_list|(
name|pagedep
argument_list|,
name|offset
argument_list|)
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"softdep_setup_directory_add: %p already at off %d\n"
argument_list|,
name|diradd_lookup
argument_list|(
name|pagedep
argument_list|,
name|offset
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dap
operator|->
name|da_pagedep
operator|=
name|pagedep
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|DIRADDHASH
argument_list|(
name|offset
argument_list|)
index|]
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|newinum
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
comment|/* 	 * If we're journaling, link the diradd into the jaddref so it 	 * may be completed after the journal entry is written.  Otherwise, 	 * link the diradd into its inodedep.  If the inode is not yet 	 * written place it on the bufwait list, otherwise do the post-inode 	 * write processing to put it on the id_pendinghd list. 	 */
if|if
condition|(
name|MOUNTEDSUJ
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|jaddref
operator|=
operator|(
expr|struct
name|jaddref
operator|*
operator|)
name|TAILQ_LAST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
name|inoreflst
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|jaddref
operator|!=
name|NULL
operator|&&
name|jaddref
operator|->
name|ja_parent
operator|==
name|dp
operator|->
name|i_number
argument_list|,
operator|(
literal|"softdep_setup_directory_add: bad jaddref %p"
operator|,
name|jaddref
operator|)
argument_list|)
expr_stmt|;
name|jaddref
operator|->
name|ja_diroff
operator|=
name|diroffset
expr_stmt|;
name|jaddref
operator|->
name|ja_diradd
operator|=
name|dap
expr_stmt|;
name|add_to_journal
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
name|diradd_inode_written
argument_list|(
name|dap
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
else|else
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|,
operator|&
name|dap
operator|->
name|da_list
argument_list|)
expr_stmt|;
comment|/* 	 * Add the journal entries for . and .. links now that the primary 	 * link is written. 	 */
if|if
condition|(
name|mkdir1
operator|!=
name|NULL
operator|&&
name|MOUNTEDSUJ
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|jaddref
operator|=
operator|(
expr|struct
name|jaddref
operator|*
operator|)
name|TAILQ_PREV
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_ref
argument_list|,
name|inoreflst
argument_list|,
name|if_deps
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|jaddref
operator|!=
name|NULL
operator|&&
name|jaddref
operator|->
name|ja_ino
operator|==
name|jaddref
operator|->
name|ja_parent
operator|&&
operator|(
name|jaddref
operator|->
name|ja_state
operator|&
name|MKDIR_BODY
operator|)
argument_list|,
operator|(
literal|"softdep_setup_directory_add: bad dot jaddref %p"
operator|,
name|jaddref
operator|)
argument_list|)
expr_stmt|;
name|mkdir1
operator|->
name|md_jaddref
operator|=
name|jaddref
expr_stmt|;
name|jaddref
operator|->
name|ja_mkdir
operator|=
name|mkdir1
expr_stmt|;
comment|/* 		 * It is important that the dotdot journal entry 		 * is added prior to the dot entry since dot writes 		 * both the dot and dotdot links.  These both must 		 * be added after the primary link for the journal 		 * to remain consistent. 		 */
name|add_to_journal
argument_list|(
operator|&
name|mkdir2
operator|->
name|md_jaddref
operator|->
name|ja_list
argument_list|)
expr_stmt|;
name|add_to_journal
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we are adding a new directory remember this diradd so that if 	 * we rename it we can keep the dot and dotdot dependencies.  If 	 * we are adding a new name for an inode that has a mkdiradd we 	 * must be in rename and we have to move the dot and dotdot 	 * dependencies to this new name.  The old name is being orphaned 	 * soon. 	 */
if|if
condition|(
name|mkdir1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|inodedep
operator|->
name|id_mkdiradd
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"softdep_setup_directory_add: Existing mkdir"
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_mkdiradd
operator|=
name|dap
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inodedep
operator|->
name|id_mkdiradd
condition|)
name|merge_diradd
argument_list|(
name|inodedep
argument_list|,
name|dap
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdirblk
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * There is nothing to do if we are already tracking 		 * this block. 		 */
if|if
condition|(
operator|(
name|pagedep
operator|->
name|pd_state
operator|&
name|NEWBLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|WORKITEM_FREE
argument_list|(
name|newdirblk
argument_list|,
name|D_NEWDIRBLK
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|newblk_lookup
argument_list|(
name|mp
argument_list|,
name|dbtofsb
argument_list|(
name|fs
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|newblk
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_setup_directory_add: lost entry"
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|newblk
operator|->
name|nb_newdirblk
argument_list|,
operator|&
name|newdirblk
operator|->
name|db_list
argument_list|)
expr_stmt|;
name|pagedep
operator|->
name|pd_state
operator||=
name|NEWBLOCK
expr_stmt|;
name|pagedep
operator|->
name|pd_newdirblk
operator|=
name|newdirblk
expr_stmt|;
name|newdirblk
operator|->
name|db_pagedep
operator|=
name|pagedep
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 		 * If we extended into an indirect signal direnter to sync. 		 */
if|if
condition|(
name|isindir
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This procedure is called to change the offset of a directory  * entry when compacting a directory block which must be owned  * exclusively by the caller. Note that the actual entry movement  * must be done in this procedure to ensure that no I/O completions  * occur while the move is in progress.  */
end_comment

begin_function
name|void
name|softdep_change_directoryentry_offset
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|,
name|base
parameter_list|,
name|oldloc
parameter_list|,
name|newloc
parameter_list|,
name|entrysize
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* Buffer holding directory block. */
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
comment|/* inode for directory */
name|caddr_t
name|base
decl_stmt|;
comment|/* address of dp->i_offset */
name|caddr_t
name|oldloc
decl_stmt|;
comment|/* address of old directory location */
name|caddr_t
name|newloc
decl_stmt|;
comment|/* address of new directory location */
name|int
name|entrysize
decl_stmt|;
comment|/* size of directory entry */
block|{
name|int
name|offset
decl_stmt|,
name|oldoffset
decl_stmt|,
name|newoffset
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|jmvref
modifier|*
name|jmvref
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|direct
modifier|*
name|de
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|mp
operator|=
name|ITOVFS
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_change_directoryentry_offset called on "
literal|"non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|de
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
name|oldloc
expr_stmt|;
name|jmvref
operator|=
name|NULL
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Moves are always journaled as it would be too complex to 	 * determine if any affected adds or removes are present in the 	 * journal. 	 */
if|if
condition|(
name|MOUNTEDSUJ
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|flags
operator|=
name|DEPALLOC
expr_stmt|;
name|jmvref
operator|=
name|newjmvref
argument_list|(
name|dp
argument_list|,
name|de
operator|->
name|d_ino
argument_list|,
name|dp
operator|->
name|i_offset
operator|+
operator|(
name|oldloc
operator|-
name|base
operator|)
argument_list|,
name|dp
operator|->
name|i_offset
operator|+
operator|(
name|newloc
operator|-
name|base
operator|)
argument_list|)
expr_stmt|;
block|}
name|lbn
operator|=
name|lblkno
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|,
name|dp
operator|->
name|i_offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|blkoff
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|,
name|dp
operator|->
name|i_offset
argument_list|)
expr_stmt|;
name|oldoffset
operator|=
name|offset
operator|+
operator|(
name|oldloc
operator|-
name|base
operator|)
expr_stmt|;
name|newoffset
operator|=
name|offset
operator|+
operator|(
name|newloc
operator|-
name|base
operator|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|pagedep_lookup
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|,
name|dp
operator|->
name|i_number
argument_list|,
name|lbn
argument_list|,
name|flags
argument_list|,
operator|&
name|pagedep
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
name|dap
operator|=
name|diradd_lookup
argument_list|(
name|pagedep
argument_list|,
name|oldoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dap
condition|)
block|{
name|dap
operator|->
name|da_offset
operator|=
name|newoffset
expr_stmt|;
name|newoffset
operator|=
name|DIRADDHASH
argument_list|(
name|newoffset
argument_list|)
expr_stmt|;
name|oldoffset
operator|=
name|DIRADDHASH
argument_list|(
name|oldoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
name|ALLCOMPLETE
operator|)
operator|!=
name|ALLCOMPLETE
operator|&&
name|newoffset
operator|!=
name|oldoffset
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|newoffset
index|]
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
block|}
block|}
name|done
label|:
if|if
condition|(
name|jmvref
condition|)
block|{
name|jmvref
operator|->
name|jm_pagedep
operator|=
name|pagedep
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_jmvrefhd
argument_list|,
name|jmvref
argument_list|,
name|jm_deps
argument_list|)
expr_stmt|;
name|add_to_journal
argument_list|(
operator|&
name|jmvref
operator|->
name|jm_list
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|oldloc
argument_list|,
name|newloc
argument_list|,
name|entrysize
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move the mkdir dependencies and journal work from one diradd to another  * when renaming a directory.  The new name must depend on the mkdir deps  * completing as the old name did.  Directories can only have one valid link  * at a time so one must be canonical.  */
end_comment

begin_function
specifier|static
name|void
name|merge_diradd
parameter_list|(
name|inodedep
parameter_list|,
name|newdap
parameter_list|)
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|diradd
modifier|*
name|newdap
decl_stmt|;
block|{
name|struct
name|diradd
modifier|*
name|olddap
decl_stmt|;
name|struct
name|mkdir
modifier|*
name|mkdir
decl_stmt|,
modifier|*
name|nextmd
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|short
name|state
decl_stmt|;
name|olddap
operator|=
name|inodedep
operator|->
name|id_mkdiradd
expr_stmt|;
name|inodedep
operator|->
name|id_mkdiradd
operator|=
name|newdap
expr_stmt|;
if|if
condition|(
operator|(
name|olddap
operator|->
name|da_state
operator|&
operator|(
name|MKDIR_PARENT
operator||
name|MKDIR_BODY
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|newdap
operator|->
name|da_state
operator|&=
operator|~
name|DEPCOMPLETE
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|inodedep
operator|->
name|id_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
for|for
control|(
name|mkdir
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ump
operator|->
name|softdep_mkdirlisthd
argument_list|)
init|;
name|mkdir
condition|;
name|mkdir
operator|=
name|nextmd
control|)
block|{
name|nextmd
operator|=
name|LIST_NEXT
argument_list|(
name|mkdir
argument_list|,
name|md_mkdirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
operator|->
name|md_diradd
operator|!=
name|olddap
condition|)
continue|continue;
name|mkdir
operator|->
name|md_diradd
operator|=
name|newdap
expr_stmt|;
name|state
operator|=
name|mkdir
operator|->
name|md_state
operator|&
operator|(
name|MKDIR_PARENT
operator||
name|MKDIR_BODY
operator|)
expr_stmt|;
name|newdap
operator|->
name|da_state
operator||=
name|state
expr_stmt|;
name|olddap
operator|->
name|da_state
operator|&=
operator|~
name|state
expr_stmt|;
if|if
condition|(
operator|(
name|olddap
operator|->
name|da_state
operator|&
operator|(
name|MKDIR_PARENT
operator||
name|MKDIR_BODY
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|olddap
operator|->
name|da_state
operator|&
operator|(
name|MKDIR_PARENT
operator||
name|MKDIR_BODY
operator|)
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"merge_diradd: unfound ref"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Any mkdir related journal items are not safe to be freed until 	 * the new name is stable. 	 */
name|jwork_move
argument_list|(
operator|&
name|newdap
operator|->
name|da_jwork
argument_list|,
operator|&
name|olddap
operator|->
name|da_jwork
argument_list|)
expr_stmt|;
name|olddap
operator|->
name|da_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|complete_diradd
argument_list|(
name|olddap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move the diradd to the pending list when all diradd dependencies are  * complete.  */
end_comment

begin_function
specifier|static
name|void
name|complete_diradd
parameter_list|(
name|dap
parameter_list|)
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
block|{
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
block|{
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|DIRCHG
condition|)
name|pagedep
operator|=
name|dap
operator|->
name|da_previous
operator|->
name|dm_pagedep
expr_stmt|;
else|else
name|pagedep
operator|=
name|dap
operator|->
name|da_pagedep
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Cancel a diradd when a dirrem overlaps with it.  We must cancel the journal  * add entries and conditonally journal the remove.  */
end_comment

begin_function
specifier|static
name|void
name|cancel_diradd
parameter_list|(
name|dap
parameter_list|,
name|dirrem
parameter_list|,
name|jremref
parameter_list|,
name|dotremref
parameter_list|,
name|dotdotremref
parameter_list|)
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|jremref
modifier|*
name|jremref
decl_stmt|;
name|struct
name|jremref
modifier|*
name|dotremref
decl_stmt|;
name|struct
name|jremref
modifier|*
name|dotdotremref
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|inoref
modifier|*
name|inoref
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|mkdir
modifier|*
name|mkdir
decl_stmt|;
comment|/* 	 * If no remove references were allocated we're on a non-journaled 	 * filesystem and can skip the cancel step. 	 */
if|if
condition|(
name|jremref
operator|==
name|NULL
condition|)
block|{
name|free_diradd
argument_list|(
name|dap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Cancel the primary name an free it if it does not require 	 * journaling. 	 */
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|dap
operator|->
name|da_list
operator|.
name|wk_mp
argument_list|,
name|dap
operator|->
name|da_newinum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Abort the addref that reference this diradd.  */
name|TAILQ_FOREACH
argument_list|(
argument|inoref
argument_list|,
argument|&inodedep->id_inoreflst
argument_list|,
argument|if_deps
argument_list|)
block|{
if|if
condition|(
name|inoref
operator|->
name|if_list
operator|.
name|wk_type
operator|!=
name|D_JADDREF
condition|)
continue|continue;
name|jaddref
operator|=
operator|(
expr|struct
name|jaddref
operator|*
operator|)
name|inoref
expr_stmt|;
if|if
condition|(
name|jaddref
operator|->
name|ja_diradd
operator|!=
name|dap
condition|)
continue|continue;
if|if
condition|(
name|cancel_jaddref
argument_list|(
name|jaddref
argument_list|,
name|inodedep
argument_list|,
operator|&
name|dirrem
operator|->
name|dm_jwork
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free_jremref
argument_list|(
name|jremref
argument_list|)
expr_stmt|;
name|jremref
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* 	 * Cancel subordinate names and free them if they do not require 	 * journaling. 	 */
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
operator|(
name|MKDIR_PARENT
operator||
name|MKDIR_BODY
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|dap
operator|->
name|da_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|mkdir
argument_list|,
argument|&ump->softdep_mkdirlisthd
argument_list|,
argument|md_mkdirs
argument_list|)
block|{
if|if
condition|(
name|mkdir
operator|->
name|md_diradd
operator|!=
name|dap
condition|)
continue|continue;
if|if
condition|(
operator|(
name|jaddref
operator|=
name|mkdir
operator|->
name|md_jaddref
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|mkdir
operator|->
name|md_jaddref
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mkdir
operator|->
name|md_state
operator|&
name|MKDIR_PARENT
condition|)
block|{
if|if
condition|(
name|cancel_jaddref
argument_list|(
name|jaddref
argument_list|,
name|NULL
argument_list|,
operator|&
name|dirrem
operator|->
name|dm_jwork
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free_jremref
argument_list|(
name|dotdotremref
argument_list|)
expr_stmt|;
name|dotdotremref
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cancel_jaddref
argument_list|(
name|jaddref
argument_list|,
name|inodedep
argument_list|,
operator|&
name|dirrem
operator|->
name|dm_jwork
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free_jremref
argument_list|(
name|dotremref
argument_list|)
expr_stmt|;
name|dotremref
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|jremref
condition|)
name|journal_jremref
argument_list|(
name|dirrem
argument_list|,
name|jremref
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
name|dotremref
condition|)
name|journal_jremref
argument_list|(
name|dirrem
argument_list|,
name|dotremref
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
name|dotdotremref
condition|)
name|journal_jremref
argument_list|(
name|dirrem
argument_list|,
name|dotdotremref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|jwork_move
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jwork
argument_list|,
operator|&
name|dap
operator|->
name|da_jwork
argument_list|)
expr_stmt|;
name|free_diradd
argument_list|(
name|dap
argument_list|,
operator|&
name|dirrem
operator|->
name|dm_jwork
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a diradd dependency structure. This routine must be called  * with splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|void
name|free_diradd
parameter_list|(
name|dap
parameter_list|,
name|wkhd
parameter_list|)
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|mkdir
modifier|*
name|mkdir
decl_stmt|,
modifier|*
name|nextmd
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|dap
operator|->
name|da_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|ONWORKLIST
condition|)
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|dap
operator|->
name|da_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
name|DIRCHG
operator|)
operator|==
literal|0
condition|)
block|{
name|pagedep
operator|=
name|dap
operator|->
name|da_pagedep
expr_stmt|;
block|}
else|else
block|{
name|dirrem
operator|=
name|dap
operator|->
name|da_previous
expr_stmt|;
name|pagedep
operator|=
name|dirrem
operator|->
name|dm_pagedep
expr_stmt|;
name|dirrem
operator|->
name|dm_dirinum
operator|=
name|pagedep
operator|->
name|pd_ino
expr_stmt|;
name|dirrem
operator|->
name|dm_state
operator||=
name|COMPLETE
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jremrefhd
argument_list|)
condition|)
name|add_to_worklist
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|pagedep
operator|->
name|pd_list
operator|.
name|wk_mp
argument_list|,
name|dap
operator|->
name|da_newinum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|inodedep
operator|->
name|id_mkdiradd
operator|==
name|dap
condition|)
name|inodedep
operator|->
name|id_mkdiradd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
operator|(
name|MKDIR_PARENT
operator||
name|MKDIR_BODY
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|mkdir
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ump
operator|->
name|softdep_mkdirlisthd
argument_list|)
init|;
name|mkdir
condition|;
name|mkdir
operator|=
name|nextmd
control|)
block|{
name|nextmd
operator|=
name|LIST_NEXT
argument_list|(
name|mkdir
argument_list|,
name|md_mkdirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
operator|->
name|md_diradd
operator|!=
name|dap
condition|)
continue|continue;
name|dap
operator|->
name|da_state
operator|&=
operator|~
operator|(
name|mkdir
operator|->
name|md_state
operator|&
operator|(
name|MKDIR_PARENT
operator||
name|MKDIR_BODY
operator|)
operator|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|mkdir
argument_list|,
name|md_mkdirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
operator|->
name|md_state
operator|&
name|ONWORKLIST
condition|)
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|mkdir
operator|->
name|md_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
operator|->
name|md_jaddref
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"free_diradd: Unexpected jaddref"
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|mkdir
argument_list|,
name|D_MKDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
operator|(
name|MKDIR_PARENT
operator||
name|MKDIR_BODY
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
operator|(
name|MKDIR_PARENT
operator||
name|MKDIR_BODY
operator|)
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"free_diradd: unfound ref"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inodedep
condition|)
name|free_inodedep
argument_list|(
name|inodedep
argument_list|)
expr_stmt|;
comment|/* 	 * Free any journal segments waiting for the directory write. 	 */
name|handle_jwork
argument_list|(
operator|&
name|dap
operator|->
name|da_jwork
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|dap
argument_list|,
name|D_DIRADD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Directory entry removal dependencies.  *   * When removing a directory entry, the entry's inode pointer must be  * zero'ed on disk before the corresponding inode's link count is decremented  * (possibly freeing the inode for re-use). This dependency is handled by  * updating the directory entry but delaying the inode count reduction until  * after the directory block has been written to disk. After this point, the  * inode count can be decremented whenever it is convenient.  */
end_comment

begin_comment
comment|/*  * This routine should be called immediately after removing  * a directory entry.  The inode's link count should not be  * decremented by the calling procedure -- the soft updates  * code will do this task when it is safe.  */
end_comment

begin_function
name|void
name|softdep_setup_remove
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|,
name|ip
parameter_list|,
name|isrmdir
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing directory block */
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
comment|/* inode for the directory being modified */
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode for directory entry being removed */
name|int
name|isrmdir
decl_stmt|;
comment|/* indicates if doing RMDIR */
block|{
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|,
modifier|*
name|prevdirrem
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|int
name|direct
decl_stmt|;
name|ump
operator|=
name|ITOUMP
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_remove called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a new dirrem if appropriate and ACQUIRE_LOCK.  We want 	 * newdirrem() to setup the full directory remove which requires 	 * isrmdir> 1. 	 */
name|dirrem
operator|=
name|newdirrem
argument_list|(
name|bp
argument_list|,
name|dp
argument_list|,
name|ip
argument_list|,
name|isrmdir
argument_list|,
operator|&
name|prevdirrem
argument_list|)
expr_stmt|;
comment|/* 	 * Add the dirrem to the inodedep's pending remove list for quick 	 * discovery later. 	 */
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_setup_remove: Lost inodedep."
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|UNLINKED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"inode unlinked"
operator|)
argument_list|)
expr_stmt|;
name|dirrem
operator|->
name|dm_state
operator||=
name|ONDEPLIST
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|inodedep
operator|->
name|id_dirremhd
argument_list|,
name|dirrem
argument_list|,
name|dm_inonext
argument_list|)
expr_stmt|;
comment|/* 	 * If the COMPLETE flag is clear, then there were no active 	 * entries and we want to roll back to a zeroed entry until 	 * the new inode is committed to disk. If the COMPLETE flag is 	 * set then we have deleted an entry that never made it to 	 * disk. If the entry we deleted resulted from a name change, 	 * then the old name still resides on disk. We cannot delete 	 * its inode (returned to us in prevdirrem) until the zeroed 	 * directory entry gets to disk. The new inode has never been 	 * referenced on the disk, so can be deleted immediately. 	 */
if|if
condition|(
operator|(
name|dirrem
operator|->
name|dm_state
operator|&
name|COMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_pagedep
operator|->
name|pd_dirremhd
argument_list|,
name|dirrem
argument_list|,
name|dm_next
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prevdirrem
operator|!=
name|NULL
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_pagedep
operator|->
name|pd_dirremhd
argument_list|,
name|prevdirrem
argument_list|,
name|dm_next
argument_list|)
expr_stmt|;
name|dirrem
operator|->
name|dm_dirinum
operator|=
name|dirrem
operator|->
name|dm_pagedep
operator|->
name|pd_ino
expr_stmt|;
name|direct
operator|=
name|LIST_EMPTY
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jremrefhd
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|direct
condition|)
name|handle_workitem_remove
argument_list|(
name|dirrem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check for an entry matching 'offset' on both the pd_dirraddhd list and the  * pd_pendinghd list of a pagedep.  */
end_comment

begin_function
specifier|static
name|struct
name|diradd
modifier|*
name|diradd_lookup
parameter_list|(
name|pagedep
parameter_list|,
name|offset
parameter_list|)
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|dap
argument_list|,
argument|&pagedep->pd_diraddhd[DIRADDHASH(offset)]
argument_list|,
argument|da_pdlist
argument_list|)
if|if
condition|(
name|dap
operator|->
name|da_offset
operator|==
name|offset
condition|)
return|return
operator|(
name|dap
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|dap
argument_list|,
argument|&pagedep->pd_pendinghd
argument_list|,
argument|da_pdlist
argument_list|)
if|if
condition|(
name|dap
operator|->
name|da_offset
operator|==
name|offset
condition|)
return|return
operator|(
name|dap
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search for a .. diradd dependency in a directory that is being removed.  * If the directory was renamed to a new parent we have a diradd rather  * than a mkdir for the .. entry.  We need to cancel it now before  * it is found in truncate().  */
end_comment

begin_function
specifier|static
name|struct
name|jremref
modifier|*
name|cancel_diradd_dotdot
parameter_list|(
name|ip
parameter_list|,
name|dirrem
parameter_list|,
name|jremref
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|jremref
modifier|*
name|jremref
decl_stmt|;
block|{
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
if|if
condition|(
name|pagedep_lookup
argument_list|(
name|ITOVFS
argument_list|(
name|ip
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|pagedep
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|jremref
operator|)
return|;
name|dap
operator|=
name|diradd_lookup
argument_list|(
name|pagedep
argument_list|,
name|DOTDOT_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dap
operator|==
name|NULL
condition|)
return|return
operator|(
name|jremref
operator|)
return|;
name|cancel_diradd
argument_list|(
name|dap
argument_list|,
name|dirrem
argument_list|,
name|jremref
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Mark any journal work as belonging to the parent so it is freed 	 * with the .. reference. 	 */
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&dirrem->dm_jwork
argument_list|,
argument|wk_list
argument_list|)
name|wk
operator|->
name|wk_state
operator||=
name|MKDIR_PARENT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cancel the MKDIR_PARENT mkdir component of a diradd when we're going to  * replace it with a dirrem/diradd pair as a result of re-parenting a  * directory.  This ensures that we don't simultaneously have a mkdir and  * a diradd for the same .. entry.  */
end_comment

begin_function
specifier|static
name|struct
name|jremref
modifier|*
name|cancel_mkdir_dotdot
parameter_list|(
name|ip
parameter_list|,
name|dirrem
parameter_list|,
name|jremref
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|jremref
modifier|*
name|jremref
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|mkdir
modifier|*
name|mkdir
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|ITOVFS
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|jremref
operator|)
return|;
name|dap
operator|=
name|inodedep
operator|->
name|id_mkdiradd
expr_stmt|;
if|if
condition|(
name|dap
operator|==
name|NULL
operator|||
operator|(
name|dap
operator|->
name|da_state
operator|&
name|MKDIR_PARENT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|jremref
operator|)
return|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|inodedep
operator|->
name|id_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
for|for
control|(
name|mkdir
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ump
operator|->
name|softdep_mkdirlisthd
argument_list|)
init|;
name|mkdir
condition|;
name|mkdir
operator|=
name|LIST_NEXT
argument_list|(
name|mkdir
argument_list|,
name|md_mkdirs
argument_list|)
control|)
if|if
condition|(
name|mkdir
operator|->
name|md_diradd
operator|==
name|dap
operator|&&
name|mkdir
operator|->
name|md_state
operator|&
name|MKDIR_PARENT
condition|)
break|break;
if|if
condition|(
name|mkdir
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"cancel_mkdir_dotdot: Unable to find mkdir\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|jaddref
operator|=
name|mkdir
operator|->
name|md_jaddref
operator|)
operator|!=
name|NULL
condition|)
block|{
name|mkdir
operator|->
name|md_jaddref
operator|=
name|NULL
expr_stmt|;
name|jaddref
operator|->
name|ja_state
operator|&=
operator|~
name|MKDIR_PARENT
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|jaddref
operator|->
name|ja_ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"cancel_mkdir_dotdot: Lost parent inodedep"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_jaddref
argument_list|(
name|jaddref
argument_list|,
name|inodedep
argument_list|,
operator|&
name|dirrem
operator|->
name|dm_jwork
argument_list|)
condition|)
block|{
name|journal_jremref
argument_list|(
name|dirrem
argument_list|,
name|jremref
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
name|jremref
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mkdir
operator|->
name|md_state
operator|&
name|ONWORKLIST
condition|)
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|mkdir
operator|->
name|md_list
argument_list|)
expr_stmt|;
name|mkdir
operator|->
name|md_state
operator||=
name|ALLCOMPLETE
expr_stmt|;
name|complete_mkdir
argument_list|(
name|mkdir
argument_list|)
expr_stmt|;
return|return
operator|(
name|jremref
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|journal_jremref
parameter_list|(
name|dirrem
parameter_list|,
name|jremref
parameter_list|,
name|inodedep
parameter_list|)
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|jremref
modifier|*
name|jremref
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
block|{
if|if
condition|(
name|inodedep
operator|==
name|NULL
condition|)
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|jremref
operator|->
name|jr_list
operator|.
name|wk_mp
argument_list|,
name|jremref
operator|->
name|jr_ref
operator|.
name|if_ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"journal_jremref: Lost inodedep"
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jremrefhd
argument_list|,
name|jremref
argument_list|,
name|jr_deps
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
operator|&
name|jremref
operator|->
name|jr_ref
argument_list|,
name|if_deps
argument_list|)
expr_stmt|;
name|add_to_journal
argument_list|(
operator|&
name|jremref
operator|->
name|jr_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dirrem_journal
parameter_list|(
name|dirrem
parameter_list|,
name|jremref
parameter_list|,
name|dotremref
parameter_list|,
name|dotdotremref
parameter_list|)
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|jremref
modifier|*
name|jremref
decl_stmt|;
name|struct
name|jremref
modifier|*
name|dotremref
decl_stmt|;
name|struct
name|jremref
modifier|*
name|dotdotremref
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|jremref
operator|->
name|jr_list
operator|.
name|wk_mp
argument_list|,
name|jremref
operator|->
name|jr_ref
operator|.
name|if_ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"dirrem_journal: Lost inodedep"
argument_list|)
expr_stmt|;
name|journal_jremref
argument_list|(
name|dirrem
argument_list|,
name|jremref
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
name|dotremref
condition|)
name|journal_jremref
argument_list|(
name|dirrem
argument_list|,
name|dotremref
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
name|dotdotremref
condition|)
name|journal_jremref
argument_list|(
name|dirrem
argument_list|,
name|dotdotremref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new dirrem if appropriate and return it along with  * its associated pagedep. Called without a lock, returns with lock.  */
end_comment

begin_function
specifier|static
name|struct
name|dirrem
modifier|*
name|newdirrem
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|,
name|ip
parameter_list|,
name|isrmdir
parameter_list|,
name|prevdirremp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing directory block */
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
comment|/* inode for the directory being modified */
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode for directory entry being removed */
name|int
name|isrmdir
decl_stmt|;
comment|/* indicates if doing RMDIR */
name|struct
name|dirrem
modifier|*
modifier|*
name|prevdirremp
decl_stmt|;
comment|/* previously referenced inode, if any */
block|{
name|int
name|offset
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|jremref
modifier|*
name|jremref
decl_stmt|;
name|struct
name|jremref
modifier|*
name|dotremref
decl_stmt|;
name|struct
name|jremref
modifier|*
name|dotdotremref
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
comment|/* 	 * Whiteouts have no deletion dependencies. 	 */
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"newdirrem: whiteout"
argument_list|)
expr_stmt|;
name|dvp
operator|=
name|ITOV
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ump
operator|=
name|ITOUMP
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* 	 * If the system is over its limit and our filesystem is 	 * responsible for more than our share of that usage and 	 * we are not a snapshot, request some inodedep cleanup. 	 * Limiting the number of dirrem structures will also limit 	 * the number of freefile and freeblks structures. 	 */
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SNAPSHOT
argument_list|(
name|ip
argument_list|)
operator|&&
name|softdep_excess_items
argument_list|(
name|ump
argument_list|,
name|D_DIRREM
argument_list|)
condition|)
name|schedule_cleanup
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|dirrem
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dirrem
argument_list|)
argument_list|,
name|M_DIRREM
argument_list|,
name|M_SOFTDEP_FLAGS
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|,
name|D_DIRREM
argument_list|,
name|dvp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jremrefhd
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jwork
argument_list|)
expr_stmt|;
name|dirrem
operator|->
name|dm_state
operator|=
name|isrmdir
condition|?
name|RMDIR
else|:
literal|0
expr_stmt|;
name|dirrem
operator|->
name|dm_oldinum
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
operator|*
name|prevdirremp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Allocate remove reference structures to track journal write 	 * dependencies.  We will always have one for the link and 	 * when doing directories we will always have one more for dot. 	 * When renaming a directory we skip the dotdot link change so 	 * this is not needed. 	 */
name|jremref
operator|=
name|dotremref
operator|=
name|dotdotremref
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|DOINGSUJ
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
if|if
condition|(
name|isrmdir
condition|)
block|{
name|jremref
operator|=
name|newjremref
argument_list|(
name|dirrem
argument_list|,
name|dp
argument_list|,
name|ip
argument_list|,
name|dp
operator|->
name|i_offset
argument_list|,
name|ip
operator|->
name|i_effnlink
operator|+
literal|2
argument_list|)
expr_stmt|;
name|dotremref
operator|=
name|newjremref
argument_list|(
name|dirrem
argument_list|,
name|ip
argument_list|,
name|ip
argument_list|,
name|DOT_OFFSET
argument_list|,
name|ip
operator|->
name|i_effnlink
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dotdotremref
operator|=
name|newjremref
argument_list|(
name|dirrem
argument_list|,
name|ip
argument_list|,
name|dp
argument_list|,
name|DOTDOT_OFFSET
argument_list|,
name|dp
operator|->
name|i_effnlink
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dotdotremref
operator|->
name|jr_state
operator||=
name|MKDIR_PARENT
expr_stmt|;
block|}
else|else
name|jremref
operator|=
name|newjremref
argument_list|(
name|dirrem
argument_list|,
name|dp
argument_list|,
name|ip
argument_list|,
name|dp
operator|->
name|i_offset
argument_list|,
name|ip
operator|->
name|i_effnlink
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|lbn
operator|=
name|lblkno
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|,
name|dp
operator|->
name|i_offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|blkoff
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|,
name|dp
operator|->
name|i_offset
argument_list|)
expr_stmt|;
name|pagedep_lookup
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|,
name|bp
argument_list|,
name|dp
operator|->
name|i_number
argument_list|,
name|lbn
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|pagedep
argument_list|)
expr_stmt|;
name|dirrem
operator|->
name|dm_pagedep
operator|=
name|pagedep
expr_stmt|;
name|dirrem
operator|->
name|dm_offset
operator|=
name|offset
expr_stmt|;
comment|/* 	 * If we're renaming a .. link to a new directory, cancel any 	 * existing MKDIR_PARENT mkdir.  If it has already been canceled 	 * the jremref is preserved for any potential diradd in this 	 * location.  This can not coincide with a rmdir. 	 */
if|if
condition|(
name|dp
operator|->
name|i_offset
operator|==
name|DOTDOT_OFFSET
condition|)
block|{
if|if
condition|(
name|isrmdir
condition|)
name|panic
argument_list|(
literal|"newdirrem: .. directory change during remove?"
argument_list|)
expr_stmt|;
name|jremref
operator|=
name|cancel_mkdir_dotdot
argument_list|(
name|dp
argument_list|,
name|dirrem
argument_list|,
name|jremref
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're removing a directory search for the .. dependency now and 	 * cancel it.  Any pending journal work will be added to the dirrem 	 * to be completed when the workitem remove completes. 	 */
if|if
condition|(
name|isrmdir
condition|)
name|dotdotremref
operator|=
name|cancel_diradd_dotdot
argument_list|(
name|ip
argument_list|,
name|dirrem
argument_list|,
name|dotdotremref
argument_list|)
expr_stmt|;
comment|/* 	 * Check for a diradd dependency for the same directory entry. 	 * If present, then both dependencies become obsolete and can 	 * be de-allocated. 	 */
name|dap
operator|=
name|diradd_lookup
argument_list|(
name|pagedep
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dap
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Link the jremref structures into the dirrem so they are 		 * written prior to the pagedep. 		 */
if|if
condition|(
name|jremref
condition|)
name|dirrem_journal
argument_list|(
name|dirrem
argument_list|,
name|jremref
argument_list|,
name|dotremref
argument_list|,
name|dotdotremref
argument_list|)
expr_stmt|;
return|return
operator|(
name|dirrem
operator|)
return|;
block|}
comment|/* 	 * Must be ATTACHED at this point. 	 */
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
name|ATTACHED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"newdirrem: not ATTACHED"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dap
operator|->
name|da_newinum
operator|!=
name|ip
operator|->
name|i_number
condition|)
name|panic
argument_list|(
literal|"newdirrem: inum %ju should be %ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ip
operator|->
name|i_number
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dap
operator|->
name|da_newinum
argument_list|)
expr_stmt|;
comment|/* 	 * If we are deleting a changed name that never made it to disk, 	 * then return the dirrem describing the previous inode (which 	 * represents the inode currently referenced from this entry on disk). 	 */
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
name|DIRCHG
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|prevdirremp
operator|=
name|dap
operator|->
name|da_previous
expr_stmt|;
name|dap
operator|->
name|da_state
operator|&=
operator|~
name|DIRCHG
expr_stmt|;
name|dap
operator|->
name|da_pagedep
operator|=
name|pagedep
expr_stmt|;
block|}
comment|/* 	 * We are deleting an entry that never made it to disk. 	 * Mark it COMPLETE so we can delete its inode immediately. 	 */
name|dirrem
operator|->
name|dm_state
operator||=
name|COMPLETE
expr_stmt|;
name|cancel_diradd
argument_list|(
name|dap
argument_list|,
name|dirrem
argument_list|,
name|jremref
argument_list|,
name|dotremref
argument_list|,
name|dotdotremref
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUJ_DEBUG
if|if
condition|(
name|isrmdir
operator|==
literal|0
condition|)
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&dirrem->dm_jwork
argument_list|,
argument|wk_list
argument_list|)
if|if
condition|(
name|wk
operator|->
name|wk_state
operator|&
operator|(
name|MKDIR_BODY
operator||
name|MKDIR_PARENT
operator|)
condition|)
name|panic
argument_list|(
literal|"bad wk %p (0x%X)\n"
argument_list|,
name|wk
argument_list|,
name|wk
operator|->
name|wk_state
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|dirrem
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Directory entry change dependencies.  *   * Changing an existing directory entry requires that an add operation  * be completed first followed by a deletion. The semantics for the addition  * are identical to the description of adding a new entry above except  * that the rollback is to the old inode number rather than zero. Once  * the addition dependency is completed, the removal is done as described  * in the removal routine above.  */
end_comment

begin_comment
comment|/*  * This routine should be called immediately after changing  * a directory entry.  The inode's link count should not be  * decremented by the calling procedure -- the soft updates  * code will perform this task when it is safe.  */
end_comment

begin_function
name|void
name|softdep_setup_directory_change
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|,
name|ip
parameter_list|,
name|newinum
parameter_list|,
name|isrmdir
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing directory block */
name|struct
name|inode
modifier|*
name|dp
decl_stmt|;
comment|/* inode for the directory being modified */
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* inode for directory entry being removed */
name|ino_t
name|newinum
decl_stmt|;
comment|/* new inode number for changed entry */
name|int
name|isrmdir
decl_stmt|;
comment|/* indicates if doing RMDIR */
block|{
name|int
name|offset
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
init|=
name|NULL
decl_stmt|;
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|,
modifier|*
name|prevdirrem
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|mp
operator|=
name|ITOVFS
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|offset
operator|=
name|blkoff
argument_list|(
name|ump
operator|->
name|um_fs
argument_list|,
name|dp
operator|->
name|i_offset
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_directory_change called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Whiteouts do not need diradd dependencies. 	 */
if|if
condition|(
name|newinum
operator|!=
name|UFS_WINO
condition|)
block|{
name|dap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|diradd
argument_list|)
argument_list|,
name|M_DIRADD
argument_list|,
name|M_SOFTDEP_FLAGS
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|dap
operator|->
name|da_list
argument_list|,
name|D_DIRADD
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|dap
operator|->
name|da_state
operator|=
name|DIRCHG
operator||
name|ATTACHED
operator||
name|DEPCOMPLETE
expr_stmt|;
name|dap
operator|->
name|da_offset
operator|=
name|offset
expr_stmt|;
name|dap
operator|->
name|da_newinum
operator|=
name|newinum
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|dap
operator|->
name|da_jwork
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate a new dirrem and ACQUIRE_LOCK. 	 */
name|dirrem
operator|=
name|newdirrem
argument_list|(
name|bp
argument_list|,
name|dp
argument_list|,
name|ip
argument_list|,
name|isrmdir
argument_list|,
operator|&
name|prevdirrem
argument_list|)
expr_stmt|;
name|pagedep
operator|=
name|dirrem
operator|->
name|dm_pagedep
expr_stmt|;
comment|/* 	 * The possible values for isrmdir: 	 *	0 - non-directory file rename 	 *	1 - directory rename within same directory 	 *   inum - directory rename to new directory of given inode number 	 * When renaming to a new directory, we are both deleting and 	 * creating a new directory entry, so the link count on the new 	 * directory should not change. Thus we do not need the followup 	 * dirrem which is usually done in handle_workitem_remove. We set 	 * the DIRCHG flag to tell handle_workitem_remove to skip the  	 * followup dirrem. 	 */
if|if
condition|(
name|isrmdir
operator|>
literal|1
condition|)
name|dirrem
operator|->
name|dm_state
operator||=
name|DIRCHG
expr_stmt|;
comment|/* 	 * Whiteouts have no additional dependencies, 	 * so just put the dirrem on the correct list. 	 */
if|if
condition|(
name|newinum
operator|==
name|UFS_WINO
condition|)
block|{
if|if
condition|(
operator|(
name|dirrem
operator|->
name|dm_state
operator|&
name|COMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_dirremhd
argument_list|,
name|dirrem
argument_list|,
name|dm_next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dirrem
operator|->
name|dm_dirinum
operator|=
name|pagedep
operator|->
name|pd_ino
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jremrefhd
argument_list|)
condition|)
name|add_to_worklist
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Add the dirrem to the inodedep's pending remove list for quick 	 * discovery later.  A valid nlinkdelta ensures that this lookup 	 * will not fail. 	 */
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_setup_directory_change: Lost inodedep."
argument_list|)
expr_stmt|;
name|dirrem
operator|->
name|dm_state
operator||=
name|ONDEPLIST
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|inodedep
operator|->
name|id_dirremhd
argument_list|,
name|dirrem
argument_list|,
name|dm_inonext
argument_list|)
expr_stmt|;
comment|/* 	 * If the COMPLETE flag is clear, then there were no active 	 * entries and we want to roll back to the previous inode until 	 * the new inode is committed to disk. If the COMPLETE flag is 	 * set, then we have deleted an entry that never made it to disk. 	 * If the entry we deleted resulted from a name change, then the old 	 * inode reference still resides on disk. Any rollback that we do 	 * needs to be to that old inode (returned to us in prevdirrem). If 	 * the entry we deleted resulted from a create, then there is 	 * no entry on the disk, so we want to roll back to zero rather 	 * than the uncommitted inode. In either of the COMPLETE cases we 	 * want to immediately free the unwritten and unreferenced inode. 	 */
if|if
condition|(
operator|(
name|dirrem
operator|->
name|dm_state
operator|&
name|COMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|dap
operator|->
name|da_previous
operator|=
name|dirrem
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prevdirrem
operator|!=
name|NULL
condition|)
block|{
name|dap
operator|->
name|da_previous
operator|=
name|prevdirrem
expr_stmt|;
block|}
else|else
block|{
name|dap
operator|->
name|da_state
operator|&=
operator|~
name|DIRCHG
expr_stmt|;
name|dap
operator|->
name|da_pagedep
operator|=
name|pagedep
expr_stmt|;
block|}
name|dirrem
operator|->
name|dm_dirinum
operator|=
name|pagedep
operator|->
name|pd_ino
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jremrefhd
argument_list|)
condition|)
name|add_to_worklist
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Lookup the jaddref for this journal entry.  We must finish 	 * initializing it and make the diradd write dependent on it. 	 * If we're not journaling, put it on the id_bufwait list if the 	 * inode is not yet written. If it is written, do the post-inode 	 * write processing to put it on the id_pendinghd list. 	 */
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|newinum
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
name|MOUNTEDSUJ
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|jaddref
operator|=
operator|(
expr|struct
name|jaddref
operator|*
operator|)
name|TAILQ_LAST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
name|inoreflst
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|jaddref
operator|!=
name|NULL
operator|&&
name|jaddref
operator|->
name|ja_parent
operator|==
name|dp
operator|->
name|i_number
argument_list|,
operator|(
literal|"softdep_setup_directory_change: bad jaddref %p"
operator|,
name|jaddref
operator|)
argument_list|)
expr_stmt|;
name|jaddref
operator|->
name|ja_diroff
operator|=
name|dp
operator|->
name|i_offset
expr_stmt|;
name|jaddref
operator|->
name|ja_diradd
operator|=
name|dap
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|DIRADDHASH
argument_list|(
name|offset
argument_list|)
index|]
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
name|add_to_journal
argument_list|(
operator|&
name|jaddref
operator|->
name|ja_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
block|{
name|dap
operator|->
name|da_state
operator||=
name|COMPLETE
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_pendinghd
argument_list|,
operator|&
name|dap
operator|->
name|da_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|DIRADDHASH
argument_list|(
name|offset
argument_list|)
index|]
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|,
operator|&
name|dap
operator|->
name|da_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're making a new name for a directory that has not been 	 * committed when need to move the dot and dotdot references to 	 * this new name. 	 */
if|if
condition|(
name|inodedep
operator|->
name|id_mkdiradd
operator|&&
name|dp
operator|->
name|i_offset
operator|!=
name|DOTDOT_OFFSET
condition|)
name|merge_diradd
argument_list|(
name|inodedep
argument_list|,
name|dap
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called whenever the link count on an inode is changed.  * It creates an inode dependency so that the new reference(s)  * to the inode cannot be committed to disk until the updated  * inode has been written.  */
end_comment

begin_function
name|void
name|softdep_change_linkcnt
parameter_list|(
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* the inode with the increased link count */
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|ITOUMP
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_change_linkcnt called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|inodedep_lookup
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|DEPALLOC
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_nlink
operator|<
name|ip
operator|->
name|i_effnlink
condition|)
name|panic
argument_list|(
literal|"softdep_change_linkcnt: bad delta"
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_nlinkdelta
operator|=
name|ip
operator|->
name|i_nlink
operator|-
name|ip
operator|->
name|i_effnlink
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attach a sbdep dependency to the superblock buf so that we can keep  * track of the head of the linked list of referenced but unlinked inodes.  */
end_comment

begin_function
name|void
name|softdep_setup_sbupdate
parameter_list|(
name|ump
parameter_list|,
name|fs
parameter_list|,
name|bp
parameter_list|)
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|sbdep
modifier|*
name|sbdep
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_sbupdate called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&bp->b_dep
argument_list|,
argument|wk_list
argument_list|)
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|==
name|D_SBDEP
condition|)
break|break;
if|if
condition|(
name|wk
operator|!=
name|NULL
condition|)
return|return;
name|sbdep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbdep
argument_list|)
argument_list|,
name|M_SBDEP
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|workitem_alloc
argument_list|(
operator|&
name|sbdep
operator|->
name|sb_list
argument_list|,
name|D_SBDEP
argument_list|,
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
expr_stmt|;
name|sbdep
operator|->
name|sb_fs
operator|=
name|fs
expr_stmt|;
name|sbdep
operator|->
name|sb_ump
operator|=
name|ump
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|sbdep
operator|->
name|sb_list
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the first unlinked inodedep which is ready to be the head of the  * list.  The inodedep and all those after it must have valid next pointers.  */
end_comment

begin_function
specifier|static
name|struct
name|inodedep
modifier|*
name|first_unlinked_inodedep
parameter_list|(
name|ump
parameter_list|)
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|idp
decl_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
for|for
control|(
name|inodedep
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|ump
operator|->
name|softdep_unlinked
argument_list|,
name|inodedeplst
argument_list|)
init|;
name|inodedep
condition|;
name|inodedep
operator|=
name|idp
control|)
block|{
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|UNLINKNEXT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|idp
operator|=
name|TAILQ_PREV
argument_list|(
name|inodedep
argument_list|,
name|inodedeplst
argument_list|,
name|id_unlinked
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|==
name|NULL
operator|||
operator|(
name|idp
operator|->
name|id_state
operator|&
name|UNLINKNEXT
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|UNLINKPREV
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|inodedep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the sujfree unlinked head pointer prior to writing a superblock.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_write_sbdep
parameter_list|(
name|sbdep
parameter_list|)
name|struct
name|sbdep
modifier|*
name|sbdep
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|fs
modifier|*
name|bpfs
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|bpfs
operator|=
name|sbdep
operator|->
name|sb_fs
expr_stmt|;
name|fs
operator|=
name|sbdep
operator|->
name|sb_ump
operator|->
name|um_fs
expr_stmt|;
name|inodedep
operator|=
name|first_unlinked_inodedep
argument_list|(
name|sbdep
operator|->
name|sb_ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep
condition|)
block|{
name|fs
operator|->
name|fs_sujfree
operator|=
name|inodedep
operator|->
name|id_ino
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator||=
name|UNLINKPREV
expr_stmt|;
block|}
else|else
name|fs
operator|->
name|fs_sujfree
operator|=
literal|0
expr_stmt|;
name|bpfs
operator|->
name|fs_sujfree
operator|=
name|fs
operator|->
name|fs_sujfree
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * After a superblock is written determine whether it must be written again  * due to a changing unlinked list head.  */
end_comment

begin_function
specifier|static
name|int
name|handle_written_sbdep
parameter_list|(
name|sbdep
parameter_list|,
name|bp
parameter_list|)
name|struct
name|sbdep
modifier|*
name|sbdep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|LOCK_OWNED
argument_list|(
name|sbdep
operator|->
name|sb_ump
argument_list|)
expr_stmt|;
name|fs
operator|=
name|sbdep
operator|->
name|sb_fs
expr_stmt|;
comment|/* 	 * If the superblock doesn't match the in-memory list start over. 	 */
name|inodedep
operator|=
name|first_unlinked_inodedep
argument_list|(
name|sbdep
operator|->
name|sb_ump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|&&
name|fs
operator|->
name|fs_sujfree
operator|!=
name|inodedep
operator|->
name|id_ino
operator|)
operator|||
operator|(
name|inodedep
operator|==
name|NULL
operator|&&
name|fs
operator|->
name|fs_sujfree
operator|!=
literal|0
operator|)
condition|)
block|{
name|bdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|WORKITEM_FREE
argument_list|(
name|sbdep
argument_list|,
name|D_SBDEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_sujfree
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Now that we have a record of this inode in stable store allow it 	 * to be written to free up pending work.  Inodes may see a lot of 	 * write activity after they are unlinked which we must not hold up. 	 */
for|for
control|(
init|;
name|inodedep
operator|!=
name|NULL
condition|;
name|inodedep
operator|=
name|TAILQ_NEXT
argument_list|(
name|inodedep
argument_list|,
name|id_unlinked
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|UNLINKLINKS
operator|)
operator|!=
name|UNLINKLINKS
condition|)
name|panic
argument_list|(
literal|"handle_written_sbdep: Bad inodedep %p (0x%X)"
argument_list|,
name|inodedep
argument_list|,
name|inodedep
operator|->
name|id_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep
operator|->
name|id_state
operator|&
name|UNLINKONLIST
condition|)
break|break;
name|inodedep
operator|->
name|id_state
operator||=
name|DEPCOMPLETE
operator||
name|UNLINKONLIST
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark an inodedep as unlinked and insert it into the in-memory unlinked list.  */
end_comment

begin_function
specifier|static
name|void
name|unlinked_inodedep
parameter_list|(
name|mp
parameter_list|,
name|inodedep
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|MOUNTEDSUJ
argument_list|(
name|mp
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|ump
operator|->
name|um_fs
operator|->
name|fs_fmod
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|inodedep
operator|->
name|id_state
operator|&
name|UNLINKED
condition|)
name|panic
argument_list|(
literal|"unlinked_inodedep: %p already unlinked\n"
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator||=
name|UNLINKED
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ump
operator|->
name|softdep_unlinked
argument_list|,
name|inodedep
argument_list|,
name|id_unlinked
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove an inodedep from the unlinked inodedep list.  This may require  * disk writes if the inode has made it that far.  */
end_comment

begin_function
specifier|static
name|void
name|clear_unlinked_inodedep
parameter_list|(
name|inodedep
parameter_list|)
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|idp
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|idn
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|ino_t
name|nino
decl_stmt|;
name|ino_t
name|pino
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|inodedep
operator|->
name|id_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
name|ino
operator|=
name|inodedep
operator|->
name|id_ino
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|UNLINKED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"clear_unlinked_inodedep: inodedep %p not unlinked"
operator|,
name|inodedep
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * If nothing has yet been written simply remove us from 		 * the in memory list and return.  This is the most common 		 * case where handle_workitem_remove() loses the final 		 * reference. 		 */
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|UNLINKLINKS
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * If we have a NEXT pointer and no PREV pointer we can simply 		 * clear NEXT's PREV and remove ourselves from the list.  Be 		 * careful not to clear PREV if the superblock points at 		 * next as well. 		 */
name|idn
operator|=
name|TAILQ_NEXT
argument_list|(
name|inodedep
argument_list|,
name|id_unlinked
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|UNLINKLINKS
operator|)
operator|==
name|UNLINKNEXT
condition|)
block|{
if|if
condition|(
name|idn
operator|&&
name|fs
operator|->
name|fs_sujfree
operator|!=
name|idn
operator|->
name|id_ino
condition|)
name|idn
operator|->
name|id_state
operator|&=
operator|~
name|UNLINKPREV
expr_stmt|;
break|break;
block|}
comment|/* 		 * Here we have an inodedep which is actually linked into 		 * the list.  We must remove it by forcing a write to the 		 * link before us, whether it be the superblock or an inode. 		 * Unfortunately the list may change while we're waiting 		 * on the buf lock for either resource so we must loop until 		 * we lock the right one.  If both the superblock and an 		 * inode point to this inode we must clear the inode first 		 * followed by the superblock. 		 */
name|idp
operator|=
name|TAILQ_PREV
argument_list|(
name|inodedep
argument_list|,
name|inodedeplst
argument_list|,
name|id_unlinked
argument_list|)
expr_stmt|;
name|pino
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|idp
operator|&&
operator|(
name|idp
operator|->
name|id_state
operator|&
name|UNLINKNEXT
operator|)
condition|)
name|pino
operator|=
name|idp
operator|->
name|id_ino
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|pino
operator|==
literal|0
condition|)
block|{
name|bp
operator|=
name|getblk
argument_list|(
name|ump
operator|->
name|um_devvp
argument_list|,
name|btodb
argument_list|(
name|fs
operator|->
name|fs_sblockloc
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_sbsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|bread
argument_list|(
name|ump
operator|->
name|um_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|pino
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* If the list has changed restart the loop. */
name|idp
operator|=
name|TAILQ_PREV
argument_list|(
name|inodedep
argument_list|,
name|inodedeplst
argument_list|,
name|id_unlinked
argument_list|)
expr_stmt|;
name|nino
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|idp
operator|&&
operator|(
name|idp
operator|->
name|id_state
operator|&
name|UNLINKNEXT
operator|)
condition|)
name|nino
operator|=
name|idp
operator|->
name|id_ino
expr_stmt|;
if|if
condition|(
name|nino
operator|!=
name|pino
operator|||
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|UNLINKPREV
operator|)
operator|!=
name|UNLINKPREV
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nino
operator|=
literal|0
expr_stmt|;
name|idn
operator|=
name|TAILQ_NEXT
argument_list|(
name|inodedep
argument_list|,
name|id_unlinked
argument_list|)
expr_stmt|;
if|if
condition|(
name|idn
condition|)
name|nino
operator|=
name|idn
operator|->
name|id_ino
expr_stmt|;
comment|/* 		 * Remove us from the in memory list.  After this we cannot 		 * access the inodedep. 		 */
name|KASSERT
argument_list|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|UNLINKED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"clear_unlinked_inodedep: inodedep %p not unlinked"
operator|,
name|inodedep
operator|)
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator|&=
operator|~
operator|(
name|UNLINKED
operator||
name|UNLINKLINKS
operator||
name|UNLINKONLIST
operator|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ump
operator|->
name|softdep_unlinked
argument_list|,
name|inodedep
argument_list|,
name|id_unlinked
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 		 * The predecessor's next pointer is manually updated here 		 * so that the NEXT flag is never cleared for an element 		 * that is in the list. 		 */
if|if
condition|(
name|pino
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|fs
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
operator|(
name|u_int
operator|)
name|fs
operator|->
name|fs_sbsize
argument_list|)
expr_stmt|;
name|ffs_oldfscompat_write
argument_list|(
operator|(
expr|struct
name|fs
operator|*
operator|)
name|bp
operator|->
name|b_data
argument_list|,
name|ump
argument_list|)
expr_stmt|;
name|softdep_setup_sbupdate
argument_list|(
name|ump
argument_list|,
operator|(
expr|struct
name|fs
operator|*
operator|)
name|bp
operator|->
name|b_data
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fs
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
operator|(
operator|(
expr|struct
name|ufs1_dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|pino
argument_list|)
operator|)
operator|->
name|di_freelink
operator|=
name|nino
expr_stmt|;
else|else
operator|(
operator|(
expr|struct
name|ufs2_dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|pino
argument_list|)
operator|)
operator|->
name|di_freelink
operator|=
name|nino
expr_stmt|;
comment|/* 		 * If the bwrite fails we have no recourse to recover.  The 		 * filesystem is corrupted already. 		 */
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 		 * If the superblock pointer still needs to be cleared force 		 * a write here. 		 */
if|if
condition|(
name|fs
operator|->
name|fs_sujfree
operator|==
name|ino
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|bp
operator|=
name|getblk
argument_list|(
name|ump
operator|->
name|um_devvp
argument_list|,
name|btodb
argument_list|(
name|fs
operator|->
name|fs_sblockloc
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_sbsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|fs
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
operator|(
name|u_int
operator|)
name|fs
operator|->
name|fs_sbsize
argument_list|)
expr_stmt|;
name|ffs_oldfscompat_write
argument_list|(
operator|(
expr|struct
name|fs
operator|*
operator|)
name|bp
operator|->
name|b_data
argument_list|,
name|ump
argument_list|)
expr_stmt|;
name|softdep_setup_sbupdate
argument_list|(
name|ump
argument_list|,
operator|(
expr|struct
name|fs
operator|*
operator|)
name|bp
operator|->
name|b_data
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|->
name|fs_sujfree
operator|!=
name|ino
condition|)
return|return;
name|panic
argument_list|(
literal|"clear_unlinked_inodedep: Failed to clear free head"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inodedep
operator|->
name|id_ino
operator|==
name|fs
operator|->
name|fs_sujfree
condition|)
name|panic
argument_list|(
literal|"clear_unlinked_inodedep: Freeing head of free list"
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator|&=
operator|~
operator|(
name|UNLINKED
operator||
name|UNLINKLINKS
operator||
name|UNLINKONLIST
operator|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ump
operator|->
name|softdep_unlinked
argument_list|,
name|inodedep
argument_list|,
name|id_unlinked
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This workitem decrements the inode's link count.  * If the link count reaches zero, the file is removed.  */
end_comment

begin_function
specifier|static
name|int
name|handle_workitem_remove
parameter_list|(
name|dirrem
parameter_list|,
name|flags
parameter_list|)
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|workhead
name|dotdotwk
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ino_t
name|oldinum
decl_stmt|;
if|if
condition|(
name|dirrem
operator|->
name|dm_state
operator|&
name|ONWORKLIST
condition|)
name|panic
argument_list|(
literal|"handle_workitem_remove: dirrem %p still on worklist"
argument_list|,
name|dirrem
argument_list|)
expr_stmt|;
name|oldinum
operator|=
name|dirrem
operator|->
name|dm_oldinum
expr_stmt|;
name|mp
operator|=
name|dirrem
operator|->
name|dm_list
operator|.
name|wk_mp
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LK_EXCLUSIVE
expr_stmt|;
if|if
condition|(
name|ffs_vgetf
argument_list|(
name|mp
argument_list|,
name|oldinum
argument_list|,
name|flags
argument_list|,
operator|&
name|vp
argument_list|,
name|FFSV_FORCEINSMQ
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|oldinum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"handle_workitem_remove: lost inodedep"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirrem
operator|->
name|dm_state
operator|&
name|ONDEPLIST
condition|)
name|LIST_REMOVE
argument_list|(
name|dirrem
argument_list|,
name|dm_inonext
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jremrefhd
argument_list|)
argument_list|,
operator|(
literal|"handle_workitem_remove:  Journal entries not written."
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Move all dependencies waiting on the remove to complete 	 * from the dirrem to the inode inowait list to be completed 	 * after the inode has been updated and written to disk.  Any 	 * marked MKDIR_PARENT are saved to be completed when the .. ref 	 * is removed. 	 */
name|LIST_INIT
argument_list|(
operator|&
name|dotdotwk
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jwork
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|wk
operator|->
name|wk_state
operator|&
name|MKDIR_PARENT
condition|)
block|{
name|wk
operator|->
name|wk_state
operator|&=
operator|~
name|MKDIR_PARENT
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|dotdotwk
argument_list|,
name|wk
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|,
name|wk
argument_list|)
expr_stmt|;
block|}
name|LIST_SWAP
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jwork
argument_list|,
operator|&
name|dotdotwk
argument_list|,
name|worklist
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
comment|/* 	 * Normal file deletion. 	 */
if|if
condition|(
operator|(
name|dirrem
operator|->
name|dm_state
operator|&
name|RMDIR
operator|)
operator|==
literal|0
condition|)
block|{
name|ip
operator|->
name|i_nlink
operator|--
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_nlink
argument_list|,
name|ip
operator|->
name|i_nlink
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_nlink
operator|<
name|ip
operator|->
name|i_effnlink
condition|)
name|panic
argument_list|(
literal|"handle_workitem_remove: bad file delta"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_nlink
operator|==
literal|0
condition|)
name|unlinked_inodedep
argument_list|(
name|mp
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_nlinkdelta
operator|=
name|ip
operator|->
name|i_nlink
operator|-
name|ip
operator|->
name|i_effnlink
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jwork
argument_list|)
argument_list|,
operator|(
literal|"handle_workitem_remove: worklist not empty. %s"
operator|,
name|TYPENAME
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jwork
argument_list|)
operator|->
name|wk_type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|dirrem
argument_list|,
name|D_DIRREM
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Directory deletion. Decrement reference count for both the 	 * just deleted parent directory entry and the reference for ".". 	 * Arrange to have the reference count on the parent decremented 	 * to account for the loss of "..". 	 */
name|ip
operator|->
name|i_nlink
operator|-=
literal|2
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_nlink
argument_list|,
name|ip
operator|->
name|i_nlink
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_nlink
operator|<
name|ip
operator|->
name|i_effnlink
condition|)
name|panic
argument_list|(
literal|"handle_workitem_remove: bad dir delta"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_nlink
operator|==
literal|0
condition|)
name|unlinked_inodedep
argument_list|(
name|mp
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_nlinkdelta
operator|=
name|ip
operator|->
name|i_nlink
operator|-
name|ip
operator|->
name|i_effnlink
expr_stmt|;
comment|/* 	 * Rename a directory to a new parent. Since, we are both deleting 	 * and creating a new directory entry, the link count on the new 	 * directory should not change. Thus we skip the followup dirrem. 	 */
if|if
condition|(
name|dirrem
operator|->
name|dm_state
operator|&
name|DIRCHG
condition|)
block|{
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jwork
argument_list|)
argument_list|,
operator|(
literal|"handle_workitem_remove: DIRCHG and worklist not empty."
operator|)
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|dirrem
argument_list|,
name|D_DIRREM
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dirrem
operator|->
name|dm_state
operator|=
name|ONDEPLIST
expr_stmt|;
name|dirrem
operator|->
name|dm_oldinum
operator|=
name|dirrem
operator|->
name|dm_dirinum
expr_stmt|;
comment|/* 	 * Place the dirrem on the parent's diremhd list. 	 */
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|dirrem
operator|->
name|dm_oldinum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"handle_workitem_remove: lost dir inodedep"
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|inodedep
operator|->
name|id_dirremhd
argument_list|,
name|dirrem
argument_list|,
name|dm_inonext
argument_list|)
expr_stmt|;
comment|/* 	 * If the allocated inode has never been written to disk, then 	 * the on-disk inode is zero'ed and we can remove the file 	 * immediately.  When journaling if the inode has been marked 	 * unlinked and not DEPCOMPLETE we know it can never be written. 	 */
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|oldinum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep
operator|==
name|NULL
operator|||
operator|(
name|inodedep
operator|->
name|id_state
operator|&
operator|(
name|DEPCOMPLETE
operator||
name|UNLINKED
operator|)
operator|)
operator|==
name|UNLINKED
operator|||
name|check_inode_unwritten
argument_list|(
name|inodedep
argument_list|)
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|handle_workitem_remove
argument_list|(
name|dirrem
argument_list|,
name|flags
argument_list|)
return|;
block|}
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|,
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
expr_stmt|;
name|out
label|:
name|ffs_update
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Inode de-allocation dependencies.  *   * When an inode's link count is reduced to zero, it can be de-allocated. We  * found it convenient to postpone de-allocation until after the inode is  * written to disk with its new link count (zero).  At this point, all of the  * on-disk inode's block pointers are nullified and, with careful dependency  * list ordering, all dependencies related to the inode will be satisfied and  * the corresponding dependency structures de-allocated.  So, if/when the  * inode is reused, there will be no mixing of old dependencies with new  * ones.  This artificial dependency is set up by the block de-allocation  * procedure above (softdep_setup_freeblocks) and completed by the  * following procedure.  */
end_comment

begin_function
specifier|static
name|void
name|handle_workitem_freefile
parameter_list|(
name|freefile
parameter_list|)
name|struct
name|freefile
modifier|*
name|freefile
decl_stmt|;
block|{
name|struct
name|workhead
name|wkhd
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|idp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|freefile
operator|->
name|fx_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|error
operator|=
name|inodedep_lookup
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|,
name|freefile
operator|->
name|fx_oldinum
argument_list|,
literal|0
argument_list|,
operator|&
name|idp
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"handle_workitem_freefile: inodedep %p survived"
argument_list|,
name|idp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UFS_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_pendinginodes
operator|-=
literal|1
expr_stmt|;
name|UFS_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|wkhd
argument_list|)
expr_stmt|;
name|LIST_SWAP
argument_list|(
operator|&
name|freefile
operator|->
name|fx_jwork
argument_list|,
operator|&
name|wkhd
argument_list|,
name|worklist
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ffs_freefile
argument_list|(
name|ump
argument_list|,
name|fs
argument_list|,
name|freefile
operator|->
name|fx_devvp
argument_list|,
name|freefile
operator|->
name|fx_oldinum
argument_list|,
name|freefile
operator|->
name|fx_mode
argument_list|,
operator|&
name|wkhd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|softdep_error
argument_list|(
literal|"handle_workitem_freefile"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|freefile
argument_list|,
name|D_FREEFILE
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Helper function which unlinks marker element from work list and returns  * the next element on the list.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|worklist
operator|*
name|markernext
argument_list|(
argument|struct worklist *marker
argument_list|)
block|{ 	struct
name|worklist
operator|*
name|next
block|;
name|next
operator|=
name|LIST_NEXT
argument_list|(
name|marker
argument_list|,
name|wk_list
argument_list|)
block|;
name|LIST_REMOVE
argument_list|(
name|marker
argument_list|,
name|wk_list
argument_list|)
block|;
return|return
name|next
return|;
block|}
end_expr_stmt

begin_comment
comment|/*  * Disk writes.  *   * The dependency structures constructed above are most actively used when file  * system blocks are written to disk.  No constraints are placed on when a  * block can be written, but unsatisfied update dependencies are made safe by  * modifying (or replacing) the source memory for the duration of the disk  * write.  When the disk write completes, the memory block is again brought  * up-to-date.  *  * In-core inode structure reclamation.  *   * Because there are a finite number of "in-core" inode structures, they are  * reused regularly.  By transferring all inode-related dependencies to the  * in-memory inode block and indexing them separately (via "inodedep"s), we  * can allow "in-core" inode structures to be reused at any time and avoid  * any increase in contention.  *  * Called just before entering the device driver to initiate a new disk I/O.  * The buffer must be locked, thus, no I/O completion operations can occur  * while we are manipulating its associated dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|softdep_disk_io_initiation
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* structure describing disk write to occur */
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|worklist
name|marker
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|jblkdep
modifier|*
name|jblkdep
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
comment|/* 	 * We only care about write operations. There should never 	 * be dependencies for reads. 	 */
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|!=
name|BIO_WRITE
condition|)
name|panic
argument_list|(
literal|"softdep_disk_io_initiation: not write"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vflags
operator|&
name|BV_BKGRDINPROG
condition|)
name|panic
argument_list|(
literal|"softdep_disk_io_initiation: Writing buffer with "
literal|"background write in progress: %p"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
name|marker
operator|.
name|wk_type
operator|=
name|D_LAST
operator|+
literal|1
expr_stmt|;
comment|/* Not a normal workitem */
name|PHOLD
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
comment|/* Don't swap out kernel stack */
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * Do any necessary pre-I/O processing. 	 */
for|for
control|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
init|;
name|wk
operator|!=
name|NULL
condition|;
name|wk
operator|=
name|markernext
argument_list|(
operator|&
name|marker
argument_list|)
control|)
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|wk
argument_list|,
operator|&
name|marker
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_PAGEDEP
case|:
name|initiate_write_filepage
argument_list|(
name|WK_PAGEDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_INODEDEP
case|:
name|inodedep
operator|=
name|WK_INODEDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep
operator|->
name|id_fs
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|initiate_write_inodeblock_ufs1
argument_list|(
name|inodedep
argument_list|,
name|bp
argument_list|)
expr_stmt|;
else|else
name|initiate_write_inodeblock_ufs2
argument_list|(
name|inodedep
argument_list|,
name|bp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_INDIRDEP
case|:
name|initiate_write_indirdep
argument_list|(
name|WK_INDIRDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_BMSAFEMAP
case|:
name|initiate_write_bmsafemap
argument_list|(
name|WK_BMSAFEMAP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_JSEG
case|:
name|WK_JSEG
argument_list|(
name|wk
argument_list|)
operator|->
name|js_buf
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
name|D_FREEBLKS
case|:
name|freeblks
operator|=
name|WK_FREEBLKS
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|jblkdep
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|)
expr_stmt|;
comment|/* 			 * We have to wait for the freeblks to be journaled 			 * before we can write an inodeblock with updated 			 * pointers.  Be careful to arrange the marker so 			 * we revisit the freeblks if it's not removed by 			 * the first jwait(). 			 */
if|if
condition|(
name|jblkdep
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
operator|&
name|marker
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_BEFORE
argument_list|(
name|wk
argument_list|,
operator|&
name|marker
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
name|jwait
argument_list|(
operator|&
name|jblkdep
operator|->
name|jb_list
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|D_ALLOCDIRECT
case|:
case|case
name|D_ALLOCINDIR
case|:
comment|/* 			 * We have to wait for the jnewblk to be journaled 			 * before we can write to a block if the contents 			 * may be confused with an earlier file's indirect 			 * at recovery time.  Handle the marker as described 			 * above. 			 */
name|newblk
operator|=
name|WK_NEWBLK
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|newblk
operator|->
name|nb_jnewblk
operator|!=
name|NULL
operator|&&
name|indirblk_lookup
argument_list|(
name|newblk
operator|->
name|nb_list
operator|.
name|wk_mp
argument_list|,
name|newblk
operator|->
name|nb_newblkno
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
operator|&
name|marker
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_BEFORE
argument_list|(
name|wk
argument_list|,
operator|&
name|marker
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
name|jwait
argument_list|(
operator|&
name|newblk
operator|->
name|nb_jnewblk
operator|->
name|jn_list
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|D_SBDEP
case|:
name|initiate_write_sbdep
argument_list|(
name|WK_SBDEP
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_MKDIR
case|:
case|case
name|D_FREEWORK
case|:
case|case
name|D_FREEDEP
case|:
case|case
name|D_JSEGDEP
case|:
continue|continue;
default|default:
name|panic
argument_list|(
literal|"handle_disk_io_initiation: Unexpected type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|PRELE
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
comment|/* Allow swapout of kernel stack */
block|}
end_function

begin_comment
comment|/*  * Called from within the procedure above to deal with unsatisfied  * allocation dependencies in a directory. The buffer must be locked,  * thus, no I/O completion operations can occur while we are  * manipulating its associated dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_write_filepage
parameter_list|(
name|pagedep
parameter_list|,
name|bp
parameter_list|)
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|jremref
modifier|*
name|jremref
decl_stmt|;
name|struct
name|jmvref
modifier|*
name|jmvref
decl_stmt|;
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|direct
modifier|*
name|ep
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pagedep
operator|->
name|pd_state
operator|&
name|IOSTARTED
condition|)
block|{
comment|/* 		 * This can only happen if there is a driver that does not 		 * understand chaining. Here biodone will reissue the call 		 * to strategy for the incomplete buffers. 		 */
name|printf
argument_list|(
literal|"initiate_write_filepage: already started\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pagedep
operator|->
name|pd_state
operator||=
name|IOSTARTED
expr_stmt|;
comment|/* 	 * Wait for all journal remove dependencies to hit the disk. 	 * We can not allow any potentially conflicting directory adds 	 * to be visible before removes and rollback is too difficult. 	 * The per-filesystem lock may be dropped and re-acquired, however  	 * we hold the buf locked so the dependency can not go away. 	 */
name|LIST_FOREACH
argument_list|(
argument|dirrem
argument_list|,
argument|&pagedep->pd_dirremhd
argument_list|,
argument|dm_next
argument_list|)
while|while
condition|(
operator|(
name|jremref
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jremrefhd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|jwait
argument_list|(
operator|&
name|jremref
operator|->
name|jr_list
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|jmvref
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_jmvrefhd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|jwait
argument_list|(
operator|&
name|jmvref
operator|->
name|jm_list
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DAHASHSZ
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|dap
argument_list|,
argument|&pagedep->pd_diraddhd[i]
argument_list|,
argument|da_pdlist
argument_list|)
block|{
name|ep
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|dap
operator|->
name|da_offset
operator|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|d_ino
operator|!=
name|dap
operator|->
name|da_newinum
condition|)
name|panic
argument_list|(
literal|"%s: dir inum %ju != new %ju"
argument_list|,
literal|"initiate_write_filepage"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ep
operator|->
name|d_ino
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dap
operator|->
name|da_newinum
argument_list|)
expr_stmt|;
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|DIRCHG
condition|)
name|ep
operator|->
name|d_ino
operator|=
name|dap
operator|->
name|da_previous
operator|->
name|dm_oldinum
expr_stmt|;
else|else
name|ep
operator|->
name|d_ino
operator|=
literal|0
expr_stmt|;
name|dap
operator|->
name|da_state
operator|&=
operator|~
name|ATTACHED
expr_stmt|;
name|dap
operator|->
name|da_state
operator||=
name|UNDONE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Version of initiate_write_inodeblock that handles UFS1 dinodes.  * Note that any bug fixes made to this routine must be done in the  * version found below.  *  * Called from within the procedure above to deal with unsatisfied  * allocation dependencies in an inodeblock. The buffer must be  * locked, thus, no I/O completion operations can occur while we  * are manipulating its associated dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_write_inodeblock_ufs1
parameter_list|(
name|inodedep
parameter_list|,
name|bp
parameter_list|)
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* The inode block */
block|{
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|,
modifier|*
name|lastadp
decl_stmt|;
name|struct
name|ufs1_dinode
modifier|*
name|dp
decl_stmt|;
name|struct
name|ufs1_dinode
modifier|*
name|sip
decl_stmt|;
name|struct
name|inoref
modifier|*
name|inoref
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ufs_lbn_t
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|ufs_lbn_t
name|prevlbn
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|int
name|deplist
decl_stmt|;
if|if
condition|(
name|inodedep
operator|->
name|id_state
operator|&
name|IOSTARTED
condition|)
name|panic
argument_list|(
literal|"initiate_write_inodeblock_ufs1: already started"
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator||=
name|IOSTARTED
expr_stmt|;
name|fs
operator|=
name|inodedep
operator|->
name|id_fs
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|inodedep
operator|->
name|id_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|ufs1_dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|inodedep
operator|->
name|id_ino
argument_list|)
expr_stmt|;
comment|/* 	 * If we're on the unlinked list but have not yet written our 	 * next pointer initialize it here. 	 */
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
operator|(
name|UNLINKED
operator||
name|UNLINKNEXT
operator|)
operator|)
operator|==
name|UNLINKED
condition|)
block|{
name|struct
name|inodedep
modifier|*
name|inon
decl_stmt|;
name|inon
operator|=
name|TAILQ_NEXT
argument_list|(
name|inodedep
argument_list|,
name|id_unlinked
argument_list|)
expr_stmt|;
name|dp
operator|->
name|di_freelink
operator|=
name|inon
condition|?
name|inon
operator|->
name|id_ino
else|:
literal|0
expr_stmt|;
block|}
comment|/* 	 * If the bitmap is not yet written, then the allocated 	 * inode cannot be written to disk. 	 */
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|DEPCOMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|inodedep
operator|->
name|id_savedino1
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"initiate_write_inodeblock_ufs1: I/O underway"
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|sip
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ufs1_dinode
argument_list|)
argument_list|,
name|M_SAVEDINO
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_savedino1
operator|=
name|sip
expr_stmt|;
operator|*
name|inodedep
operator|->
name|id_savedino1
operator|=
operator|*
name|dp
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ufs1_dinode
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|di_gen
operator|=
name|inodedep
operator|->
name|id_savedino1
operator|->
name|di_gen
expr_stmt|;
name|dp
operator|->
name|di_freelink
operator|=
name|inodedep
operator|->
name|id_savedino1
operator|->
name|di_freelink
expr_stmt|;
return|return;
block|}
comment|/* 	 * If no dependencies, then there is nothing to roll back. 	 */
name|inodedep
operator|->
name|id_savedsize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
name|inodedep
operator|->
name|id_savedextsize
operator|=
literal|0
expr_stmt|;
name|inodedep
operator|->
name|id_savednlink
operator|=
name|dp
operator|->
name|di_nlink
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|)
condition|)
return|return;
comment|/* 	 * Revert the link count to that of the first unwritten journal entry. 	 */
name|inoref
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|)
expr_stmt|;
if|if
condition|(
name|inoref
condition|)
name|dp
operator|->
name|di_nlink
operator|=
name|inoref
operator|->
name|if_nlink
expr_stmt|;
comment|/* 	 * Set the dependencies to busy. 	 */
for|for
control|(
name|deplist
operator|=
literal|0
operator|,
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
init|;
name|adp
condition|;
name|adp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|deplist
operator|!=
literal|0
operator|&&
name|prevlbn
operator|>=
name|adp
operator|->
name|ad_offset
condition|)
name|panic
argument_list|(
literal|"softdep_write_inodeblock: lbn order"
argument_list|)
expr_stmt|;
name|prevlbn
operator|=
name|adp
operator|->
name|ad_offset
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|ad_offset
operator|<
name|UFS_NDADDR
operator|&&
name|dp
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_offset
index|]
operator|!=
name|adp
operator|->
name|ad_newblkno
condition|)
name|panic
argument_list|(
literal|"%s: direct pointer #%jd mismatch %d != %jd"
argument_list|,
literal|"softdep_write_inodeblock"
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_offset
argument_list|,
name|dp
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_offset
index|]
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_newblkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|ad_offset
operator|>=
name|UFS_NDADDR
operator|&&
name|dp
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
index|]
operator|!=
name|adp
operator|->
name|ad_newblkno
condition|)
name|panic
argument_list|(
literal|"%s: indirect pointer #%jd mismatch %d != %jd"
argument_list|,
literal|"softdep_write_inodeblock"
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
argument_list|,
name|dp
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
index|]
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_newblkno
argument_list|)
expr_stmt|;
name|deplist
operator||=
literal|1
operator|<<
name|adp
operator|->
name|ad_offset
expr_stmt|;
if|if
condition|(
operator|(
name|adp
operator|->
name|ad_state
operator|&
name|ATTACHED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_write_inodeblock: Unknown state 0x%x"
argument_list|,
name|adp
operator|->
name|ad_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INVARIANTS */
name|adp
operator|->
name|ad_state
operator|&=
operator|~
name|ATTACHED
expr_stmt|;
name|adp
operator|->
name|ad_state
operator||=
name|UNDONE
expr_stmt|;
block|}
comment|/* 	 * The on-disk inode cannot claim to be any larger than the last 	 * fragment that has been written. Otherwise, the on-disk inode 	 * might have fragments that were not the last block in the file 	 * which would corrupt the filesystem. 	 */
for|for
control|(
name|lastadp
operator|=
name|NULL
operator|,
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
init|;
name|adp
condition|;
name|lastadp
operator|=
name|adp
operator|,
name|adp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
control|)
block|{
if|if
condition|(
name|adp
operator|->
name|ad_offset
operator|>=
name|UFS_NDADDR
condition|)
break|break;
name|dp
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_offset
index|]
operator|=
name|adp
operator|->
name|ad_oldblkno
expr_stmt|;
comment|/* keep going until hitting a rollback to a frag */
if|if
condition|(
name|adp
operator|->
name|ad_oldsize
operator|==
literal|0
operator|||
name|adp
operator|->
name|ad_oldsize
operator|==
name|fs
operator|->
name|fs_bsize
condition|)
continue|continue;
name|dp
operator|->
name|di_size
operator|=
name|fs
operator|->
name|fs_bsize
operator|*
name|adp
operator|->
name|ad_offset
operator|+
name|adp
operator|->
name|ad_oldsize
expr_stmt|;
for|for
control|(
name|i
operator|=
name|adp
operator|->
name|ad_offset
operator|+
literal|1
init|;
name|i
operator|<
name|UFS_NDADDR
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|dp
operator|->
name|di_db
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|(
name|deplist
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_write_inodeblock: lost dep1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INVARIANTS */
name|dp
operator|->
name|di_db
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UFS_NIADDR
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|dp
operator|->
name|di_ib
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|(
name|deplist
operator|&
operator|(
operator|(
literal|1
operator|<<
name|UFS_NDADDR
operator|)
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_write_inodeblock: lost dep2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INVARIANTS */
name|dp
operator|->
name|di_ib
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * If we have zero'ed out the last allocated block of the file, 	 * roll back the size to the last currently allocated block. 	 * We know that this last allocated block is a full-sized as 	 * we already checked for fragments in the loop above. 	 */
if|if
condition|(
name|lastadp
operator|!=
name|NULL
operator|&&
name|dp
operator|->
name|di_size
operator|<=
operator|(
name|lastadp
operator|->
name|ad_offset
operator|+
literal|1
operator|)
operator|*
name|fs
operator|->
name|fs_bsize
condition|)
block|{
for|for
control|(
name|i
operator|=
name|lastadp
operator|->
name|ad_offset
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|dp
operator|->
name|di_db
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
name|dp
operator|->
name|di_size
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|fs
operator|->
name|fs_bsize
expr_stmt|;
block|}
comment|/* 	 * The only dependencies are for indirect blocks. 	 * 	 * The file size for indirect block additions is not guaranteed. 	 * Such a guarantee would be non-trivial to achieve. The conventional 	 * synchronous write implementation also does not make this guarantee. 	 * Fsck should catch and fix discrepancies. Arguably, the file size 	 * can be over-estimated without destroying integrity when the file 	 * moves into the indirect blocks (i.e., is large). If we want to 	 * postpone fsck, we are stuck with this argument. 	 */
for|for
control|(
init|;
name|adp
condition|;
name|adp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
control|)
name|dp
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Version of initiate_write_inodeblock that handles UFS2 dinodes.  * Note that any bug fixes made to this routine must be done in the  * version found above.  *  * Called from within the procedure above to deal with unsatisfied  * allocation dependencies in an inodeblock. The buffer must be  * locked, thus, no I/O completion operations can occur while we  * are manipulating its associated dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_write_inodeblock_ufs2
parameter_list|(
name|inodedep
parameter_list|,
name|bp
parameter_list|)
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* The inode block */
block|{
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|,
modifier|*
name|lastadp
decl_stmt|;
name|struct
name|ufs2_dinode
modifier|*
name|dp
decl_stmt|;
name|struct
name|ufs2_dinode
modifier|*
name|sip
decl_stmt|;
name|struct
name|inoref
modifier|*
name|inoref
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ufs_lbn_t
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|ufs_lbn_t
name|prevlbn
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|int
name|deplist
decl_stmt|;
if|if
condition|(
name|inodedep
operator|->
name|id_state
operator|&
name|IOSTARTED
condition|)
name|panic
argument_list|(
literal|"initiate_write_inodeblock_ufs2: already started"
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator||=
name|IOSTARTED
expr_stmt|;
name|fs
operator|=
name|inodedep
operator|->
name|id_fs
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|inodedep
operator|->
name|id_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|ufs2_dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|inodedep
operator|->
name|id_ino
argument_list|)
expr_stmt|;
comment|/* 	 * If we're on the unlinked list but have not yet written our 	 * next pointer initialize it here. 	 */
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
operator|(
name|UNLINKED
operator||
name|UNLINKNEXT
operator|)
operator|)
operator|==
name|UNLINKED
condition|)
block|{
name|struct
name|inodedep
modifier|*
name|inon
decl_stmt|;
name|inon
operator|=
name|TAILQ_NEXT
argument_list|(
name|inodedep
argument_list|,
name|id_unlinked
argument_list|)
expr_stmt|;
name|dp
operator|->
name|di_freelink
operator|=
name|inon
condition|?
name|inon
operator|->
name|id_ino
else|:
literal|0
expr_stmt|;
block|}
comment|/* 	 * If the bitmap is not yet written, then the allocated 	 * inode cannot be written to disk. 	 */
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|DEPCOMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|inodedep
operator|->
name|id_savedino2
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"initiate_write_inodeblock_ufs2: I/O underway"
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|sip
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ufs2_dinode
argument_list|)
argument_list|,
name|M_SAVEDINO
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_savedino2
operator|=
name|sip
expr_stmt|;
operator|*
name|inodedep
operator|->
name|id_savedino2
operator|=
operator|*
name|dp
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ufs2_dinode
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|di_gen
operator|=
name|inodedep
operator|->
name|id_savedino2
operator|->
name|di_gen
expr_stmt|;
name|dp
operator|->
name|di_freelink
operator|=
name|inodedep
operator|->
name|id_savedino2
operator|->
name|di_freelink
expr_stmt|;
return|return;
block|}
comment|/* 	 * If no dependencies, then there is nothing to roll back. 	 */
name|inodedep
operator|->
name|id_savedsize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
name|inodedep
operator|->
name|id_savedextsize
operator|=
name|dp
operator|->
name|di_extsize
expr_stmt|;
name|inodedep
operator|->
name|id_savednlink
operator|=
name|dp
operator|->
name|di_nlink
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|)
condition|)
return|return;
comment|/* 	 * Revert the link count to that of the first unwritten journal entry. 	 */
name|inoref
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|)
expr_stmt|;
if|if
condition|(
name|inoref
condition|)
name|dp
operator|->
name|di_nlink
operator|=
name|inoref
operator|->
name|if_nlink
expr_stmt|;
comment|/* 	 * Set the ext data dependencies to busy. 	 */
for|for
control|(
name|deplist
operator|=
literal|0
operator|,
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
init|;
name|adp
condition|;
name|adp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|deplist
operator|!=
literal|0
operator|&&
name|prevlbn
operator|>=
name|adp
operator|->
name|ad_offset
condition|)
name|panic
argument_list|(
literal|"softdep_write_inodeblock: lbn order"
argument_list|)
expr_stmt|;
name|prevlbn
operator|=
name|adp
operator|->
name|ad_offset
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|di_extb
index|[
name|adp
operator|->
name|ad_offset
index|]
operator|!=
name|adp
operator|->
name|ad_newblkno
condition|)
name|panic
argument_list|(
literal|"%s: direct pointer #%jd mismatch %jd != %jd"
argument_list|,
literal|"softdep_write_inodeblock"
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_offset
argument_list|,
operator|(
name|intmax_t
operator|)
name|dp
operator|->
name|di_extb
index|[
name|adp
operator|->
name|ad_offset
index|]
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_newblkno
argument_list|)
expr_stmt|;
name|deplist
operator||=
literal|1
operator|<<
name|adp
operator|->
name|ad_offset
expr_stmt|;
if|if
condition|(
operator|(
name|adp
operator|->
name|ad_state
operator|&
name|ATTACHED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_write_inodeblock: Unknown state 0x%x"
argument_list|,
name|adp
operator|->
name|ad_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INVARIANTS */
name|adp
operator|->
name|ad_state
operator|&=
operator|~
name|ATTACHED
expr_stmt|;
name|adp
operator|->
name|ad_state
operator||=
name|UNDONE
expr_stmt|;
block|}
comment|/* 	 * The on-disk inode cannot claim to be any larger than the last 	 * fragment that has been written. Otherwise, the on-disk inode 	 * might have fragments that were not the last block in the ext 	 * data which would corrupt the filesystem. 	 */
for|for
control|(
name|lastadp
operator|=
name|NULL
operator|,
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
init|;
name|adp
condition|;
name|lastadp
operator|=
name|adp
operator|,
name|adp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
control|)
block|{
name|dp
operator|->
name|di_extb
index|[
name|adp
operator|->
name|ad_offset
index|]
operator|=
name|adp
operator|->
name|ad_oldblkno
expr_stmt|;
comment|/* keep going until hitting a rollback to a frag */
if|if
condition|(
name|adp
operator|->
name|ad_oldsize
operator|==
literal|0
operator|||
name|adp
operator|->
name|ad_oldsize
operator|==
name|fs
operator|->
name|fs_bsize
condition|)
continue|continue;
name|dp
operator|->
name|di_extsize
operator|=
name|fs
operator|->
name|fs_bsize
operator|*
name|adp
operator|->
name|ad_offset
operator|+
name|adp
operator|->
name|ad_oldsize
expr_stmt|;
for|for
control|(
name|i
operator|=
name|adp
operator|->
name|ad_offset
operator|+
literal|1
init|;
name|i
operator|<
name|UFS_NXADDR
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|dp
operator|->
name|di_extb
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|(
name|deplist
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_write_inodeblock: lost dep1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INVARIANTS */
name|dp
operator|->
name|di_extb
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|lastadp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* 	 * If we have zero'ed out the last allocated block of the ext 	 * data, roll back the size to the last currently allocated block. 	 * We know that this last allocated block is a full-sized as 	 * we already checked for fragments in the loop above. 	 */
if|if
condition|(
name|lastadp
operator|!=
name|NULL
operator|&&
name|dp
operator|->
name|di_extsize
operator|<=
operator|(
name|lastadp
operator|->
name|ad_offset
operator|+
literal|1
operator|)
operator|*
name|fs
operator|->
name|fs_bsize
condition|)
block|{
for|for
control|(
name|i
operator|=
name|lastadp
operator|->
name|ad_offset
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|dp
operator|->
name|di_extb
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
name|dp
operator|->
name|di_extsize
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|fs
operator|->
name|fs_bsize
expr_stmt|;
block|}
comment|/* 	 * Set the file data dependencies to busy. 	 */
for|for
control|(
name|deplist
operator|=
literal|0
operator|,
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
init|;
name|adp
condition|;
name|adp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|deplist
operator|!=
literal|0
operator|&&
name|prevlbn
operator|>=
name|adp
operator|->
name|ad_offset
condition|)
name|panic
argument_list|(
literal|"softdep_write_inodeblock: lbn order"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adp
operator|->
name|ad_state
operator|&
name|ATTACHED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"inodedep %p and adp %p not attached"
argument_list|,
name|inodedep
argument_list|,
name|adp
argument_list|)
expr_stmt|;
name|prevlbn
operator|=
name|adp
operator|->
name|ad_offset
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|ad_offset
operator|<
name|UFS_NDADDR
operator|&&
name|dp
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_offset
index|]
operator|!=
name|adp
operator|->
name|ad_newblkno
condition|)
name|panic
argument_list|(
literal|"%s: direct pointer #%jd mismatch %jd != %jd"
argument_list|,
literal|"softdep_write_inodeblock"
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_offset
argument_list|,
operator|(
name|intmax_t
operator|)
name|dp
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_offset
index|]
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_newblkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|ad_offset
operator|>=
name|UFS_NDADDR
operator|&&
name|dp
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
index|]
operator|!=
name|adp
operator|->
name|ad_newblkno
condition|)
name|panic
argument_list|(
literal|"%s indirect pointer #%jd mismatch %jd != %jd"
argument_list|,
literal|"softdep_write_inodeblock:"
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
argument_list|,
operator|(
name|intmax_t
operator|)
name|dp
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
index|]
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_newblkno
argument_list|)
expr_stmt|;
name|deplist
operator||=
literal|1
operator|<<
name|adp
operator|->
name|ad_offset
expr_stmt|;
if|if
condition|(
operator|(
name|adp
operator|->
name|ad_state
operator|&
name|ATTACHED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_write_inodeblock: Unknown state 0x%x"
argument_list|,
name|adp
operator|->
name|ad_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INVARIANTS */
name|adp
operator|->
name|ad_state
operator|&=
operator|~
name|ATTACHED
expr_stmt|;
name|adp
operator|->
name|ad_state
operator||=
name|UNDONE
expr_stmt|;
block|}
comment|/* 	 * The on-disk inode cannot claim to be any larger than the last 	 * fragment that has been written. Otherwise, the on-disk inode 	 * might have fragments that were not the last block in the file 	 * which would corrupt the filesystem. 	 */
for|for
control|(
name|lastadp
operator|=
name|NULL
operator|,
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
init|;
name|adp
condition|;
name|lastadp
operator|=
name|adp
operator|,
name|adp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
control|)
block|{
if|if
condition|(
name|adp
operator|->
name|ad_offset
operator|>=
name|UFS_NDADDR
condition|)
break|break;
name|dp
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_offset
index|]
operator|=
name|adp
operator|->
name|ad_oldblkno
expr_stmt|;
comment|/* keep going until hitting a rollback to a frag */
if|if
condition|(
name|adp
operator|->
name|ad_oldsize
operator|==
literal|0
operator|||
name|adp
operator|->
name|ad_oldsize
operator|==
name|fs
operator|->
name|fs_bsize
condition|)
continue|continue;
name|dp
operator|->
name|di_size
operator|=
name|fs
operator|->
name|fs_bsize
operator|*
name|adp
operator|->
name|ad_offset
operator|+
name|adp
operator|->
name|ad_oldsize
expr_stmt|;
for|for
control|(
name|i
operator|=
name|adp
operator|->
name|ad_offset
operator|+
literal|1
init|;
name|i
operator|<
name|UFS_NDADDR
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|dp
operator|->
name|di_db
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|(
name|deplist
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_write_inodeblock: lost dep2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INVARIANTS */
name|dp
operator|->
name|di_db
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UFS_NIADDR
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|dp
operator|->
name|di_ib
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|(
name|deplist
operator|&
operator|(
operator|(
literal|1
operator|<<
name|UFS_NDADDR
operator|)
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_write_inodeblock: lost dep3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INVARIANTS */
name|dp
operator|->
name|di_ib
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * If we have zero'ed out the last allocated block of the file, 	 * roll back the size to the last currently allocated block. 	 * We know that this last allocated block is a full-sized as 	 * we already checked for fragments in the loop above. 	 */
if|if
condition|(
name|lastadp
operator|!=
name|NULL
operator|&&
name|dp
operator|->
name|di_size
operator|<=
operator|(
name|lastadp
operator|->
name|ad_offset
operator|+
literal|1
operator|)
operator|*
name|fs
operator|->
name|fs_bsize
condition|)
block|{
for|for
control|(
name|i
operator|=
name|lastadp
operator|->
name|ad_offset
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|dp
operator|->
name|di_db
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
name|dp
operator|->
name|di_size
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|fs
operator|->
name|fs_bsize
expr_stmt|;
block|}
comment|/* 	 * The only dependencies are for indirect blocks. 	 * 	 * The file size for indirect block additions is not guaranteed. 	 * Such a guarantee would be non-trivial to achieve. The conventional 	 * synchronous write implementation also does not make this guarantee. 	 * Fsck should catch and fix discrepancies. Arguably, the file size 	 * can be over-estimated without destroying integrity when the file 	 * moves into the indirect blocks (i.e., is large). If we want to 	 * postpone fsck, we are stuck with this argument. 	 */
for|for
control|(
init|;
name|adp
condition|;
name|adp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
control|)
name|dp
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cancel an indirdep as a result of truncation.  Release all of the  * children allocindirs and place their journal work on the appropriate  * list.  */
end_comment

begin_function
specifier|static
name|void
name|cancel_indirdep
parameter_list|(
name|indirdep
parameter_list|,
name|bp
parameter_list|,
name|freeblks
parameter_list|)
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
block|{
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
comment|/* 	 * None of the indirect pointers will ever be visible, 	 * so they can simply be tossed. GOINGAWAY ensures 	 * that allocated pointers will be saved in the buffer 	 * cache until they are freed. Note that they will 	 * only be able to be found by their physical address 	 * since the inode mapping the logical address will 	 * be gone. The save buffer used for the safe copy 	 * was allocated in setup_allocindir_phase2 using 	 * the physical address so it could be used for this 	 * purpose. Hence we swap the safe copy with the real 	 * copy, allowing the safe copy to be freed and holding 	 * on to the real copy for later use in indir_trunc. 	 */
if|if
condition|(
name|indirdep
operator|->
name|ir_state
operator|&
name|GOINGAWAY
condition|)
name|panic
argument_list|(
literal|"cancel_indirdep: already gone"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|indirdep
operator|->
name|ir_state
operator|&
name|DEPCOMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|indirdep
operator|->
name|ir_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|indirdep
argument_list|,
name|ir_next
argument_list|)
expr_stmt|;
block|}
name|indirdep
operator|->
name|ir_state
operator||=
name|GOINGAWAY
expr_stmt|;
comment|/* 	 * Pass in bp for blocks still have journal writes 	 * pending so we can cancel them on their own. 	 */
while|while
condition|(
operator|(
name|aip
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_deplisthd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cancel_allocindir
argument_list|(
name|aip
argument_list|,
name|bp
argument_list|,
name|freeblks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|aip
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_donehd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cancel_allocindir
argument_list|(
name|aip
argument_list|,
name|NULL
argument_list|,
name|freeblks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|aip
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_writehd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cancel_allocindir
argument_list|(
name|aip
argument_list|,
name|NULL
argument_list|,
name|freeblks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|aip
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_completehd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cancel_allocindir
argument_list|(
name|aip
argument_list|,
name|NULL
argument_list|,
name|freeblks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If there are pending partial truncations we need to keep the 	 * old block copy around until they complete.  This is because 	 * the current b_data is not a perfect superset of the available 	 * blocks. 	 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|)
condition|)
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|indirdep
operator|->
name|ir_saveddata
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_list
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_dep
argument_list|,
operator|&
name|indirdep
operator|->
name|ir_list
argument_list|)
expr_stmt|;
name|indirdep
operator|->
name|ir_bp
operator|=
name|NULL
expr_stmt|;
name|indirdep
operator|->
name|ir_freeblks
operator|=
name|freeblks
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free an indirdep once it no longer has new pointers to track.  */
end_comment

begin_function
specifier|static
name|void
name|free_indirdep
parameter_list|(
name|indirdep
parameter_list|)
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
block|{
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|)
argument_list|,
operator|(
literal|"free_indirdep: Indir trunc list not empty."
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_completehd
argument_list|)
argument_list|,
operator|(
literal|"free_indirdep: Complete head not empty."
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_writehd
argument_list|)
argument_list|,
operator|(
literal|"free_indirdep: write head not empty."
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_donehd
argument_list|)
argument_list|,
operator|(
literal|"free_indirdep: done head not empty."
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_deplisthd
argument_list|)
argument_list|,
operator|(
literal|"free_indirdep: deplist head not empty."
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|indirdep
operator|->
name|ir_state
operator|&
name|DEPCOMPLETE
operator|)
argument_list|,
operator|(
literal|"free_indirdep: %p still on newblk list."
operator|,
name|indirdep
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|indirdep
operator|->
name|ir_saveddata
operator|==
name|NULL
argument_list|,
operator|(
literal|"free_indirdep: %p still has saved data."
operator|,
name|indirdep
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirdep
operator|->
name|ir_state
operator|&
name|ONWORKLIST
condition|)
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_list
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|indirdep
argument_list|,
name|D_INDIRDEP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called before a write to an indirdep.  This routine is responsible for  * rolling back pointers to a safe state which includes only those  * allocindirs which have been completed.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_write_indirdep
parameter_list|(
name|indirdep
parameter_list|,
name|bp
parameter_list|)
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|indirdep
operator|->
name|ir_state
operator||=
name|IOSTARTED
expr_stmt|;
if|if
condition|(
name|indirdep
operator|->
name|ir_state
operator|&
name|GOINGAWAY
condition|)
name|panic
argument_list|(
literal|"disk_io_initiation: indirdep gone"
argument_list|)
expr_stmt|;
comment|/* 	 * If there are no remaining dependencies, this will be writing 	 * the real pointers. 	 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_deplisthd
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|)
condition|)
return|return;
comment|/* 	 * Replace up-to-date version with safe version. 	 */
if|if
condition|(
name|indirdep
operator|->
name|ir_saveddata
operator|==
name|NULL
condition|)
block|{
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|indirdep
operator|->
name|ir_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|indirdep
operator|->
name|ir_saveddata
operator|=
name|malloc
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|,
name|M_INDIRDEP
argument_list|,
name|M_SOFTDEP_FLAGS
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
name|indirdep
operator|->
name|ir_state
operator|&=
operator|~
name|ATTACHED
expr_stmt|;
name|indirdep
operator|->
name|ir_state
operator||=
name|UNDONE
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|indirdep
operator|->
name|ir_saveddata
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when an inode has been cleared in a cg bitmap.  This finally  * eliminates any canceled jaddrefs  */
end_comment

begin_function
name|void
name|softdep_setup_inofree
parameter_list|(
name|mp
parameter_list|,
name|bp
parameter_list|,
name|ino
parameter_list|,
name|wkhd
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|,
modifier|*
name|wkn
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|uint8_t
modifier|*
name|inosused
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_inofree called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
name|cgp
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|inosused
operator|=
name|cg_inosused
argument_list|(
name|cgp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|inosused
argument_list|,
name|ino
operator|%
name|fs
operator|->
name|fs_ipg
argument_list|)
condition|)
name|panic
argument_list|(
literal|"softdep_setup_inofree: inode %ju not freed."
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
condition|)
name|panic
argument_list|(
literal|"softdep_setup_inofree: ino %ju has existing inodedep %p"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ino
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
name|wkhd
condition|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|wk
argument_list|,
argument|wkhd
argument_list|,
argument|wk_list
argument_list|,
argument|wkn
argument_list|)
block|{
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|!=
name|D_JADDREF
condition|)
continue|continue;
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
comment|/* 			 * We can free immediately even if the jaddref 			 * isn't attached in a background write as now 			 * the bitmaps are reconciled. 			 */
name|wk
operator|->
name|wk_state
operator||=
name|COMPLETE
operator||
name|ATTACHED
expr_stmt|;
name|free_jaddref
argument_list|(
name|WK_JADDREF
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|jwork_move
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
name|wkhd
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called via ffs_blkfree() after a set of frags has been cleared from a cg  * map.  Any dependencies waiting for the write to clear are added to the  * buf's list and any jnewblks that are being canceled are discarded  * immediately.  */
end_comment

begin_function
name|void
name|softdep_setup_blkfree
parameter_list|(
name|mp
parameter_list|,
name|bp
parameter_list|,
name|blkno
parameter_list|,
name|frags
parameter_list|,
name|wkhd
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
name|int
name|frags
decl_stmt|;
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
ifdef|#
directive|ifdef
name|SUJ_DEBUG
name|uint8_t
modifier|*
name|blksfree
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|ufs2_daddr_t
name|jstart
decl_stmt|;
name|ufs2_daddr_t
name|jend
decl_stmt|;
name|ufs2_daddr_t
name|end
decl_stmt|;
name|long
name|bno
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|CTR3
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"softdep_setup_blkfree: blkno %jd frags %d wk head %p"
argument_list|,
name|blkno
argument_list|,
name|frags
argument_list|,
name|wkhd
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_setup_blkfree called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* Lookup the bmsafemap so we track when it is dirty. */
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
name|bmsafemap
operator|=
name|bmsafemap_lookup
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|,
name|dtog
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Detach any jnewblks which have been canceled.  They must linger 	 * until the bitmap is cleared again by ffs_blkfree() to prevent 	 * an unjournaled allocation from hitting the disk. 	 */
if|if
condition|(
name|wkhd
condition|)
block|{
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
name|wkhd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_SUJ
argument_list|,
literal|"softdep_setup_blkfree: blkno %jd wk type %d"
argument_list|,
name|blkno
argument_list|,
name|wk
operator|->
name|wk_type
argument_list|)
expr_stmt|;
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|!=
name|D_JNEWBLK
condition|)
block|{
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_freehd
argument_list|,
name|wk
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|jnewblk
operator|=
name|WK_JNEWBLK
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|jnewblk
operator|->
name|jn_state
operator|&
name|GOINGAWAY
argument_list|,
operator|(
literal|"softdep_setup_blkfree: jnewblk not canceled."
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUJ_DEBUG
comment|/* 			 * Assert that this block is free in the bitmap 			 * before we discard the jnewblk. 			 */
name|cgp
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|blksfree
operator|=
name|cg_blksfree
argument_list|(
name|cgp
argument_list|)
expr_stmt|;
name|bno
operator|=
name|dtogd
argument_list|(
name|fs
argument_list|,
name|jnewblk
operator|->
name|jn_blkno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|jnewblk
operator|->
name|jn_oldfrags
init|;
name|i
operator|<
name|jnewblk
operator|->
name|jn_frags
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isset
argument_list|(
name|blksfree
argument_list|,
name|bno
operator|+
name|i
argument_list|)
condition|)
continue|continue;
name|panic
argument_list|(
literal|"softdep_setup_blkfree: not free"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 			 * Even if it's not attached we can free immediately 			 * as the new bitmap is correct. 			 */
name|wk
operator|->
name|wk_state
operator||=
name|COMPLETE
operator||
name|ATTACHED
expr_stmt|;
name|free_jnewblk
argument_list|(
name|jnewblk
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SUJ_DEBUG
comment|/* 	 * Assert that we are not freeing a block which has an outstanding 	 * allocation dependency. 	 */
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_fs
expr_stmt|;
name|bmsafemap
operator|=
name|bmsafemap_lookup
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|,
name|dtog
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|end
operator|=
name|blkno
operator|+
name|frags
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|jnewblk
argument_list|,
argument|&bmsafemap->sm_jnewblkhd
argument_list|,
argument|jn_deps
argument_list|)
block|{
comment|/* 		 * Don't match against blocks that will be freed when the 		 * background write is done. 		 */
if|if
condition|(
operator|(
name|jnewblk
operator|->
name|jn_state
operator|&
operator|(
name|ATTACHED
operator||
name|COMPLETE
operator||
name|DEPCOMPLETE
operator|)
operator|)
operator|==
operator|(
name|COMPLETE
operator||
name|DEPCOMPLETE
operator|)
condition|)
continue|continue;
name|jstart
operator|=
name|jnewblk
operator|->
name|jn_blkno
operator|+
name|jnewblk
operator|->
name|jn_oldfrags
expr_stmt|;
name|jend
operator|=
name|jnewblk
operator|->
name|jn_blkno
operator|+
name|jnewblk
operator|->
name|jn_frags
expr_stmt|;
if|if
condition|(
operator|(
name|blkno
operator|>=
name|jstart
operator|&&
name|blkno
operator|<
name|jend
operator|)
operator|||
operator|(
name|end
operator|>
name|jstart
operator|&&
name|end
operator|<=
name|jend
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"state 0x%X %jd - %d %d dep %p\n"
argument_list|,
name|jnewblk
operator|->
name|jn_state
argument_list|,
name|jnewblk
operator|->
name|jn_blkno
argument_list|,
name|jnewblk
operator|->
name|jn_oldfrags
argument_list|,
name|jnewblk
operator|->
name|jn_frags
argument_list|,
name|jnewblk
operator|->
name|jn_dep
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"softdep_setup_blkfree: "
literal|"%jd-%jd(%d) overlaps with %jd-%jd"
argument_list|,
name|blkno
argument_list|,
name|end
argument_list|,
name|frags
argument_list|,
name|jstart
argument_list|,
name|jend
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Revert a block allocation when the journal record that describes it  * is not yet written.  */
end_comment

begin_function
specifier|static
name|int
name|jnewblk_rollback
parameter_list|(
name|jnewblk
parameter_list|,
name|fs
parameter_list|,
name|cgp
parameter_list|,
name|blksfree
parameter_list|)
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|uint8_t
modifier|*
name|blksfree
decl_stmt|;
block|{
name|ufs1_daddr_t
name|fragno
decl_stmt|;
name|long
name|cgbno
decl_stmt|,
name|bbase
decl_stmt|;
name|int
name|frags
decl_stmt|,
name|blk
decl_stmt|;
name|int
name|i
decl_stmt|;
name|frags
operator|=
literal|0
expr_stmt|;
name|cgbno
operator|=
name|dtogd
argument_list|(
name|fs
argument_list|,
name|jnewblk
operator|->
name|jn_blkno
argument_list|)
expr_stmt|;
comment|/* 	 * We have to test which frags need to be rolled back.  We may 	 * be operating on a stale copy when doing background writes. 	 */
for|for
control|(
name|i
operator|=
name|jnewblk
operator|->
name|jn_oldfrags
init|;
name|i
operator|<
name|jnewblk
operator|->
name|jn_frags
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isclr
argument_list|(
name|blksfree
argument_list|,
name|cgbno
operator|+
name|i
argument_list|)
condition|)
name|frags
operator|++
expr_stmt|;
if|if
condition|(
name|frags
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * This is mostly ffs_blkfree() sans some validation and 	 * superblock updates. 	 */
if|if
condition|(
name|frags
operator|==
name|fs
operator|->
name|fs_frag
condition|)
block|{
name|fragno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|cgbno
argument_list|)
expr_stmt|;
name|ffs_setblock
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|fragno
argument_list|)
expr_stmt|;
name|ffs_clusteracct
argument_list|(
name|fs
argument_list|,
name|cgp
argument_list|,
name|fragno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cgbno
operator|+=
name|jnewblk
operator|->
name|jn_oldfrags
expr_stmt|;
name|bbase
operator|=
name|cgbno
operator|-
name|fragnum
argument_list|(
name|fs
argument_list|,
name|cgbno
argument_list|)
expr_stmt|;
comment|/* Decrement the old frags.  */
name|blk
operator|=
name|blkmap
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|bbase
argument_list|)
expr_stmt|;
name|ffs_fragacct
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|,
name|cgp
operator|->
name|cg_frsum
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Deallocate the fragment */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|frags
condition|;
name|i
operator|++
control|)
name|setbit
argument_list|(
name|blksfree
argument_list|,
name|cgbno
operator|+
name|i
argument_list|)
expr_stmt|;
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nffree
operator|+=
name|frags
expr_stmt|;
comment|/* Add back in counts associated with the new frags */
name|blk
operator|=
name|blkmap
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|bbase
argument_list|)
expr_stmt|;
name|ffs_fragacct
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|,
name|cgp
operator|->
name|cg_frsum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If a complete block has been reassembled, account for it. */
name|fragno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|bbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffs_isblock
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|fragno
argument_list|)
condition|)
block|{
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nffree
operator|-=
name|fs
operator|->
name|fs_frag
expr_stmt|;
name|ffs_clusteracct
argument_list|(
name|fs
argument_list|,
name|cgp
argument_list|,
name|fragno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
block|}
block|}
name|stat_jnewblk
operator|++
expr_stmt|;
name|jnewblk
operator|->
name|jn_state
operator|&=
operator|~
name|ATTACHED
expr_stmt|;
name|jnewblk
operator|->
name|jn_state
operator||=
name|UNDONE
expr_stmt|;
return|return
operator|(
name|frags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|initiate_write_bmsafemap
parameter_list|(
name|bmsafemap
parameter_list|,
name|bp
parameter_list|)
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* The cg block. */
block|{
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|;
name|uint8_t
modifier|*
name|inosused
decl_stmt|;
name|uint8_t
modifier|*
name|blksfree
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
comment|/* 	 * If this is a background write, we did this at the time that 	 * the copy was made, so do not need to do it again. 	 */
if|if
condition|(
name|bmsafemap
operator|->
name|sm_state
operator|&
name|IOSTARTED
condition|)
return|return;
name|bmsafemap
operator|->
name|sm_state
operator||=
name|IOSTARTED
expr_stmt|;
comment|/* 	 * Clear any inode allocations which are pending journal writes. 	 */
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_jaddrefhd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|cgp
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|bmsafemap
operator|->
name|sm_list
operator|.
name|wk_mp
argument_list|)
operator|->
name|um_fs
expr_stmt|;
name|inosused
operator|=
name|cg_inosused
argument_list|(
name|cgp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|jaddref
argument_list|,
argument|&bmsafemap->sm_jaddrefhd
argument_list|,
argument|ja_bmdeps
argument_list|)
block|{
name|ino
operator|=
name|jaddref
operator|->
name|ja_ino
operator|%
name|fs
operator|->
name|fs_ipg
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|inosused
argument_list|,
name|ino
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|jaddref
operator|->
name|ja_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
condition|)
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_ndir
operator|--
expr_stmt|;
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nifree
operator|++
expr_stmt|;
name|clrbit
argument_list|(
name|inosused
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|jaddref
operator|->
name|ja_state
operator|&=
operator|~
name|ATTACHED
expr_stmt|;
name|jaddref
operator|->
name|ja_state
operator||=
name|UNDONE
expr_stmt|;
name|stat_jaddref
operator|++
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"initiate_write_bmsafemap: inode %ju "
literal|"marked free"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|jaddref
operator|->
name|ja_ino
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Clear any block allocations which are pending journal writes. 	 */
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_jnewblkhd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|cgp
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|bmsafemap
operator|->
name|sm_list
operator|.
name|wk_mp
argument_list|)
operator|->
name|um_fs
expr_stmt|;
name|blksfree
operator|=
name|cg_blksfree
argument_list|(
name|cgp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|jnewblk
argument_list|,
argument|&bmsafemap->sm_jnewblkhd
argument_list|,
argument|jn_deps
argument_list|)
block|{
if|if
condition|(
name|jnewblk_rollback
argument_list|(
name|jnewblk
argument_list|,
name|fs
argument_list|,
name|cgp
argument_list|,
name|blksfree
argument_list|)
condition|)
continue|continue;
name|panic
argument_list|(
literal|"initiate_write_bmsafemap: block %jd "
literal|"marked free"
argument_list|,
name|jnewblk
operator|->
name|jn_blkno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Move allocation lists to the written lists so they can be 	 * cleared once the block write is complete. 	 */
name|LIST_SWAP
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_inodedephd
argument_list|,
operator|&
name|bmsafemap
operator|->
name|sm_inodedepwr
argument_list|,
name|inodedep
argument_list|,
name|id_deps
argument_list|)
expr_stmt|;
name|LIST_SWAP
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_newblkhd
argument_list|,
operator|&
name|bmsafemap
operator|->
name|sm_newblkwr
argument_list|,
name|newblk
argument_list|,
name|nb_deps
argument_list|)
expr_stmt|;
name|LIST_SWAP
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_freehd
argument_list|,
operator|&
name|bmsafemap
operator|->
name|sm_freewr
argument_list|,
name|worklist
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is called during the completion interrupt  * service routine for a disk write (from the procedure called  * by the device driver to inform the filesystem caches of  * a request completion).  It should be called early in this  * procedure, before the block is made available to other  * processes or other routines are called.  *  */
end_comment

begin_function
specifier|static
name|void
name|softdep_disk_write_complete
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* describes the completed disk write */
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|worklist
modifier|*
name|owk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|workhead
name|reattach
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|buf
modifier|*
name|sbp
decl_stmt|;
comment|/* 	 * If an error occurred while doing the write, then the data 	 * has not hit the disk and the dependencies cannot be processed. 	 * But we do have to go through and roll forward any dependencies 	 * that were rolled back before the disk write. 	 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_ioflags
operator|&
name|BIO_ERROR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
operator|)
operator|==
literal|0
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&bp->b_dep
argument_list|,
argument|wk_list
argument_list|)
block|{
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_PAGEDEP
case|:
name|handle_written_filepage
argument_list|(
name|WK_PAGEDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_INODEDEP
case|:
name|handle_written_inodeblock
argument_list|(
name|WK_INODEDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_BMSAFEMAP
case|:
name|handle_written_bmsafemap
argument_list|(
name|WK_BMSAFEMAP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_INDIRDEP
case|:
name|handle_written_indirdep
argument_list|(
name|WK_INDIRDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|,
operator|&
name|sbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
default|default:
comment|/* nothing to roll forward */
continue|continue;
block|}
block|}
return|return;
block|}
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|reattach
argument_list|)
expr_stmt|;
comment|/* 	 * This lock must not be released anywhere in this code segment. 	 */
name|sbp
operator|=
name|NULL
expr_stmt|;
name|owk
operator|=
name|NULL
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|dep_write
index|[
name|wk
operator|->
name|wk_type
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|wk
operator|==
name|owk
condition|)
name|panic
argument_list|(
literal|"duplicate worklist: %p\n"
argument_list|,
name|wk
argument_list|)
expr_stmt|;
name|owk
operator|=
name|wk
expr_stmt|;
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_PAGEDEP
case|:
if|if
condition|(
name|handle_written_filepage
argument_list|(
name|WK_PAGEDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|,
name|WRITESUCCEEDED
argument_list|)
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|reattach
argument_list|,
name|wk
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_INODEDEP
case|:
if|if
condition|(
name|handle_written_inodeblock
argument_list|(
name|WK_INODEDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|,
name|WRITESUCCEEDED
argument_list|)
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|reattach
argument_list|,
name|wk
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_BMSAFEMAP
case|:
if|if
condition|(
name|handle_written_bmsafemap
argument_list|(
name|WK_BMSAFEMAP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|,
name|WRITESUCCEEDED
argument_list|)
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|reattach
argument_list|,
name|wk
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_MKDIR
case|:
name|handle_written_mkdir
argument_list|(
name|WK_MKDIR
argument_list|(
name|wk
argument_list|)
argument_list|,
name|MKDIR_BODY
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_ALLOCDIRECT
case|:
name|wk
operator|->
name|wk_state
operator||=
name|COMPLETE
expr_stmt|;
name|handle_allocdirect_partdone
argument_list|(
name|WK_ALLOCDIRECT
argument_list|(
name|wk
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_ALLOCINDIR
case|:
name|wk
operator|->
name|wk_state
operator||=
name|COMPLETE
expr_stmt|;
name|handle_allocindir_partdone
argument_list|(
name|WK_ALLOCINDIR
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_INDIRDEP
case|:
if|if
condition|(
name|handle_written_indirdep
argument_list|(
name|WK_INDIRDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|,
operator|&
name|sbp
argument_list|,
name|WRITESUCCEEDED
argument_list|)
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|reattach
argument_list|,
name|wk
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_FREEBLKS
case|:
name|wk
operator|->
name|wk_state
operator||=
name|COMPLETE
expr_stmt|;
name|freeblks
operator|=
name|WK_FREEBLKS
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wk
operator|->
name|wk_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|)
condition|)
name|add_to_worklist
argument_list|(
name|wk
argument_list|,
name|WK_NODELAY
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_FREEWORK
case|:
name|handle_written_freework
argument_list|(
name|WK_FREEWORK
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|D_JSEGDEP
case|:
name|free_jsegdep
argument_list|(
name|WK_JSEGDEP
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_JSEG
case|:
name|handle_written_jseg
argument_list|(
name|WK_JSEG
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_SBDEP
case|:
if|if
condition|(
name|handle_written_sbdep
argument_list|(
name|WK_SBDEP
argument_list|(
name|wk
argument_list|)
argument_list|,
name|bp
argument_list|)
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|reattach
argument_list|,
name|wk
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_FREEDEP
case|:
name|free_freedep
argument_list|(
name|WK_FREEDEP
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|panic
argument_list|(
literal|"handle_disk_write_complete: Unknown type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
comment|/* 	 * Reattach any requests that must be redone. 	 */
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|reattach
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
name|wk
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbp
condition|)
name|brelse
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called from within softdep_disk_write_complete above. Note that  * this routine is always called from interrupt level with further  * splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|void
name|handle_allocdirect_partdone
parameter_list|(
name|adp
parameter_list|,
name|wkhd
parameter_list|)
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|;
comment|/* the completed allocdirect */
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
comment|/* Work to do when inode is writtne. */
block|{
name|struct
name|allocdirectlst
modifier|*
name|listhead
decl_stmt|;
name|struct
name|allocdirect
modifier|*
name|listadp
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|long
name|bsize
decl_stmt|;
if|if
condition|(
operator|(
name|adp
operator|->
name|ad_state
operator|&
name|ALLCOMPLETE
operator|)
operator|!=
name|ALLCOMPLETE
condition|)
return|return;
comment|/* 	 * The on-disk inode cannot claim to be any larger than the last 	 * fragment that has been written. Otherwise, the on-disk inode 	 * might have fragments that were not the last block in the file 	 * which would corrupt the filesystem. Thus, we cannot free any 	 * allocdirects after one whose ad_oldblkno claims a fragment as 	 * these blocks must be rolled back to zero before writing the inode. 	 * We check the currently active set of allocdirects in id_inoupdt 	 * or id_extupdt as appropriate. 	 */
name|inodedep
operator|=
name|adp
operator|->
name|ad_inodedep
expr_stmt|;
name|bsize
operator|=
name|inodedep
operator|->
name|id_fs
operator|->
name|fs_bsize
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|ad_state
operator|&
name|EXTDATA
condition|)
name|listhead
operator|=
operator|&
name|inodedep
operator|->
name|id_extupdt
expr_stmt|;
else|else
name|listhead
operator|=
operator|&
name|inodedep
operator|->
name|id_inoupdt
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|listadp
argument_list|,
argument|listhead
argument_list|,
argument|ad_next
argument_list|)
block|{
comment|/* found our block */
if|if
condition|(
name|listadp
operator|==
name|adp
condition|)
break|break;
comment|/* continue if ad_oldlbn is not a fragment */
if|if
condition|(
name|listadp
operator|->
name|ad_oldsize
operator|==
literal|0
operator|||
name|listadp
operator|->
name|ad_oldsize
operator|==
name|bsize
condition|)
continue|continue;
comment|/* hit a fragment */
return|return;
block|}
comment|/* 	 * If we have reached the end of the current list without 	 * finding the just finished dependency, then it must be 	 * on the future dependency list. Future dependencies cannot 	 * be freed until they are moved to the current list. 	 */
if|if
condition|(
name|listadp
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|adp
operator|->
name|ad_state
operator|&
name|EXTDATA
condition|)
name|listhead
operator|=
operator|&
name|inodedep
operator|->
name|id_newextupdt
expr_stmt|;
else|else
name|listhead
operator|=
operator|&
name|inodedep
operator|->
name|id_newinoupdt
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|listadp
argument_list|,
argument|listhead
argument_list|,
argument|ad_next
argument_list|)
comment|/* found our block */
if|if
condition|(
name|listadp
operator|==
name|adp
condition|)
break|break;
if|if
condition|(
name|listadp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"handle_allocdirect_partdone: lost dep"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return;
block|}
comment|/* 	 * If we have found the just finished dependency, then queue 	 * it along with anything that follows it that is complete. 	 * Since the pointer has not yet been written in the inode 	 * as the dependency prevents it, place the allocdirect on the 	 * bufwait list where it will be freed once the pointer is 	 * valid. 	 */
if|if
condition|(
name|wkhd
operator|==
name|NULL
condition|)
name|wkhd
operator|=
operator|&
name|inodedep
operator|->
name|id_bufwait
expr_stmt|;
for|for
control|(
init|;
name|adp
condition|;
name|adp
operator|=
name|listadp
control|)
block|{
name|listadp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adp
operator|->
name|ad_state
operator|&
name|ALLCOMPLETE
operator|)
operator|!=
name|ALLCOMPLETE
condition|)
return|return;
name|TAILQ_REMOVE
argument_list|(
name|listhead
argument_list|,
name|adp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
name|wkhd
argument_list|,
operator|&
name|adp
operator|->
name|ad_block
operator|.
name|nb_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Called from within softdep_disk_write_complete above.  This routine  * completes successfully written allocindirs.  */
end_comment

begin_function
specifier|static
name|void
name|handle_allocindir_partdone
parameter_list|(
name|aip
parameter_list|)
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
comment|/* the completed allocindir */
block|{
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
if|if
condition|(
operator|(
name|aip
operator|->
name|ai_state
operator|&
name|ALLCOMPLETE
operator|)
operator|!=
name|ALLCOMPLETE
condition|)
return|return;
name|indirdep
operator|=
name|aip
operator|->
name|ai_indirdep
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|aip
argument_list|,
name|ai_next
argument_list|)
expr_stmt|;
comment|/* 	 * Don't set a pointer while the buffer is undergoing IO or while 	 * we have active truncations. 	 */
if|if
condition|(
name|indirdep
operator|->
name|ir_state
operator|&
name|UNDONE
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|)
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_donehd
argument_list|,
name|aip
argument_list|,
name|ai_next
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|indirdep
operator|->
name|ir_state
operator|&
name|UFS1FMT
condition|)
operator|(
operator|(
name|ufs1_daddr_t
operator|*
operator|)
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_data
operator|)
index|[
name|aip
operator|->
name|ai_offset
index|]
operator|=
name|aip
operator|->
name|ai_newblkno
expr_stmt|;
else|else
operator|(
operator|(
name|ufs2_daddr_t
operator|*
operator|)
name|indirdep
operator|->
name|ir_savebp
operator|->
name|b_data
operator|)
index|[
name|aip
operator|->
name|ai_offset
index|]
operator|=
name|aip
operator|->
name|ai_newblkno
expr_stmt|;
comment|/* 	 * Await the pointer write before freeing the allocindir. 	 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_writehd
argument_list|,
name|aip
argument_list|,
name|ai_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release segments held on a jwork list.  */
end_comment

begin_function
specifier|static
name|void
name|handle_jwork
parameter_list|(
name|wkhd
parameter_list|)
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
name|wkhd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_JSEGDEP
case|:
name|free_jsegdep
argument_list|(
name|WK_JSEGDEP
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_FREEDEP
case|:
name|free_freedep
argument_list|(
name|WK_FREEDEP
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_FREEFRAG
case|:
name|rele_jseg
argument_list|(
name|WK_JSEG
argument_list|(
name|WK_FREEFRAG
argument_list|(
name|wk
argument_list|)
operator|->
name|ff_jdep
argument_list|)
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|wk
argument_list|,
name|D_FREEFRAG
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_FREEWORK
case|:
name|handle_written_freework
argument_list|(
name|WK_FREEWORK
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|panic
argument_list|(
literal|"handle_jwork: Unknown type %s\n"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Handle the bufwait list on an inode when it is safe to release items  * held there.  This normally happens after an inode block is written but  * may be delayed and handled later if there are pending journal items that  * are not yet safe to be released.  */
end_comment

begin_function
specifier|static
name|struct
name|freefile
modifier|*
name|handle_bufwait
parameter_list|(
name|inodedep
parameter_list|,
name|refhd
parameter_list|)
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|workhead
modifier|*
name|refhd
decl_stmt|;
block|{
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|freefile
modifier|*
name|freefile
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|freefile
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_FREEFILE
case|:
comment|/* 			 * We defer adding freefile to the worklist 			 * until all other additions have been made to 			 * ensure that it will be done after all the 			 * old blocks have been freed. 			 */
if|if
condition|(
name|freefile
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"handle_bufwait: freefile"
argument_list|)
expr_stmt|;
name|freefile
operator|=
name|WK_FREEFILE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_MKDIR
case|:
name|handle_written_mkdir
argument_list|(
name|WK_MKDIR
argument_list|(
name|wk
argument_list|)
argument_list|,
name|MKDIR_PARENT
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_DIRADD
case|:
name|diradd_inode_written
argument_list|(
name|WK_DIRADD
argument_list|(
name|wk
argument_list|)
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_FREEFRAG
case|:
name|wk
operator|->
name|wk_state
operator||=
name|COMPLETE
expr_stmt|;
if|if
condition|(
operator|(
name|wk
operator|->
name|wk_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
name|add_to_worklist
argument_list|(
name|wk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_DIRREM
case|:
name|wk
operator|->
name|wk_state
operator||=
name|COMPLETE
expr_stmt|;
name|add_to_worklist
argument_list|(
name|wk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_ALLOCDIRECT
case|:
case|case
name|D_ALLOCINDIR
case|:
name|free_newblk
argument_list|(
name|WK_NEWBLK
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_JNEWBLK
case|:
name|wk
operator|->
name|wk_state
operator||=
name|COMPLETE
expr_stmt|;
name|free_jnewblk
argument_list|(
name|WK_JNEWBLK
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * Save freed journal segments and add references on 		 * the supplied list which will delay their release 		 * until the cg bitmap is cleared on disk. 		 */
case|case
name|D_JSEGDEP
case|:
if|if
condition|(
name|refhd
operator|==
name|NULL
condition|)
name|free_jsegdep
argument_list|(
name|WK_JSEGDEP
argument_list|(
name|wk
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|WORKLIST_INSERT
argument_list|(
name|refhd
argument_list|,
name|wk
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_JADDREF
case|:
name|jaddref
operator|=
name|WK_JADDREF
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|,
operator|&
name|jaddref
operator|->
name|ja_ref
argument_list|,
name|if_deps
argument_list|)
expr_stmt|;
comment|/* 			 * Transfer any jaddrefs to the list to be freed with 			 * the bitmap if we're handling a removed file. 			 */
if|if
condition|(
name|refhd
operator|==
name|NULL
condition|)
block|{
name|wk
operator|->
name|wk_state
operator||=
name|COMPLETE
expr_stmt|;
name|free_jaddref
argument_list|(
name|jaddref
argument_list|)
expr_stmt|;
block|}
else|else
name|WORKLIST_INSERT
argument_list|(
name|refhd
argument_list|,
name|wk
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|panic
argument_list|(
literal|"handle_bufwait: Unknown type %p(%s)"
argument_list|,
name|wk
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
return|return
operator|(
name|freefile
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called from within softdep_disk_write_complete above to restore  * in-memory inode block contents to their most up-to-date state. Note  * that this routine is always called from interrupt level with further  * interrupts from this device blocked.  *  * If the write did not succeed, we will do all the roll-forward  * operations, but we will not take the actions that will allow its  * dependencies to be processed.  */
end_comment

begin_function
specifier|static
name|int
name|handle_written_inodeblock
parameter_list|(
name|inodedep
parameter_list|,
name|bp
parameter_list|,
name|flags
parameter_list|)
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing the inode block */
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|freefile
modifier|*
name|freefile
decl_stmt|;
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|,
modifier|*
name|nextadp
decl_stmt|;
name|struct
name|ufs1_dinode
modifier|*
name|dp1
init|=
name|NULL
decl_stmt|;
name|struct
name|ufs2_dinode
modifier|*
name|dp2
init|=
name|NULL
decl_stmt|;
name|struct
name|workhead
name|wkhd
decl_stmt|;
name|int
name|hadchanges
decl_stmt|,
name|fstype
decl_stmt|;
name|ino_t
name|freelink
decl_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|wkhd
argument_list|)
expr_stmt|;
name|hadchanges
operator|=
literal|0
expr_stmt|;
name|freefile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|IOSTARTED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"handle_written_inodeblock: not started"
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator|&=
operator|~
name|IOSTARTED
expr_stmt|;
if|if
condition|(
name|inodedep
operator|->
name|id_fs
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
block|{
name|fstype
operator|=
name|UFS1
expr_stmt|;
name|dp1
operator|=
operator|(
expr|struct
name|ufs1_dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|inodedep
operator|->
name|id_fs
argument_list|,
name|inodedep
operator|->
name|id_ino
argument_list|)
expr_stmt|;
name|freelink
operator|=
name|dp1
operator|->
name|di_freelink
expr_stmt|;
block|}
else|else
block|{
name|fstype
operator|=
name|UFS2
expr_stmt|;
name|dp2
operator|=
operator|(
expr|struct
name|ufs2_dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|inodedep
operator|->
name|id_fs
argument_list|,
name|inodedep
operator|->
name|id_ino
argument_list|)
expr_stmt|;
name|freelink
operator|=
name|dp2
operator|->
name|di_freelink
expr_stmt|;
block|}
comment|/* 	 * Leave this inodeblock dirty until it's in the list. 	 */
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
operator|(
name|UNLINKED
operator||
name|UNLINKONLIST
operator|)
operator|)
operator|==
name|UNLINKED
operator|&&
operator|(
name|flags
operator|&
name|WRITESUCCEEDED
operator|)
condition|)
block|{
name|struct
name|inodedep
modifier|*
name|inon
decl_stmt|;
name|inon
operator|=
name|TAILQ_NEXT
argument_list|(
name|inodedep
argument_list|,
name|id_unlinked
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inon
operator|==
name|NULL
operator|&&
name|freelink
operator|==
literal|0
operator|)
operator|||
operator|(
name|inon
operator|&&
name|inon
operator|->
name|id_ino
operator|==
name|freelink
operator|)
condition|)
block|{
if|if
condition|(
name|inon
condition|)
name|inon
operator|->
name|id_state
operator||=
name|UNLINKPREV
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator||=
name|UNLINKNEXT
expr_stmt|;
block|}
name|hadchanges
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If we had to rollback the inode allocation because of 	 * bitmaps being incomplete, then simply restore it. 	 * Keep the block dirty so that it will not be reclaimed until 	 * all associated dependencies have been cleared and the 	 * corresponding updates written to disk. 	 */
if|if
condition|(
name|inodedep
operator|->
name|id_savedino1
operator|!=
name|NULL
condition|)
block|{
name|hadchanges
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fstype
operator|==
name|UFS1
condition|)
operator|*
name|dp1
operator|=
operator|*
name|inodedep
operator|->
name|id_savedino1
expr_stmt|;
else|else
operator|*
name|dp2
operator|=
operator|*
name|inodedep
operator|->
name|id_savedino2
expr_stmt|;
name|free
argument_list|(
name|inodedep
operator|->
name|id_savedino1
argument_list|,
name|M_SAVEDINO
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_savedino1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
name|stat_inode_bitmap
operator|++
expr_stmt|;
name|bdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * If the inode is clear here and GOINGAWAY it will never 		 * be written.  Process the bufwait and clear any pending 		 * work which may include the freefile. 		 */
if|if
condition|(
name|inodedep
operator|->
name|id_state
operator|&
name|GOINGAWAY
condition|)
goto|goto
name|bufwait
goto|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|WRITESUCCEEDED
condition|)
name|inodedep
operator|->
name|id_state
operator||=
name|COMPLETE
expr_stmt|;
comment|/* 	 * Roll forward anything that had to be rolled back before  	 * the inode could be updated. 	 */
for|for
control|(
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
init|;
name|adp
condition|;
name|adp
operator|=
name|nextadp
control|)
block|{
name|nextadp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|ad_state
operator|&
name|ATTACHED
condition|)
name|panic
argument_list|(
literal|"handle_written_inodeblock: new entry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstype
operator|==
name|UFS1
condition|)
block|{
if|if
condition|(
name|adp
operator|->
name|ad_offset
operator|<
name|UFS_NDADDR
condition|)
block|{
if|if
condition|(
name|dp1
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_offset
index|]
operator|!=
name|adp
operator|->
name|ad_oldblkno
condition|)
name|panic
argument_list|(
literal|"%s %s #%jd mismatch %d != %jd"
argument_list|,
literal|"handle_written_inodeblock:"
argument_list|,
literal|"direct pointer"
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_offset
argument_list|,
name|dp1
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_offset
index|]
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_oldblkno
argument_list|)
expr_stmt|;
name|dp1
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_offset
index|]
operator|=
name|adp
operator|->
name|ad_newblkno
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dp1
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
index|]
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: %s #%jd allocated as %d"
argument_list|,
literal|"handle_written_inodeblock"
argument_list|,
literal|"indirect pointer"
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
argument_list|,
name|dp1
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
index|]
argument_list|)
expr_stmt|;
name|dp1
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
index|]
operator|=
name|adp
operator|->
name|ad_newblkno
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|adp
operator|->
name|ad_offset
operator|<
name|UFS_NDADDR
condition|)
block|{
if|if
condition|(
name|dp2
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_offset
index|]
operator|!=
name|adp
operator|->
name|ad_oldblkno
condition|)
name|panic
argument_list|(
literal|"%s: %s #%jd %s %jd != %jd"
argument_list|,
literal|"handle_written_inodeblock"
argument_list|,
literal|"direct pointer"
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_offset
argument_list|,
literal|"mismatch"
argument_list|,
operator|(
name|intmax_t
operator|)
name|dp2
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_offset
index|]
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_oldblkno
argument_list|)
expr_stmt|;
name|dp2
operator|->
name|di_db
index|[
name|adp
operator|->
name|ad_offset
index|]
operator|=
name|adp
operator|->
name|ad_newblkno
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dp2
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
index|]
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: %s #%jd allocated as %jd"
argument_list|,
literal|"handle_written_inodeblock"
argument_list|,
literal|"indirect pointer"
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
argument_list|,
operator|(
name|intmax_t
operator|)
name|dp2
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
index|]
argument_list|)
expr_stmt|;
name|dp2
operator|->
name|di_ib
index|[
name|adp
operator|->
name|ad_offset
operator|-
name|UFS_NDADDR
index|]
operator|=
name|adp
operator|->
name|ad_newblkno
expr_stmt|;
block|}
block|}
name|adp
operator|->
name|ad_state
operator|&=
operator|~
name|UNDONE
expr_stmt|;
name|adp
operator|->
name|ad_state
operator||=
name|ATTACHED
expr_stmt|;
name|hadchanges
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
init|;
name|adp
condition|;
name|adp
operator|=
name|nextadp
control|)
block|{
name|nextadp
operator|=
name|TAILQ_NEXT
argument_list|(
name|adp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|ad_state
operator|&
name|ATTACHED
condition|)
name|panic
argument_list|(
literal|"handle_written_inodeblock: new entry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp2
operator|->
name|di_extb
index|[
name|adp
operator|->
name|ad_offset
index|]
operator|!=
name|adp
operator|->
name|ad_oldblkno
condition|)
name|panic
argument_list|(
literal|"%s: direct pointers #%jd %s %jd != %jd"
argument_list|,
literal|"handle_written_inodeblock"
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_offset
argument_list|,
literal|"mismatch"
argument_list|,
operator|(
name|intmax_t
operator|)
name|dp2
operator|->
name|di_extb
index|[
name|adp
operator|->
name|ad_offset
index|]
argument_list|,
operator|(
name|intmax_t
operator|)
name|adp
operator|->
name|ad_oldblkno
argument_list|)
expr_stmt|;
name|dp2
operator|->
name|di_extb
index|[
name|adp
operator|->
name|ad_offset
index|]
operator|=
name|adp
operator|->
name|ad_newblkno
expr_stmt|;
name|adp
operator|->
name|ad_state
operator|&=
operator|~
name|UNDONE
expr_stmt|;
name|adp
operator|->
name|ad_state
operator||=
name|ATTACHED
expr_stmt|;
name|hadchanges
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hadchanges
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
name|stat_direct_blk_ptrs
operator|++
expr_stmt|;
comment|/* 	 * Reset the file size to its most up-to-date value. 	 */
if|if
condition|(
name|inodedep
operator|->
name|id_savedsize
operator|==
operator|-
literal|1
operator|||
name|inodedep
operator|->
name|id_savedextsize
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"handle_written_inodeblock: bad size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep
operator|->
name|id_savednlink
operator|>
name|LINK_MAX
condition|)
name|panic
argument_list|(
literal|"handle_written_inodeblock: Invalid link count "
literal|"%jd for inodedep %p"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|inodedep
operator|->
name|id_savednlink
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstype
operator|==
name|UFS1
condition|)
block|{
if|if
condition|(
name|dp1
operator|->
name|di_nlink
operator|!=
name|inodedep
operator|->
name|id_savednlink
condition|)
block|{
name|dp1
operator|->
name|di_nlink
operator|=
name|inodedep
operator|->
name|id_savednlink
expr_stmt|;
name|hadchanges
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dp1
operator|->
name|di_size
operator|!=
name|inodedep
operator|->
name|id_savedsize
condition|)
block|{
name|dp1
operator|->
name|di_size
operator|=
name|inodedep
operator|->
name|id_savedsize
expr_stmt|;
name|hadchanges
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dp2
operator|->
name|di_nlink
operator|!=
name|inodedep
operator|->
name|id_savednlink
condition|)
block|{
name|dp2
operator|->
name|di_nlink
operator|=
name|inodedep
operator|->
name|id_savednlink
expr_stmt|;
name|hadchanges
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dp2
operator|->
name|di_size
operator|!=
name|inodedep
operator|->
name|id_savedsize
condition|)
block|{
name|dp2
operator|->
name|di_size
operator|=
name|inodedep
operator|->
name|id_savedsize
expr_stmt|;
name|hadchanges
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dp2
operator|->
name|di_extsize
operator|!=
name|inodedep
operator|->
name|id_savedextsize
condition|)
block|{
name|dp2
operator|->
name|di_extsize
operator|=
name|inodedep
operator|->
name|id_savedextsize
expr_stmt|;
name|hadchanges
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|inodedep
operator|->
name|id_savedsize
operator|=
operator|-
literal|1
expr_stmt|;
name|inodedep
operator|->
name|id_savedextsize
operator|=
operator|-
literal|1
expr_stmt|;
name|inodedep
operator|->
name|id_savednlink
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * If there were any rollbacks in the inode block, then it must be 	 * marked dirty so that its will eventually get written back in 	 * its correct form. 	 */
if|if
condition|(
name|hadchanges
condition|)
name|bdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bufwait
label|:
comment|/* 	 * If the write did not succeed, we have done all the roll-forward 	 * operations, but we cannot take the actions that will allow its 	 * dependencies to be processed. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|WRITESUCCEEDED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|hadchanges
operator|)
return|;
comment|/* 	 * Process any allocdirects that completed during the update. 	 */
if|if
condition|(
operator|(
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|handle_allocdirect_partdone
argument_list|(
name|adp
argument_list|,
operator|&
name|wkhd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|handle_allocdirect_partdone
argument_list|(
name|adp
argument_list|,
operator|&
name|wkhd
argument_list|)
expr_stmt|;
comment|/* 	 * Process deallocations that were held pending until the 	 * inode had been written to disk. Freeing of the inode 	 * is delayed until after all blocks have been freed to 	 * avoid creation of new<vfsid, inum, lbn> triples 	 * before the old ones have been deleted.  Completely 	 * unlinked inodes are not processed until the unlinked 	 * inode list is written or the last reference is removed. 	 */
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
operator|(
name|UNLINKED
operator||
name|UNLINKONLIST
operator|)
operator|)
operator|!=
name|UNLINKED
condition|)
block|{
name|freefile
operator|=
name|handle_bufwait
argument_list|(
name|inodedep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|freefile
operator|&&
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|wkhd
argument_list|)
condition|)
block|{
name|WORKLIST_INSERT
argument_list|(
operator|&
name|wkhd
argument_list|,
operator|&
name|freefile
operator|->
name|fx_list
argument_list|)
expr_stmt|;
name|freefile
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * Move rolled forward dependency completions to the bufwait list 	 * now that those that were already written have been processed. 	 */
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|wkhd
argument_list|)
operator|&&
name|hadchanges
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"handle_written_inodeblock: bufwait but no changes"
argument_list|)
expr_stmt|;
name|jwork_move
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|,
operator|&
name|wkhd
argument_list|)
expr_stmt|;
if|if
condition|(
name|freefile
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If the inode is goingaway it was never written.  Fake up 		 * the state here so free_inodedep() can succeed. 		 */
if|if
condition|(
name|inodedep
operator|->
name|id_state
operator|&
name|GOINGAWAY
condition|)
name|inodedep
operator|->
name|id_state
operator||=
name|COMPLETE
operator||
name|DEPCOMPLETE
expr_stmt|;
if|if
condition|(
name|free_inodedep
argument_list|(
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"handle_written_inodeblock: live inodedep %p"
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
name|add_to_worklist
argument_list|(
operator|&
name|freefile
operator|->
name|fx_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If no outstanding dependencies, free it. 	 */
if|if
condition|(
name|free_inodedep
argument_list|(
name|inodedep
argument_list|)
operator|||
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|)
operator|==
literal|0
operator|&&
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|==
literal|0
operator|&&
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
operator|==
literal|0
operator|&&
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|hadchanges
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform needed roll-forwards and kick off any dependencies that  * can now be processed.  *  * If the write did not succeed, we will do all the roll-forward  * operations, but we will not take the actions that will allow its  * dependencies to be processed.  */
end_comment

begin_function
specifier|static
name|int
name|handle_written_indirdep
parameter_list|(
name|indirdep
parameter_list|,
name|bp
parameter_list|,
name|bpp
parameter_list|,
name|flags
parameter_list|)
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|buf
modifier|*
modifier|*
name|bpp
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|struct
name|buf
modifier|*
name|sbp
decl_stmt|;
name|int
name|chgs
decl_stmt|;
if|if
condition|(
name|indirdep
operator|->
name|ir_state
operator|&
name|GOINGAWAY
condition|)
name|panic
argument_list|(
literal|"handle_written_indirdep: indirdep gone"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|indirdep
operator|->
name|ir_state
operator|&
name|IOSTARTED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"handle_written_indirdep: IO not started"
argument_list|)
expr_stmt|;
name|chgs
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If there were rollbacks revert them here. 	 */
if|if
condition|(
name|indirdep
operator|->
name|ir_saveddata
condition|)
block|{
name|bcopy
argument_list|(
name|indirdep
operator|->
name|ir_saveddata
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|indirdep
operator|->
name|ir_saveddata
argument_list|,
name|M_INDIRDEP
argument_list|)
expr_stmt|;
name|indirdep
operator|->
name|ir_saveddata
operator|=
name|NULL
expr_stmt|;
block|}
name|chgs
operator|=
literal|1
expr_stmt|;
block|}
name|indirdep
operator|->
name|ir_state
operator|&=
operator|~
operator|(
name|UNDONE
operator||
name|IOSTARTED
operator|)
expr_stmt|;
name|indirdep
operator|->
name|ir_state
operator||=
name|ATTACHED
expr_stmt|;
comment|/* 	 * If the write did not succeed, we have done all the roll-forward 	 * operations, but we cannot take the actions that will allow its 	 * dependencies to be processed. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|WRITESUCCEEDED
operator|)
operator|==
literal|0
condition|)
block|{
name|stat_indir_blk_ptrs
operator|++
expr_stmt|;
name|bdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Move allocindirs with written pointers to the completehd if 	 * the indirdep's pointer is not yet written.  Otherwise 	 * free them here. 	 */
while|while
condition|(
operator|(
name|aip
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_writehd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|aip
argument_list|,
name|ai_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|indirdep
operator|->
name|ir_state
operator|&
name|DEPCOMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_completehd
argument_list|,
name|aip
argument_list|,
name|ai_next
argument_list|)
expr_stmt|;
name|newblk_freefrag
argument_list|(
operator|&
name|aip
operator|->
name|ai_block
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|free_newblk
argument_list|(
operator|&
name|aip
operator|->
name|ai_block
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Move allocindirs that have finished dependency processing from 	 * the done list to the write list after updating the pointers. 	 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|aip
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_donehd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|handle_allocindir_partdone
argument_list|(
name|aip
argument_list|)
expr_stmt|;
if|if
condition|(
name|aip
operator|==
name|LIST_FIRST
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_donehd
argument_list|)
condition|)
name|panic
argument_list|(
literal|"disk_write_complete: not gone"
argument_list|)
expr_stmt|;
name|chgs
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Preserve the indirdep if there were any changes or if it is not 	 * yet valid on disk. 	 */
if|if
condition|(
name|chgs
condition|)
block|{
name|stat_indir_blk_ptrs
operator|++
expr_stmt|;
name|bdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If there were no changes we can discard the savedbp and detach 	 * ourselves from the buf.  We are only carrying completed pointers 	 * in this case. 	 */
name|sbp
operator|=
name|indirdep
operator|->
name|ir_savebp
expr_stmt|;
name|sbp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_NOCACHE
expr_stmt|;
name|indirdep
operator|->
name|ir_savebp
operator|=
name|NULL
expr_stmt|;
name|indirdep
operator|->
name|ir_bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|bpp
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"handle_written_indirdep: bp already exists."
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|sbp
expr_stmt|;
comment|/* 	 * The indirdep may not be freed until its parent points at it. 	 */
if|if
condition|(
name|indirdep
operator|->
name|ir_state
operator|&
name|DEPCOMPLETE
condition|)
name|free_indirdep
argument_list|(
name|indirdep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a diradd entry after its dependent inode has been written.  * This routine must be called with splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|void
name|diradd_inode_written
parameter_list|(
name|dap
parameter_list|,
name|inodedep
parameter_list|)
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
block|{
name|dap
operator|->
name|da_state
operator||=
name|COMPLETE
expr_stmt|;
name|complete_diradd
argument_list|(
name|dap
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_pendinghd
argument_list|,
operator|&
name|dap
operator|->
name|da_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the bmsafemap will have rollbacks when written.  Must only  * be called with the per-filesystem lock and the buf lock on the cg held.  */
end_comment

begin_function
specifier|static
name|int
name|bmsafemap_backgroundwrite
parameter_list|(
name|bmsafemap
parameter_list|,
name|bp
parameter_list|)
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|dirty
decl_stmt|;
name|LOCK_OWNED
argument_list|(
name|VFSTOUFS
argument_list|(
name|bmsafemap
operator|->
name|sm_list
operator|.
name|wk_mp
argument_list|)
argument_list|)
expr_stmt|;
name|dirty
operator|=
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_jaddrefhd
argument_list|)
operator||
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_jnewblkhd
argument_list|)
expr_stmt|;
comment|/* 	 * If we're initiating a background write we need to process the 	 * rollbacks as they exist now, not as they exist when IO starts. 	 * No other consumers will look at the contents of the shadowed 	 * buf so this is safe to do here. 	 */
if|if
condition|(
name|bp
operator|->
name|b_xflags
operator|&
name|BX_BKGRDMARKER
condition|)
name|initiate_write_bmsafemap
argument_list|(
name|bmsafemap
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dirty
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Re-apply an allocation when a cg write is complete.  */
end_comment

begin_function
specifier|static
name|int
name|jnewblk_rollforward
parameter_list|(
name|jnewblk
parameter_list|,
name|fs
parameter_list|,
name|cgp
parameter_list|,
name|blksfree
parameter_list|)
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|uint8_t
modifier|*
name|blksfree
decl_stmt|;
block|{
name|ufs1_daddr_t
name|fragno
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
name|long
name|cgbno
decl_stmt|,
name|bbase
decl_stmt|;
name|int
name|frags
decl_stmt|,
name|blk
decl_stmt|;
name|int
name|i
decl_stmt|;
name|frags
operator|=
literal|0
expr_stmt|;
name|cgbno
operator|=
name|dtogd
argument_list|(
name|fs
argument_list|,
name|jnewblk
operator|->
name|jn_blkno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|jnewblk
operator|->
name|jn_oldfrags
init|;
name|i
operator|<
name|jnewblk
operator|->
name|jn_frags
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|blksfree
argument_list|,
name|cgbno
operator|+
name|i
argument_list|)
condition|)
name|panic
argument_list|(
literal|"jnewblk_rollforward: re-allocated fragment"
argument_list|)
expr_stmt|;
name|frags
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|frags
operator|==
name|fs
operator|->
name|fs_frag
condition|)
block|{
name|blkno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|cgbno
argument_list|)
expr_stmt|;
name|ffs_clrblock
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
operator|(
name|long
operator|)
name|blkno
argument_list|)
expr_stmt|;
name|ffs_clusteracct
argument_list|(
name|fs
argument_list|,
name|cgp
argument_list|,
name|blkno
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
block|}
else|else
block|{
name|bbase
operator|=
name|cgbno
operator|-
name|fragnum
argument_list|(
name|fs
argument_list|,
name|cgbno
argument_list|)
expr_stmt|;
name|cgbno
operator|+=
name|jnewblk
operator|->
name|jn_oldfrags
expr_stmt|;
comment|/* If a complete block had been reassembled, account for it. */
name|fragno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|bbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffs_isblock
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|fragno
argument_list|)
condition|)
block|{
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nffree
operator|+=
name|fs
operator|->
name|fs_frag
expr_stmt|;
name|ffs_clusteracct
argument_list|(
name|fs
argument_list|,
name|cgp
argument_list|,
name|fragno
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
block|}
comment|/* Decrement the old frags.  */
name|blk
operator|=
name|blkmap
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|bbase
argument_list|)
expr_stmt|;
name|ffs_fragacct
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|,
name|cgp
operator|->
name|cg_frsum
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Allocate the fragment */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|frags
condition|;
name|i
operator|++
control|)
name|clrbit
argument_list|(
name|blksfree
argument_list|,
name|cgbno
operator|+
name|i
argument_list|)
expr_stmt|;
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nffree
operator|-=
name|frags
expr_stmt|;
comment|/* Add back in counts associated with the new frags */
name|blk
operator|=
name|blkmap
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|bbase
argument_list|)
expr_stmt|;
name|ffs_fragacct
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|,
name|cgp
operator|->
name|cg_frsum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|frags
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Complete a write to a bmsafemap structure.  Roll forward any bitmap  * changes if it's not a background write.  Set all written dependencies   * to DEPCOMPLETE and free the structure if possible.  *  * If the write did not succeed, we will do all the roll-forward  * operations, but we will not take the actions that will allow its  * dependencies to be processed.  */
end_comment

begin_function
specifier|static
name|int
name|handle_written_bmsafemap
parameter_list|(
name|bmsafemap
parameter_list|,
name|bp
parameter_list|,
name|flags
parameter_list|)
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|,
modifier|*
name|jatmp
decl_stmt|;
name|struct
name|jnewblk
modifier|*
name|jnewblk
decl_stmt|,
modifier|*
name|jntmp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|uint8_t
modifier|*
name|inosused
decl_stmt|;
name|uint8_t
modifier|*
name|blksfree
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|int
name|foreground
decl_stmt|;
name|int
name|chgs
decl_stmt|;
if|if
condition|(
operator|(
name|bmsafemap
operator|->
name|sm_state
operator|&
name|IOSTARTED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"handle_written_bmsafemap: Not started\n"
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|bmsafemap
operator|->
name|sm_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|chgs
operator|=
literal|0
expr_stmt|;
name|bmsafemap
operator|->
name|sm_state
operator|&=
operator|~
name|IOSTARTED
expr_stmt|;
name|foreground
operator|=
operator|(
name|bp
operator|->
name|b_xflags
operator|&
name|BX_BKGRDMARKER
operator|)
operator|==
literal|0
expr_stmt|;
comment|/* 	 * If write was successful, release journal work that was waiting 	 * on the write. Otherwise move the work back. 	 */
if|if
condition|(
name|flags
operator|&
name|WRITESUCCEEDED
condition|)
name|handle_jwork
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_freewr
argument_list|)
expr_stmt|;
else|else
name|LIST_CONCAT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_freehd
argument_list|,
operator|&
name|bmsafemap
operator|->
name|sm_freewr
argument_list|,
name|worklist
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
comment|/* 	 * Restore unwritten inode allocation pending jaddref writes. 	 */
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_jaddrefhd
argument_list|)
condition|)
block|{
name|cgp
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|bmsafemap
operator|->
name|sm_list
operator|.
name|wk_mp
argument_list|)
operator|->
name|um_fs
expr_stmt|;
name|inosused
operator|=
name|cg_inosused
argument_list|(
name|cgp
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|jaddref
argument_list|,
argument|&bmsafemap->sm_jaddrefhd
argument_list|,
argument|ja_bmdeps
argument_list|,
argument|jatmp
argument_list|)
block|{
if|if
condition|(
operator|(
name|jaddref
operator|->
name|ja_state
operator|&
name|UNDONE
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|ino
operator|=
name|jaddref
operator|->
name|ja_ino
operator|%
name|fs
operator|->
name|fs_ipg
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|inosused
argument_list|,
name|ino
argument_list|)
condition|)
name|panic
argument_list|(
literal|"handle_written_bmsafemap: "
literal|"re-allocated inode"
argument_list|)
expr_stmt|;
comment|/* Do the roll-forward only if it's a real copy. */
if|if
condition|(
name|foreground
condition|)
block|{
if|if
condition|(
operator|(
name|jaddref
operator|->
name|ja_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
condition|)
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_ndir
operator|++
expr_stmt|;
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nifree
operator|--
expr_stmt|;
name|setbit
argument_list|(
name|inosused
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|chgs
operator|=
literal|1
expr_stmt|;
block|}
name|jaddref
operator|->
name|ja_state
operator|&=
operator|~
name|UNDONE
expr_stmt|;
name|jaddref
operator|->
name|ja_state
operator||=
name|ATTACHED
expr_stmt|;
name|free_jaddref
argument_list|(
name|jaddref
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Restore any block allocations which are pending journal writes. 	 */
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_jnewblkhd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|cgp
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|fs
operator|=
name|VFSTOUFS
argument_list|(
name|bmsafemap
operator|->
name|sm_list
operator|.
name|wk_mp
argument_list|)
operator|->
name|um_fs
expr_stmt|;
name|blksfree
operator|=
name|cg_blksfree
argument_list|(
name|cgp
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|jnewblk
argument_list|,
argument|&bmsafemap->sm_jnewblkhd
argument_list|,
argument|jn_deps
argument_list|,
argument|jntmp
argument_list|)
block|{
if|if
condition|(
operator|(
name|jnewblk
operator|->
name|jn_state
operator|&
name|UNDONE
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Do the roll-forward only if it's a real copy. */
if|if
condition|(
name|foreground
operator|&&
name|jnewblk_rollforward
argument_list|(
name|jnewblk
argument_list|,
name|fs
argument_list|,
name|cgp
argument_list|,
name|blksfree
argument_list|)
condition|)
name|chgs
operator|=
literal|1
expr_stmt|;
name|jnewblk
operator|->
name|jn_state
operator|&=
operator|~
operator|(
name|UNDONE
operator||
name|NEWBLOCK
operator|)
expr_stmt|;
name|jnewblk
operator|->
name|jn_state
operator||=
name|ATTACHED
expr_stmt|;
name|free_jnewblk
argument_list|(
name|jnewblk
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If the write did not succeed, we have done all the roll-forward 	 * operations, but we cannot take the actions that will allow its 	 * dependencies to be processed. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|WRITESUCCEEDED
operator|)
operator|==
literal|0
condition|)
block|{
name|LIST_CONCAT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_newblkhd
argument_list|,
operator|&
name|bmsafemap
operator|->
name|sm_newblkwr
argument_list|,
name|newblk
argument_list|,
name|nb_deps
argument_list|)
expr_stmt|;
name|LIST_CONCAT
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_freehd
argument_list|,
operator|&
name|bmsafemap
operator|->
name|sm_freewr
argument_list|,
name|worklist
argument_list|,
name|wk_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|foreground
condition|)
name|bdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|newblk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_newblkwr
argument_list|)
operator|)
condition|)
block|{
name|newblk
operator|->
name|nb_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|newblk
operator|->
name|nb_state
operator|&=
operator|~
name|ONDEPLIST
expr_stmt|;
name|newblk
operator|->
name|nb_bmsafemap
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|newblk
argument_list|,
name|nb_deps
argument_list|)
expr_stmt|;
if|if
condition|(
name|newblk
operator|->
name|nb_list
operator|.
name|wk_type
operator|==
name|D_ALLOCDIRECT
condition|)
name|handle_allocdirect_partdone
argument_list|(
name|WK_ALLOCDIRECT
argument_list|(
operator|&
name|newblk
operator|->
name|nb_list
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|newblk
operator|->
name|nb_list
operator|.
name|wk_type
operator|==
name|D_ALLOCINDIR
condition|)
name|handle_allocindir_partdone
argument_list|(
name|WK_ALLOCINDIR
argument_list|(
operator|&
name|newblk
operator|->
name|nb_list
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|newblk
operator|->
name|nb_list
operator|.
name|wk_type
operator|!=
name|D_NEWBLK
condition|)
name|panic
argument_list|(
literal|"handle_written_bmsafemap: Unexpected type: %s"
argument_list|,
name|TYPENAME
argument_list|(
name|newblk
operator|->
name|nb_list
operator|.
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|inodedep
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_inodedepwr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|inodedep
operator|->
name|id_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|inodedep
operator|->
name|id_state
operator|&=
operator|~
name|ONDEPLIST
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|inodedep
argument_list|,
name|id_deps
argument_list|)
expr_stmt|;
name|inodedep
operator|->
name|id_bmsafemap
operator|=
name|NULL
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|bmsafemap
argument_list|,
name|sm_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chgs
operator|==
literal|0
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_jaddrefhd
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_jnewblkhd
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_newblkhd
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_inodedephd
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_freehd
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|bmsafemap
argument_list|,
name|sm_hash
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|bmsafemap
argument_list|,
name|D_BMSAFEMAP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ump
operator|->
name|softdep_dirtycg
argument_list|,
name|bmsafemap
argument_list|,
name|sm_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|foreground
condition|)
name|bdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to free a mkdir dependency.  */
end_comment

begin_function
specifier|static
name|void
name|complete_mkdir
parameter_list|(
name|mkdir
parameter_list|)
name|struct
name|mkdir
modifier|*
name|mkdir
decl_stmt|;
block|{
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
if|if
condition|(
operator|(
name|mkdir
operator|->
name|md_state
operator|&
name|ALLCOMPLETE
operator|)
operator|!=
name|ALLCOMPLETE
condition|)
return|return;
name|LIST_REMOVE
argument_list|(
name|mkdir
argument_list|,
name|md_mkdirs
argument_list|)
expr_stmt|;
name|dap
operator|=
name|mkdir
operator|->
name|md_diradd
expr_stmt|;
name|dap
operator|->
name|da_state
operator|&=
operator|~
operator|(
name|mkdir
operator|->
name|md_state
operator|&
operator|(
name|MKDIR_PARENT
operator||
name|MKDIR_BODY
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
operator|(
name|MKDIR_PARENT
operator||
name|MKDIR_BODY
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|dap
operator|->
name|da_state
operator||=
name|DEPCOMPLETE
expr_stmt|;
name|complete_diradd
argument_list|(
name|dap
argument_list|)
expr_stmt|;
block|}
name|WORKITEM_FREE
argument_list|(
name|mkdir
argument_list|,
name|D_MKDIR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle the completion of a mkdir dependency.  */
end_comment

begin_function
specifier|static
name|void
name|handle_written_mkdir
parameter_list|(
name|mkdir
parameter_list|,
name|type
parameter_list|)
name|struct
name|mkdir
modifier|*
name|mkdir
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|mkdir
operator|->
name|md_state
operator|&
operator|(
name|MKDIR_PARENT
operator||
name|MKDIR_BODY
operator|)
operator|)
operator|!=
name|type
condition|)
name|panic
argument_list|(
literal|"handle_written_mkdir: bad type"
argument_list|)
expr_stmt|;
name|mkdir
operator|->
name|md_state
operator||=
name|COMPLETE
expr_stmt|;
name|complete_mkdir
argument_list|(
name|mkdir
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_pagedep
parameter_list|(
name|pagedep
parameter_list|)
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pagedep
operator|->
name|pd_state
operator|&
name|NEWBLOCK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_dirremhd
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DAHASHSZ
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_jmvrefhd
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|pagedep
operator|->
name|pd_state
operator|&
name|ONWORKLIST
condition|)
name|WORKLIST_REMOVE
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pagedep
argument_list|,
name|pd_hash
argument_list|)
expr_stmt|;
name|WORKITEM_FREE
argument_list|(
name|pagedep
argument_list|,
name|D_PAGEDEP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called from within softdep_disk_write_complete above.  * A write operation was just completed. Removed inodes can  * now be freed and associated block pointers may be committed.  * Note that this routine is always called from interrupt level  * with further interrupts from this device blocked.  *  * If the write did not succeed, we will do all the roll-forward  * operations, but we will not take the actions that will allow its  * dependencies to be processed.  */
end_comment

begin_function
specifier|static
name|int
name|handle_written_filepage
parameter_list|(
name|pagedep
parameter_list|,
name|bp
parameter_list|,
name|flags
parameter_list|)
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing the written page */
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|,
modifier|*
name|nextdap
decl_stmt|;
name|struct
name|direct
modifier|*
name|ep
decl_stmt|;
name|int
name|i
decl_stmt|,
name|chgs
decl_stmt|;
if|if
condition|(
operator|(
name|pagedep
operator|->
name|pd_state
operator|&
name|IOSTARTED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"handle_written_filepage: not started"
argument_list|)
expr_stmt|;
name|pagedep
operator|->
name|pd_state
operator|&=
operator|~
name|IOSTARTED
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|WRITESUCCEEDED
operator|)
operator|==
literal|0
condition|)
goto|goto
name|rollforward
goto|;
comment|/* 	 * Process any directory removals that have been committed. 	 */
while|while
condition|(
operator|(
name|dirrem
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_dirremhd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|dirrem
argument_list|,
name|dm_next
argument_list|)
expr_stmt|;
name|dirrem
operator|->
name|dm_state
operator||=
name|COMPLETE
expr_stmt|;
name|dirrem
operator|->
name|dm_dirinum
operator|=
name|pagedep
operator|->
name|pd_ino
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jremrefhd
argument_list|)
argument_list|,
operator|(
literal|"handle_written_filepage: Journal entries not written."
operator|)
argument_list|)
expr_stmt|;
name|add_to_worklist
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free any directory additions that have been committed. 	 * If it is a newly allocated block, we have to wait until 	 * the on-disk directory inode claims the new block. 	 */
if|if
condition|(
operator|(
name|pagedep
operator|->
name|pd_state
operator|&
name|NEWBLOCK
operator|)
operator|==
literal|0
condition|)
while|while
condition|(
operator|(
name|dap
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|free_diradd
argument_list|(
name|dap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rollforward
label|:
comment|/* 	 * Uncommitted directory entries must be restored. 	 */
for|for
control|(
name|chgs
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DAHASHSZ
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|dap
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|i
index|]
argument_list|)
init|;
name|dap
condition|;
name|dap
operator|=
name|nextdap
control|)
block|{
name|nextdap
operator|=
name|LIST_NEXT
argument_list|(
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|ATTACHED
condition|)
name|panic
argument_list|(
literal|"handle_written_filepage: attached"
argument_list|)
expr_stmt|;
name|ep
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|dap
operator|->
name|da_offset
operator|)
expr_stmt|;
name|ep
operator|->
name|d_ino
operator|=
name|dap
operator|->
name|da_newinum
expr_stmt|;
name|dap
operator|->
name|da_state
operator|&=
operator|~
name|UNDONE
expr_stmt|;
name|dap
operator|->
name|da_state
operator||=
name|ATTACHED
expr_stmt|;
name|chgs
operator|=
literal|1
expr_stmt|;
comment|/* 			 * If the inode referenced by the directory has 			 * been written out, then the dependency can be 			 * moved to the pending list. 			 */
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
name|ALLCOMPLETE
operator|)
operator|==
name|ALLCOMPLETE
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_pendinghd
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If there were any rollbacks in the directory, then it must be 	 * marked dirty so that its will eventually get written back in 	 * its correct form. 	 */
if|if
condition|(
name|chgs
operator|||
operator|(
name|flags
operator|&
name|WRITESUCCEEDED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
name|stat_dir_entry
operator|++
expr_stmt|;
name|bdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If we are not waiting for a new directory block to be 	 * claimed by its inode, then the pagedep will be freed. 	 * Otherwise it will remain to track any new entries on 	 * the page in case they are fsync'ed. 	 */
name|free_pagedep
argument_list|(
name|pagedep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Writing back in-core inode structures.  *   * The filesystem only accesses an inode's contents when it occupies an  * "in-core" inode structure.  These "in-core" structures are separate from  * the page frames used to cache inode blocks.  Only the latter are  * transferred to/from the disk.  So, when the updated contents of the  * "in-core" inode structure are copied to the corresponding in-memory inode  * block, the dependencies are also transferred.  The following procedure is  * called when copying a dirty "in-core" inode to a cached inode block.  */
end_comment

begin_comment
comment|/*  * Called when an inode is loaded from disk. If the effective link count  * differed from the actual link count when it was last flushed, then we  * need to ensure that the correct effective link count is put back.  */
end_comment

begin_function
name|void
name|softdep_load_inodeblock
parameter_list|(
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* the "in_core" copy of the inode */
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|ITOUMP
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_load_inodeblock called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check for alternate nlink count. 	 */
name|ip
operator|->
name|i_effnlink
operator|=
name|ip
operator|->
name|i_nlink
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|->
name|i_effnlink
operator|-=
name|inodedep
operator|->
name|id_nlinkdelta
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is called just before the "in-core" inode  * information is to be copied to the in-memory inode block.  * Recall that an inode block contains several inodes. If  * the force flag is set, then the dependencies will be  * cleared so that the update can always be made. Note that  * the buffer is locked when this routine is called, so we  * will never be in the middle of writing the inode block   * to disk.  */
end_comment

begin_function
name|void
name|softdep_update_inodeblock
parameter_list|(
name|ip
parameter_list|,
name|bp
parameter_list|,
name|waitfor
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
comment|/* the "in_core" copy of the inode */
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* the buffer containing the inode block */
name|int
name|waitfor
decl_stmt|;
comment|/* nonzero => update must be allowed */
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|inoref
modifier|*
name|inoref
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|buf
modifier|*
name|ibp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ump
operator|=
name|ITOUMP
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|mp
operator|=
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_update_inodeblock called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
comment|/* 	 * Preserve the freelink that is on disk.  clear_unlinked_inodedep() 	 * does not have access to the in-core ip so must write directly into 	 * the inode block buffer when setting freelink. 	 */
if|if
condition|(
name|fs
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_freelink
argument_list|,
operator|(
operator|(
expr|struct
name|ufs1_dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
operator|)
operator|->
name|di_freelink
argument_list|)
expr_stmt|;
else|else
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|i_freelink
argument_list|,
operator|(
operator|(
expr|struct
name|ufs2_dinode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
operator|)
operator|->
name|di_freelink
argument_list|)
expr_stmt|;
comment|/* 	 * If the effective link count is not equal to the actual link 	 * count, then we must track the difference in an inodedep while 	 * the inode is (potentially) tossed out of the cache. Otherwise, 	 * if there is no existing inodedep, then there are no dependencies 	 * to track. 	 */
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_effnlink
operator|!=
name|ip
operator|->
name|i_nlink
condition|)
name|panic
argument_list|(
literal|"softdep_update_inodeblock: bad link count"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inodedep
operator|->
name|id_nlinkdelta
operator|!=
name|ip
operator|->
name|i_nlink
operator|-
name|ip
operator|->
name|i_effnlink
condition|)
name|panic
argument_list|(
literal|"softdep_update_inodeblock: bad delta"
argument_list|)
expr_stmt|;
comment|/* 	 * If we're flushing all dependencies we must also move any waiting 	 * for journal writes onto the bufwait list prior to I/O. 	 */
if|if
condition|(
name|waitfor
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|inoref
argument_list|,
argument|&inodedep->id_inoreflst
argument_list|,
argument|if_deps
argument_list|)
block|{
if|if
condition|(
operator|(
name|inoref
operator|->
name|if_state
operator|&
operator|(
name|DEPCOMPLETE
operator||
name|GOINGAWAY
operator|)
operator|)
operator|==
name|DEPCOMPLETE
condition|)
block|{
name|jwait
argument_list|(
operator|&
name|inoref
operator|->
name|if_list
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
block|}
comment|/* 	 * Changes have been initiated. Anything depending on these 	 * changes cannot occur until this inode has been written. 	 */
name|inodedep
operator|->
name|id_state
operator|&=
operator|~
name|COMPLETE
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|ONWORKLIST
operator|)
operator|==
literal|0
condition|)
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
operator|&
name|inodedep
operator|->
name|id_list
argument_list|)
expr_stmt|;
comment|/* 	 * Any new dependencies associated with the incore inode must  	 * now be moved to the list associated with the buffer holding 	 * the in-memory copy of the inode. Once merged process any 	 * allocdirects that are completed by the merger. 	 */
name|merge_inode_lists
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|,
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
condition|)
name|handle_allocdirect_partdone
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|merge_inode_lists
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newextupdt
argument_list|,
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
condition|)
name|handle_allocdirect_partdone
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Now that the inode has been pushed into the buffer, the 	 * operations dependent on the inode being written to disk 	 * can be moved to the id_bufwait so that they will be 	 * processed when the buffer I/O completes. 	 */
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|,
name|wk
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Newly allocated inodes cannot be written until the bitmap 	 * that allocates them have been written (indicated by 	 * DEPCOMPLETE being set in id_state). If we are doing a 	 * forced sync (e.g., an fsync on a file), we force the bitmap 	 * to be written so that the update can be done. 	 */
if|if
condition|(
name|waitfor
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return;
block|}
name|retry
label|:
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
operator|(
name|DEPCOMPLETE
operator||
name|GOINGAWAY
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return;
block|}
name|ibp
operator|=
name|inodedep
operator|->
name|id_bmsafemap
operator|->
name|sm_buf
expr_stmt|;
name|ibp
operator|=
name|getdirtybuf
argument_list|(
name|ibp
argument_list|,
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If ibp came back as NULL, the dependency could have been 		 * freed while we slept.  Look it up again, and check to see 		 * that it has completed. 		 */
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bwrite
argument_list|(
name|ibp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|softdep_error
argument_list|(
literal|"softdep_update_inodeblock: bwrite"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Merge the a new inode dependency list (such as id_newinoupdt) into an  * old inode dependency list (such as id_inoupdt). This routine must be  * called with splbio interrupts blocked.  */
end_comment

begin_function
specifier|static
name|void
name|merge_inode_lists
parameter_list|(
name|newlisthead
parameter_list|,
name|oldlisthead
parameter_list|)
name|struct
name|allocdirectlst
modifier|*
name|newlisthead
decl_stmt|;
name|struct
name|allocdirectlst
modifier|*
name|oldlisthead
decl_stmt|;
block|{
name|struct
name|allocdirect
modifier|*
name|listadp
decl_stmt|,
modifier|*
name|newadp
decl_stmt|;
name|newadp
operator|=
name|TAILQ_FIRST
argument_list|(
name|newlisthead
argument_list|)
expr_stmt|;
for|for
control|(
name|listadp
operator|=
name|TAILQ_FIRST
argument_list|(
name|oldlisthead
argument_list|)
init|;
name|listadp
operator|&&
name|newadp
condition|;
control|)
block|{
if|if
condition|(
name|listadp
operator|->
name|ad_offset
operator|<
name|newadp
operator|->
name|ad_offset
condition|)
block|{
name|listadp
operator|=
name|TAILQ_NEXT
argument_list|(
name|listadp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|TAILQ_REMOVE
argument_list|(
name|newlisthead
argument_list|,
name|newadp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|listadp
argument_list|,
name|newadp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|listadp
operator|->
name|ad_offset
operator|==
name|newadp
operator|->
name|ad_offset
condition|)
block|{
name|allocdirect_merge
argument_list|(
name|oldlisthead
argument_list|,
name|newadp
argument_list|,
name|listadp
argument_list|)
expr_stmt|;
name|listadp
operator|=
name|newadp
expr_stmt|;
block|}
name|newadp
operator|=
name|TAILQ_FIRST
argument_list|(
name|newlisthead
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|newadp
operator|=
name|TAILQ_FIRST
argument_list|(
name|newlisthead
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|newlisthead
argument_list|,
name|newadp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|oldlisthead
argument_list|,
name|newadp
argument_list|,
name|ad_next
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * If we are doing an fsync, then we must ensure that any directory  * entries for the inode have been written after the inode gets to disk.  */
end_comment

begin_function
name|int
name|softdep_fsync
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
comment|/* the "in_core" copy of the inode */
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|inoref
modifier|*
name|inoref
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|pvp
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flushparent
decl_stmt|,
name|pagedep_new_block
decl_stmt|;
name|ino_t
name|parentino
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|vp
operator|->
name|v_mount
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
if|if
condition|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|restart
label|:
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|inoref
argument_list|,
argument|&inodedep->id_inoreflst
argument_list|,
argument|if_deps
argument_list|)
block|{
if|if
condition|(
operator|(
name|inoref
operator|->
name|if_state
operator|&
operator|(
name|DEPCOMPLETE
operator||
name|GOINGAWAY
operator|)
operator|)
operator|==
name|DEPCOMPLETE
condition|)
block|{
name|jwait
argument_list|(
operator|&
name|inoref
operator|->
name|if_list
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newextupdt
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|)
condition|)
name|panic
argument_list|(
literal|"softdep_fsync: pending ops %p"
argument_list|,
name|inodedep
argument_list|)
expr_stmt|;
for|for
control|(
name|error
operator|=
literal|0
operator|,
name|flushparent
operator|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_pendinghd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|!=
name|D_DIRADD
condition|)
name|panic
argument_list|(
literal|"softdep_fsync: Unexpected type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
name|dap
operator|=
name|WK_DIRADD
argument_list|(
name|wk
argument_list|)
expr_stmt|;
comment|/* 		 * Flush our parent if this directory entry has a MKDIR_PARENT 		 * dependency or is contained in a newly allocated block. 		 */
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|DIRCHG
condition|)
name|pagedep
operator|=
name|dap
operator|->
name|da_previous
operator|->
name|dm_pagedep
expr_stmt|;
else|else
name|pagedep
operator|=
name|dap
operator|->
name|da_pagedep
expr_stmt|;
name|parentino
operator|=
name|pagedep
operator|->
name|pd_ino
expr_stmt|;
name|lbn
operator|=
name|pagedep
operator|->
name|pd_lbn
expr_stmt|;
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
operator|(
name|MKDIR_BODY
operator||
name|COMPLETE
operator|)
operator|)
operator|!=
name|COMPLETE
condition|)
name|panic
argument_list|(
literal|"softdep_fsync: dirty"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dap
operator|->
name|da_state
operator|&
name|MKDIR_PARENT
operator|)
operator|||
operator|(
name|pagedep
operator|->
name|pd_state
operator|&
name|NEWBLOCK
operator|)
condition|)
name|flushparent
operator|=
literal|1
expr_stmt|;
else|else
name|flushparent
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If we are being fsync'ed as part of vgone'ing this vnode, 		 * then we will not be able to release and recover the 		 * vnode below, so we just have to give up on writing its 		 * directory entry out. It will eventually be written, just 		 * not now, but then the user was not asking to have it 		 * written, so we are not breaking any promises. 		 */
if|if
condition|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
condition|)
break|break;
comment|/* 		 * We prevent deadlock by always fetching inodes from the 		 * root, moving down the directory tree. Thus, when fetching 		 * our parent directory, we first try to get the lock. If 		 * that fails, we must unlock ourselves before requesting 		 * the lock on our parent. See the comment in ufs_lookup 		 * for details on possible races. 		 */
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffs_vgetf
argument_list|(
name|mp
argument_list|,
name|parentino
argument_list|,
name|LK_NOWAIT
operator||
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|pvp
argument_list|,
name|FFSV_FORCEINSMQ
argument_list|)
condition|)
block|{
name|error
operator|=
name|vfs_busy
argument_list|(
name|mp
argument_list|,
name|MBF_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|vfs_ref
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|vfs_busy
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|vfs_rel
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
condition|)
block|{
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|ffs_vgetf
argument_list|(
name|mp
argument_list|,
name|parentino
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|pvp
argument_list|,
name|FFSV_FORCEINSMQ
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|vput
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * All MKDIR_PARENT dependencies and all the NEWBLOCK pagedeps 		 * that are contained in direct blocks will be resolved by  		 * doing a ffs_update. Pagedeps contained in indirect blocks 		 * may require a complete sync'ing of the directory. So, we 		 * try the cheap and fast ffs_update first, and if that fails, 		 * then we do the slower ffs_syncvnode of the directory. 		 */
if|if
condition|(
name|flushparent
condition|)
block|{
name|int
name|locked
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ffs_update
argument_list|(
name|pvp
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vput
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_pendinghd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wk
operator|->
name|wk_type
operator|!=
name|D_DIRADD
condition|)
name|panic
argument_list|(
literal|"softdep_fsync: Unexpected type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
name|dap
operator|=
name|WK_DIRADD
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|DIRCHG
condition|)
name|pagedep
operator|=
name|dap
operator|->
name|da_previous
operator|->
name|dm_pagedep
expr_stmt|;
else|else
name|pagedep
operator|=
name|dap
operator|->
name|da_pagedep
expr_stmt|;
name|pagedep_new_block
operator|=
name|pagedep
operator|->
name|pd_state
operator|&
name|NEWBLOCK
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pagedep_new_block
operator|&&
operator|(
name|error
operator|=
name|ffs_syncvnode
argument_list|(
name|pvp
argument_list|,
name|MNT_WAIT
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|vput
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|locked
condition|)
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Flush directory page containing the inode's name. 		 */
name|error
operator|=
name|bread
argument_list|(
name|pvp
argument_list|,
name|lbn
argument_list|,
name|blksize
argument_list|(
name|fs
argument_list|,
name|VTOI
argument_list|(
name|pvp
argument_list|)
argument_list|,
name|lbn
argument_list|)
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush all the dirty bitmaps associated with the block device  * before flushing the rest of the dirty blocks so as to reduce  * the number of dependencies that will have to be rolled back.  *  * XXX Unused?  */
end_comment

begin_function
name|void
name|softdep_fsync_mountdev
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
if|if
condition|(
operator|!
name|vn_isdisk
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|)
condition|)
name|panic
argument_list|(
literal|"softdep_fsync_mountdev: vnode not a disk"
argument_list|)
expr_stmt|;
name|bo
operator|=
operator|&
name|vp
operator|->
name|v_bufobj
expr_stmt|;
name|restart
label|:
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&bo->bo_dirty.bv_hd
argument_list|,
argument|b_bobufs
argument_list|,
argument|nbp
argument_list|)
block|{
comment|/*  		 * If it is already scheduled, skip to the next buffer. 		 */
if|if
condition|(
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_NOWAIT
argument_list|,
name|NULL
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_fsync_mountdev: not dirty"
argument_list|)
expr_stmt|;
comment|/* 		 * We are only interested in bitmaps with outstanding 		 * dependencies. 		 */
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|wk
operator|->
name|wk_type
operator|!=
name|D_BMSAFEMAP
operator|||
operator|(
name|bp
operator|->
name|b_vflags
operator|&
name|BV_BKGRDINPROG
operator|)
condition|)
block|{
name|BUF_UNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|drain_output
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sync all cylinder groups that were dirty at the time this function is  * called.  Newly dirtied cgs will be inserted before the sentinel.  This  * is used to flush freedep activity that may be holding up writes to a  * indirect block.  */
end_comment

begin_function
specifier|static
name|int
name|sync_cgs
parameter_list|(
name|mp
parameter_list|,
name|waitfor
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|waitfor
decl_stmt|;
block|{
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
name|struct
name|bmsafemap
modifier|*
name|sentinel
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sentinel
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sentinel
argument_list|)
argument_list|,
name|M_BMSAFEMAP
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sentinel
operator|->
name|sm_cg
operator|=
operator|-
literal|1
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ump
operator|->
name|softdep_dirtycg
argument_list|,
name|sentinel
argument_list|,
name|sm_next
argument_list|)
expr_stmt|;
for|for
control|(
name|bmsafemap
operator|=
name|LIST_NEXT
argument_list|(
name|sentinel
argument_list|,
name|sm_next
argument_list|)
init|;
name|bmsafemap
operator|!=
name|NULL
condition|;
name|bmsafemap
operator|=
name|LIST_NEXT
argument_list|(
name|sentinel
argument_list|,
name|sm_next
argument_list|)
control|)
block|{
comment|/* Skip sentinels and cgs with no work to release. */
if|if
condition|(
name|bmsafemap
operator|->
name|sm_cg
operator|==
operator|-
literal|1
operator|||
operator|(
name|LIST_EMPTY
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_freehd
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_freewr
argument_list|)
operator|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|sentinel
argument_list|,
name|sm_next
argument_list|)
expr_stmt|;
name|LIST_INSERT_AFTER
argument_list|(
name|bmsafemap
argument_list|,
name|sentinel
argument_list|,
name|sm_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If we don't get the lock and we're waiting try again, if 		 * not move on to the next buf and try to sync it. 		 */
name|bp
operator|=
name|getdirtybuf
argument_list|(
name|bmsafemap
operator|->
name|sm_buf
argument_list|,
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|,
name|waitfor
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
operator|&&
name|waitfor
operator|==
name|MNT_WAIT
condition|)
continue|continue;
name|LIST_REMOVE
argument_list|(
name|sentinel
argument_list|,
name|sm_next
argument_list|)
expr_stmt|;
name|LIST_INSERT_AFTER
argument_list|(
name|bmsafemap
argument_list|,
name|sentinel
argument_list|,
name|sm_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
continue|continue;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitfor
operator|==
name|MNT_NOWAIT
condition|)
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|LIST_REMOVE
argument_list|(
name|sentinel
argument_list|,
name|sm_next
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sentinel
argument_list|,
name|M_BMSAFEMAP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is called when we are trying to synchronously flush a  * file. This routine must eliminate any filesystem metadata dependencies  * so that the syncing routine can succeed.  */
end_comment

begin_function
name|int
name|softdep_sync_metadata
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_sync_metadata called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that any direct block dependencies have been cleared, 	 * truncations are started, and inode references are journaled. 	 */
name|ACQUIRE_LOCK
argument_list|(
name|VFSTOUFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Write all journal records to prevent rollbacks on devvp. 	 */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VCHR
condition|)
name|softdep_flushjournal
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|error
operator|=
name|flush_inodedep_deps
argument_list|(
name|vp
argument_list|,
name|vp
operator|->
name|v_mount
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that all truncates are written so we won't find deps on 	 * indirect blocks. 	 */
name|process_truncates
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|VFSTOUFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is called when we are attempting to sync a buf with  * dependencies.  If waitfor is MNT_NOWAIT it attempts to schedule any  * other IO it can but returns EBUSY if the buffer is not yet able to  * be written.  Dependencies which will not cause rollbacks will always  * return 0.  */
end_comment

begin_function
name|int
name|softdep_sync_buf
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|waitfor
parameter_list|)
block|{
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_sync_buf called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * For VCHR we just don't want to force flush any dependencies that 	 * will cause rollbacks. 	 */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VCHR
condition|)
block|{
if|if
condition|(
name|waitfor
operator|==
name|MNT_NOWAIT
operator|&&
name|softdep_count_dependencies
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * As we hold the buffer locked, none of its dependencies 	 * will disappear. 	 */
name|error
operator|=
literal|0
expr_stmt|;
name|top
label|:
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&bp->b_dep
argument_list|,
argument|wk_list
argument_list|)
block|{
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_ALLOCDIRECT
case|:
case|case
name|D_ALLOCINDIR
case|:
name|newblk
operator|=
name|WK_NEWBLK
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|newblk
operator|->
name|nb_jnewblk
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|waitfor
operator|==
name|MNT_NOWAIT
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|jwait
argument_list|(
operator|&
name|newblk
operator|->
name|nb_jnewblk
operator|->
name|jn_list
argument_list|,
name|waitfor
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|newblk
operator|->
name|nb_state
operator|&
name|DEPCOMPLETE
operator|||
name|waitfor
operator|==
name|MNT_NOWAIT
condition|)
continue|continue;
name|nbp
operator|=
name|newblk
operator|->
name|nb_bmsafemap
operator|->
name|sm_buf
expr_stmt|;
name|nbp
operator|=
name|getdirtybuf
argument_list|(
name|nbp
argument_list|,
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|,
name|waitfor
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbp
operator|==
name|NULL
condition|)
goto|goto
name|top
goto|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bwrite
argument_list|(
name|nbp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_INDIRDEP
case|:
name|indirdep
operator|=
name|WK_INDIRDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitfor
operator|==
name|MNT_NOWAIT
condition|)
block|{
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|)
operator|||
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_deplisthd
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|indirdep
operator|->
name|ir_trunc
argument_list|)
condition|)
name|panic
argument_list|(
literal|"softdep_sync_buf: truncation pending."
argument_list|)
expr_stmt|;
name|restart
label|:
name|LIST_FOREACH
argument_list|(
argument|aip
argument_list|,
argument|&indirdep->ir_deplisthd
argument_list|,
argument|ai_next
argument_list|)
block|{
name|newblk
operator|=
operator|(
expr|struct
name|newblk
operator|*
operator|)
name|aip
expr_stmt|;
if|if
condition|(
name|newblk
operator|->
name|nb_jnewblk
operator|!=
name|NULL
condition|)
block|{
name|jwait
argument_list|(
operator|&
name|newblk
operator|->
name|nb_jnewblk
operator|->
name|jn_list
argument_list|,
name|waitfor
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|newblk
operator|->
name|nb_state
operator|&
name|DEPCOMPLETE
condition|)
continue|continue;
name|nbp
operator|=
name|newblk
operator|->
name|nb_bmsafemap
operator|->
name|sm_buf
expr_stmt|;
name|nbp
operator|=
name|getdirtybuf
argument_list|(
name|nbp
argument_list|,
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|,
name|waitfor
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbp
operator|==
name|NULL
condition|)
goto|goto
name|restart
goto|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bwrite
argument_list|(
name|nbp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
continue|continue;
case|case
name|D_PAGEDEP
case|:
comment|/* 			 * Only flush directory entries in synchronous passes. 			 */
if|if
condition|(
name|waitfor
operator|!=
name|MNT_WAIT
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
comment|/* 			 * While syncing snapshots, we must allow recursive 			 * lookups. 			 */
name|BUF_AREC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 			 * We are trying to sync a directory that may 			 * have dependencies on both its own metadata 			 * and/or dependencies on the inodes of any 			 * recently allocated files. We walk its diradd 			 * lists pushing out the associated inode. 			 */
name|pagedep
operator|=
name|WK_PAGEDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DAHASHSZ
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|error
operator|=
name|flush_pagedep_deps
argument_list|(
name|vp
argument_list|,
name|wk
operator|->
name|wk_mp
argument_list|,
operator|&
name|pagedep
operator|->
name|pd_diraddhd
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
block|{
name|BUF_NOREC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
block|}
name|BUF_NOREC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|D_FREEWORK
case|:
case|case
name|D_FREEDEP
case|:
case|case
name|D_JSEGDEP
case|:
case|case
name|D_JNEWBLK
case|:
continue|continue;
default|default:
name|panic
argument_list|(
literal|"softdep_sync_buf: Unknown type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|out_unlock
label|:
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush the dependencies associated with an inodedep.  * Called with splbio blocked.  */
end_comment

begin_function
specifier|static
name|int
name|flush_inodedep_deps
parameter_list|(
name|vp
parameter_list|,
name|mp
parameter_list|,
name|ino
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|inoref
modifier|*
name|inoref
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|int
name|error
decl_stmt|,
name|waitfor
decl_stmt|;
comment|/* 	 * This work is done in two passes. The first pass grabs most 	 * of the buffers and begins asynchronously writing them. The 	 * only way to wait for these asynchronous writes is to sleep 	 * on the filesystem vnode which may stay busy for a long time 	 * if the filesystem is active. So, instead, we make a second 	 * pass over the dependencies blocking on each write. In the 	 * usual case we will be blocking against a write that we 	 * initiated, so when it is done the dependency will have been 	 * resolved. Thus the second pass is expected to end quickly. 	 * We give a brief window at the top of the loop to allow 	 * any pending I/O to complete. 	 */
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
for|for
control|(
name|error
operator|=
literal|0
operator|,
name|waitfor
operator|=
name|MNT_NOWAIT
init|;
condition|;
control|)
block|{
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|restart
label|:
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|TAILQ_FOREACH
argument_list|(
argument|inoref
argument_list|,
argument|&inodedep->id_inoreflst
argument_list|,
argument|if_deps
argument_list|)
block|{
if|if
condition|(
operator|(
name|inoref
operator|->
name|if_state
operator|&
operator|(
name|DEPCOMPLETE
operator||
name|GOINGAWAY
operator|)
operator|)
operator|==
name|DEPCOMPLETE
condition|)
block|{
name|jwait
argument_list|(
operator|&
name|inoref
operator|->
name|if_list
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
if|if
condition|(
name|flush_deplist
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|,
name|waitfor
argument_list|,
operator|&
name|error
argument_list|)
operator|||
name|flush_deplist
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|,
name|waitfor
argument_list|,
operator|&
name|error
argument_list|)
operator|||
name|flush_deplist
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|,
name|waitfor
argument_list|,
operator|&
name|error
argument_list|)
operator|||
name|flush_deplist
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newextupdt
argument_list|,
name|waitfor
argument_list|,
operator|&
name|error
argument_list|)
condition|)
continue|continue;
comment|/* 		 * If pass2, we are done, otherwise do pass 2. 		 */
if|if
condition|(
name|waitfor
operator|==
name|MNT_WAIT
condition|)
break|break;
name|waitfor
operator|=
name|MNT_WAIT
expr_stmt|;
block|}
comment|/* 	 * Try freeing inodedep in case all dependencies have been removed. 	 */
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|free_inodedep
argument_list|(
name|inodedep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush an inode dependency list.  * Called with splbio blocked.  */
end_comment

begin_function
specifier|static
name|int
name|flush_deplist
parameter_list|(
name|listhead
parameter_list|,
name|waitfor
parameter_list|,
name|errorp
parameter_list|)
name|struct
name|allocdirectlst
modifier|*
name|listhead
decl_stmt|;
name|int
name|waitfor
decl_stmt|;
name|int
modifier|*
name|errorp
decl_stmt|;
block|{
name|struct
name|allocdirect
modifier|*
name|adp
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|(
name|adp
operator|=
name|TAILQ_FIRST
argument_list|(
name|listhead
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|adp
operator|->
name|ad_list
operator|.
name|wk_mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|adp
argument_list|,
argument|listhead
argument_list|,
argument|ad_next
argument_list|)
block|{
name|newblk
operator|=
operator|(
expr|struct
name|newblk
operator|*
operator|)
name|adp
expr_stmt|;
if|if
condition|(
name|newblk
operator|->
name|nb_jnewblk
operator|!=
name|NULL
condition|)
block|{
name|jwait
argument_list|(
operator|&
name|newblk
operator|->
name|nb_jnewblk
operator|->
name|jn_list
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|newblk
operator|->
name|nb_state
operator|&
name|DEPCOMPLETE
condition|)
continue|continue;
name|bp
operator|=
name|newblk
operator|->
name|nb_bmsafemap
operator|->
name|sm_buf
expr_stmt|;
name|bp
operator|=
name|getdirtybuf
argument_list|(
name|bp
argument_list|,
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|,
name|waitfor
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|waitfor
operator|==
name|MNT_NOWAIT
condition|)
continue|continue;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitfor
operator|==
name|MNT_NOWAIT
condition|)
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
operator|*
name|errorp
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush dependencies associated with an allocdirect block.  */
end_comment

begin_function
specifier|static
name|int
name|flush_newblk_dep
parameter_list|(
name|vp
parameter_list|,
name|mp
parameter_list|,
name|lbn
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
block|{
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|ufs2_daddr_t
name|blkno
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|bo
operator|=
operator|&
name|vp
operator|->
name|v_bufobj
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|blkno
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|i_db
index|[
name|lbn
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"flush_newblk_dep: Missing block"
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * Loop until all dependencies related to this block are satisfied. 	 * We must be careful to restart after each sleep in case a write 	 * completes some part of this process for us. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|newblk_lookup
argument_list|(
name|mp
argument_list|,
name|blkno
argument_list|,
literal|0
argument_list|,
operator|&
name|newblk
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|newblk
operator|->
name|nb_list
operator|.
name|wk_type
operator|!=
name|D_ALLOCDIRECT
condition|)
name|panic
argument_list|(
literal|"flush_newblk_deps: Bad newblk %p"
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
comment|/* 		 * Flush the journal. 		 */
if|if
condition|(
name|newblk
operator|->
name|nb_jnewblk
operator|!=
name|NULL
condition|)
block|{
name|jwait
argument_list|(
operator|&
name|newblk
operator|->
name|nb_jnewblk
operator|->
name|jn_list
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Write the bitmap dependency. 		 */
if|if
condition|(
operator|(
name|newblk
operator|->
name|nb_state
operator|&
name|DEPCOMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|=
name|newblk
operator|->
name|nb_bmsafemap
operator|->
name|sm_buf
expr_stmt|;
name|bp
operator|=
name|getdirtybuf
argument_list|(
name|bp
argument_list|,
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
continue|continue;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Write the buffer. 		 */
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|bp
operator|=
name|gbincore
argument_list|(
name|bo
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_SLEEPFAIL
operator||
name|LK_INTERLOCK
argument_list|,
name|BO_LOCKPTR
argument_list|(
name|bo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOLCK
condition|)
block|{
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* Slept, retry */
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
comment|/* Failed */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
condition|)
block|{
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
else|else
name|BUF_UNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
comment|/* 		 * We have to wait for the direct pointers to 		 * point at the newdirblk before the dependency 		 * will go away. 		 */
name|error
operator|=
name|ffs_update
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Eliminate a pagedep dependency by flushing out all its diradd dependencies.  * Called with splbio blocked.  */
end_comment

begin_function
specifier|static
name|int
name|flush_pagedep_deps
parameter_list|(
name|pvp
parameter_list|,
name|mp
parameter_list|,
name|diraddhdp
parameter_list|)
name|struct
name|vnode
modifier|*
name|pvp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|diraddhd
modifier|*
name|diraddhdp
decl_stmt|;
block|{
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|inoref
modifier|*
name|inoref
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
name|struct
name|diraddhd
name|unfinished
decl_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|unfinished
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|restart
label|:
while|while
condition|(
operator|(
name|dap
operator|=
name|LIST_FIRST
argument_list|(
name|diraddhdp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Flush ourselves if this directory entry 		 * has a MKDIR_PARENT dependency. 		 */
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|MKDIR_PARENT
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ffs_update
argument_list|(
name|pvp
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 			 * If that cleared dependencies, go on to next. 			 */
if|if
condition|(
name|dap
operator|!=
name|LIST_FIRST
argument_list|(
name|diraddhdp
argument_list|)
condition|)
continue|continue;
comment|/* 			 * All MKDIR_PARENT dependencies and all the 			 * NEWBLOCK pagedeps that are contained in direct 			 * blocks were resolved by doing above ffs_update. 			 * Pagedeps contained in indirect blocks may 			 * require a complete sync'ing of the directory. 			 * We are in the midst of doing a complete sync, 			 * so if they are not resolved in this pass we 			 * defer them for now as they will be sync'ed by 			 * our caller shortly. 			 */
name|LIST_REMOVE
argument_list|(
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|unfinished
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * A newly allocated directory must have its "." and 		 * ".." entries written out before its name can be 		 * committed in its parent.  		 */
name|inum
operator|=
name|dap
operator|->
name|da_newinum
expr_stmt|;
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|,
name|inum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"flush_pagedep_deps: lost inode1"
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for any pending journal adds to complete so we don't 		 * cause rollbacks while syncing. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|inoref
argument_list|,
argument|&inodedep->id_inoreflst
argument_list|,
argument|if_deps
argument_list|)
block|{
if|if
condition|(
operator|(
name|inoref
operator|->
name|if_state
operator|&
operator|(
name|DEPCOMPLETE
operator||
name|GOINGAWAY
operator|)
operator|)
operator|==
name|DEPCOMPLETE
condition|)
block|{
name|jwait
argument_list|(
operator|&
name|inoref
operator|->
name|if_list
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|MKDIR_BODY
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ffs_vgetf
argument_list|(
name|mp
argument_list|,
name|inum
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|vp
argument_list|,
name|FFSV_FORCEINSMQ
argument_list|)
operator|)
condition|)
break|break;
name|error
operator|=
name|flush_newblk_dep
argument_list|(
name|vp
argument_list|,
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * If we still have the dependency we might need to 			 * update the vnode to sync the new link count to 			 * disk. 			 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|dap
operator|==
name|LIST_FIRST
argument_list|(
name|diraddhdp
argument_list|)
condition|)
name|error
operator|=
name|ffs_update
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 			 * If that cleared dependencies, go on to next. 			 */
if|if
condition|(
name|dap
operator|!=
name|LIST_FIRST
argument_list|(
name|diraddhdp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dap
operator|->
name|da_state
operator|&
name|MKDIR_BODY
condition|)
block|{
name|inodedep_lookup
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|,
name|inum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"flush_pagedep_deps: MKDIR_BODY "
literal|"inodedep %p dap %p vp %p"
argument_list|,
name|inodedep
argument_list|,
name|dap
argument_list|,
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Flush the inode on which the directory entry depends. 		 * Having accounted for MKDIR_PARENT and MKDIR_BODY above, 		 * the only remaining dependency is that the updated inode 		 * count must get pushed to disk. The inode has already 		 * been pushed into its inode buffer (via VOP_UPDATE) at 		 * the time of the reference count change. So we need only 		 * locate that buffer, ensure that there will be no rollback 		 * caused by a bitmap dependency, then write the inode buffer. 		 */
name|retry
label|:
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|,
name|inum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"flush_pagedep_deps: lost inode"
argument_list|)
expr_stmt|;
comment|/* 		 * If the inode still has bitmap dependencies, 		 * push them to disk. 		 */
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
operator|(
name|DEPCOMPLETE
operator||
name|GOINGAWAY
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|=
name|inodedep
operator|->
name|id_bmsafemap
operator|->
name|sm_buf
expr_stmt|;
name|bp
operator|=
name|getdirtybuf
argument_list|(
name|bp
argument_list|,
name|LOCK_PTR
argument_list|(
name|ump
argument_list|)
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
goto|goto
name|retry
goto|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|dap
operator|!=
name|LIST_FIRST
argument_list|(
name|diraddhdp
argument_list|)
condition|)
continue|continue;
block|}
comment|/* 		 * If the inode is still sitting in a buffer waiting 		 * to be written or waiting for the link count to be 		 * adjusted update it here to flush it to disk. 		 */
if|if
condition|(
name|dap
operator|==
name|LIST_FIRST
argument_list|(
name|diraddhdp
argument_list|)
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ffs_vgetf
argument_list|(
name|mp
argument_list|,
name|inum
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|vp
argument_list|,
name|FFSV_FORCEINSMQ
argument_list|)
operator|)
condition|)
break|break;
name|error
operator|=
name|ffs_update
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we have failed to get rid of all the dependencies 		 * then something is seriously wrong. 		 */
if|if
condition|(
name|dap
operator|==
name|LIST_FIRST
argument_list|(
name|diraddhdp
argument_list|)
condition|)
block|{
name|inodedep_lookup
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|,
name|inum
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"flush_pagedep_deps: failed to flush "
literal|"inodedep %p ino %ju dap %p"
argument_list|,
name|inodedep
argument_list|,
operator|(
name|uintmax_t
operator|)
name|inum
argument_list|,
name|dap
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dap
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|unfinished
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|diraddhdp
argument_list|,
name|dap
argument_list|,
name|da_pdlist
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A large burst of file addition or deletion activity can drive the  * memory load excessively high. First attempt to slow things down  * using the techniques below. If that fails, this routine requests  * the offending operations to fall back to running synchronously  * until the memory load returns to a reasonable level.  */
end_comment

begin_function
name|int
name|softdep_slowdown
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|int
name|jlow
decl_stmt|;
name|int
name|max_softdeps_hard
decl_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_slowdown called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|jlow
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check for journal space if needed. 	 */
if|if
condition|(
name|DOINGSUJ
argument_list|(
name|vp
argument_list|)
condition|)
block|{
if|if
condition|(
name|journal_space
argument_list|(
name|ump
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|jlow
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If the system is under its limits and our filesystem is 	 * not responsible for more than our share of the usage and 	 * we are not low on journal space, then no need to slow down. 	 */
name|max_softdeps_hard
operator|=
name|max_softdeps
operator|*
literal|11
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|dep_current
index|[
name|D_DIRREM
index|]
operator|<
name|max_softdeps_hard
operator|/
literal|2
operator|&&
name|dep_current
index|[
name|D_INODEDEP
index|]
operator|<
name|max_softdeps_hard
operator|&&
name|dep_current
index|[
name|D_INDIRDEP
index|]
operator|<
name|max_softdeps_hard
operator|/
literal|1000
operator|&&
name|dep_current
index|[
name|D_FREEBLKS
index|]
operator|<
name|max_softdeps_hard
operator|&&
name|jlow
operator|==
literal|0
operator|&&
name|ump
operator|->
name|softdep_curdeps
index|[
name|D_DIRREM
index|]
operator|<
operator|(
name|max_softdeps_hard
operator|/
literal|2
operator|)
operator|/
name|stat_flush_threads
operator|&&
name|ump
operator|->
name|softdep_curdeps
index|[
name|D_INODEDEP
index|]
operator|<
name|max_softdeps_hard
operator|/
name|stat_flush_threads
operator|&&
name|ump
operator|->
name|softdep_curdeps
index|[
name|D_INDIRDEP
index|]
operator|<
operator|(
name|max_softdeps_hard
operator|/
literal|1000
operator|)
operator|/
name|stat_flush_threads
operator|&&
name|ump
operator|->
name|softdep_curdeps
index|[
name|D_FREEBLKS
index|]
operator|<
name|max_softdeps_hard
operator|/
name|stat_flush_threads
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the journal is low or our filesystem is over its limit 	 * then speedup the cleanup. 	 */
if|if
condition|(
name|ump
operator|->
name|softdep_curdeps
index|[
name|D_INDIRDEP
index|]
operator|<
operator|(
name|max_softdeps_hard
operator|/
literal|1000
operator|)
operator|/
name|stat_flush_threads
operator|||
name|jlow
condition|)
name|softdep_speedup
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|stat_sync_limit_hit
operator|+=
literal|1
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * We only slow down the rate at which new dependencies are 	 * generated if we are not using journaling. With journaling, 	 * the cleanup should always be sufficient to keep things 	 * under control. 	 */
if|if
condition|(
name|DOINGSUJ
argument_list|(
name|vp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called by the allocation routines when they are about to fail  * in the hope that we can free up the requested resource (inodes  * or disk space).  *   * First check to see if the work list has anything on it. If it has,  * clean up entries until we successfully free the requested resource.  * Because this process holds inodes locked, we cannot handle any remove  * requests that might block on a locked inode as that could lead to  * deadlock. If the worklist yields none of the requested resource,  * start syncing out vnodes to free up the needed space.  */
end_comment

begin_function
name|int
name|softdep_request_cleanup
parameter_list|(
name|fs
parameter_list|,
name|vp
parameter_list|,
name|cred
parameter_list|,
name|resource
parameter_list|)
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|resource
decl_stmt|;
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|long
name|starttime
decl_stmt|;
name|ufs2_daddr_t
name|needed
decl_stmt|;
name|int
name|error
decl_stmt|,
name|failed_vnode
decl_stmt|;
comment|/* 	 * If we are being called because of a process doing a 	 * copy-on-write, then it is not safe to process any 	 * worklist items as we will recurse into the copyonwrite 	 * routine.  This will result in an incoherent snapshot. 	 * If the vnode that we hold is a snapshot, we must avoid 	 * handling other resources that could cause deadlock. 	 */
if|if
condition|(
operator|(
name|curthread
operator|->
name|td_pflags
operator|&
name|TDP_COWINPROGRESS
operator|)
operator|||
name|IS_SNAPSHOT
argument_list|(
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|resource
operator|==
name|FLUSH_BLOCKS_WAIT
condition|)
name|stat_cleanup_blkrequests
operator|+=
literal|1
expr_stmt|;
else|else
name|stat_cleanup_inorequests
operator|+=
literal|1
expr_stmt|;
name|mp
operator|=
name|vp
operator|->
name|v_mount
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
name|UFS_MTX
argument_list|(
name|ump
argument_list|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|UFS_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|error
operator|=
name|ffs_update
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|UFS_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If we are in need of resources, start by cleaning up 	 * any block removals associated with our inode. 	 */
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|process_removes
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|process_truncates
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * Now clean up at least as many resources as we will need. 	 * 	 * When requested to clean up inodes, the number that are needed 	 * is set by the number of simultaneous writers (mnt_writeopcount) 	 * plus a bit of slop (2) in case some more writers show up while 	 * we are cleaning. 	 * 	 * When requested to free up space, the amount of space that 	 * we need is enough blocks to allocate a full-sized segment 	 * (fs_contigsumsize). The number of such segments that will 	 * be needed is set by the number of simultaneous writers 	 * (mnt_writeopcount) plus a bit of slop (2) in case some more 	 * writers show up while we are cleaning. 	 * 	 * Additionally, if we are unpriviledged and allocating space, 	 * we need to ensure that we clean up enough blocks to get the 	 * needed number of blocks over the threshold of the minimum 	 * number of blocks required to be kept free by the filesystem 	 * (fs_minfree). 	 */
if|if
condition|(
name|resource
operator|==
name|FLUSH_INODES_WAIT
condition|)
block|{
name|needed
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_writeopcount
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resource
operator|==
name|FLUSH_BLOCKS_WAIT
condition|)
block|{
name|needed
operator|=
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_writeopcount
operator|+
literal|2
operator|)
operator|*
name|fs
operator|->
name|fs_contigsumsize
expr_stmt|;
if|if
condition|(
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_BLOCKRESERVE
argument_list|,
literal|0
argument_list|)
condition|)
name|needed
operator|+=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|roundup
argument_list|(
operator|(
name|fs
operator|->
name|fs_dsize
operator|*
name|fs
operator|->
name|fs_minfree
operator|/
literal|100
operator|)
operator|-
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nffree
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UFS_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"softdep_request_cleanup: Unknown resource type %d\n"
argument_list|,
name|resource
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|starttime
operator|=
name|time_second
expr_stmt|;
name|retry
label|:
if|if
condition|(
operator|(
name|resource
operator|==
name|FLUSH_BLOCKS_WAIT
operator|&&
name|ump
operator|->
name|softdep_on_worklist
operator|>
literal|0
operator|&&
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nbfree
operator|<=
name|needed
operator|)
operator|||
operator|(
name|resource
operator|==
name|FLUSH_INODES_WAIT
operator|&&
name|fs
operator|->
name|fs_pendinginodes
operator|>
literal|0
operator|&&
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nifree
operator|<=
name|needed
operator|)
condition|)
block|{
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|ump
operator|->
name|softdep_on_worklist
operator|>
literal|0
operator|&&
name|process_worklist_item
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|,
name|ump
operator|->
name|softdep_on_worklist
argument_list|,
name|LK_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
name|stat_worklist_push
operator|+=
literal|1
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we still need resources and there are no more worklist 	 * entries to process to obtain them, we have to start flushing 	 * the dirty vnodes to force the release of additional requests 	 * to the worklist that we can then process to reap addition 	 * resources. We walk the vnodes associated with the mount point 	 * until we get the needed worklist requests that we can reap. 	 * 	 * If there are several threads all needing to clean the same 	 * mount point, only one is allowed to walk the mount list. 	 * When several threads all try to walk the same mount list, 	 * they end up competing with each other and often end up in 	 * livelock. This approach ensures that forward progress is 	 * made at the cost of occational ENOSPC errors being returned 	 * that might otherwise have been avoided. 	 */
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|resource
operator|==
name|FLUSH_BLOCKS_WAIT
operator|&&
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nbfree
operator|<=
name|needed
operator|)
operator|||
operator|(
name|resource
operator|==
name|FLUSH_INODES_WAIT
operator|&&
name|fs
operator|->
name|fs_pendinginodes
operator|>
literal|0
operator|&&
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nifree
operator|<=
name|needed
operator|)
condition|)
block|{
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ump
operator|->
name|um_softdep
operator|->
name|sd_flags
operator|&
name|FLUSH_RC_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|ump
operator|->
name|um_softdep
operator|->
name|sd_flags
operator||=
name|FLUSH_RC_ACTIVE
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|failed_vnode
operator|=
name|softdep_request_cleanup_flush
argument_list|(
name|mp
argument_list|,
name|ump
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|ump
operator|->
name|um_softdep
operator|->
name|sd_flags
operator|&=
operator|~
name|FLUSH_RC_ACTIVE
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|ump
operator|->
name|softdep_on_worklist
operator|>
literal|0
condition|)
block|{
name|stat_cleanup_retries
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|failed_vnode
condition|)
goto|goto
name|retry
goto|;
block|}
block|}
else|else
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|stat_cleanup_failures
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|time_second
operator|-
name|starttime
operator|>
name|stat_cleanup_high_delay
condition|)
name|stat_cleanup_high_delay
operator|=
name|time_second
operator|-
name|starttime
expr_stmt|;
name|UFS_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scan the vnodes for the specified mount point flushing out any  * vnodes that can be locked without waiting. Finally, try to flush  * the device associated with the mount point if it can be locked  * without waiting.  *  * We return 0 if we were able to lock every vnode in our scan.  * If we had to skip one or more vnodes, we return 1.  */
end_comment

begin_function
specifier|static
name|int
name|softdep_request_cleanup_flush
parameter_list|(
name|mp
parameter_list|,
name|ump
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|,
modifier|*
name|mvp
decl_stmt|;
name|int
name|failed_vnode
decl_stmt|;
name|failed_vnode
operator|=
literal|0
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|MNT_VNODE_FOREACH_ALL
argument_list|(
argument|lvp
argument_list|,
argument|mp
argument_list|,
argument|mvp
argument_list|)
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|lvp
operator|->
name|v_bufobj
operator|.
name|bo_dirty
operator|.
name|bv_hd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|vget
argument_list|(
name|lvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_INTERLOCK
operator||
name|LK_NOWAIT
argument_list|,
name|td
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|failed_vnode
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lvp
operator|->
name|v_vflag
operator|&
name|VV_NOSYNC
condition|)
block|{
comment|/* unlinked */
name|vput
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|ffs_syncvnode
argument_list|(
name|lvp
argument_list|,
name|MNT_NOWAIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
block|}
name|lvp
operator|=
name|ump
operator|->
name|um_devvp
expr_stmt|;
if|if
condition|(
name|vn_lock
argument_list|(
name|lvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_NOWAIT
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VOP_FSYNC
argument_list|(
name|lvp
argument_list|,
name|MNT_NOWAIT
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|lvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|failed_vnode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|softdep_excess_items
parameter_list|(
name|struct
name|ufsmount
modifier|*
name|ump
parameter_list|,
name|int
name|item
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|item
operator|>=
literal|0
operator|&&
name|item
operator|<
name|D_LAST
argument_list|,
operator|(
literal|"item %d"
operator|,
name|item
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dep_current
index|[
name|item
index|]
operator|>
name|max_softdeps
operator|&&
name|ump
operator|->
name|softdep_curdeps
index|[
name|item
index|]
operator|>
name|max_softdeps
operator|/
name|stat_flush_threads
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|schedule_cleanup
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
if|if
condition|(
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_KTHREAD
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|td
operator|->
name|td_proc
operator|->
name|p_flag2
operator|&
name|P2_AST_SU
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No ast is delivered to kernel threads, so nobody 		 * would deref the mp.  Some kernel threads 		 * explicitely check for AST, e.g. NFS daemon does 		 * this in the serving loop. 		 */
return|return;
block|}
if|if
condition|(
name|td
operator|->
name|td_su
operator|!=
name|NULL
condition|)
name|vfs_rel
argument_list|(
name|td
operator|->
name|td_su
argument_list|)
expr_stmt|;
name|vfs_ref
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_su
operator|=
name|mp
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_ASTPENDING
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|softdep_ast_cleanup_proc
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bool
name|req
decl_stmt|;
while|while
condition|(
operator|(
name|mp
operator|=
name|td
operator|->
name|td_su
operator|)
operator|!=
name|NULL
condition|)
block|{
name|td
operator|->
name|td_su
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|vfs_busy
argument_list|(
name|mp
argument_list|,
name|MBF_NOWAIT
argument_list|)
expr_stmt|;
name|vfs_rel
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|ffs_own_mount
argument_list|(
name|mp
argument_list|)
operator|&&
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|req
operator|=
name|false
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|softdep_excess_items
argument_list|(
name|ump
argument_list|,
name|D_INODEDEP
argument_list|)
condition|)
block|{
name|req
operator|=
name|true
expr_stmt|;
name|request_cleanup
argument_list|(
name|mp
argument_list|,
name|FLUSH_INODES
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|softdep_excess_items
argument_list|(
name|ump
argument_list|,
name|D_DIRREM
argument_list|)
condition|)
block|{
name|req
operator|=
name|true
expr_stmt|;
name|request_cleanup
argument_list|(
name|mp
argument_list|,
name|FLUSH_BLOCKS
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|softdep_excess_items
argument_list|(
name|ump
argument_list|,
name|D_NEWBLK
argument_list|)
operator|||
name|softdep_excess_items
argument_list|(
name|ump
argument_list|,
name|D_ALLOCDIRECT
argument_list|)
operator|||
name|softdep_excess_items
argument_list|(
name|ump
argument_list|,
name|D_ALLOCINDIR
argument_list|)
condition|)
block|{
name|error
operator|=
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|req
operator|=
name|true
expr_stmt|;
name|VFS_SYNC
argument_list|(
name|mp
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_KTHREAD
operator|)
operator|!=
literal|0
operator|||
operator|!
name|req
condition|)
break|break;
block|}
block|}
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mp
operator|=
name|td
operator|->
name|td_su
operator|)
operator|!=
name|NULL
condition|)
block|{
name|td
operator|->
name|td_su
operator|=
name|NULL
expr_stmt|;
name|vfs_rel
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * If memory utilization has gotten too high, deliberately slow things  * down and speed up the I/O processing.  */
end_comment

begin_function
specifier|static
name|int
name|request_cleanup
parameter_list|(
name|mp
parameter_list|,
name|resource
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|resource
decl_stmt|;
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * We never hold up the filesystem syncer or buf daemon. 	 */
if|if
condition|(
name|td
operator|->
name|td_pflags
operator|&
operator|(
name|TDP_SOFTDEP
operator||
name|TDP_NORUNNINGBUF
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * First check to see if the work list has gotten backlogged. 	 * If it has, co-opt this process to help clean up two entries. 	 * Because this process may hold inodes locked, we cannot 	 * handle any remove requests that might block on a locked 	 * inode as that could lead to deadlock.  We set TDP_SOFTDEP 	 * to avoid recursively processing the worklist. 	 */
if|if
condition|(
name|ump
operator|->
name|softdep_on_worklist
operator|>
name|max_softdeps
operator|/
literal|10
condition|)
block|{
name|td
operator|->
name|td_pflags
operator||=
name|TDP_SOFTDEP
expr_stmt|;
name|process_worklist_item
argument_list|(
name|mp
argument_list|,
literal|2
argument_list|,
name|LK_NOWAIT
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_SOFTDEP
expr_stmt|;
name|stat_worklist_push
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Next, we attempt to speed up the syncer process. If that 	 * is successful, then we allow the process to continue. 	 */
if|if
condition|(
name|softdep_speedup
argument_list|(
name|ump
argument_list|)
operator|&&
name|resource
operator|!=
name|FLUSH_BLOCKS_WAIT
operator|&&
name|resource
operator|!=
name|FLUSH_INODES_WAIT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If we are resource constrained on inode dependencies, try 	 * flushing some dirty inodes. Otherwise, we are constrained 	 * by file deletions, so try accelerating flushes of directories 	 * with removal dependencies. We would like to do the cleanup 	 * here, but we probably hold an inode locked at this point and  	 * that might deadlock against one that we try to clean. So, 	 * the best that we can do is request the syncer daemon to do 	 * the cleanup for us. 	 */
switch|switch
condition|(
name|resource
condition|)
block|{
case|case
name|FLUSH_INODES
case|:
case|case
name|FLUSH_INODES_WAIT
case|:
name|ACQUIRE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|stat_ino_limit_push
operator|+=
literal|1
expr_stmt|;
name|req_clear_inodedeps
operator|+=
literal|1
expr_stmt|;
name|FREE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|stat_countp
operator|=
operator|&
name|stat_ino_limit_hit
expr_stmt|;
break|break;
case|case
name|FLUSH_BLOCKS
case|:
case|case
name|FLUSH_BLOCKS_WAIT
case|:
name|ACQUIRE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|stat_blk_limit_push
operator|+=
literal|1
expr_stmt|;
name|req_clear_remove
operator|+=
literal|1
expr_stmt|;
name|FREE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|stat_countp
operator|=
operator|&
name|stat_blk_limit_hit
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"request_cleanup: unknown type"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Hopefully the syncer daemon will catch up and awaken us. 	 * We wait at most tickdelay before proceeding in any case. 	 */
name|ACQUIRE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|proc_waiting
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|softdep_callout
argument_list|)
operator|==
name|FALSE
condition|)
name|callout_reset
argument_list|(
operator|&
name|softdep_callout
argument_list|,
name|tickdelay
operator|>
literal|2
condition|?
name|tickdelay
else|:
literal|2
argument_list|,
name|pause_timer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_KTHREAD
operator|)
operator|==
literal|0
condition|)
name|msleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|proc_waiting
argument_list|,
operator|&
name|lk
argument_list|,
name|PPAUSE
argument_list|,
literal|"softupdate"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proc_waiting
operator|-=
literal|1
expr_stmt|;
name|FREE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Awaken processes pausing in request_cleanup and clear proc_waiting  * to indicate that there is no longer a timer running. Pause_timer  * will be called with the global softdep mutex (&lk) locked.  */
end_comment

begin_function
specifier|static
name|void
name|pause_timer
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|GBLLOCK_OWNED
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
comment|/* 	 * The callout_ API has acquired mtx and will hold it around this 	 * function call. 	 */
operator|*
name|stat_countp
operator|+=
name|proc_waiting
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|proc_waiting
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If requested, try removing inode or removal dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|check_clear_deps
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
comment|/* 	 * If we are suspended, it may be because of our using 	 * too many inodedeps, so help clear them out. 	 */
if|if
condition|(
name|MOUNTEDSUJ
argument_list|(
name|mp
argument_list|)
operator|&&
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|softdep_jblocks
operator|->
name|jb_suspended
condition|)
name|clear_inodedeps
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * General requests for cleanup of backed up dependencies 	 */
name|ACQUIRE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|req_clear_inodedeps
condition|)
block|{
name|req_clear_inodedeps
operator|-=
literal|1
expr_stmt|;
name|FREE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|clear_inodedeps
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|proc_waiting
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|req_clear_remove
condition|)
block|{
name|req_clear_remove
operator|-=
literal|1
expr_stmt|;
name|FREE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|clear_remove
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|proc_waiting
argument_list|)
expr_stmt|;
block|}
name|FREE_GBLLOCK
argument_list|(
operator|&
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush out a directory with at least one removal dependency in an effort to  * reduce the number of dirrem, freefile, and freeblks dependency structures.  */
end_comment

begin_function
specifier|static
name|void
name|clear_remove
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
name|struct
name|pagedep_hashhead
modifier|*
name|pagedephd
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cnt
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<=
name|ump
operator|->
name|pagedep_hash_size
condition|;
name|cnt
operator|++
control|)
block|{
name|pagedephd
operator|=
operator|&
name|ump
operator|->
name|pagedep_hashtbl
index|[
name|ump
operator|->
name|pagedep_nextclean
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|ump
operator|->
name|pagedep_nextclean
operator|>
name|ump
operator|->
name|pagedep_hash_size
condition|)
name|ump
operator|->
name|pagedep_nextclean
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pagedep
argument_list|,
argument|pagedephd
argument_list|,
argument|pd_hash
argument_list|)
block|{
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|pagedep
operator|->
name|pd_dirremhd
argument_list|)
condition|)
continue|continue;
name|ino
operator|=
name|pagedep
operator|->
name|pd_ino
expr_stmt|;
if|if
condition|(
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|mp
argument_list|,
name|V_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 			 * Let unmount clear deps 			 */
name|error
operator|=
name|vfs_busy
argument_list|(
name|mp
argument_list|,
name|MBF_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|finish_write
goto|;
name|error
operator|=
name|ffs_vgetf
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|vp
argument_list|,
name|FFSV_FORCEINSMQ
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|softdep_error
argument_list|(
literal|"clear_remove: vget"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|finish_write
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ffs_syncvnode
argument_list|(
name|vp
argument_list|,
name|MNT_NOWAIT
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|softdep_error
argument_list|(
literal|"clear_remove: fsync"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bo
operator|=
operator|&
name|vp
operator|->
name|v_bufobj
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|drain_output
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|finish_write
label|:
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Clear out a block of dirty inodes in an effort to reduce  * the number of inodedep dependency structures.  */
end_comment

begin_function
specifier|static
name|void
name|clear_inodedeps
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
name|struct
name|inodedep_hashhead
modifier|*
name|inodedephd
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cnt
decl_stmt|;
name|ino_t
name|firstino
decl_stmt|,
name|lastino
decl_stmt|,
name|ino
decl_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
name|LOCK_OWNED
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * Pick a random inode dependency to be cleared. 	 * We will then gather up all the inodes in its block  	 * that have dependencies and flush them out. 	 */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<=
name|ump
operator|->
name|inodedep_hash_size
condition|;
name|cnt
operator|++
control|)
block|{
name|inodedephd
operator|=
operator|&
name|ump
operator|->
name|inodedep_hashtbl
index|[
name|ump
operator|->
name|inodedep_nextclean
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|ump
operator|->
name|inodedep_nextclean
operator|>
name|ump
operator|->
name|inodedep_hash_size
condition|)
name|ump
operator|->
name|inodedep_nextclean
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|=
name|LIST_FIRST
argument_list|(
name|inodedephd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|inodedep
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Find the last inode in the block with dependencies. 	 */
name|firstino
operator|=
name|rounddown2
argument_list|(
name|inodedep
operator|->
name|id_ino
argument_list|,
name|INOPB
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|lastino
operator|=
name|firstino
operator|+
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|-
literal|1
init|;
name|lastino
operator|>
name|firstino
condition|;
name|lastino
operator|--
control|)
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|lastino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 	 * Asynchronously push all but the last inode with dependencies. 	 * Synchronously push the last inode with dependencies to ensure 	 * that the inode block gets written to free up the inodedeps. 	 */
for|for
control|(
name|ino
operator|=
name|firstino
init|;
name|ino
operator|<=
name|lastino
condition|;
name|ino
operator|++
control|)
block|{
if|if
condition|(
name|inodedep_lookup
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
operator|&
name|inodedep
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|mp
argument_list|,
name|V_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|error
operator|=
name|vfs_busy
argument_list|(
name|mp
argument_list|,
name|MBF_NOWAIT
argument_list|)
expr_stmt|;
comment|/* Let unmount clear deps */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ffs_vgetf
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|vp
argument_list|,
name|FFSV_FORCEINSMQ
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|softdep_error
argument_list|(
literal|"clear_inodedeps: vget"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return;
block|}
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ino
operator|==
name|lastino
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|ffs_syncvnode
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|softdep_error
argument_list|(
literal|"clear_inodedeps: fsync1"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|ffs_syncvnode
argument_list|(
name|vp
argument_list|,
name|MNT_NOWAIT
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|softdep_error
argument_list|(
literal|"clear_inodedeps: fsync2"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|BO_LOCK
argument_list|(
operator|&
name|vp
operator|->
name|v_bufobj
argument_list|)
expr_stmt|;
name|drain_output
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|BO_UNLOCK
argument_list|(
operator|&
name|vp
operator|->
name|v_bufobj
argument_list|)
expr_stmt|;
block|}
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|softdep_buf_append
parameter_list|(
name|bp
parameter_list|,
name|wkhd
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
name|wkhd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_buf_append called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
name|wkhd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|WORKLIST_REMOVE
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|WORKLIST_INSERT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|,
name|wk
argument_list|)
expr_stmt|;
block|}
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_inode_append
parameter_list|(
name|ip
parameter_list|,
name|cred
parameter_list|,
name|wkhd
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ump
operator|=
name|ITOUMP
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|UFSTOVFS
argument_list|(
name|ump
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_inode_append called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ump
operator|->
name|um_fs
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|ump
operator|->
name|um_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_bsize
argument_list|,
name|cred
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|softdep_freework
argument_list|(
name|wkhd
argument_list|)
expr_stmt|;
return|return;
block|}
name|softdep_buf_append
argument_list|(
name|bp
argument_list|,
name|wkhd
argument_list|)
expr_stmt|;
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|softdep_freework
parameter_list|(
name|wkhd
parameter_list|)
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
name|wkhd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|KASSERT
argument_list|(
name|MOUNTEDSOFTDEP
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"softdep_freework called on non-softdep filesystem"
operator|)
argument_list|)
expr_stmt|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|handle_jwork
argument_list|(
name|wkhd
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function to determine if the buffer has outstanding dependencies  * that will cause a roll-back if the buffer is written. If wantcount  * is set, return number of dependencies, otherwise just yes or no.  */
end_comment

begin_function
specifier|static
name|int
name|softdep_count_dependencies
parameter_list|(
name|bp
parameter_list|,
name|wantcount
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|wantcount
decl_stmt|;
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|bmsafemap
modifier|*
name|bmsafemap
decl_stmt|;
name|struct
name|freework
modifier|*
name|freework
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|indirdep
modifier|*
name|indirdep
decl_stmt|;
name|struct
name|freeblks
modifier|*
name|freeblks
decl_stmt|;
name|struct
name|allocindir
modifier|*
name|aip
decl_stmt|;
name|struct
name|pagedep
modifier|*
name|pagedep
decl_stmt|;
name|struct
name|dirrem
modifier|*
name|dirrem
decl_stmt|;
name|struct
name|newblk
modifier|*
name|newblk
decl_stmt|;
name|struct
name|mkdir
modifier|*
name|mkdir
decl_stmt|;
name|struct
name|diradd
modifier|*
name|dap
decl_stmt|;
name|int
name|i
decl_stmt|,
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|wk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|wk
operator|->
name|wk_mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|wk
argument_list|,
argument|&bp->b_dep
argument_list|,
argument|wk_list
argument_list|)
block|{
switch|switch
condition|(
name|wk
operator|->
name|wk_type
condition|)
block|{
case|case
name|D_INODEDEP
case|:
name|inodedep
operator|=
name|WK_INODEDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
name|DEPCOMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* bitmap allocation dependency */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
condition|)
block|{
comment|/* direct block pointer dependency */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
condition|)
block|{
comment|/* direct block pointer dependency */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|)
condition|)
block|{
comment|/* Add reference dependency. */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
continue|continue;
case|case
name|D_INDIRDEP
case|:
name|indirdep
operator|=
name|WK_INDIRDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|freework
argument_list|,
argument|&indirdep->ir_trunc
argument_list|,
argument|fw_next
argument_list|)
block|{
comment|/* indirect truncation dependency */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
name|LIST_FOREACH
argument_list|(
argument|aip
argument_list|,
argument|&indirdep->ir_deplisthd
argument_list|,
argument|ai_next
argument_list|)
block|{
comment|/* indirect block pointer dependency */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
continue|continue;
case|case
name|D_PAGEDEP
case|:
name|pagedep
operator|=
name|WK_PAGEDEP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|dirrem
argument_list|,
argument|&pagedep->pd_dirremhd
argument_list|,
argument|dm_next
argument_list|)
block|{
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|dirrem
operator|->
name|dm_jremrefhd
argument_list|)
condition|)
block|{
comment|/* Journal remove ref dependency. */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DAHASHSZ
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|dap
argument_list|,
argument|&pagedep->pd_diraddhd[i]
argument_list|,
argument|da_pdlist
argument_list|)
block|{
comment|/* directory entry dependency */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
block|}
continue|continue;
case|case
name|D_BMSAFEMAP
case|:
name|bmsafemap
operator|=
name|WK_BMSAFEMAP
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_jaddrefhd
argument_list|)
condition|)
block|{
comment|/* Add reference dependency. */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|bmsafemap
operator|->
name|sm_jnewblkhd
argument_list|)
condition|)
block|{
comment|/* Allocate block dependency. */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
continue|continue;
case|case
name|D_FREEBLKS
case|:
name|freeblks
operator|=
name|WK_FREEBLKS
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|freeblks
operator|->
name|fb_jblkdephd
argument_list|)
condition|)
block|{
comment|/* Freeblk journal dependency. */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
continue|continue;
case|case
name|D_ALLOCDIRECT
case|:
case|case
name|D_ALLOCINDIR
case|:
name|newblk
operator|=
name|WK_NEWBLK
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|newblk
operator|->
name|nb_jnewblk
condition|)
block|{
comment|/* Journal allocate dependency. */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
continue|continue;
case|case
name|D_MKDIR
case|:
name|mkdir
operator|=
name|WK_MKDIR
argument_list|(
name|wk
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
operator|->
name|md_jaddref
condition|)
block|{
comment|/* Journal reference dependency. */
name|retval
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wantcount
condition|)
goto|goto
name|out
goto|;
block|}
continue|continue;
case|case
name|D_FREEWORK
case|:
case|case
name|D_FREEDEP
case|:
case|case
name|D_JSEGDEP
case|:
case|case
name|D_JSEG
case|:
case|case
name|D_SBDEP
case|:
comment|/* never a dependency on these blocks */
continue|continue;
default|default:
name|panic
argument_list|(
literal|"softdep_count_dependencies: Unexpected type %s"
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|out
label|:
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Acquire exclusive access to a buffer.  * Must be called with a locked mtx parameter.  * Return acquired buffer or NULL on failure.  */
end_comment

begin_function
specifier|static
name|struct
name|buf
modifier|*
name|getdirtybuf
parameter_list|(
name|bp
parameter_list|,
name|lock
parameter_list|,
name|waitfor
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|rwlock
modifier|*
name|lock
decl_stmt|;
name|int
name|waitfor
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_NOWAIT
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|waitfor
operator|!=
name|MNT_WAIT
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|error
operator|=
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_SLEEPFAIL
operator||
name|LK_INTERLOCK
argument_list|,
name|lock
argument_list|)
expr_stmt|;
comment|/* 		 * Even if we successfully acquire bp here, we have dropped 		 * lock, which may violates our guarantee. 		 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|BUF_UNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|!=
name|ENOLCK
condition|)
name|panic
argument_list|(
literal|"getdirtybuf: inconsistent lock: %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_vflags
operator|&
name|BV_BKGRDINPROG
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lock
operator|!=
name|BO_LOCKPTR
argument_list|(
name|bp
operator|->
name|b_bufobj
argument_list|)
operator|&&
name|waitfor
operator|==
name|MNT_WAIT
condition|)
block|{
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bp
operator|->
name|b_bufobj
argument_list|)
expr_stmt|;
name|BUF_UNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_vflags
operator|&
name|BV_BKGRDINPROG
operator|)
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_vflags
operator||=
name|BV_BKGRDWAIT
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|bp
operator|->
name|b_xflags
argument_list|,
name|BO_LOCKPTR
argument_list|(
name|bp
operator|->
name|b_bufobj
argument_list|)
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"getbuf"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|BO_UNLOCK
argument_list|(
name|bp
operator|->
name|b_bufobj
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|BUF_UNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitfor
operator|!=
name|MNT_WAIT
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 		 * The lock argument must be bp->b_vp's mutex in 		 * this case. 		 */
ifdef|#
directive|ifdef
name|DEBUG_VFS_LOCKS
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|->
name|v_type
operator|!=
name|VCHR
condition|)
name|ASSERT_BO_WLOCKED
argument_list|(
name|bp
operator|->
name|b_bufobj
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|b_vflags
operator||=
name|BV_BKGRDWAIT
expr_stmt|;
name|rw_sleep
argument_list|(
operator|&
name|bp
operator|->
name|b_xflags
argument_list|,
name|lock
argument_list|,
name|PRIBIO
argument_list|,
literal|"getbuf"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
block|{
name|BUF_UNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if it is safe to suspend the file system now.  On entry,  * the vnode interlock for devvp should be held.  Return 0 with  * the mount interlock held if the file system can be suspended now,  * otherwise return EAGAIN with the mount interlock held.  */
end_comment

begin_function
name|int
name|softdep_check_suspend
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|vnode
modifier|*
name|devvp
parameter_list|,
name|int
name|softdep_depcnt
parameter_list|,
name|int
name|softdep_accdepcnt
parameter_list|,
name|int
name|secondary_writes
parameter_list|,
name|int
name|secondary_accwrites
parameter_list|)
block|{
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|int
name|error
decl_stmt|,
name|unlinked
decl_stmt|;
name|bo
operator|=
operator|&
name|devvp
operator|->
name|v_bufobj
expr_stmt|;
name|ASSERT_BO_WLOCKED
argument_list|(
name|bo
argument_list|)
expr_stmt|;
comment|/* 	 * If we are not running with soft updates, then we need only 	 * deal with secondary writes as we try to suspend. 	 */
if|if
condition|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
while|while
condition|(
name|mp
operator|->
name|mnt_secondary_writes
operator|!=
literal|0
condition|)
block|{
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|mp
operator|->
name|mnt_secondary_writes
argument_list|,
name|MNT_MTX
argument_list|(
name|mp
argument_list|)
argument_list|,
operator|(
name|PUSER
operator|-
literal|1
operator|)
operator||
name|PDROP
argument_list|,
literal|"secwr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Reasons for needing more work before suspend: 		 * - Dirty buffers on devvp. 		 * - Secondary writes occurred after start of vnode sync loop 		 */
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bo
operator|->
name|bo_numoutput
operator|>
literal|0
operator|||
name|bo
operator|->
name|bo_dirty
operator|.
name|bv_cnt
operator|>
literal|0
operator|||
name|secondary_writes
operator|!=
literal|0
operator|||
name|mp
operator|->
name|mnt_secondary_writes
operator|!=
literal|0
operator|||
name|secondary_accwrites
operator|!=
name|mp
operator|->
name|mnt_secondary_accwrites
condition|)
name|error
operator|=
name|EAGAIN
expr_stmt|;
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If we are running with soft updates, then we need to coordinate 	 * with them as we try to suspend. 	 */
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|TRY_ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
condition|)
block|{
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mnt_secondary_writes
operator|!=
literal|0
condition|)
block|{
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|mp
operator|->
name|mnt_secondary_writes
argument_list|,
name|MNT_MTX
argument_list|(
name|mp
argument_list|)
argument_list|,
operator|(
name|PUSER
operator|-
literal|1
operator|)
operator||
name|PDROP
argument_list|,
literal|"secwr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|unlinked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|MOUNTEDSUJ
argument_list|(
name|mp
argument_list|)
condition|)
block|{
for|for
control|(
name|inodedep
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ump
operator|->
name|softdep_unlinked
argument_list|)
init|;
name|inodedep
operator|!=
name|NULL
condition|;
name|inodedep
operator|=
name|TAILQ_NEXT
argument_list|(
name|inodedep
argument_list|,
name|id_unlinked
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|inodedep
operator|->
name|id_state
operator|&
operator|(
name|UNLINKED
operator||
name|UNLINKLINKS
operator||
name|UNLINKONLIST
operator|)
operator|)
operator|!=
operator|(
name|UNLINKED
operator||
name|UNLINKLINKS
operator||
name|UNLINKONLIST
operator|)
operator|||
operator|!
name|check_inodedep_free
argument_list|(
name|inodedep
argument_list|)
condition|)
continue|continue;
name|unlinked
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Reasons for needing more work before suspend: 	 * - Dirty buffers on devvp. 	 * - Softdep activity occurred after start of vnode sync loop 	 * - Secondary writes occurred after start of vnode sync loop 	 */
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bo
operator|->
name|bo_numoutput
operator|>
literal|0
operator|||
name|bo
operator|->
name|bo_dirty
operator|.
name|bv_cnt
operator|>
literal|0
operator|||
name|softdep_depcnt
operator|!=
name|unlinked
operator|||
name|ump
operator|->
name|softdep_deps
operator|!=
name|unlinked
operator|||
name|softdep_accdepcnt
operator|!=
name|ump
operator|->
name|softdep_accdeps
operator|||
name|secondary_writes
operator|!=
literal|0
operator|||
name|mp
operator|->
name|mnt_secondary_writes
operator|!=
literal|0
operator|||
name|secondary_accwrites
operator|!=
name|mp
operator|->
name|mnt_secondary_accwrites
condition|)
name|error
operator|=
name|EAGAIN
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the number of dependency structures for the file system, both  * the current number and the total number allocated.  These will  * later be used to detect that softdep processing has occurred.  */
end_comment

begin_function
name|void
name|softdep_get_depcounts
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|softdep_depsp
parameter_list|,
name|int
modifier|*
name|softdep_accdepsp
parameter_list|)
block|{
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
if|if
condition|(
name|MOUNTEDSOFTDEP
argument_list|(
name|mp
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|softdep_depsp
operator|=
literal|0
expr_stmt|;
operator|*
name|softdep_accdepsp
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|ump
operator|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ACQUIRE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
operator|*
name|softdep_depsp
operator|=
name|ump
operator|->
name|softdep_deps
expr_stmt|;
operator|*
name|softdep_accdepsp
operator|=
name|ump
operator|->
name|softdep_accdeps
expr_stmt|;
name|FREE_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for pending output on a vnode to complete.  * Must be called with vnode lock and interlock locked.  *  * XXX: Should just be a call to bufobj_wwait().  */
end_comment

begin_function
specifier|static
name|void
name|drain_output
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
name|bo
operator|=
operator|&
name|vp
operator|->
name|v_bufobj
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|vp
argument_list|,
literal|"drain_output"
argument_list|)
expr_stmt|;
name|ASSERT_BO_WLOCKED
argument_list|(
name|bo
argument_list|)
expr_stmt|;
while|while
condition|(
name|bo
operator|->
name|bo_numoutput
condition|)
block|{
name|bo
operator|->
name|bo_flag
operator||=
name|BO_WWAIT
expr_stmt|;
name|msleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|bo
operator|->
name|bo_numoutput
argument_list|,
name|BO_LOCKPTR
argument_list|(
name|bo
argument_list|)
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|,
literal|"drainvp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Called whenever a buffer that is being invalidated or reallocated  * contains dependencies. This should only happen if an I/O error has  * occurred. The routine is called with the buffer locked.  */
end_comment

begin_function
specifier|static
name|void
name|softdep_deallocate_dependencies
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_ioflags
operator|&
name|BIO_ERROR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"softdep_deallocate_dependencies: dangling deps"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|!=
name|NULL
operator|&&
name|bp
operator|->
name|b_vp
operator|->
name|v_mount
operator|!=
name|NULL
condition|)
name|softdep_error
argument_list|(
name|bp
operator|->
name|b_vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
name|bp
operator|->
name|b_error
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"softdep_deallocate_dependencies: "
literal|"got error %d while accessing filesystem\n"
argument_list|,
name|bp
operator|->
name|b_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_error
operator|!=
name|ENXIO
condition|)
name|panic
argument_list|(
literal|"softdep_deallocate_dependencies: unrecovered I/O error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function to handle asynchronous write errors in the filesystem.  */
end_comment

begin_function
specifier|static
name|void
name|softdep_error
parameter_list|(
name|func
parameter_list|,
name|error
parameter_list|)
name|char
modifier|*
name|func
decl_stmt|;
name|int
name|error
decl_stmt|;
block|{
comment|/* XXX should do something better! */
name|printf
argument_list|(
literal|"%s: got error %d while accessing filesystem\n"
argument_list|,
name|func
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function
specifier|static
name|void
name|inodedep_print
parameter_list|(
name|struct
name|inodedep
modifier|*
name|inodedep
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|db_printf
argument_list|(
literal|"%p fs %p st %x ino %jd inoblk %jd delta %jd nlink %jd"
literal|" saveino %p\n"
argument_list|,
name|inodedep
argument_list|,
name|inodedep
operator|->
name|id_fs
argument_list|,
name|inodedep
operator|->
name|id_state
argument_list|,
operator|(
name|intmax_t
operator|)
name|inodedep
operator|->
name|id_ino
argument_list|,
operator|(
name|intmax_t
operator|)
name|fsbtodb
argument_list|(
name|inodedep
operator|->
name|id_fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|inodedep
operator|->
name|id_fs
argument_list|,
name|inodedep
operator|->
name|id_ino
argument_list|)
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|inodedep
operator|->
name|id_nlinkdelta
argument_list|,
operator|(
name|intmax_t
operator|)
name|inodedep
operator|->
name|id_savednlink
argument_list|,
name|inodedep
operator|->
name|id_savedino1
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|==
literal|0
condition|)
return|return;
name|db_printf
argument_list|(
literal|"\tpendinghd %p, bufwait %p, inowait %p, inoreflst %p, "
literal|"mkdiradd %p\n"
argument_list|,
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_pendinghd
argument_list|)
argument_list|,
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_bufwait
argument_list|)
argument_list|,
name|LIST_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inowait
argument_list|)
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoreflst
argument_list|)
argument_list|,
name|inodedep
operator|->
name|id_mkdiradd
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\tinoupdt %p, newinoupdt %p, extupdt %p, newextupdt %p\n"
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_inoupdt
argument_list|)
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newinoupdt
argument_list|)
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_extupdt
argument_list|)
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|inodedep
operator|->
name|id_newextupdt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|inodedep
argument_list|,
argument|db_show_inodedep
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|have_addr
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Address required\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inodedep_print
argument_list|(
operator|(
expr|struct
name|inodedep
operator|*
operator|)
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|inodedeps
argument_list|,
argument|db_show_inodedeps
argument_list|)
end_macro

begin_block
block|{
name|struct
name|inodedep_hashhead
modifier|*
name|inodedephd
decl_stmt|;
name|struct
name|inodedep
modifier|*
name|inodedep
decl_stmt|;
name|struct
name|ufsmount
modifier|*
name|ump
decl_stmt|;
name|int
name|cnt
decl_stmt|;
if|if
condition|(
name|have_addr
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Address required\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ump
operator|=
operator|(
expr|struct
name|ufsmount
operator|*
operator|)
name|addr
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|ump
operator|->
name|inodedep_hash_size
condition|;
name|cnt
operator|++
control|)
block|{
name|inodedephd
operator|=
operator|&
name|ump
operator|->
name|inodedep_hashtbl
index|[
name|cnt
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|inodedep
argument_list|,
argument|inodedephd
argument_list|,
argument|id_hash
argument_list|)
block|{
name|inodedep_print
argument_list|(
name|inodedep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|worklist
argument_list|,
argument|db_show_worklist
argument_list|)
end_macro

begin_block
block|{
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
if|if
condition|(
name|have_addr
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Address required\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|wk
operator|=
operator|(
expr|struct
name|worklist
operator|*
operator|)
name|addr
expr_stmt|;
name|printf
argument_list|(
literal|"worklist: %p type %s state 0x%X\n"
argument_list|,
name|wk
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|,
name|wk
operator|->
name|wk_state
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|workhead
argument_list|,
argument|db_show_workhead
argument_list|)
end_macro

begin_block
block|{
name|struct
name|workhead
modifier|*
name|wkhd
decl_stmt|;
name|struct
name|worklist
modifier|*
name|wk
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|have_addr
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Address required\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|wkhd
operator|=
operator|(
expr|struct
name|workhead
operator|*
operator|)
name|addr
expr_stmt|;
name|wk
operator|=
name|LIST_FIRST
argument_list|(
name|wkhd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
operator|&&
name|wk
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|wk
operator|=
name|LIST_NEXT
argument_list|(
name|wk
argument_list|,
name|wk_list
argument_list|)
control|)
name|db_printf
argument_list|(
literal|"worklist: %p type %s state 0x%X"
argument_list|,
name|wk
argument_list|,
name|TYPENAME
argument_list|(
name|wk
operator|->
name|wk_type
argument_list|)
argument_list|,
name|wk
operator|->
name|wk_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|100
condition|)
name|db_printf
argument_list|(
literal|"workhead overflow"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|mkdirs
argument_list|,
argument|db_show_mkdirs
argument_list|)
end_macro

begin_block
block|{
name|struct
name|mkdirlist
modifier|*
name|mkdirlisthd
decl_stmt|;
name|struct
name|jaddref
modifier|*
name|jaddref
decl_stmt|;
name|struct
name|diradd
modifier|*
name|diradd
decl_stmt|;
name|struct
name|mkdir
modifier|*
name|mkdir
decl_stmt|;
if|if
condition|(
name|have_addr
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Address required\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|mkdirlisthd
operator|=
operator|(
expr|struct
name|mkdirlist
operator|*
operator|)
name|addr
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|mkdir
argument_list|,
argument|mkdirlisthd
argument_list|,
argument|md_mkdirs
argument_list|)
block|{
name|diradd
operator|=
name|mkdir
operator|->
name|md_diradd
expr_stmt|;
name|db_printf
argument_list|(
literal|"mkdir: %p state 0x%X dap %p state 0x%X"
argument_list|,
name|mkdir
argument_list|,
name|mkdir
operator|->
name|md_state
argument_list|,
name|diradd
argument_list|,
name|diradd
operator|->
name|da_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|jaddref
operator|=
name|mkdir
operator|->
name|md_jaddref
operator|)
operator|!=
name|NULL
condition|)
name|db_printf
argument_list|(
literal|" jaddref %p jaddref state 0x%X"
argument_list|,
name|jaddref
argument_list|,
name|jaddref
operator|->
name|ja_state
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* exported to ffs_vfsops.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|db_print_ffs
parameter_list|(
name|struct
name|ufsmount
modifier|*
name|ump
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|db_print_ffs
parameter_list|(
name|struct
name|ufsmount
modifier|*
name|ump
parameter_list|)
block|{
name|db_printf
argument_list|(
literal|"mp %p %s devvp %p fs %p su_wl %d su_deps %d su_req %d\n"
argument_list|,
name|ump
operator|->
name|um_mountp
argument_list|,
name|ump
operator|->
name|um_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
name|ump
operator|->
name|um_devvp
argument_list|,
name|ump
operator|->
name|um_fs
argument_list|,
name|ump
operator|->
name|softdep_on_worklist
argument_list|,
name|ump
operator|->
name|softdep_deps
argument_list|,
name|ump
operator|->
name|softdep_req
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOFTUPDATES */
end_comment

end_unit

